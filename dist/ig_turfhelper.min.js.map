{"version":3,"file":"ig_turfhelper.min.js","sources":["ig_turfhelper.js"],"sourcesContent":["\n/*\n * turf-google-maps\n * version 0.9.2\n * MIT Licensed\n * Felipe Figueroa (amenadiel@gmail.com)\n * https://github.com/HuasoFoundries/turf-google-maps\n */\n \n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.turfHelper = {})));\n}(this, (function (exports) { 'use strict';\n\n  var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  };\n\n  /** @license\n   *\n   *  Copyright (C) 2012 K. Arthur Endsley (kaendsle@mtu.edu)\n   *  Michigan Tech Research Institute (MTRI)\n   *  3600 Green Court, Suite 100, Ann Arbor, MI, 48105\n   *\n   *  This program is free software: you can redistribute it and/or modify\n   *  it under the terms of the GNU General Public License as published by\n   *  the Free Software Foundation, either version 3 of the License, or\n   *  (at your option) any later version.\n   *\n   *  This program is distributed in the hope that it will be useful,\n   *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n   *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   *  GNU General Public License for more details.\n   *\n   *  You should have received a copy of the GNU General Public License\n   *  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n   *\n   */\n  var beginsWith, endsWith;\n  var Wkt = function Wkt(obj) {\n      if (obj instanceof Wkt) return obj;\n      if (!(this instanceof Wkt)) return new Wkt(obj);\n      this._wrapped = obj;\n  };\n  beginsWith = function beginsWith(str, sub) {\n      return str.substring(0, sub.length) === sub;\n  };\n  endsWith = function endsWith(str, sub) {\n      return str.substring(str.length - sub.length) === sub;\n  };\n  Wkt.delimiter = ' ';\n  Wkt.isArray = function (obj) {\n      return !!(obj && obj.constructor === Array);\n  };\n  Wkt.trim = function (str, sub) {\n      sub = sub || ' ';\n      while (beginsWith(str, sub)) {\n          str = str.substring(1);\n      }\n      while (endsWith(str, sub)) {\n          str = str.substring(0, str.length - 1);\n      }\n      return str;\n  };\n  Wkt.Wkt = function (initializer) {\n      this.delimiter = Wkt.delimiter || ' ';\n      this.wrapVertices = true;\n      this.regExes = {\n          'typeStr': /^\\s*(\\w+)\\s*\\(\\s*(.*)\\s*\\)\\s*$/,\n          'spaces': /\\s+|\\+/,\n          'numeric': /-*\\d+(\\.*\\d+)?/,\n          'comma': /\\s*,\\s*/,\n          'parenComma': /\\)\\s*,\\s*\\(/,\n          'coord': /-*\\d+\\.*\\d+ -*\\d+\\.*\\d+/,\n          'doubleParenComma': /\\)\\s*\\)\\s*,\\s*\\(\\s*\\(/,\n          'trimParens': /^\\s*\\(?(.*?)\\)?\\s*$/,\n          'ogcTypes': /^(multi)?(point|line|polygon|box)?(string)?$/i,\n          'crudeJson': /^{.*\"(type|coordinates|geometries|features)\":.*}$/\n      };\n      this.components = undefined;\n      if (initializer && typeof initializer === 'string') {\n          this.read(initializer);\n      } else if (initializer && (typeof initializer === 'undefined' ? 'undefined' : _typeof(initializer)) !== undefined) {\n          this.fromObject(initializer);\n      }\n  };\n  Wkt.Wkt.prototype.isCollection = function () {\n      switch (this.type.slice(0, 5)) {\n          case 'multi':\n              return true;\n          case 'polyg':\n              return true;\n          default:\n              return false;\n      }\n  };\n  Wkt.Wkt.prototype.sameCoords = function (a, b) {\n      return a.x === b.x && a.y === b.y;\n  };\n  Wkt.Wkt.prototype.fromObject = function (obj) {\n      var result;\n      if (obj.hasOwnProperty('type') && obj.hasOwnProperty('coordinates')) {\n          result = this.fromJson(obj);\n      } else {\n          result = this.deconstruct.call(this, obj);\n      }\n      this.components = result.components;\n      this.isRectangle = result.isRectangle || false;\n      this.type = result.type;\n      return this;\n  };\n  Wkt.Wkt.prototype.toObject = function (config) {\n      var obj = this.construct[this.type].call(this, config);\n      if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && !Wkt.isArray(obj)) {\n          obj.properties = this.properties;\n      }\n      return obj;\n  };\n  Wkt.Wkt.prototype.toString = function (config) {\n      return this.write();\n  };\n  Wkt.Wkt.prototype.fromJson = function (obj) {\n      var i, j, k, coords, iring, oring;\n      this.type = obj.type.toLowerCase();\n      this.components = [];\n      if (obj.hasOwnProperty('geometry')) {\n          this.fromJson(obj.geometry);\n          this.properties = obj.properties;\n          return this;\n      }\n      coords = obj.coordinates;\n      if (!Wkt.isArray(coords[0])) {\n          this.components.push({\n              x: coords[0],\n              y: coords[1]\n          });\n      } else {\n          for (i in coords) {\n              if (coords.hasOwnProperty(i)) {\n                  if (!Wkt.isArray(coords[i][0])) {\n                      if (this.type === 'multipoint') {\n                          this.components.push([{\n                              x: coords[i][0],\n                              y: coords[i][1]\n                          }]);\n                      } else {\n                          this.components.push({\n                              x: coords[i][0],\n                              y: coords[i][1]\n                          });\n                      }\n                  } else {\n                      oring = [];\n                      for (j in coords[i]) {\n                          if (coords[i].hasOwnProperty(j)) {\n                              if (!Wkt.isArray(coords[i][j][0])) {\n                                  oring.push({\n                                      x: coords[i][j][0],\n                                      y: coords[i][j][1]\n                                  });\n                              } else {\n                                  iring = [];\n                                  for (k in coords[i][j]) {\n                                      if (coords[i][j].hasOwnProperty(k)) {\n                                          iring.push({\n                                              x: coords[i][j][k][0],\n                                              y: coords[i][j][k][1]\n                                          });\n                                      }\n                                  }\n                                  oring.push(iring);\n                              }\n                          }\n                      }\n                      this.components.push(oring);\n                  }\n              }\n          }\n      }\n      return this;\n  };\n  Wkt.Wkt.prototype.toJson = function () {\n      var cs, json, i, j, k, ring, rings;\n      cs = this.components;\n      json = {\n          coordinates: [],\n          type: function () {\n              var i, type, s;\n              type = this.regExes.ogcTypes.exec(this.type).slice(1);\n              s = [];\n              for (i in type) {\n                  if (type.hasOwnProperty(i)) {\n                      if (type[i] !== undefined) {\n                          s.push(type[i].toLowerCase().slice(0, 1).toUpperCase() + type[i].toLowerCase().slice(1));\n                      }\n                  }\n              }\n              return s;\n          }.call(this).join('')\n      };if (this.type.toLowerCase() === 'box') {\n          json.type = 'Polygon';\n          json.bbox = [];\n          for (i in cs) {\n              if (cs.hasOwnProperty(i)) {\n                  json.bbox = json.bbox.concat([cs[i].x, cs[i].y]);\n              }\n          }\n          json.coordinates = [[[cs[0].x, cs[0].y], [cs[0].x, cs[1].y], [cs[1].x, cs[1].y], [cs[1].x, cs[0].y], [cs[0].x, cs[0].y]]];\n          return json;\n      }\n      for (i in cs) {\n          if (cs.hasOwnProperty(i)) {\n              if (Wkt.isArray(cs[i])) {\n                  rings = [];\n                  for (j in cs[i]) {\n                      if (cs[i].hasOwnProperty(j)) {\n                          if (Wkt.isArray(cs[i][j])) {\n                              ring = [];\n                              for (k in cs[i][j]) {\n                                  if (cs[i][j].hasOwnProperty(k)) {\n                                      ring.push([cs[i][j][k].x, cs[i][j][k].y]);\n                                  }\n                              }\n                              rings.push(ring);\n                          } else {\n                              if (cs[i].length > 1) {\n                                  rings.push([cs[i][j].x, cs[i][j].y]);\n                              } else {\n                                  rings = rings.concat([cs[i][j].x, cs[i][j].y]);\n                              }\n                          }\n                      }\n                  }\n                  json.coordinates.push(rings);\n              } else {\n                  if (cs.length > 1) {\n                      json.coordinates.push([cs[i].x, cs[i].y]);\n                  } else {\n                      json.coordinates = json.coordinates.concat([cs[i].x, cs[i].y]);\n                  }\n              }\n          }\n      }\n      return json;\n  };\n  Wkt.Wkt.prototype.merge = function (wkt) {\n      var prefix = this.type.slice(0, 5);\n      if (this.type !== wkt.type) {\n          if (this.type.slice(5, this.type.length) !== wkt.type) {\n              throw TypeError('The input geometry types must agree or the calling Wkt.Wkt instance must be a multigeometry of the other');\n          }\n      }\n      switch (prefix) {\n          case 'point':\n              this.components = [this.components.concat(wkt.components)];\n              break;\n          case 'multi':\n              this.components = this.components.concat(wkt.type.slice(0, 5) === 'multi' ? wkt.components : [wkt.components]);\n              break;\n          default:\n              this.components = [this.components, wkt.components];\n              break;\n      }\n      if (prefix !== 'multi') {\n          this.type = 'multi' + this.type;\n      }\n      return this;\n  };\n  Wkt.Wkt.prototype.read = function (str) {\n      var matches;\n      matches = this.regExes.typeStr.exec(str);\n      if (matches) {\n          this.type = matches[1].toLowerCase();\n          this.base = matches[2];\n          if (this.ingest[this.type]) {\n              this.components = this.ingest[this.type].apply(this, [this.base]);\n          }\n      } else {\n          if (this.regExes.crudeJson.test(str)) {\n              if ((typeof JSON === 'undefined' ? 'undefined' : _typeof(JSON)) === 'object' && typeof JSON.parse === 'function') {\n                  this.fromJson(JSON.parse(str));\n              } else {\n                  console.log('JSON.parse() is not available; cannot parse GeoJSON strings');\n                  throw {\n                      name: 'JSONError',\n                      message: 'JSON.parse() is not available; cannot parse GeoJSON strings'\n                  };\n              }\n          } else {\n              console.log('Invalid WKT string provided to read() ', str);\n              throw {\n                  name: 'WKTError',\n                  message: 'Invalid WKT string provided to read()'\n              };\n          }\n      }\n      return this;\n  };\n  Wkt.Wkt.prototype.write = function (components) {\n      var i, pieces, data;\n      components = components || this.components;\n      pieces = [];\n      pieces.push(this.type.toUpperCase() + '(');\n      for (i = 0; i < components.length; i += 1) {\n          if (this.isCollection() && i > 0) {\n              pieces.push(',');\n          }\n          if (!this.extract[this.type]) {\n              return null;\n          }\n          data = this.extract[this.type].apply(this, [components[i]]);\n          if (this.isCollection() && this.type !== 'multipoint') {\n              pieces.push('(' + data + ')');\n          } else {\n              pieces.push(data);\n              if (i !== components.length - 1 && this.type !== 'multipoint') {\n                  pieces.push(',');\n              }\n          }\n      }\n      pieces.push(')');\n      return pieces.join('');\n  };\n  Wkt.Wkt.prototype.extract = {\n      point: function point(_point) {\n          return String(_point.x) + this.delimiter + String(_point.y);\n      },\n      multipoint: function multipoint(_multipoint) {\n          var i,\n              parts = [],\n              s;\n          for (i = 0; i < _multipoint.length; i += 1) {\n              s = this.extract.point.apply(this, [_multipoint[i]]);\n              if (this.wrapVertices) {\n                  s = '(' + s + ')';\n              }\n              parts.push(s);\n          }\n          return parts.join(',');\n      },\n      linestring: function linestring(_linestring) {\n          return this.extract.point.apply(this, [_linestring]);\n      },\n      multilinestring: function multilinestring(_multilinestring) {\n          var i,\n              parts = [];\n          if (_multilinestring.length) {\n              for (i = 0; i < _multilinestring.length; i += 1) {\n                  parts.push(this.extract.linestring.apply(this, [_multilinestring[i]]));\n              }\n          } else {\n              parts.push(this.extract.point.apply(this, [_multilinestring]));\n          }\n          return parts.join(',');\n      },\n      polygon: function polygon(_polygon) {\n          return this.extract.multilinestring.apply(this, [_polygon]);\n      },\n      multipolygon: function multipolygon(_multipolygon) {\n          var i,\n              parts = [];\n          for (i = 0; i < _multipolygon.length; i += 1) {\n              parts.push('(' + this.extract.polygon.apply(this, [_multipolygon[i]]) + ')');\n          }\n          return parts.join(',');\n      },\n      box: function box(_box) {\n          return this.extract.linestring.apply(this, [_box]);\n      },\n      geometrycollection: function geometrycollection(str) {\n          console.log('The geometrycollection WKT type is not yet supported.');\n      }\n  };\n  Wkt.Wkt.prototype.ingest = {\n      point: function point(str) {\n          var coords = Wkt.trim(str).split(this.regExes.spaces);\n          return [{\n              x: parseFloat(this.regExes.numeric.exec(coords[0])[0]),\n              y: parseFloat(this.regExes.numeric.exec(coords[1])[0])\n          }];\n      },\n      multipoint: function multipoint(str) {\n          var i, components, points;\n          components = [];\n          points = Wkt.trim(str).split(this.regExes.comma);\n          for (i = 0; i < points.length; i += 1) {\n              components.push(this.ingest.point.apply(this, [points[i]]));\n          }\n          return components;\n      },\n      linestring: function linestring(str) {\n          var i, multipoints, components;\n          multipoints = this.ingest.multipoint.apply(this, [str]);\n          components = [];\n          for (i = 0; i < multipoints.length; i += 1) {\n              components = components.concat(multipoints[i]);\n          }\n          return components;\n      },\n      multilinestring: function multilinestring(str) {\n          var i, components, line, lines;\n          components = [];\n          lines = Wkt.trim(str).split(this.regExes.doubleParenComma);\n          if (lines.length === 1) {\n              lines = Wkt.trim(str).split(this.regExes.parenComma);\n          }\n          for (i = 0; i < lines.length; i += 1) {\n              line = lines[i].replace(this.regExes.trimParens, '$1');\n              components.push(this.ingest.linestring.apply(this, [line]));\n          }\n          return components;\n      },\n      polygon: function polygon(str) {\n          var i, j, components, subcomponents, ring, rings;\n          rings = Wkt.trim(str).split(this.regExes.parenComma);\n          components = [];\n          for (i = 0; i < rings.length; i += 1) {\n              ring = rings[i].replace(this.regExes.trimParens, '$1').split(this.regExes.comma);\n              subcomponents = [];\n              for (j = 0; j < ring.length; j += 1) {\n                  var split = ring[j].split(this.regExes.spaces);\n                  if (split.length > 2) {\n                      split = split.filter(function (n) {\n                          return n != \"\";\n                      });\n                  }\n                  if (split.length === 2) {\n                      var x_cord = split[0];\n                      var y_cord = split[1];\n                      subcomponents.push({\n                          x: parseFloat(x_cord),\n                          y: parseFloat(y_cord)\n                      });\n                  }\n              }\n              components.push(subcomponents);\n          }\n          return components;\n      },\n      box: function box(str) {\n          var i, multipoints, components;\n          multipoints = this.ingest.multipoint.apply(this, [str]);\n          components = [];\n          for (i = 0; i < multipoints.length; i += 1) {\n              components = components.concat(multipoints[i]);\n          }\n          return components;\n      },\n      multipolygon: function multipolygon(str) {\n          var i, components, polygon, polygons;\n          components = [];\n          polygons = Wkt.trim(str).split(this.regExes.doubleParenComma);\n          for (i = 0; i < polygons.length; i += 1) {\n              polygon = polygons[i].replace(this.regExes.trimParens, '$1');\n              components.push(this.ingest.polygon.apply(this, [polygon]));\n          }\n          return components;\n      },\n      geometrycollection: function geometrycollection(str) {\n          console.log('The geometrycollection WKT type is not yet supported.');\n      }\n  };\n  Wkt.Wkt.prototype.isRectangle = false;\n  Wkt.Wkt.prototype.construct = {\n      point: function point(config, component) {\n          var c = component || this.components;\n          config = config || {\n              optimized: true\n          };\n          config.position = new google.maps.LatLng(c[0].y, c[0].x);\n          return new google.maps.Marker(config);\n      },\n      multipoint: function multipoint(config) {\n          var i, c, arr;\n          c = this.components;\n          config = config || {};\n          arr = [];\n          for (i = 0; i < c.length; i += 1) {\n              arr.push(this.construct.point(config, c[i]));\n          }\n          return arr;\n      },\n      linestring: function linestring(config, component) {\n          var i, c;\n          c = component || this.components;\n          config = config || {\n              editable: false\n          };\n          config.path = [];\n          for (i = 0; i < c.length; i += 1) {\n              config.path.push(new google.maps.LatLng(c[i].y, c[i].x));\n          }\n          return new google.maps.Polyline(config);\n      },\n      multilinestring: function multilinestring(config) {\n          var i, c, arr;\n          c = this.components;\n          config = config || {\n              editable: false\n          };\n          config.path = [];\n          arr = [];\n          for (i = 0; i < c.length; i += 1) {\n              arr.push(this.construct.linestring(config, c[i]));\n          }\n          return arr;\n      },\n      box: function box(config, component) {\n          var c = component || this.components;\n          config = config || {};\n          config.bounds = new google.maps.LatLngBounds(new google.maps.LatLng(c[0].y, c[0].x), new google.maps.LatLng(c[1].y, c[1].x));\n          return new google.maps.Rectangle(config);\n      },\n      polygon: function polygon(config, component) {\n          var j, k, c, rings, verts;\n          c = component || this.components;\n          config = config || {\n              editable: false\n          };\n          config.paths = [];\n          rings = [];\n          for (j = 0; j < c.length; j += 1) {\n              verts = [];\n              for (k = 0; k < c[j].length - 1; k += 1) {\n                  verts.push(new google.maps.LatLng(c[j][k].y, c[j][k].x));\n              }\n              if (j !== 0) {\n                  if (config.reverseInnerPolygons === null || config.reverseInnerPolygons) {\n                      verts.reverse();\n                  }\n              }\n              rings.push(verts);\n          }\n          config.paths = config.paths.concat(rings);\n          if (this.isRectangle) {\n              return function () {\n                  var bounds, v;\n                  bounds = new google.maps.LatLngBounds();\n                  for (v in rings[0]) {\n                      if (rings[0].hasOwnProperty(v)) {\n                          bounds.extend(rings[0][v]);\n                      }\n                  }\n                  return new google.maps.Rectangle({\n                      bounds: bounds\n                  });\n              }();\n          } else {\n              return new google.maps.Polygon(config);\n          }\n      },\n      multipolygon: function multipolygon(config) {\n          var i, c, arr;\n          c = this.components;\n          config = config || {\n              editable: false\n          };\n          config.path = [];\n          arr = [];\n          for (i = 0; i < c.length; i += 1) {\n              arr.push(this.construct.polygon(config, c[i]));\n          }\n          return arr;\n      }\n  };\n  Wkt.Wkt.prototype.deconstruct = function (obj, multiFlag) {\n      var features, i, j, verts, rings, sign, tmp, response, lat, lng, vertex, ring;\n      var polygons, polygon, k, linestring, linestrings;\n      if (google.maps.geometry) {\n          sign = google.maps.geometry.spherical.computeSignedArea;\n      }\n      if (obj.constructor === google.maps.LatLng) {\n          response = {\n              type: 'point',\n              components: [{\n                  x: obj.lng(),\n                  y: obj.lat()\n              }]\n          };\n          return response;\n      }\n      if (obj.constructor === google.maps.Point) {\n          response = {\n              type: 'point',\n              components: [{\n                  x: obj.x,\n                  y: obj.y\n              }]\n          };\n          return response;\n      }\n      if (obj.constructor === google.maps.Marker) {\n          response = {\n              type: 'point',\n              components: [{\n                  x: obj.getPosition().lng(),\n                  y: obj.getPosition().lat()\n              }]\n          };\n          return response;\n      }\n      if (obj.constructor === google.maps.Polyline) {\n          verts = [];\n          for (i = 0; i < obj.getPath().length; i += 1) {\n              tmp = obj.getPath().getAt(i);\n              verts.push({\n                  x: tmp.lng(),\n                  y: tmp.lat()\n              });\n          }\n          response = {\n              type: 'linestring',\n              components: verts\n          };\n          return response;\n      }\n      if (obj.constructor === google.maps.Polygon) {\n          rings = [];\n          if (multiFlag === undefined) {\n              multiFlag = function () {\n                  var areas, l;\n                  l = obj.getPaths().length;\n                  if (l <= 1) {\n                      return false;\n                  }\n                  if (l === 2) {\n                      if (sign(obj.getPaths().getAt(0)) * sign(obj.getPaths().getAt(1)) < 0) {\n                          return false;\n                      }\n                      return true;\n                  }\n                  areas = obj.getPaths().getArray().map(function (k) {\n                      return sign(k) / Math.abs(sign(k));\n                  });\n                  if (areas.indexOf(areas[0]) !== areas.lastIndexOf(areas[0])) {\n                      multiFlag = true;\n                      return true;\n                  }\n                  return false;\n              }();\n          }\n          for (i = 0; i < obj.getPaths().length; i += 1) {\n              tmp = obj.getPaths().getAt(i);\n              verts = [];\n              for (j = 0; j < obj.getPaths().getAt(i).length; j += 1) {\n                  verts.push({\n                      x: tmp.getAt(j).lng(),\n                      y: tmp.getAt(j).lat()\n                  });\n              }\n              if (!tmp.getAt(tmp.length - 1).equals(tmp.getAt(0))) {\n                  if (i % 2 !== 0) {\n                      verts.unshift({\n                          x: tmp.getAt(tmp.length - 1).lng(),\n                          y: tmp.getAt(tmp.length - 1).lat()\n                      });\n                  } else {\n                      verts.push({\n                          x: tmp.getAt(0).lng(),\n                          y: tmp.getAt(0).lat()\n                      });\n                  }\n              }\n              if (obj.getPaths().length > 1 && i > 0) {\n                  if (sign(obj.getPaths().getAt(i)) > 0 && sign(obj.getPaths().getAt(i - 1)) > 0 || sign(obj.getPaths().getAt(i)) < 0 && sign(obj.getPaths().getAt(i - 1)) < 0 && !multiFlag) {\n                      verts = [verts];\n                  }\n              }\n              if (i % 2 !== 0) {\n                  verts.reverse();\n              }\n              rings.push(verts);\n          }\n          response = {\n              type: multiFlag ? 'multipolygon' : 'polygon',\n              components: rings\n          };\n          return response;\n      }\n      if (obj.constructor === google.maps.Circle) {\n          var point = obj.getCenter();\n          var radius = obj.getRadius();\n          verts = [];\n          var d2r = Math.PI / 180;\n          var r2d = 180 / Math.PI;\n          radius = radius / 1609;\n          var earthsradius = 3963;\n          var num_seg = 32;\n          var rlat = radius / earthsradius * r2d;\n          var rlng = rlat / Math.cos(point.lat() * d2r);\n          for (var n = 0; n <= num_seg; n++) {\n              var theta = Math.PI * (n / (num_seg / 2));\n              lng = point.lng() + rlng * Math.cos(theta);\n              lat = point.lat() + rlat * Math.sin(theta);\n              verts.push({\n                  x: lng,\n                  y: lat\n              });\n          }\n          response = {\n              type: 'polygon',\n              components: [verts]\n          };\n          return response;\n      }\n      if (obj.constructor === google.maps.LatLngBounds) {\n          tmp = obj;\n          verts = [];\n          verts.push({\n              x: tmp.getSouthWest().lng(),\n              y: tmp.getNorthEast().lat()\n          });\n          verts.push({\n              x: tmp.getNorthEast().lng(),\n              y: tmp.getNorthEast().lat()\n          });\n          verts.push({\n              x: tmp.getNorthEast().lng(),\n              y: tmp.getSouthWest().lat()\n          });\n          verts.push({\n              x: tmp.getSouthWest().lng(),\n              y: tmp.getSouthWest().lat()\n          });\n          verts.push({\n              x: tmp.getSouthWest().lng(),\n              y: tmp.getNorthEast().lat()\n          });\n          response = {\n              type: 'polygon',\n              isRectangle: true,\n              components: [verts]\n          };\n          return response;\n      }\n      if (obj.constructor === google.maps.Rectangle) {\n          tmp = obj.getBounds();\n          verts = [];\n          verts.push({\n              x: tmp.getSouthWest().lng(),\n              y: tmp.getNorthEast().lat()\n          });\n          verts.push({\n              x: tmp.getNorthEast().lng(),\n              y: tmp.getNorthEast().lat()\n          });\n          verts.push({\n              x: tmp.getNorthEast().lng(),\n              y: tmp.getSouthWest().lat()\n          });\n          verts.push({\n              x: tmp.getSouthWest().lng(),\n              y: tmp.getSouthWest().lat()\n          });\n          verts.push({\n              x: tmp.getSouthWest().lng(),\n              y: tmp.getNorthEast().lat()\n          });\n          response = {\n              type: 'polygon',\n              isRectangle: true,\n              components: [verts]\n          };\n          return response;\n      }\n      if (obj.constructor === google.maps.Data.Feature) {\n          return this.deconstruct.call(this, obj.getGeometry());\n      }\n      if (obj.constructor === google.maps.Data.Point) {\n          response = {\n              type: 'point',\n              components: [{\n                  x: obj.get().lng(),\n                  y: obj.get().lat()\n              }]\n          };\n          return response;\n      }\n      if (obj.constructor === google.maps.Data.LineString) {\n          verts = [];\n          for (i = 0; i < obj.getLength(); i += 1) {\n              vertex = obj.getAt(i);\n              verts.push({\n                  x: vertex.lng(),\n                  y: vertex.lat()\n              });\n          }\n          response = {\n              type: 'linestring',\n              components: verts\n          };\n          return response;\n      }\n      if (obj.constructor === google.maps.Data.Polygon) {\n          rings = [];\n          for (i = 0; i < obj.getLength(); i += 1) {\n              ring = obj.getAt(i);\n              verts = [];\n              for (j = 0; j < ring.getLength(); j += 1) {\n                  vertex = ring.getAt(j);\n                  verts.push({\n                      x: vertex.lng(),\n                      y: vertex.lat()\n                  });\n              }\n              verts.push({\n                  x: ring.getAt(0).lng(),\n                  y: ring.getAt(0).lat()\n              });\n              rings.push(verts);\n          }\n          response = {\n              type: 'polygon',\n              components: rings\n          };\n          return response;\n      }\n      if (obj.constructor === google.maps.Data.MultiPoint) {\n          verts = [];\n          for (i = 0; i < obj.getLength(); i += 1) {\n              vertex = obj.getAt(i);\n              verts.push([{\n                  x: vertex.lng(),\n                  y: vertex.lat()\n              }]);\n          }\n          response = {\n              type: 'multipoint',\n              components: verts\n          };\n          return response;\n      }\n      if (obj.constructor === google.maps.Data.MultiLineString) {\n          linestrings = [];\n          for (i = 0; i < obj.getLength(); i += 1) {\n              verts = [];\n              linestring = obj.getAt(i);\n              for (j = 0; j < linestring.getLength(); j += 1) {\n                  vertex = linestring.getAt(j);\n                  verts.push({\n                      x: vertex.lng(),\n                      y: vertex.lat()\n                  });\n              }\n              linestrings.push(verts);\n          }\n          response = {\n              type: 'multilinestring',\n              components: linestrings\n          };\n          return response;\n      }\n      if (obj.constructor === google.maps.Data.MultiPolygon) {\n          polygons = [];\n          for (k = 0; k < obj.getLength(); k += 1) {\n              polygon = obj.getAt(k);\n              rings = [];\n              for (i = 0; i < polygon.getLength(); i += 1) {\n                  ring = polygon.getAt(i);\n                  verts = [];\n                  for (j = 0; j < ring.getLength(); j += 1) {\n                      vertex = ring.getAt(j);\n                      verts.push({\n                          x: vertex.lng(),\n                          y: vertex.lat()\n                      });\n                  }\n                  verts.push({\n                      x: ring.getAt(0).lng(),\n                      y: ring.getAt(0).lat()\n                  });\n                  rings.push(verts);\n              }\n              polygons.push(rings);\n          }\n          response = {\n              type: 'multipolygon',\n              components: polygons\n          };\n          return response;\n      }\n      if (obj.constructor === google.maps.Data.GeometryCollection) {\n          var objects = [];\n          for (k = 0; k < obj.getLength(); k += 1) {\n              var object = obj.getAt(k);\n              objects.push(this.deconstruct.call(this, object));\n          }\n          response = {\n              type: 'geometrycollection',\n              components: objects\n          };\n          return response;\n      }\n      if (Wkt.isArray(obj)) {\n          features = [];\n          for (i = 0; i < obj.length; i += 1) {\n              features.push(this.deconstruct.call(this, obj[i], true));\n          }\n          response = {\n              type: function () {\n                  var k,\n                      type = obj[0].constructor;\n                  for (k = 0; k < obj.length; k += 1) {\n                      if (obj[k].constructor !== type) {\n                          return 'geometrycollection';\n                      }\n                  }\n                  switch (type) {\n                      case google.maps.Marker:\n                          return 'multipoint';\n                      case google.maps.Polyline:\n                          return 'multilinestring';\n                      case google.maps.Polygon:\n                          return 'multipolygon';\n                      default:\n                          return 'geometrycollection';\n                  }\n              }(),\n              components: function () {\n                  var i, comps;\n                  comps = [];\n                  for (i = 0; i < features.length; i += 1) {\n                      if (features[i].components) {\n                          comps.push(features[i].components);\n                      }\n                  }\n                  return {\n                      comps: comps\n                  };\n              }()\n          };\n          response.components = response.components.comps;\n          return response;\n      }\n      console.warn('The passed object does not have any recognizable properties.');\n  };\n  function Wicket$1() {\n      return new Wkt.Wkt();\n  }\n\n  function arrayMap(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        result = Array(length);\n    while (++index < length) {\n      result[index] = iteratee(array[index], index, array);\n    }\n    return result;\n  }\n\n  function listCacheClear() {\n    this.__data__ = [];\n    this.size = 0;\n  }\n\n  function eq(value, other) {\n    return value === other || value !== value && other !== other;\n  }\n\n  function assocIndexOf(array, key) {\n    var length = array.length;\n    while (length--) {\n      if (eq(array[length][0], key)) {\n        return length;\n      }\n    }\n    return -1;\n  }\n\n  var arrayProto = Array.prototype;\n  var splice = arrayProto.splice;\n  function listCacheDelete(key) {\n    var data = this.__data__,\n        index = assocIndexOf(data, key);\n    if (index < 0) {\n      return false;\n    }\n    var lastIndex = data.length - 1;\n    if (index == lastIndex) {\n      data.pop();\n    } else {\n      splice.call(data, index, 1);\n    }\n    --this.size;\n    return true;\n  }\n\n  function listCacheGet(key) {\n    var data = this.__data__,\n        index = assocIndexOf(data, key);\n    return index < 0 ? undefined : data[index][1];\n  }\n\n  function listCacheHas(key) {\n    return assocIndexOf(this.__data__, key) > -1;\n  }\n\n  function listCacheSet(key, value) {\n    var data = this.__data__,\n        index = assocIndexOf(data, key);\n    if (index < 0) {\n      ++this.size;\n      data.push([key, value]);\n    } else {\n      data[index][1] = value;\n    }\n    return this;\n  }\n\n  function ListCache(entries) {\n    var index = -1,\n        length = entries == null ? 0 : entries.length;\n    this.clear();\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  }\n  ListCache.prototype.clear = listCacheClear;\n  ListCache.prototype['delete'] = listCacheDelete;\n  ListCache.prototype.get = listCacheGet;\n  ListCache.prototype.has = listCacheHas;\n  ListCache.prototype.set = listCacheSet;\n\n  function stackClear() {\n    this.__data__ = new ListCache();\n    this.size = 0;\n  }\n\n  function stackDelete(key) {\n    var data = this.__data__,\n        result = data['delete'](key);\n    this.size = data.size;\n    return result;\n  }\n\n  function stackGet(key) {\n    return this.__data__.get(key);\n  }\n\n  function stackHas(key) {\n    return this.__data__.has(key);\n  }\n\n  var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global && global.Object === Object && global;\n\n  var freeSelf = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self && self.Object === Object && self;\n  var root = freeGlobal || freeSelf || Function('return this')();\n\n  var _Symbol = root.Symbol;\n\n  var objectProto = Object.prototype;\n  var hasOwnProperty = objectProto.hasOwnProperty;\n  var nativeObjectToString = objectProto.toString;\n  var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;\n  function getRawTag(value) {\n    var isOwn = hasOwnProperty.call(value, symToStringTag),\n        tag = value[symToStringTag];\n    try {\n      value[symToStringTag] = undefined;\n      var unmasked = true;\n    } catch (e) {}\n    var result = nativeObjectToString.call(value);\n    if (unmasked) {\n      if (isOwn) {\n        value[symToStringTag] = tag;\n      } else {\n        delete value[symToStringTag];\n      }\n    }\n    return result;\n  }\n\n  var objectProto$1 = Object.prototype;\n  var nativeObjectToString$1 = objectProto$1.toString;\n  function objectToString(value) {\n    return nativeObjectToString$1.call(value);\n  }\n\n  var nullTag = '[object Null]',\n      undefinedTag = '[object Undefined]';\n  var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;\n  function baseGetTag(value) {\n    if (value == null) {\n      return value === undefined ? undefinedTag : nullTag;\n    }\n    return symToStringTag$1 && symToStringTag$1 in Object(value) ? getRawTag(value) : objectToString(value);\n  }\n\n  function isObject(value) {\n    var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);\n    return value != null && (type == 'object' || type == 'function');\n  }\n\n  var asyncTag = '[object AsyncFunction]',\n      funcTag = '[object Function]',\n      genTag = '[object GeneratorFunction]',\n      proxyTag = '[object Proxy]';\n  function isFunction(value) {\n    if (!isObject(value)) {\n      return false;\n    }\n    var tag = baseGetTag(value);\n    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n  }\n\n  var coreJsData = root['__core-js_shared__'];\n\n  var maskSrcKey = function () {\n    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n    return uid ? 'Symbol(src)_1.' + uid : '';\n  }();\n  function isMasked(func) {\n    return !!maskSrcKey && maskSrcKey in func;\n  }\n\n  var funcProto = Function.prototype;\n  var funcToString = funcProto.toString;\n  function toSource(func) {\n    if (func != null) {\n      try {\n        return funcToString.call(func);\n      } catch (e) {}\n      try {\n        return func + '';\n      } catch (e) {}\n    }\n    return '';\n  }\n\n  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n  var funcProto$1 = Function.prototype,\n      objectProto$2 = Object.prototype;\n  var funcToString$1 = funcProto$1.toString;\n  var hasOwnProperty$1 = objectProto$2.hasOwnProperty;\n  var reIsNative = RegExp('^' + funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\\\$&').replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$');\n  function baseIsNative(value) {\n    if (!isObject(value) || isMasked(value)) {\n      return false;\n    }\n    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n    return pattern.test(toSource(value));\n  }\n\n  function getValue(object, key) {\n    return object == null ? undefined : object[key];\n  }\n\n  function getNative(object, key) {\n    var value = getValue(object, key);\n    return baseIsNative(value) ? value : undefined;\n  }\n\n  var Map$1 = getNative(root, 'Map');\n\n  var nativeCreate = getNative(Object, 'create');\n\n  function hashClear() {\n    this.__data__ = nativeCreate ? nativeCreate(null) : {};\n    this.size = 0;\n  }\n\n  function hashDelete(key) {\n    var result = this.has(key) && delete this.__data__[key];\n    this.size -= result ? 1 : 0;\n    return result;\n  }\n\n  var HASH_UNDEFINED = '__lodash_hash_undefined__';\n  var objectProto$3 = Object.prototype;\n  var hasOwnProperty$2 = objectProto$3.hasOwnProperty;\n  function hashGet(key) {\n    var data = this.__data__;\n    if (nativeCreate) {\n      var result = data[key];\n      return result === HASH_UNDEFINED ? undefined : result;\n    }\n    return hasOwnProperty$2.call(data, key) ? data[key] : undefined;\n  }\n\n  var objectProto$4 = Object.prototype;\n  var hasOwnProperty$3 = objectProto$4.hasOwnProperty;\n  function hashHas(key) {\n    var data = this.__data__;\n    return nativeCreate ? data[key] !== undefined : hasOwnProperty$3.call(data, key);\n  }\n\n  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';\n  function hashSet(key, value) {\n    var data = this.__data__;\n    this.size += this.has(key) ? 0 : 1;\n    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED$1 : value;\n    return this;\n  }\n\n  function Hash(entries) {\n    var index = -1,\n        length = entries == null ? 0 : entries.length;\n    this.clear();\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  }\n  Hash.prototype.clear = hashClear;\n  Hash.prototype['delete'] = hashDelete;\n  Hash.prototype.get = hashGet;\n  Hash.prototype.has = hashHas;\n  Hash.prototype.set = hashSet;\n\n  function mapCacheClear() {\n    this.size = 0;\n    this.__data__ = {\n      'hash': new Hash(),\n      'map': new (Map$1 || ListCache)(),\n      'string': new Hash()\n    };\n  }\n\n  function isKeyable(value) {\n    var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);\n    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;\n  }\n\n  function getMapData(map, key) {\n    var data = map.__data__;\n    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;\n  }\n\n  function mapCacheDelete(key) {\n    var result = getMapData(this, key)['delete'](key);\n    this.size -= result ? 1 : 0;\n    return result;\n  }\n\n  function mapCacheGet(key) {\n    return getMapData(this, key).get(key);\n  }\n\n  function mapCacheHas(key) {\n    return getMapData(this, key).has(key);\n  }\n\n  function mapCacheSet(key, value) {\n    var data = getMapData(this, key),\n        size = data.size;\n    data.set(key, value);\n    this.size += data.size == size ? 0 : 1;\n    return this;\n  }\n\n  function MapCache(entries) {\n    var index = -1,\n        length = entries == null ? 0 : entries.length;\n    this.clear();\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  }\n  MapCache.prototype.clear = mapCacheClear;\n  MapCache.prototype['delete'] = mapCacheDelete;\n  MapCache.prototype.get = mapCacheGet;\n  MapCache.prototype.has = mapCacheHas;\n  MapCache.prototype.set = mapCacheSet;\n\n  var LARGE_ARRAY_SIZE = 200;\n  function stackSet(key, value) {\n    var data = this.__data__;\n    if (data instanceof ListCache) {\n      var pairs = data.__data__;\n      if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {\n        pairs.push([key, value]);\n        this.size = ++data.size;\n        return this;\n      }\n      data = this.__data__ = new MapCache(pairs);\n    }\n    data.set(key, value);\n    this.size = data.size;\n    return this;\n  }\n\n  function Stack(entries) {\n    var data = this.__data__ = new ListCache(entries);\n    this.size = data.size;\n  }\n  Stack.prototype.clear = stackClear;\n  Stack.prototype['delete'] = stackDelete;\n  Stack.prototype.get = stackGet;\n  Stack.prototype.has = stackHas;\n  Stack.prototype.set = stackSet;\n\n  var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';\n  function setCacheAdd(value) {\n    this.__data__.set(value, HASH_UNDEFINED$2);\n    return this;\n  }\n\n  function setCacheHas(value) {\n    return this.__data__.has(value);\n  }\n\n  function SetCache(values) {\n    var index = -1,\n        length = values == null ? 0 : values.length;\n    this.__data__ = new MapCache();\n    while (++index < length) {\n      this.add(values[index]);\n    }\n  }\n  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\n  SetCache.prototype.has = setCacheHas;\n\n  function arraySome(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n    while (++index < length) {\n      if (predicate(array[index], index, array)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function cacheHas(cache, key) {\n    return cache.has(key);\n  }\n\n  var COMPARE_PARTIAL_FLAG = 1,\n      COMPARE_UNORDERED_FLAG = 2;\n  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n        arrLength = array.length,\n        othLength = other.length;\n    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n      return false;\n    }\n    var stacked = stack.get(array);\n    if (stacked && stack.get(other)) {\n      return stacked == other;\n    }\n    var index = -1,\n        result = true,\n        seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;\n    stack.set(array, other);\n    stack.set(other, array);\n    while (++index < arrLength) {\n      var arrValue = array[index],\n          othValue = other[index];\n      if (customizer) {\n        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);\n      }\n      if (compared !== undefined) {\n        if (compared) {\n          continue;\n        }\n        result = false;\n        break;\n      }\n      if (seen) {\n        if (!arraySome(other, function (othValue, othIndex) {\n          if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n            return seen.push(othIndex);\n          }\n        })) {\n          result = false;\n          break;\n        }\n      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n        result = false;\n        break;\n      }\n    }\n    stack['delete'](array);\n    stack['delete'](other);\n    return result;\n  }\n\n  var Uint8Array = root.Uint8Array;\n\n  function mapToArray(map) {\n    var index = -1,\n        result = Array(map.size);\n    map.forEach(function (value, key) {\n      result[++index] = [key, value];\n    });\n    return result;\n  }\n\n  function setToArray(set) {\n    var index = -1,\n        result = Array(set.size);\n    set.forEach(function (value) {\n      result[++index] = value;\n    });\n    return result;\n  }\n\n  var COMPARE_PARTIAL_FLAG$1 = 1,\n      COMPARE_UNORDERED_FLAG$1 = 2;\n  var boolTag = '[object Boolean]',\n      dateTag = '[object Date]',\n      errorTag = '[object Error]',\n      mapTag = '[object Map]',\n      numberTag = '[object Number]',\n      regexpTag = '[object RegExp]',\n      setTag = '[object Set]',\n      stringTag = '[object String]',\n      symbolTag = '[object Symbol]';\n  var arrayBufferTag = '[object ArrayBuffer]',\n      dataViewTag = '[object DataView]';\n  var symbolProto = _Symbol ? _Symbol.prototype : undefined,\n      symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n    switch (tag) {\n      case dataViewTag:\n        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {\n          return false;\n        }\n        object = object.buffer;\n        other = other.buffer;\n      case arrayBufferTag:\n        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n          return false;\n        }\n        return true;\n      case boolTag:\n      case dateTag:\n      case numberTag:\n        return eq(+object, +other);\n      case errorTag:\n        return object.name == other.name && object.message == other.message;\n      case regexpTag:\n      case stringTag:\n        return object == other + '';\n      case mapTag:\n        var convert = mapToArray;\n      case setTag:\n        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;\n        convert || (convert = setToArray);\n        if (object.size != other.size && !isPartial) {\n          return false;\n        }\n        var stacked = stack.get(object);\n        if (stacked) {\n          return stacked == other;\n        }\n        bitmask |= COMPARE_UNORDERED_FLAG$1;\n        stack.set(object, other);\n        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n        stack['delete'](object);\n        return result;\n      case symbolTag:\n        if (symbolValueOf) {\n          return symbolValueOf.call(object) == symbolValueOf.call(other);\n        }\n    }\n    return false;\n  }\n\n  function arrayPush(array, values) {\n    var index = -1,\n        length = values.length,\n        offset = array.length;\n    while (++index < length) {\n      array[offset + index] = values[index];\n    }\n    return array;\n  }\n\n  var isArray = Array.isArray;\n\n  function baseGetAllKeys(object, keysFunc, symbolsFunc) {\n    var result = keysFunc(object);\n    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n  }\n\n  function arrayFilter(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        resIndex = 0,\n        result = [];\n    while (++index < length) {\n      var value = array[index];\n      if (predicate(value, index, array)) {\n        result[resIndex++] = value;\n      }\n    }\n    return result;\n  }\n\n  function stubArray() {\n    return [];\n  }\n\n  var objectProto$5 = Object.prototype;\n  var propertyIsEnumerable = objectProto$5.propertyIsEnumerable;\n  var nativeGetSymbols = Object.getOwnPropertySymbols;\n  var getSymbols = !nativeGetSymbols ? stubArray : function (object) {\n    if (object == null) {\n      return [];\n    }\n    object = Object(object);\n    return arrayFilter(nativeGetSymbols(object), function (symbol) {\n      return propertyIsEnumerable.call(object, symbol);\n    });\n  };\n\n  function baseTimes(n, iteratee) {\n    var index = -1,\n        result = Array(n);\n    while (++index < n) {\n      result[index] = iteratee(index);\n    }\n    return result;\n  }\n\n  function isObjectLike(value) {\n    return value != null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object';\n  }\n\n  var argsTag = '[object Arguments]';\n  function baseIsArguments(value) {\n    return isObjectLike(value) && baseGetTag(value) == argsTag;\n  }\n\n  var objectProto$6 = Object.prototype;\n  var hasOwnProperty$4 = objectProto$6.hasOwnProperty;\n  var propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable;\n  var isArguments = baseIsArguments(function () {\n    return arguments;\n  }()) ? baseIsArguments : function (value) {\n    return isObjectLike(value) && hasOwnProperty$4.call(value, 'callee') && !propertyIsEnumerable$1.call(value, 'callee');\n  };\n\n  function stubFalse() {\n    return false;\n  }\n\n  var freeExports = (typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;\n  var freeModule = freeExports && (typeof module === 'undefined' ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;\n  var moduleExports = freeModule && freeModule.exports === freeExports;\n  var Buffer = moduleExports ? root.Buffer : undefined;\n  var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n  var isBuffer = nativeIsBuffer || stubFalse;\n\n  var MAX_SAFE_INTEGER = 9007199254740991;\n  var reIsUint = /^(?:0|[1-9]\\d*)$/;\n  function isIndex(value, length) {\n    length = length == null ? MAX_SAFE_INTEGER : length;\n    return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;\n  }\n\n  var MAX_SAFE_INTEGER$1 = 9007199254740991;\n  function isLength(value) {\n    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;\n  }\n\n  var argsTag$1 = '[object Arguments]',\n      arrayTag = '[object Array]',\n      boolTag$1 = '[object Boolean]',\n      dateTag$1 = '[object Date]',\n      errorTag$1 = '[object Error]',\n      funcTag$1 = '[object Function]',\n      mapTag$1 = '[object Map]',\n      numberTag$1 = '[object Number]',\n      objectTag = '[object Object]',\n      regexpTag$1 = '[object RegExp]',\n      setTag$1 = '[object Set]',\n      stringTag$1 = '[object String]',\n      weakMapTag = '[object WeakMap]';\n  var arrayBufferTag$1 = '[object ArrayBuffer]',\n      dataViewTag$1 = '[object DataView]',\n      float32Tag = '[object Float32Array]',\n      float64Tag = '[object Float64Array]',\n      int8Tag = '[object Int8Array]',\n      int16Tag = '[object Int16Array]',\n      int32Tag = '[object Int32Array]',\n      uint8Tag = '[object Uint8Array]',\n      uint8ClampedTag = '[object Uint8ClampedArray]',\n      uint16Tag = '[object Uint16Array]',\n      uint32Tag = '[object Uint32Array]';\n  var typedArrayTags = {};\n  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;\n  typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$1] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$1] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$1] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag] = false;\n  function baseIsTypedArray(value) {\n      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n  }\n\n  function baseUnary(func) {\n    return function (value) {\n      return func(value);\n    };\n  }\n\n  var freeExports$1 = (typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;\n  var freeModule$1 = freeExports$1 && (typeof module === 'undefined' ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;\n  var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;\n  var freeProcess = moduleExports$1 && freeGlobal.process;\n  var nodeUtil = function () {\n    try {\n      return freeProcess && freeProcess.binding && freeProcess.binding('util');\n    } catch (e) {}\n  }();\n\n  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n  var objectProto$7 = Object.prototype;\n  var hasOwnProperty$5 = objectProto$7.hasOwnProperty;\n  function arrayLikeKeys(value, inherited) {\n    var isArr = isArray(value),\n        isArg = !isArr && isArguments(value),\n        isBuff = !isArr && !isArg && isBuffer(value),\n        isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n        skipIndexes = isArr || isArg || isBuff || isType,\n        result = skipIndexes ? baseTimes(value.length, String) : [],\n        length = result.length;\n    for (var key in value) {\n      if ((inherited || hasOwnProperty$5.call(value, key)) && !(skipIndexes && (\n      key == 'length' ||\n      isBuff && (key == 'offset' || key == 'parent') ||\n      isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') ||\n      isIndex(key, length)))) {\n        result.push(key);\n      }\n    }\n    return result;\n  }\n\n  var objectProto$8 = Object.prototype;\n  function isPrototype(value) {\n    var Ctor = value && value.constructor,\n        proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$8;\n    return value === proto;\n  }\n\n  function overArg(func, transform) {\n    return function (arg) {\n      return func(transform(arg));\n    };\n  }\n\n  var nativeKeys = overArg(Object.keys, Object);\n\n  var objectProto$9 = Object.prototype;\n  var hasOwnProperty$6 = objectProto$9.hasOwnProperty;\n  function baseKeys(object) {\n    if (!isPrototype(object)) {\n      return nativeKeys(object);\n    }\n    var result = [];\n    for (var key in Object(object)) {\n      if (hasOwnProperty$6.call(object, key) && key != 'constructor') {\n        result.push(key);\n      }\n    }\n    return result;\n  }\n\n  function isArrayLike(value) {\n    return value != null && isLength(value.length) && !isFunction(value);\n  }\n\n  function keys(object) {\n    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n  }\n\n  function getAllKeys(object) {\n    return baseGetAllKeys(object, keys, getSymbols);\n  }\n\n  var COMPARE_PARTIAL_FLAG$2 = 1;\n  var objectProto$10 = Object.prototype;\n  var hasOwnProperty$7 = objectProto$10.hasOwnProperty;\n  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2,\n        objProps = getAllKeys(object),\n        objLength = objProps.length,\n        othProps = getAllKeys(other),\n        othLength = othProps.length;\n    if (objLength != othLength && !isPartial) {\n      return false;\n    }\n    var index = objLength;\n    while (index--) {\n      var key = objProps[index];\n      if (!(isPartial ? key in other : hasOwnProperty$7.call(other, key))) {\n        return false;\n      }\n    }\n    var stacked = stack.get(object);\n    if (stacked && stack.get(other)) {\n      return stacked == other;\n    }\n    var result = true;\n    stack.set(object, other);\n    stack.set(other, object);\n    var skipCtor = isPartial;\n    while (++index < objLength) {\n      key = objProps[index];\n      var objValue = object[key],\n          othValue = other[key];\n      if (customizer) {\n        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);\n      }\n      if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {\n        result = false;\n        break;\n      }\n      skipCtor || (skipCtor = key == 'constructor');\n    }\n    if (result && !skipCtor) {\n      var objCtor = object.constructor,\n          othCtor = other.constructor;\n      if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n        result = false;\n      }\n    }\n    stack['delete'](object);\n    stack['delete'](other);\n    return result;\n  }\n\n  var DataView = getNative(root, 'DataView');\n\n  var Promise$1 = getNative(root, 'Promise');\n\n  var Set = getNative(root, 'Set');\n\n  var WeakMap = getNative(root, 'WeakMap');\n\n  var mapTag$2 = '[object Map]',\n      objectTag$1 = '[object Object]',\n      promiseTag = '[object Promise]',\n      setTag$2 = '[object Set]',\n      weakMapTag$1 = '[object WeakMap]';\n  var dataViewTag$2 = '[object DataView]';\n  var dataViewCtorString = toSource(DataView),\n      mapCtorString = toSource(Map$1),\n      promiseCtorString = toSource(Promise$1),\n      setCtorString = toSource(Set),\n      weakMapCtorString = toSource(WeakMap);\n  var getTag = baseGetTag;\n  if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$2 || Map$1 && getTag(new Map$1()) != mapTag$2 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set && getTag(new Set()) != setTag$2 || WeakMap && getTag(new WeakMap()) != weakMapTag$1) {\n      getTag = function getTag(value) {\n          var result = baseGetTag(value),\n              Ctor = result == objectTag$1 ? value.constructor : undefined,\n              ctorString = Ctor ? toSource(Ctor) : '';\n          if (ctorString) {\n              switch (ctorString) {\n                  case dataViewCtorString:\n                      return dataViewTag$2;\n                  case mapCtorString:\n                      return mapTag$2;\n                  case promiseCtorString:\n                      return promiseTag;\n                  case setCtorString:\n                      return setTag$2;\n                  case weakMapCtorString:\n                      return weakMapTag$1;\n              }\n          }\n          return result;\n      };\n  }\n  var getTag$1 = getTag;\n\n  var COMPARE_PARTIAL_FLAG$3 = 1;\n  var argsTag$2 = '[object Arguments]',\n      arrayTag$1 = '[object Array]',\n      objectTag$2 = '[object Object]';\n  var objectProto$11 = Object.prototype;\n  var hasOwnProperty$8 = objectProto$11.hasOwnProperty;\n  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n    var objIsArr = isArray(object),\n        othIsArr = isArray(other),\n        objTag = objIsArr ? arrayTag$1 : getTag$1(object),\n        othTag = othIsArr ? arrayTag$1 : getTag$1(other);\n    objTag = objTag == argsTag$2 ? objectTag$2 : objTag;\n    othTag = othTag == argsTag$2 ? objectTag$2 : othTag;\n    var objIsObj = objTag == objectTag$2,\n        othIsObj = othTag == objectTag$2,\n        isSameTag = objTag == othTag;\n    if (isSameTag && isBuffer(object)) {\n      if (!isBuffer(other)) {\n        return false;\n      }\n      objIsArr = true;\n      objIsObj = false;\n    }\n    if (isSameTag && !objIsObj) {\n      stack || (stack = new Stack());\n      return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n    }\n    if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {\n      var objIsWrapped = objIsObj && hasOwnProperty$8.call(object, '__wrapped__'),\n          othIsWrapped = othIsObj && hasOwnProperty$8.call(other, '__wrapped__');\n      if (objIsWrapped || othIsWrapped) {\n        var objUnwrapped = objIsWrapped ? object.value() : object,\n            othUnwrapped = othIsWrapped ? other.value() : other;\n        stack || (stack = new Stack());\n        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n      }\n    }\n    if (!isSameTag) {\n      return false;\n    }\n    stack || (stack = new Stack());\n    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n  }\n\n  function baseIsEqual(value, other, bitmask, customizer, stack) {\n    if (value === other) {\n      return true;\n    }\n    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {\n      return value !== value && other !== other;\n    }\n    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n  }\n\n  var COMPARE_PARTIAL_FLAG$4 = 1,\n      COMPARE_UNORDERED_FLAG$2 = 2;\n  function baseIsMatch(object, source, matchData, customizer) {\n    var index = matchData.length,\n        length = index,\n        noCustomizer = !customizer;\n    if (object == null) {\n      return !length;\n    }\n    object = Object(object);\n    while (index--) {\n      var data = matchData[index];\n      if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {\n        return false;\n      }\n    }\n    while (++index < length) {\n      data = matchData[index];\n      var key = data[0],\n          objValue = object[key],\n          srcValue = data[1];\n      if (noCustomizer && data[2]) {\n        if (objValue === undefined && !(key in object)) {\n          return false;\n        }\n      } else {\n        var stack = new Stack();\n        if (customizer) {\n          var result = customizer(objValue, srcValue, key, object, source, stack);\n        }\n        if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$4 | COMPARE_UNORDERED_FLAG$2, customizer, stack) : result)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  function isStrictComparable(value) {\n    return value === value && !isObject(value);\n  }\n\n  function getMatchData(object) {\n    var result = keys(object),\n        length = result.length;\n    while (length--) {\n      var key = result[length],\n          value = object[key];\n      result[length] = [key, value, isStrictComparable(value)];\n    }\n    return result;\n  }\n\n  function matchesStrictComparable(key, srcValue) {\n    return function (object) {\n      if (object == null) {\n        return false;\n      }\n      return object[key] === srcValue && (srcValue !== undefined || key in Object(object));\n    };\n  }\n\n  function baseMatches(source) {\n    var matchData = getMatchData(source);\n    if (matchData.length == 1 && matchData[0][2]) {\n      return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n    }\n    return function (object) {\n      return object === source || baseIsMatch(object, source, matchData);\n    };\n  }\n\n  var symbolTag$1 = '[object Symbol]';\n  function isSymbol(value) {\n    return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag$1;\n  }\n\n  var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n      reIsPlainProp = /^\\w*$/;\n  function isKey(value, object) {\n    if (isArray(value)) {\n      return false;\n    }\n    var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);\n    if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {\n      return true;\n    }\n    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);\n  }\n\n  var FUNC_ERROR_TEXT = 'Expected a function';\n  function memoize(func, resolver) {\n    if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {\n      throw new TypeError(FUNC_ERROR_TEXT);\n    }\n    var memoized = function memoized() {\n      var args = arguments,\n          key = resolver ? resolver.apply(this, args) : args[0],\n          cache = memoized.cache;\n      if (cache.has(key)) {\n        return cache.get(key);\n      }\n      var result = func.apply(this, args);\n      memoized.cache = cache.set(key, result) || cache;\n      return result;\n    };\n    memoized.cache = new (memoize.Cache || MapCache)();\n    return memoized;\n  }\n  memoize.Cache = MapCache;\n\n  var MAX_MEMOIZE_SIZE = 500;\n  function memoizeCapped(func) {\n    var result = memoize(func, function (key) {\n      if (cache.size === MAX_MEMOIZE_SIZE) {\n        cache.clear();\n      }\n      return key;\n    });\n    var cache = result.cache;\n    return result;\n  }\n\n  var reLeadingDot = /^\\./,\n      rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n  var reEscapeChar = /\\\\(\\\\)?/g;\n  var stringToPath = memoizeCapped(function (string) {\n    var result = [];\n    if (reLeadingDot.test(string)) {\n      result.push('');\n    }\n    string.replace(rePropName, function (match, number, quote, string) {\n      result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);\n    });\n    return result;\n  });\n\n  var INFINITY = 1 / 0;\n  var symbolProto$1 = _Symbol ? _Symbol.prototype : undefined,\n      symbolToString = symbolProto$1 ? symbolProto$1.toString : undefined;\n  function baseToString(value) {\n    if (typeof value == 'string') {\n      return value;\n    }\n    if (isArray(value)) {\n      return arrayMap(value, baseToString) + '';\n    }\n    if (isSymbol(value)) {\n      return symbolToString ? symbolToString.call(value) : '';\n    }\n    var result = value + '';\n    return result == '0' && 1 / value == -INFINITY ? '-0' : result;\n  }\n\n  function toString(value) {\n    return value == null ? '' : baseToString(value);\n  }\n\n  function castPath(value, object) {\n    if (isArray(value)) {\n      return value;\n    }\n    return isKey(value, object) ? [value] : stringToPath(toString(value));\n  }\n\n  var INFINITY$1 = 1 / 0;\n  function toKey(value) {\n    if (typeof value == 'string' || isSymbol(value)) {\n      return value;\n    }\n    var result = value + '';\n    return result == '0' && 1 / value == -INFINITY$1 ? '-0' : result;\n  }\n\n  function baseGet(object, path) {\n    path = castPath(path, object);\n    var index = 0,\n        length = path.length;\n    while (object != null && index < length) {\n      object = object[toKey(path[index++])];\n    }\n    return index && index == length ? object : undefined;\n  }\n\n  function get$1(object, path, defaultValue) {\n    var result = object == null ? undefined : baseGet(object, path);\n    return result === undefined ? defaultValue : result;\n  }\n\n  function baseHasIn(object, key) {\n    return object != null && key in Object(object);\n  }\n\n  function hasPath(object, path, hasFunc) {\n    path = castPath(path, object);\n    var index = -1,\n        length = path.length,\n        result = false;\n    while (++index < length) {\n      var key = toKey(path[index]);\n      if (!(result = object != null && hasFunc(object, key))) {\n        break;\n      }\n      object = object[key];\n    }\n    if (result || ++index != length) {\n      return result;\n    }\n    length = object == null ? 0 : object.length;\n    return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));\n  }\n\n  function hasIn(object, path) {\n    return object != null && hasPath(object, path, baseHasIn);\n  }\n\n  var COMPARE_PARTIAL_FLAG$5 = 1,\n      COMPARE_UNORDERED_FLAG$3 = 2;\n  function baseMatchesProperty(path, srcValue) {\n    if (isKey(path) && isStrictComparable(srcValue)) {\n      return matchesStrictComparable(toKey(path), srcValue);\n    }\n    return function (object) {\n      var objValue = get$1(object, path);\n      return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$5 | COMPARE_UNORDERED_FLAG$3);\n    };\n  }\n\n  function identity(value) {\n    return value;\n  }\n\n  function baseProperty(key) {\n    return function (object) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  function basePropertyDeep(path) {\n    return function (object) {\n      return baseGet(object, path);\n    };\n  }\n\n  function property(path) {\n    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n  }\n\n  function baseIteratee(value) {\n    if (typeof value == 'function') {\n      return value;\n    }\n    if (value == null) {\n      return identity;\n    }\n    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object') {\n      return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);\n    }\n    return property(value);\n  }\n\n  function createBaseFor(fromRight) {\n    return function (object, iteratee, keysFunc) {\n      var index = -1,\n          iterable = Object(object),\n          props = keysFunc(object),\n          length = props.length;\n      while (length--) {\n        var key = props[fromRight ? length : ++index];\n        if (iteratee(iterable[key], key, iterable) === false) {\n          break;\n        }\n      }\n      return object;\n    };\n  }\n\n  var baseFor = createBaseFor();\n\n  function baseForOwn(object, iteratee) {\n    return object && baseFor(object, iteratee, keys);\n  }\n\n  function createBaseEach(eachFunc, fromRight) {\n    return function (collection, iteratee) {\n      if (collection == null) {\n        return collection;\n      }\n      if (!isArrayLike(collection)) {\n        return eachFunc(collection, iteratee);\n      }\n      var length = collection.length,\n          index = fromRight ? length : -1,\n          iterable = Object(collection);\n      while (fromRight ? index-- : ++index < length) {\n        if (iteratee(iterable[index], index, iterable) === false) {\n          break;\n        }\n      }\n      return collection;\n    };\n  }\n\n  var baseEach = createBaseEach(baseForOwn);\n\n  function baseMap(collection, iteratee) {\n    var index = -1,\n        result = isArrayLike(collection) ? Array(collection.length) : [];\n    baseEach(collection, function (value, key, collection) {\n      result[++index] = iteratee(value, key, collection);\n    });\n    return result;\n  }\n\n  function map(collection, iteratee) {\n    var func = isArray(collection) ? arrayMap : baseMap;\n    return func(collection, baseIteratee(iteratee, 3));\n  }\n\n  function arrayEach(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n    while (++index < length) {\n      if (iteratee(array[index], index, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  function castFunction(value) {\n    return typeof value == 'function' ? value : identity;\n  }\n\n  function forEach(collection, iteratee) {\n    var func = isArray(collection) ? arrayEach : baseEach;\n    return func(collection, castFunction(iteratee));\n  }\n\n  function toLatLng(position) {\n  \tif (position instanceof google.maps.LatLng) {\n  \t\treturn {\n  \t\t\tlat: position.lat(),\n  \t\t\tlng: position.lng()\n  \t\t};\n  \t} else if (position.lat && position.lng) {\n  \t\treturn position;\n  \t} else {\n  \t\treturn {\n  \t\t\tlat: position[1],\n  \t\t\tlng: position[0]\n  \t\t};\n  \t}\n  }\n  function toLatLngs(coordinates) {\n  \treturn map(coordinates, toLatLng);\n  }\n  function toCoord$1(LatLng) {\n  \tif (google.maps && google.maps.LatLng && LatLng instanceof google.maps.LatLng) {\n  \t\treturn [LatLng.lng(), LatLng.lat()];\n  \t} else if (LatLng.lat && LatLng.lng) {\n  \t\treturn [LatLng.lng, LatLng.lat];\n  \t} else if (LatLng.length && LatLng.length >= 2) {\n  \t\treturn LatLng;\n  \t} else {\n  \t\tthrow new Error('google.maps is not present in the global scope');\n  \t}\n  }\n  function toCoords(arrayLatLng, closeRing) {\n  \tvar ring = map(arrayLatLng, toCoord$1);\n  \tif (closeRing === true) {\n  \t\tvar last_coord = ring.pop();\n  \t\tif (last_coord[0] === ring[0][0] && last_coord[1] === ring[0][1]) {\n  \t\t\tring.push(ring[0]);\n  \t\t} else {\n  \t\t\tring.push(last_coord);\n  \t\t\tring.push(ring[0]);\n  \t\t}\n  \t}\n  \treturn ring;\n  }\n\n  var earthRadius = 6371008.8;\n  var factors = {\n      meters: earthRadius,\n      metres: earthRadius,\n      millimeters: earthRadius * 1000,\n      millimetres: earthRadius * 1000,\n      centimeters: earthRadius * 100,\n      centimetres: earthRadius * 100,\n      kilometers: earthRadius / 1000,\n      kilometres: earthRadius / 1000,\n      miles: earthRadius / 1609.344,\n      nauticalmiles: earthRadius / 1852,\n      inches: earthRadius * 39.370,\n      yards: earthRadius / 1.0936,\n      feet: earthRadius * 3.28084,\n      radians: 1,\n      degrees: earthRadius / 111325\n  };\n  function feature(geometry, properties, bbox, id) {\n      if (geometry === undefined) throw new Error('geometry is required');\n      if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n      if (bbox) {\n          if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n          if (bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');\n      }\n      if (id && ['string', 'number'].indexOf(typeof id === 'undefined' ? 'undefined' : _typeof(id)) === -1) throw new Error('id must be a number or a string');\n      var feat = { type: 'Feature' };\n      if (id) feat.id = id;\n      if (bbox) feat.bbox = bbox;\n      feat.properties = properties || {};\n      feat.geometry = geometry;\n      return feat;\n  }\n  function point(coordinates, properties, bbox, id) {\n      if (!coordinates) throw new Error('No coordinates passed');\n      if (!Array.isArray(coordinates)) throw new Error('Coordinates must be an Array');\n      if (coordinates.length < 2) throw new Error('Coordinates must be at least 2 numbers long');\n      if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('Coordinates must contain numbers');\n      return feature({\n          type: 'Point',\n          coordinates: coordinates\n      }, properties, bbox, id);\n  }\n  function polygon(coordinates, properties, bbox, id) {\n      if (!coordinates) throw new Error('No coordinates passed');\n      for (var i = 0; i < coordinates.length; i++) {\n          var ring = coordinates[i];\n          if (ring.length < 4) {\n              throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n          }\n          for (var j = 0; j < ring[ring.length - 1].length; j++) {\n              if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('Coordinates must contain numbers');\n              if (ring[ring.length - 1][j] !== ring[0][j]) {\n                  throw new Error('First and last Position are not equivalent.');\n              }\n          }\n      }\n      return feature({\n          type: 'Polygon',\n          coordinates: coordinates\n      }, properties, bbox, id);\n  }\n  function lineString(coordinates, properties, bbox, id) {\n      if (!coordinates) throw new Error('No coordinates passed');\n      if (coordinates.length < 2) throw new Error('Coordinates must be an array of two or more positions');\n      if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('Coordinates must contain numbers');\n      return feature({\n          type: 'LineString',\n          coordinates: coordinates\n      }, properties, bbox, id);\n  }\n  function featureCollection(features, bbox, id) {\n      if (!features) throw new Error('No features passed');\n      if (!Array.isArray(features)) throw new Error('features must be an Array');\n      if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');\n      if (id && ['string', 'number'].indexOf(typeof id === 'undefined' ? 'undefined' : _typeof(id)) === -1) throw new Error('id must be a number or a string');\n      var fc = { type: 'FeatureCollection' };\n      if (id) fc.id = id;\n      if (bbox) fc.bbox = bbox;\n      fc.features = features;\n      return fc;\n  }\n  function multiLineString(coordinates, properties, bbox, id) {\n      if (!coordinates) throw new Error('No coordinates passed');\n      return feature({\n          type: 'MultiLineString',\n          coordinates: coordinates\n      }, properties, bbox, id);\n  }\n  function geometryCollection(geometries, properties, bbox, id) {\n      if (!geometries) throw new Error('geometries is required');\n      if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n      return feature({\n          type: 'GeometryCollection',\n          geometries: geometries\n      }, properties, bbox, id);\n  }\n  function radiansToLength(radians, units) {\n      if (radians === undefined || radians === null) throw new Error('radians is required');\n      if (units && typeof units !== 'string') throw new Error('units must be a string');\n      var factor = factors[units || 'kilometers'];\n      if (!factor) throw new Error(units + ' units is invalid');\n      return radians * factor;\n  }\n  function lengthToRadians(distance, units) {\n      if (distance === undefined || distance === null) throw new Error('distance is required');\n      if (units && typeof units !== 'string') throw new Error('units must be a string');\n      var factor = factors[units || 'kilometers'];\n      if (!factor) throw new Error(units + ' units is invalid');\n      return distance / factor;\n  }\n  function radiansToDegrees(radians) {\n      if (radians === null || radians === undefined) throw new Error('radians is required');\n      var degrees = radians % (2 * Math.PI);\n      return degrees * 180 / Math.PI;\n  }\n  function degreesToRadians(degrees) {\n      if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n      var radians = degrees % 360;\n      return radians * Math.PI / 180;\n  }\n  function isNumber(num) {\n      return !isNaN(num) && num !== null && !Array.isArray(num);\n  }\n  function isObject$1(input) {\n      return !!input && input.constructor === Object;\n  }\n\n  var debug = console.debug.bind(console, '%c turfHelper' + ':', \"color:#00CC00;font-weight:bold;\"),\n      warn = console.debug.bind(console, '%c turfHelper' + ':', \"color:orange;font-weight:bold;\");\n  function arrayToFeaturePolygon(LatLngArray) {\n      var vertices = toCoords(LatLngArray, true);\n      return {\n          type: \"Feature\",\n          properties: {},\n          geometry: {\n              type: \"Polygon\",\n              coordinates: [vertices]\n          }\n      };\n  }\n  function markerToFeaturePoint(marker) {\n      if (!marker.getPosition || typeof marker.getPosition !== 'function') {\n          throw new Error('input object does not have a getPosition method');\n      }\n      var position = marker.getPosition(),\n          Feature = {\n          type: \"Feature\",\n          properties: {},\n          geometry: {\n              type: \"Point\",\n              coordinates: [position.lng(), position.lat()]\n          }\n      };\n      return Feature;\n  }function polylineToFeatureLinestring(objeto) {\n      var vertices;\n      if (objeto instanceof google.maps.Polyline) {\n          vertices = toCoords(objeto.getPath().getArray());\n      } else {\n          vertices = toCoords(objeto);\n      }\n      return lineString(vertices);\n  }\n  function polygonToFeaturePolygon(object) {\n      var ring, polygonFeature;\n      if (object.type === 'Feature') {\n          polygonFeature = object;\n      } else if (object instanceof google.maps.Polygon) {\n          object = object.getPath().getArray();\n          ring = toCoords(object, true);\n          polygonFeature = arrayToFeaturePolygon(ring);\n      } else if (!!(object && object.constructor === Array)) {\n          ring = toCoords(object, true);\n          polygonFeature = arrayToFeaturePolygon(ring);\n      } else if (object.geometry) {\n          polygonFeature = {\n              type: \"Feature\",\n              properties: {},\n              geometry: object.geometry\n          };\n      } else {\n          throw new Error('object is not a Feature, google.maps.Polygon nor an array of google.maps.LatLng');\n      }\n      polygonFeature.properties = {};\n      return polygonFeature;\n  }\n  function arrayToFeaturePoints(latLngArray) {\n      var FeatureCollection = {\n          \"type\": \"FeatureCollection\",\n          \"features\": []\n      };\n      latLngArray.forEach(function (latLng) {\n          var Feature = {\n              type: \"Feature\",\n              geometry: {\n                  type: \"Point\",\n                  coordinates: toCoords([latLng])[0]\n              }\n          };\n          FeatureCollection.features.push(Feature);\n      });\n      return FeatureCollection;\n  }\n\n  function tin(points, z) {\n      if (points.type !== 'FeatureCollection') throw new Error('points must be a FeatureCollection');\n      var isPointZ = false;\n      return featureCollection(triangulate(points.features.map(function (p) {\n          var point$$1 = {\n              x: p.geometry.coordinates[0],\n              y: p.geometry.coordinates[1]\n          };\n          if (z) {\n              point$$1.z = p.properties[z];\n          } else if (p.geometry.coordinates.length === 3) {\n              isPointZ = true;\n              point$$1.z = p.geometry.coordinates[2];\n          }\n          return point$$1;\n      })).map(function (triangle) {\n          var a = [triangle.a.x, triangle.a.y];\n          var b = [triangle.b.x, triangle.b.y];\n          var c = [triangle.c.x, triangle.c.y];\n          var properties = {};\n          if (isPointZ) {\n              a.push(triangle.a.z);\n              b.push(triangle.b.z);\n              c.push(triangle.c.z);\n          } else {\n              properties = {\n                  a: triangle.a.z,\n                  b: triangle.b.z,\n                  c: triangle.c.z\n              };\n          }\n          return polygon([[a, b, c, a]], properties);\n      }));\n  }\n  function Triangle(a, b, c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n      var A = b.x - a.x,\n          B = b.y - a.y,\n          C = c.x - a.x,\n          D = c.y - a.y,\n          E = A * (a.x + b.x) + B * (a.y + b.y),\n          F = C * (a.x + c.x) + D * (a.y + c.y),\n          G = 2 * (A * (c.y - b.y) - B * (c.x - b.x)),\n          dx,\n          dy;\n      this.x = (D * E - B * F) / G;\n      this.y = (A * F - C * E) / G;\n      dx = this.x - a.x;\n      dy = this.y - a.y;\n      this.r = dx * dx + dy * dy;\n  }\n  function byX(a, b) {\n      return b.x - a.x;\n  }\n  function dedup(edges) {\n      var j = edges.length,\n          a,\n          b,\n          i,\n          m,\n          n;\n      outer: while (j) {\n          b = edges[--j];\n          a = edges[--j];\n          i = j;\n          while (i) {\n              n = edges[--i];\n              m = edges[--i];\n              if (a === m && b === n || a === n && b === m) {\n                  edges.splice(j, 2);\n                  edges.splice(i, 2);\n                  j -= 2;\n                  continue outer;\n              }\n          }\n      }\n  }\n  function triangulate(vertices) {\n      if (vertices.length < 3) return [];\n      vertices.sort(byX);\n      var i = vertices.length - 1,\n          xmin = vertices[i].x,\n          xmax = vertices[0].x,\n          ymin = vertices[i].y,\n          ymax = ymin,\n          epsilon = 1e-12;\n      var a, b, c, A, B, G;\n      while (i--) {\n          if (vertices[i].y < ymin) ymin = vertices[i].y;\n          if (vertices[i].y > ymax) ymax = vertices[i].y;\n      }\n      var dx = xmax - xmin,\n          dy = ymax - ymin,\n          dmax = dx > dy ? dx : dy,\n          xmid = (xmax + xmin) * 0.5,\n          ymid = (ymax + ymin) * 0.5,\n          open = [new Triangle({\n          x: xmid - 20 * dmax,\n          y: ymid - dmax,\n          __sentinel: true\n      }, {\n          x: xmid,\n          y: ymid + 20 * dmax,\n          __sentinel: true\n      }, {\n          x: xmid + 20 * dmax,\n          y: ymid - dmax,\n          __sentinel: true\n      })],\n          closed = [],\n          edges = [],\n          j;\n      i = vertices.length;\n      while (i--) {\n          edges.length = 0;\n          j = open.length;\n          while (j--) {\n              dx = vertices[i].x - open[j].x;\n              if (dx > 0 && dx * dx > open[j].r) {\n                  closed.push(open[j]);\n                  open.splice(j, 1);\n                  continue;\n              }\n              dy = vertices[i].y - open[j].y;\n              if (dx * dx + dy * dy > open[j].r) continue;\n              edges.push(open[j].a, open[j].b, open[j].b, open[j].c, open[j].c, open[j].a);\n              open.splice(j, 1);\n          }\n          dedup(edges);\n          j = edges.length;\n          while (j) {\n              b = edges[--j];\n              a = edges[--j];\n              c = vertices[i];\n              A = b.x - a.x;\n              B = b.y - a.y;\n              G = 2 * (A * (c.y - b.y) - B * (c.x - b.x));\n              if (Math.abs(G) > epsilon) {\n                  open.push(new Triangle(a, b, c));\n              }\n          }\n      }\n      Array.prototype.push.apply(closed, open);\n      i = closed.length;\n      while (i--) {\n          if (closed[i].a.__sentinel || closed[i].b.__sentinel || closed[i].c.__sentinel) closed.splice(i, 1);\n      }return closed;\n  }\n\n  function clone(geojson) {\n      if (!geojson) throw new Error('geojson is required');\n      switch (geojson.type) {\n          case 'Feature':\n              return cloneFeature(geojson);\n          case 'FeatureCollection':\n              return cloneFeatureCollection(geojson);\n          case 'Point':\n          case 'LineString':\n          case 'Polygon':\n          case 'MultiPoint':\n          case 'MultiLineString':\n          case 'MultiPolygon':\n          case 'GeometryCollection':\n              return cloneGeometry(geojson);\n          default:\n              throw new Error('unknown GeoJSON type');\n      }\n  }\n  function cloneFeature(geojson) {\n      var cloned = { type: 'Feature' };\n      Object.keys(geojson).forEach(function (key) {\n          switch (key) {\n              case 'type':\n              case 'properties':\n              case 'geometry':\n                  return;\n              default:\n                  cloned[key] = geojson[key];\n          }\n      });\n      cloned.properties = cloneProperties(geojson.properties);\n      cloned.geometry = cloneGeometry(geojson.geometry);\n      return cloned;\n  }\n  function cloneProperties(properties) {\n      var cloned = {};\n      if (!properties) return cloned;\n      Object.keys(properties).forEach(function (key) {\n          var value = properties[key];\n          if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\n              if (value.length) cloned[key] = value.map(function (item) {\n                  return item;\n              });\n              cloned[key] = cloneProperties(value);\n          } else cloned[key] = value;\n      });\n      return cloned;\n  }\n  function cloneFeatureCollection(geojson) {\n      var cloned = { type: 'FeatureCollection' };\n      Object.keys(geojson).forEach(function (key) {\n          switch (key) {\n              case 'type':\n              case 'features':\n                  return;\n              default:\n                  cloned[key] = geojson[key];\n          }\n      });\n      cloned.features = geojson.features.map(function (feature) {\n          return cloneFeature(feature);\n      });\n      return cloned;\n  }\n  function cloneGeometry(geometry) {\n      var geom = { type: geometry.type };\n      if (geometry.bbox) geom.bbox = geometry.bbox;\n      if (geometry.type === 'GeometryCollection') {\n          geom.geometries = geometry.geometries.map(function (geom) {\n              return cloneGeometry(geom);\n          });\n          return geom;\n      }\n      geom.coordinates = deepSlice(geometry.coordinates);\n      return geom;\n  }\n  function deepSlice(coords) {\n      if (_typeof(coords[0]) !== 'object') {\n          return coords.slice();\n      }\n      return coords.map(function (coord) {\n          return deepSlice(coord);\n      });\n  }\n\n  function getCoord(obj) {\n      if (!obj) throw new Error('obj is required');\n      var coordinates = getCoords(obj);\n      if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\n          return coordinates;\n      } else {\n          throw new Error('Coordinate is not a valid Point');\n      }\n  }\n  function getCoords(obj) {\n      if (!obj) throw new Error('obj is required');\n      var coordinates;\n      if (obj.length) {\n          coordinates = obj;\n      } else if (obj.coordinates) {\n          coordinates = obj.coordinates;\n      } else if (obj.geometry && obj.geometry.coordinates) {\n          coordinates = obj.geometry.coordinates;\n      }\n      if (coordinates) {\n          containsNumber(coordinates);\n          return coordinates;\n      }\n      throw new Error('No valid coordinates');\n  }\n  function containsNumber(coordinates) {\n      if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\n          return true;\n      }\n      if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n          return containsNumber(coordinates[0]);\n      }\n      throw new Error('coordinates must only contain numbers');\n  }\n  function getType(geojson, name) {\n      if (!geojson) throw new Error((name || 'geojson') + ' is required');\n      if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n      if (geojson.type) return geojson.type;\n      throw new Error((name || 'geojson') + ' is invalid');\n  }\n\n  function coordEach(geojson, callback, excludeWrapCoord) {\n      if (geojson === null) return;\n      var featureIndex,\n          geometryIndex,\n          j,\n          k,\n          l,\n          geometry$$1,\n          stopG,\n          coords,\n          geometryMaybeCollection,\n          wrapShrink = 0,\n          coordIndex = 0,\n          isGeometryCollection,\n          type = geojson.type,\n          isFeatureCollection = type === 'FeatureCollection',\n          isFeature = type === 'Feature',\n          stop = isFeatureCollection ? geojson.features.length : 1;\n      for (featureIndex = 0; featureIndex < stop; featureIndex++) {\n          geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;\n          isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n          stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n          for (geometryIndex = 0; geometryIndex < stopG; geometryIndex++) {\n              var featureSubIndex = 0;\n              geometry$$1 = isGeometryCollection ? geometryMaybeCollection.geometries[geometryIndex] : geometryMaybeCollection;\n              if (geometry$$1 === null) continue;\n              coords = geometry$$1.coordinates;\n              var geomType = geometry$$1.type;\n              wrapShrink = excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon') ? 1 : 0;\n              switch (geomType) {\n                  case null:\n                      break;\n                  case 'Point':\n                      callback(coords, coordIndex, featureIndex, featureSubIndex);\n                      coordIndex++;\n                      featureSubIndex++;\n                      break;\n                  case 'LineString':\n                  case 'MultiPoint':\n                      for (j = 0; j < coords.length; j++) {\n                          callback(coords[j], coordIndex, featureIndex, featureSubIndex);\n                          coordIndex++;\n                          if (geomType === 'MultiPoint') featureSubIndex++;\n                      }\n                      if (geomType === 'LineString') featureSubIndex++;\n                      break;\n                  case 'Polygon':\n                  case 'MultiLineString':\n                      for (j = 0; j < coords.length; j++) {\n                          for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                              callback(coords[j][k], coordIndex, featureIndex, featureSubIndex);\n                              coordIndex++;\n                          }\n                          if (geomType === 'MultiLineString') featureSubIndex++;\n                      }\n                      if (geomType === 'Polygon') featureSubIndex++;\n                      break;\n                  case 'MultiPolygon':\n                      for (j = 0; j < coords.length; j++) {\n                          for (k = 0; k < coords[j].length; k++) {\n                              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                                  callback(coords[j][k][l], coordIndex, featureIndex, featureSubIndex);\n                                  coordIndex++;\n                              }\n                          }featureSubIndex++;\n                      }\n                      break;\n                  case 'GeometryCollection':\n                      for (j = 0; j < geometry$$1.geometries.length; j++) {\n                          coordEach(geometry$$1.geometries[j], callback, excludeWrapCoord);\n                      }break;\n                  default:\n                      throw new Error('Unknown Geometry Type');\n              }\n          }\n      }\n  }\n  function featureEach(geojson, callback) {\n      if (geojson.type === 'Feature') {\n          callback(geojson, 0);\n      } else if (geojson.type === 'FeatureCollection') {\n          for (var i = 0; i < geojson.features.length; i++) {\n              callback(geojson.features[i], i);\n          }\n      }\n  }\n  function geomEach(geojson, callback) {\n      var i,\n          j,\n          g,\n          geometry$$1,\n          stopG,\n          geometryMaybeCollection,\n          isGeometryCollection,\n          featureProperties,\n          featureBBox,\n          featureId,\n          featureIndex = 0,\n          isFeatureCollection = geojson.type === 'FeatureCollection',\n          isFeature = geojson.type === 'Feature',\n          stop = isFeatureCollection ? geojson.features.length : 1;\n      for (i = 0; i < stop; i++) {\n          geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;\n          featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};\n          featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : undefined;\n          featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : undefined;\n          isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n          stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n          for (g = 0; g < stopG; g++) {\n              geometry$$1 = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n              if (geometry$$1 === null) {\n                  callback(null, featureIndex, featureProperties, featureBBox, featureId);\n                  continue;\n              }\n              switch (geometry$$1.type) {\n                  case 'Point':\n                  case 'LineString':\n                  case 'MultiPoint':\n                  case 'Polygon':\n                  case 'MultiLineString':\n                  case 'MultiPolygon':\n                      {\n                          callback(geometry$$1, featureIndex, featureProperties, featureBBox, featureId);\n                          break;\n                      }\n                  case 'GeometryCollection':\n                      {\n                          for (j = 0; j < geometry$$1.geometries.length; j++) {\n                              callback(geometry$$1.geometries[j], featureIndex, featureProperties, featureBBox, featureId);\n                          }\n                          break;\n                      }\n                  default:\n                      throw new Error('Unknown Geometry Type');\n              }\n          }\n          featureIndex++;\n      }\n  }\n  function flattenEach(geojson, callback) {\n      geomEach(geojson, function (geometry$$1, featureIndex, properties, bbox, id) {\n          var type = geometry$$1 === null ? null : geometry$$1.type;\n          switch (type) {\n              case null:\n              case 'Point':\n              case 'LineString':\n              case 'Polygon':\n                  callback(feature(geometry$$1, properties, bbox, id), featureIndex, 0);\n                  return;\n          }\n          var geomType;\n          switch (type) {\n              case 'MultiPoint':\n                  geomType = 'Point';\n                  break;\n              case 'MultiLineString':\n                  geomType = 'LineString';\n                  break;\n              case 'MultiPolygon':\n                  geomType = 'Polygon';\n                  break;\n          }\n          geometry$$1.coordinates.forEach(function (coordinate, featureSubIndex) {\n              var geom = {\n                  type: geomType,\n                  coordinates: coordinate\n              };\n              callback(feature(geom, properties), featureIndex, featureSubIndex);\n          });\n      });\n  }\n  function lineEach(geojson, callback) {\n      if (!geojson) throw new Error('geojson is required');\n      flattenEach(geojson, function (feature$$1, featureIndex, featureSubIndex) {\n          if (feature$$1.geometry === null) return;\n          var type = feature$$1.geometry.type;\n          var coords = feature$$1.geometry.coordinates;\n          switch (type) {\n              case 'LineString':\n                  callback(feature$$1, featureIndex, featureSubIndex, 0);\n                  break;\n              case 'Polygon':\n                  for (var lineIndex = 0; lineIndex < coords.length; lineIndex++) {\n                      callback(lineString(coords[lineIndex], feature$$1.properties), featureIndex, featureSubIndex, lineIndex);\n                  }\n                  break;\n          }\n      });\n  }\n  function lineReduce(geojson, callback, initialValue) {\n      var previousValue = initialValue;\n      lineEach(geojson, function (currentLine, featureIndex, featureSubIndex, lineIndex) {\n          if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;else previousValue = callback(previousValue, currentLine, featureIndex, featureSubIndex, lineIndex);\n      });\n      return previousValue;\n  }\n\n  function lineDissolve(geojson, options) {\n      options = options || {};\n      if (!isObject$1(options)) throw new Error('options is invalid');\n      var mutate = options.mutate;\n      if (getType(geojson) !== 'FeatureCollection') throw new Error('geojson must be a FeatureCollection');\n      if (!geojson.features.length) throw new Error('geojson is empty');\n      if (mutate === false || mutate === undefined) geojson = clone(geojson);\n      var result = [];\n      var lastLine = lineReduce(geojson, function (previousLine, currentLine) {\n          var merged = mergeLineStrings(previousLine, currentLine);\n          if (merged) return merged;\n          else {\n                  result.push(previousLine);\n                  return currentLine;\n              }\n      });\n      if (lastLine) result.push(lastLine);\n      if (!result.length) return null;\n      else if (result.length === 1) return result[0];\n          else return multiLineString(result.map(function (line) {\n                  return line.coordinates;\n              }));\n  }\n  function coordId(coord) {\n      return coord[0].toString() + ',' + coord[1].toString();\n  }\n  function mergeLineStrings(a, b) {\n      var coords1 = a.geometry.coordinates;\n      var coords2 = b.geometry.coordinates;\n      var s1 = coordId(coords1[0]);\n      var e1 = coordId(coords1[coords1.length - 1]);\n      var s2 = coordId(coords2[0]);\n      var e2 = coordId(coords2[coords2.length - 1]);\n      var coords;\n      if (s1 === e2) coords = coords2.concat(coords1.slice(1));else if (s2 === e1) coords = coords1.concat(coords2.slice(1));else if (s1 === s2) coords = coords1.slice(1).reverse().concat(coords2);else if (e1 === e2) coords = coords1.concat(coords2.reverse().slice(1));else return null;\n      return lineString(coords);\n  }\n\n  function identity$1 (x) {\n    return x;\n  }\n\n  function transform (transform) {\n    if (transform == null) return identity$1;\n    var x0,\n        y0,\n        kx = transform.scale[0],\n        ky = transform.scale[1],\n        dx = transform.translate[0],\n        dy = transform.translate[1];\n    return function (input, i) {\n      if (!i) x0 = y0 = 0;\n      var j = 2,\n          n = input.length,\n          output = new Array(n);\n      output[0] = (x0 += input[0]) * kx + dx;\n      output[1] = (y0 += input[1]) * ky + dy;\n      while (j < n) {\n        output[j] = input[j], ++j;\n      }return output;\n    };\n  }\n\n  function reverse (array, n) {\n    var t,\n        j = array.length,\n        i = j - n;\n    while (i < --j) {\n      t = array[i], array[i++] = array[j], array[j] = t;\n    }\n  }\n\n  function object(topology, o) {\n    var transformPoint = transform(topology.transform),\n        arcs = topology.arcs;\n    function arc(i, points) {\n      if (points.length) points.pop();\n      for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {\n        points.push(transformPoint(a[k], k));\n      }\n      if (i < 0) reverse(points, n);\n    }\n    function point(p) {\n      return transformPoint(p);\n    }\n    function line(arcs) {\n      var points = [];\n      for (var i = 0, n = arcs.length; i < n; ++i) {\n        arc(arcs[i], points);\n      }if (points.length < 2) points.push(points[0]);\n      return points;\n    }\n    function ring(arcs) {\n      var points = line(arcs);\n      while (points.length < 4) {\n        points.push(points[0]);\n      }\n      return points;\n    }\n    function polygon(arcs) {\n      return arcs.map(ring);\n    }\n    function geometry(o) {\n      var type = o.type,\n          coordinates;\n      switch (type) {\n        case \"GeometryCollection\":\n          return { type: type, geometries: o.geometries.map(geometry) };\n        case \"Point\":\n          coordinates = point(o.coordinates);break;\n        case \"MultiPoint\":\n          coordinates = o.coordinates.map(point);break;\n        case \"LineString\":\n          coordinates = line(o.arcs);break;\n        case \"MultiLineString\":\n          coordinates = o.arcs.map(line);break;\n        case \"Polygon\":\n          coordinates = polygon(o.arcs);break;\n        case \"MultiPolygon\":\n          coordinates = o.arcs.map(polygon);break;\n        default:\n          return null;\n      }\n      return { type: type, coordinates: coordinates };\n    }\n    return geometry(o);\n  }\n\n  function stitch (topology, arcs) {\n    var stitchedArcs = {},\n        fragmentByStart = {},\n        fragmentByEnd = {},\n        fragments = [],\n        emptyIndex = -1;\n    arcs.forEach(function (i, j) {\n      var arc = topology.arcs[i < 0 ? ~i : i],\n          t;\n      if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {\n        t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;\n      }\n    });\n    arcs.forEach(function (i) {\n      var e = ends(i),\n          start = e[0],\n          end = e[1],\n          f,\n          g;\n      if (f = fragmentByEnd[start]) {\n        delete fragmentByEnd[f.end];\n        f.push(i);\n        f.end = end;\n        if (g = fragmentByStart[end]) {\n          delete fragmentByStart[g.start];\n          var fg = g === f ? f : f.concat(g);\n          fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;\n        } else {\n          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n        }\n      } else if (f = fragmentByStart[end]) {\n        delete fragmentByStart[f.start];\n        f.unshift(i);\n        f.start = start;\n        if (g = fragmentByEnd[start]) {\n          delete fragmentByEnd[g.end];\n          var gf = g === f ? f : g.concat(f);\n          fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;\n        } else {\n          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n        }\n      } else {\n        f = [i];\n        fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;\n      }\n    });\n    function ends(i) {\n      var arc = topology.arcs[i < 0 ? ~i : i],\n          p0 = arc[0],\n          p1;\n      if (topology.transform) p1 = [0, 0], arc.forEach(function (dp) {\n        p1[0] += dp[0], p1[1] += dp[1];\n      });else p1 = arc[arc.length - 1];\n      return i < 0 ? [p1, p0] : [p0, p1];\n    }\n    function flush(fragmentByEnd, fragmentByStart) {\n      for (var k in fragmentByEnd) {\n        var f = fragmentByEnd[k];\n        delete fragmentByStart[f.start];\n        delete f.start;\n        delete f.end;\n        f.forEach(function (i) {\n          stitchedArcs[i < 0 ? ~i : i] = 1;\n        });\n        fragments.push(f);\n      }\n    }\n    flush(fragmentByEnd, fragmentByStart);\n    flush(fragmentByStart, fragmentByEnd);\n    arcs.forEach(function (i) {\n      if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]);\n    });\n    return fragments;\n  }\n\n  function planarRingArea(ring) {\n    var i = -1,\n        n = ring.length,\n        a,\n        b = ring[n - 1],\n        area = 0;\n    while (++i < n) {\n      a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];\n    }return Math.abs(area);\n  }\n  function merge (topology) {\n    return object(topology, mergeArcs.apply(this, arguments));\n  }\n  function mergeArcs(topology, objects) {\n    var polygonsByArc = {},\n        polygons = [],\n        groups = [];\n    objects.forEach(geometry);\n    function geometry(o) {\n      switch (o.type) {\n        case \"GeometryCollection\":\n          o.geometries.forEach(geometry);break;\n        case \"Polygon\":\n          extract(o.arcs);break;\n        case \"MultiPolygon\":\n          o.arcs.forEach(extract);break;\n      }\n    }\n    function extract(polygon) {\n      polygon.forEach(function (ring) {\n        ring.forEach(function (arc) {\n          (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);\n        });\n      });\n      polygons.push(polygon);\n    }\n    function area(ring) {\n      return planarRingArea(object(topology, { type: \"Polygon\", arcs: [ring] }).coordinates[0]);\n    }\n    polygons.forEach(function (polygon) {\n      if (!polygon._) {\n        var group = [],\n            neighbors = [polygon];\n        polygon._ = 1;\n        groups.push(group);\n        while (polygon = neighbors.pop()) {\n          group.push(polygon);\n          polygon.forEach(function (ring) {\n            ring.forEach(function (arc) {\n              polygonsByArc[arc < 0 ? ~arc : arc].forEach(function (polygon) {\n                if (!polygon._) {\n                  polygon._ = 1;\n                  neighbors.push(polygon);\n                }\n              });\n            });\n          });\n        }\n      }\n    });\n    polygons.forEach(function (polygon) {\n      delete polygon._;\n    });\n    return {\n      type: \"MultiPolygon\",\n      arcs: groups.map(function (polygons) {\n        var arcs = [],\n            n;\n        polygons.forEach(function (polygon) {\n          polygon.forEach(function (ring) {\n            ring.forEach(function (arc) {\n              if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {\n                arcs.push(arc);\n              }\n            });\n          });\n        });\n        arcs = stitch(topology, arcs);\n        if ((n = arcs.length) > 1) {\n          for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {\n            if ((ki = area(arcs[i])) > k) {\n              t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;\n            }\n          }\n        }\n        return arcs;\n      })\n    };\n  }\n\n  function bounds (objects) {\n    var x0 = Infinity,\n        y0 = Infinity,\n        x1 = -Infinity,\n        y1 = -Infinity;\n    function boundGeometry(geometry) {\n      if (geometry != null && boundGeometryType.hasOwnProperty(geometry.type)) boundGeometryType[geometry.type](geometry);\n    }\n    var boundGeometryType = {\n      GeometryCollection: function GeometryCollection(o) {\n        o.geometries.forEach(boundGeometry);\n      },\n      Point: function Point(o) {\n        boundPoint(o.coordinates);\n      },\n      MultiPoint: function MultiPoint(o) {\n        o.coordinates.forEach(boundPoint);\n      },\n      LineString: function LineString(o) {\n        boundLine(o.arcs);\n      },\n      MultiLineString: function MultiLineString(o) {\n        o.arcs.forEach(boundLine);\n      },\n      Polygon: function Polygon(o) {\n        o.arcs.forEach(boundLine);\n      },\n      MultiPolygon: function MultiPolygon(o) {\n        o.arcs.forEach(boundMultiLine);\n      }\n    };\n    function boundPoint(coordinates) {\n      var x = coordinates[0],\n          y = coordinates[1];\n      if (x < x0) x0 = x;\n      if (x > x1) x1 = x;\n      if (y < y0) y0 = y;\n      if (y > y1) y1 = y;\n    }\n    function boundLine(coordinates) {\n      coordinates.forEach(boundPoint);\n    }\n    function boundMultiLine(coordinates) {\n      coordinates.forEach(boundLine);\n    }\n    for (var key in objects) {\n      boundGeometry(objects[key]);\n    }\n    return x1 >= x0 && y1 >= y0 ? [x0, y0, x1, y1] : undefined;\n  }\n\n  function hashset (size, hash, equal, type, empty) {\n    if (arguments.length === 3) {\n      type = Array;\n      empty = null;\n    }\n    var store = new type(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))),\n        mask = size - 1;\n    for (var i = 0; i < size; ++i) {\n      store[i] = empty;\n    }\n    function add(value) {\n      var index = hash(value) & mask,\n          match = store[index],\n          collisions = 0;\n      while (match != empty) {\n        if (equal(match, value)) return true;\n        if (++collisions >= size) throw new Error(\"full hashset\");\n        match = store[index = index + 1 & mask];\n      }\n      store[index] = value;\n      return true;\n    }\n    function has(value) {\n      var index = hash(value) & mask,\n          match = store[index],\n          collisions = 0;\n      while (match != empty) {\n        if (equal(match, value)) return true;\n        if (++collisions >= size) break;\n        match = store[index = index + 1 & mask];\n      }\n      return false;\n    }\n    function values() {\n      var values = [];\n      for (var i = 0, n = store.length; i < n; ++i) {\n        var match = store[i];\n        if (match != empty) values.push(match);\n      }\n      return values;\n    }\n    return {\n      add: add,\n      has: has,\n      values: values\n    };\n  }\n\n  function hashmap (size, hash, equal, keyType, keyEmpty, valueType) {\n    if (arguments.length === 3) {\n      keyType = valueType = Array;\n      keyEmpty = null;\n    }\n    var keystore = new keyType(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))),\n        valstore = new valueType(size),\n        mask = size - 1;\n    for (var i = 0; i < size; ++i) {\n      keystore[i] = keyEmpty;\n    }\n    function set(key, value) {\n      var index = hash(key) & mask,\n          matchKey = keystore[index],\n          collisions = 0;\n      while (matchKey != keyEmpty) {\n        if (equal(matchKey, key)) return valstore[index] = value;\n        if (++collisions >= size) throw new Error(\"full hashmap\");\n        matchKey = keystore[index = index + 1 & mask];\n      }\n      keystore[index] = key;\n      valstore[index] = value;\n      return value;\n    }\n    function maybeSet(key, value) {\n      var index = hash(key) & mask,\n          matchKey = keystore[index],\n          collisions = 0;\n      while (matchKey != keyEmpty) {\n        if (equal(matchKey, key)) return valstore[index];\n        if (++collisions >= size) throw new Error(\"full hashmap\");\n        matchKey = keystore[index = index + 1 & mask];\n      }\n      keystore[index] = key;\n      valstore[index] = value;\n      return value;\n    }\n    function get(key, missingValue) {\n      var index = hash(key) & mask,\n          matchKey = keystore[index],\n          collisions = 0;\n      while (matchKey != keyEmpty) {\n        if (equal(matchKey, key)) return valstore[index];\n        if (++collisions >= size) break;\n        matchKey = keystore[index = index + 1 & mask];\n      }\n      return missingValue;\n    }\n    function keys() {\n      var keys = [];\n      for (var i = 0, n = keystore.length; i < n; ++i) {\n        var matchKey = keystore[i];\n        if (matchKey != keyEmpty) keys.push(matchKey);\n      }\n      return keys;\n    }\n    return {\n      set: set,\n      maybeSet: maybeSet,\n      get: get,\n      keys: keys\n    };\n  }\n\n  function equalPoint (pointA, pointB) {\n    return pointA[0] === pointB[0] && pointA[1] === pointB[1];\n  }\n\n  var buffer = new ArrayBuffer(16),\n      floats = new Float64Array(buffer),\n      uints = new Uint32Array(buffer);\n  function hashPoint (point) {\n    floats[0] = point[0];\n    floats[1] = point[1];\n    var hash = uints[0] ^ uints[1];\n    hash = hash << 5 ^ hash >> 7 ^ uints[2] ^ uints[3];\n    return hash & 0x7fffffff;\n  }\n\n  function join (topology) {\n    var coordinates = topology.coordinates,\n        lines = topology.lines,\n        rings = topology.rings,\n        indexes = index(),\n        visitedByIndex = new Int32Array(coordinates.length),\n        leftByIndex = new Int32Array(coordinates.length),\n        rightByIndex = new Int32Array(coordinates.length),\n        junctionByIndex = new Int8Array(coordinates.length),\n        junctionCount = 0,\n    i,\n        n,\n        previousIndex,\n        currentIndex,\n        nextIndex;\n    for (i = 0, n = coordinates.length; i < n; ++i) {\n      visitedByIndex[i] = leftByIndex[i] = rightByIndex[i] = -1;\n    }\n    for (i = 0, n = lines.length; i < n; ++i) {\n      var line = lines[i],\n          lineStart = line[0],\n          lineEnd = line[1];\n      currentIndex = indexes[lineStart];\n      nextIndex = indexes[++lineStart];\n      ++junctionCount, junctionByIndex[currentIndex] = 1;\n      while (++lineStart <= lineEnd) {\n        sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[lineStart]);\n      }\n      ++junctionCount, junctionByIndex[nextIndex] = 1;\n    }\n    for (i = 0, n = coordinates.length; i < n; ++i) {\n      visitedByIndex[i] = -1;\n    }\n    for (i = 0, n = rings.length; i < n; ++i) {\n      var ring = rings[i],\n          ringStart = ring[0] + 1,\n          ringEnd = ring[1];\n      previousIndex = indexes[ringEnd - 1];\n      currentIndex = indexes[ringStart - 1];\n      nextIndex = indexes[ringStart];\n      sequence(i, previousIndex, currentIndex, nextIndex);\n      while (++ringStart <= ringEnd) {\n        sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[ringStart]);\n      }\n    }\n    function sequence(i, previousIndex, currentIndex, nextIndex) {\n      if (visitedByIndex[currentIndex] === i) return;\n      visitedByIndex[currentIndex] = i;\n      var leftIndex = leftByIndex[currentIndex];\n      if (leftIndex >= 0) {\n        var rightIndex = rightByIndex[currentIndex];\n        if ((leftIndex !== previousIndex || rightIndex !== nextIndex) && (leftIndex !== nextIndex || rightIndex !== previousIndex)) {\n          ++junctionCount, junctionByIndex[currentIndex] = 1;\n        }\n      } else {\n        leftByIndex[currentIndex] = previousIndex;\n        rightByIndex[currentIndex] = nextIndex;\n      }\n    }\n    function index() {\n      var indexByPoint = hashmap(coordinates.length * 1.4, hashIndex, equalIndex, Int32Array, -1, Int32Array),\n          indexes = new Int32Array(coordinates.length);\n      for (var i = 0, n = coordinates.length; i < n; ++i) {\n        indexes[i] = indexByPoint.maybeSet(i, i);\n      }\n      return indexes;\n    }\n    function hashIndex(i) {\n      return hashPoint(coordinates[i]);\n    }\n    function equalIndex(i, j) {\n      return equalPoint(coordinates[i], coordinates[j]);\n    }\n    visitedByIndex = leftByIndex = rightByIndex = null;\n    var junctionByPoint = hashset(junctionCount * 1.4, hashPoint, equalPoint),\n        j;\n    for (i = 0, n = coordinates.length; i < n; ++i) {\n      if (junctionByIndex[j = indexes[i]]) {\n        junctionByPoint.add(coordinates[j]);\n      }\n    }\n    return junctionByPoint;\n  }\n\n  function cut (topology) {\n    var junctions = join(topology),\n        coordinates = topology.coordinates,\n        lines = topology.lines,\n        rings = topology.rings,\n        next,\n        i,\n        n;\n    for (i = 0, n = lines.length; i < n; ++i) {\n      var line = lines[i],\n          lineMid = line[0],\n          lineEnd = line[1];\n      while (++lineMid < lineEnd) {\n        if (junctions.has(coordinates[lineMid])) {\n          next = { 0: lineMid, 1: line[1] };\n          line[1] = lineMid;\n          line = line.next = next;\n        }\n      }\n    }\n    for (i = 0, n = rings.length; i < n; ++i) {\n      var ring = rings[i],\n          ringStart = ring[0],\n          ringMid = ringStart,\n          ringEnd = ring[1],\n          ringFixed = junctions.has(coordinates[ringStart]);\n      while (++ringMid < ringEnd) {\n        if (junctions.has(coordinates[ringMid])) {\n          if (ringFixed) {\n            next = { 0: ringMid, 1: ring[1] };\n            ring[1] = ringMid;\n            ring = ring.next = next;\n          } else {\n            rotateArray(coordinates, ringStart, ringEnd, ringEnd - ringMid);\n            coordinates[ringEnd] = coordinates[ringStart];\n            ringFixed = true;\n            ringMid = ringStart;\n          }\n        }\n      }\n    }\n    return topology;\n  }\n  function rotateArray(array, start, end, offset) {\n    reverse$1(array, start, end);\n    reverse$1(array, start, start + offset);\n    reverse$1(array, start + offset, end);\n  }\n  function reverse$1(array, start, end) {\n    for (var mid = start + (end-- - start >> 1), t; start < mid; ++start, --end) {\n      t = array[start], array[start] = array[end], array[end] = t;\n    }\n  }\n\n  function dedup$1 (topology) {\n    var coordinates = topology.coordinates,\n        lines = topology.lines,\n        line,\n        rings = topology.rings,\n        ring,\n        arcCount = lines.length + rings.length,\n        i,\n        n;\n    delete topology.lines;\n    delete topology.rings;\n    for (i = 0, n = lines.length; i < n; ++i) {\n      line = lines[i];while (line = line.next) {\n        ++arcCount;\n      }\n    }\n    for (i = 0, n = rings.length; i < n; ++i) {\n      ring = rings[i];while (ring = ring.next) {\n        ++arcCount;\n      }\n    }\n    var arcsByEnd = hashmap(arcCount * 2 * 1.4, hashPoint, equalPoint),\n        arcs = topology.arcs = [];\n    for (i = 0, n = lines.length; i < n; ++i) {\n      line = lines[i];\n      do {\n        dedupLine(line);\n      } while (line = line.next);\n    }\n    for (i = 0, n = rings.length; i < n; ++i) {\n      ring = rings[i];\n      if (ring.next) {\n        do {\n          dedupLine(ring);\n        } while (ring = ring.next);\n      } else {\n        dedupRing(ring);\n      }\n    }\n    function dedupLine(arc) {\n      var startPoint, endPoint, startArcs, startArc, endArcs, endArc, i, n;\n      if (startArcs = arcsByEnd.get(startPoint = coordinates[arc[0]])) {\n        for (i = 0, n = startArcs.length; i < n; ++i) {\n          startArc = startArcs[i];\n          if (equalLine(startArc, arc)) {\n            arc[0] = startArc[0];\n            arc[1] = startArc[1];\n            return;\n          }\n        }\n      }\n      if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[1]])) {\n        for (i = 0, n = endArcs.length; i < n; ++i) {\n          endArc = endArcs[i];\n          if (reverseEqualLine(endArc, arc)) {\n            arc[1] = endArc[0];\n            arc[0] = endArc[1];\n            return;\n          }\n        }\n      }\n      if (startArcs) startArcs.push(arc);else arcsByEnd.set(startPoint, [arc]);\n      if (endArcs) endArcs.push(arc);else arcsByEnd.set(endPoint, [arc]);\n      arcs.push(arc);\n    }\n    function dedupRing(arc) {\n      var endPoint, endArcs, endArc, i, n;\n      if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0]])) {\n        for (i = 0, n = endArcs.length; i < n; ++i) {\n          endArc = endArcs[i];\n          if (equalRing(endArc, arc)) {\n            arc[0] = endArc[0];\n            arc[1] = endArc[1];\n            return;\n          }\n          if (reverseEqualRing(endArc, arc)) {\n            arc[0] = endArc[1];\n            arc[1] = endArc[0];\n            return;\n          }\n        }\n      }\n      if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0] + findMinimumOffset(arc)])) {\n        for (i = 0, n = endArcs.length; i < n; ++i) {\n          endArc = endArcs[i];\n          if (equalRing(endArc, arc)) {\n            arc[0] = endArc[0];\n            arc[1] = endArc[1];\n            return;\n          }\n          if (reverseEqualRing(endArc, arc)) {\n            arc[0] = endArc[1];\n            arc[1] = endArc[0];\n            return;\n          }\n        }\n      }\n      if (endArcs) endArcs.push(arc);else arcsByEnd.set(endPoint, [arc]);\n      arcs.push(arc);\n    }\n    function equalLine(arcA, arcB) {\n      var ia = arcA[0],\n          ib = arcB[0],\n          ja = arcA[1],\n          jb = arcB[1];\n      if (ia - ja !== ib - jb) return false;\n      for (; ia <= ja; ++ia, ++ib) {\n        if (!equalPoint(coordinates[ia], coordinates[ib])) return false;\n      }return true;\n    }\n    function reverseEqualLine(arcA, arcB) {\n      var ia = arcA[0],\n          ib = arcB[0],\n          ja = arcA[1],\n          jb = arcB[1];\n      if (ia - ja !== ib - jb) return false;\n      for (; ia <= ja; ++ia, --jb) {\n        if (!equalPoint(coordinates[ia], coordinates[jb])) return false;\n      }return true;\n    }\n    function equalRing(arcA, arcB) {\n      var ia = arcA[0],\n          ib = arcB[0],\n          ja = arcA[1],\n          jb = arcB[1],\n          n = ja - ia;\n      if (n !== jb - ib) return false;\n      var ka = findMinimumOffset(arcA),\n          kb = findMinimumOffset(arcB);\n      for (var i = 0; i < n; ++i) {\n        if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[ib + (i + kb) % n])) return false;\n      }\n      return true;\n    }\n    function reverseEqualRing(arcA, arcB) {\n      var ia = arcA[0],\n          ib = arcB[0],\n          ja = arcA[1],\n          jb = arcB[1],\n          n = ja - ia;\n      if (n !== jb - ib) return false;\n      var ka = findMinimumOffset(arcA),\n          kb = n - findMinimumOffset(arcB);\n      for (var i = 0; i < n; ++i) {\n        if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[jb - (i + kb) % n])) return false;\n      }\n      return true;\n    }\n    function findMinimumOffset(arc) {\n      var start = arc[0],\n          end = arc[1],\n          mid = start,\n          minimum = mid,\n          minimumPoint = coordinates[mid];\n      while (++mid < end) {\n        var point = coordinates[mid];\n        if (point[0] < minimumPoint[0] || point[0] === minimumPoint[0] && point[1] < minimumPoint[1]) {\n          minimum = mid;\n          minimumPoint = point;\n        }\n      }\n      return minimum - start;\n    }\n    return topology;\n  }\n\n  function delta (arcs) {\n    var i = -1,\n        n = arcs.length;\n    while (++i < n) {\n      var arc = arcs[i],\n          j = 0,\n          k = 1,\n          m = arc.length,\n          point = arc[0],\n          x0 = point[0],\n          y0 = point[1],\n          x1,\n          y1;\n      while (++j < m) {\n        point = arc[j], x1 = point[0], y1 = point[1];\n        if (x1 !== x0 || y1 !== y0) arc[k++] = [x1 - x0, y1 - y0], x0 = x1, y0 = y1;\n      }\n      if (k === 1) arc[k++] = [0, 0];\n      arc.length = k;\n    }\n    return arcs;\n  }\n\n  function extract (objects) {\n    var index = -1,\n        lines = [],\n        rings = [],\n        coordinates = [];\n    function extractGeometry(geometry) {\n      if (geometry && extractGeometryType.hasOwnProperty(geometry.type)) extractGeometryType[geometry.type](geometry);\n    }\n    var extractGeometryType = {\n      GeometryCollection: function GeometryCollection(o) {\n        o.geometries.forEach(extractGeometry);\n      },\n      LineString: function LineString(o) {\n        o.arcs = extractLine(o.arcs);\n      },\n      MultiLineString: function MultiLineString(o) {\n        o.arcs = o.arcs.map(extractLine);\n      },\n      Polygon: function Polygon(o) {\n        o.arcs = o.arcs.map(extractRing);\n      },\n      MultiPolygon: function MultiPolygon(o) {\n        o.arcs = o.arcs.map(extractMultiRing);\n      }\n    };\n    function extractLine(line) {\n      for (var i = 0, n = line.length; i < n; ++i) {\n        coordinates[++index] = line[i];\n      }var arc = { 0: index - n + 1, 1: index };\n      lines.push(arc);\n      return arc;\n    }\n    function extractRing(ring) {\n      for (var i = 0, n = ring.length; i < n; ++i) {\n        coordinates[++index] = ring[i];\n      }var arc = { 0: index - n + 1, 1: index };\n      rings.push(arc);\n      return arc;\n    }\n    function extractMultiRing(rings) {\n      return rings.map(extractRing);\n    }\n    for (var key in objects) {\n      extractGeometry(objects[key]);\n    }\n    return {\n      type: \"Topology\",\n      coordinates: coordinates,\n      lines: lines,\n      rings: rings,\n      objects: objects\n    };\n  }\n\n  function geometry$1 (inputs) {\n    var outputs = {},\n        key;\n    for (key in inputs) {\n      outputs[key] = geomifyObject(inputs[key]);\n    }return outputs;\n  }\n  function geomifyObject(input) {\n    return input == null ? { type: null } : (input.type === \"FeatureCollection\" ? geomifyFeatureCollection : input.type === \"Feature\" ? geomifyFeature : geomifyGeometry)(input);\n  }\n  function geomifyFeatureCollection(input) {\n    var output = { type: \"GeometryCollection\", geometries: input.features.map(geomifyFeature) };\n    if (input.bbox != null) output.bbox = input.bbox;\n    return output;\n  }\n  function geomifyFeature(input) {\n    var output = geomifyGeometry(input.geometry),\n        key;\n    if (input.id != null) output.id = input.id;\n    if (input.bbox != null) output.bbox = input.bbox;\n    for (key in input.properties) {\n      output.properties = input.properties;break;\n    }\n    return output;\n  }\n  function geomifyGeometry(input) {\n    if (input == null) return { type: null };\n    var output = input.type === \"GeometryCollection\" ? { type: \"GeometryCollection\", geometries: input.geometries.map(geomifyGeometry) } : input.type === \"Point\" || input.type === \"MultiPoint\" ? { type: input.type, coordinates: input.coordinates } : { type: input.type, arcs: input.coordinates };\n    if (input.bbox != null) output.bbox = input.bbox;\n    return output;\n  }\n\n  function prequantize (objects, bbox, n) {\n    var x0 = bbox[0],\n        y0 = bbox[1],\n        x1 = bbox[2],\n        y1 = bbox[3],\n        kx = x1 - x0 ? (n - 1) / (x1 - x0) : 1,\n        ky = y1 - y0 ? (n - 1) / (y1 - y0) : 1;\n    function quantizePoint(input) {\n      return [Math.round((input[0] - x0) * kx), Math.round((input[1] - y0) * ky)];\n    }\n    function quantizePoints(input, m) {\n      var i = -1,\n          j = 0,\n          n = input.length,\n          output = new Array(n),\n      pi,\n          px,\n          py,\n          x,\n          y;\n      while (++i < n) {\n        pi = input[i];\n        x = Math.round((pi[0] - x0) * kx);\n        y = Math.round((pi[1] - y0) * ky);\n        if (x !== px || y !== py) output[j++] = [px = x, py = y];\n      }\n      output.length = j;\n      while (j < m) {\n        j = output.push([output[0][0], output[0][1]]);\n      }return output;\n    }\n    function quantizeLine(input) {\n      return quantizePoints(input, 2);\n    }\n    function quantizeRing(input) {\n      return quantizePoints(input, 4);\n    }\n    function quantizePolygon(input) {\n      return input.map(quantizeRing);\n    }\n    function quantizeGeometry(o) {\n      if (o != null && quantizeGeometryType.hasOwnProperty(o.type)) quantizeGeometryType[o.type](o);\n    }\n    var quantizeGeometryType = {\n      GeometryCollection: function GeometryCollection(o) {\n        o.geometries.forEach(quantizeGeometry);\n      },\n      Point: function Point(o) {\n        o.coordinates = quantizePoint(o.coordinates);\n      },\n      MultiPoint: function MultiPoint(o) {\n        o.coordinates = o.coordinates.map(quantizePoint);\n      },\n      LineString: function LineString(o) {\n        o.arcs = quantizeLine(o.arcs);\n      },\n      MultiLineString: function MultiLineString(o) {\n        o.arcs = o.arcs.map(quantizeLine);\n      },\n      Polygon: function Polygon(o) {\n        o.arcs = quantizePolygon(o.arcs);\n      },\n      MultiPolygon: function MultiPolygon(o) {\n        o.arcs = o.arcs.map(quantizePolygon);\n      }\n    };\n    for (var key in objects) {\n      quantizeGeometry(objects[key]);\n    }\n    return {\n      scale: [1 / kx, 1 / ky],\n      translate: [x0, y0]\n    };\n  }\n\n  function topology (objects, quantization) {\n    var bbox = bounds(objects = geometry$1(objects)),\n        transform = quantization > 0 && bbox && prequantize(objects, bbox, quantization),\n        topology = dedup$1(cut(extract(objects))),\n        coordinates = topology.coordinates,\n        indexByArc = hashmap(topology.arcs.length * 1.4, hashArc, equalArc);\n    objects = topology.objects;\n    topology.bbox = bbox;\n    topology.arcs = topology.arcs.map(function (arc, i) {\n      indexByArc.set(arc, i);\n      return coordinates.slice(arc[0], arc[1] + 1);\n    });\n    delete topology.coordinates;\n    coordinates = null;\n    function indexGeometry(geometry) {\n      if (geometry && indexGeometryType.hasOwnProperty(geometry.type)) indexGeometryType[geometry.type](geometry);\n    }\n    var indexGeometryType = {\n      GeometryCollection: function GeometryCollection(o) {\n        o.geometries.forEach(indexGeometry);\n      },\n      LineString: function LineString(o) {\n        o.arcs = indexArcs(o.arcs);\n      },\n      MultiLineString: function MultiLineString(o) {\n        o.arcs = o.arcs.map(indexArcs);\n      },\n      Polygon: function Polygon(o) {\n        o.arcs = o.arcs.map(indexArcs);\n      },\n      MultiPolygon: function MultiPolygon(o) {\n        o.arcs = o.arcs.map(indexMultiArcs);\n      }\n    };\n    function indexArcs(arc) {\n      var indexes = [];\n      do {\n        var index = indexByArc.get(arc);\n        indexes.push(arc[0] < arc[1] ? index : ~index);\n      } while (arc = arc.next);\n      return indexes;\n    }\n    function indexMultiArcs(arcs) {\n      return arcs.map(indexArcs);\n    }\n    for (var key in objects) {\n      indexGeometry(objects[key]);\n    }\n    if (transform) {\n      topology.transform = transform;\n      topology.arcs = delta(topology.arcs);\n    }\n    return topology;\n  }\n  function hashArc(arc) {\n    var i = arc[0],\n        j = arc[1],\n        t;\n    if (j < i) t = i, i = j, j = t;\n    return i + 31 * j;\n  }\n  function equalArc(arcA, arcB) {\n    var ia = arcA[0],\n        ja = arcA[1],\n        ib = arcB[0],\n        jb = arcB[1],\n        t;\n    if (ja < ia) t = ia, ia = ja, ja = t;\n    if (jb < ib) t = ib, ib = jb, jb = t;\n    return ia === ib && ja === jb;\n  }\n\n  function polygonDissolve(geojson, options) {\n      options = options || {};\n      if (!isObject$1(options)) throw new Error('options is invalid');\n      var mutate = options.mutate;\n      if (getType(geojson) !== 'FeatureCollection') throw new Error('geojson must be a FeatureCollection');\n      if (!geojson.features.length) throw new Error('geojson is empty');\n      if (mutate === false || mutate === undefined) geojson = clone(geojson);\n      var geoms = [];\n      flattenEach(geojson, function (feature$$1) {\n          geoms.push(feature$$1.geometry);\n      });\n      var topo = topology({ geoms: geometryCollection(geoms).geometry });\n      return merge(topo, topo.objects.geoms.geometries);\n  }\n\n  function dissolve(geojson, options) {\n      options = options || {};\n      if (!isObject$1(options)) throw new Error('options is invalid');\n      var mutate = options.mutate;\n      if (getType(geojson) !== 'FeatureCollection') throw new Error('geojson must be a FeatureCollection');\n      if (!geojson.features.length) throw new Error('geojson is empty');\n      if (mutate === false || mutate === undefined) geojson = clone(geojson);\n      var type = getHomogenousType(geojson);\n      if (!type) throw new Error('geojson must be homogenous');\n      switch (type) {\n          case 'LineString':\n              return lineDissolve(geojson, options);\n          case 'Polygon':\n              return polygonDissolve(geojson, options);\n          default:\n              throw new Error(type + ' is not supported');\n      }\n  }\n  function getHomogenousType(geojson) {\n      var types = {};\n      flattenEach(geojson, function (feature$$1) {\n          types[feature$$1.geometry.type] = true;\n      });\n      var keys = Object.keys(types);\n      if (keys.length === 1) return keys[0];\n      return null;\n  }\n\n  function distance(from, to, options) {\n    options = options || {};\n    if (!isObject$1(options)) throw new Error('options is invalid');\n    var units = options.units;\n    var coordinates1 = getCoord(from);\n    var coordinates2 = getCoord(to);\n    var dLat = degreesToRadians(coordinates2[1] - coordinates1[1]);\n    var dLon = degreesToRadians(coordinates2[0] - coordinates1[0]);\n    var lat1 = degreesToRadians(coordinates1[1]);\n    var lat2 = degreesToRadians(coordinates2[1]);\n    var a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n    return radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), units);\n  }\n\n  function concave(points, options) {\n      options = options || {};\n      if (!isObject$1(options)) throw new Error('options is invalid');\n      if (!points) throw new Error('points is required');\n      var maxEdge = options.maxEdge || Infinity;\n      if (!isNumber(maxEdge)) throw new Error('maxEdge is invalid');\n      var cleaned = removeDuplicates(points);\n      var tinPolys = tin(cleaned);\n      tinPolys.features = tinPolys.features.filter(function (triangle) {\n          var pt1 = triangle.geometry.coordinates[0][0];\n          var pt2 = triangle.geometry.coordinates[0][1];\n          var pt3 = triangle.geometry.coordinates[0][2];\n          var dist1 = distance(pt1, pt2, options);\n          var dist2 = distance(pt2, pt3, options);\n          var dist3 = distance(pt1, pt3, options);\n          return dist1 <= maxEdge && dist2 <= maxEdge && dist3 <= maxEdge;\n      });\n      if (tinPolys.features.length < 1) return null;\n      var dissolved = dissolve(tinPolys, options);\n      if (dissolved.coordinates.length === 1) {\n          dissolved.coordinates = dissolved.coordinates[0];\n          dissolved.type = 'Polygon';\n      }\n      return feature(dissolved);\n  }\n  function removeDuplicates(points) {\n      var cleaned = [];\n      var existing = {};\n      featureEach(points, function (pt) {\n          if (!pt.geometry) return;\n          var key = pt.geometry.coordinates.join('-');\n          if (!existing.hasOwnProperty(key)) {\n              cleaned.push(pt);\n              existing[key] = true;\n          }\n      });\n      return featureCollection(cleaned);\n  }\n\n  function concave$1(latLngArray, maxEdge, units) {\n    var FeatureCollection = arrayToFeaturePoints(latLngArray);\n    return concave(FeatureCollection, {\n      maxEdge: maxEdge,\n      units: units\n    });\n  }\n\n  function feature$3(geometry, properties, options) {\n      options = options || {};\n      if (!isObject$2(options)) throw new Error('options is invalid');\n      var bbox = options.bbox;\n      var id = options.id;\n      if (geometry === undefined) throw new Error('geometry is required');\n      if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n      if (bbox) validateBBox(bbox);\n      if (id) validateId(id);\n      var feat = { type: 'Feature' };\n      if (id) feat.id = id;\n      if (bbox) feat.bbox = bbox;\n      feat.properties = properties || {};\n      feat.geometry = geometry;\n      return feat;\n  }\n  function isNumber$1(num) {\n      return !isNaN(num) && num !== null && !Array.isArray(num);\n  }\n  function isObject$2(input) {\n      return !!input && input.constructor === Object;\n  }\n  function validateBBox(bbox) {\n      if (!bbox) throw new Error('bbox is required');\n      if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n      if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n      bbox.forEach(function (num) {\n          if (!isNumber$1(num)) throw new Error('bbox must only contain numbers');\n      });\n  }\n  function validateId(id) {\n      if (!id) throw new Error('id is required');\n      if (['string', 'number'].indexOf(typeof id === 'undefined' ? 'undefined' : _typeof(id)) === -1) throw new Error('id must be a number or a string');\n  }\n\n  function getCoords$1(coords) {\n      if (!coords) throw new Error('coords is required');\n      if (coords.type === 'Feature' && coords.geometry !== null) return coords.geometry.coordinates;\n      if (coords.coordinates) return coords.coordinates;\n      if (Array.isArray(coords)) return coords;\n      throw new Error('coords must be GeoJSON Feature, Geometry Object or an Array');\n  }\n  function getType$1(geojson, name) {\n      if (!geojson) throw new Error((name || 'geojson') + ' is required');\n      if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n      if (geojson.type) return geojson.type;\n      throw new Error((name || 'geojson') + ' is invalid');\n  }\n\n  function cleanCoords(geojson, options) {\n      var mutate = (typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object' ? options.mutate : options;\n      if (!geojson) throw new Error('geojson is required');\n      var type = getType$1(geojson);\n      var newCoords = [];\n      switch (type) {\n          case 'LineString':\n              newCoords = cleanLine(geojson);\n              break;\n          case 'MultiLineString':\n          case 'Polygon':\n              getCoords$1(geojson).forEach(function (line) {\n                  newCoords.push(cleanLine(line));\n              });\n              break;\n          case 'MultiPolygon':\n              getCoords$1(geojson).forEach(function (polygons$$1) {\n                  var polyPoints = [];\n                  polygons$$1.forEach(function (ring) {\n                      polyPoints.push(cleanLine(ring));\n                  });\n                  newCoords.push(polyPoints);\n              });\n              break;\n          case 'Point':\n              return geojson;\n          case 'MultiPoint':\n              var existing = {};\n              getCoords$1(geojson).forEach(function (coord) {\n                  var key = coord.join('-');\n                  if (!existing.hasOwnProperty(key)) {\n                      newCoords.push(coord);\n                      existing[key] = true;\n                  }\n              });\n              break;\n          default:\n              throw new Error(type + ' geometry not supported');\n      }\n      if (geojson.coordinates) {\n          if (mutate === true) {\n              geojson.coordinates = newCoords;\n              return geojson;\n          }\n          return { type: type, coordinates: newCoords };\n      } else {\n          if (mutate === true) {\n              geojson.geometry.coordinates = newCoords;\n              return geojson;\n          }\n          return feature$3({ type: type, coordinates: newCoords }, geojson.properties, geojson.bbox, geojson.id);\n      }\n  }\n  function cleanLine(line) {\n      var points$$1 = getCoords$1(line);\n      if (points$$1.length === 2 && !equals(points$$1[0], points$$1[1])) return points$$1;\n      var prevPoint, point, nextPoint;\n      var newPoints = [];\n      var secondToLast = points$$1.length - 1;\n      newPoints.push(points$$1[0]);\n      for (var i = 1; i < secondToLast; i++) {\n          prevPoint = points$$1[i - 1];\n          point = points$$1[i];\n          nextPoint = points$$1[i + 1];\n          if (!isPointOnLineSegment(prevPoint, nextPoint, point)) {\n              newPoints.push(point);\n          }\n      }\n      newPoints.push(nextPoint);\n      return newPoints;\n  }\n  function equals(pt1, pt2) {\n      return pt1[0] === pt2[0] && pt1[1] === pt2[1];\n  }\n  function isPointOnLineSegment(start, end, point) {\n      var x = point[0],\n          y = point[1];\n      var startX = start[0],\n          startY = start[1];\n      var endX = end[0],\n          endY = end[1];\n      var dxc = x - startX;\n      var dyc = y - startY;\n      var dxl = endX - startX;\n      var dyl = endY - startY;\n      var cross = dxc * dyl - dyc * dxl;\n      if (cross !== 0) return false;else if (Math.abs(dxl) >= Math.abs(dyl)) return dxl > 0 ? startX <= x && x <= endX : endX <= x && x <= startX;else return dyl > 0 ? startY <= y && y <= endY : endY <= y && y <= startY;\n  }\n\n  function clone$1(geojson) {\n      if (!geojson) throw new Error('geojson is required');\n      switch (geojson.type) {\n          case 'Feature':\n              return cloneFeature$1(geojson);\n          case 'FeatureCollection':\n              return cloneFeatureCollection$1(geojson);\n          case 'Point':\n          case 'LineString':\n          case 'Polygon':\n          case 'MultiPoint':\n          case 'MultiLineString':\n          case 'MultiPolygon':\n          case 'GeometryCollection':\n              return cloneGeometry$1(geojson);\n          default:\n              throw new Error('unknown GeoJSON type');\n      }\n  }\n  function cloneFeature$1(geojson) {\n      var cloned = { type: 'Feature' };\n      Object.keys(geojson).forEach(function (key) {\n          switch (key) {\n              case 'type':\n              case 'properties':\n              case 'geometry':\n                  return;\n              default:\n                  cloned[key] = geojson[key];\n          }\n      });\n      cloned.properties = cloneProperties$1(geojson.properties);\n      cloned.geometry = cloneGeometry$1(geojson.geometry);\n      return cloned;\n  }\n  function cloneProperties$1(properties) {\n      var cloned = {};\n      if (!properties) return cloned;\n      Object.keys(properties).forEach(function (key) {\n          var value = properties[key];\n          if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\n              if (value === null) {\n                  cloned[key] = null;\n              } else if (value.length) {\n                  cloned[key] = value.map(function (item) {\n                      return item;\n                  });\n              } else {\n                  cloned[key] = cloneProperties$1(value);\n              }\n          } else cloned[key] = value;\n      });\n      return cloned;\n  }\n  function cloneFeatureCollection$1(geojson) {\n      var cloned = { type: 'FeatureCollection' };\n      Object.keys(geojson).forEach(function (key) {\n          switch (key) {\n              case 'type':\n              case 'features':\n                  return;\n              default:\n                  cloned[key] = geojson[key];\n          }\n      });\n      cloned.features = geojson.features.map(function (feature) {\n          return cloneFeature$1(feature);\n      });\n      return cloned;\n  }\n  function cloneGeometry$1(geometry) {\n      var geom = { type: geometry.type };\n      if (geometry.bbox) geom.bbox = geometry.bbox;\n      if (geometry.type === 'GeometryCollection') {\n          geom.geometries = geometry.geometries.map(function (geom) {\n              return cloneGeometry$1(geom);\n          });\n          return geom;\n      }\n      geom.coordinates = deepSlice$1(geometry.coordinates);\n      return geom;\n  }\n  function deepSlice$1(coords) {\n      if (_typeof(coords[0]) !== 'object') {\n          return coords.slice();\n      }\n      return coords.map(function (coord) {\n          return deepSlice$1(coord);\n      });\n  }\n\n  function isObject$3(input) {\n      return !!input && input.constructor === Object;\n  }\n\n  function geomEach$1(geojson, callback) {\n      var i,\n          j,\n          g,\n          geometry,\n          stopG,\n          geometryMaybeCollection,\n          isGeometryCollection,\n          featureProperties,\n          featureBBox,\n          featureId,\n          featureIndex = 0,\n          isFeatureCollection = geojson.type === 'FeatureCollection',\n          isFeature = geojson.type === 'Feature',\n          stop = isFeatureCollection ? geojson.features.length : 1;\n      for (i = 0; i < stop; i++) {\n          geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;\n          featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};\n          featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : undefined;\n          featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : undefined;\n          isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n          stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n          for (g = 0; g < stopG; g++) {\n              geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n              if (geometry === null) {\n                  if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                  continue;\n              }\n              switch (geometry.type) {\n                  case 'Point':\n                  case 'LineString':\n                  case 'MultiPoint':\n                  case 'Polygon':\n                  case 'MultiLineString':\n                  case 'MultiPolygon':\n                      {\n                          if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                          break;\n                      }\n                  case 'GeometryCollection':\n                      {\n                          for (j = 0; j < geometry.geometries.length; j++) {\n                              if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                          }\n                          break;\n                      }\n                  default:\n                      throw new Error('Unknown Geometry Type');\n              }\n          }\n          featureIndex++;\n      }\n  }\n\n  function getSqDist(p1, p2) {\n      var dx = p1.x - p2.x,\n          dy = p1.y - p2.y;\n      return dx * dx + dy * dy;\n  }\n  function getSqSegDist(p, p1, p2) {\n      var x = p1.x,\n          y = p1.y,\n          dx = p2.x - x,\n          dy = p2.y - y;\n      if (dx !== 0 || dy !== 0) {\n          var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);\n          if (t > 1) {\n              x = p2.x;\n              y = p2.y;\n          } else if (t > 0) {\n              x += dx * t;\n              y += dy * t;\n          }\n      }\n      dx = p.x - x;\n      dy = p.y - y;\n      return dx * dx + dy * dy;\n  }\n  function simplifyRadialDist(points, sqTolerance) {\n      var prevPoint = points[0],\n          newPoints = [prevPoint],\n          point;\n      for (var i = 1, len = points.length; i < len; i++) {\n          point = points[i];\n          if (getSqDist(point, prevPoint) > sqTolerance) {\n              newPoints.push(point);\n              prevPoint = point;\n          }\n      }\n      if (prevPoint !== point) newPoints.push(point);\n      return newPoints;\n  }\n  function simplifyDPStep(points, first, last, sqTolerance, simplified) {\n      var maxSqDist = sqTolerance,\n          index;\n      for (var i = first + 1; i < last; i++) {\n          var sqDist = getSqSegDist(points[i], points[first], points[last]);\n          if (sqDist > maxSqDist) {\n              index = i;\n              maxSqDist = sqDist;\n          }\n      }\n      if (maxSqDist > sqTolerance) {\n          if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);\n          simplified.push(points[index]);\n          if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);\n      }\n  }\n  function simplifyDouglasPeucker(points, sqTolerance) {\n      var last = points.length - 1;\n      var simplified = [points[0]];\n      simplifyDPStep(points, 0, last, sqTolerance, simplified);\n      simplified.push(points[last]);\n      return simplified;\n  }\n  function simplify$2(points, tolerance, highestQuality) {\n      if (points.length <= 2) return points;\n      var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;\n      points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);\n      points = simplifyDouglasPeucker(points, sqTolerance);\n      return points;\n  }\n  function simplify(geojson, options) {\n      options = options || {};\n      if (!isObject$3(options)) throw new Error('options is invalid');\n      var tolerance = options.tolerance !== undefined ? options.tolerance : 1;\n      var highQuality = options.highQuality || false;\n      var mutate = options.mutate || false;\n      if (!geojson) throw new Error('geojson is required');\n      if (tolerance && tolerance < 0) throw new Error('invalid tolerance');\n      if (mutate !== true) geojson = clone$1(geojson);\n      geomEach$1(geojson, function (geom) {\n          simplifyGeom(geom, tolerance, highQuality);\n      });\n      return geojson;\n  }\n  function simplifyGeom(geometry, tolerance, highQuality) {\n      var type = geometry.type;\n      if (type === 'Point' || type === 'MultiPoint') return geometry;\n      cleanCoords(geometry, true);\n      var coordinates = geometry.coordinates;\n      switch (type) {\n          case 'LineString':\n              geometry['coordinates'] = simplifyLine(coordinates, tolerance, highQuality);\n              break;\n          case 'MultiLineString':\n              geometry['coordinates'] = coordinates.map(function (lines) {\n                  return simplifyLine(lines, tolerance, highQuality);\n              });\n              break;\n          case 'Polygon':\n              geometry['coordinates'] = simplifyPolygon(coordinates, tolerance, highQuality);\n              break;\n          case 'MultiPolygon':\n              geometry['coordinates'] = coordinates.map(function (rings) {\n                  return simplifyPolygon(rings, tolerance, highQuality);\n              });\n      }\n      return geometry;\n  }\n  function simplifyLine(coordinates, tolerance, highQuality) {\n      return simplify$2(coordinates.map(function (coord) {\n          return { x: coord[0], y: coord[1], z: coord[2] };\n      }), tolerance, highQuality).map(function (coords) {\n          return coords.z ? [coords.x, coords.y, coords.z] : [coords.x, coords.y];\n      });\n  }\n  function simplifyPolygon(coordinates, tolerance, highQuality) {\n      return coordinates.map(function (ring) {\n          var pts = ring.map(function (coord) {\n              return { x: coord[0], y: coord[1] };\n          });\n          if (pts.length < 4) {\n              throw new Error('invalid polygon');\n          }\n          var simpleRing = simplify$2(pts, tolerance, highQuality).map(function (coords) {\n              return [coords.x, coords.y];\n          });\n          while (!checkValidity(simpleRing)) {\n              tolerance -= tolerance * 0.01;\n              simpleRing = simplify$2(pts, tolerance, highQuality).map(function (coords) {\n                  return [coords.x, coords.y];\n              });\n          }\n          if (simpleRing[simpleRing.length - 1][0] !== simpleRing[0][0] || simpleRing[simpleRing.length - 1][1] !== simpleRing[0][1]) {\n              simpleRing.push(simpleRing[0]);\n          }\n          return simpleRing;\n      });\n  }\n  function checkValidity(ring) {\n      if (ring.length < 3) return false;\n      return !(ring.length === 3 && ring[2][0] === ring[0][0] && ring[2][1] === ring[0][1]);\n  }\n\n  function simplifyPointArray(coordArray, tolerance, highQuality) {\n  \ttolerance = tolerance || 0.00001;\n  \thighQuality = highQuality || false;\n  \tvar Feature = lineString(toCoords(coordArray));\n  \tvar simplifiedgeom = simplify(Feature, tolerance, highQuality);\n  \treturn simplifiedgeom.geometry.coordinates;\n  }function simplifyFeature(object, output, tolerance, highQuality) {\n  \toutput = (output || 'feature').toLowerCase();\n  \tvar Feature;\n  \tif (object instanceof google.maps.Polyline || object instanceof google.maps.Polygon) {\n  \t\tvar geometry$$1 = Wicket$1().fromObject(object).toJson();\n  \t\tFeature = {\n  \t\t\ttype: \"Feature\",\n  \t\t\tproperties: {},\n  \t\t\tgeometry: geometry$$1\n  \t\t};\n  \t} else if (object.type && object.type === 'Feature' && object.geometry) {\n  \t\tFeature = object;\n  \t} else {\n  \t\tFeature = polygonToFeaturePolygon(object);\n  \t}\n  \tif (Feature.geometry.type === 'MultiPolygon') {\n  \t\tFeature.geometry.type = 'Polygon';\n  \t\tFeature.geometry.coordinates = Feature.geometry.coordinates[0];\n  \t}\n  \tvar simplifiedgeom = simplify(Feature, tolerance, highQuality);\n  \tif (simplifiedgeom && simplifiedgeom.geometry) {\n  \t\tFeature = simplifiedgeom;\n  \t} else {\n  \t\twarn('Cannot simplify  Feature', Feature);\n  \t}\n  \tif (output === 'geometry') {\n  \t\treturn Feature.geometry;\n  \t} else if (output === 'object') {\n  \t\treturn Wicket$1().fromJson(Feature.geometry).toObject();\n  \t} else {\n  \t\treturn Feature;\n  \t}\n  }\n\n  function bearing(start, end, options) {\n      options = options || {};\n      if (!isObject$1(options)) throw new Error('options is invalid');\n      var final = options.final;\n      if (final === true) return calculateFinalBearing(start, end);\n      var coordinates1 = getCoord(start);\n      var coordinates2 = getCoord(end);\n      var lon1 = degreesToRadians(coordinates1[0]);\n      var lon2 = degreesToRadians(coordinates2[0]);\n      var lat1 = degreesToRadians(coordinates1[1]);\n      var lat2 = degreesToRadians(coordinates2[1]);\n      var a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n      var b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n      return radiansToDegrees(Math.atan2(a, b));\n  }\n  function calculateFinalBearing(start, end) {\n      var bear = bearing(end, start);\n      bear = (bear + 180) % 360;\n      return bear;\n  }\n\n  function destination(origin, distance, bearing, options) {\n      options = options || {};\n      if (!isObject$1(options)) throw new Error('options is invalid');\n      var units = options.units;\n      var coordinates1 = getCoord(origin);\n      var longitude1 = degreesToRadians(coordinates1[0]);\n      var latitude1 = degreesToRadians(coordinates1[1]);\n      var bearing_rad = degreesToRadians(bearing);\n      var radians = lengthToRadians(distance, units);\n      var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) + Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearing_rad));\n      var longitude2 = longitude1 + Math.atan2(Math.sin(bearing_rad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));\n      return point([radiansToDegrees(longitude2), radiansToDegrees(latitude2)]);\n  }\n\n  function along(line, distance$$1, options) {\n      options = options || {};\n      if (!isObject$1(options)) throw new Error('options is invalid');\n      var coords;\n      if (line.type === 'Feature') coords = line.geometry.coordinates;else if (line.type === 'LineString') coords = line.coordinates;else throw new Error('input must be a LineString Feature or Geometry');\n      if (!isNumber(distance$$1)) throw new Error('distance must be a number');\n      var travelled = 0;\n      for (var i = 0; i < coords.length; i++) {\n          if (distance$$1 >= travelled && i === coords.length - 1) break;else if (travelled >= distance$$1) {\n              var overshot = distance$$1 - travelled;\n              if (!overshot) return point(coords[i]);else {\n                  var direction = bearing(coords[i], coords[i - 1]) - 180;\n                  var interpolated = destination(coords[i], overshot, direction, options);\n                  return interpolated;\n              }\n          } else {\n              travelled += distance(coords[i], coords[i + 1], options);\n          }\n      }\n      return point(coords[coords.length - 1]);\n  }\n\n  function along$1(object, distance, units) {\n  \tvar Feature;\n  \tif (object instanceof google.maps.Polyline) {\n  \t\tvar geometry$$1 = Wicket$1().fromObject(object).toJson();\n  \t\tFeature = {\n  \t\t\ttype: \"Feature\",\n  \t\t\tproperties: {},\n  \t\t\tgeometry: geometry$$1\n  \t\t};\n  \t} else if (object.type && object.type === 'Feature' && object.geometry) {\n  \t\tFeature = object;\n  \t} else {\n  \t\tvar arrayCoords = toCoords(object);\n  \t\tFeature = lineString(arrayCoords);\n  \t}\n  \treturn along(Feature, distance, units);\n  }\n\n  function extend (target, source) {\n    for (var key in source) {\n      if (source.hasOwnProperty(key)) target[key] = source[key];\n    }\n  }\n\n  function NumberUtil() {}\n  extend(NumberUtil.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn NumberUtil;\n  \t}\n  });\n  NumberUtil.equalsWithTolerance = function (x1, x2, tolerance) {\n  \treturn Math.abs(x1 - x2) <= tolerance;\n  };\n\n  function IllegalArgumentException() {}\n\n  function Double() {}\n  Double.isNaN = function (n) {\n    return Number.isNaN(n);\n  };\n  Double.doubleToLongBits = function (n) {\n    return n;\n  };\n  Double.longBitsToDouble = function (n) {\n    return n;\n  };\n  Double.isInfinite = function (n) {\n    return !Number.isFinite(n);\n  };\n  Double.MAX_VALUE = Number.MAX_VALUE;\n\n  function Comparable() {}\n\n  function Clonable() {}\n\n  function Comparator() {}\n\n  function Serializable() {}\n\n  function RuntimeException(message) {\n    this.name = 'RuntimeException';\n    this.message = message;\n    this.stack = new Error().stack;\n    Error.call(this, message);\n  }\n  RuntimeException.prototype = Object.create(Error.prototype);\n  RuntimeException.prototype.constructor = Error;\n\n  function inherits$1 (c, p) {\n    c.prototype = Object.create(p.prototype);\n    c.prototype.constructor = c;\n  }\n\n  function AssertionFailedException() {\n  \tif (arguments.length === 0) {\n  \t\tRuntimeException.call(this);\n  \t} else if (arguments.length === 1) {\n  \t\tvar message = arguments[0];\n  \t\tRuntimeException.call(this, message);\n  \t}\n  }\n  inherits$1(AssertionFailedException, RuntimeException);\n  extend(AssertionFailedException.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn AssertionFailedException;\n  \t}\n  });\n\n  function Assert() {}\n  extend(Assert.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Assert;\n  \t}\n  });\n  Assert.shouldNeverReachHere = function () {\n  \tif (arguments.length === 0) {\n  \t\tAssert.shouldNeverReachHere(null);\n  \t} else if (arguments.length === 1) {\n  \t\tvar message = arguments[0];\n  \t\tthrow new AssertionFailedException(\"Should never reach here\" + (message !== null ? \": \" + message : \"\"));\n  \t}\n  };\n  Assert.isTrue = function () {\n  \tif (arguments.length === 1) {\n  \t\tvar assertion = arguments[0];\n  \t\tAssert.isTrue(assertion, null);\n  \t} else if (arguments.length === 2) {\n  \t\tvar assertion = arguments[0],\n  \t\t    message = arguments[1];\n  \t\tif (!assertion) {\n  \t\t\tif (message === null) {\n  \t\t\t\tthrow new AssertionFailedException();\n  \t\t\t} else {\n  \t\t\t\tthrow new AssertionFailedException(message);\n  \t\t\t}\n  \t\t}\n  \t}\n  };\n  Assert.equals = function () {\n  \tif (arguments.length === 2) {\n  \t\tvar expectedValue = arguments[0],\n  \t\t    actualValue = arguments[1];\n  \t\tAssert.equals(expectedValue, actualValue, null);\n  \t} else if (arguments.length === 3) {\n  \t\tvar expectedValue = arguments[0],\n  \t\t    actualValue = arguments[1],\n  \t\t    message = arguments[2];\n  \t\tif (!actualValue.equals(expectedValue)) {\n  \t\t\tthrow new AssertionFailedException(\"Expected \" + expectedValue + \" but encountered \" + actualValue + (message !== null ? \": \" + message : \"\"));\n  \t\t}\n  \t}\n  };\n\n  function Coordinate() {\n  \tthis.x = null;\n  \tthis.y = null;\n  \tthis.z = null;\n  \tif (arguments.length === 0) {\n  \t\tCoordinate.call(this, 0.0, 0.0);\n  \t} else if (arguments.length === 1) {\n  \t\tvar c = arguments[0];\n  \t\tCoordinate.call(this, c.x, c.y, c.z);\n  \t} else if (arguments.length === 2) {\n  \t\tvar x = arguments[0],\n  \t\t    y = arguments[1];\n  \t\tCoordinate.call(this, x, y, Coordinate.NULL_ORDINATE);\n  \t} else if (arguments.length === 3) {\n  \t\tvar x = arguments[0],\n  \t\t    y = arguments[1],\n  \t\t    z = arguments[2];\n  \t\tthis.x = x;\n  \t\tthis.y = y;\n  \t\tthis.z = z;\n  \t}\n  }\n  extend(Coordinate.prototype, {\n  \tsetOrdinate: function setOrdinate(ordinateIndex, value) {\n  \t\tswitch (ordinateIndex) {\n  \t\t\tcase Coordinate.X:\n  \t\t\t\tthis.x = value;\n  \t\t\t\tbreak;\n  \t\t\tcase Coordinate.Y:\n  \t\t\t\tthis.y = value;\n  \t\t\t\tbreak;\n  \t\t\tcase Coordinate.Z:\n  \t\t\t\tthis.z = value;\n  \t\t\t\tbreak;\n  \t\t\tdefault:\n  \t\t\t\tthrow new IllegalArgumentException(\"Invalid ordinate index: \" + ordinateIndex);\n  \t\t}\n  \t},\n  \tequals2D: function equals2D() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar other = arguments[0];\n  \t\t\tif (this.x !== other.x) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t\tif (this.y !== other.y) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t\treturn true;\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar c = arguments[0],\n  \t\t\t    tolerance = arguments[1];\n  \t\t\tif (!NumberUtil.equalsWithTolerance(this.x, c.x, tolerance)) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t\tif (!NumberUtil.equalsWithTolerance(this.y, c.y, tolerance)) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t\treturn true;\n  \t\t}\n  \t},\n  \tgetOrdinate: function getOrdinate(ordinateIndex) {\n  \t\tswitch (ordinateIndex) {\n  \t\t\tcase Coordinate.X:\n  \t\t\t\treturn this.x;\n  \t\t\tcase Coordinate.Y:\n  \t\t\t\treturn this.y;\n  \t\t\tcase Coordinate.Z:\n  \t\t\t\treturn this.z;\n  \t\t}\n  \t\tthrow new IllegalArgumentException(\"Invalid ordinate index: \" + ordinateIndex);\n  \t},\n  \tequals3D: function equals3D(other) {\n  \t\treturn this.x === other.x && this.y === other.y && (this.z === other.z || Double.isNaN(this.z) && Double.isNaN(other.z));\n  \t},\n  \tequals: function equals(other) {\n  \t\tif (!(other instanceof Coordinate)) {\n  \t\t\treturn false;\n  \t\t}\n  \t\treturn this.equals2D(other);\n  \t},\n  \tequalInZ: function equalInZ(c, tolerance) {\n  \t\treturn NumberUtil.equalsWithTolerance(this.z, c.z, tolerance);\n  \t},\n  \tcompareTo: function compareTo(o) {\n  \t\tvar other = o;\n  \t\tif (this.x < other.x) return -1;\n  \t\tif (this.x > other.x) return 1;\n  \t\tif (this.y < other.y) return -1;\n  \t\tif (this.y > other.y) return 1;\n  \t\treturn 0;\n  \t},\n  \tclone: function clone() {\n  \t\ttry {\n  \t\t\tvar coord = null;\n  \t\t\treturn coord;\n  \t\t} catch (e) {\n  \t\t\tif (e instanceof CloneNotSupportedException) {\n  \t\t\t\tAssert.shouldNeverReachHere(\"this shouldn't happen because this class is Cloneable\");\n  \t\t\t\treturn null;\n  \t\t\t} else throw e;\n  \t\t} finally {}\n  \t},\n  \tcopy: function copy() {\n  \t\treturn new Coordinate(this);\n  \t},\n  \ttoString: function toString() {\n  \t\treturn \"(\" + this.x + \", \" + this.y + \", \" + this.z + \")\";\n  \t},\n  \tdistance3D: function distance3D(c) {\n  \t\tvar dx = this.x - c.x;\n  \t\tvar dy = this.y - c.y;\n  \t\tvar dz = this.z - c.z;\n  \t\treturn Math.sqrt(dx * dx + dy * dy + dz * dz);\n  \t},\n  \tdistance: function distance(c) {\n  \t\tvar dx = this.x - c.x;\n  \t\tvar dy = this.y - c.y;\n  \t\treturn Math.sqrt(dx * dx + dy * dy);\n  \t},\n  \thashCode: function hashCode() {\n  \t\tvar result = 17;\n  \t\tresult = 37 * result + Coordinate.hashCode(this.x);\n  \t\tresult = 37 * result + Coordinate.hashCode(this.y);\n  \t\treturn result;\n  \t},\n  \tsetCoordinate: function setCoordinate(other) {\n  \t\tthis.x = other.x;\n  \t\tthis.y = other.y;\n  \t\tthis.z = other.z;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparable, Clonable, Serializable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Coordinate;\n  \t}\n  });\n  Coordinate.hashCode = function () {\n  \tif (arguments.length === 1) {\n  \t\tvar x = arguments[0];\n  \t\tvar f = Double.doubleToLongBits(x);\n  \t\treturn Math.trunc(f ^ f >>> 32);\n  \t}\n  };\n  function DimensionalComparator() {\n  \tthis._dimensionsToTest = 2;\n  \tif (arguments.length === 0) {\n  \t\tDimensionalComparator.call(this, 2);\n  \t} else if (arguments.length === 1) {\n  \t\tvar dimensionsToTest = arguments[0];\n  \t\tif (dimensionsToTest !== 2 && dimensionsToTest !== 3) throw new IllegalArgumentException(\"only 2 or 3 dimensions may be specified\");\n  \t\tthis._dimensionsToTest = dimensionsToTest;\n  \t}\n  }\n  extend(DimensionalComparator.prototype, {\n  \tcompare: function compare(o1, o2) {\n  \t\tvar c1 = o1;\n  \t\tvar c2 = o2;\n  \t\tvar compX = DimensionalComparator.compare(c1.x, c2.x);\n  \t\tif (compX !== 0) return compX;\n  \t\tvar compY = DimensionalComparator.compare(c1.y, c2.y);\n  \t\tif (compY !== 0) return compY;\n  \t\tif (this._dimensionsToTest <= 2) return 0;\n  \t\tvar compZ = DimensionalComparator.compare(c1.z, c2.z);\n  \t\treturn compZ;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparator];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn DimensionalComparator;\n  \t}\n  });\n  DimensionalComparator.compare = function (a, b) {\n  \tif (a < b) return -1;\n  \tif (a > b) return 1;\n  \tif (Double.isNaN(a)) {\n  \t\tif (Double.isNaN(b)) return 0;\n  \t\treturn -1;\n  \t}\n  \tif (Double.isNaN(b)) return 1;\n  \treturn 0;\n  };\n  Coordinate.DimensionalComparator = DimensionalComparator;\n  Coordinate.serialVersionUID = 6683108902428366910;\n  Coordinate.NULL_ORDINATE = Double.NaN;\n  Coordinate.X = 0;\n  Coordinate.Y = 1;\n  Coordinate.Z = 2;\n\n  function Iterator() {}Iterator.prototype.hasNext = function () {};\n  Iterator.prototype.next = function () {};\n  Iterator.prototype.remove = function () {};\n\n  function Collection() {}Collection.prototype.add = function () {};\n  Collection.prototype.addAll = function () {};\n  Collection.prototype.isEmpty = function () {};\n  Collection.prototype.iterator = function () {};\n  Collection.prototype.size = function () {};\n  Collection.prototype.toArray = function () {};\n  Collection.prototype.remove = function () {};\n\n  function IndexOutOfBoundsException$1(message) {\n    this.message = message || '';\n  }IndexOutOfBoundsException$1.prototype = new Error();\n  IndexOutOfBoundsException$1.prototype.name = 'IndexOutOfBoundsException';\n\n  function List() {}List.prototype = Object.create(Collection.prototype);\n  List.prototype.constructor = List;\n  List.prototype.get = function () {};\n  List.prototype.set = function () {};\n  List.prototype.isEmpty = function () {};\n\n  function NoSuchElementException(message) {\n    this.message = message || '';\n  }NoSuchElementException.prototype = new Error();\n  NoSuchElementException.prototype.name = 'NoSuchElementException';\n\n  function OperationNotSupported(message) {\n    this.message = message || '';\n  }OperationNotSupported.prototype = new Error();\n  OperationNotSupported.prototype.name = 'OperationNotSupported';\n\n  function ArrayList() {\n    this.array_ = [];\n    if (arguments[0] instanceof Collection) {\n      this.addAll(arguments[0]);\n    }\n  }ArrayList.prototype = Object.create(List.prototype);\n  ArrayList.prototype.constructor = ArrayList;\n  ArrayList.prototype.ensureCapacity = function () {};\n  ArrayList.prototype.interfaces_ = function () {\n    return [List, Collection];\n  };\n  ArrayList.prototype.add = function (e) {\n    if (arguments.length === 1) {\n      this.array_.push(e);\n    } else {\n      this.array_.splice(arguments[0], arguments[1]);\n    }\n    return true;\n  };\n  ArrayList.prototype.clear = function () {\n    this.array_ = [];\n  };\n  ArrayList.prototype.addAll = function (c) {\n    for (var i = c.iterator(); i.hasNext();) {\n      this.add(i.next());\n    }\n    return true;\n  };\n  ArrayList.prototype.set = function (index, element) {\n    var oldElement = this.array_[index];\n    this.array_[index] = element;\n    return oldElement;\n  };\n  ArrayList.prototype.iterator = function () {\n    return new Iterator_(this);\n  };\n  ArrayList.prototype.get = function (index) {\n    if (index < 0 || index >= this.size()) {\n      throw new IndexOutOfBoundsException$1();\n    }\n    return this.array_[index];\n  };\n  ArrayList.prototype.isEmpty = function () {\n    return this.array_.length === 0;\n  };\n  ArrayList.prototype.size = function () {\n    return this.array_.length;\n  };\n  ArrayList.prototype.toArray = function () {\n    var array = [];\n    for (var i = 0, len = this.array_.length; i < len; i++) {\n      array.push(this.array_[i]);\n    }\n    return array;\n  };\n  ArrayList.prototype.remove = function (o) {\n    var found = false;\n    for (var i = 0, len = this.array_.length; i < len; i++) {\n      if (this.array_[i] === o) {\n        this.array_.splice(i, 1);\n        found = true;\n        break;\n      }\n    }\n    return found;\n  };\n  var Iterator_ = function Iterator_(arrayList) {\n    this.arrayList_ = arrayList;\n    this.position_ = 0;\n  };\n  Iterator_.prototype.next = function () {\n    if (this.position_ === this.arrayList_.size()) {\n      throw new NoSuchElementException();\n    }\n    return this.arrayList_.get(this.position_++);\n  };\n  Iterator_.prototype.hasNext = function () {\n    if (this.position_ < this.arrayList_.size()) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  Iterator_.prototype.set = function (element) {\n    return this.arrayList_.set(this.position_ - 1, element);\n  };\n  Iterator_.prototype.remove = function () {\n    this.arrayList_.remove(this.arrayList_.get(this.position_));\n  };\n\n  function CoordinateList() {\n  \tArrayList.apply(this);\n  \tif (arguments.length === 0) ; else if (arguments.length === 1) {\n  \t\tvar coord = arguments[0];\n  \t\tthis.ensureCapacity(coord.length);\n  \t\tthis.add(coord, true);\n  \t} else if (arguments.length === 2) {\n  \t\tvar coord = arguments[0],\n  \t\t    allowRepeated = arguments[1];\n  \t\tthis.ensureCapacity(coord.length);\n  \t\tthis.add(coord, allowRepeated);\n  \t}\n  }\n  inherits$1(CoordinateList, ArrayList);\n  extend(CoordinateList.prototype, {\n  \tgetCoordinate: function getCoordinate(i) {\n  \t\treturn this.get(i);\n  \t},\n  \taddAll: function addAll() {\n  \t\tif (arguments.length === 2) {\n  \t\t\tvar coll = arguments[0],\n  \t\t\t    allowRepeated = arguments[1];\n  \t\t\tvar isChanged = false;\n  \t\t\tfor (var i = coll.iterator(); i.hasNext();) {\n  \t\t\t\tthis.add(i.next(), allowRepeated);\n  \t\t\t\tisChanged = true;\n  \t\t\t}\n  \t\t\treturn isChanged;\n  \t\t} else return ArrayList.prototype.addAll.apply(this, arguments);\n  \t},\n  \tclone: function clone() {\n  \t\tvar clone = ArrayList.prototype.clone.call(this);\n  \t\tfor (var i = 0; i < this.size(); i++) {\n  \t\t\tclone.add(i, this.get(i).copy());\n  \t\t}\n  \t\treturn clone;\n  \t},\n  \ttoCoordinateArray: function toCoordinateArray() {\n  \t\treturn this.toArray(CoordinateList.coordArrayType);\n  \t},\n  \tadd: function add() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar coord = arguments[0];\n  \t\t\tArrayList.prototype.add.call(this, coord);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tif (arguments[0] instanceof Array && typeof arguments[1] === \"boolean\") {\n  \t\t\t\tvar coord = arguments[0],\n  \t\t\t\t    allowRepeated = arguments[1];\n  \t\t\t\tthis.add(coord, allowRepeated, true);\n  \t\t\t\treturn true;\n  \t\t\t} else if (arguments[0] instanceof Coordinate && typeof arguments[1] === \"boolean\") {\n  \t\t\t\tvar coord = arguments[0],\n  \t\t\t\t    allowRepeated = arguments[1];\n  \t\t\t\tif (!allowRepeated) {\n  \t\t\t\t\tif (this.size() >= 1) {\n  \t\t\t\t\t\tvar last = this.get(this.size() - 1);\n  \t\t\t\t\t\tif (last.equals2D(coord)) return null;\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t\tArrayList.prototype.add.call(this, coord);\n  \t\t\t} else if (arguments[0] instanceof Object && typeof arguments[1] === \"boolean\") {\n  \t\t\t\tvar obj = arguments[0],\n  \t\t\t\t    allowRepeated = arguments[1];\n  \t\t\t\tthis.add(obj, allowRepeated);\n  \t\t\t\treturn true;\n  \t\t\t}\n  \t\t} else if (arguments.length === 3) {\n  \t\t\tif (typeof arguments[2] === \"boolean\" && arguments[0] instanceof Array && typeof arguments[1] === \"boolean\") {\n  \t\t\t\tvar coord = arguments[0],\n  \t\t\t\t    allowRepeated = arguments[1],\n  \t\t\t\t    direction = arguments[2];\n  \t\t\t\tif (direction) {\n  \t\t\t\t\tfor (var i = 0; i < coord.length; i++) {\n  \t\t\t\t\t\tthis.add(coord[i], allowRepeated);\n  \t\t\t\t\t}\n  \t\t\t\t} else {\n  \t\t\t\t\tfor (var i = coord.length - 1; i >= 0; i--) {\n  \t\t\t\t\t\tthis.add(coord[i], allowRepeated);\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t\treturn true;\n  \t\t\t} else if (typeof arguments[2] === \"boolean\" && Number.isInteger(arguments[0]) && arguments[1] instanceof Coordinate) {\n  \t\t\t\tvar i = arguments[0],\n  \t\t\t\t    coord = arguments[1],\n  \t\t\t\t    allowRepeated = arguments[2];\n  \t\t\t\tif (!allowRepeated) {\n  \t\t\t\t\tvar size = this.size();\n  \t\t\t\t\tif (size > 0) {\n  \t\t\t\t\t\tif (i > 0) {\n  \t\t\t\t\t\t\tvar prev = this.get(i - 1);\n  \t\t\t\t\t\t\tif (prev.equals2D(coord)) return null;\n  \t\t\t\t\t\t}\n  \t\t\t\t\t\tif (i < size) {\n  \t\t\t\t\t\t\tvar next = this.get(i);\n  \t\t\t\t\t\t\tif (next.equals2D(coord)) return null;\n  \t\t\t\t\t\t}\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t\tArrayList.prototype.add.call(this, i, coord);\n  \t\t\t}\n  \t\t} else if (arguments.length === 4) {\n  \t\t\tvar coord = arguments[0],\n  \t\t\t    allowRepeated = arguments[1],\n  \t\t\t    start = arguments[2],\n  \t\t\t    end = arguments[3];\n  \t\t\tvar inc = 1;\n  \t\t\tif (start > end) inc = -1;\n  \t\t\tfor (var i = start; i !== end; i += inc) {\n  \t\t\t\tthis.add(coord[i], allowRepeated);\n  \t\t\t}\n  \t\t\treturn true;\n  \t\t}\n  \t},\n  \tcloseRing: function closeRing() {\n  \t\tif (this.size() > 0) this.add(new Coordinate(this.get(0)), false);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn CoordinateList;\n  \t}\n  });\n  CoordinateList.coordArrayType = new Array(0).fill(null);\n\n  function Envelope() {\n  \tthis._minx = null;\n  \tthis._maxx = null;\n  \tthis._miny = null;\n  \tthis._maxy = null;\n  \tif (arguments.length === 0) {\n  \t\tthis.init();\n  \t} else if (arguments.length === 1) {\n  \t\tif (arguments[0] instanceof Coordinate) {\n  \t\t\tvar p = arguments[0];\n  \t\t\tthis.init(p.x, p.x, p.y, p.y);\n  \t\t} else if (arguments[0] instanceof Envelope) {\n  \t\t\tvar env = arguments[0];\n  \t\t\tthis.init(env);\n  \t\t}\n  \t} else if (arguments.length === 2) {\n  \t\tvar p1 = arguments[0],\n  \t\t    p2 = arguments[1];\n  \t\tthis.init(p1.x, p2.x, p1.y, p2.y);\n  \t} else if (arguments.length === 4) {\n  \t\tvar x1 = arguments[0],\n  \t\t    x2 = arguments[1],\n  \t\t    y1 = arguments[2],\n  \t\t    y2 = arguments[3];\n  \t\tthis.init(x1, x2, y1, y2);\n  \t}\n  }\n  extend(Envelope.prototype, {\n  \tgetArea: function getArea() {\n  \t\treturn this.getWidth() * this.getHeight();\n  \t},\n  \tequals: function equals(other) {\n  \t\tif (!(other instanceof Envelope)) {\n  \t\t\treturn false;\n  \t\t}\n  \t\tvar otherEnvelope = other;\n  \t\tif (this.isNull()) {\n  \t\t\treturn otherEnvelope.isNull();\n  \t\t}\n  \t\treturn this._maxx === otherEnvelope.getMaxX() && this._maxy === otherEnvelope.getMaxY() && this._minx === otherEnvelope.getMinX() && this._miny === otherEnvelope.getMinY();\n  \t},\n  \tintersection: function intersection(env) {\n  \t\tif (this.isNull() || env.isNull() || !this.intersects(env)) return new Envelope();\n  \t\tvar intMinX = this._minx > env._minx ? this._minx : env._minx;\n  \t\tvar intMinY = this._miny > env._miny ? this._miny : env._miny;\n  \t\tvar intMaxX = this._maxx < env._maxx ? this._maxx : env._maxx;\n  \t\tvar intMaxY = this._maxy < env._maxy ? this._maxy : env._maxy;\n  \t\treturn new Envelope(intMinX, intMaxX, intMinY, intMaxY);\n  \t},\n  \tisNull: function isNull() {\n  \t\treturn this._maxx < this._minx;\n  \t},\n  \tgetMaxX: function getMaxX() {\n  \t\treturn this._maxx;\n  \t},\n  \tcovers: function covers() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tif (arguments[0] instanceof Coordinate) {\n  \t\t\t\tvar p = arguments[0];\n  \t\t\t\treturn this.covers(p.x, p.y);\n  \t\t\t} else if (arguments[0] instanceof Envelope) {\n  \t\t\t\tvar other = arguments[0];\n  \t\t\t\tif (this.isNull() || other.isNull()) {\n  \t\t\t\t\treturn false;\n  \t\t\t\t}\n  \t\t\t\treturn other.getMinX() >= this._minx && other.getMaxX() <= this._maxx && other.getMinY() >= this._miny && other.getMaxY() <= this._maxy;\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar x = arguments[0],\n  \t\t\t    y = arguments[1];\n  \t\t\tif (this.isNull()) return false;\n  \t\t\treturn x >= this._minx && x <= this._maxx && y >= this._miny && y <= this._maxy;\n  \t\t}\n  \t},\n  \tintersects: function intersects() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tif (arguments[0] instanceof Envelope) {\n  \t\t\t\tvar other = arguments[0];\n  \t\t\t\tif (this.isNull() || other.isNull()) {\n  \t\t\t\t\treturn false;\n  \t\t\t\t}\n  \t\t\t\treturn !(other._minx > this._maxx || other._maxx < this._minx || other._miny > this._maxy || other._maxy < this._miny);\n  \t\t\t} else if (arguments[0] instanceof Coordinate) {\n  \t\t\t\tvar p = arguments[0];\n  \t\t\t\treturn this.intersects(p.x, p.y);\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar x = arguments[0],\n  \t\t\t    y = arguments[1];\n  \t\t\tif (this.isNull()) return false;\n  \t\t\treturn !(x > this._maxx || x < this._minx || y > this._maxy || y < this._miny);\n  \t\t}\n  \t},\n  \tgetMinY: function getMinY() {\n  \t\treturn this._miny;\n  \t},\n  \tgetMinX: function getMinX() {\n  \t\treturn this._minx;\n  \t},\n  \texpandToInclude: function expandToInclude() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tif (arguments[0] instanceof Coordinate) {\n  \t\t\t\tvar p = arguments[0];\n  \t\t\t\tthis.expandToInclude(p.x, p.y);\n  \t\t\t} else if (arguments[0] instanceof Envelope) {\n  \t\t\t\tvar other = arguments[0];\n  \t\t\t\tif (other.isNull()) {\n  \t\t\t\t\treturn null;\n  \t\t\t\t}\n  \t\t\t\tif (this.isNull()) {\n  \t\t\t\t\tthis._minx = other.getMinX();\n  \t\t\t\t\tthis._maxx = other.getMaxX();\n  \t\t\t\t\tthis._miny = other.getMinY();\n  \t\t\t\t\tthis._maxy = other.getMaxY();\n  \t\t\t\t} else {\n  \t\t\t\t\tif (other._minx < this._minx) {\n  \t\t\t\t\t\tthis._minx = other._minx;\n  \t\t\t\t\t}\n  \t\t\t\t\tif (other._maxx > this._maxx) {\n  \t\t\t\t\t\tthis._maxx = other._maxx;\n  \t\t\t\t\t}\n  \t\t\t\t\tif (other._miny < this._miny) {\n  \t\t\t\t\t\tthis._miny = other._miny;\n  \t\t\t\t\t}\n  \t\t\t\t\tif (other._maxy > this._maxy) {\n  \t\t\t\t\t\tthis._maxy = other._maxy;\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar x = arguments[0],\n  \t\t\t    y = arguments[1];\n  \t\t\tif (this.isNull()) {\n  \t\t\t\tthis._minx = x;\n  \t\t\t\tthis._maxx = x;\n  \t\t\t\tthis._miny = y;\n  \t\t\t\tthis._maxy = y;\n  \t\t\t} else {\n  \t\t\t\tif (x < this._minx) {\n  \t\t\t\t\tthis._minx = x;\n  \t\t\t\t}\n  \t\t\t\tif (x > this._maxx) {\n  \t\t\t\t\tthis._maxx = x;\n  \t\t\t\t}\n  \t\t\t\tif (y < this._miny) {\n  \t\t\t\t\tthis._miny = y;\n  \t\t\t\t}\n  \t\t\t\tif (y > this._maxy) {\n  \t\t\t\t\tthis._maxy = y;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tminExtent: function minExtent() {\n  \t\tif (this.isNull()) return 0.0;\n  \t\tvar w = this.getWidth();\n  \t\tvar h = this.getHeight();\n  \t\tif (w < h) return w;\n  \t\treturn h;\n  \t},\n  \tgetWidth: function getWidth() {\n  \t\tif (this.isNull()) {\n  \t\t\treturn 0;\n  \t\t}\n  \t\treturn this._maxx - this._minx;\n  \t},\n  \tcompareTo: function compareTo(o) {\n  \t\tvar env = o;\n  \t\tif (this.isNull()) {\n  \t\t\tif (env.isNull()) return 0;\n  \t\t\treturn -1;\n  \t\t} else {\n  \t\t\tif (env.isNull()) return 1;\n  \t\t}\n  \t\tif (this._minx < env._minx) return -1;\n  \t\tif (this._minx > env._minx) return 1;\n  \t\tif (this._miny < env._miny) return -1;\n  \t\tif (this._miny > env._miny) return 1;\n  \t\tif (this._maxx < env._maxx) return -1;\n  \t\tif (this._maxx > env._maxx) return 1;\n  \t\tif (this._maxy < env._maxy) return -1;\n  \t\tif (this._maxy > env._maxy) return 1;\n  \t\treturn 0;\n  \t},\n  \ttranslate: function translate(transX, transY) {\n  \t\tif (this.isNull()) {\n  \t\t\treturn null;\n  \t\t}\n  \t\tthis.init(this.getMinX() + transX, this.getMaxX() + transX, this.getMinY() + transY, this.getMaxY() + transY);\n  \t},\n  \ttoString: function toString() {\n  \t\treturn \"Env[\" + this._minx + \" : \" + this._maxx + \", \" + this._miny + \" : \" + this._maxy + \"]\";\n  \t},\n  \tsetToNull: function setToNull() {\n  \t\tthis._minx = 0;\n  \t\tthis._maxx = -1;\n  \t\tthis._miny = 0;\n  \t\tthis._maxy = -1;\n  \t},\n  \tgetHeight: function getHeight() {\n  \t\tif (this.isNull()) {\n  \t\t\treturn 0;\n  \t\t}\n  \t\treturn this._maxy - this._miny;\n  \t},\n  \tmaxExtent: function maxExtent() {\n  \t\tif (this.isNull()) return 0.0;\n  \t\tvar w = this.getWidth();\n  \t\tvar h = this.getHeight();\n  \t\tif (w > h) return w;\n  \t\treturn h;\n  \t},\n  \texpandBy: function expandBy() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar distance = arguments[0];\n  \t\t\tthis.expandBy(distance, distance);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar deltaX = arguments[0],\n  \t\t\t    deltaY = arguments[1];\n  \t\t\tif (this.isNull()) return null;\n  \t\t\tthis._minx -= deltaX;\n  \t\t\tthis._maxx += deltaX;\n  \t\t\tthis._miny -= deltaY;\n  \t\t\tthis._maxy += deltaY;\n  \t\t\tif (this._minx > this._maxx || this._miny > this._maxy) this.setToNull();\n  \t\t}\n  \t},\n  \tcontains: function contains() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tif (arguments[0] instanceof Envelope) {\n  \t\t\t\tvar other = arguments[0];\n  \t\t\t\treturn this.covers(other);\n  \t\t\t} else if (arguments[0] instanceof Coordinate) {\n  \t\t\t\tvar p = arguments[0];\n  \t\t\t\treturn this.covers(p);\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar x = arguments[0],\n  \t\t\t    y = arguments[1];\n  \t\t\treturn this.covers(x, y);\n  \t\t}\n  \t},\n  \tcentre: function centre() {\n  \t\tif (this.isNull()) return null;\n  \t\treturn new Coordinate((this.getMinX() + this.getMaxX()) / 2.0, (this.getMinY() + this.getMaxY()) / 2.0);\n  \t},\n  \tinit: function init() {\n  \t\tif (arguments.length === 0) {\n  \t\t\tthis.setToNull();\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tif (arguments[0] instanceof Coordinate) {\n  \t\t\t\tvar p = arguments[0];\n  \t\t\t\tthis.init(p.x, p.x, p.y, p.y);\n  \t\t\t} else if (arguments[0] instanceof Envelope) {\n  \t\t\t\tvar env = arguments[0];\n  \t\t\t\tthis._minx = env._minx;\n  \t\t\t\tthis._maxx = env._maxx;\n  \t\t\t\tthis._miny = env._miny;\n  \t\t\t\tthis._maxy = env._maxy;\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar p1 = arguments[0],\n  \t\t\t    p2 = arguments[1];\n  \t\t\tthis.init(p1.x, p2.x, p1.y, p2.y);\n  \t\t} else if (arguments.length === 4) {\n  \t\t\tvar x1 = arguments[0],\n  \t\t\t    x2 = arguments[1],\n  \t\t\t    y1 = arguments[2],\n  \t\t\t    y2 = arguments[3];\n  \t\t\tif (x1 < x2) {\n  \t\t\t\tthis._minx = x1;\n  \t\t\t\tthis._maxx = x2;\n  \t\t\t} else {\n  \t\t\t\tthis._minx = x2;\n  \t\t\t\tthis._maxx = x1;\n  \t\t\t}\n  \t\t\tif (y1 < y2) {\n  \t\t\t\tthis._miny = y1;\n  \t\t\t\tthis._maxy = y2;\n  \t\t\t} else {\n  \t\t\t\tthis._miny = y2;\n  \t\t\t\tthis._maxy = y1;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetMaxY: function getMaxY() {\n  \t\treturn this._maxy;\n  \t},\n  \tdistance: function distance(env) {\n  \t\tif (this.intersects(env)) return 0;\n  \t\tvar dx = 0.0;\n  \t\tif (this._maxx < env._minx) dx = env._minx - this._maxx;else if (this._minx > env._maxx) dx = this._minx - env._maxx;\n  \t\tvar dy = 0.0;\n  \t\tif (this._maxy < env._miny) dy = env._miny - this._maxy;else if (this._miny > env._maxy) dy = this._miny - env._maxy;\n  \t\tif (dx === 0.0) return dy;\n  \t\tif (dy === 0.0) return dx;\n  \t\treturn Math.sqrt(dx * dx + dy * dy);\n  \t},\n  \thashCode: function hashCode() {\n  \t\tvar result = 17;\n  \t\tresult = 37 * result + Coordinate.hashCode(this._minx);\n  \t\tresult = 37 * result + Coordinate.hashCode(this._maxx);\n  \t\tresult = 37 * result + Coordinate.hashCode(this._miny);\n  \t\tresult = 37 * result + Coordinate.hashCode(this._maxy);\n  \t\treturn result;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparable, Serializable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Envelope;\n  \t}\n  });\n  Envelope.intersects = function () {\n  \tif (arguments.length === 3) {\n  \t\tvar p1 = arguments[0],\n  \t\t    p2 = arguments[1],\n  \t\t    q = arguments[2];\n  \t\tif (q.x >= (p1.x < p2.x ? p1.x : p2.x) && q.x <= (p1.x > p2.x ? p1.x : p2.x) && q.y >= (p1.y < p2.y ? p1.y : p2.y) && q.y <= (p1.y > p2.y ? p1.y : p2.y)) {\n  \t\t\treturn true;\n  \t\t}\n  \t\treturn false;\n  \t} else if (arguments.length === 4) {\n  \t\tvar p1 = arguments[0],\n  \t\t    p2 = arguments[1],\n  \t\t    q1 = arguments[2],\n  \t\t    q2 = arguments[3];\n  \t\tvar minq = Math.min(q1.x, q2.x);\n  \t\tvar maxq = Math.max(q1.x, q2.x);\n  \t\tvar minp = Math.min(p1.x, p2.x);\n  \t\tvar maxp = Math.max(p1.x, p2.x);\n  \t\tif (minp > maxq) return false;\n  \t\tif (maxp < minq) return false;\n  \t\tminq = Math.min(q1.y, q2.y);\n  \t\tmaxq = Math.max(q1.y, q2.y);\n  \t\tminp = Math.min(p1.y, p2.y);\n  \t\tmaxp = Math.max(p1.y, p2.y);\n  \t\tif (minp > maxq) return false;\n  \t\tif (maxp < minq) return false;\n  \t\treturn true;\n  \t}\n  };\n  Envelope.serialVersionUID = 5873921885273102420;\n\n  function Exception() {}\n\n  function NotRepresentableException() {\n  \tException.call(this, \"Projective point not representable on the Cartesian plane.\");\n  }\n  inherits$1(NotRepresentableException, Exception);\n  extend(NotRepresentableException.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn NotRepresentableException;\n  \t}\n  });\n\n  function Location() {}\n  extend(Location.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Location;\n  \t}\n  });\n  Location.toLocationSymbol = function (locationValue) {\n  \tswitch (locationValue) {\n  \t\tcase Location.EXTERIOR:\n  \t\t\treturn 'e';\n  \t\tcase Location.BOUNDARY:\n  \t\t\treturn 'b';\n  \t\tcase Location.INTERIOR:\n  \t\t\treturn 'i';\n  \t\tcase Location.NONE:\n  \t\t\treturn '-';\n  \t}\n  \tthrow new IllegalArgumentException(\"Unknown location value: \" + locationValue);\n  };\n  Location.INTERIOR = 0;\n  Location.BOUNDARY = 1;\n  Location.EXTERIOR = 2;\n  Location.NONE = -1;\n\n  function hasInterface (o, i) {\n    return o.interfaces_ && o.interfaces_().indexOf(i) > -1;\n  }\n\n  function MathUtil() {}\n  extend(MathUtil.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MathUtil;\n  \t}\n  });\n  MathUtil.log10 = function (x) {\n  \tvar ln = Math.log(x);\n  \tif (Double.isInfinite(ln)) return ln;\n  \tif (Double.isNaN(ln)) return ln;\n  \treturn ln / MathUtil.LOG_10;\n  };\n  MathUtil.min = function (v1, v2, v3, v4) {\n  \tvar min = v1;\n  \tif (v2 < min) min = v2;\n  \tif (v3 < min) min = v3;\n  \tif (v4 < min) min = v4;\n  \treturn min;\n  };\n  MathUtil.clamp = function () {\n  \tif (typeof arguments[2] === \"number\" && typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\") {\n  \t\tvar x = arguments[0],\n  \t\t    min = arguments[1],\n  \t\t    max = arguments[2];\n  \t\tif (x < min) return min;\n  \t\tif (x > max) return max;\n  \t\treturn x;\n  \t} else if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {\n  \t\tvar x = arguments[0],\n  \t\t    min = arguments[1],\n  \t\t    max = arguments[2];\n  \t\tif (x < min) return min;\n  \t\tif (x > max) return max;\n  \t\treturn x;\n  \t}\n  };\n  MathUtil.wrap = function (index, max) {\n  \tif (index < 0) {\n  \t\treturn max - -index % max;\n  \t}\n  \treturn index % max;\n  };\n  MathUtil.max = function () {\n  \tif (arguments.length === 3) {\n  \t\tvar v1 = arguments[0],\n  \t\t    v2 = arguments[1],\n  \t\t    v3 = arguments[2];\n  \t\tvar max = v1;\n  \t\tif (v2 > max) max = v2;\n  \t\tif (v3 > max) max = v3;\n  \t\treturn max;\n  \t} else if (arguments.length === 4) {\n  \t\tvar v1 = arguments[0],\n  \t\t    v2 = arguments[1],\n  \t\t    v3 = arguments[2],\n  \t\t    v4 = arguments[3];\n  \t\tvar max = v1;\n  \t\tif (v2 > max) max = v2;\n  \t\tif (v3 > max) max = v3;\n  \t\tif (v4 > max) max = v4;\n  \t\treturn max;\n  \t}\n  };\n  MathUtil.average = function (x1, x2) {\n  \treturn (x1 + x2) / 2.0;\n  };\n  MathUtil.LOG_10 = Math.log(10);\n\n  function StringBuffer(str) {\n    this.str = str;\n  }\n  StringBuffer.prototype.append = function (e) {\n    this.str += e;\n  };\n  StringBuffer.prototype.setCharAt = function (i, c) {\n    this.str = this.str.substr(0, i) + c + this.str.substr(i + 1);\n  };\n  StringBuffer.prototype.toString = function (e) {\n    return this.str;\n  };\n\n  function Integer(value) {\n    this.value = value;\n  }\n  Integer.prototype.intValue = function () {\n    return this.value;\n  };\n  Integer.prototype.compareTo = function (o) {\n    if (this.value < o) return -1;\n    if (this.value > o) return 1;\n    return 0;\n  };\n  Integer.isNaN = function (n) {\n    return Number.isNaN(n);\n  };\n\n  function Character() {}\n  Character.isWhitespace = function (c) {\n    return c <= 32 && c >= 0 || c == 127;\n  };\n  Character.toUpperCase = function (c) {\n    return c.toUpperCase();\n  };\n\n  function DD() {\n  \tthis._hi = 0.0;\n  \tthis._lo = 0.0;\n  \tif (arguments.length === 0) {\n  \t\tthis.init(0.0);\n  \t} else if (arguments.length === 1) {\n  \t\tif (typeof arguments[0] === \"number\") {\n  \t\t\tvar x = arguments[0];\n  \t\t\tthis.init(x);\n  \t\t} else if (arguments[0] instanceof DD) {\n  \t\t\tvar dd = arguments[0];\n  \t\t\tthis.init(dd);\n  \t\t} else if (typeof arguments[0] === \"string\") {\n  \t\t\tvar str = arguments[0];\n  \t\t\tDD.call(this, DD.parse(str));\n  \t\t}\n  \t} else if (arguments.length === 2) {\n  \t\tvar hi = arguments[0],\n  \t\t    lo = arguments[1];\n  \t\tthis.init(hi, lo);\n  \t}\n  }\n  extend(DD.prototype, {\n  \tle: function le(y) {\n  \t\treturn this._hi < y._hi || this._hi === y._hi && this._lo <= y._lo;\n  \t},\n  \textractSignificantDigits: function extractSignificantDigits(insertDecimalPoint, magnitude) {\n  \t\tvar y = this.abs();\n  \t\tvar mag = DD.magnitude(y._hi);\n  \t\tvar scale = DD.TEN.pow(mag);\n  \t\ty = y.divide(scale);\n  \t\tif (y.gt(DD.TEN)) {\n  \t\t\ty = y.divide(DD.TEN);\n  \t\t\tmag += 1;\n  \t\t} else if (y.lt(DD.ONE)) {\n  \t\t\ty = y.multiply(DD.TEN);\n  \t\t\tmag -= 1;\n  \t\t}\n  \t\tvar decimalPointPos = mag + 1;\n  \t\tvar buf = new StringBuffer();\n  \t\tvar numDigits = DD.MAX_PRINT_DIGITS - 1;\n  \t\tfor (var i = 0; i <= numDigits; i++) {\n  \t\t\tif (insertDecimalPoint && i === decimalPointPos) {\n  \t\t\t\tbuf.append('.');\n  \t\t\t}\n  \t\t\tvar digit = Math.trunc(y._hi);\n  \t\t\tif (digit < 0) {\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t\tvar rebiasBy10 = false;\n  \t\t\tvar digitChar = 0;\n  \t\t\tif (digit > 9) {\n  \t\t\t\trebiasBy10 = true;\n  \t\t\t\tdigitChar = '9';\n  \t\t\t} else {\n  \t\t\t\tdigitChar = '0' + digit;\n  \t\t\t}\n  \t\t\tbuf.append(digitChar);\n  \t\t\ty = y.subtract(DD.valueOf(digit)).multiply(DD.TEN);\n  \t\t\tif (rebiasBy10) y.selfAdd(DD.TEN);\n  \t\t\tvar continueExtractingDigits = true;\n  \t\t\tvar remMag = DD.magnitude(y._hi);\n  \t\t\tif (remMag < 0 && Math.abs(remMag) >= numDigits - i) continueExtractingDigits = false;\n  \t\t\tif (!continueExtractingDigits) break;\n  \t\t}\n  \t\tmagnitude[0] = mag;\n  \t\treturn buf.toString();\n  \t},\n  \tsqr: function sqr() {\n  \t\treturn this.multiply(this);\n  \t},\n  \tdoubleValue: function doubleValue() {\n  \t\treturn this._hi + this._lo;\n  \t},\n  \tsubtract: function subtract() {\n  \t\tif (arguments[0] instanceof DD) {\n  \t\t\tvar y = arguments[0];\n  \t\t\treturn this.add(y.negate());\n  \t\t} else if (typeof arguments[0] === \"number\") {\n  \t\t\tvar y = arguments[0];\n  \t\t\treturn this.add(-y);\n  \t\t}\n  \t},\n  \tequals: function equals() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar y = arguments[0];\n  \t\t\treturn this._hi === y._hi && this._lo === y._lo;\n  \t\t}\n  \t},\n  \tisZero: function isZero() {\n  \t\treturn this._hi === 0.0 && this._lo === 0.0;\n  \t},\n  \tselfSubtract: function selfSubtract() {\n  \t\tif (arguments[0] instanceof DD) {\n  \t\t\tvar y = arguments[0];\n  \t\t\tif (this.isNaN()) return this;\n  \t\t\treturn this.selfAdd(-y._hi, -y._lo);\n  \t\t} else if (typeof arguments[0] === \"number\") {\n  \t\t\tvar y = arguments[0];\n  \t\t\tif (this.isNaN()) return this;\n  \t\t\treturn this.selfAdd(-y, 0.0);\n  \t\t}\n  \t},\n  \tgetSpecialNumberString: function getSpecialNumberString() {\n  \t\tif (this.isZero()) return \"0.0\";\n  \t\tif (this.isNaN()) return \"NaN \";\n  \t\treturn null;\n  \t},\n  \tmin: function min(x) {\n  \t\tif (this.le(x)) {\n  \t\t\treturn this;\n  \t\t} else {\n  \t\t\treturn x;\n  \t\t}\n  \t},\n  \tselfDivide: function selfDivide() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tif (arguments[0] instanceof DD) {\n  \t\t\t\tvar y = arguments[0];\n  \t\t\t\treturn this.selfDivide(y._hi, y._lo);\n  \t\t\t} else if (typeof arguments[0] === \"number\") {\n  \t\t\t\tvar y = arguments[0];\n  \t\t\t\treturn this.selfDivide(y, 0.0);\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar yhi = arguments[0],\n  \t\t\t    ylo = arguments[1];\n  \t\t\tvar hc = null,\n  \t\t\t    tc = null,\n  \t\t\t    hy = null,\n  \t\t\t    ty = null,\n  \t\t\t    C = null,\n  \t\t\t    c = null,\n  \t\t\t    U = null,\n  \t\t\t    u = null;\n  \t\t\tC = this._hi / yhi;\n  \t\t\tc = DD.SPLIT * C;\n  \t\t\thc = c - C;\n  \t\t\tu = DD.SPLIT * yhi;\n  \t\t\thc = c - hc;\n  \t\t\ttc = C - hc;\n  \t\t\thy = u - yhi;\n  \t\t\tU = C * yhi;\n  \t\t\thy = u - hy;\n  \t\t\tty = yhi - hy;\n  \t\t\tu = hc * hy - U + hc * ty + tc * hy + tc * ty;\n  \t\t\tc = (this._hi - U - u + this._lo - C * ylo) / yhi;\n  \t\t\tu = C + c;\n  \t\t\tthis._hi = u;\n  \t\t\tthis._lo = C - u + c;\n  \t\t\treturn this;\n  \t\t}\n  \t},\n  \tdump: function dump() {\n  \t\treturn \"DD<\" + this._hi + \", \" + this._lo + \">\";\n  \t},\n  \tdivide: function divide() {\n  \t\tif (arguments[0] instanceof DD) {\n  \t\t\tvar y = arguments[0];\n  \t\t\tvar hc = null,\n  \t\t\t    tc = null,\n  \t\t\t    hy = null,\n  \t\t\t    ty = null,\n  \t\t\t    C = null,\n  \t\t\t    c = null,\n  \t\t\t    U = null,\n  \t\t\t    u = null;\n  \t\t\tC = this._hi / y._hi;\n  \t\t\tc = DD.SPLIT * C;\n  \t\t\thc = c - C;\n  \t\t\tu = DD.SPLIT * y._hi;\n  \t\t\thc = c - hc;\n  \t\t\ttc = C - hc;\n  \t\t\thy = u - y._hi;\n  \t\t\tU = C * y._hi;\n  \t\t\thy = u - hy;\n  \t\t\tty = y._hi - hy;\n  \t\t\tu = hc * hy - U + hc * ty + tc * hy + tc * ty;\n  \t\t\tc = (this._hi - U - u + this._lo - C * y._lo) / y._hi;\n  \t\t\tu = C + c;\n  \t\t\tvar zhi = u;\n  \t\t\tvar zlo = C - u + c;\n  \t\t\treturn new DD(zhi, zlo);\n  \t\t} else if (typeof arguments[0] === \"number\") {\n  \t\t\tvar y = arguments[0];\n  \t\t\tif (Double.isNaN(y)) return DD.createNaN();\n  \t\t\treturn DD.copy(this).selfDivide(y, 0.0);\n  \t\t}\n  \t},\n  \tge: function ge(y) {\n  \t\treturn this._hi > y._hi || this._hi === y._hi && this._lo >= y._lo;\n  \t},\n  \tpow: function pow(exp) {\n  \t\tif (exp === 0.0) return DD.valueOf(1.0);\n  \t\tvar r = new DD(this);\n  \t\tvar s = DD.valueOf(1.0);\n  \t\tvar n = Math.abs(exp);\n  \t\tif (n > 1) {\n  \t\t\twhile (n > 0) {\n  \t\t\t\tif (n % 2 === 1) {\n  \t\t\t\t\ts.selfMultiply(r);\n  \t\t\t\t}\n  \t\t\t\tn /= 2;\n  \t\t\t\tif (n > 0) r = r.sqr();\n  \t\t\t}\n  \t\t} else {\n  \t\t\ts = r;\n  \t\t}\n  \t\tif (exp < 0) return s.reciprocal();\n  \t\treturn s;\n  \t},\n  \tceil: function ceil() {\n  \t\tif (this.isNaN()) return DD.NaN;\n  \t\tvar fhi = Math.ceil(this._hi);\n  \t\tvar flo = 0.0;\n  \t\tif (fhi === this._hi) {\n  \t\t\tflo = Math.ceil(this._lo);\n  \t\t}\n  \t\treturn new DD(fhi, flo);\n  \t},\n  \tcompareTo: function compareTo(o) {\n  \t\tvar other = o;\n  \t\tif (this._hi < other._hi) return -1;\n  \t\tif (this._hi > other._hi) return 1;\n  \t\tif (this._lo < other._lo) return -1;\n  \t\tif (this._lo > other._lo) return 1;\n  \t\treturn 0;\n  \t},\n  \trint: function rint() {\n  \t\tif (this.isNaN()) return this;\n  \t\tvar plus5 = this.add(0.5);\n  \t\treturn plus5.floor();\n  \t},\n  \tsetValue: function setValue() {\n  \t\tif (arguments[0] instanceof DD) {\n  \t\t\tvar value = arguments[0];\n  \t\t\tthis.init(value);\n  \t\t\treturn this;\n  \t\t} else if (typeof arguments[0] === \"number\") {\n  \t\t\tvar value = arguments[0];\n  \t\t\tthis.init(value);\n  \t\t\treturn this;\n  \t\t}\n  \t},\n  \tmax: function max(x) {\n  \t\tif (this.ge(x)) {\n  \t\t\treturn this;\n  \t\t} else {\n  \t\t\treturn x;\n  \t\t}\n  \t},\n  \tsqrt: function sqrt() {\n  \t\tif (this.isZero()) return DD.valueOf(0.0);\n  \t\tif (this.isNegative()) {\n  \t\t\treturn DD.NaN;\n  \t\t}\n  \t\tvar x = 1.0 / Math.sqrt(this._hi);\n  \t\tvar ax = this._hi * x;\n  \t\tvar axdd = DD.valueOf(ax);\n  \t\tvar diffSq = this.subtract(axdd.sqr());\n  \t\tvar d2 = diffSq._hi * (x * 0.5);\n  \t\treturn axdd.add(d2);\n  \t},\n  \tselfAdd: function selfAdd() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tif (arguments[0] instanceof DD) {\n  \t\t\t\tvar y = arguments[0];\n  \t\t\t\treturn this.selfAdd(y._hi, y._lo);\n  \t\t\t} else if (typeof arguments[0] === \"number\") {\n  \t\t\t\tvar y = arguments[0];\n  \t\t\t\tvar H = null,\n  \t\t\t\t    h = null,\n  \t\t\t\t    S = null,\n  \t\t\t\t    s = null,\n  \t\t\t\t    e = null,\n  \t\t\t\t    f = null;\n  \t\t\t\tS = this._hi + y;\n  \t\t\t\te = S - this._hi;\n  \t\t\t\ts = S - e;\n  \t\t\t\ts = y - e + (this._hi - s);\n  \t\t\t\tf = s + this._lo;\n  \t\t\t\tH = S + f;\n  \t\t\t\th = f + (S - H);\n  \t\t\t\tthis._hi = H + h;\n  \t\t\t\tthis._lo = h + (H - this._hi);\n  \t\t\t\treturn this;\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar yhi = arguments[0],\n  \t\t\t    ylo = arguments[1];\n  \t\t\tvar H = null,\n  \t\t\t    h = null,\n  \t\t\t    T = null,\n  \t\t\t    t = null,\n  \t\t\t    S = null,\n  \t\t\t    s = null,\n  \t\t\t    e = null,\n  \t\t\t    f = null;\n  \t\t\tS = this._hi + yhi;\n  \t\t\tT = this._lo + ylo;\n  \t\t\te = S - this._hi;\n  \t\t\tf = T - this._lo;\n  \t\t\ts = S - e;\n  \t\t\tt = T - f;\n  \t\t\ts = yhi - e + (this._hi - s);\n  \t\t\tt = ylo - f + (this._lo - t);\n  \t\t\te = s + T;\n  \t\t\tH = S + e;\n  \t\t\th = e + (S - H);\n  \t\t\te = t + h;\n  \t\t\tvar zhi = H + e;\n  \t\t\tvar zlo = e + (H - zhi);\n  \t\t\tthis._hi = zhi;\n  \t\t\tthis._lo = zlo;\n  \t\t\treturn this;\n  \t\t}\n  \t},\n  \tselfMultiply: function selfMultiply() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tif (arguments[0] instanceof DD) {\n  \t\t\t\tvar y = arguments[0];\n  \t\t\t\treturn this.selfMultiply(y._hi, y._lo);\n  \t\t\t} else if (typeof arguments[0] === \"number\") {\n  \t\t\t\tvar y = arguments[0];\n  \t\t\t\treturn this.selfMultiply(y, 0.0);\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar yhi = arguments[0],\n  \t\t\t    ylo = arguments[1];\n  \t\t\tvar hx = null,\n  \t\t\t    tx = null,\n  \t\t\t    hy = null,\n  \t\t\t    ty = null,\n  \t\t\t    C = null,\n  \t\t\t    c = null;\n  \t\t\tC = DD.SPLIT * this._hi;\n  \t\t\thx = C - this._hi;\n  \t\t\tc = DD.SPLIT * yhi;\n  \t\t\thx = C - hx;\n  \t\t\ttx = this._hi - hx;\n  \t\t\thy = c - yhi;\n  \t\t\tC = this._hi * yhi;\n  \t\t\thy = c - hy;\n  \t\t\tty = yhi - hy;\n  \t\t\tc = hx * hy - C + hx * ty + tx * hy + tx * ty + (this._hi * ylo + this._lo * yhi);\n  \t\t\tvar zhi = C + c;\n  \t\t\thx = C - zhi;\n  \t\t\tvar zlo = c + hx;\n  \t\t\tthis._hi = zhi;\n  \t\t\tthis._lo = zlo;\n  \t\t\treturn this;\n  \t\t}\n  \t},\n  \tselfSqr: function selfSqr() {\n  \t\treturn this.selfMultiply(this);\n  \t},\n  \tfloor: function floor() {\n  \t\tif (this.isNaN()) return DD.NaN;\n  \t\tvar fhi = Math.floor(this._hi);\n  \t\tvar flo = 0.0;\n  \t\tif (fhi === this._hi) {\n  \t\t\tflo = Math.floor(this._lo);\n  \t\t}\n  \t\treturn new DD(fhi, flo);\n  \t},\n  \tnegate: function negate() {\n  \t\tif (this.isNaN()) return this;\n  \t\treturn new DD(-this._hi, -this._lo);\n  \t},\n  \tclone: function clone() {\n  \t\ttry {\n  \t\t\treturn null;\n  \t\t} catch (ex) {\n  \t\t\tif (ex instanceof CloneNotSupportedException) {\n  \t\t\t\treturn null;\n  \t\t\t} else throw ex;\n  \t\t} finally {}\n  \t},\n  \tmultiply: function multiply() {\n  \t\tif (arguments[0] instanceof DD) {\n  \t\t\tvar y = arguments[0];\n  \t\t\tif (y.isNaN()) return DD.createNaN();\n  \t\t\treturn DD.copy(this).selfMultiply(y);\n  \t\t} else if (typeof arguments[0] === \"number\") {\n  \t\t\tvar y = arguments[0];\n  \t\t\tif (Double.isNaN(y)) return DD.createNaN();\n  \t\t\treturn DD.copy(this).selfMultiply(y, 0.0);\n  \t\t}\n  \t},\n  \tisNaN: function isNaN() {\n  \t\treturn Double.isNaN(this._hi);\n  \t},\n  \tintValue: function intValue() {\n  \t\treturn Math.trunc(this._hi);\n  \t},\n  \ttoString: function toString() {\n  \t\tvar mag = DD.magnitude(this._hi);\n  \t\tif (mag >= -3 && mag <= 20) return this.toStandardNotation();\n  \t\treturn this.toSciNotation();\n  \t},\n  \ttoStandardNotation: function toStandardNotation() {\n  \t\tvar specialStr = this.getSpecialNumberString();\n  \t\tif (specialStr !== null) return specialStr;\n  \t\tvar magnitude = new Array(1).fill(null);\n  \t\tvar sigDigits = this.extractSignificantDigits(true, magnitude);\n  \t\tvar decimalPointPos = magnitude[0] + 1;\n  \t\tvar num = sigDigits;\n  \t\tif (sigDigits.charAt(0) === '.') {\n  \t\t\tnum = \"0\" + sigDigits;\n  \t\t} else if (decimalPointPos < 0) {\n  \t\t\tnum = \"0.\" + DD.stringOfChar('0', -decimalPointPos) + sigDigits;\n  \t\t} else if (sigDigits.indexOf('.') === -1) {\n  \t\t\tvar numZeroes = decimalPointPos - sigDigits.length;\n  \t\t\tvar zeroes = DD.stringOfChar('0', numZeroes);\n  \t\t\tnum = sigDigits + zeroes + \".0\";\n  \t\t}\n  \t\tif (this.isNegative()) return \"-\" + num;\n  \t\treturn num;\n  \t},\n  \treciprocal: function reciprocal() {\n  \t\tvar hc = null,\n  \t\t    tc = null,\n  \t\t    hy = null,\n  \t\t    ty = null,\n  \t\t    C = null,\n  \t\t    c = null,\n  \t\t    U = null,\n  \t\t    u = null;\n  \t\tC = 1.0 / this._hi;\n  \t\tc = DD.SPLIT * C;\n  \t\thc = c - C;\n  \t\tu = DD.SPLIT * this._hi;\n  \t\thc = c - hc;\n  \t\ttc = C - hc;\n  \t\thy = u - this._hi;\n  \t\tU = C * this._hi;\n  \t\thy = u - hy;\n  \t\tty = this._hi - hy;\n  \t\tu = hc * hy - U + hc * ty + tc * hy + tc * ty;\n  \t\tc = (1.0 - U - u - C * this._lo) / this._hi;\n  \t\tvar zhi = C + c;\n  \t\tvar zlo = C - zhi + c;\n  \t\treturn new DD(zhi, zlo);\n  \t},\n  \ttoSciNotation: function toSciNotation() {\n  \t\tif (this.isZero()) return DD.SCI_NOT_ZERO;\n  \t\tvar specialStr = this.getSpecialNumberString();\n  \t\tif (specialStr !== null) return specialStr;\n  \t\tvar magnitude = new Array(1).fill(null);\n  \t\tvar digits = this.extractSignificantDigits(false, magnitude);\n  \t\tvar expStr = DD.SCI_NOT_EXPONENT_CHAR + magnitude[0];\n  \t\tif (digits.charAt(0) === '0') {\n  \t\t\tthrow new IllegalStateException(\"Found leading zero: \" + digits);\n  \t\t}\n  \t\tvar trailingDigits = \"\";\n  \t\tif (digits.length > 1) trailingDigits = digits.substring(1);\n  \t\tvar digitsWithDecimal = digits.charAt(0) + \".\" + trailingDigits;\n  \t\tif (this.isNegative()) return \"-\" + digitsWithDecimal + expStr;\n  \t\treturn digitsWithDecimal + expStr;\n  \t},\n  \tabs: function abs() {\n  \t\tif (this.isNaN()) return DD.NaN;\n  \t\tif (this.isNegative()) return this.negate();\n  \t\treturn new DD(this);\n  \t},\n  \tisPositive: function isPositive() {\n  \t\treturn this._hi > 0.0 || this._hi === 0.0 && this._lo > 0.0;\n  \t},\n  \tlt: function lt(y) {\n  \t\treturn this._hi < y._hi || this._hi === y._hi && this._lo < y._lo;\n  \t},\n  \tadd: function add() {\n  \t\tif (arguments[0] instanceof DD) {\n  \t\t\tvar y = arguments[0];\n  \t\t\treturn DD.copy(this).selfAdd(y);\n  \t\t} else if (typeof arguments[0] === \"number\") {\n  \t\t\tvar y = arguments[0];\n  \t\t\treturn DD.copy(this).selfAdd(y);\n  \t\t}\n  \t},\n  \tinit: function init() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tif (typeof arguments[0] === \"number\") {\n  \t\t\t\tvar x = arguments[0];\n  \t\t\t\tthis._hi = x;\n  \t\t\t\tthis._lo = 0.0;\n  \t\t\t} else if (arguments[0] instanceof DD) {\n  \t\t\t\tvar dd = arguments[0];\n  \t\t\t\tthis._hi = dd._hi;\n  \t\t\t\tthis._lo = dd._lo;\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar hi = arguments[0],\n  \t\t\t    lo = arguments[1];\n  \t\t\tthis._hi = hi;\n  \t\t\tthis._lo = lo;\n  \t\t}\n  \t},\n  \tgt: function gt(y) {\n  \t\treturn this._hi > y._hi || this._hi === y._hi && this._lo > y._lo;\n  \t},\n  \tisNegative: function isNegative() {\n  \t\treturn this._hi < 0.0 || this._hi === 0.0 && this._lo < 0.0;\n  \t},\n  \ttrunc: function trunc() {\n  \t\tif (this.isNaN()) return DD.NaN;\n  \t\tif (this.isPositive()) return this.floor();else return this.ceil();\n  \t},\n  \tsignum: function signum() {\n  \t\tif (this._hi > 0) return 1;\n  \t\tif (this._hi < 0) return -1;\n  \t\tif (this._lo > 0) return 1;\n  \t\tif (this._lo < 0) return -1;\n  \t\treturn 0;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Serializable, Comparable, Clonable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn DD;\n  \t}\n  });\n  DD.sqr = function (x) {\n  \treturn DD.valueOf(x).selfMultiply(x);\n  };\n  DD.valueOf = function () {\n  \tif (typeof arguments[0] === \"string\") {\n  \t\tvar str = arguments[0];\n  \t\treturn DD.parse(str);\n  \t} else if (typeof arguments[0] === \"number\") {\n  \t\tvar x = arguments[0];\n  \t\treturn new DD(x);\n  \t}\n  };\n  DD.sqrt = function (x) {\n  \treturn DD.valueOf(x).sqrt();\n  };\n  DD.parse = function (str) {\n  \tvar i = 0;\n  \tvar strlen = str.length;\n  \twhile (Character.isWhitespace(str.charAt(i))) {\n  \t\ti++;\n  \t}var isNegative = false;\n  \tif (i < strlen) {\n  \t\tvar signCh = str.charAt(i);\n  \t\tif (signCh === '-' || signCh === '+') {\n  \t\t\ti++;\n  \t\t\tif (signCh === '-') isNegative = true;\n  \t\t}\n  \t}\n  \tvar val = new DD();\n  \tvar numDigits = 0;\n  \tvar numBeforeDec = 0;\n  \tvar exp = 0;\n  \twhile (true) {\n  \t\tif (i >= strlen) break;\n  \t\tvar ch = str.charAt(i);\n  \t\ti++;\n  \t\tif (Character.isDigit(ch)) {\n  \t\t\tvar d = ch - '0';\n  \t\t\tval.selfMultiply(DD.TEN);\n  \t\t\tval.selfAdd(d);\n  \t\t\tnumDigits++;\n  \t\t\tcontinue;\n  \t\t}\n  \t\tif (ch === '.') {\n  \t\t\tnumBeforeDec = numDigits;\n  \t\t\tcontinue;\n  \t\t}\n  \t\tif (ch === 'e' || ch === 'E') {\n  \t\t\tvar expStr = str.substring(i);\n  \t\t\ttry {\n  \t\t\t\texp = Integer.parseInt(expStr);\n  \t\t\t} catch (ex) {\n  \t\t\t\tif (ex instanceof NumberFormatException) {\n  \t\t\t\t\tthrow new NumberFormatException(\"Invalid exponent \" + expStr + \" in string \" + str);\n  \t\t\t\t} else throw ex;\n  \t\t\t} finally {}\n  \t\t\tbreak;\n  \t\t}\n  \t\tthrow new NumberFormatException(\"Unexpected character '\" + ch + \"' at position \" + i + \" in string \" + str);\n  \t}\n  \tvar val2 = val;\n  \tvar numDecPlaces = numDigits - numBeforeDec - exp;\n  \tif (numDecPlaces === 0) {\n  \t\tval2 = val;\n  \t} else if (numDecPlaces > 0) {\n  \t\tvar scale = DD.TEN.pow(numDecPlaces);\n  \t\tval2 = val.divide(scale);\n  \t} else if (numDecPlaces < 0) {\n  \t\tvar scale = DD.TEN.pow(-numDecPlaces);\n  \t\tval2 = val.multiply(scale);\n  \t}\n  \tif (isNegative) {\n  \t\treturn val2.negate();\n  \t}\n  \treturn val2;\n  };\n  DD.createNaN = function () {\n  \treturn new DD(Double.NaN, Double.NaN);\n  };\n  DD.copy = function (dd) {\n  \treturn new DD(dd);\n  };\n  DD.magnitude = function (x) {\n  \tvar xAbs = Math.abs(x);\n  \tvar xLog10 = Math.log(xAbs) / Math.log(10);\n  \tvar xMag = Math.trunc(Math.floor(xLog10));\n  \tvar xApprox = Math.pow(10, xMag);\n  \tif (xApprox * 10 <= xAbs) xMag += 1;\n  \treturn xMag;\n  };\n  DD.stringOfChar = function (ch, len) {\n  \tvar buf = new StringBuffer();\n  \tfor (var i = 0; i < len; i++) {\n  \t\tbuf.append(ch);\n  \t}\n  \treturn buf.toString();\n  };\n  DD.PI = new DD(3.141592653589793116e+00, 1.224646799147353207e-16);\n  DD.TWO_PI = new DD(6.283185307179586232e+00, 2.449293598294706414e-16);\n  DD.PI_2 = new DD(1.570796326794896558e+00, 6.123233995736766036e-17);\n  DD.E = new DD(2.718281828459045091e+00, 1.445646891729250158e-16);\n  DD.NaN = new DD(Double.NaN, Double.NaN);\n  DD.EPS = 1.23259516440783e-32;\n  DD.SPLIT = 134217729.0;\n  DD.MAX_PRINT_DIGITS = 32;\n  DD.TEN = DD.valueOf(10.0);\n  DD.ONE = DD.valueOf(1.0);\n  DD.SCI_NOT_EXPONENT_CHAR = \"E\";\n  DD.SCI_NOT_ZERO = \"0.0E0\";\n\n  function CGAlgorithmsDD() {}\n  extend(CGAlgorithmsDD.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn CGAlgorithmsDD;\n  \t}\n  });\n  CGAlgorithmsDD.orientationIndex = function (p1, p2, q) {\n  \tvar index = CGAlgorithmsDD.orientationIndexFilter(p1, p2, q);\n  \tif (index <= 1) return index;\n  \tvar dx1 = DD.valueOf(p2.x).selfAdd(-p1.x);\n  \tvar dy1 = DD.valueOf(p2.y).selfAdd(-p1.y);\n  \tvar dx2 = DD.valueOf(q.x).selfAdd(-p2.x);\n  \tvar dy2 = DD.valueOf(q.y).selfAdd(-p2.y);\n  \treturn dx1.selfMultiply(dy2).selfSubtract(dy1.selfMultiply(dx2)).signum();\n  };\n  CGAlgorithmsDD.signOfDet2x2 = function (x1, y1, x2, y2) {\n  \tvar det = x1.multiply(y2).selfSubtract(y1.multiply(x2));\n  \treturn det.signum();\n  };\n  CGAlgorithmsDD.intersection = function (p1, p2, q1, q2) {\n  \tvar denom1 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p2.x).selfSubtract(p1.x));\n  \tvar denom2 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p2.y).selfSubtract(p1.y));\n  \tvar denom = denom1.subtract(denom2);\n  \tvar numx1 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));\n  \tvar numx2 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));\n  \tvar numx = numx1.subtract(numx2);\n  \tvar fracP = numx.selfDivide(denom).doubleValue();\n  \tvar x = DD.valueOf(p1.x).selfAdd(DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(fracP)).doubleValue();\n  \tvar numy1 = DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));\n  \tvar numy2 = DD.valueOf(p2.y).selfSubtract(p1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));\n  \tvar numy = numy1.subtract(numy2);\n  \tvar fracQ = numy.selfDivide(denom).doubleValue();\n  \tvar y = DD.valueOf(q1.y).selfAdd(DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(fracQ)).doubleValue();\n  \treturn new Coordinate(x, y);\n  };\n  CGAlgorithmsDD.orientationIndexFilter = function (pa, pb, pc) {\n  \tvar detsum = null;\n  \tvar detleft = (pa.x - pc.x) * (pb.y - pc.y);\n  \tvar detright = (pa.y - pc.y) * (pb.x - pc.x);\n  \tvar det = detleft - detright;\n  \tif (detleft > 0.0) {\n  \t\tif (detright <= 0.0) {\n  \t\t\treturn CGAlgorithmsDD.signum(det);\n  \t\t} else {\n  \t\t\tdetsum = detleft + detright;\n  \t\t}\n  \t} else if (detleft < 0.0) {\n  \t\tif (detright >= 0.0) {\n  \t\t\treturn CGAlgorithmsDD.signum(det);\n  \t\t} else {\n  \t\t\tdetsum = -detleft - detright;\n  \t\t}\n  \t} else {\n  \t\treturn CGAlgorithmsDD.signum(det);\n  \t}\n  \tvar errbound = CGAlgorithmsDD.DP_SAFE_EPSILON * detsum;\n  \tif (det >= errbound || -det >= errbound) {\n  \t\treturn CGAlgorithmsDD.signum(det);\n  \t}\n  \treturn 2;\n  };\n  CGAlgorithmsDD.signum = function (x) {\n  \tif (x > 0) return 1;\n  \tif (x < 0) return -1;\n  \treturn 0;\n  };\n  CGAlgorithmsDD.DP_SAFE_EPSILON = 1e-15;\n\n  function CoordinateSequence() {}\n  extend(CoordinateSequence.prototype, {\n  \tsetOrdinate: function setOrdinate(index, ordinateIndex, value) {},\n  \tsize: function size() {},\n  \tgetOrdinate: function getOrdinate(index, ordinateIndex) {},\n  \tgetCoordinate: function getCoordinate() {\n  \t},\n  \tgetCoordinateCopy: function getCoordinateCopy(i) {},\n  \tgetDimension: function getDimension() {},\n  \tgetX: function getX(index) {},\n  \tclone: function clone() {},\n  \texpandEnvelope: function expandEnvelope(env) {},\n  \tcopy: function copy() {},\n  \tgetY: function getY(index) {},\n  \ttoCoordinateArray: function toCoordinateArray() {},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Clonable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn CoordinateSequence;\n  \t}\n  });\n  CoordinateSequence.X = 0;\n  CoordinateSequence.Y = 1;\n  CoordinateSequence.Z = 2;\n  CoordinateSequence.M = 3;\n\n  function System() {}\n  System.arraycopy = function (src, srcPos, dest, destPos, len) {\n    var c = 0;\n    for (var i = srcPos; i < srcPos + len; i++) {\n      dest[destPos + c] = src[i];\n      c++;\n    }\n  };\n  System.getProperty = function (name) {\n    return {\n      'line.separator': '\\n'\n    }[name];\n  };\n\n  function HCoordinate() {\n  \tthis.x = null;\n  \tthis.y = null;\n  \tthis.w = null;\n  \tif (arguments.length === 0) {\n  \t\tthis.x = 0.0;\n  \t\tthis.y = 0.0;\n  \t\tthis.w = 1.0;\n  \t} else if (arguments.length === 1) {\n  \t\tvar p = arguments[0];\n  \t\tthis.x = p.x;\n  \t\tthis.y = p.y;\n  \t\tthis.w = 1.0;\n  \t} else if (arguments.length === 2) {\n  \t\tif (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\") {\n  \t\t\tvar _x = arguments[0],\n  \t\t\t    _y = arguments[1];\n  \t\t\tthis.x = _x;\n  \t\t\tthis.y = _y;\n  \t\t\tthis.w = 1.0;\n  \t\t} else if (arguments[0] instanceof HCoordinate && arguments[1] instanceof HCoordinate) {\n  \t\t\tvar p1 = arguments[0],\n  \t\t\t    p2 = arguments[1];\n  \t\t\tthis.x = p1.y * p2.w - p2.y * p1.w;\n  \t\t\tthis.y = p2.x * p1.w - p1.x * p2.w;\n  \t\t\tthis.w = p1.x * p2.y - p2.x * p1.y;\n  \t\t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n  \t\t\tvar p1 = arguments[0],\n  \t\t\t    p2 = arguments[1];\n  \t\t\tthis.x = p1.y - p2.y;\n  \t\t\tthis.y = p2.x - p1.x;\n  \t\t\tthis.w = p1.x * p2.y - p2.x * p1.y;\n  \t\t}\n  \t} else if (arguments.length === 3) {\n  \t\tvar _x = arguments[0],\n  \t\t    _y = arguments[1],\n  \t\t    _w = arguments[2];\n  \t\tthis.x = _x;\n  \t\tthis.y = _y;\n  \t\tthis.w = _w;\n  \t} else if (arguments.length === 4) {\n  \t\tvar p1 = arguments[0],\n  \t\t    p2 = arguments[1],\n  \t\t    q1 = arguments[2],\n  \t\t    q2 = arguments[3];\n  \t\tvar px = p1.y - p2.y;\n  \t\tvar py = p2.x - p1.x;\n  \t\tvar pw = p1.x * p2.y - p2.x * p1.y;\n  \t\tvar qx = q1.y - q2.y;\n  \t\tvar qy = q2.x - q1.x;\n  \t\tvar qw = q1.x * q2.y - q2.x * q1.y;\n  \t\tthis.x = py * qw - qy * pw;\n  \t\tthis.y = qx * pw - px * qw;\n  \t\tthis.w = px * qy - qx * py;\n  \t}\n  }\n  extend(HCoordinate.prototype, {\n  \tgetY: function getY() {\n  \t\tvar a = this.y / this.w;\n  \t\tif (Double.isNaN(a) || Double.isInfinite(a)) {\n  \t\t\tthrow new NotRepresentableException();\n  \t\t}\n  \t\treturn a;\n  \t},\n  \tgetX: function getX() {\n  \t\tvar a = this.x / this.w;\n  \t\tif (Double.isNaN(a) || Double.isInfinite(a)) {\n  \t\t\tthrow new NotRepresentableException();\n  \t\t}\n  \t\treturn a;\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\tvar p = new Coordinate();\n  \t\tp.x = this.getX();\n  \t\tp.y = this.getY();\n  \t\treturn p;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn HCoordinate;\n  \t}\n  });\n  HCoordinate.intersection = function (p1, p2, q1, q2) {\n  \tvar px = p1.y - p2.y;\n  \tvar py = p2.x - p1.x;\n  \tvar pw = p1.x * p2.y - p2.x * p1.y;\n  \tvar qx = q1.y - q2.y;\n  \tvar qy = q2.x - q1.x;\n  \tvar qw = q1.x * q2.y - q2.x * q1.y;\n  \tvar x = py * qw - qy * pw;\n  \tvar y = qx * pw - px * qw;\n  \tvar w = px * qy - qx * py;\n  \tvar xInt = x / w;\n  \tvar yInt = y / w;\n  \tif (Double.isNaN(xInt) || Double.isInfinite(xInt) || Double.isNaN(yInt) || Double.isInfinite(yInt)) {\n  \t\tthrow new NotRepresentableException();\n  \t}\n  \treturn new Coordinate(xInt, yInt);\n  };\n\n  function CoordinateSequenceFactory() {}\n  extend(CoordinateSequenceFactory.prototype, {\n  \tcreate: function create() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tif (arguments[0] instanceof Array) ; else if (hasInterface(arguments[0], CoordinateSequence)) ;\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn CoordinateSequenceFactory;\n  \t}\n  });\n\n  function GeometryComponentFilter() {}\n  extend(GeometryComponentFilter.prototype, {\n  \tfilter: function filter(geom) {},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn GeometryComponentFilter;\n  \t}\n  });\n\n  function Geometry() {\n  \tthis._envelope = null;\n  \tthis._factory = null;\n  \tthis._SRID = null;\n  \tthis._userData = null;\n  \tvar factory = arguments[0];\n  \tthis._factory = factory;\n  \tthis._SRID = factory.getSRID();\n  }\n  extend(Geometry.prototype, {\n  \tisGeometryCollection: function isGeometryCollection() {\n  \t\treturn this.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION;\n  \t},\n  \tgetFactory: function getFactory() {\n  \t\treturn this._factory;\n  \t},\n  \tgetGeometryN: function getGeometryN(n) {\n  \t\treturn this;\n  \t},\n  \tgetArea: function getArea() {\n  \t\treturn 0.0;\n  \t},\n  \tisRectangle: function isRectangle() {\n  \t\treturn false;\n  \t},\n  \tequals: function equals() {\n  \t\tif (arguments[0] instanceof Geometry) {\n  \t\t\tvar g = arguments[0];\n  \t\t\tif (g === null) return false;\n  \t\t\treturn this.equalsTopo(g);\n  \t\t} else if (arguments[0] instanceof Object) {\n  \t\t\tvar o = arguments[0];\n  \t\t\tif (!(o instanceof Geometry)) return false;\n  \t\t\tvar g = o;\n  \t\t\treturn this.equalsExact(g);\n  \t\t}\n  \t},\n  \tequalsExact: function equalsExact(other) {\n  \t\treturn this === other || this.equalsExact(other, 0);\n  \t},\n  \tgeometryChanged: function geometryChanged() {\n  \t\tthis.apply(Geometry.geometryChangedFilter);\n  \t},\n  \tgeometryChangedAction: function geometryChangedAction() {\n  \t\tthis._envelope = null;\n  \t},\n  \tequalsNorm: function equalsNorm(g) {\n  \t\tif (g === null) return false;\n  \t\treturn this.norm().equalsExact(g.norm());\n  \t},\n  \tgetLength: function getLength() {\n  \t\treturn 0.0;\n  \t},\n  \tgetNumGeometries: function getNumGeometries() {\n  \t\treturn 1;\n  \t},\n  \tcompareTo: function compareTo() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar o = arguments[0];\n  \t\t\tvar other = o;\n  \t\t\tif (this.getSortIndex() !== other.getSortIndex()) {\n  \t\t\t\treturn this.getSortIndex() - other.getSortIndex();\n  \t\t\t}\n  \t\t\tif (this.isEmpty() && other.isEmpty()) {\n  \t\t\t\treturn 0;\n  \t\t\t}\n  \t\t\tif (this.isEmpty()) {\n  \t\t\t\treturn -1;\n  \t\t\t}\n  \t\t\tif (other.isEmpty()) {\n  \t\t\t\treturn 1;\n  \t\t\t}\n  \t\t\treturn this.compareToSameClass(o);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar o = arguments[0],\n  \t\t\t    comp = arguments[1];\n  \t\t\tvar other = o;\n  \t\t\tif (this.getSortIndex() !== other.getSortIndex()) {\n  \t\t\t\treturn this.getSortIndex() - other.getSortIndex();\n  \t\t\t}\n  \t\t\tif (this.isEmpty() && other.isEmpty()) {\n  \t\t\t\treturn 0;\n  \t\t\t}\n  \t\t\tif (this.isEmpty()) {\n  \t\t\t\treturn -1;\n  \t\t\t}\n  \t\t\tif (other.isEmpty()) {\n  \t\t\t\treturn 1;\n  \t\t\t}\n  \t\t\treturn this.compareToSameClass(o, comp);\n  \t\t}\n  \t},\n  \tgetUserData: function getUserData() {\n  \t\treturn this._userData;\n  \t},\n  \tgetSRID: function getSRID() {\n  \t\treturn this._SRID;\n  \t},\n  \tgetEnvelope: function getEnvelope() {\n  \t\treturn this.getFactory().toGeometry(this.getEnvelopeInternal());\n  \t},\n  \tcheckNotGeometryCollection: function checkNotGeometryCollection(g) {\n  \t\tif (g.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION) {\n  \t\t\tthrow new IllegalArgumentException(\"This method does not support GeometryCollection arguments\");\n  \t\t}\n  \t},\n  \tequal: function equal(a, b, tolerance) {\n  \t\tif (tolerance === 0) {\n  \t\t\treturn a.equals(b);\n  \t\t}\n  \t\treturn a.distance(b) <= tolerance;\n  \t},\n  \tnorm: function norm() {\n  \t\tvar copy = this.copy();\n  \t\tcopy.normalize();\n  \t\treturn copy;\n  \t},\n  \tgetPrecisionModel: function getPrecisionModel() {\n  \t\treturn this._factory.getPrecisionModel();\n  \t},\n  \tgetEnvelopeInternal: function getEnvelopeInternal() {\n  \t\tif (this._envelope === null) {\n  \t\t\tthis._envelope = this.computeEnvelopeInternal();\n  \t\t}\n  \t\treturn new Envelope(this._envelope);\n  \t},\n  \tsetSRID: function setSRID(SRID) {\n  \t\tthis._SRID = SRID;\n  \t},\n  \tsetUserData: function setUserData(userData) {\n  \t\tthis._userData = userData;\n  \t},\n  \tcompare: function compare(a, b) {\n  \t\tvar i = a.iterator();\n  \t\tvar j = b.iterator();\n  \t\twhile (i.hasNext() && j.hasNext()) {\n  \t\t\tvar aElement = i.next();\n  \t\t\tvar bElement = j.next();\n  \t\t\tvar comparison = aElement.compareTo(bElement);\n  \t\t\tif (comparison !== 0) {\n  \t\t\t\treturn comparison;\n  \t\t\t}\n  \t\t}\n  \t\tif (i.hasNext()) {\n  \t\t\treturn 1;\n  \t\t}\n  \t\tif (j.hasNext()) {\n  \t\t\treturn -1;\n  \t\t}\n  \t\treturn 0;\n  \t},\n  \thashCode: function hashCode() {\n  \t\treturn this.getEnvelopeInternal().hashCode();\n  \t},\n  \tisGeometryCollectionOrDerived: function isGeometryCollectionOrDerived() {\n  \t\tif (this.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === Geometry.SORTINDEX_MULTIPOINT || this.getSortIndex() === Geometry.SORTINDEX_MULTILINESTRING || this.getSortIndex() === Geometry.SORTINDEX_MULTIPOLYGON) {\n  \t\t\treturn true;\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Clonable, Comparable, Serializable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Geometry;\n  \t}\n  });\n  Geometry.hasNonEmptyElements = function (geometries) {\n  \tfor (var i = 0; i < geometries.length; i++) {\n  \t\tif (!geometries[i].isEmpty()) {\n  \t\t\treturn true;\n  \t\t}\n  \t}\n  \treturn false;\n  };\n  Geometry.hasNullElements = function (array) {\n  \tfor (var i = 0; i < array.length; i++) {\n  \t\tif (array[i] === null) {\n  \t\t\treturn true;\n  \t\t}\n  \t}\n  \treturn false;\n  };\n  Geometry.serialVersionUID = 8763622679187376702;\n  Geometry.SORTINDEX_POINT = 0;\n  Geometry.SORTINDEX_MULTIPOINT = 1;\n  Geometry.SORTINDEX_LINESTRING = 2;\n  Geometry.SORTINDEX_LINEARRING = 3;\n  Geometry.SORTINDEX_MULTILINESTRING = 4;\n  Geometry.SORTINDEX_POLYGON = 5;\n  Geometry.SORTINDEX_MULTIPOLYGON = 6;\n  Geometry.SORTINDEX_GEOMETRYCOLLECTION = 7;\n  Geometry.geometryChangedFilter = {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [GeometryComponentFilter];\n  \t},\n  \tfilter: function filter(geom) {\n  \t\tgeom.geometryChangedAction();\n  \t}\n  };\n\n  function CoordinateFilter() {}\n  extend(CoordinateFilter.prototype, {\n  \tfilter: function filter(coord) {},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn CoordinateFilter;\n  \t}\n  });\n\n  function BoundaryNodeRule() {}\n  extend(BoundaryNodeRule.prototype, {\n  \tisInBoundary: function isInBoundary(boundaryCount) {},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn BoundaryNodeRule;\n  \t}\n  });\n  function Mod2BoundaryNodeRule() {}\n  extend(Mod2BoundaryNodeRule.prototype, {\n  \tisInBoundary: function isInBoundary(boundaryCount) {\n  \t\treturn boundaryCount % 2 === 1;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [BoundaryNodeRule];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Mod2BoundaryNodeRule;\n  \t}\n  });\n  function EndPointBoundaryNodeRule() {}\n  extend(EndPointBoundaryNodeRule.prototype, {\n  \tisInBoundary: function isInBoundary(boundaryCount) {\n  \t\treturn boundaryCount > 0;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [BoundaryNodeRule];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn EndPointBoundaryNodeRule;\n  \t}\n  });\n  function MultiValentEndPointBoundaryNodeRule() {}\n  extend(MultiValentEndPointBoundaryNodeRule.prototype, {\n  \tisInBoundary: function isInBoundary(boundaryCount) {\n  \t\treturn boundaryCount > 1;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [BoundaryNodeRule];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MultiValentEndPointBoundaryNodeRule;\n  \t}\n  });\n  function MonoValentEndPointBoundaryNodeRule() {}\n  extend(MonoValentEndPointBoundaryNodeRule.prototype, {\n  \tisInBoundary: function isInBoundary(boundaryCount) {\n  \t\treturn boundaryCount === 1;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [BoundaryNodeRule];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MonoValentEndPointBoundaryNodeRule;\n  \t}\n  });\n  BoundaryNodeRule.Mod2BoundaryNodeRule = Mod2BoundaryNodeRule;\n  BoundaryNodeRule.EndPointBoundaryNodeRule = EndPointBoundaryNodeRule;\n  BoundaryNodeRule.MultiValentEndPointBoundaryNodeRule = MultiValentEndPointBoundaryNodeRule;\n  BoundaryNodeRule.MonoValentEndPointBoundaryNodeRule = MonoValentEndPointBoundaryNodeRule;\n  BoundaryNodeRule.MOD2_BOUNDARY_RULE = new Mod2BoundaryNodeRule();\n  BoundaryNodeRule.ENDPOINT_BOUNDARY_RULE = new EndPointBoundaryNodeRule();\n  BoundaryNodeRule.MULTIVALENT_ENDPOINT_BOUNDARY_RULE = new MultiValentEndPointBoundaryNodeRule();\n  BoundaryNodeRule.MONOVALENT_ENDPOINT_BOUNDARY_RULE = new MonoValentEndPointBoundaryNodeRule();\n  BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE = BoundaryNodeRule.MOD2_BOUNDARY_RULE;\n\n  function CoordinateArrays() {}\n  extend(CoordinateArrays.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn CoordinateArrays;\n  \t}\n  });\n  CoordinateArrays.isRing = function (pts) {\n  \tif (pts.length < 4) return false;\n  \tif (!pts[0].equals2D(pts[pts.length - 1])) return false;\n  \treturn true;\n  };\n  CoordinateArrays.ptNotInList = function (testPts, pts) {\n  \tfor (var i = 0; i < testPts.length; i++) {\n  \t\tvar testPt = testPts[i];\n  \t\tif (CoordinateArrays.indexOf(testPt, pts) < 0) return testPt;\n  \t}\n  \treturn null;\n  };\n  CoordinateArrays.scroll = function (coordinates, firstCoordinate) {\n  \tvar i = CoordinateArrays.indexOf(firstCoordinate, coordinates);\n  \tif (i < 0) return null;\n  \tvar newCoordinates = new Array(coordinates.length).fill(null);\n  \tSystem.arraycopy(coordinates, i, newCoordinates, 0, coordinates.length - i);\n  \tSystem.arraycopy(coordinates, 0, newCoordinates, coordinates.length - i, i);\n  \tSystem.arraycopy(newCoordinates, 0, coordinates, 0, coordinates.length);\n  };\n  CoordinateArrays.equals = function () {\n  \tif (arguments.length === 2) {\n  \t\tvar coord1 = arguments[0],\n  \t\t    coord2 = arguments[1];\n  \t\tif (coord1 === coord2) return true;\n  \t\tif (coord1 === null || coord2 === null) return false;\n  \t\tif (coord1.length !== coord2.length) return false;\n  \t\tfor (var i = 0; i < coord1.length; i++) {\n  \t\t\tif (!coord1[i].equals(coord2[i])) return false;\n  \t\t}\n  \t\treturn true;\n  \t} else if (arguments.length === 3) {\n  \t\tvar coord1 = arguments[0],\n  \t\t    coord2 = arguments[1],\n  \t\t    coordinateComparator = arguments[2];\n  \t\tif (coord1 === coord2) return true;\n  \t\tif (coord1 === null || coord2 === null) return false;\n  \t\tif (coord1.length !== coord2.length) return false;\n  \t\tfor (var i = 0; i < coord1.length; i++) {\n  \t\t\tif (coordinateComparator.compare(coord1[i], coord2[i]) !== 0) return false;\n  \t\t}\n  \t\treturn true;\n  \t}\n  };\n  CoordinateArrays.intersection = function (coordinates, env) {\n  \tvar coordList = new CoordinateList();\n  \tfor (var i = 0; i < coordinates.length; i++) {\n  \t\tif (env.intersects(coordinates[i])) coordList.add(coordinates[i], true);\n  \t}\n  \treturn coordList.toCoordinateArray();\n  };\n  CoordinateArrays.hasRepeatedPoints = function (coord) {\n  \tfor (var i = 1; i < coord.length; i++) {\n  \t\tif (coord[i - 1].equals(coord[i])) {\n  \t\t\treturn true;\n  \t\t}\n  \t}\n  \treturn false;\n  };\n  CoordinateArrays.removeRepeatedPoints = function (coord) {\n  \tif (!CoordinateArrays.hasRepeatedPoints(coord)) return coord;\n  \tvar coordList = new CoordinateList(coord, false);\n  \treturn coordList.toCoordinateArray();\n  };\n  CoordinateArrays.reverse = function (coord) {\n  \tvar last = coord.length - 1;\n  \tvar mid = Math.trunc(last / 2);\n  \tfor (var i = 0; i <= mid; i++) {\n  \t\tvar tmp = coord[i];\n  \t\tcoord[i] = coord[last - i];\n  \t\tcoord[last - i] = tmp;\n  \t}\n  };\n  CoordinateArrays.removeNull = function (coord) {\n  \tvar nonNull = 0;\n  \tfor (var i = 0; i < coord.length; i++) {\n  \t\tif (coord[i] !== null) nonNull++;\n  \t}\n  \tvar newCoord = new Array(nonNull).fill(null);\n  \tif (nonNull === 0) return newCoord;\n  \tvar j = 0;\n  \tfor (var i = 0; i < coord.length; i++) {\n  \t\tif (coord[i] !== null) newCoord[j++] = coord[i];\n  \t}\n  \treturn newCoord;\n  };\n  CoordinateArrays.copyDeep = function () {\n  \tif (arguments.length === 1) {\n  \t\tvar coordinates = arguments[0];\n  \t\tvar copy = new Array(coordinates.length).fill(null);\n  \t\tfor (var i = 0; i < coordinates.length; i++) {\n  \t\t\tcopy[i] = new Coordinate(coordinates[i]);\n  \t\t}\n  \t\treturn copy;\n  \t} else if (arguments.length === 5) {\n  \t\tvar src = arguments[0],\n  \t\t    srcStart = arguments[1],\n  \t\t    dest = arguments[2],\n  \t\t    destStart = arguments[3],\n  \t\t    length = arguments[4];\n  \t\tfor (var i = 0; i < length; i++) {\n  \t\t\tdest[destStart + i] = new Coordinate(src[srcStart + i]);\n  \t\t}\n  \t}\n  };\n  CoordinateArrays.isEqualReversed = function (pts1, pts2) {\n  \tfor (var i = 0; i < pts1.length; i++) {\n  \t\tvar p1 = pts1[i];\n  \t\tvar p2 = pts2[pts1.length - i - 1];\n  \t\tif (p1.compareTo(p2) !== 0) return false;\n  \t}\n  \treturn true;\n  };\n  CoordinateArrays.envelope = function (coordinates) {\n  \tvar env = new Envelope();\n  \tfor (var i = 0; i < coordinates.length; i++) {\n  \t\tenv.expandToInclude(coordinates[i]);\n  \t}\n  \treturn env;\n  };\n  CoordinateArrays.toCoordinateArray = function (coordList) {\n  \treturn coordList.toArray(CoordinateArrays.coordArrayType);\n  };\n  CoordinateArrays.atLeastNCoordinatesOrNothing = function (n, c) {\n  \treturn c.length >= n ? c : [];\n  };\n  CoordinateArrays.indexOf = function (coordinate, coordinates) {\n  \tfor (var i = 0; i < coordinates.length; i++) {\n  \t\tif (coordinate.equals(coordinates[i])) {\n  \t\t\treturn i;\n  \t\t}\n  \t}\n  \treturn -1;\n  };\n  CoordinateArrays.increasingDirection = function (pts) {\n  \tfor (var i = 0; i < Math.trunc(pts.length / 2); i++) {\n  \t\tvar j = pts.length - 1 - i;\n  \t\tvar comp = pts[i].compareTo(pts[j]);\n  \t\tif (comp !== 0) return comp;\n  \t}\n  \treturn 1;\n  };\n  CoordinateArrays.compare = function (pts1, pts2) {\n  \tvar i = 0;\n  \twhile (i < pts1.length && i < pts2.length) {\n  \t\tvar compare = pts1[i].compareTo(pts2[i]);\n  \t\tif (compare !== 0) return compare;\n  \t\ti++;\n  \t}\n  \tif (i < pts2.length) return -1;\n  \tif (i < pts1.length) return 1;\n  \treturn 0;\n  };\n  CoordinateArrays.minCoordinate = function (coordinates) {\n  \tvar minCoord = null;\n  \tfor (var i = 0; i < coordinates.length; i++) {\n  \t\tif (minCoord === null || minCoord.compareTo(coordinates[i]) > 0) {\n  \t\t\tminCoord = coordinates[i];\n  \t\t}\n  \t}\n  \treturn minCoord;\n  };\n  CoordinateArrays.extract = function (pts, start, end) {\n  \tstart = MathUtil.clamp(start, 0, pts.length);\n  \tend = MathUtil.clamp(end, -1, pts.length);\n  \tvar npts = end - start + 1;\n  \tif (end < 0) npts = 0;\n  \tif (start >= pts.length) npts = 0;\n  \tif (end < start) npts = 0;\n  \tvar extractPts = new Array(npts).fill(null);\n  \tif (npts === 0) return extractPts;\n  \tvar iPts = 0;\n  \tfor (var i = start; i <= end; i++) {\n  \t\textractPts[iPts++] = pts[i];\n  \t}\n  \treturn extractPts;\n  };\n  function ForwardComparator() {}\n  extend(ForwardComparator.prototype, {\n  \tcompare: function compare(o1, o2) {\n  \t\tvar pts1 = o1;\n  \t\tvar pts2 = o2;\n  \t\treturn CoordinateArrays.compare(pts1, pts2);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparator];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn ForwardComparator;\n  \t}\n  });\n  function BidirectionalComparator() {}\n  extend(BidirectionalComparator.prototype, {\n  \tcompare: function compare(o1, o2) {\n  \t\tvar pts1 = o1;\n  \t\tvar pts2 = o2;\n  \t\tif (pts1.length < pts2.length) return -1;\n  \t\tif (pts1.length > pts2.length) return 1;\n  \t\tif (pts1.length === 0) return 0;\n  \t\tvar forwardComp = CoordinateArrays.compare(pts1, pts2);\n  \t\tvar isEqualRev = CoordinateArrays.isEqualReversed(pts1, pts2);\n  \t\tif (isEqualRev) return 0;\n  \t\treturn forwardComp;\n  \t},\n  \tOLDcompare: function OLDcompare(o1, o2) {\n  \t\tvar pts1 = o1;\n  \t\tvar pts2 = o2;\n  \t\tif (pts1.length < pts2.length) return -1;\n  \t\tif (pts1.length > pts2.length) return 1;\n  \t\tif (pts1.length === 0) return 0;\n  \t\tvar dir1 = CoordinateArrays.increasingDirection(pts1);\n  \t\tvar dir2 = CoordinateArrays.increasingDirection(pts2);\n  \t\tvar i1 = dir1 > 0 ? 0 : pts1.length - 1;\n  \t\tvar i2 = dir2 > 0 ? 0 : pts1.length - 1;\n  \t\tfor (var i = 0; i < pts1.length; i++) {\n  \t\t\tvar comparePt = pts1[i1].compareTo(pts2[i2]);\n  \t\t\tif (comparePt !== 0) return comparePt;\n  \t\t\ti1 += dir1;\n  \t\t\ti2 += dir2;\n  \t\t}\n  \t\treturn 0;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparator];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn BidirectionalComparator;\n  \t}\n  });\n  CoordinateArrays.ForwardComparator = ForwardComparator;\n  CoordinateArrays.BidirectionalComparator = BidirectionalComparator;\n  CoordinateArrays.coordArrayType = new Array(0).fill(null);\n\n  function Map$2() {}Map$2.prototype.get = function () {};\n  Map$2.prototype.put = function () {};\n  Map$2.prototype.size = function () {};\n  Map$2.prototype.values = function () {};\n  Map$2.prototype.entrySet = function () {};\n\n  function SortedMap() {}SortedMap.prototype = new Map$2();\n\n  function Set$1() {}Set$1.prototype = new Collection();\n  Set$1.prototype.contains = function () {};\n\n  function HashSet() {\n    this.array_ = [];\n    if (arguments[0] instanceof Collection) {\n      this.addAll(arguments[0]);\n    }\n  }HashSet.prototype = new Set$1();\n  HashSet.prototype.contains = function (o) {\n    for (var i = 0, len = this.array_.length; i < len; i++) {\n      var e = this.array_[i];\n      if (e === o) {\n        return true;\n      }\n    }\n    return false;\n  };\n  HashSet.prototype.add = function (o) {\n    if (this.contains(o)) {\n      return false;\n    }\n    this.array_.push(o);\n    return true;\n  };\n  HashSet.prototype.addAll = function (c) {\n    for (var i = c.iterator(); i.hasNext();) {\n      this.add(i.next());\n    }\n    return true;\n  };\n  HashSet.prototype.remove = function (o) {\n    throw new javascript.util.OperationNotSupported();\n  };\n  HashSet.prototype.size = function () {\n    return this.array_.length;\n  };\n  HashSet.prototype.isEmpty = function () {\n    return this.array_.length === 0;\n  };\n  HashSet.prototype.toArray = function () {\n    var array = [];\n    for (var i = 0, len = this.array_.length; i < len; i++) {\n      array.push(this.array_[i]);\n    }\n    return array;\n  };\n  HashSet.prototype.iterator = function () {\n    return new Iterator_$1(this);\n  };\n  var Iterator_$1 = function Iterator_(hashSet) {\n    this.hashSet_ = hashSet;\n    this.position_ = 0;\n  };\n  Iterator_$1.prototype.next = function () {\n    if (this.position_ === this.hashSet_.size()) {\n      throw new NoSuchElementException();\n    }\n    return this.hashSet_.array_[this.position_++];\n  };\n  Iterator_$1.prototype.hasNext = function () {\n    if (this.position_ < this.hashSet_.size()) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  Iterator_$1.prototype.remove = function () {\n    throw new OperationNotSupported();\n  };\n\n  var BLACK = 0;\n  var RED = 1;\n  function colorOf(p) {\n    return p == null ? BLACK : p.color;\n  }\n  function parentOf(p) {\n    return p == null ? null : p.parent;\n  }\n  function setColor(p, c) {\n    if (p !== null) p.color = c;\n  }\n  function leftOf(p) {\n    return p == null ? null : p.left;\n  }\n  function rightOf(p) {\n    return p == null ? null : p.right;\n  }\n  function TreeMap() {\n    this.root_ = null;\n    this.size_ = 0;\n  }TreeMap.prototype = new SortedMap();\n  TreeMap.prototype.get = function (key) {\n    var p = this.root_;\n    while (p !== null) {\n      var cmp = key['compareTo'](p.key);\n      if (cmp < 0) {\n        p = p.left;\n      } else if (cmp > 0) {\n        p = p.right;\n      } else {\n        return p.value;\n      }\n    }\n    return null;\n  };\n  TreeMap.prototype.put = function (key, value) {\n    if (this.root_ === null) {\n      this.root_ = {\n        key: key,\n        value: value,\n        left: null,\n        right: null,\n        parent: null,\n        color: BLACK,\n        getValue: function getValue() {\n          return this.value;\n        },\n        getKey: function getKey() {\n          return this.key;\n        }\n      };\n      this.size_ = 1;\n      return null;\n    }\n    var t = this.root_,\n        parent,\n        cmp;\n    do {\n      parent = t;\n      cmp = key['compareTo'](t.key);\n      if (cmp < 0) {\n        t = t.left;\n      } else if (cmp > 0) {\n        t = t.right;\n      } else {\n        var oldValue = t.value;\n        t.value = value;\n        return oldValue;\n      }\n    } while (t !== null);\n    var e = {\n      key: key,\n      left: null,\n      right: null,\n      value: value,\n      parent: parent,\n      color: BLACK,\n      getValue: function getValue() {\n        return this.value;\n      },\n      getKey: function getKey() {\n        return this.key;\n      }\n    };\n    if (cmp < 0) {\n      parent.left = e;\n    } else {\n      parent.right = e;\n    }\n    this.fixAfterInsertion(e);\n    this.size_++;\n    return null;\n  };\n  TreeMap.prototype.fixAfterInsertion = function (x) {\n    x.color = RED;\n    while (x != null && x != this.root_ && x.parent.color == RED) {\n      if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {\n        var y = rightOf(parentOf(parentOf(x)));\n        if (colorOf(y) == RED) {\n          setColor(parentOf(x), BLACK);\n          setColor(y, BLACK);\n          setColor(parentOf(parentOf(x)), RED);\n          x = parentOf(parentOf(x));\n        } else {\n          if (x == rightOf(parentOf(x))) {\n            x = parentOf(x);\n            this.rotateLeft(x);\n          }\n          setColor(parentOf(x), BLACK);\n          setColor(parentOf(parentOf(x)), RED);\n          this.rotateRight(parentOf(parentOf(x)));\n        }\n      } else {\n        var y = leftOf(parentOf(parentOf(x)));\n        if (colorOf(y) == RED) {\n          setColor(parentOf(x), BLACK);\n          setColor(y, BLACK);\n          setColor(parentOf(parentOf(x)), RED);\n          x = parentOf(parentOf(x));\n        } else {\n          if (x == leftOf(parentOf(x))) {\n            x = parentOf(x);\n            this.rotateRight(x);\n          }\n          setColor(parentOf(x), BLACK);\n          setColor(parentOf(parentOf(x)), RED);\n          this.rotateLeft(parentOf(parentOf(x)));\n        }\n      }\n    }\n    this.root_.color = BLACK;\n  };\n  TreeMap.prototype.values = function () {\n    var arrayList = new ArrayList();\n    var p = this.getFirstEntry();\n    if (p !== null) {\n      arrayList.add(p.value);\n      while ((p = TreeMap.successor(p)) !== null) {\n        arrayList.add(p.value);\n      }\n    }\n    return arrayList;\n  };\n  TreeMap.prototype.entrySet = function () {\n    var hashSet = new HashSet();\n    var p = this.getFirstEntry();\n    if (p !== null) {\n      hashSet.add(p);\n      while ((p = TreeMap.successor(p)) !== null) {\n        hashSet.add(p);\n      }\n    }\n    return hashSet;\n  };\n  TreeMap.prototype.rotateLeft = function (p) {\n    if (p != null) {\n      var r = p.right;\n      p.right = r.left;\n      if (r.left != null) r.left.parent = p;\n      r.parent = p.parent;\n      if (p.parent == null) this.root_ = r;else if (p.parent.left == p) p.parent.left = r;else p.parent.right = r;\n      r.left = p;\n      p.parent = r;\n    }\n  };\n  TreeMap.prototype.rotateRight = function (p) {\n    if (p != null) {\n      var l = p.left;\n      p.left = l.right;\n      if (l.right != null) l.right.parent = p;\n      l.parent = p.parent;\n      if (p.parent == null) this.root_ = l;else if (p.parent.right == p) p.parent.right = l;else p.parent.left = l;\n      l.right = p;\n      p.parent = l;\n    }\n  };\n  TreeMap.prototype.getFirstEntry = function () {\n    var p = this.root_;\n    if (p != null) {\n      while (p.left != null) {\n        p = p.left;\n      }\n    }\n    return p;\n  };\n  TreeMap.successor = function (t) {\n    if (t === null) return null;else if (t.right !== null) {\n      var p = t.right;\n      while (p.left !== null) {\n        p = p.left;\n      }\n      return p;\n    } else {\n      var p = t.parent;\n      var ch = t;\n      while (p !== null && ch === p.right) {\n        ch = p;\n        p = p.parent;\n      }\n      return p;\n    }\n  };\n  TreeMap.prototype.size = function () {\n    return this.size_;\n  };\n\n  function Lineal() {}\n  extend(Lineal.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Lineal;\n  \t}\n  });\n\n  function SortedSet() {}SortedSet.prototype = new Set$1();\n\n  function TreeSet() {\n    this.array_ = [];\n    if (arguments[0] instanceof Collection) {\n      this.addAll(arguments[0]);\n    }\n  }TreeSet.prototype = new SortedSet();\n  TreeSet.prototype.contains = function (o) {\n    for (var i = 0, len = this.array_.length; i < len; i++) {\n      var e = this.array_[i];\n      if (e['compareTo'](o) === 0) {\n        return true;\n      }\n    }\n    return false;\n  };\n  TreeSet.prototype.add = function (o) {\n    if (this.contains(o)) {\n      return false;\n    }\n    for (var i = 0, len = this.array_.length; i < len; i++) {\n      var e = this.array_[i];\n      if (e['compareTo'](o) === 1) {\n        this.array_.splice(i, 0, o);\n        return true;\n      }\n    }\n    this.array_.push(o);\n    return true;\n  };\n  TreeSet.prototype.addAll = function (c) {\n    for (var i = c.iterator(); i.hasNext();) {\n      this.add(i.next());\n    }\n    return true;\n  };\n  TreeSet.prototype.remove = function (e) {\n    throw new OperationNotSupported();\n  };\n  TreeSet.prototype.size = function () {\n    return this.array_.length;\n  };\n  TreeSet.prototype.isEmpty = function () {\n    return this.array_.length === 0;\n  };\n  TreeSet.prototype.toArray = function () {\n    var array = [];\n    for (var i = 0, len = this.array_.length; i < len; i++) {\n      array.push(this.array_[i]);\n    }\n    return array;\n  };\n  TreeSet.prototype.iterator = function () {\n    return new Iterator_$2(this);\n  };\n  var Iterator_$2 = function Iterator_(treeSet) {\n    this.treeSet_ = treeSet;\n    this.position_ = 0;\n  };\n  Iterator_$2.prototype.next = function () {\n    if (this.position_ === this.treeSet_.size()) {\n      throw new NoSuchElementException();\n    }\n    return this.treeSet_.array_[this.position_++];\n  };\n  Iterator_$2.prototype.hasNext = function () {\n    if (this.position_ < this.treeSet_.size()) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  Iterator_$2.prototype.remove = function () {\n    throw new OperationNotSupported();\n  };\n\n  function Arrays() {}Arrays.sort = function () {\n    var a = arguments[0],\n        i,\n        t,\n        comparator,\n        compare;\n    if (arguments.length === 1) {\n      compare = function compare(a, b) {\n        return a.compareTo(b);\n      };\n      a.sort(compare);\n      return;\n    } else if (arguments.length === 2) {\n      comparator = arguments[1];\n      compare = function compare(a, b) {\n        return comparator['compare'](a, b);\n      };\n      a.sort(compare);\n    } else if (arguments.length === 3) {\n      t = a.slice(arguments[1], arguments[2]);\n      t.sort();\n      var r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));\n      a.splice(0, a.length);\n      for (i = 0; i < r.length; i++) {\n        a.push(r[i]);\n      }\n      return;\n    } else if (arguments.length === 4) {\n      t = a.slice(arguments[1], arguments[2]);\n      comparator = arguments[3];\n      compare = function compare(a, b) {\n        return comparator['compare'](a, b);\n      };\n      t.sort(compare);\n      r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));\n      a.splice(0, a.length);\n      for (i = 0; i < r.length; i++) {\n        a.push(r[i]);\n      }\n      return;\n    }\n  };\n  Arrays.asList = function (array) {\n    var arrayList = new ArrayList();\n    for (var i = 0, len = array.length; i < len; i++) {\n      arrayList.add(array[i]);\n    }\n    return arrayList;\n  };\n\n  function Dimension() {}\n  extend(Dimension.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Dimension;\n  \t}\n  });\n  Dimension.toDimensionSymbol = function (dimensionValue) {\n  \tswitch (dimensionValue) {\n  \t\tcase Dimension.FALSE:\n  \t\t\treturn Dimension.SYM_FALSE;\n  \t\tcase Dimension.TRUE:\n  \t\t\treturn Dimension.SYM_TRUE;\n  \t\tcase Dimension.DONTCARE:\n  \t\t\treturn Dimension.SYM_DONTCARE;\n  \t\tcase Dimension.P:\n  \t\t\treturn Dimension.SYM_P;\n  \t\tcase Dimension.L:\n  \t\t\treturn Dimension.SYM_L;\n  \t\tcase Dimension.A:\n  \t\t\treturn Dimension.SYM_A;\n  \t}\n  \tthrow new IllegalArgumentException(\"Unknown dimension value: \" + dimensionValue);\n  };\n  Dimension.toDimensionValue = function (dimensionSymbol) {\n  \tswitch (Character.toUpperCase(dimensionSymbol)) {\n  \t\tcase Dimension.SYM_FALSE:\n  \t\t\treturn Dimension.FALSE;\n  \t\tcase Dimension.SYM_TRUE:\n  \t\t\treturn Dimension.TRUE;\n  \t\tcase Dimension.SYM_DONTCARE:\n  \t\t\treturn Dimension.DONTCARE;\n  \t\tcase Dimension.SYM_P:\n  \t\t\treturn Dimension.P;\n  \t\tcase Dimension.SYM_L:\n  \t\t\treturn Dimension.L;\n  \t\tcase Dimension.SYM_A:\n  \t\t\treturn Dimension.A;\n  \t}\n  \tthrow new IllegalArgumentException(\"Unknown dimension symbol: \" + dimensionSymbol);\n  };\n  Dimension.P = 0;\n  Dimension.L = 1;\n  Dimension.A = 2;\n  Dimension.FALSE = -1;\n  Dimension.TRUE = -2;\n  Dimension.DONTCARE = -3;\n  Dimension.SYM_FALSE = 'F';\n  Dimension.SYM_TRUE = 'T';\n  Dimension.SYM_DONTCARE = '*';\n  Dimension.SYM_P = '0';\n  Dimension.SYM_L = '1';\n  Dimension.SYM_A = '2';\n\n  function GeometryFilter() {}\n  extend(GeometryFilter.prototype, {\n  \tfilter: function filter(geom) {},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn GeometryFilter;\n  \t}\n  });\n\n  function CoordinateSequenceFilter() {}\n  extend(CoordinateSequenceFilter.prototype, {\n  \tfilter: function filter(seq, i) {},\n  \tisDone: function isDone() {},\n  \tisGeometryChanged: function isGeometryChanged() {},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn CoordinateSequenceFilter;\n  \t}\n  });\n\n  function GeometryCollection() {\n  \tthis._geometries = null;\n  \tvar geometries = arguments[0],\n  \t    factory = arguments[1];\n  \tGeometry.call(this, factory);\n  \tif (geometries === null) {\n  \t\tgeometries = [];\n  \t}\n  \tif (Geometry.hasNullElements(geometries)) {\n  \t\tthrow new IllegalArgumentException(\"geometries must not contain null elements\");\n  \t}\n  \tthis._geometries = geometries;\n  }\n  inherits$1(GeometryCollection, Geometry);\n  extend(GeometryCollection.prototype, {\n  \tcomputeEnvelopeInternal: function computeEnvelopeInternal() {\n  \t\tvar envelope = new Envelope();\n  \t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\tenvelope.expandToInclude(this._geometries[i].getEnvelopeInternal());\n  \t\t}\n  \t\treturn envelope;\n  \t},\n  \tgetGeometryN: function getGeometryN(n) {\n  \t\treturn this._geometries[n];\n  \t},\n  \tgetSortIndex: function getSortIndex() {\n  \t\treturn Geometry.SORTINDEX_GEOMETRYCOLLECTION;\n  \t},\n  \tgetCoordinates: function getCoordinates() {\n  \t\tvar coordinates = new Array(this.getNumPoints()).fill(null);\n  \t\tvar k = -1;\n  \t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\tvar childCoordinates = this._geometries[i].getCoordinates();\n  \t\t\tfor (var j = 0; j < childCoordinates.length; j++) {\n  \t\t\t\tk++;\n  \t\t\t\tcoordinates[k] = childCoordinates[j];\n  \t\t\t}\n  \t\t}\n  \t\treturn coordinates;\n  \t},\n  \tgetArea: function getArea() {\n  \t\tvar area = 0.0;\n  \t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\tarea += this._geometries[i].getArea();\n  \t\t}\n  \t\treturn area;\n  \t},\n  \tequalsExact: function equalsExact() {\n  \t\tif (arguments.length === 2) {\n  \t\t\tvar other = arguments[0],\n  \t\t\t    tolerance = arguments[1];\n  \t\t\tif (!this.isEquivalentClass(other)) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t\tvar otherCollection = other;\n  \t\t\tif (this._geometries.length !== otherCollection._geometries.length) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\t\tif (!this._geometries[i].equalsExact(otherCollection._geometries[i], tolerance)) {\n  \t\t\t\t\treturn false;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\treturn true;\n  \t\t} else return Geometry.prototype.equalsExact.apply(this, arguments);\n  \t},\n  \tnormalize: function normalize() {\n  \t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\tthis._geometries[i].normalize();\n  \t\t}\n  \t\tArrays.sort(this._geometries);\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\tif (this.isEmpty()) return null;\n  \t\treturn this._geometries[0].getCoordinate();\n  \t},\n  \tgetBoundaryDimension: function getBoundaryDimension() {\n  \t\tvar dimension = Dimension.FALSE;\n  \t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\tdimension = Math.max(dimension, this._geometries[i].getBoundaryDimension());\n  \t\t}\n  \t\treturn dimension;\n  \t},\n  \tgetDimension: function getDimension() {\n  \t\tvar dimension = Dimension.FALSE;\n  \t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\tdimension = Math.max(dimension, this._geometries[i].getDimension());\n  \t\t}\n  \t\treturn dimension;\n  \t},\n  \tgetLength: function getLength() {\n  \t\tvar sum = 0.0;\n  \t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\tsum += this._geometries[i].getLength();\n  \t\t}\n  \t\treturn sum;\n  \t},\n  \tgetNumPoints: function getNumPoints() {\n  \t\tvar numPoints = 0;\n  \t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\tnumPoints += this._geometries[i].getNumPoints();\n  \t\t}\n  \t\treturn numPoints;\n  \t},\n  \tgetNumGeometries: function getNumGeometries() {\n  \t\treturn this._geometries.length;\n  \t},\n  \treverse: function reverse() {\n  \t\tvar n = this._geometries.length;\n  \t\tvar revGeoms = new Array(n).fill(null);\n  \t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\trevGeoms[i] = this._geometries[i].reverse();\n  \t\t}\n  \t\treturn this.getFactory().createGeometryCollection(revGeoms);\n  \t},\n  \tcompareToSameClass: function compareToSameClass() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar o = arguments[0];\n  \t\t\tvar theseElements = new TreeSet(Arrays.asList(this._geometries));\n  \t\t\tvar otherElements = new TreeSet(Arrays.asList(o._geometries));\n  \t\t\treturn this.compare(theseElements, otherElements);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar o = arguments[0],\n  \t\t\t    comp = arguments[1];\n  \t\t\tvar gc = o;\n  \t\t\tvar n1 = this.getNumGeometries();\n  \t\t\tvar n2 = gc.getNumGeometries();\n  \t\t\tvar i = 0;\n  \t\t\twhile (i < n1 && i < n2) {\n  \t\t\t\tvar thisGeom = this.getGeometryN(i);\n  \t\t\t\tvar otherGeom = gc.getGeometryN(i);\n  \t\t\t\tvar holeComp = thisGeom.compareToSameClass(otherGeom, comp);\n  \t\t\t\tif (holeComp !== 0) return holeComp;\n  \t\t\t\ti++;\n  \t\t\t}\n  \t\t\tif (i < n1) return 1;\n  \t\t\tif (i < n2) return -1;\n  \t\t\treturn 0;\n  \t\t}\n  \t},\n  \tapply: function apply() {\n  \t\tif (hasInterface(arguments[0], CoordinateFilter)) {\n  \t\t\tvar filter = arguments[0];\n  \t\t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\t\tthis._geometries[i].apply(filter);\n  \t\t\t}\n  \t\t} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n  \t\t\tvar filter = arguments[0];\n  \t\t\tif (this._geometries.length === 0) return null;\n  \t\t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\t\tthis._geometries[i].apply(filter);\n  \t\t\t\tif (filter.isDone()) {\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\tif (filter.isGeometryChanged()) this.geometryChanged();\n  \t\t} else if (hasInterface(arguments[0], GeometryFilter)) {\n  \t\t\tvar filter = arguments[0];\n  \t\t\tfilter.filter(this);\n  \t\t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\t\tthis._geometries[i].apply(filter);\n  \t\t\t}\n  \t\t} else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n  \t\t\tvar filter = arguments[0];\n  \t\t\tfilter.filter(this);\n  \t\t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\t\tthis._geometries[i].apply(filter);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetBoundary: function getBoundary() {\n  \t\tthis.checkNotGeometryCollection(this);\n  \t\tAssert.shouldNeverReachHere();\n  \t\treturn null;\n  \t},\n  \tclone: function clone() {\n  \t\tvar gc = Geometry.prototype.clone.call(this);\n  \t\tgc._geometries = new Array(this._geometries.length).fill(null);\n  \t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\tgc._geometries[i] = this._geometries[i].clone();\n  \t\t}\n  \t\treturn gc;\n  \t},\n  \tgetGeometryType: function getGeometryType() {\n  \t\treturn \"GeometryCollection\";\n  \t},\n  \tcopy: function copy() {\n  \t\tvar geometries = new Array(this._geometries.length).fill(null);\n  \t\tfor (var i = 0; i < geometries.length; i++) {\n  \t\t\tgeometries[i] = this._geometries[i].copy();\n  \t\t}\n  \t\treturn new GeometryCollection(geometries, this._factory);\n  \t},\n  \tisEmpty: function isEmpty() {\n  \t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\tif (!this._geometries[i].isEmpty()) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t}\n  \t\treturn true;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn GeometryCollection;\n  \t}\n  });\n  GeometryCollection.serialVersionUID = -5694727726395021467;\n\n  function MultiLineString() {\n  \tvar lineStrings = arguments[0],\n  \t    factory = arguments[1];\n  \tGeometryCollection.call(this, lineStrings, factory);\n  }\n  inherits$1(MultiLineString, GeometryCollection);\n  extend(MultiLineString.prototype, {\n  \tgetSortIndex: function getSortIndex() {\n  \t\treturn Geometry.SORTINDEX_MULTILINESTRING;\n  \t},\n  \tequalsExact: function equalsExact() {\n  \t\tif (arguments.length === 2) {\n  \t\t\tvar other = arguments[0],\n  \t\t\t    tolerance = arguments[1];\n  \t\t\tif (!this.isEquivalentClass(other)) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t\treturn GeometryCollection.prototype.equalsExact.call(this, other, tolerance);\n  \t\t} else return GeometryCollection.prototype.equalsExact.apply(this, arguments);\n  \t},\n  \tgetBoundaryDimension: function getBoundaryDimension() {\n  \t\tif (this.isClosed()) {\n  \t\t\treturn Dimension.FALSE;\n  \t\t}\n  \t\treturn 0;\n  \t},\n  \tisClosed: function isClosed() {\n  \t\tif (this.isEmpty()) {\n  \t\t\treturn false;\n  \t\t}\n  \t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\tif (!this._geometries[i].isClosed()) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t}\n  \t\treturn true;\n  \t},\n  \tgetDimension: function getDimension() {\n  \t\treturn 1;\n  \t},\n  \treverse: function reverse() {\n  \t\tvar nLines = this._geometries.length;\n  \t\tvar revLines = new Array(nLines).fill(null);\n  \t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\trevLines[nLines - 1 - i] = this._geometries[i].reverse();\n  \t\t}\n  \t\treturn this.getFactory().createMultiLineString(revLines);\n  \t},\n  \tgetBoundary: function getBoundary() {\n  \t\treturn new BoundaryOp(this).getBoundary();\n  \t},\n  \tgetGeometryType: function getGeometryType() {\n  \t\treturn \"MultiLineString\";\n  \t},\n  \tcopy: function copy() {\n  \t\tvar lineStrings = new Array(this._geometries.length).fill(null);\n  \t\tfor (var i = 0; i < lineStrings.length; i++) {\n  \t\t\tlineStrings[i] = this._geometries[i].copy();\n  \t\t}\n  \t\treturn new MultiLineString(lineStrings, this._factory);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Lineal];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MultiLineString;\n  \t}\n  });\n  MultiLineString.serialVersionUID = 8166665132445433741;\n\n  function BoundaryOp() {\n  \tthis._geom = null;\n  \tthis._geomFact = null;\n  \tthis._bnRule = null;\n  \tthis._endpointMap = null;\n  \tif (arguments.length === 1) {\n  \t\tvar geom = arguments[0];\n  \t\tBoundaryOp.call(this, geom, BoundaryNodeRule.MOD2_BOUNDARY_RULE);\n  \t} else if (arguments.length === 2) {\n  \t\tvar geom = arguments[0],\n  \t\t    bnRule = arguments[1];\n  \t\tthis._geom = geom;\n  \t\tthis._geomFact = geom.getFactory();\n  \t\tthis._bnRule = bnRule;\n  \t}\n  }\n  extend(BoundaryOp.prototype, {\n  \tboundaryMultiLineString: function boundaryMultiLineString(mLine) {\n  \t\tif (this._geom.isEmpty()) {\n  \t\t\treturn this.getEmptyMultiPoint();\n  \t\t}\n  \t\tvar bdyPts = this.computeBoundaryCoordinates(mLine);\n  \t\tif (bdyPts.length === 1) {\n  \t\t\treturn this._geomFact.createPoint(bdyPts[0]);\n  \t\t}\n  \t\treturn this._geomFact.createMultiPointFromCoords(bdyPts);\n  \t},\n  \tgetBoundary: function getBoundary() {\n  \t\tif (this._geom instanceof LineString) return this.boundaryLineString(this._geom);\n  \t\tif (this._geom instanceof MultiLineString) return this.boundaryMultiLineString(this._geom);\n  \t\treturn this._geom.getBoundary();\n  \t},\n  \tboundaryLineString: function boundaryLineString(line) {\n  \t\tif (this._geom.isEmpty()) {\n  \t\t\treturn this.getEmptyMultiPoint();\n  \t\t}\n  \t\tif (line.isClosed()) {\n  \t\t\tvar closedEndpointOnBoundary = this._bnRule.isInBoundary(2);\n  \t\t\tif (closedEndpointOnBoundary) {\n  \t\t\t\treturn line.getStartPoint();\n  \t\t\t} else {\n  \t\t\t\treturn this._geomFact.createMultiPoint();\n  \t\t\t}\n  \t\t}\n  \t\treturn this._geomFact.createMultiPoint([line.getStartPoint(), line.getEndPoint()]);\n  \t},\n  \tgetEmptyMultiPoint: function getEmptyMultiPoint() {\n  \t\treturn this._geomFact.createMultiPoint();\n  \t},\n  \tcomputeBoundaryCoordinates: function computeBoundaryCoordinates(mLine) {\n  \t\tvar bdyPts = new ArrayList();\n  \t\tthis._endpointMap = new TreeMap();\n  \t\tfor (var i = 0; i < mLine.getNumGeometries(); i++) {\n  \t\t\tvar line = mLine.getGeometryN(i);\n  \t\t\tif (line.getNumPoints() === 0) continue;\n  \t\t\tthis.addEndpoint(line.getCoordinateN(0));\n  \t\t\tthis.addEndpoint(line.getCoordinateN(line.getNumPoints() - 1));\n  \t\t}\n  \t\tfor (var it = this._endpointMap.entrySet().iterator(); it.hasNext();) {\n  \t\t\tvar entry = it.next();\n  \t\t\tvar counter = entry.getValue();\n  \t\t\tvar valence = counter.count;\n  \t\t\tif (this._bnRule.isInBoundary(valence)) {\n  \t\t\t\tbdyPts.add(entry.getKey());\n  \t\t\t}\n  \t\t}\n  \t\treturn CoordinateArrays.toCoordinateArray(bdyPts);\n  \t},\n  \taddEndpoint: function addEndpoint(pt) {\n  \t\tvar counter = this._endpointMap.get(pt);\n  \t\tif (counter === null) {\n  \t\t\tcounter = new Counter();\n  \t\t\tthis._endpointMap.put(pt, counter);\n  \t\t}\n  \t\tcounter.count++;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn BoundaryOp;\n  \t}\n  });\n  BoundaryOp.getBoundary = function () {\n  \tif (arguments.length === 1) {\n  \t\tvar g = arguments[0];\n  \t\tvar bop = new BoundaryOp(g);\n  \t\treturn bop.getBoundary();\n  \t} else if (arguments.length === 2) {\n  \t\tvar g = arguments[0],\n  \t\t    bnRule = arguments[1];\n  \t\tvar bop = new BoundaryOp(g, bnRule);\n  \t\treturn bop.getBoundary();\n  \t}\n  };\n  function Counter() {\n  \tthis.count = null;\n  }\n  extend(Counter.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Counter;\n  \t}\n  });\n\n  function PrintStream() {}\n\n  function StringReader() {}\n\n  function DecimalFormat() {}\n\n  function ByteArrayOutputStream() {}\n\n  function IOException() {}\n\n  function LineNumberReader() {}\n\n  function StringUtil() {}\n  extend(StringUtil.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn StringUtil;\n  \t}\n  });\n  StringUtil.chars = function (c, n) {\n  \tvar ch = new Array(n).fill(null);\n  \tfor (var i = 0; i < n; i++) {\n  \t\tch[i] = c;\n  \t}\n  \treturn new String(ch);\n  };\n  StringUtil.getStackTrace = function () {\n  \tif (arguments.length === 1) {\n  \t\tvar t = arguments[0];\n  \t\tvar os = new ByteArrayOutputStream();\n  \t\tvar ps = new PrintStream(os);\n  \t\tt.printStackTrace(ps);\n  \t\treturn os.toString();\n  \t} else if (arguments.length === 2) {\n  \t\tvar t = arguments[0],\n  \t\t    depth = arguments[1];\n  \t\tvar stackTrace = \"\";\n  \t\tvar stringReader = new StringReader(StringUtil.getStackTrace(t));\n  \t\tvar lineNumberReader = new LineNumberReader(stringReader);\n  \t\tfor (var i = 0; i < depth; i++) {\n  \t\t\ttry {\n  \t\t\t\tstackTrace += lineNumberReader.readLine() + StringUtil.NEWLINE;\n  \t\t\t} catch (e) {\n  \t\t\t\tif (e instanceof IOException) {\n  \t\t\t\t\tAssert.shouldNeverReachHere();\n  \t\t\t\t} else throw e;\n  \t\t\t} finally {}\n  \t\t}\n  \t\treturn stackTrace;\n  \t}\n  };\n  StringUtil.split = function (s, separator) {\n  \tvar separatorlen = separator.length;\n  \tvar tokenList = new ArrayList();\n  \tvar tmpString = \"\" + s;\n  \tvar pos = tmpString.indexOf(separator);\n  \twhile (pos >= 0) {\n  \t\tvar token = tmpString.substring(0, pos);\n  \t\ttokenList.add(token);\n  \t\ttmpString = tmpString.substring(pos + separatorlen);\n  \t\tpos = tmpString.indexOf(separator);\n  \t}\n  \tif (tmpString.length > 0) tokenList.add(tmpString);\n  \tvar res = new Array(tokenList.size()).fill(null);\n  \tfor (var i = 0; i < res.length; i++) {\n  \t\tres[i] = tokenList.get(i);\n  \t}\n  \treturn res;\n  };\n  StringUtil.toString = function () {\n  \tif (arguments.length === 1) {\n  \t\tvar d = arguments[0];\n  \t\treturn StringUtil.SIMPLE_ORDINATE_FORMAT.format(d);\n  \t}\n  };\n  StringUtil.spaces = function (n) {\n  \treturn StringUtil.chars(' ', n);\n  };\n  StringUtil.NEWLINE = System.getProperty(\"line.separator\");\n  StringUtil.SIMPLE_ORDINATE_FORMAT = new DecimalFormat(\"0.#\");\n\n  function CoordinateSequences() {}\n  extend(CoordinateSequences.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn CoordinateSequences;\n  \t}\n  });\n  CoordinateSequences.copyCoord = function (src, srcPos, dest, destPos) {\n  \tvar minDim = Math.min(src.getDimension(), dest.getDimension());\n  \tfor (var dim = 0; dim < minDim; dim++) {\n  \t\tdest.setOrdinate(destPos, dim, src.getOrdinate(srcPos, dim));\n  \t}\n  };\n  CoordinateSequences.isRing = function (seq) {\n  \tvar n = seq.size();\n  \tif (n === 0) return true;\n  \tif (n <= 3) return false;\n  \treturn seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);\n  };\n  CoordinateSequences.isEqual = function (cs1, cs2) {\n  \tvar cs1Size = cs1.size();\n  \tvar cs2Size = cs2.size();\n  \tif (cs1Size !== cs2Size) return false;\n  \tvar dim = Math.min(cs1.getDimension(), cs2.getDimension());\n  \tfor (var i = 0; i < cs1Size; i++) {\n  \t\tfor (var d = 0; d < dim; d++) {\n  \t\t\tvar v1 = cs1.getOrdinate(i, d);\n  \t\t\tvar v2 = cs2.getOrdinate(i, d);\n  \t\t\tif (cs1.getOrdinate(i, d) === cs2.getOrdinate(i, d)) continue;\n  \t\t\tif (Double.isNaN(v1) && Double.isNaN(v2)) continue;\n  \t\t\treturn false;\n  \t\t}\n  \t}\n  \treturn true;\n  };\n  CoordinateSequences.extend = function (fact, seq, size) {\n  \tvar newseq = fact.create(size, seq.getDimension());\n  \tvar n = seq.size();\n  \tCoordinateSequences.copy(seq, 0, newseq, 0, n);\n  \tif (n > 0) {\n  \t\tfor (var i = n; i < size; i++) {\n  \t\t\tCoordinateSequences.copy(seq, n - 1, newseq, i, 1);\n  \t\t}\n  \t}\n  \treturn newseq;\n  };\n  CoordinateSequences.reverse = function (seq) {\n  \tvar last = seq.size() - 1;\n  \tvar mid = Math.trunc(last / 2);\n  \tfor (var i = 0; i <= mid; i++) {\n  \t\tCoordinateSequences.swap(seq, i, last - i);\n  \t}\n  };\n  CoordinateSequences.swap = function (seq, i, j) {\n  \tif (i === j) return null;\n  \tfor (var dim = 0; dim < seq.getDimension(); dim++) {\n  \t\tvar tmp = seq.getOrdinate(i, dim);\n  \t\tseq.setOrdinate(i, dim, seq.getOrdinate(j, dim));\n  \t\tseq.setOrdinate(j, dim, tmp);\n  \t}\n  };\n  CoordinateSequences.copy = function (src, srcPos, dest, destPos, length) {\n  \tfor (var i = 0; i < length; i++) {\n  \t\tCoordinateSequences.copyCoord(src, srcPos + i, dest, destPos + i);\n  \t}\n  };\n  CoordinateSequences.toString = function () {\n  \tif (arguments.length === 1) {\n  \t\tvar cs = arguments[0];\n  \t\tvar size = cs.size();\n  \t\tif (size === 0) return \"()\";\n  \t\tvar dim = cs.getDimension();\n  \t\tvar buf = new StringBuffer();\n  \t\tbuf.append('(');\n  \t\tfor (var i = 0; i < size; i++) {\n  \t\t\tif (i > 0) buf.append(\" \");\n  \t\t\tfor (var d = 0; d < dim; d++) {\n  \t\t\t\tif (d > 0) buf.append(\",\");\n  \t\t\t\tbuf.append(StringUtil.toString(cs.getOrdinate(i, d)));\n  \t\t\t}\n  \t\t}\n  \t\tbuf.append(')');\n  \t\treturn buf.toString();\n  \t}\n  };\n  CoordinateSequences.ensureValidRing = function (fact, seq) {\n  \tvar n = seq.size();\n  \tif (n === 0) return seq;\n  \tif (n <= 3) return CoordinateSequences.createClosedRing(fact, seq, 4);\n  \tvar isClosed = seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);\n  \tif (isClosed) return seq;\n  \treturn CoordinateSequences.createClosedRing(fact, seq, n + 1);\n  };\n  CoordinateSequences.createClosedRing = function (fact, seq, size) {\n  \tvar newseq = fact.create(size, seq.getDimension());\n  \tvar n = seq.size();\n  \tCoordinateSequences.copy(seq, 0, newseq, 0, n);\n  \tfor (var i = n; i < size; i++) {\n  \t\tCoordinateSequences.copy(seq, 0, newseq, i, 1);\n  \t}return newseq;\n  };\n\n  function LineString() {\n  \tthis._points = null;\n  \tvar points = arguments[0],\n  \t    factory = arguments[1];\n  \tGeometry.call(this, factory);\n  \tthis.init(points);\n  }\n  inherits$1(LineString, Geometry);\n  extend(LineString.prototype, {\n  \tcomputeEnvelopeInternal: function computeEnvelopeInternal() {\n  \t\tif (this.isEmpty()) {\n  \t\t\treturn new Envelope();\n  \t\t}\n  \t\treturn this._points.expandEnvelope(new Envelope());\n  \t},\n  \tisRing: function isRing() {\n  \t\treturn this.isClosed() && this.isSimple();\n  \t},\n  \tgetSortIndex: function getSortIndex() {\n  \t\treturn Geometry.SORTINDEX_LINESTRING;\n  \t},\n  \tgetCoordinates: function getCoordinates() {\n  \t\treturn this._points.toCoordinateArray();\n  \t},\n  \tequalsExact: function equalsExact() {\n  \t\tif (arguments.length === 2) {\n  \t\t\tvar other = arguments[0],\n  \t\t\t    tolerance = arguments[1];\n  \t\t\tif (!this.isEquivalentClass(other)) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t\tvar otherLineString = other;\n  \t\t\tif (this._points.size() !== otherLineString._points.size()) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t\tfor (var i = 0; i < this._points.size(); i++) {\n  \t\t\t\tif (!this.equal(this._points.getCoordinate(i), otherLineString._points.getCoordinate(i), tolerance)) {\n  \t\t\t\t\treturn false;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\treturn true;\n  \t\t} else return Geometry.prototype.equalsExact.apply(this, arguments);\n  \t},\n  \tnormalize: function normalize() {\n  \t\tfor (var i = 0; i < Math.trunc(this._points.size() / 2); i++) {\n  \t\t\tvar j = this._points.size() - 1 - i;\n  \t\t\tif (!this._points.getCoordinate(i).equals(this._points.getCoordinate(j))) {\n  \t\t\t\tif (this._points.getCoordinate(i).compareTo(this._points.getCoordinate(j)) > 0) {\n  \t\t\t\t\tCoordinateSequences.reverse(this._points);\n  \t\t\t\t}\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\tif (this.isEmpty()) return null;\n  \t\treturn this._points.getCoordinate(0);\n  \t},\n  \tgetBoundaryDimension: function getBoundaryDimension() {\n  \t\tif (this.isClosed()) {\n  \t\t\treturn Dimension.FALSE;\n  \t\t}\n  \t\treturn 0;\n  \t},\n  \tisClosed: function isClosed() {\n  \t\tif (this.isEmpty()) {\n  \t\t\treturn false;\n  \t\t}\n  \t\treturn this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));\n  \t},\n  \tgetEndPoint: function getEndPoint() {\n  \t\tif (this.isEmpty()) {\n  \t\t\treturn null;\n  \t\t}\n  \t\treturn this.getPointN(this.getNumPoints() - 1);\n  \t},\n  \tgetDimension: function getDimension() {\n  \t\treturn 1;\n  \t},\n  \tgetLength: function getLength() {\n  \t\treturn CGAlgorithms.computeLength(this._points);\n  \t},\n  \tgetNumPoints: function getNumPoints() {\n  \t\treturn this._points.size();\n  \t},\n  \treverse: function reverse() {\n  \t\tvar seq = this._points.copy();\n  \t\tCoordinateSequences.reverse(seq);\n  \t\tvar revLine = this.getFactory().createLineString(seq);\n  \t\treturn revLine;\n  \t},\n  \tcompareToSameClass: function compareToSameClass() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar o = arguments[0];\n  \t\t\tvar line = o;\n  \t\t\tvar i = 0;\n  \t\t\tvar j = 0;\n  \t\t\twhile (i < this._points.size() && j < line._points.size()) {\n  \t\t\t\tvar comparison = this._points.getCoordinate(i).compareTo(line._points.getCoordinate(j));\n  \t\t\t\tif (comparison !== 0) {\n  \t\t\t\t\treturn comparison;\n  \t\t\t\t}\n  \t\t\t\ti++;\n  \t\t\t\tj++;\n  \t\t\t}\n  \t\t\tif (i < this._points.size()) {\n  \t\t\t\treturn 1;\n  \t\t\t}\n  \t\t\tif (j < line._points.size()) {\n  \t\t\t\treturn -1;\n  \t\t\t}\n  \t\t\treturn 0;\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar o = arguments[0],\n  \t\t\t    comp = arguments[1];\n  \t\t\tvar line = o;\n  \t\t\treturn comp.compare(this._points, line._points);\n  \t\t}\n  \t},\n  \tapply: function apply() {\n  \t\tif (hasInterface(arguments[0], CoordinateFilter)) {\n  \t\t\tvar filter = arguments[0];\n  \t\t\tfor (var i = 0; i < this._points.size(); i++) {\n  \t\t\t\tfilter.filter(this._points.getCoordinate(i));\n  \t\t\t}\n  \t\t} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n  \t\t\tvar filter = arguments[0];\n  \t\t\tif (this._points.size() === 0) return null;\n  \t\t\tfor (var i = 0; i < this._points.size(); i++) {\n  \t\t\t\tfilter.filter(this._points, i);\n  \t\t\t\tif (filter.isDone()) break;\n  \t\t\t}\n  \t\t\tif (filter.isGeometryChanged()) this.geometryChanged();\n  \t\t} else if (hasInterface(arguments[0], GeometryFilter)) {\n  \t\t\tvar filter = arguments[0];\n  \t\t\tfilter.filter(this);\n  \t\t} else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n  \t\t\tvar filter = arguments[0];\n  \t\t\tfilter.filter(this);\n  \t\t}\n  \t},\n  \tgetBoundary: function getBoundary() {\n  \t\treturn new BoundaryOp(this).getBoundary();\n  \t},\n  \tisEquivalentClass: function isEquivalentClass(other) {\n  \t\treturn other instanceof LineString;\n  \t},\n  \tclone: function clone() {\n  \t\tvar ls = Geometry.prototype.clone.call(this);\n  \t\tls._points = this._points.clone();\n  \t\treturn ls;\n  \t},\n  \tgetCoordinateN: function getCoordinateN(n) {\n  \t\treturn this._points.getCoordinate(n);\n  \t},\n  \tgetGeometryType: function getGeometryType() {\n  \t\treturn \"LineString\";\n  \t},\n  \tcopy: function copy() {\n  \t\treturn new LineString(this._points.copy(), this._factory);\n  \t},\n  \tgetCoordinateSequence: function getCoordinateSequence() {\n  \t\treturn this._points;\n  \t},\n  \tisEmpty: function isEmpty() {\n  \t\treturn this._points.size() === 0;\n  \t},\n  \tinit: function init(points) {\n  \t\tif (points === null) {\n  \t\t\tpoints = this.getFactory().getCoordinateSequenceFactory().create([]);\n  \t\t}\n  \t\tif (points.size() === 1) {\n  \t\t\tthrow new IllegalArgumentException(\"Invalid number of points in LineString (found \" + points.size() + \" - must be 0 or >= 2)\");\n  \t\t}\n  \t\tthis._points = points;\n  \t},\n  \tisCoordinate: function isCoordinate(pt) {\n  \t\tfor (var i = 0; i < this._points.size(); i++) {\n  \t\t\tif (this._points.getCoordinate(i).equals(pt)) {\n  \t\t\t\treturn true;\n  \t\t\t}\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tgetStartPoint: function getStartPoint() {\n  \t\tif (this.isEmpty()) {\n  \t\t\treturn null;\n  \t\t}\n  \t\treturn this.getPointN(0);\n  \t},\n  \tgetPointN: function getPointN(n) {\n  \t\treturn this.getFactory().createPoint(this._points.getCoordinate(n));\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Lineal];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LineString;\n  \t}\n  });\n  LineString.serialVersionUID = 3110669828065365560;\n\n  function Puntal() {}\n  extend(Puntal.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Puntal;\n  \t}\n  });\n\n  function Point() {\n  \tthis._coordinates = null;\n  \tvar coordinates = arguments[0],\n  \t    factory = arguments[1];\n  \tGeometry.call(this, factory);\n  \tthis.init(coordinates);\n  }\n  inherits$1(Point, Geometry);\n  extend(Point.prototype, {\n  \tcomputeEnvelopeInternal: function computeEnvelopeInternal() {\n  \t\tif (this.isEmpty()) {\n  \t\t\treturn new Envelope();\n  \t\t}\n  \t\tvar env = new Envelope();\n  \t\tenv.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0));\n  \t\treturn env;\n  \t},\n  \tgetSortIndex: function getSortIndex() {\n  \t\treturn Geometry.SORTINDEX_POINT;\n  \t},\n  \tgetCoordinates: function getCoordinates() {\n  \t\treturn this.isEmpty() ? [] : [this.getCoordinate()];\n  \t},\n  \tequalsExact: function equalsExact() {\n  \t\tif (arguments.length === 2) {\n  \t\t\tvar other = arguments[0],\n  \t\t\t    tolerance = arguments[1];\n  \t\t\tif (!this.isEquivalentClass(other)) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t\tif (this.isEmpty() && other.isEmpty()) {\n  \t\t\t\treturn true;\n  \t\t\t}\n  \t\t\tif (this.isEmpty() !== other.isEmpty()) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t\treturn this.equal(other.getCoordinate(), this.getCoordinate(), tolerance);\n  \t\t} else return Geometry.prototype.equalsExact.apply(this, arguments);\n  \t},\n  \tnormalize: function normalize() {},\n  \tgetCoordinate: function getCoordinate() {\n  \t\treturn this._coordinates.size() !== 0 ? this._coordinates.getCoordinate(0) : null;\n  \t},\n  \tgetBoundaryDimension: function getBoundaryDimension() {\n  \t\treturn Dimension.FALSE;\n  \t},\n  \tgetDimension: function getDimension() {\n  \t\treturn 0;\n  \t},\n  \tgetNumPoints: function getNumPoints() {\n  \t\treturn this.isEmpty() ? 0 : 1;\n  \t},\n  \treverse: function reverse() {\n  \t\treturn this.copy();\n  \t},\n  \tgetX: function getX() {\n  \t\tif (this.getCoordinate() === null) {\n  \t\t\tthrow new IllegalStateException(\"getX called on empty Point\");\n  \t\t}\n  \t\treturn this.getCoordinate().x;\n  \t},\n  \tcompareToSameClass: function compareToSameClass() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar other = arguments[0];\n  \t\t\tvar point = other;\n  \t\t\treturn this.getCoordinate().compareTo(point.getCoordinate());\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar other = arguments[0],\n  \t\t\t    comp = arguments[1];\n  \t\t\tvar point = other;\n  \t\t\treturn comp.compare(this._coordinates, point._coordinates);\n  \t\t}\n  \t},\n  \tapply: function apply() {\n  \t\tif (hasInterface(arguments[0], CoordinateFilter)) {\n  \t\t\tvar filter = arguments[0];\n  \t\t\tif (this.isEmpty()) {\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t\tfilter.filter(this.getCoordinate());\n  \t\t} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n  \t\t\tvar filter = arguments[0];\n  \t\t\tif (this.isEmpty()) return null;\n  \t\t\tfilter.filter(this._coordinates, 0);\n  \t\t\tif (filter.isGeometryChanged()) this.geometryChanged();\n  \t\t} else if (hasInterface(arguments[0], GeometryFilter)) {\n  \t\t\tvar filter = arguments[0];\n  \t\t\tfilter.filter(this);\n  \t\t} else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n  \t\t\tvar filter = arguments[0];\n  \t\t\tfilter.filter(this);\n  \t\t}\n  \t},\n  \tgetBoundary: function getBoundary() {\n  \t\treturn this.getFactory().createGeometryCollection(null);\n  \t},\n  \tclone: function clone() {\n  \t\tvar p = Geometry.prototype.clone.call(this);\n  \t\tp._coordinates = this._coordinates.clone();\n  \t\treturn p;\n  \t},\n  \tgetGeometryType: function getGeometryType() {\n  \t\treturn \"Point\";\n  \t},\n  \tcopy: function copy() {\n  \t\treturn new Point(this._coordinates.copy(), this._factory);\n  \t},\n  \tgetCoordinateSequence: function getCoordinateSequence() {\n  \t\treturn this._coordinates;\n  \t},\n  \tgetY: function getY() {\n  \t\tif (this.getCoordinate() === null) {\n  \t\t\tthrow new IllegalStateException(\"getY called on empty Point\");\n  \t\t}\n  \t\treturn this.getCoordinate().y;\n  \t},\n  \tisEmpty: function isEmpty() {\n  \t\treturn this._coordinates.size() === 0;\n  \t},\n  \tinit: function init(coordinates) {\n  \t\tif (coordinates === null) {\n  \t\t\tcoordinates = this.getFactory().getCoordinateSequenceFactory().create([]);\n  \t\t}\n  \t\tAssert.isTrue(coordinates.size() <= 1);\n  \t\tthis._coordinates = coordinates;\n  \t},\n  \tisSimple: function isSimple() {\n  \t\treturn true;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Puntal];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Point;\n  \t}\n  });\n  Point.serialVersionUID = 4902022702746614570;\n\n  function Polygonal() {}\n  extend(Polygonal.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Polygonal;\n  \t}\n  });\n\n  function Polygon() {\n  \tthis._shell = null;\n  \tthis._holes = null;\n  \tvar shell = arguments[0],\n  \t    holes = arguments[1],\n  \t    factory = arguments[2];\n  \tGeometry.call(this, factory);\n  \tif (shell === null) {\n  \t\tshell = this.getFactory().createLinearRing();\n  \t}\n  \tif (holes === null) {\n  \t\tholes = [];\n  \t}\n  \tif (Geometry.hasNullElements(holes)) {\n  \t\tthrow new IllegalArgumentException(\"holes must not contain null elements\");\n  \t}\n  \tif (shell.isEmpty() && Geometry.hasNonEmptyElements(holes)) {\n  \t\tthrow new IllegalArgumentException(\"shell is empty but holes are not\");\n  \t}\n  \tthis._shell = shell;\n  \tthis._holes = holes;\n  }\n  inherits$1(Polygon, Geometry);\n  extend(Polygon.prototype, {\n  \tcomputeEnvelopeInternal: function computeEnvelopeInternal() {\n  \t\treturn this._shell.getEnvelopeInternal();\n  \t},\n  \tgetSortIndex: function getSortIndex() {\n  \t\treturn Geometry.SORTINDEX_POLYGON;\n  \t},\n  \tgetCoordinates: function getCoordinates() {\n  \t\tif (this.isEmpty()) {\n  \t\t\treturn [];\n  \t\t}\n  \t\tvar coordinates = new Array(this.getNumPoints()).fill(null);\n  \t\tvar k = -1;\n  \t\tvar shellCoordinates = this._shell.getCoordinates();\n  \t\tfor (var x = 0; x < shellCoordinates.length; x++) {\n  \t\t\tk++;\n  \t\t\tcoordinates[k] = shellCoordinates[x];\n  \t\t}\n  \t\tfor (var i = 0; i < this._holes.length; i++) {\n  \t\t\tvar childCoordinates = this._holes[i].getCoordinates();\n  \t\t\tfor (var j = 0; j < childCoordinates.length; j++) {\n  \t\t\t\tk++;\n  \t\t\t\tcoordinates[k] = childCoordinates[j];\n  \t\t\t}\n  \t\t}\n  \t\treturn coordinates;\n  \t},\n  \tgetArea: function getArea() {\n  \t\tvar area = 0.0;\n  \t\tarea += Math.abs(CGAlgorithms.signedArea(this._shell.getCoordinateSequence()));\n  \t\tfor (var i = 0; i < this._holes.length; i++) {\n  \t\t\tarea -= Math.abs(CGAlgorithms.signedArea(this._holes[i].getCoordinateSequence()));\n  \t\t}\n  \t\treturn area;\n  \t},\n  \tisRectangle: function isRectangle() {\n  \t\tif (this.getNumInteriorRing() !== 0) return false;\n  \t\tif (this._shell === null) return false;\n  \t\tif (this._shell.getNumPoints() !== 5) return false;\n  \t\tvar seq = this._shell.getCoordinateSequence();\n  \t\tvar env = this.getEnvelopeInternal();\n  \t\tfor (var i = 0; i < 5; i++) {\n  \t\t\tvar x = seq.getX(i);\n  \t\t\tif (!(x === env.getMinX() || x === env.getMaxX())) return false;\n  \t\t\tvar y = seq.getY(i);\n  \t\t\tif (!(y === env.getMinY() || y === env.getMaxY())) return false;\n  \t\t}\n  \t\tvar prevX = seq.getX(0);\n  \t\tvar prevY = seq.getY(0);\n  \t\tfor (var i = 1; i <= 4; i++) {\n  \t\t\tvar x = seq.getX(i);\n  \t\t\tvar y = seq.getY(i);\n  \t\t\tvar xChanged = x !== prevX;\n  \t\t\tvar yChanged = y !== prevY;\n  \t\t\tif (xChanged === yChanged) return false;\n  \t\t\tprevX = x;\n  \t\t\tprevY = y;\n  \t\t}\n  \t\treturn true;\n  \t},\n  \tequalsExact: function equalsExact() {\n  \t\tif (arguments.length === 2) {\n  \t\t\tvar other = arguments[0],\n  \t\t\t    tolerance = arguments[1];\n  \t\t\tif (!this.isEquivalentClass(other)) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t\tvar otherPolygon = other;\n  \t\t\tvar thisShell = this._shell;\n  \t\t\tvar otherPolygonShell = otherPolygon._shell;\n  \t\t\tif (!thisShell.equalsExact(otherPolygonShell, tolerance)) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t\tif (this._holes.length !== otherPolygon._holes.length) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t\tfor (var i = 0; i < this._holes.length; i++) {\n  \t\t\t\tif (!this._holes[i].equalsExact(otherPolygon._holes[i], tolerance)) {\n  \t\t\t\t\treturn false;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\treturn true;\n  \t\t} else return Geometry.prototype.equalsExact.apply(this, arguments);\n  \t},\n  \tnormalize: function normalize() {\n  \t\tif (arguments.length === 0) {\n  \t\t\tthis.normalize(this._shell, true);\n  \t\t\tfor (var i = 0; i < this._holes.length; i++) {\n  \t\t\t\tthis.normalize(this._holes[i], false);\n  \t\t\t}\n  \t\t\tArrays.sort(this._holes);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar ring = arguments[0],\n  \t\t\t    clockwise = arguments[1];\n  \t\t\tif (ring.isEmpty()) {\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t\tvar uniqueCoordinates = new Array(ring.getCoordinates().length - 1).fill(null);\n  \t\t\tSystem.arraycopy(ring.getCoordinates(), 0, uniqueCoordinates, 0, uniqueCoordinates.length);\n  \t\t\tvar minCoordinate = CoordinateArrays.minCoordinate(ring.getCoordinates());\n  \t\t\tCoordinateArrays.scroll(uniqueCoordinates, minCoordinate);\n  \t\t\tSystem.arraycopy(uniqueCoordinates, 0, ring.getCoordinates(), 0, uniqueCoordinates.length);\n  \t\t\tring.getCoordinates()[uniqueCoordinates.length] = uniqueCoordinates[0];\n  \t\t\tif (CGAlgorithms.isCCW(ring.getCoordinates()) === clockwise) {\n  \t\t\t\tCoordinateArrays.reverse(ring.getCoordinates());\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\treturn this._shell.getCoordinate();\n  \t},\n  \tgetNumInteriorRing: function getNumInteriorRing() {\n  \t\treturn this._holes.length;\n  \t},\n  \tgetBoundaryDimension: function getBoundaryDimension() {\n  \t\treturn 1;\n  \t},\n  \tgetDimension: function getDimension() {\n  \t\treturn 2;\n  \t},\n  \tgetLength: function getLength() {\n  \t\tvar len = 0.0;\n  \t\tlen += this._shell.getLength();\n  \t\tfor (var i = 0; i < this._holes.length; i++) {\n  \t\t\tlen += this._holes[i].getLength();\n  \t\t}\n  \t\treturn len;\n  \t},\n  \tgetNumPoints: function getNumPoints() {\n  \t\tvar numPoints = this._shell.getNumPoints();\n  \t\tfor (var i = 0; i < this._holes.length; i++) {\n  \t\t\tnumPoints += this._holes[i].getNumPoints();\n  \t\t}\n  \t\treturn numPoints;\n  \t},\n  \treverse: function reverse() {\n  \t\tvar poly = this.copy();\n  \t\tpoly._shell = this._shell.copy().reverse();\n  \t\tpoly._holes = new Array(this._holes.length).fill(null);\n  \t\tfor (var i = 0; i < this._holes.length; i++) {\n  \t\t\tpoly._holes[i] = this._holes[i].copy().reverse();\n  \t\t}\n  \t\treturn poly;\n  \t},\n  \tconvexHull: function convexHull() {\n  \t\treturn this.getExteriorRing().convexHull();\n  \t},\n  \tcompareToSameClass: function compareToSameClass() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar o = arguments[0];\n  \t\t\tvar thisShell = this._shell;\n  \t\t\tvar otherShell = o._shell;\n  \t\t\treturn thisShell.compareToSameClass(otherShell);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar o = arguments[0],\n  \t\t\t    comp = arguments[1];\n  \t\t\tvar poly = o;\n  \t\t\tvar thisShell = this._shell;\n  \t\t\tvar otherShell = poly._shell;\n  \t\t\tvar shellComp = thisShell.compareToSameClass(otherShell, comp);\n  \t\t\tif (shellComp !== 0) return shellComp;\n  \t\t\tvar nHole1 = this.getNumInteriorRing();\n  \t\t\tvar nHole2 = poly.getNumInteriorRing();\n  \t\t\tvar i = 0;\n  \t\t\twhile (i < nHole1 && i < nHole2) {\n  \t\t\t\tvar thisHole = this.getInteriorRingN(i);\n  \t\t\t\tvar otherHole = poly.getInteriorRingN(i);\n  \t\t\t\tvar holeComp = thisHole.compareToSameClass(otherHole, comp);\n  \t\t\t\tif (holeComp !== 0) return holeComp;\n  \t\t\t\ti++;\n  \t\t\t}\n  \t\t\tif (i < nHole1) return 1;\n  \t\t\tif (i < nHole2) return -1;\n  \t\t\treturn 0;\n  \t\t}\n  \t},\n  \tapply: function apply() {\n  \t\tif (hasInterface(arguments[0], CoordinateFilter)) {\n  \t\t\tvar filter = arguments[0];\n  \t\t\tthis._shell.apply(filter);\n  \t\t\tfor (var i = 0; i < this._holes.length; i++) {\n  \t\t\t\tthis._holes[i].apply(filter);\n  \t\t\t}\n  \t\t} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n  \t\t\tvar filter = arguments[0];\n  \t\t\tthis._shell.apply(filter);\n  \t\t\tif (!filter.isDone()) {\n  \t\t\t\tfor (var i = 0; i < this._holes.length; i++) {\n  \t\t\t\t\tthis._holes[i].apply(filter);\n  \t\t\t\t\tif (filter.isDone()) break;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\tif (filter.isGeometryChanged()) this.geometryChanged();\n  \t\t} else if (hasInterface(arguments[0], GeometryFilter)) {\n  \t\t\tvar filter = arguments[0];\n  \t\t\tfilter.filter(this);\n  \t\t} else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n  \t\t\tvar filter = arguments[0];\n  \t\t\tfilter.filter(this);\n  \t\t\tthis._shell.apply(filter);\n  \t\t\tfor (var i = 0; i < this._holes.length; i++) {\n  \t\t\t\tthis._holes[i].apply(filter);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetBoundary: function getBoundary() {\n  \t\tif (this.isEmpty()) {\n  \t\t\treturn this.getFactory().createMultiLineString();\n  \t\t}\n  \t\tvar rings = new Array(this._holes.length + 1).fill(null);\n  \t\trings[0] = this._shell;\n  \t\tfor (var i = 0; i < this._holes.length; i++) {\n  \t\t\trings[i + 1] = this._holes[i];\n  \t\t}\n  \t\tif (rings.length <= 1) return this.getFactory().createLinearRing(rings[0].getCoordinateSequence());\n  \t\treturn this.getFactory().createMultiLineString(rings);\n  \t},\n  \tclone: function clone() {\n  \t\tvar poly = Geometry.prototype.clone.call(this);\n  \t\tpoly._shell = this._shell.clone();\n  \t\tpoly._holes = new Array(this._holes.length).fill(null);\n  \t\tfor (var i = 0; i < this._holes.length; i++) {\n  \t\t\tpoly._holes[i] = this._holes[i].clone();\n  \t\t}\n  \t\treturn poly;\n  \t},\n  \tgetGeometryType: function getGeometryType() {\n  \t\treturn \"Polygon\";\n  \t},\n  \tcopy: function copy() {\n  \t\tvar shell = this._shell.copy();\n  \t\tvar holes = new Array(this._holes.length).fill(null);\n  \t\tfor (var i = 0; i < holes.length; i++) {\n  \t\t\tholes[i] = this._holes[i].copy();\n  \t\t}\n  \t\treturn new Polygon(shell, holes, this._factory);\n  \t},\n  \tgetExteriorRing: function getExteriorRing() {\n  \t\treturn this._shell;\n  \t},\n  \tisEmpty: function isEmpty() {\n  \t\treturn this._shell.isEmpty();\n  \t},\n  \tgetInteriorRingN: function getInteriorRingN(n) {\n  \t\treturn this._holes[n];\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Polygonal];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Polygon;\n  \t}\n  });\n  Polygon.serialVersionUID = -3494792200821764533;\n\n  function MultiPoint() {\n  \tvar points = arguments[0],\n  \t    factory = arguments[1];\n  \tGeometryCollection.call(this, points, factory);\n  }\n  inherits$1(MultiPoint, GeometryCollection);\n  extend(MultiPoint.prototype, {\n  \tgetSortIndex: function getSortIndex() {\n  \t\treturn Geometry.SORTINDEX_MULTIPOINT;\n  \t},\n  \tisValid: function isValid() {\n  \t\treturn true;\n  \t},\n  \tequalsExact: function equalsExact() {\n  \t\tif (arguments.length === 2) {\n  \t\t\tvar other = arguments[0],\n  \t\t\t    tolerance = arguments[1];\n  \t\t\tif (!this.isEquivalentClass(other)) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t\treturn GeometryCollection.prototype.equalsExact.call(this, other, tolerance);\n  \t\t} else return GeometryCollection.prototype.equalsExact.apply(this, arguments);\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar n = arguments[0];\n  \t\t\treturn this._geometries[n].getCoordinate();\n  \t\t} else return GeometryCollection.prototype.getCoordinate.apply(this, arguments);\n  \t},\n  \tgetBoundaryDimension: function getBoundaryDimension() {\n  \t\treturn Dimension.FALSE;\n  \t},\n  \tgetDimension: function getDimension() {\n  \t\treturn 0;\n  \t},\n  \tgetBoundary: function getBoundary() {\n  \t\treturn this.getFactory().createGeometryCollection(null);\n  \t},\n  \tgetGeometryType: function getGeometryType() {\n  \t\treturn \"MultiPoint\";\n  \t},\n  \tcopy: function copy() {\n  \t\tvar points = new Array(this._geometries.length).fill(null);\n  \t\tfor (var i = 0; i < points.length; i++) {\n  \t\t\tpoints[i] = this._geometries[i].copy();\n  \t\t}\n  \t\treturn new MultiPoint(points, this._factory);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Puntal];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MultiPoint;\n  \t}\n  });\n  MultiPoint.serialVersionUID = -8048474874175355449;\n\n  function LinearRing() {\n  \tif (arguments[0] instanceof Coordinate && arguments[1] instanceof GeometryFactory) {\n  \t\tvar points = arguments[0],\n  \t\t    factory = arguments[1];\n  \t\tLinearRing.call(this, factory.getCoordinateSequenceFactory().create(points), factory);\n  \t} else if (hasInterface(arguments[0], CoordinateSequence) && arguments[1] instanceof GeometryFactory) {\n  \t\tvar points = arguments[0],\n  \t\t    factory = arguments[1];\n  \t\tLineString.call(this, points, factory);\n  \t\tthis.validateConstruction();\n  \t}\n  }\n  inherits$1(LinearRing, LineString);\n  extend(LinearRing.prototype, {\n  \tgetSortIndex: function getSortIndex() {\n  \t\treturn Geometry.SORTINDEX_LINEARRING;\n  \t},\n  \tgetBoundaryDimension: function getBoundaryDimension() {\n  \t\treturn Dimension.FALSE;\n  \t},\n  \tisClosed: function isClosed() {\n  \t\tif (this.isEmpty()) {\n  \t\t\treturn true;\n  \t\t}\n  \t\treturn LineString.prototype.isClosed.call(this);\n  \t},\n  \treverse: function reverse() {\n  \t\tvar seq = this._points.copy();\n  \t\tCoordinateSequences.reverse(seq);\n  \t\tvar rev = this.getFactory().createLinearRing(seq);\n  \t\treturn rev;\n  \t},\n  \tvalidateConstruction: function validateConstruction() {\n  \t\tif (!this.isEmpty() && !LineString.prototype.isClosed.call(this)) {\n  \t\t\tthrow new IllegalArgumentException(\"Points of LinearRing do not form a closed linestring\");\n  \t\t}\n  \t\tif (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < LinearRing.MINIMUM_VALID_SIZE) {\n  \t\t\tthrow new IllegalArgumentException(\"Invalid number of points in LinearRing (found \" + this.getCoordinateSequence().size() + \" - must be 0 or >= 4)\");\n  \t\t}\n  \t},\n  \tgetGeometryType: function getGeometryType() {\n  \t\treturn \"LinearRing\";\n  \t},\n  \tcopy: function copy() {\n  \t\treturn new LinearRing(this._points.copy(), this._factory);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LinearRing;\n  \t}\n  });\n  LinearRing.MINIMUM_VALID_SIZE = 4;\n  LinearRing.serialVersionUID = -4261142084085851829;\n\n  function MultiPolygon() {\n  \tvar polygons = arguments[0],\n  \t    factory = arguments[1];\n  \tGeometryCollection.call(this, polygons, factory);\n  }\n  inherits$1(MultiPolygon, GeometryCollection);\n  extend(MultiPolygon.prototype, {\n  \tgetSortIndex: function getSortIndex() {\n  \t\treturn Geometry.SORTINDEX_MULTIPOLYGON;\n  \t},\n  \tequalsExact: function equalsExact() {\n  \t\tif (arguments.length === 2) {\n  \t\t\tvar other = arguments[0],\n  \t\t\t    tolerance = arguments[1];\n  \t\t\tif (!this.isEquivalentClass(other)) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t\treturn GeometryCollection.prototype.equalsExact.call(this, other, tolerance);\n  \t\t} else return GeometryCollection.prototype.equalsExact.apply(this, arguments);\n  \t},\n  \tgetBoundaryDimension: function getBoundaryDimension() {\n  \t\treturn 1;\n  \t},\n  \tgetDimension: function getDimension() {\n  \t\treturn 2;\n  \t},\n  \treverse: function reverse() {\n  \t\tvar n = this._geometries.length;\n  \t\tvar revGeoms = new Array(n).fill(null);\n  \t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\trevGeoms[i] = this._geometries[i].reverse();\n  \t\t}\n  \t\treturn this.getFactory().createMultiPolygon(revGeoms);\n  \t},\n  \tgetBoundary: function getBoundary() {\n  \t\tif (this.isEmpty()) {\n  \t\t\treturn this.getFactory().createMultiLineString();\n  \t\t}\n  \t\tvar allRings = new ArrayList();\n  \t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\tvar polygon = this._geometries[i];\n  \t\t\tvar rings = polygon.getBoundary();\n  \t\t\tfor (var j = 0; j < rings.getNumGeometries(); j++) {\n  \t\t\t\tallRings.add(rings.getGeometryN(j));\n  \t\t\t}\n  \t\t}\n  \t\tvar allRingsArray = new Array(allRings.size()).fill(null);\n  \t\treturn this.getFactory().createMultiLineString(allRings.toArray(allRingsArray));\n  \t},\n  \tgetGeometryType: function getGeometryType() {\n  \t\treturn \"MultiPolygon\";\n  \t},\n  \tcopy: function copy() {\n  \t\tvar polygons = new Array(this._geometries.length).fill(null);\n  \t\tfor (var i = 0; i < polygons.length; i++) {\n  \t\t\tpolygons[i] = this._geometries[i].copy();\n  \t\t}\n  \t\treturn new MultiPolygon(polygons, this._factory);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Polygonal];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MultiPolygon;\n  \t}\n  });\n  MultiPolygon.serialVersionUID = -551033529766975875;\n\n  function GeometryEditor() {\n  \tthis._factory = null;\n  \tthis._isUserDataCopied = false;\n  \tif (arguments.length === 0) ; else if (arguments.length === 1) {\n  \t\tvar factory = arguments[0];\n  \t\tthis._factory = factory;\n  \t}\n  }\n  extend(GeometryEditor.prototype, {\n  \tsetCopyUserData: function setCopyUserData(isUserDataCopied) {\n  \t\tthis._isUserDataCopied = isUserDataCopied;\n  \t},\n  \tedit: function edit(geometry, operation) {\n  \t\tif (geometry === null) return null;\n  \t\tvar result = this.editInternal(geometry, operation);\n  \t\tif (this._isUserDataCopied) {\n  \t\t\tresult.setUserData(geometry.getUserData());\n  \t\t}\n  \t\treturn result;\n  \t},\n  \teditInternal: function editInternal(geometry, operation) {\n  \t\tif (this._factory === null) this._factory = geometry.getFactory();\n  \t\tif (geometry instanceof GeometryCollection) {\n  \t\t\treturn this.editGeometryCollection(geometry, operation);\n  \t\t}\n  \t\tif (geometry instanceof Polygon) {\n  \t\t\treturn this.editPolygon(geometry, operation);\n  \t\t}\n  \t\tif (geometry instanceof Point) {\n  \t\t\treturn operation.edit(geometry, this._factory);\n  \t\t}\n  \t\tif (geometry instanceof LineString) {\n  \t\t\treturn operation.edit(geometry, this._factory);\n  \t\t}\n  \t\tAssert.shouldNeverReachHere(\"Unsupported Geometry class: \" + geometry.getClass().getName());\n  \t\treturn null;\n  \t},\n  \teditGeometryCollection: function editGeometryCollection(collection, operation) {\n  \t\tvar collectionForType = operation.edit(collection, this._factory);\n  \t\tvar geometries = new ArrayList();\n  \t\tfor (var i = 0; i < collectionForType.getNumGeometries(); i++) {\n  \t\t\tvar geometry = this.edit(collectionForType.getGeometryN(i), operation);\n  \t\t\tif (geometry === null || geometry.isEmpty()) {\n  \t\t\t\tcontinue;\n  \t\t\t}\n  \t\t\tgeometries.add(geometry);\n  \t\t}\n  \t\tif (collectionForType.getClass() === MultiPoint) {\n  \t\t\treturn this._factory.createMultiPoint(geometries.toArray([]));\n  \t\t}\n  \t\tif (collectionForType.getClass() === MultiLineString) {\n  \t\t\treturn this._factory.createMultiLineString(geometries.toArray([]));\n  \t\t}\n  \t\tif (collectionForType.getClass() === MultiPolygon) {\n  \t\t\treturn this._factory.createMultiPolygon(geometries.toArray([]));\n  \t\t}\n  \t\treturn this._factory.createGeometryCollection(geometries.toArray([]));\n  \t},\n  \teditPolygon: function editPolygon(polygon, operation) {\n  \t\tvar newPolygon = operation.edit(polygon, this._factory);\n  \t\tif (newPolygon === null) newPolygon = this._factory.createPolygon(null);\n  \t\tif (newPolygon.isEmpty()) {\n  \t\t\treturn newPolygon;\n  \t\t}\n  \t\tvar shell = this.edit(newPolygon.getExteriorRing(), operation);\n  \t\tif (shell === null || shell.isEmpty()) {\n  \t\t\treturn this._factory.createPolygon();\n  \t\t}\n  \t\tvar holes = new ArrayList();\n  \t\tfor (var i = 0; i < newPolygon.getNumInteriorRing(); i++) {\n  \t\t\tvar hole = this.edit(newPolygon.getInteriorRingN(i), operation);\n  \t\t\tif (hole === null || hole.isEmpty()) {\n  \t\t\t\tcontinue;\n  \t\t\t}\n  \t\t\tholes.add(hole);\n  \t\t}\n  \t\treturn this._factory.createPolygon(shell, holes.toArray([]));\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn GeometryEditor;\n  \t}\n  });\n  function GeometryEditorOperation() {}\n  GeometryEditor.GeometryEditorOperation = GeometryEditorOperation;\n  function NoOpGeometryOperation() {}\n  extend(NoOpGeometryOperation.prototype, {\n  \tedit: function edit(geometry, factory) {\n  \t\treturn geometry;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [GeometryEditorOperation];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn NoOpGeometryOperation;\n  \t}\n  });\n  function CoordinateOperation() {}\n  extend(CoordinateOperation.prototype, {\n  \tedit: function edit(geometry, factory) {\n  \t\tvar coords = this.editCoordinates(geometry.getCoordinates(), geometry);\n  \t\tif (coords === null) return geometry;\n  \t\tif (geometry instanceof LinearRing) {\n  \t\t\treturn factory.createLinearRing(coords);\n  \t\t}\n  \t\tif (geometry instanceof LineString) {\n  \t\t\treturn factory.createLineString(coords);\n  \t\t}\n  \t\tif (geometry instanceof Point) {\n  \t\t\tif (coords.length > 0) {\n  \t\t\t\treturn factory.createPoint(coords[0]);\n  \t\t\t} else {\n  \t\t\t\treturn factory.createPoint();\n  \t\t\t}\n  \t\t}\n  \t\treturn geometry;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [GeometryEditorOperation];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn CoordinateOperation;\n  \t}\n  });\n  function CoordinateSequenceOperation() {}\n  extend(CoordinateSequenceOperation.prototype, {\n  \tedit: function edit(geometry, factory) {\n  \t\tif (geometry instanceof LinearRing) {\n  \t\t\treturn factory.createLinearRing(this.edit(geometry.getCoordinateSequence(), geometry));\n  \t\t}\n  \t\tif (geometry instanceof LineString) {\n  \t\t\treturn factory.createLineString(this.edit(geometry.getCoordinateSequence(), geometry));\n  \t\t}\n  \t\tif (geometry instanceof Point) {\n  \t\t\treturn factory.createPoint(this.edit(geometry.getCoordinateSequence(), geometry));\n  \t\t}\n  \t\treturn geometry;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [GeometryEditorOperation];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn CoordinateSequenceOperation;\n  \t}\n  });\n  GeometryEditor.NoOpGeometryOperation = NoOpGeometryOperation;\n  GeometryEditor.CoordinateOperation = CoordinateOperation;\n  GeometryEditor.CoordinateSequenceOperation = CoordinateSequenceOperation;\n\n  function CoordinateArraySequence() {\n  \tthis._dimension = 3;\n  \tthis._coordinates = null;\n  \tif (arguments.length === 1) {\n  \t\tif (arguments[0] instanceof Array) {\n  \t\t\tvar coordinates = arguments[0];\n  \t\t\tCoordinateArraySequence.call(this, coordinates, 3);\n  \t\t} else if (Number.isInteger(arguments[0])) {\n  \t\t\tvar size = arguments[0];\n  \t\t\tthis._coordinates = new Array(size).fill(null);\n  \t\t\tfor (var i = 0; i < size; i++) {\n  \t\t\t\tthis._coordinates[i] = new Coordinate();\n  \t\t\t}\n  \t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n  \t\t\tvar coordSeq = arguments[0];\n  \t\t\tif (coordSeq === null) {\n  \t\t\t\tthis._coordinates = new Array(0).fill(null);\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t\tthis._dimension = coordSeq.getDimension();\n  \t\t\tthis._coordinates = new Array(coordSeq.size()).fill(null);\n  \t\t\tfor (var i = 0; i < this._coordinates.length; i++) {\n  \t\t\t\tthis._coordinates[i] = coordSeq.getCoordinateCopy(i);\n  \t\t\t}\n  \t\t}\n  \t} else if (arguments.length === 2) {\n  \t\tif (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {\n  \t\t\tvar coordinates = arguments[0],\n  \t\t\t    dimension = arguments[1];\n  \t\t\tthis._coordinates = coordinates;\n  \t\t\tthis._dimension = dimension;\n  \t\t\tif (coordinates === null) this._coordinates = new Array(0).fill(null);\n  \t\t} else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {\n  \t\t\tvar size = arguments[0],\n  \t\t\t    dimension = arguments[1];\n  \t\t\tthis._coordinates = new Array(size).fill(null);\n  \t\t\tthis._dimension = dimension;\n  \t\t\tfor (var i = 0; i < size; i++) {\n  \t\t\t\tthis._coordinates[i] = new Coordinate();\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n  extend(CoordinateArraySequence.prototype, {\n  \tsetOrdinate: function setOrdinate(index, ordinateIndex, value) {\n  \t\tswitch (ordinateIndex) {\n  \t\t\tcase CoordinateSequence.X:\n  \t\t\t\tthis._coordinates[index].x = value;\n  \t\t\t\tbreak;\n  \t\t\tcase CoordinateSequence.Y:\n  \t\t\t\tthis._coordinates[index].y = value;\n  \t\t\t\tbreak;\n  \t\t\tcase CoordinateSequence.Z:\n  \t\t\t\tthis._coordinates[index].z = value;\n  \t\t\t\tbreak;\n  \t\t\tdefault:\n  \t\t\t\tthrow new IllegalArgumentException(\"invalid ordinateIndex\");\n  \t\t}\n  \t},\n  \tsize: function size() {\n  \t\treturn this._coordinates.length;\n  \t},\n  \tgetOrdinate: function getOrdinate(index, ordinateIndex) {\n  \t\tswitch (ordinateIndex) {\n  \t\t\tcase CoordinateSequence.X:\n  \t\t\t\treturn this._coordinates[index].x;\n  \t\t\tcase CoordinateSequence.Y:\n  \t\t\t\treturn this._coordinates[index].y;\n  \t\t\tcase CoordinateSequence.Z:\n  \t\t\t\treturn this._coordinates[index].z;\n  \t\t}\n  \t\treturn Double.NaN;\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar i = arguments[0];\n  \t\t\treturn this._coordinates[i];\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar index = arguments[0],\n  \t\t\t    coord = arguments[1];\n  \t\t\tcoord.x = this._coordinates[index].x;\n  \t\t\tcoord.y = this._coordinates[index].y;\n  \t\t\tcoord.z = this._coordinates[index].z;\n  \t\t}\n  \t},\n  \tgetCoordinateCopy: function getCoordinateCopy(i) {\n  \t\treturn new Coordinate(this._coordinates[i]);\n  \t},\n  \tgetDimension: function getDimension() {\n  \t\treturn this._dimension;\n  \t},\n  \tgetX: function getX(index) {\n  \t\treturn this._coordinates[index].x;\n  \t},\n  \tclone: function clone() {\n  \t\tvar cloneCoordinates = new Array(this.size()).fill(null);\n  \t\tfor (var i = 0; i < this._coordinates.length; i++) {\n  \t\t\tcloneCoordinates[i] = this._coordinates[i].clone();\n  \t\t}\n  \t\treturn new CoordinateArraySequence(cloneCoordinates, this._dimension);\n  \t},\n  \texpandEnvelope: function expandEnvelope(env) {\n  \t\tfor (var i = 0; i < this._coordinates.length; i++) {\n  \t\t\tenv.expandToInclude(this._coordinates[i]);\n  \t\t}\n  \t\treturn env;\n  \t},\n  \tcopy: function copy() {\n  \t\tvar cloneCoordinates = new Array(this.size()).fill(null);\n  \t\tfor (var i = 0; i < this._coordinates.length; i++) {\n  \t\t\tcloneCoordinates[i] = this._coordinates[i].copy();\n  \t\t}\n  \t\treturn new CoordinateArraySequence(cloneCoordinates, this._dimension);\n  \t},\n  \ttoString: function toString() {\n  \t\tif (this._coordinates.length > 0) {\n  \t\t\tvar strBuf = new StringBuffer(17 * this._coordinates.length);\n  \t\t\tstrBuf.append('(');\n  \t\t\tstrBuf.append(this._coordinates[0]);\n  \t\t\tfor (var i = 1; i < this._coordinates.length; i++) {\n  \t\t\t\tstrBuf.append(\", \");\n  \t\t\t\tstrBuf.append(this._coordinates[i]);\n  \t\t\t}\n  \t\t\tstrBuf.append(')');\n  \t\t\treturn strBuf.toString();\n  \t\t} else {\n  \t\t\treturn \"()\";\n  \t\t}\n  \t},\n  \tgetY: function getY(index) {\n  \t\treturn this._coordinates[index].y;\n  \t},\n  \ttoCoordinateArray: function toCoordinateArray() {\n  \t\treturn this._coordinates;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [CoordinateSequence, Serializable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn CoordinateArraySequence;\n  \t}\n  });\n  CoordinateArraySequence.serialVersionUID = -915438501601840650;\n\n  function CoordinateArraySequenceFactory() {}\n  extend(CoordinateArraySequenceFactory.prototype, {\n  \treadResolve: function readResolve() {\n  \t\treturn CoordinateArraySequenceFactory.instance();\n  \t},\n  \tcreate: function create() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tif (arguments[0] instanceof Array) {\n  \t\t\t\tvar coordinates = arguments[0];\n  \t\t\t\treturn new CoordinateArraySequence(coordinates);\n  \t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n  \t\t\t\tvar coordSeq = arguments[0];\n  \t\t\t\treturn new CoordinateArraySequence(coordSeq);\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar size = arguments[0],\n  \t\t\t    dimension = arguments[1];\n  \t\t\tif (dimension > 3) dimension = 3;\n  \t\t\tif (dimension < 2) return new CoordinateArraySequence(size);\n  \t\t\treturn new CoordinateArraySequence(size, dimension);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [CoordinateSequenceFactory, Serializable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn CoordinateArraySequenceFactory;\n  \t}\n  });\n  CoordinateArraySequenceFactory.instance = function () {\n  \treturn CoordinateArraySequenceFactory.instanceObject;\n  };\n  CoordinateArraySequenceFactory.serialVersionUID = -4099577099607551657;\n  CoordinateArraySequenceFactory.instanceObject = new CoordinateArraySequenceFactory();\n\n  var i;\n  var defineProperty$1 = Object.defineProperty;\n  function is(a, b) {\n    return a === b || a !== a && b !== b;\n  }\n  var MapPolyfill = createCollection({\n    'delete': sharedDelete,\n    has: mapHas,\n    get: sharedGet,\n    set: sharedSet,\n    keys: sharedKeys,\n    values: sharedValues,\n    entries: mapEntries,\n    forEach: sharedForEach,\n    clear: sharedClear\n  });\n  function createCollection(proto, objectOnly) {\n    function Collection(a) {\n      if (!this || this.constructor !== Collection) return new Collection(a);\n      this._keys = [];\n      this._values = [];\n      this._itp = [];\n      this.objectOnly = objectOnly;\n      if (a) init.call(this, a);\n    }\n    if (!objectOnly) {\n      defineProperty$1(proto, 'size', {\n        get: sharedSize\n      });\n    }\n    proto.constructor = Collection;\n    Collection.prototype = proto;\n    return Collection;\n  }\n  function init(a) {\n    if (this.add) a.forEach(this.add, this);\n    else a.forEach(function (a) {\n        this.set(a[0], a[1]);\n      }, this);\n  }\n  function sharedDelete(key) {\n    if (this.has(key)) {\n      this._keys.splice(i, 1);\n      this._values.splice(i, 1);\n      this._itp.forEach(function (p) {\n        if (i < p[0]) p[0]--;\n      });\n    }\n    return i > -1;\n  }\n  function sharedGet(key) {\n    return this.has(key) ? this._values[i] : undefined;\n  }\n  function has(list, key) {\n    if (this.objectOnly && key !== Object(key)) throw new TypeError('Invalid value used as weak collection key');\n    if (key !== key || key === 0) for (i = list.length; i-- && !is(list[i], key);) {}\n    else i = list.indexOf(key);\n    return i > -1;\n  }\n  function mapHas(value) {\n    return has.call(this, this._keys, value);\n  }\n  function sharedSet(key, value) {\n    this.has(key) ? this._values[i] = value : this._values[this._keys.push(key) - 1] = value;\n    return this;\n  }\n  function sharedClear() {\n    (this._keys || 0).length = this._values.length = 0;\n  }\n  function sharedKeys() {\n    return sharedIterator(this._itp, this._keys);\n  }\n  function sharedValues() {\n    return sharedIterator(this._itp, this._values);\n  }\n  function mapEntries() {\n    return sharedIterator(this._itp, this._keys, this._values);\n  }\n  function sharedIterator(itp, array, array2) {\n    var p = [0];\n    var done = false;\n    itp.push(p);\n    return {\n      next: function next() {\n        var v;\n        var k = p[0];\n        if (!done && k < array.length) {\n          v = array2 ? [array[k], array2[k]] : array[k];\n          p[0]++;\n        } else {\n          done = true;\n          itp.splice(itp.indexOf(p), 1);\n        }\n        return { done: done, value: v };\n      }\n    };\n  }\n  function sharedSize() {\n    return this._values.length;\n  }\n  function sharedForEach(callback, context) {\n    var it = this.entries();\n    for (;;) {\n      var r = it.next();\n      if (r.done) break;\n      callback.call(context, r.value[1], r.value[0], this);\n    }\n  }\n\n  var MapImpl = typeof Map === 'undefined' || !Map.prototype.values ? MapPolyfill : Map;\n  function HashMap() {\n    this.map_ = new MapImpl();\n  }\n  HashMap.prototype = new Map$2();\n  HashMap.prototype.get = function (key) {\n    return this.map_.get(key) || null;\n  };\n  HashMap.prototype.put = function (key, value) {\n    this.map_.set(key, value);\n    return value;\n  };\n  HashMap.prototype.values = function () {\n    var arrayList = new ArrayList();\n    var it = this.map_.values();\n    var o = it.next();\n    while (!o.done) {\n      arrayList.add(o.value);\n      o = it.next();\n    }\n    return arrayList;\n  };\n  HashMap.prototype.entrySet = function () {\n    var hashSet = new HashSet();\n    this.map_.entries().forEach(function (entry) {\n      return hashSet.add(entry);\n    });\n    return hashSet;\n  };\n  HashMap.prototype.size = function () {\n    return this.map_.size();\n  };\n\n  function PrecisionModel() {\n  \tthis._modelType = null;\n  \tthis._scale = null;\n  \tif (arguments.length === 0) {\n  \t\tthis._modelType = PrecisionModel.FLOATING;\n  \t} else if (arguments.length === 1) {\n  \t\tif (arguments[0] instanceof Type) {\n  \t\t\tvar modelType = arguments[0];\n  \t\t\tthis._modelType = modelType;\n  \t\t\tif (modelType === PrecisionModel.FIXED) {\n  \t\t\t\tthis.setScale(1.0);\n  \t\t\t}\n  \t\t} else if (typeof arguments[0] === \"number\") {\n  \t\t\tvar scale = arguments[0];\n  \t\t\tthis._modelType = PrecisionModel.FIXED;\n  \t\t\tthis.setScale(scale);\n  \t\t} else if (arguments[0] instanceof PrecisionModel) {\n  \t\t\tvar pm = arguments[0];\n  \t\t\tthis._modelType = pm._modelType;\n  \t\t\tthis._scale = pm._scale;\n  \t\t}\n  \t}\n  }\n  extend(PrecisionModel.prototype, {\n  \tequals: function equals(other) {\n  \t\tif (!(other instanceof PrecisionModel)) {\n  \t\t\treturn false;\n  \t\t}\n  \t\tvar otherPrecisionModel = other;\n  \t\treturn this._modelType === otherPrecisionModel._modelType && this._scale === otherPrecisionModel._scale;\n  \t},\n  \tcompareTo: function compareTo(o) {\n  \t\tvar other = o;\n  \t\tvar sigDigits = this.getMaximumSignificantDigits();\n  \t\tvar otherSigDigits = other.getMaximumSignificantDigits();\n  \t\treturn new Integer(sigDigits).compareTo(new Integer(otherSigDigits));\n  \t},\n  \tgetScale: function getScale() {\n  \t\treturn this._scale;\n  \t},\n  \tisFloating: function isFloating() {\n  \t\treturn this._modelType === PrecisionModel.FLOATING || this._modelType === PrecisionModel.FLOATING_SINGLE;\n  \t},\n  \tgetType: function getType() {\n  \t\treturn this._modelType;\n  \t},\n  \ttoString: function toString() {\n  \t\tvar description = \"UNKNOWN\";\n  \t\tif (this._modelType === PrecisionModel.FLOATING) {\n  \t\t\tdescription = \"Floating\";\n  \t\t} else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {\n  \t\t\tdescription = \"Floating-Single\";\n  \t\t} else if (this._modelType === PrecisionModel.FIXED) {\n  \t\t\tdescription = \"Fixed (Scale=\" + this.getScale() + \")\";\n  \t\t}\n  \t\treturn description;\n  \t},\n  \tmakePrecise: function makePrecise() {\n  \t\tif (typeof arguments[0] === \"number\") {\n  \t\t\tvar val = arguments[0];\n  \t\t\tif (Double.isNaN(val)) return val;\n  \t\t\tif (this._modelType === PrecisionModel.FLOATING_SINGLE) {\n  \t\t\t\tvar floatSingleVal = val;\n  \t\t\t\treturn floatSingleVal;\n  \t\t\t}\n  \t\t\tif (this._modelType === PrecisionModel.FIXED) {\n  \t\t\t\treturn Math.round(val * this._scale) / this._scale;\n  \t\t\t}\n  \t\t\treturn val;\n  \t\t} else if (arguments[0] instanceof Coordinate) {\n  \t\t\tvar coord = arguments[0];\n  \t\t\tif (this._modelType === PrecisionModel.FLOATING) return null;\n  \t\t\tcoord.x = this.makePrecise(coord.x);\n  \t\t\tcoord.y = this.makePrecise(coord.y);\n  \t\t}\n  \t},\n  \tgetMaximumSignificantDigits: function getMaximumSignificantDigits() {\n  \t\tvar maxSigDigits = 16;\n  \t\tif (this._modelType === PrecisionModel.FLOATING) {\n  \t\t\tmaxSigDigits = 16;\n  \t\t} else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {\n  \t\t\tmaxSigDigits = 6;\n  \t\t} else if (this._modelType === PrecisionModel.FIXED) {\n  \t\t\tmaxSigDigits = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)));\n  \t\t}\n  \t\treturn maxSigDigits;\n  \t},\n  \tsetScale: function setScale(scale) {\n  \t\tthis._scale = Math.abs(scale);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Serializable, Comparable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn PrecisionModel;\n  \t}\n  });\n  PrecisionModel.mostPrecise = function (pm1, pm2) {\n  \tif (pm1.compareTo(pm2) >= 0) return pm1;\n  \treturn pm2;\n  };\n  function Type() {\n  \tthis._name = null;\n  \tvar name = arguments[0];\n  \tthis._name = name;\n  \tType.nameToTypeMap.put(name, this);\n  }\n  extend(Type.prototype, {\n  \treadResolve: function readResolve() {\n  \t\treturn Type.nameToTypeMap.get(this._name);\n  \t},\n  \ttoString: function toString() {\n  \t\treturn this._name;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Serializable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Type;\n  \t}\n  });\n  Type.serialVersionUID = -5528602631731589822;\n  Type.nameToTypeMap = new HashMap();\n  PrecisionModel.Type = Type;\n  PrecisionModel.serialVersionUID = 7777263578777803835;\n  PrecisionModel.FIXED = new Type(\"FIXED\");\n  PrecisionModel.FLOATING = new Type(\"FLOATING\");\n  PrecisionModel.FLOATING_SINGLE = new Type(\"FLOATING SINGLE\");\n  PrecisionModel.maximumPreciseValue = 9007199254740992.0;\n\n  function GeometryFactory() {\n  \tthis._precisionModel = null;\n  \tthis._coordinateSequenceFactory = null;\n  \tthis._SRID = null;\n  \tif (arguments.length === 0) {\n  \t\tGeometryFactory.call(this, new PrecisionModel(), 0);\n  \t} else if (arguments.length === 1) {\n  \t\tif (hasInterface(arguments[0], CoordinateSequenceFactory)) {\n  \t\t\tvar coordinateSequenceFactory = arguments[0];\n  \t\t\tGeometryFactory.call(this, new PrecisionModel(), 0, coordinateSequenceFactory);\n  \t\t} else if (arguments[0] instanceof PrecisionModel) {\n  \t\t\tvar precisionModel = arguments[0];\n  \t\t\tGeometryFactory.call(this, precisionModel, 0, GeometryFactory.getDefaultCoordinateSequenceFactory());\n  \t\t}\n  \t} else if (arguments.length === 2) {\n  \t\tvar precisionModel = arguments[0],\n  \t\t    SRID = arguments[1];\n  \t\tGeometryFactory.call(this, precisionModel, SRID, GeometryFactory.getDefaultCoordinateSequenceFactory());\n  \t} else if (arguments.length === 3) {\n  \t\tvar precisionModel = arguments[0],\n  \t\t    SRID = arguments[1],\n  \t\t    coordinateSequenceFactory = arguments[2];\n  \t\tthis._precisionModel = precisionModel;\n  \t\tthis._coordinateSequenceFactory = coordinateSequenceFactory;\n  \t\tthis._SRID = SRID;\n  \t}\n  }\n  extend(GeometryFactory.prototype, {\n  \ttoGeometry: function toGeometry(envelope) {\n  \t\tif (envelope.isNull()) {\n  \t\t\treturn this.createPoint(null);\n  \t\t}\n  \t\tif (envelope.getMinX() === envelope.getMaxX() && envelope.getMinY() === envelope.getMaxY()) {\n  \t\t\treturn this.createPoint(new Coordinate(envelope.getMinX(), envelope.getMinY()));\n  \t\t}\n  \t\tif (envelope.getMinX() === envelope.getMaxX() || envelope.getMinY() === envelope.getMaxY()) {\n  \t\t\treturn this.createLineString([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY())]);\n  \t\t}\n  \t\treturn this.createPolygon(this.createLinearRing([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMinY())]), null);\n  \t},\n  \tcreateLineString: function createLineString() {\n  \t\tif (arguments.length === 0) {\n  \t\t\treturn this.createLineString(this.getCoordinateSequenceFactory().create([]));\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tif (arguments[0] instanceof Array) {\n  \t\t\t\tvar coordinates = arguments[0];\n  \t\t\t\treturn this.createLineString(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);\n  \t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n  \t\t\t\tvar coordinates = arguments[0];\n  \t\t\t\treturn new LineString(coordinates, this);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcreateMultiLineString: function createMultiLineString() {\n  \t\tif (arguments.length === 0) {\n  \t\t\treturn new MultiLineString(null, this);\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tvar lineStrings = arguments[0];\n  \t\t\treturn new MultiLineString(lineStrings, this);\n  \t\t}\n  \t},\n  \tbuildGeometry: function buildGeometry(geomList) {\n  \t\tvar geomClass = null;\n  \t\tvar isHeterogeneous = false;\n  \t\tvar hasGeometryCollection = false;\n  \t\tfor (var i = geomList.iterator(); i.hasNext();) {\n  \t\t\tvar geom = i.next();\n  \t\t\tvar partClass = geom.getClass();\n  \t\t\tif (geomClass === null) {\n  \t\t\t\tgeomClass = partClass;\n  \t\t\t}\n  \t\t\tif (partClass !== geomClass) {\n  \t\t\t\tisHeterogeneous = true;\n  \t\t\t}\n  \t\t\tif (geom.isGeometryCollectionOrDerived()) hasGeometryCollection = true;\n  \t\t}\n  \t\tif (geomClass === null) {\n  \t\t\treturn this.createGeometryCollection();\n  \t\t}\n  \t\tif (isHeterogeneous || hasGeometryCollection) {\n  \t\t\treturn this.createGeometryCollection(GeometryFactory.toGeometryArray(geomList));\n  \t\t}\n  \t\tvar geom0 = geomList.iterator().next();\n  \t\tvar isCollection = geomList.size() > 1;\n  \t\tif (isCollection) {\n  \t\t\tif (geom0 instanceof Polygon) {\n  \t\t\t\treturn this.createMultiPolygon(GeometryFactory.toPolygonArray(geomList));\n  \t\t\t} else if (geom0 instanceof LineString) {\n  \t\t\t\treturn this.createMultiLineString(GeometryFactory.toLineStringArray(geomList));\n  \t\t\t} else if (geom0 instanceof Point) {\n  \t\t\t\treturn this.createMultiPoint(GeometryFactory.toPointArray(geomList));\n  \t\t\t}\n  \t\t\tAssert.shouldNeverReachHere(\"Unhandled class: \" + geom0.getClass().getName());\n  \t\t}\n  \t\treturn geom0;\n  \t},\n  \tcreateMultiPointFromCoords: function createMultiPointFromCoords(coordinates) {\n  \t\treturn this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);\n  \t},\n  \tcreatePoint: function createPoint() {\n  \t\tif (arguments.length === 0) {\n  \t\t\treturn this.createPoint(this.getCoordinateSequenceFactory().create([]));\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tif (arguments[0] instanceof Coordinate) {\n  \t\t\t\tvar coordinate = arguments[0];\n  \t\t\t\treturn this.createPoint(coordinate !== null ? this.getCoordinateSequenceFactory().create([coordinate]) : null);\n  \t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n  \t\t\t\tvar coordinates = arguments[0];\n  \t\t\t\treturn new Point(coordinates, this);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetCoordinateSequenceFactory: function getCoordinateSequenceFactory() {\n  \t\treturn this._coordinateSequenceFactory;\n  \t},\n  \tcreatePolygon: function createPolygon() {\n  \t\tif (arguments.length === 0) {\n  \t\t\treturn new Polygon(null, null, this);\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tif (hasInterface(arguments[0], CoordinateSequence)) {\n  \t\t\t\tvar coordinates = arguments[0];\n  \t\t\t\treturn this.createPolygon(this.createLinearRing(coordinates));\n  \t\t\t} else if (arguments[0] instanceof Array) {\n  \t\t\t\tvar coordinates = arguments[0];\n  \t\t\t\treturn this.createPolygon(this.createLinearRing(coordinates));\n  \t\t\t} else if (arguments[0] instanceof LinearRing) {\n  \t\t\t\tvar shell = arguments[0];\n  \t\t\t\treturn this.createPolygon(shell, null);\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar shell = arguments[0],\n  \t\t\t    holes = arguments[1];\n  \t\t\treturn new Polygon(shell, holes, this);\n  \t\t}\n  \t},\n  \tgetSRID: function getSRID() {\n  \t\treturn this._SRID;\n  \t},\n  \tcreateGeometryCollection: function createGeometryCollection() {\n  \t\tif (arguments.length === 0) {\n  \t\t\treturn new GeometryCollection(null, this);\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tvar geometries = arguments[0];\n  \t\t\treturn new GeometryCollection(geometries, this);\n  \t\t}\n  \t},\n  \tcreateGeometry: function createGeometry(g) {\n  \t\tvar editor = new GeometryEditor(this);\n  \t\treturn editor.edit(g, {\n  \t\t\tedit: function edit() {\n  \t\t\t\tif (arguments.length === 2) {\n  \t\t\t\t\tvar coordSeq = arguments[0];\n  \t\t\t\t\treturn this._coordinateSequenceFactory.create(coordSeq);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t});\n  \t},\n  \tgetPrecisionModel: function getPrecisionModel() {\n  \t\treturn this._precisionModel;\n  \t},\n  \tcreateLinearRing: function createLinearRing() {\n  \t\tif (arguments.length === 0) {\n  \t\t\treturn this.createLinearRing(this.getCoordinateSequenceFactory().create([]));\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tif (arguments[0] instanceof Array) {\n  \t\t\t\tvar coordinates = arguments[0];\n  \t\t\t\treturn this.createLinearRing(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);\n  \t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n  \t\t\t\tvar coordinates = arguments[0];\n  \t\t\t\treturn new LinearRing(coordinates, this);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcreateMultiPolygon: function createMultiPolygon() {\n  \t\tif (arguments.length === 0) {\n  \t\t\treturn new MultiPolygon(null, this);\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tvar polygons = arguments[0];\n  \t\t\treturn new MultiPolygon(polygons, this);\n  \t\t}\n  \t},\n  \tcreateMultiPoint: function createMultiPoint() {\n  \t\tif (arguments.length === 0) {\n  \t\t\treturn new MultiPoint(null, this);\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tif (arguments[0] instanceof Array) {\n  \t\t\t\tvar point = arguments[0];\n  \t\t\t\treturn new MultiPoint(point, this);\n  \t\t\t} else if (arguments[0] instanceof Array) {\n  \t\t\t\tvar coordinates = arguments[0];\n  \t\t\t\treturn this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);\n  \t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n  \t\t\t\tvar coordinates = arguments[0];\n  \t\t\t\tif (coordinates === null) {\n  \t\t\t\t\treturn this.createMultiPoint(new Array(0).fill(null));\n  \t\t\t\t}\n  \t\t\t\tvar points = new Array(coordinates.size()).fill(null);\n  \t\t\t\tfor (var i = 0; i < coordinates.size(); i++) {\n  \t\t\t\t\tvar ptSeq = this.getCoordinateSequenceFactory().create(1, coordinates.getDimension());\n  \t\t\t\t\tCoordinateSequences.copy(coordinates, i, ptSeq, 0, 1);\n  \t\t\t\t\tpoints[i] = this.createPoint(ptSeq);\n  \t\t\t\t}\n  \t\t\t\treturn this.createMultiPoint(points);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Serializable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn GeometryFactory;\n  \t}\n  });\n  GeometryFactory.toMultiPolygonArray = function (multiPolygons) {\n  \tvar multiPolygonArray = new Array(multiPolygons.size()).fill(null);\n  \treturn multiPolygons.toArray(multiPolygonArray);\n  };\n  GeometryFactory.toGeometryArray = function (geometries) {\n  \tif (geometries === null) return null;\n  \tvar geometryArray = new Array(geometries.size()).fill(null);\n  \treturn geometries.toArray(geometryArray);\n  };\n  GeometryFactory.getDefaultCoordinateSequenceFactory = function () {\n  \treturn CoordinateArraySequenceFactory.instance();\n  };\n  GeometryFactory.toMultiLineStringArray = function (multiLineStrings) {\n  \tvar multiLineStringArray = new Array(multiLineStrings.size()).fill(null);\n  \treturn multiLineStrings.toArray(multiLineStringArray);\n  };\n  GeometryFactory.toLineStringArray = function (lineStrings) {\n  \tvar lineStringArray = new Array(lineStrings.size()).fill(null);\n  \treturn lineStrings.toArray(lineStringArray);\n  };\n  GeometryFactory.toMultiPointArray = function (multiPoints) {\n  \tvar multiPointArray = new Array(multiPoints.size()).fill(null);\n  \treturn multiPoints.toArray(multiPointArray);\n  };\n  GeometryFactory.toLinearRingArray = function (linearRings) {\n  \tvar linearRingArray = new Array(linearRings.size()).fill(null);\n  \treturn linearRings.toArray(linearRingArray);\n  };\n  GeometryFactory.toPointArray = function (points) {\n  \tvar pointArray = new Array(points.size()).fill(null);\n  \treturn points.toArray(pointArray);\n  };\n  GeometryFactory.toPolygonArray = function (polygons) {\n  \tvar polygonArray = new Array(polygons.size()).fill(null);\n  \treturn polygons.toArray(polygonArray);\n  };\n  GeometryFactory.createPointFromInternalCoord = function (coord, exemplar) {\n  \texemplar.getPrecisionModel().makePrecise(coord);\n  \treturn exemplar.getFactory().createPoint(coord);\n  };\n  GeometryFactory.serialVersionUID = -6820524753094095635;\n\n  var regExes = {\n    'typeStr': /^\\s*(\\w+)\\s*\\(\\s*(.*)\\s*\\)\\s*$/,\n    'emptyTypeStr': /^\\s*(\\w+)\\s*EMPTY\\s*$/,\n    'spaces': /\\s+/,\n    'parenComma': /\\)\\s*,\\s*\\(/,\n    'doubleParenComma': /\\)\\s*\\)\\s*,\\s*\\(\\s*\\(/,\n    'trimParens': /^\\s*\\(?(.*?)\\)?\\s*$/\n  };function WKTParser(geometryFactory) {\n    this.geometryFactory = geometryFactory || new GeometryFactory();\n  }\n  extend(WKTParser.prototype, {\n    read: function read(wkt) {\n      var geometry, type, str;\n      wkt = wkt.replace(/[\\n\\r]/g, ' ');\n      var matches = regExes.typeStr.exec(wkt);\n      if (wkt.search('EMPTY') !== -1) {\n        matches = regExes.emptyTypeStr.exec(wkt);\n        matches[2] = undefined;\n      }\n      if (matches) {\n        type = matches[1].toLowerCase();\n        str = matches[2];\n        if (parse[type]) {\n          geometry = parse[type].apply(this, [str]);\n        }\n      }\n      if (geometry === undefined) throw new Error('Could not parse WKT ' + wkt);\n      return geometry;\n    },\n    write: function write(geometry) {\n      return this.extractGeometry(geometry);\n    },\n    extractGeometry: function extractGeometry(geometry) {\n      var type = geometry.getGeometryType().toLowerCase();\n      if (!extract$1[type]) {\n        return null;\n      }\n      var wktType = type.toUpperCase();\n      var data;\n      if (geometry.isEmpty()) {\n        data = wktType + ' EMPTY';\n      } else {\n        data = wktType + '(' + extract$1[type].apply(this, [geometry]) + ')';\n      }\n      return data;\n    }\n  });\n  var extract$1 = {\n    coordinate: function coordinate(_coordinate) {\n      return _coordinate.x + ' ' + _coordinate.y;\n    },\n    point: function point(_point) {\n      return extract$1.coordinate.call(this, _point._coordinates._coordinates[0]);\n    },\n    multipoint: function multipoint(_multipoint) {\n      var array = [];\n      for (var i = 0, len = _multipoint._geometries.length; i < len; ++i) {\n        array.push('(' + extract$1.point.apply(this, [_multipoint._geometries[i]]) + ')');\n      }\n      return array.join(',');\n    },\n    linestring: function linestring(_linestring) {\n      var array = [];\n      for (var i = 0, len = _linestring._points._coordinates.length; i < len; ++i) {\n        array.push(extract$1.coordinate.apply(this, [_linestring._points._coordinates[i]]));\n      }\n      return array.join(',');\n    },\n    linearring: function linearring(_linearring) {\n      var array = [];\n      for (var i = 0, len = _linearring._points._coordinates.length; i < len; ++i) {\n        array.push(extract$1.coordinate.apply(this, [_linearring._points._coordinates[i]]));\n      }\n      return array.join(',');\n    },\n    multilinestring: function multilinestring(_multilinestring) {\n      var array = [];\n      for (var i = 0, len = _multilinestring._geometries.length; i < len; ++i) {\n        array.push('(' + extract$1.linestring.apply(this, [_multilinestring._geometries[i]]) + ')');\n      }\n      return array.join(',');\n    },\n    polygon: function polygon(_polygon) {\n      var array = [];\n      array.push('(' + extract$1.linestring.apply(this, [_polygon._shell]) + ')');\n      for (var i = 0, len = _polygon._holes.length; i < len; ++i) {\n        array.push('(' + extract$1.linestring.apply(this, [_polygon._holes[i]]) + ')');\n      }\n      return array.join(',');\n    },\n    multipolygon: function multipolygon(_multipolygon) {\n      var array = [];\n      for (var i = 0, len = _multipolygon._geometries.length; i < len; ++i) {\n        array.push('(' + extract$1.polygon.apply(this, [_multipolygon._geometries[i]]) + ')');\n      }\n      return array.join(',');\n    },\n    geometrycollection: function geometrycollection(collection) {\n      var array = [];\n      for (var i = 0, len = collection._geometries.length; i < len; ++i) {\n        array.push(this.extractGeometry(collection._geometries[i]));\n      }\n      return array.join(',');\n    }\n  };\n  var parse = {\n    point: function point(str) {\n      if (str === undefined) {\n        return this.geometryFactory.createPoint();\n      }\n      var coords = str.trim().split(regExes.spaces);\n      return this.geometryFactory.createPoint(new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1])));\n    },\n    multipoint: function multipoint(str) {\n      if (str === undefined) {\n        return this.geometryFactory.createMultiPoint();\n      }\n      var point;\n      var points = str.trim().split(',');\n      var components = [];\n      for (var i = 0, len = points.length; i < len; ++i) {\n        point = points[i].replace(regExes.trimParens, '$1');\n        components.push(parse.point.apply(this, [point]));\n      }\n      return this.geometryFactory.createMultiPoint(components);\n    },\n    linestring: function linestring(str) {\n      if (str === undefined) {\n        return this.geometryFactory.createLineString();\n      }\n      var points = str.trim().split(',');\n      var components = [];\n      var coords;\n      for (var i = 0, len = points.length; i < len; ++i) {\n        coords = points[i].trim().split(regExes.spaces);\n        components.push(new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1])));\n      }\n      return this.geometryFactory.createLineString(components);\n    },\n    linearring: function linearring(str) {\n      if (str === undefined) {\n        return this.geometryFactory.createLinearRing();\n      }\n      var points = str.trim().split(',');\n      var components = [];\n      var coords;\n      for (var i = 0, len = points.length; i < len; ++i) {\n        coords = points[i].trim().split(regExes.spaces);\n        components.push(new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1])));\n      }\n      return this.geometryFactory.createLinearRing(components);\n    },\n    multilinestring: function multilinestring(str) {\n      if (str === undefined) {\n        return this.geometryFactory.createMultiLineString();\n      }\n      var line;\n      var lines = str.trim().split(regExes.parenComma);\n      var components = [];\n      for (var i = 0, len = lines.length; i < len; ++i) {\n        line = lines[i].replace(regExes.trimParens, '$1');\n        components.push(parse.linestring.apply(this, [line]));\n      }\n      return this.geometryFactory.createMultiLineString(components);\n    },\n    polygon: function polygon(str) {\n      if (str === undefined) {\n        return this.geometryFactory.createPolygon();\n      }\n      var ring, linestring, linearring;\n      var rings = str.trim().split(regExes.parenComma);\n      var shell;\n      var holes = [];\n      for (var i = 0, len = rings.length; i < len; ++i) {\n        ring = rings[i].replace(regExes.trimParens, '$1');\n        linestring = parse.linestring.apply(this, [ring]);\n        linearring = this.geometryFactory.createLinearRing(linestring._points);\n        if (i === 0) {\n          shell = linearring;\n        } else {\n          holes.push(linearring);\n        }\n      }\n      return this.geometryFactory.createPolygon(shell, holes);\n    },\n    multipolygon: function multipolygon(str) {\n      if (str === undefined) {\n        return this.geometryFactory.createMultiPolygon();\n      }\n      var polygon;\n      var polygons = str.trim().split(regExes.doubleParenComma);\n      var components = [];\n      for (var i = 0, len = polygons.length; i < len; ++i) {\n        polygon = polygons[i].replace(regExes.trimParens, '$1');\n        components.push(parse.polygon.apply(this, [polygon]));\n      }\n      return this.geometryFactory.createMultiPolygon(components);\n    },\n    geometrycollection: function geometrycollection(str) {\n      if (str === undefined) {\n        return this.geometryFactory.createGeometryCollection();\n      }\n      str = str.replace(/,\\s*([A-Za-z])/g, '|$1');\n      var wktArray = str.trim().split('|');\n      var components = [];\n      for (var i = 0, len = wktArray.length; i < len; ++i) {\n        components.push(this.read(wktArray[i]));\n      }\n      return this.geometryFactory.createGeometryCollection(components);\n    }\n  };\n\n  function WKTWriter(geometryFactory) {\n    this.parser = new WKTParser(geometryFactory);\n  }\n  extend(WKTWriter.prototype, {\n    write: function write(geometry) {\n      return this.parser.write(geometry);\n    }\n  });\n  extend(WKTWriter, {\n    toLineString: function toLineString(p0, p1) {\n      if (arguments.length !== 2) {\n        throw new Error('Not implemented');\n      }\n      return 'LINESTRING ( ' + p0.x + ' ' + p0.y + ', ' + p1.x + ' ' + p1.y + ' )';\n    }\n  });\n\n  function LineIntersector() {\n  \tthis._result = null;\n  \tthis._inputLines = Array(2).fill().map(function () {\n  \t\treturn Array(2);\n  \t});\n  \tthis._intPt = new Array(2).fill(null);\n  \tthis._intLineIndex = null;\n  \tthis._isProper = null;\n  \tthis._pa = null;\n  \tthis._pb = null;\n  \tthis._precisionModel = null;\n  \tthis._intPt[0] = new Coordinate();\n  \tthis._intPt[1] = new Coordinate();\n  \tthis._pa = this._intPt[0];\n  \tthis._pb = this._intPt[1];\n  \tthis._result = 0;\n  }\n  extend(LineIntersector.prototype, {\n  \tgetIndexAlongSegment: function getIndexAlongSegment(segmentIndex, intIndex) {\n  \t\tthis.computeIntLineIndex();\n  \t\treturn this._intLineIndex[segmentIndex][intIndex];\n  \t},\n  \tgetTopologySummary: function getTopologySummary() {\n  \t\tvar catBuf = new StringBuffer();\n  \t\tif (this.isEndPoint()) catBuf.append(\" endpoint\");\n  \t\tif (this._isProper) catBuf.append(\" proper\");\n  \t\tif (this.isCollinear()) catBuf.append(\" collinear\");\n  \t\treturn catBuf.toString();\n  \t},\n  \tcomputeIntersection: function computeIntersection(p1, p2, p3, p4) {\n  \t\tthis._inputLines[0][0] = p1;\n  \t\tthis._inputLines[0][1] = p2;\n  \t\tthis._inputLines[1][0] = p3;\n  \t\tthis._inputLines[1][1] = p4;\n  \t\tthis._result = this.computeIntersect(p1, p2, p3, p4);\n  \t},\n  \tgetIntersectionNum: function getIntersectionNum() {\n  \t\treturn this._result;\n  \t},\n  \tcomputeIntLineIndex: function computeIntLineIndex() {\n  \t\tif (arguments.length === 0) {\n  \t\t\tif (this._intLineIndex === null) {\n  \t\t\t\tthis._intLineIndex = Array(2).fill().map(function () {\n  \t\t\t\t\treturn Array(2);\n  \t\t\t\t});\n  \t\t\t\tthis.computeIntLineIndex(0);\n  \t\t\t\tthis.computeIntLineIndex(1);\n  \t\t\t}\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tvar segmentIndex = arguments[0];\n  \t\t\tvar dist0 = this.getEdgeDistance(segmentIndex, 0);\n  \t\t\tvar dist1 = this.getEdgeDistance(segmentIndex, 1);\n  \t\t\tif (dist0 > dist1) {\n  \t\t\t\tthis._intLineIndex[segmentIndex][0] = 0;\n  \t\t\t\tthis._intLineIndex[segmentIndex][1] = 1;\n  \t\t\t} else {\n  \t\t\t\tthis._intLineIndex[segmentIndex][0] = 1;\n  \t\t\t\tthis._intLineIndex[segmentIndex][1] = 0;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tisProper: function isProper() {\n  \t\treturn this.hasIntersection() && this._isProper;\n  \t},\n  \tsetPrecisionModel: function setPrecisionModel(precisionModel) {\n  \t\tthis._precisionModel = precisionModel;\n  \t},\n  \tisInteriorIntersection: function isInteriorIntersection() {\n  \t\tif (arguments.length === 0) {\n  \t\t\tif (this.isInteriorIntersection(0)) return true;\n  \t\t\tif (this.isInteriorIntersection(1)) return true;\n  \t\t\treturn false;\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tvar inputLineIndex = arguments[0];\n  \t\t\tfor (var i = 0; i < this._result; i++) {\n  \t\t\t\tif (!(this._intPt[i].equals2D(this._inputLines[inputLineIndex][0]) || this._intPt[i].equals2D(this._inputLines[inputLineIndex][1]))) {\n  \t\t\t\t\treturn true;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\treturn false;\n  \t\t}\n  \t},\n  \tgetIntersection: function getIntersection(intIndex) {\n  \t\treturn this._intPt[intIndex];\n  \t},\n  \tisEndPoint: function isEndPoint() {\n  \t\treturn this.hasIntersection() && !this._isProper;\n  \t},\n  \thasIntersection: function hasIntersection() {\n  \t\treturn this._result !== LineIntersector.NO_INTERSECTION;\n  \t},\n  \tgetEdgeDistance: function getEdgeDistance(segmentIndex, intIndex) {\n  \t\tvar dist = LineIntersector.computeEdgeDistance(this._intPt[intIndex], this._inputLines[segmentIndex][0], this._inputLines[segmentIndex][1]);\n  \t\treturn dist;\n  \t},\n  \tisCollinear: function isCollinear() {\n  \t\treturn this._result === LineIntersector.COLLINEAR_INTERSECTION;\n  \t},\n  \ttoString: function toString() {\n  \t\treturn WKTWriter.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + \" - \" + WKTWriter.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();\n  \t},\n  \tgetEndpoint: function getEndpoint(segmentIndex, ptIndex) {\n  \t\treturn this._inputLines[segmentIndex][ptIndex];\n  \t},\n  \tisIntersection: function isIntersection(pt) {\n  \t\tfor (var i = 0; i < this._result; i++) {\n  \t\t\tif (this._intPt[i].equals2D(pt)) {\n  \t\t\t\treturn true;\n  \t\t\t}\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tgetIntersectionAlongSegment: function getIntersectionAlongSegment(segmentIndex, intIndex) {\n  \t\tthis.computeIntLineIndex();\n  \t\treturn this._intPt[this._intLineIndex[segmentIndex][intIndex]];\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LineIntersector;\n  \t}\n  });\n  LineIntersector.computeEdgeDistance = function (p, p0, p1) {\n  \tvar dx = Math.abs(p1.x - p0.x);\n  \tvar dy = Math.abs(p1.y - p0.y);\n  \tvar dist = -1.0;\n  \tif (p.equals(p0)) {\n  \t\tdist = 0.0;\n  \t} else if (p.equals(p1)) {\n  \t\tif (dx > dy) dist = dx;else dist = dy;\n  \t} else {\n  \t\tvar pdx = Math.abs(p.x - p0.x);\n  \t\tvar pdy = Math.abs(p.y - p0.y);\n  \t\tif (dx > dy) dist = pdx;else dist = pdy;\n  \t\tif (dist === 0.0 && !p.equals(p0)) {\n  \t\t\tdist = Math.max(pdx, pdy);\n  \t\t}\n  \t}\n  \tAssert.isTrue(!(dist === 0.0 && !p.equals(p0)), \"Bad distance calculation\");\n  \treturn dist;\n  };\n  LineIntersector.nonRobustComputeEdgeDistance = function (p, p1, p2) {\n  \tvar dx = p.x - p1.x;\n  \tvar dy = p.y - p1.y;\n  \tvar dist = Math.sqrt(dx * dx + dy * dy);\n  \tAssert.isTrue(!(dist === 0.0 && !p.equals(p1)), \"Invalid distance calculation\");\n  \treturn dist;\n  };\n  LineIntersector.DONT_INTERSECT = 0;\n  LineIntersector.DO_INTERSECT = 1;\n  LineIntersector.COLLINEAR = 2;\n  LineIntersector.NO_INTERSECTION = 0;\n  LineIntersector.POINT_INTERSECTION = 1;\n  LineIntersector.COLLINEAR_INTERSECTION = 2;\n\n  function RobustLineIntersector() {\n  \tLineIntersector.apply(this);\n  }\n  inherits$1(RobustLineIntersector, LineIntersector);\n  extend(RobustLineIntersector.prototype, {\n  \tisInSegmentEnvelopes: function isInSegmentEnvelopes(intPt) {\n  \t\tvar env0 = new Envelope(this._inputLines[0][0], this._inputLines[0][1]);\n  \t\tvar env1 = new Envelope(this._inputLines[1][0], this._inputLines[1][1]);\n  \t\treturn env0.contains(intPt) && env1.contains(intPt);\n  \t},\n  \tcomputeIntersection: function computeIntersection() {\n  \t\tif (arguments.length === 3) {\n  \t\t\tvar p = arguments[0],\n  \t\t\t    p1 = arguments[1],\n  \t\t\t    p2 = arguments[2];\n  \t\t\tthis._isProper = false;\n  \t\t\tif (Envelope.intersects(p1, p2, p)) {\n  \t\t\t\tif (CGAlgorithms.orientationIndex(p1, p2, p) === 0 && CGAlgorithms.orientationIndex(p2, p1, p) === 0) {\n  \t\t\t\t\tthis._isProper = true;\n  \t\t\t\t\tif (p.equals(p1) || p.equals(p2)) {\n  \t\t\t\t\t\tthis._isProper = false;\n  \t\t\t\t\t}\n  \t\t\t\t\tthis._result = LineIntersector.POINT_INTERSECTION;\n  \t\t\t\t\treturn null;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\tthis._result = LineIntersector.NO_INTERSECTION;\n  \t\t} else return LineIntersector.prototype.computeIntersection.apply(this, arguments);\n  \t},\n  \tnormalizeToMinimum: function normalizeToMinimum(n1, n2, n3, n4, normPt) {\n  \t\tnormPt.x = this.smallestInAbsValue(n1.x, n2.x, n3.x, n4.x);\n  \t\tnormPt.y = this.smallestInAbsValue(n1.y, n2.y, n3.y, n4.y);\n  \t\tn1.x -= normPt.x;\n  \t\tn1.y -= normPt.y;\n  \t\tn2.x -= normPt.x;\n  \t\tn2.y -= normPt.y;\n  \t\tn3.x -= normPt.x;\n  \t\tn3.y -= normPt.y;\n  \t\tn4.x -= normPt.x;\n  \t\tn4.y -= normPt.y;\n  \t},\n  \tsafeHCoordinateIntersection: function safeHCoordinateIntersection(p1, p2, q1, q2) {\n  \t\tvar intPt = null;\n  \t\ttry {\n  \t\t\tintPt = HCoordinate.intersection(p1, p2, q1, q2);\n  \t\t} catch (e) {\n  \t\t\tif (e instanceof NotRepresentableException) {\n  \t\t\t\tintPt = RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2);\n  \t\t\t} else throw e;\n  \t\t} finally {}\n  \t\treturn intPt;\n  \t},\n  \tintersection: function intersection(p1, p2, q1, q2) {\n  \t\tvar intPt = this.intersectionWithNormalization(p1, p2, q1, q2);\n  \t\tif (!this.isInSegmentEnvelopes(intPt)) {\n  \t\t\tintPt = new Coordinate(RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2));\n  \t\t}\n  \t\tif (this._precisionModel !== null) {\n  \t\t\tthis._precisionModel.makePrecise(intPt);\n  \t\t}\n  \t\treturn intPt;\n  \t},\n  \tsmallestInAbsValue: function smallestInAbsValue(x1, x2, x3, x4) {\n  \t\tvar x = x1;\n  \t\tvar xabs = Math.abs(x);\n  \t\tif (Math.abs(x2) < xabs) {\n  \t\t\tx = x2;\n  \t\t\txabs = Math.abs(x2);\n  \t\t}\n  \t\tif (Math.abs(x3) < xabs) {\n  \t\t\tx = x3;\n  \t\t\txabs = Math.abs(x3);\n  \t\t}\n  \t\tif (Math.abs(x4) < xabs) {\n  \t\t\tx = x4;\n  \t\t}\n  \t\treturn x;\n  \t},\n  \tcheckDD: function checkDD(p1, p2, q1, q2, intPt) {\n  \t\tvar intPtDD = CGAlgorithmsDD.intersection(p1, p2, q1, q2);\n  \t\tvar isIn = this.isInSegmentEnvelopes(intPtDD);\n  \t\tSystem.out.println(\"DD in env = \" + isIn + \"  --------------------- \" + intPtDD);\n  \t\tif (intPt.distance(intPtDD) > 0.0001) {\n  \t\t\tSystem.out.println(\"Distance = \" + intPt.distance(intPtDD));\n  \t\t}\n  \t},\n  \tintersectionWithNormalization: function intersectionWithNormalization(p1, p2, q1, q2) {\n  \t\tvar n1 = new Coordinate(p1);\n  \t\tvar n2 = new Coordinate(p2);\n  \t\tvar n3 = new Coordinate(q1);\n  \t\tvar n4 = new Coordinate(q2);\n  \t\tvar normPt = new Coordinate();\n  \t\tthis.normalizeToEnvCentre(n1, n2, n3, n4, normPt);\n  \t\tvar intPt = this.safeHCoordinateIntersection(n1, n2, n3, n4);\n  \t\tintPt.x += normPt.x;\n  \t\tintPt.y += normPt.y;\n  \t\treturn intPt;\n  \t},\n  \tcomputeCollinearIntersection: function computeCollinearIntersection(p1, p2, q1, q2) {\n  \t\tvar p1q1p2 = Envelope.intersects(p1, p2, q1);\n  \t\tvar p1q2p2 = Envelope.intersects(p1, p2, q2);\n  \t\tvar q1p1q2 = Envelope.intersects(q1, q2, p1);\n  \t\tvar q1p2q2 = Envelope.intersects(q1, q2, p2);\n  \t\tif (p1q1p2 && p1q2p2) {\n  \t\t\tthis._intPt[0] = q1;\n  \t\t\tthis._intPt[1] = q2;\n  \t\t\treturn LineIntersector.COLLINEAR_INTERSECTION;\n  \t\t}\n  \t\tif (q1p1q2 && q1p2q2) {\n  \t\t\tthis._intPt[0] = p1;\n  \t\t\tthis._intPt[1] = p2;\n  \t\t\treturn LineIntersector.COLLINEAR_INTERSECTION;\n  \t\t}\n  \t\tif (p1q1p2 && q1p1q2) {\n  \t\t\tthis._intPt[0] = q1;\n  \t\t\tthis._intPt[1] = p1;\n  \t\t\treturn q1.equals(p1) && !p1q2p2 && !q1p2q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n  \t\t}\n  \t\tif (p1q1p2 && q1p2q2) {\n  \t\t\tthis._intPt[0] = q1;\n  \t\t\tthis._intPt[1] = p2;\n  \t\t\treturn q1.equals(p2) && !p1q2p2 && !q1p1q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n  \t\t}\n  \t\tif (p1q2p2 && q1p1q2) {\n  \t\t\tthis._intPt[0] = q2;\n  \t\t\tthis._intPt[1] = p1;\n  \t\t\treturn q2.equals(p1) && !p1q1p2 && !q1p2q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n  \t\t}\n  \t\tif (p1q2p2 && q1p2q2) {\n  \t\t\tthis._intPt[0] = q2;\n  \t\t\tthis._intPt[1] = p2;\n  \t\t\treturn q2.equals(p2) && !p1q1p2 && !q1p1q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n  \t\t}\n  \t\treturn LineIntersector.NO_INTERSECTION;\n  \t},\n  \tnormalizeToEnvCentre: function normalizeToEnvCentre(n00, n01, n10, n11, normPt) {\n  \t\tvar minX0 = n00.x < n01.x ? n00.x : n01.x;\n  \t\tvar minY0 = n00.y < n01.y ? n00.y : n01.y;\n  \t\tvar maxX0 = n00.x > n01.x ? n00.x : n01.x;\n  \t\tvar maxY0 = n00.y > n01.y ? n00.y : n01.y;\n  \t\tvar minX1 = n10.x < n11.x ? n10.x : n11.x;\n  \t\tvar minY1 = n10.y < n11.y ? n10.y : n11.y;\n  \t\tvar maxX1 = n10.x > n11.x ? n10.x : n11.x;\n  \t\tvar maxY1 = n10.y > n11.y ? n10.y : n11.y;\n  \t\tvar intMinX = minX0 > minX1 ? minX0 : minX1;\n  \t\tvar intMaxX = maxX0 < maxX1 ? maxX0 : maxX1;\n  \t\tvar intMinY = minY0 > minY1 ? minY0 : minY1;\n  \t\tvar intMaxY = maxY0 < maxY1 ? maxY0 : maxY1;\n  \t\tvar intMidX = (intMinX + intMaxX) / 2.0;\n  \t\tvar intMidY = (intMinY + intMaxY) / 2.0;\n  \t\tnormPt.x = intMidX;\n  \t\tnormPt.y = intMidY;\n  \t\tn00.x -= normPt.x;\n  \t\tn00.y -= normPt.y;\n  \t\tn01.x -= normPt.x;\n  \t\tn01.y -= normPt.y;\n  \t\tn10.x -= normPt.x;\n  \t\tn10.y -= normPt.y;\n  \t\tn11.x -= normPt.x;\n  \t\tn11.y -= normPt.y;\n  \t},\n  \tcomputeIntersect: function computeIntersect(p1, p2, q1, q2) {\n  \t\tthis._isProper = false;\n  \t\tif (!Envelope.intersects(p1, p2, q1, q2)) return LineIntersector.NO_INTERSECTION;\n  \t\tvar Pq1 = CGAlgorithms.orientationIndex(p1, p2, q1);\n  \t\tvar Pq2 = CGAlgorithms.orientationIndex(p1, p2, q2);\n  \t\tif (Pq1 > 0 && Pq2 > 0 || Pq1 < 0 && Pq2 < 0) {\n  \t\t\treturn LineIntersector.NO_INTERSECTION;\n  \t\t}\n  \t\tvar Qp1 = CGAlgorithms.orientationIndex(q1, q2, p1);\n  \t\tvar Qp2 = CGAlgorithms.orientationIndex(q1, q2, p2);\n  \t\tif (Qp1 > 0 && Qp2 > 0 || Qp1 < 0 && Qp2 < 0) {\n  \t\t\treturn LineIntersector.NO_INTERSECTION;\n  \t\t}\n  \t\tvar collinear = Pq1 === 0 && Pq2 === 0 && Qp1 === 0 && Qp2 === 0;\n  \t\tif (collinear) {\n  \t\t\treturn this.computeCollinearIntersection(p1, p2, q1, q2);\n  \t\t}\n  \t\tif (Pq1 === 0 || Pq2 === 0 || Qp1 === 0 || Qp2 === 0) {\n  \t\t\tthis._isProper = false;\n  \t\t\tif (p1.equals2D(q1) || p1.equals2D(q2)) {\n  \t\t\t\tthis._intPt[0] = p1;\n  \t\t\t} else if (p2.equals2D(q1) || p2.equals2D(q2)) {\n  \t\t\t\tthis._intPt[0] = p2;\n  \t\t\t} else if (Pq1 === 0) {\n  \t\t\t\tthis._intPt[0] = new Coordinate(q1);\n  \t\t\t} else if (Pq2 === 0) {\n  \t\t\t\tthis._intPt[0] = new Coordinate(q2);\n  \t\t\t} else if (Qp1 === 0) {\n  \t\t\t\tthis._intPt[0] = new Coordinate(p1);\n  \t\t\t} else if (Qp2 === 0) {\n  \t\t\t\tthis._intPt[0] = new Coordinate(p2);\n  \t\t\t}\n  \t\t} else {\n  \t\t\tthis._isProper = true;\n  \t\t\tthis._intPt[0] = this.intersection(p1, p2, q1, q2);\n  \t\t}\n  \t\treturn LineIntersector.POINT_INTERSECTION;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn RobustLineIntersector;\n  \t}\n  });\n  RobustLineIntersector.nearestEndpoint = function (p1, p2, q1, q2) {\n  \tvar nearestPt = p1;\n  \tvar minDist = CGAlgorithms.distancePointLine(p1, q1, q2);\n  \tvar dist = CGAlgorithms.distancePointLine(p2, q1, q2);\n  \tif (dist < minDist) {\n  \t\tminDist = dist;\n  \t\tnearestPt = p2;\n  \t}\n  \tdist = CGAlgorithms.distancePointLine(q1, p1, p2);\n  \tif (dist < minDist) {\n  \t\tminDist = dist;\n  \t\tnearestPt = q1;\n  \t}\n  \tdist = CGAlgorithms.distancePointLine(q2, p1, p2);\n  \tif (dist < minDist) {\n  \t\tminDist = dist;\n  \t\tnearestPt = q2;\n  \t}\n  \treturn nearestPt;\n  };\n\n  function RobustDeterminant() {}\n  extend(RobustDeterminant.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn RobustDeterminant;\n  \t}\n  });\n  RobustDeterminant.orientationIndex = function (p1, p2, q) {\n  \tvar dx1 = p2.x - p1.x;\n  \tvar dy1 = p2.y - p1.y;\n  \tvar dx2 = q.x - p2.x;\n  \tvar dy2 = q.y - p2.y;\n  \treturn RobustDeterminant.signOfDet2x2(dx1, dy1, dx2, dy2);\n  };\n  RobustDeterminant.signOfDet2x2 = function (x1, y1, x2, y2) {\n  \tvar sign = null;\n  \tvar swap = null;\n  \tvar k = null;\n  \tsign = 1;\n  \tif (x1 === 0.0 || y2 === 0.0) {\n  \t\tif (y1 === 0.0 || x2 === 0.0) {\n  \t\t\treturn 0;\n  \t\t} else if (y1 > 0) {\n  \t\t\tif (x2 > 0) {\n  \t\t\t\treturn -sign;\n  \t\t\t} else {\n  \t\t\t\treturn sign;\n  \t\t\t}\n  \t\t} else {\n  \t\t\tif (x2 > 0) {\n  \t\t\t\treturn sign;\n  \t\t\t} else {\n  \t\t\t\treturn -sign;\n  \t\t\t}\n  \t\t}\n  \t}\n  \tif (y1 === 0.0 || x2 === 0.0) {\n  \t\tif (y2 > 0) {\n  \t\t\tif (x1 > 0) {\n  \t\t\t\treturn sign;\n  \t\t\t} else {\n  \t\t\t\treturn -sign;\n  \t\t\t}\n  \t\t} else {\n  \t\t\tif (x1 > 0) {\n  \t\t\t\treturn -sign;\n  \t\t\t} else {\n  \t\t\t\treturn sign;\n  \t\t\t}\n  \t\t}\n  \t}\n  \tif (0.0 < y1) {\n  \t\tif (0.0 < y2) {\n  \t\t\tif (y1 <= y2) ; else {\n  \t\t\t\tsign = -sign;\n  \t\t\t\tswap = x1;\n  \t\t\t\tx1 = x2;\n  \t\t\t\tx2 = swap;\n  \t\t\t\tswap = y1;\n  \t\t\t\ty1 = y2;\n  \t\t\t\ty2 = swap;\n  \t\t\t}\n  \t\t} else {\n  \t\t\tif (y1 <= -y2) {\n  \t\t\t\tsign = -sign;\n  \t\t\t\tx2 = -x2;\n  \t\t\t\ty2 = -y2;\n  \t\t\t} else {\n  \t\t\t\tswap = x1;\n  \t\t\t\tx1 = -x2;\n  \t\t\t\tx2 = swap;\n  \t\t\t\tswap = y1;\n  \t\t\t\ty1 = -y2;\n  \t\t\t\ty2 = swap;\n  \t\t\t}\n  \t\t}\n  \t} else {\n  \t\tif (0.0 < y2) {\n  \t\t\tif (-y1 <= y2) {\n  \t\t\t\tsign = -sign;\n  \t\t\t\tx1 = -x1;\n  \t\t\t\ty1 = -y1;\n  \t\t\t} else {\n  \t\t\t\tswap = -x1;\n  \t\t\t\tx1 = x2;\n  \t\t\t\tx2 = swap;\n  \t\t\t\tswap = -y1;\n  \t\t\t\ty1 = y2;\n  \t\t\t\ty2 = swap;\n  \t\t\t}\n  \t\t} else {\n  \t\t\tif (y1 >= y2) {\n  \t\t\t\tx1 = -x1;\n  \t\t\t\ty1 = -y1;\n  \t\t\t\tx2 = -x2;\n  \t\t\t\ty2 = -y2;\n  \t\t\t} else {\n  \t\t\t\tsign = -sign;\n  \t\t\t\tswap = -x1;\n  \t\t\t\tx1 = -x2;\n  \t\t\t\tx2 = swap;\n  \t\t\t\tswap = -y1;\n  \t\t\t\ty1 = -y2;\n  \t\t\t\ty2 = swap;\n  \t\t\t}\n  \t\t}\n  \t}\n  \tif (0.0 < x1) {\n  \t\tif (0.0 < x2) {\n  \t\t\tif (x1 <= x2) ; else {\n  \t\t\t\treturn sign;\n  \t\t\t}\n  \t\t} else {\n  \t\t\treturn sign;\n  \t\t}\n  \t} else {\n  \t\tif (0.0 < x2) {\n  \t\t\treturn -sign;\n  \t\t} else {\n  \t\t\tif (x1 >= x2) {\n  \t\t\t\tsign = -sign;\n  \t\t\t\tx1 = -x1;\n  \t\t\t\tx2 = -x2;\n  \t\t\t} else {\n  \t\t\t\treturn -sign;\n  \t\t\t}\n  \t\t}\n  \t}\n  \twhile (true) {\n  \t\tk = Math.floor(x2 / x1);\n  \t\tx2 = x2 - k * x1;\n  \t\ty2 = y2 - k * y1;\n  \t\tif (y2 < 0.0) {\n  \t\t\treturn -sign;\n  \t\t}\n  \t\tif (y2 > y1) {\n  \t\t\treturn sign;\n  \t\t}\n  \t\tif (x1 > x2 + x2) {\n  \t\t\tif (y1 < y2 + y2) {\n  \t\t\t\treturn sign;\n  \t\t\t}\n  \t\t} else {\n  \t\t\tif (y1 > y2 + y2) {\n  \t\t\t\treturn -sign;\n  \t\t\t} else {\n  \t\t\t\tx2 = x1 - x2;\n  \t\t\t\ty2 = y1 - y2;\n  \t\t\t\tsign = -sign;\n  \t\t\t}\n  \t\t}\n  \t\tif (y2 === 0.0) {\n  \t\t\tif (x2 === 0.0) {\n  \t\t\t\treturn 0;\n  \t\t\t} else {\n  \t\t\t\treturn -sign;\n  \t\t\t}\n  \t\t}\n  \t\tif (x2 === 0.0) {\n  \t\t\treturn sign;\n  \t\t}\n  \t\tk = Math.floor(x1 / x2);\n  \t\tx1 = x1 - k * x2;\n  \t\ty1 = y1 - k * y2;\n  \t\tif (y1 < 0.0) {\n  \t\t\treturn sign;\n  \t\t}\n  \t\tif (y1 > y2) {\n  \t\t\treturn -sign;\n  \t\t}\n  \t\tif (x2 > x1 + x1) {\n  \t\t\tif (y2 < y1 + y1) {\n  \t\t\t\treturn -sign;\n  \t\t\t}\n  \t\t} else {\n  \t\t\tif (y2 > y1 + y1) {\n  \t\t\t\treturn sign;\n  \t\t\t} else {\n  \t\t\t\tx1 = x2 - x1;\n  \t\t\t\ty1 = y2 - y1;\n  \t\t\t\tsign = -sign;\n  \t\t\t}\n  \t\t}\n  \t\tif (y1 === 0.0) {\n  \t\t\tif (x1 === 0.0) {\n  \t\t\t\treturn 0;\n  \t\t\t} else {\n  \t\t\t\treturn sign;\n  \t\t\t}\n  \t\t}\n  \t\tif (x1 === 0.0) {\n  \t\t\treturn -sign;\n  \t\t}\n  \t}\n  };\n\n  function RayCrossingCounter() {\n  \tthis._p = null;\n  \tthis._crossingCount = 0;\n  \tthis._isPointOnSegment = false;\n  \tvar p = arguments[0];\n  \tthis._p = p;\n  }\n  extend(RayCrossingCounter.prototype, {\n  \tcountSegment: function countSegment(p1, p2) {\n  \t\tif (p1.x < this._p.x && p2.x < this._p.x) return null;\n  \t\tif (this._p.x === p2.x && this._p.y === p2.y) {\n  \t\t\tthis._isPointOnSegment = true;\n  \t\t\treturn null;\n  \t\t}\n  \t\tif (p1.y === this._p.y && p2.y === this._p.y) {\n  \t\t\tvar minx = p1.x;\n  \t\t\tvar maxx = p2.x;\n  \t\t\tif (minx > maxx) {\n  \t\t\t\tminx = p2.x;\n  \t\t\t\tmaxx = p1.x;\n  \t\t\t}\n  \t\t\tif (this._p.x >= minx && this._p.x <= maxx) {\n  \t\t\t\tthis._isPointOnSegment = true;\n  \t\t\t}\n  \t\t\treturn null;\n  \t\t}\n  \t\tif (p1.y > this._p.y && p2.y <= this._p.y || p2.y > this._p.y && p1.y <= this._p.y) {\n  \t\t\tvar x1 = p1.x - this._p.x;\n  \t\t\tvar y1 = p1.y - this._p.y;\n  \t\t\tvar x2 = p2.x - this._p.x;\n  \t\t\tvar y2 = p2.y - this._p.y;\n  \t\t\tvar xIntSign = RobustDeterminant.signOfDet2x2(x1, y1, x2, y2);\n  \t\t\tif (xIntSign === 0.0) {\n  \t\t\t\tthis._isPointOnSegment = true;\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t\tif (y2 < y1) xIntSign = -xIntSign;\n  \t\t\tif (xIntSign > 0.0) {\n  \t\t\t\tthis._crossingCount++;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tisPointInPolygon: function isPointInPolygon() {\n  \t\treturn this.getLocation() !== Location.EXTERIOR;\n  \t},\n  \tgetLocation: function getLocation() {\n  \t\tif (this._isPointOnSegment) return Location.BOUNDARY;\n  \t\tif (this._crossingCount % 2 === 1) {\n  \t\t\treturn Location.INTERIOR;\n  \t\t}\n  \t\treturn Location.EXTERIOR;\n  \t},\n  \tisOnSegment: function isOnSegment() {\n  \t\treturn this._isPointOnSegment;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn RayCrossingCounter;\n  \t}\n  });\n  RayCrossingCounter.locatePointInRing = function () {\n  \tif (arguments[0] instanceof Coordinate && hasInterface(arguments[1], CoordinateSequence)) {\n  \t\tvar p = arguments[0],\n  \t\t    ring = arguments[1];\n  \t\tvar counter = new RayCrossingCounter(p);\n  \t\tvar p1 = new Coordinate();\n  \t\tvar p2 = new Coordinate();\n  \t\tfor (var i = 1; i < ring.size(); i++) {\n  \t\t\tring.getCoordinate(i, p1);\n  \t\t\tring.getCoordinate(i - 1, p2);\n  \t\t\tcounter.countSegment(p1, p2);\n  \t\t\tif (counter.isOnSegment()) return counter.getLocation();\n  \t\t}\n  \t\treturn counter.getLocation();\n  \t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Array) {\n  \t\tvar p = arguments[0],\n  \t\t    ring = arguments[1];\n  \t\tvar counter = new RayCrossingCounter(p);\n  \t\tfor (var i = 1; i < ring.length; i++) {\n  \t\t\tvar p1 = ring[i];\n  \t\t\tvar p2 = ring[i - 1];\n  \t\t\tcounter.countSegment(p1, p2);\n  \t\t\tif (counter.isOnSegment()) return counter.getLocation();\n  \t\t}\n  \t\treturn counter.getLocation();\n  \t}\n  };\n\n  function CGAlgorithms() {}\n  extend(CGAlgorithms.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn CGAlgorithms;\n  \t}\n  });\n  CGAlgorithms.orientationIndex = function (p1, p2, q) {\n  \treturn CGAlgorithmsDD.orientationIndex(p1, p2, q);\n  };\n  CGAlgorithms.signedArea = function () {\n  \tif (arguments[0] instanceof Array) {\n  \t\tvar ring = arguments[0];\n  \t\tif (ring.length < 3) return 0.0;\n  \t\tvar sum = 0.0;\n  \t\tvar x0 = ring[0].x;\n  \t\tfor (var i = 1; i < ring.length - 1; i++) {\n  \t\t\tvar x = ring[i].x - x0;\n  \t\t\tvar y1 = ring[i + 1].y;\n  \t\t\tvar y2 = ring[i - 1].y;\n  \t\t\tsum += x * (y2 - y1);\n  \t\t}\n  \t\treturn sum / 2.0;\n  \t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n  \t\tvar ring = arguments[0];\n  \t\tvar n = ring.size();\n  \t\tif (n < 3) return 0.0;\n  \t\tvar p0 = new Coordinate();\n  \t\tvar p1 = new Coordinate();\n  \t\tvar p2 = new Coordinate();\n  \t\tring.getCoordinate(0, p1);\n  \t\tring.getCoordinate(1, p2);\n  \t\tvar x0 = p1.x;\n  \t\tp2.x -= x0;\n  \t\tvar sum = 0.0;\n  \t\tfor (var i = 1; i < n - 1; i++) {\n  \t\t\tp0.y = p1.y;\n  \t\t\tp1.x = p2.x;\n  \t\t\tp1.y = p2.y;\n  \t\t\tring.getCoordinate(i + 1, p2);\n  \t\t\tp2.x -= x0;\n  \t\t\tsum += p1.x * (p0.y - p2.y);\n  \t\t}\n  \t\treturn sum / 2.0;\n  \t}\n  };\n  CGAlgorithms.distanceLineLine = function (A, B, C, D) {\n  \tif (A.equals(B)) return CGAlgorithms.distancePointLine(A, C, D);\n  \tif (C.equals(D)) return CGAlgorithms.distancePointLine(D, A, B);\n  \tvar noIntersection = false;\n  \tif (!Envelope.intersects(A, B, C, D)) {\n  \t\tnoIntersection = true;\n  \t} else {\n  \t\tvar denom = (B.x - A.x) * (D.y - C.y) - (B.y - A.y) * (D.x - C.x);\n  \t\tif (denom === 0) {\n  \t\t\tnoIntersection = true;\n  \t\t} else {\n  \t\t\tvar r_num = (A.y - C.y) * (D.x - C.x) - (A.x - C.x) * (D.y - C.y);\n  \t\t\tvar s_num = (A.y - C.y) * (B.x - A.x) - (A.x - C.x) * (B.y - A.y);\n  \t\t\tvar s = s_num / denom;\n  \t\t\tvar r = r_num / denom;\n  \t\t\tif (r < 0 || r > 1 || s < 0 || s > 1) {\n  \t\t\t\tnoIntersection = true;\n  \t\t\t}\n  \t\t}\n  \t}\n  \tif (noIntersection) {\n  \t\treturn MathUtil.min(CGAlgorithms.distancePointLine(A, C, D), CGAlgorithms.distancePointLine(B, C, D), CGAlgorithms.distancePointLine(C, A, B), CGAlgorithms.distancePointLine(D, A, B));\n  \t}\n  \treturn 0.0;\n  };\n  CGAlgorithms.isPointInRing = function (p, ring) {\n  \treturn CGAlgorithms.locatePointInRing(p, ring) !== Location.EXTERIOR;\n  };\n  CGAlgorithms.computeLength = function (pts) {\n  \tvar n = pts.size();\n  \tif (n <= 1) return 0.0;\n  \tvar len = 0.0;\n  \tvar p = new Coordinate();\n  \tpts.getCoordinate(0, p);\n  \tvar x0 = p.x;\n  \tvar y0 = p.y;\n  \tfor (var i = 1; i < n; i++) {\n  \t\tpts.getCoordinate(i, p);\n  \t\tvar x1 = p.x;\n  \t\tvar y1 = p.y;\n  \t\tvar dx = x1 - x0;\n  \t\tvar dy = y1 - y0;\n  \t\tlen += Math.sqrt(dx * dx + dy * dy);\n  \t\tx0 = x1;\n  \t\ty0 = y1;\n  \t}\n  \treturn len;\n  };\n  CGAlgorithms.isCCW = function (ring) {\n  \tvar nPts = ring.length - 1;\n  \tif (nPts < 3) throw new IllegalArgumentException(\"Ring has fewer than 4 points, so orientation cannot be determined\");\n  \tvar hiPt = ring[0];\n  \tvar hiIndex = 0;\n  \tfor (var i = 1; i <= nPts; i++) {\n  \t\tvar p = ring[i];\n  \t\tif (p.y > hiPt.y) {\n  \t\t\thiPt = p;\n  \t\t\thiIndex = i;\n  \t\t}\n  \t}\n  \tvar iPrev = hiIndex;\n  \tdo {\n  \t\tiPrev = iPrev - 1;\n  \t\tif (iPrev < 0) iPrev = nPts;\n  \t} while (ring[iPrev].equals2D(hiPt) && iPrev !== hiIndex);\n  \tvar iNext = hiIndex;\n  \tdo {\n  \t\tiNext = (iNext + 1) % nPts;\n  \t} while (ring[iNext].equals2D(hiPt) && iNext !== hiIndex);\n  \tvar prev = ring[iPrev];\n  \tvar next = ring[iNext];\n  \tif (prev.equals2D(hiPt) || next.equals2D(hiPt) || prev.equals2D(next)) return false;\n  \tvar disc = CGAlgorithms.computeOrientation(prev, hiPt, next);\n  \tvar isCCW = false;\n  \tif (disc === 0) {\n  \t\tisCCW = prev.x > next.x;\n  \t} else {\n  \t\tisCCW = disc > 0;\n  \t}\n  \treturn isCCW;\n  };\n  CGAlgorithms.locatePointInRing = function (p, ring) {\n  \treturn RayCrossingCounter.locatePointInRing(p, ring);\n  };\n  CGAlgorithms.distancePointLinePerpendicular = function (p, A, B) {\n  \tvar len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);\n  \tvar s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;\n  \treturn Math.abs(s) * Math.sqrt(len2);\n  };\n  CGAlgorithms.computeOrientation = function (p1, p2, q) {\n  \treturn CGAlgorithms.orientationIndex(p1, p2, q);\n  };\n  CGAlgorithms.distancePointLine = function () {\n  \tif (arguments.length === 2) {\n  \t\tvar p = arguments[0],\n  \t\t    line = arguments[1];\n  \t\tif (line.length === 0) throw new IllegalArgumentException(\"Line array must contain at least one vertex\");\n  \t\tvar minDistance = p.distance(line[0]);\n  \t\tfor (var i = 0; i < line.length - 1; i++) {\n  \t\t\tvar dist = CGAlgorithms.distancePointLine(p, line[i], line[i + 1]);\n  \t\t\tif (dist < minDistance) {\n  \t\t\t\tminDistance = dist;\n  \t\t\t}\n  \t\t}\n  \t\treturn minDistance;\n  \t} else if (arguments.length === 3) {\n  \t\tvar p = arguments[0],\n  \t\t    A = arguments[1],\n  \t\t    B = arguments[2];\n  \t\tif (A.x === B.x && A.y === B.y) return p.distance(A);\n  \t\tvar len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);\n  \t\tvar r = ((p.x - A.x) * (B.x - A.x) + (p.y - A.y) * (B.y - A.y)) / len2;\n  \t\tif (r <= 0.0) return p.distance(A);\n  \t\tif (r >= 1.0) return p.distance(B);\n  \t\tvar s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;\n  \t\treturn Math.abs(s) * Math.sqrt(len2);\n  \t}\n  };\n  CGAlgorithms.isOnLine = function (p, pt) {\n  \tvar lineIntersector = new RobustLineIntersector();\n  \tfor (var i = 1; i < pt.length; i++) {\n  \t\tvar p0 = pt[i - 1];\n  \t\tvar p1 = pt[i];\n  \t\tlineIntersector.computeIntersection(p, p0, p1);\n  \t\tif (lineIntersector.hasIntersection()) {\n  \t\t\treturn true;\n  \t\t}\n  \t}\n  \treturn false;\n  };\n  CGAlgorithms.CLOCKWISE = -1;\n  CGAlgorithms.RIGHT = CGAlgorithms.CLOCKWISE;\n  CGAlgorithms.COUNTERCLOCKWISE = 1;\n  CGAlgorithms.LEFT = CGAlgorithms.COUNTERCLOCKWISE;\n  CGAlgorithms.COLLINEAR = 0;\n  CGAlgorithms.STRAIGHT = CGAlgorithms.COLLINEAR;\n\n  function LineSegment() {\n  \tthis.p0 = null;\n  \tthis.p1 = null;\n  \tif (arguments.length === 0) {\n  \t\tLineSegment.call(this, new Coordinate(), new Coordinate());\n  \t} else if (arguments.length === 1) {\n  \t\tvar ls = arguments[0];\n  \t\tLineSegment.call(this, ls.p0, ls.p1);\n  \t} else if (arguments.length === 2) {\n  \t\tvar p0 = arguments[0],\n  \t\t    p1 = arguments[1];\n  \t\tthis.p0 = p0;\n  \t\tthis.p1 = p1;\n  \t} else if (arguments.length === 4) {\n  \t\tvar x0 = arguments[0],\n  \t\t    y0 = arguments[1],\n  \t\t    x1 = arguments[2],\n  \t\t    y1 = arguments[3];\n  \t\tLineSegment.call(this, new Coordinate(x0, y0), new Coordinate(x1, y1));\n  \t}\n  }\n  extend(LineSegment.prototype, {\n  \tminX: function minX() {\n  \t\treturn Math.min(this.p0.x, this.p1.x);\n  \t},\n  \torientationIndex: function orientationIndex() {\n  \t\tif (arguments[0] instanceof LineSegment) {\n  \t\t\tvar seg = arguments[0];\n  \t\t\tvar orient0 = CGAlgorithms.orientationIndex(this.p0, this.p1, seg.p0);\n  \t\t\tvar orient1 = CGAlgorithms.orientationIndex(this.p0, this.p1, seg.p1);\n  \t\t\tif (orient0 >= 0 && orient1 >= 0) return Math.max(orient0, orient1);\n  \t\t\tif (orient0 <= 0 && orient1 <= 0) return Math.max(orient0, orient1);\n  \t\t\treturn 0;\n  \t\t} else if (arguments[0] instanceof Coordinate) {\n  \t\t\tvar p = arguments[0];\n  \t\t\treturn CGAlgorithms.orientationIndex(this.p0, this.p1, p);\n  \t\t}\n  \t},\n  \ttoGeometry: function toGeometry(geomFactory) {\n  \t\treturn geomFactory.createLineString([this.p0, this.p1]);\n  \t},\n  \tisVertical: function isVertical() {\n  \t\treturn this.p0.x === this.p1.x;\n  \t},\n  \tequals: function equals(o) {\n  \t\tif (!(o instanceof LineSegment)) {\n  \t\t\treturn false;\n  \t\t}\n  \t\tvar other = o;\n  \t\treturn this.p0.equals(other.p0) && this.p1.equals(other.p1);\n  \t},\n  \tintersection: function intersection(line) {\n  \t\tvar li = new RobustLineIntersector();\n  \t\tli.computeIntersection(this.p0, this.p1, line.p0, line.p1);\n  \t\tif (li.hasIntersection()) return li.getIntersection(0);\n  \t\treturn null;\n  \t},\n  \tproject: function project() {\n  \t\tif (arguments[0] instanceof Coordinate) {\n  \t\t\tvar p = arguments[0];\n  \t\t\tif (p.equals(this.p0) || p.equals(this.p1)) return new Coordinate(p);\n  \t\t\tvar r = this.projectionFactor(p);\n  \t\t\tvar coord = new Coordinate();\n  \t\t\tcoord.x = this.p0.x + r * (this.p1.x - this.p0.x);\n  \t\t\tcoord.y = this.p0.y + r * (this.p1.y - this.p0.y);\n  \t\t\treturn coord;\n  \t\t} else if (arguments[0] instanceof LineSegment) {\n  \t\t\tvar seg = arguments[0];\n  \t\t\tvar pf0 = this.projectionFactor(seg.p0);\n  \t\t\tvar pf1 = this.projectionFactor(seg.p1);\n  \t\t\tif (pf0 >= 1.0 && pf1 >= 1.0) return null;\n  \t\t\tif (pf0 <= 0.0 && pf1 <= 0.0) return null;\n  \t\t\tvar newp0 = this.project(seg.p0);\n  \t\t\tif (pf0 < 0.0) newp0 = this.p0;\n  \t\t\tif (pf0 > 1.0) newp0 = this.p1;\n  \t\t\tvar newp1 = this.project(seg.p1);\n  \t\t\tif (pf1 < 0.0) newp1 = this.p0;\n  \t\t\tif (pf1 > 1.0) newp1 = this.p1;\n  \t\t\treturn new LineSegment(newp0, newp1);\n  \t\t}\n  \t},\n  \tnormalize: function normalize() {\n  \t\tif (this.p1.compareTo(this.p0) < 0) this.reverse();\n  \t},\n  \tangle: function angle() {\n  \t\treturn Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);\n  \t},\n  \tgetCoordinate: function getCoordinate(i) {\n  \t\tif (i === 0) return this.p0;\n  \t\treturn this.p1;\n  \t},\n  \tdistancePerpendicular: function distancePerpendicular(p) {\n  \t\treturn CGAlgorithms.distancePointLinePerpendicular(p, this.p0, this.p1);\n  \t},\n  \tminY: function minY() {\n  \t\treturn Math.min(this.p0.y, this.p1.y);\n  \t},\n  \tmidPoint: function midPoint() {\n  \t\treturn LineSegment.midPoint(this.p0, this.p1);\n  \t},\n  \tprojectionFactor: function projectionFactor(p) {\n  \t\tif (p.equals(this.p0)) return 0.0;\n  \t\tif (p.equals(this.p1)) return 1.0;\n  \t\tvar dx = this.p1.x - this.p0.x;\n  \t\tvar dy = this.p1.y - this.p0.y;\n  \t\tvar len = dx * dx + dy * dy;\n  \t\tif (len <= 0.0) return Double.NaN;\n  \t\tvar r = ((p.x - this.p0.x) * dx + (p.y - this.p0.y) * dy) / len;\n  \t\treturn r;\n  \t},\n  \tclosestPoints: function closestPoints(line) {\n  \t\tvar intPt = this.intersection(line);\n  \t\tif (intPt !== null) {\n  \t\t\treturn [intPt, intPt];\n  \t\t}\n  \t\tvar closestPt = new Array(2).fill(null);\n  \t\tvar minDistance = Double.MAX_VALUE;\n  \t\tvar dist = null;\n  \t\tvar close00 = this.closestPoint(line.p0);\n  \t\tminDistance = close00.distance(line.p0);\n  \t\tclosestPt[0] = close00;\n  \t\tclosestPt[1] = line.p0;\n  \t\tvar close01 = this.closestPoint(line.p1);\n  \t\tdist = close01.distance(line.p1);\n  \t\tif (dist < minDistance) {\n  \t\t\tminDistance = dist;\n  \t\t\tclosestPt[0] = close01;\n  \t\t\tclosestPt[1] = line.p1;\n  \t\t}\n  \t\tvar close10 = line.closestPoint(this.p0);\n  \t\tdist = close10.distance(this.p0);\n  \t\tif (dist < minDistance) {\n  \t\t\tminDistance = dist;\n  \t\t\tclosestPt[0] = this.p0;\n  \t\t\tclosestPt[1] = close10;\n  \t\t}\n  \t\tvar close11 = line.closestPoint(this.p1);\n  \t\tdist = close11.distance(this.p1);\n  \t\tif (dist < minDistance) {\n  \t\t\tminDistance = dist;\n  \t\t\tclosestPt[0] = this.p1;\n  \t\t\tclosestPt[1] = close11;\n  \t\t}\n  \t\treturn closestPt;\n  \t},\n  \tclosestPoint: function closestPoint(p) {\n  \t\tvar factor = this.projectionFactor(p);\n  \t\tif (factor > 0 && factor < 1) {\n  \t\t\treturn this.project(p);\n  \t\t}\n  \t\tvar dist0 = this.p0.distance(p);\n  \t\tvar dist1 = this.p1.distance(p);\n  \t\tif (dist0 < dist1) return this.p0;\n  \t\treturn this.p1;\n  \t},\n  \tmaxX: function maxX() {\n  \t\treturn Math.max(this.p0.x, this.p1.x);\n  \t},\n  \tgetLength: function getLength() {\n  \t\treturn this.p0.distance(this.p1);\n  \t},\n  \tcompareTo: function compareTo(o) {\n  \t\tvar other = o;\n  \t\tvar comp0 = this.p0.compareTo(other.p0);\n  \t\tif (comp0 !== 0) return comp0;\n  \t\treturn this.p1.compareTo(other.p1);\n  \t},\n  \treverse: function reverse() {\n  \t\tvar temp = this.p0;\n  \t\tthis.p0 = this.p1;\n  \t\tthis.p1 = temp;\n  \t},\n  \tequalsTopo: function equalsTopo(other) {\n  \t\treturn this.p0.equals(other.p0) && this.p1.equals(other.p1) || this.p0.equals(other.p1) && this.p1.equals(other.p0);\n  \t},\n  \tlineIntersection: function lineIntersection(line) {\n  \t\ttry {\n  \t\t\tvar intPt = HCoordinate.intersection(this.p0, this.p1, line.p0, line.p1);\n  \t\t\treturn intPt;\n  \t\t} catch (ex) {\n  \t\t\tif (ex instanceof NotRepresentableException) ; else throw ex;\n  \t\t} finally {}\n  \t\treturn null;\n  \t},\n  \tmaxY: function maxY() {\n  \t\treturn Math.max(this.p0.y, this.p1.y);\n  \t},\n  \tpointAlongOffset: function pointAlongOffset(segmentLengthFraction, offsetDistance) {\n  \t\tvar segx = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);\n  \t\tvar segy = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);\n  \t\tvar dx = this.p1.x - this.p0.x;\n  \t\tvar dy = this.p1.y - this.p0.y;\n  \t\tvar len = Math.sqrt(dx * dx + dy * dy);\n  \t\tvar ux = 0.0;\n  \t\tvar uy = 0.0;\n  \t\tif (offsetDistance !== 0.0) {\n  \t\t\tif (len <= 0.0) throw new IllegalStateException(\"Cannot compute offset from zero-length line segment\");\n  \t\t\tux = offsetDistance * dx / len;\n  \t\t\tuy = offsetDistance * dy / len;\n  \t\t}\n  \t\tvar offsetx = segx - uy;\n  \t\tvar offsety = segy + ux;\n  \t\tvar coord = new Coordinate(offsetx, offsety);\n  \t\treturn coord;\n  \t},\n  \tsetCoordinates: function setCoordinates() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar ls = arguments[0];\n  \t\t\tthis.setCoordinates(ls.p0, ls.p1);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar p0 = arguments[0],\n  \t\t\t    p1 = arguments[1];\n  \t\t\tthis.p0.x = p0.x;\n  \t\t\tthis.p0.y = p0.y;\n  \t\t\tthis.p1.x = p1.x;\n  \t\t\tthis.p1.y = p1.y;\n  \t\t}\n  \t},\n  \tsegmentFraction: function segmentFraction(inputPt) {\n  \t\tvar segFrac = this.projectionFactor(inputPt);\n  \t\tif (segFrac < 0.0) segFrac = 0.0;else if (segFrac > 1.0 || Double.isNaN(segFrac)) segFrac = 1.0;\n  \t\treturn segFrac;\n  \t},\n  \ttoString: function toString() {\n  \t\treturn \"LINESTRING( \" + this.p0.x + \" \" + this.p0.y + \", \" + this.p1.x + \" \" + this.p1.y + \")\";\n  \t},\n  \tisHorizontal: function isHorizontal() {\n  \t\treturn this.p0.y === this.p1.y;\n  \t},\n  \tdistance: function distance() {\n  \t\tif (arguments[0] instanceof LineSegment) {\n  \t\t\tvar ls = arguments[0];\n  \t\t\treturn CGAlgorithms.distanceLineLine(this.p0, this.p1, ls.p0, ls.p1);\n  \t\t} else if (arguments[0] instanceof Coordinate) {\n  \t\t\tvar p = arguments[0];\n  \t\t\treturn CGAlgorithms.distancePointLine(p, this.p0, this.p1);\n  \t\t}\n  \t},\n  \tpointAlong: function pointAlong(segmentLengthFraction) {\n  \t\tvar coord = new Coordinate();\n  \t\tcoord.x = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);\n  \t\tcoord.y = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);\n  \t\treturn coord;\n  \t},\n  \thashCode: function hashCode() {\n  \t\tvar bits0 = java.lang.Double.doubleToLongBits(this.p0.x);\n  \t\tbits0 ^= java.lang.Double.doubleToLongBits(this.p0.y) * 31;\n  \t\tvar hash0 = Math.trunc(bits0) ^ Math.trunc(bits0 >> 32);\n  \t\tvar bits1 = java.lang.Double.doubleToLongBits(this.p1.x);\n  \t\tbits1 ^= java.lang.Double.doubleToLongBits(this.p1.y) * 31;\n  \t\tvar hash1 = Math.trunc(bits1) ^ Math.trunc(bits1 >> 32);\n  \t\treturn hash0 ^ hash1;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparable, Serializable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LineSegment;\n  \t}\n  });\n  LineSegment.midPoint = function (p0, p1) {\n  \treturn new Coordinate((p0.x + p1.x) / 2, (p0.y + p1.y) / 2);\n  };\n  LineSegment.serialVersionUID = 3252005833466256227;\n\n  function IntersectionMatrix() {\n  \tthis._matrix = null;\n  \tif (arguments.length === 0) {\n  \t\tthis._matrix = Array(3).fill().map(function () {\n  \t\t\treturn Array(3);\n  \t\t});\n  \t\tthis.setAll(Dimension.FALSE);\n  \t} else if (arguments.length === 1) {\n  \t\tif (typeof arguments[0] === \"string\") {\n  \t\t\tvar elements = arguments[0];\n  \t\t\tIntersectionMatrix.call(this);\n  \t\t\tthis.set(elements);\n  \t\t} else if (arguments[0] instanceof IntersectionMatrix) {\n  \t\t\tvar other = arguments[0];\n  \t\t\tIntersectionMatrix.call(this);\n  \t\t\tthis._matrix[Location.INTERIOR][Location.INTERIOR] = other._matrix[Location.INTERIOR][Location.INTERIOR];\n  \t\t\tthis._matrix[Location.INTERIOR][Location.BOUNDARY] = other._matrix[Location.INTERIOR][Location.BOUNDARY];\n  \t\t\tthis._matrix[Location.INTERIOR][Location.EXTERIOR] = other._matrix[Location.INTERIOR][Location.EXTERIOR];\n  \t\t\tthis._matrix[Location.BOUNDARY][Location.INTERIOR] = other._matrix[Location.BOUNDARY][Location.INTERIOR];\n  \t\t\tthis._matrix[Location.BOUNDARY][Location.BOUNDARY] = other._matrix[Location.BOUNDARY][Location.BOUNDARY];\n  \t\t\tthis._matrix[Location.BOUNDARY][Location.EXTERIOR] = other._matrix[Location.BOUNDARY][Location.EXTERIOR];\n  \t\t\tthis._matrix[Location.EXTERIOR][Location.INTERIOR] = other._matrix[Location.EXTERIOR][Location.INTERIOR];\n  \t\t\tthis._matrix[Location.EXTERIOR][Location.BOUNDARY] = other._matrix[Location.EXTERIOR][Location.BOUNDARY];\n  \t\t\tthis._matrix[Location.EXTERIOR][Location.EXTERIOR] = other._matrix[Location.EXTERIOR][Location.EXTERIOR];\n  \t\t}\n  \t}\n  }\n  extend(IntersectionMatrix.prototype, {\n  \tisIntersects: function isIntersects() {\n  \t\treturn !this.isDisjoint();\n  \t},\n  \tisCovers: function isCovers() {\n  \t\tvar hasPointInCommon = IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY]);\n  \t\treturn hasPointInCommon && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE;\n  \t},\n  \tisCoveredBy: function isCoveredBy() {\n  \t\tvar hasPointInCommon = IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY]);\n  \t\treturn hasPointInCommon && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE;\n  \t},\n  \tset: function set() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar dimensionSymbols = arguments[0];\n  \t\t\tfor (var i = 0; i < dimensionSymbols.length; i++) {\n  \t\t\t\tvar row = Math.trunc(i / 3);\n  \t\t\t\tvar col = i % 3;\n  \t\t\t\tthis._matrix[row][col] = Dimension.toDimensionValue(dimensionSymbols.charAt(i));\n  \t\t\t}\n  \t\t} else if (arguments.length === 3) {\n  \t\t\tvar row = arguments[0],\n  \t\t\t    column = arguments[1],\n  \t\t\t    dimensionValue = arguments[2];\n  \t\t\tthis._matrix[row][column] = dimensionValue;\n  \t\t}\n  \t},\n  \tisContains: function isContains() {\n  \t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE;\n  \t},\n  \tsetAtLeast: function setAtLeast() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar minimumDimensionSymbols = arguments[0];\n  \t\t\tfor (var i = 0; i < minimumDimensionSymbols.length; i++) {\n  \t\t\t\tvar row = Math.trunc(i / 3);\n  \t\t\t\tvar col = i % 3;\n  \t\t\t\tthis.setAtLeast(row, col, Dimension.toDimensionValue(minimumDimensionSymbols.charAt(i)));\n  \t\t\t}\n  \t\t} else if (arguments.length === 3) {\n  \t\t\tvar row = arguments[0],\n  \t\t\t    column = arguments[1],\n  \t\t\t    minimumDimensionValue = arguments[2];\n  \t\t\tif (this._matrix[row][column] < minimumDimensionValue) {\n  \t\t\t\tthis._matrix[row][column] = minimumDimensionValue;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tsetAtLeastIfValid: function setAtLeastIfValid(row, column, minimumDimensionValue) {\n  \t\tif (row >= 0 && column >= 0) {\n  \t\t\tthis.setAtLeast(row, column, minimumDimensionValue);\n  \t\t}\n  \t},\n  \tisWithin: function isWithin() {\n  \t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE;\n  \t},\n  \tisTouches: function isTouches(dimensionOfGeometryA, dimensionOfGeometryB) {\n  \t\tif (dimensionOfGeometryA > dimensionOfGeometryB) {\n  \t\t\treturn this.isTouches(dimensionOfGeometryB, dimensionOfGeometryA);\n  \t\t}\n  \t\tif (dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.L) {\n  \t\t\treturn this._matrix[Location.INTERIOR][Location.INTERIOR] === Dimension.FALSE && (IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY]));\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tisOverlaps: function isOverlaps(dimensionOfGeometryA, dimensionOfGeometryB) {\n  \t\tif (dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.A) {\n  \t\t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR]);\n  \t\t}\n  \t\tif (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L) {\n  \t\t\treturn this._matrix[Location.INTERIOR][Location.INTERIOR] === 1 && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR]);\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tisEquals: function isEquals(dimensionOfGeometryA, dimensionOfGeometryB) {\n  \t\tif (dimensionOfGeometryA !== dimensionOfGeometryB) {\n  \t\t\treturn false;\n  \t\t}\n  \t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE;\n  \t},\n  \ttoString: function toString() {\n  \t\tvar buf = new StringBuffer(\"123456789\");\n  \t\tfor (var ai = 0; ai < 3; ai++) {\n  \t\t\tfor (var bi = 0; bi < 3; bi++) {\n  \t\t\t\tbuf.setCharAt(3 * ai + bi, Dimension.toDimensionSymbol(this._matrix[ai][bi]));\n  \t\t\t}\n  \t\t}\n  \t\treturn buf.toString();\n  \t},\n  \tsetAll: function setAll(dimensionValue) {\n  \t\tfor (var ai = 0; ai < 3; ai++) {\n  \t\t\tfor (var bi = 0; bi < 3; bi++) {\n  \t\t\t\tthis._matrix[ai][bi] = dimensionValue;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tget: function get(row, column) {\n  \t\treturn this._matrix[row][column];\n  \t},\n  \ttranspose: function transpose() {\n  \t\tvar temp = this._matrix[1][0];\n  \t\tthis._matrix[1][0] = this._matrix[0][1];\n  \t\tthis._matrix[0][1] = temp;\n  \t\ttemp = this._matrix[2][0];\n  \t\tthis._matrix[2][0] = this._matrix[0][2];\n  \t\tthis._matrix[0][2] = temp;\n  \t\ttemp = this._matrix[2][1];\n  \t\tthis._matrix[2][1] = this._matrix[1][2];\n  \t\tthis._matrix[1][2] = temp;\n  \t\treturn this;\n  \t},\n  \tmatches: function matches(requiredDimensionSymbols) {\n  \t\tif (requiredDimensionSymbols.length !== 9) {\n  \t\t\tthrow new IllegalArgumentException(\"Should be length 9: \" + requiredDimensionSymbols);\n  \t\t}\n  \t\tfor (var ai = 0; ai < 3; ai++) {\n  \t\t\tfor (var bi = 0; bi < 3; bi++) {\n  \t\t\t\tif (!IntersectionMatrix.matches(this._matrix[ai][bi], requiredDimensionSymbols.charAt(3 * ai + bi))) {\n  \t\t\t\t\treturn false;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\treturn true;\n  \t},\n  \tadd: function add(im) {\n  \t\tfor (var i = 0; i < 3; i++) {\n  \t\t\tfor (var j = 0; j < 3; j++) {\n  \t\t\t\tthis.setAtLeast(i, j, im.get(i, j));\n  \t\t\t}\n  \t\t}\n  \t},\n  \tisDisjoint: function isDisjoint() {\n  \t\treturn this._matrix[Location.INTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.INTERIOR][Location.BOUNDARY] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.BOUNDARY] === Dimension.FALSE;\n  \t},\n  \tisCrosses: function isCrosses(dimensionOfGeometryA, dimensionOfGeometryB) {\n  \t\tif (dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.L || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.A) {\n  \t\t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR]);\n  \t\t}\n  \t\tif (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.L) {\n  \t\t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR]);\n  \t\t}\n  \t\tif (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L) {\n  \t\t\treturn this._matrix[Location.INTERIOR][Location.INTERIOR] === 0;\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Clonable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn IntersectionMatrix;\n  \t}\n  });\n  IntersectionMatrix.matches = function () {\n  \tif (Number.isInteger(arguments[0]) && typeof arguments[1] === \"string\") {\n  \t\tvar actualDimensionValue = arguments[0],\n  \t\t    requiredDimensionSymbol = arguments[1];\n  \t\tif (requiredDimensionSymbol === Dimension.SYM_DONTCARE) {\n  \t\t\treturn true;\n  \t\t}\n  \t\tif (requiredDimensionSymbol === Dimension.SYM_TRUE && (actualDimensionValue >= 0 || actualDimensionValue === Dimension.TRUE)) {\n  \t\t\treturn true;\n  \t\t}\n  \t\tif (requiredDimensionSymbol === Dimension.SYM_FALSE && actualDimensionValue === Dimension.FALSE) {\n  \t\t\treturn true;\n  \t\t}\n  \t\tif (requiredDimensionSymbol === Dimension.SYM_P && actualDimensionValue === Dimension.P) {\n  \t\t\treturn true;\n  \t\t}\n  \t\tif (requiredDimensionSymbol === Dimension.SYM_L && actualDimensionValue === Dimension.L) {\n  \t\t\treturn true;\n  \t\t}\n  \t\tif (requiredDimensionSymbol === Dimension.SYM_A && actualDimensionValue === Dimension.A) {\n  \t\t\treturn true;\n  \t\t}\n  \t\treturn false;\n  \t} else if (typeof arguments[0] === \"string\" && typeof arguments[1] === \"string\") {\n  \t\tvar actualDimensionSymbols = arguments[0],\n  \t\t    requiredDimensionSymbols = arguments[1];\n  \t\tvar m = new IntersectionMatrix(actualDimensionSymbols);\n  \t\treturn m.matches(requiredDimensionSymbols);\n  \t}\n  };\n  IntersectionMatrix.isTrue = function (actualDimensionValue) {\n  \tif (actualDimensionValue >= 0 || actualDimensionValue === Dimension.TRUE) {\n  \t\treturn true;\n  \t}\n  \treturn false;\n  };\n\n  function Centroid() {\n  \tthis._areaBasePt = null;\n  \tthis._triangleCent3 = new Coordinate();\n  \tthis._areasum2 = 0;\n  \tthis._cg3 = new Coordinate();\n  \tthis._lineCentSum = new Coordinate();\n  \tthis._totalLength = 0.0;\n  \tthis._ptCount = 0;\n  \tthis._ptCentSum = new Coordinate();\n  \tvar geom = arguments[0];\n  \tthis._areaBasePt = null;\n  \tthis.add(geom);\n  }\n  extend(Centroid.prototype, {\n  \taddPoint: function addPoint(pt) {\n  \t\tthis._ptCount += 1;\n  \t\tthis._ptCentSum.x += pt.x;\n  \t\tthis._ptCentSum.y += pt.y;\n  \t},\n  \tsetBasePoint: function setBasePoint(basePt) {\n  \t\tif (this._areaBasePt === null) this._areaBasePt = basePt;\n  \t},\n  \taddLineSegments: function addLineSegments(pts) {\n  \t\tvar lineLen = 0.0;\n  \t\tfor (var i = 0; i < pts.length - 1; i++) {\n  \t\t\tvar segmentLen = pts[i].distance(pts[i + 1]);\n  \t\t\tif (segmentLen === 0.0) continue;\n  \t\t\tlineLen += segmentLen;\n  \t\t\tvar midx = (pts[i].x + pts[i + 1].x) / 2;\n  \t\t\tthis._lineCentSum.x += segmentLen * midx;\n  \t\t\tvar midy = (pts[i].y + pts[i + 1].y) / 2;\n  \t\t\tthis._lineCentSum.y += segmentLen * midy;\n  \t\t}\n  \t\tthis._totalLength += lineLen;\n  \t\tif (lineLen === 0.0 && pts.length > 0) this.addPoint(pts[0]);\n  \t},\n  \taddHole: function addHole(pts) {\n  \t\tvar isPositiveArea = CGAlgorithms.isCCW(pts);\n  \t\tfor (var i = 0; i < pts.length - 1; i++) {\n  \t\t\tthis.addTriangle(this._areaBasePt, pts[i], pts[i + 1], isPositiveArea);\n  \t\t}\n  \t\tthis.addLineSegments(pts);\n  \t},\n  \tgetCentroid: function getCentroid() {\n  \t\tvar cent = new Coordinate();\n  \t\tif (Math.abs(this._areasum2) > 0.0) {\n  \t\t\tcent.x = this._cg3.x / 3 / this._areasum2;\n  \t\t\tcent.y = this._cg3.y / 3 / this._areasum2;\n  \t\t} else if (this._totalLength > 0.0) {\n  \t\t\tcent.x = this._lineCentSum.x / this._totalLength;\n  \t\t\tcent.y = this._lineCentSum.y / this._totalLength;\n  \t\t} else if (this._ptCount > 0) {\n  \t\t\tcent.x = this._ptCentSum.x / this._ptCount;\n  \t\t\tcent.y = this._ptCentSum.y / this._ptCount;\n  \t\t} else {\n  \t\t\treturn null;\n  \t\t}\n  \t\treturn cent;\n  \t},\n  \taddShell: function addShell(pts) {\n  \t\tif (pts.length > 0) this.setBasePoint(pts[0]);\n  \t\tvar isPositiveArea = !CGAlgorithms.isCCW(pts);\n  \t\tfor (var i = 0; i < pts.length - 1; i++) {\n  \t\t\tthis.addTriangle(this._areaBasePt, pts[i], pts[i + 1], isPositiveArea);\n  \t\t}\n  \t\tthis.addLineSegments(pts);\n  \t},\n  \taddTriangle: function addTriangle(p0, p1, p2, isPositiveArea) {\n  \t\tvar sign = isPositiveArea ? 1.0 : -1.0;\n  \t\tCentroid.centroid3(p0, p1, p2, this._triangleCent3);\n  \t\tvar area2 = Centroid.area2(p0, p1, p2);\n  \t\tthis._cg3.x += sign * area2 * this._triangleCent3.x;\n  \t\tthis._cg3.y += sign * area2 * this._triangleCent3.y;\n  \t\tthis._areasum2 += sign * area2;\n  \t},\n  \tadd: function add() {\n  \t\tif (arguments[0] instanceof Polygon) {\n  \t\t\tvar poly = arguments[0];\n  \t\t\tthis.addShell(poly.getExteriorRing().getCoordinates());\n  \t\t\tfor (var i = 0; i < poly.getNumInteriorRing(); i++) {\n  \t\t\t\tthis.addHole(poly.getInteriorRingN(i).getCoordinates());\n  \t\t\t}\n  \t\t} else if (arguments[0] instanceof Geometry) {\n  \t\t\tvar geom = arguments[0];\n  \t\t\tif (geom.isEmpty()) return null;\n  \t\t\tif (geom instanceof Point) {\n  \t\t\t\tthis.addPoint(geom.getCoordinate());\n  \t\t\t} else if (geom instanceof LineString) {\n  \t\t\t\tthis.addLineSegments(geom.getCoordinates());\n  \t\t\t} else if (geom instanceof Polygon) {\n  \t\t\t\tvar poly = geom;\n  \t\t\t\tthis.add(poly);\n  \t\t\t} else if (geom instanceof GeometryCollection) {\n  \t\t\t\tvar gc = geom;\n  \t\t\t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n  \t\t\t\t\tthis.add(gc.getGeometryN(i));\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Centroid;\n  \t}\n  });\n  Centroid.area2 = function (p1, p2, p3) {\n  \treturn (p2.x - p1.x) * (p3.y - p1.y) - (p3.x - p1.x) * (p2.y - p1.y);\n  };\n  Centroid.centroid3 = function (p1, p2, p3, c) {\n  \tc.x = p1.x + p2.x + p3.x;\n  \tc.y = p1.y + p2.y + p3.y;\n  \treturn null;\n  };\n  Centroid.getCentroid = function (geom) {\n  \tvar cent = new Centroid(geom);\n  \treturn cent.getCentroid();\n  };\n\n  function EmptyStackException(message) {\n    this.message = message || '';\n  }EmptyStackException.prototype = new Error();\n  EmptyStackException.prototype.name = 'EmptyStackException';\n\n  function Stack$1() {\n    this.array_ = [];\n  }Stack$1.prototype = new List();\n  Stack$1.prototype.add = function (e) {\n    this.array_.push(e);\n    return true;\n  };\n  Stack$1.prototype.get = function (index) {\n    if (index < 0 || index >= this.size()) {\n      throw new IndexOutOfBoundsException();\n    }\n    return this.array_[index];\n  };\n  Stack$1.prototype.push = function (e) {\n    this.array_.push(e);\n    return e;\n  };\n  Stack$1.prototype.pop = function (e) {\n    if (this.array_.length === 0) {\n      throw new EmptyStackException();\n    }\n    return this.array_.pop();\n  };\n  Stack$1.prototype.peek = function () {\n    if (this.array_.length === 0) {\n      throw new EmptyStackException();\n    }\n    return this.array_[this.array_.length - 1];\n  };\n  Stack$1.prototype.empty = function () {\n    if (this.array_.length === 0) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  Stack$1.prototype.isEmpty = function () {\n    return this.empty();\n  };\n  Stack$1.prototype.search = function (o) {\n    return this.array_.indexOf(o);\n  };\n  Stack$1.prototype.size = function () {\n    return this.array_.length;\n  };\n  Stack$1.prototype.toArray = function () {\n    var array = [];\n    for (var i = 0, len = this.array_.length; i < len; i++) {\n      array.push(this.array_[i]);\n    }\n    return array;\n  };\n\n  function UniqueCoordinateArrayFilter() {\n  \tthis.treeSet = new TreeSet();\n  \tthis.list = new ArrayList();\n  }\n  extend(UniqueCoordinateArrayFilter.prototype, {\n  \tfilter: function filter(coord) {\n  \t\tif (!this.treeSet.contains(coord)) {\n  \t\t\tthis.list.add(coord);\n  \t\t\tthis.treeSet.add(coord);\n  \t\t}\n  \t},\n  \tgetCoordinates: function getCoordinates() {\n  \t\tvar coordinates = new Array(this.list.size()).fill(null);\n  \t\treturn this.list.toArray(coordinates);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [CoordinateFilter];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn UniqueCoordinateArrayFilter;\n  \t}\n  });\n  UniqueCoordinateArrayFilter.filterCoordinates = function (coords) {\n  \tvar filter = new UniqueCoordinateArrayFilter();\n  \tfor (var i = 0; i < coords.length; i++) {\n  \t\tfilter.filter(coords[i]);\n  \t}\n  \treturn filter.getCoordinates();\n  };\n\n  function ConvexHull() {\n  \tthis._geomFactory = null;\n  \tthis._inputPts = null;\n  \tif (arguments.length === 1) {\n  \t\tvar geometry = arguments[0];\n  \t\tConvexHull.call(this, ConvexHull.extractCoordinates(geometry), geometry.getFactory());\n  \t} else if (arguments.length === 2) {\n  \t\tvar pts = arguments[0],\n  \t\t    geomFactory = arguments[1];\n  \t\tthis._inputPts = UniqueCoordinateArrayFilter.filterCoordinates(pts);\n  \t\tthis._geomFactory = geomFactory;\n  \t}\n  }\n  extend(ConvexHull.prototype, {\n  \tpreSort: function preSort(pts) {\n  \t\tvar t = null;\n  \t\tfor (var i = 1; i < pts.length; i++) {\n  \t\t\tif (pts[i].y < pts[0].y || pts[i].y === pts[0].y && pts[i].x < pts[0].x) {\n  \t\t\t\tt = pts[0];\n  \t\t\t\tpts[0] = pts[i];\n  \t\t\t\tpts[i] = t;\n  \t\t\t}\n  \t\t}\n  \t\tArrays.sort(pts, 1, pts.length, new RadialComparator(pts[0]));\n  \t\treturn pts;\n  \t},\n  \tcomputeOctRing: function computeOctRing(inputPts) {\n  \t\tvar octPts = this.computeOctPts(inputPts);\n  \t\tvar coordList = new CoordinateList();\n  \t\tcoordList.add(octPts, false);\n  \t\tif (coordList.size() < 3) {\n  \t\t\treturn null;\n  \t\t}\n  \t\tcoordList.closeRing();\n  \t\treturn coordList.toCoordinateArray();\n  \t},\n  \tlineOrPolygon: function lineOrPolygon(coordinates) {\n  \t\tcoordinates = this.cleanRing(coordinates);\n  \t\tif (coordinates.length === 3) {\n  \t\t\treturn this._geomFactory.createLineString([coordinates[0], coordinates[1]]);\n  \t\t}\n  \t\tvar linearRing = this._geomFactory.createLinearRing(coordinates);\n  \t\treturn this._geomFactory.createPolygon(linearRing, null);\n  \t},\n  \tcleanRing: function cleanRing(original) {\n  \t\tAssert.equals(original[0], original[original.length - 1]);\n  \t\tvar cleanedRing = new ArrayList();\n  \t\tvar previousDistinctCoordinate = null;\n  \t\tfor (var i = 0; i <= original.length - 2; i++) {\n  \t\t\tvar currentCoordinate = original[i];\n  \t\t\tvar nextCoordinate = original[i + 1];\n  \t\t\tif (currentCoordinate.equals(nextCoordinate)) {\n  \t\t\t\tcontinue;\n  \t\t\t}\n  \t\t\tif (previousDistinctCoordinate !== null && this.isBetween(previousDistinctCoordinate, currentCoordinate, nextCoordinate)) {\n  \t\t\t\tcontinue;\n  \t\t\t}\n  \t\t\tcleanedRing.add(currentCoordinate);\n  \t\t\tpreviousDistinctCoordinate = currentCoordinate;\n  \t\t}\n  \t\tcleanedRing.add(original[original.length - 1]);\n  \t\tvar cleanedRingCoordinates = new Array(cleanedRing.size()).fill(null);\n  \t\treturn cleanedRing.toArray(cleanedRingCoordinates);\n  \t},\n  \tisBetween: function isBetween(c1, c2, c3) {\n  \t\tif (CGAlgorithms.computeOrientation(c1, c2, c3) !== 0) {\n  \t\t\treturn false;\n  \t\t}\n  \t\tif (c1.x !== c3.x) {\n  \t\t\tif (c1.x <= c2.x && c2.x <= c3.x) {\n  \t\t\t\treturn true;\n  \t\t\t}\n  \t\t\tif (c3.x <= c2.x && c2.x <= c1.x) {\n  \t\t\t\treturn true;\n  \t\t\t}\n  \t\t}\n  \t\tif (c1.y !== c3.y) {\n  \t\t\tif (c1.y <= c2.y && c2.y <= c3.y) {\n  \t\t\t\treturn true;\n  \t\t\t}\n  \t\t\tif (c3.y <= c2.y && c2.y <= c1.y) {\n  \t\t\t\treturn true;\n  \t\t\t}\n  \t\t}\n  \t\treturn false;\n  \t},\n  \treduce: function reduce(inputPts) {\n  \t\tvar polyPts = this.computeOctRing(inputPts);\n  \t\tif (polyPts === null) return inputPts;\n  \t\tvar reducedSet = new TreeSet();\n  \t\tfor (var i = 0; i < polyPts.length; i++) {\n  \t\t\treducedSet.add(polyPts[i]);\n  \t\t}\n  \t\tfor (var i = 0; i < inputPts.length; i++) {\n  \t\t\tif (!CGAlgorithms.isPointInRing(inputPts[i], polyPts)) {\n  \t\t\t\treducedSet.add(inputPts[i]);\n  \t\t\t}\n  \t\t}\n  \t\tvar reducedPts = CoordinateArrays.toCoordinateArray(reducedSet);\n  \t\tif (reducedPts.length < 3) return this.padArray3(reducedPts);\n  \t\treturn reducedPts;\n  \t},\n  \tgetConvexHull: function getConvexHull() {\n  \t\tif (this._inputPts.length === 0) {\n  \t\t\treturn this._geomFactory.createGeometryCollection(null);\n  \t\t}\n  \t\tif (this._inputPts.length === 1) {\n  \t\t\treturn this._geomFactory.createPoint(this._inputPts[0]);\n  \t\t}\n  \t\tif (this._inputPts.length === 2) {\n  \t\t\treturn this._geomFactory.createLineString(this._inputPts);\n  \t\t}\n  \t\tvar reducedPts = this._inputPts;\n  \t\tif (this._inputPts.length > 50) {\n  \t\t\treducedPts = this.reduce(this._inputPts);\n  \t\t}\n  \t\tvar sortedPts = this.preSort(reducedPts);\n  \t\tvar cHS = this.grahamScan(sortedPts);\n  \t\tvar cH = this.toCoordinateArray(cHS);\n  \t\treturn this.lineOrPolygon(cH);\n  \t},\n  \tpadArray3: function padArray3(pts) {\n  \t\tvar pad = new Array(3).fill(null);\n  \t\tfor (var i = 0; i < pad.length; i++) {\n  \t\t\tif (i < pts.length) {\n  \t\t\t\tpad[i] = pts[i];\n  \t\t\t} else pad[i] = pts[0];\n  \t\t}\n  \t\treturn pad;\n  \t},\n  \tcomputeOctPts: function computeOctPts(inputPts) {\n  \t\tvar pts = new Array(8).fill(null);\n  \t\tfor (var j = 0; j < pts.length; j++) {\n  \t\t\tpts[j] = inputPts[0];\n  \t\t}\n  \t\tfor (var i = 1; i < inputPts.length; i++) {\n  \t\t\tif (inputPts[i].x < pts[0].x) {\n  \t\t\t\tpts[0] = inputPts[i];\n  \t\t\t}\n  \t\t\tif (inputPts[i].x - inputPts[i].y < pts[1].x - pts[1].y) {\n  \t\t\t\tpts[1] = inputPts[i];\n  \t\t\t}\n  \t\t\tif (inputPts[i].y > pts[2].y) {\n  \t\t\t\tpts[2] = inputPts[i];\n  \t\t\t}\n  \t\t\tif (inputPts[i].x + inputPts[i].y > pts[3].x + pts[3].y) {\n  \t\t\t\tpts[3] = inputPts[i];\n  \t\t\t}\n  \t\t\tif (inputPts[i].x > pts[4].x) {\n  \t\t\t\tpts[4] = inputPts[i];\n  \t\t\t}\n  \t\t\tif (inputPts[i].x - inputPts[i].y > pts[5].x - pts[5].y) {\n  \t\t\t\tpts[5] = inputPts[i];\n  \t\t\t}\n  \t\t\tif (inputPts[i].y < pts[6].y) {\n  \t\t\t\tpts[6] = inputPts[i];\n  \t\t\t}\n  \t\t\tif (inputPts[i].x + inputPts[i].y < pts[7].x + pts[7].y) {\n  \t\t\t\tpts[7] = inputPts[i];\n  \t\t\t}\n  \t\t}\n  \t\treturn pts;\n  \t},\n  \ttoCoordinateArray: function toCoordinateArray(stack) {\n  \t\tvar coordinates = new Array(stack.size()).fill(null);\n  \t\tfor (var i = 0; i < stack.size(); i++) {\n  \t\t\tvar coordinate = stack.get(i);\n  \t\t\tcoordinates[i] = coordinate;\n  \t\t}\n  \t\treturn coordinates;\n  \t},\n  \tgrahamScan: function grahamScan(c) {\n  \t\tvar p = null;\n  \t\tvar ps = new Stack$1();\n  \t\tp = ps.push(c[0]);\n  \t\tp = ps.push(c[1]);\n  \t\tp = ps.push(c[2]);\n  \t\tfor (var i = 3; i < c.length; i++) {\n  \t\t\tp = ps.pop();\n  \t\t\twhile (!ps.empty() && CGAlgorithms.computeOrientation(ps.peek(), p, c[i]) > 0) {\n  \t\t\t\tp = ps.pop();\n  \t\t\t}\n  \t\t\tp = ps.push(p);\n  \t\t\tp = ps.push(c[i]);\n  \t\t}\n  \t\tp = ps.push(c[0]);\n  \t\treturn ps;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn ConvexHull;\n  \t}\n  });\n  ConvexHull.extractCoordinates = function (geom) {\n  \tvar filter = new UniqueCoordinateArrayFilter();\n  \tgeom.apply(filter);\n  \treturn filter.getCoordinates();\n  };\n  function RadialComparator() {\n  \tthis._origin = null;\n  \tvar origin = arguments[0];\n  \tthis._origin = origin;\n  }\n  extend(RadialComparator.prototype, {\n  \tcompare: function compare(o1, o2) {\n  \t\tvar p1 = o1;\n  \t\tvar p2 = o2;\n  \t\treturn RadialComparator.polarCompare(this._origin, p1, p2);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparator];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn RadialComparator;\n  \t}\n  });\n  RadialComparator.polarCompare = function (o, p, q) {\n  \tvar dxp = p.x - o.x;\n  \tvar dyp = p.y - o.y;\n  \tvar dxq = q.x - o.x;\n  \tvar dyq = q.y - o.y;\n  \tvar orient = CGAlgorithms.computeOrientation(o, p, q);\n  \tif (orient === CGAlgorithms.COUNTERCLOCKWISE) return 1;\n  \tif (orient === CGAlgorithms.CLOCKWISE) return -1;\n  \tvar op = dxp * dxp + dyp * dyp;\n  \tvar oq = dxq * dxq + dyq * dyq;\n  \tif (op < oq) {\n  \t\treturn -1;\n  \t}\n  \tif (op > oq) {\n  \t\treturn 1;\n  \t}\n  \treturn 0;\n  };\n  ConvexHull.RadialComparator = RadialComparator;\n\n  function GeometryTransformer() {\n  \tthis._inputGeom = null;\n  \tthis._factory = null;\n  \tthis._pruneEmptyGeometry = true;\n  \tthis._preserveGeometryCollectionType = true;\n  \tthis._preserveCollections = false;\n  \tthis._preserveType = false;\n  }\n  extend(GeometryTransformer.prototype, {\n  \ttransformPoint: function transformPoint(geom, parent) {\n  \t\treturn this._factory.createPoint(this.transformCoordinates(geom.getCoordinateSequence(), geom));\n  \t},\n  \ttransformPolygon: function transformPolygon(geom, parent) {\n  \t\tvar isAllValidLinearRings = true;\n  \t\tvar shell = this.transformLinearRing(geom.getExteriorRing(), geom);\n  \t\tif (shell === null || !(shell instanceof LinearRing) || shell.isEmpty()) isAllValidLinearRings = false;\n  \t\tvar holes = new ArrayList();\n  \t\tfor (var i = 0; i < geom.getNumInteriorRing(); i++) {\n  \t\t\tvar hole = this.transformLinearRing(geom.getInteriorRingN(i), geom);\n  \t\t\tif (hole === null || hole.isEmpty()) {\n  \t\t\t\tcontinue;\n  \t\t\t}\n  \t\t\tif (!(hole instanceof LinearRing)) isAllValidLinearRings = false;\n  \t\t\tholes.add(hole);\n  \t\t}\n  \t\tif (isAllValidLinearRings) return this._factory.createPolygon(shell, holes.toArray([]));else {\n  \t\t\tvar components = new ArrayList();\n  \t\t\tif (shell !== null) components.add(shell);\n  \t\t\tcomponents.addAll(holes);\n  \t\t\treturn this._factory.buildGeometry(components);\n  \t\t}\n  \t},\n  \tcreateCoordinateSequence: function createCoordinateSequence(coords) {\n  \t\treturn this._factory.getCoordinateSequenceFactory().create(coords);\n  \t},\n  \tgetInputGeometry: function getInputGeometry() {\n  \t\treturn this._inputGeom;\n  \t},\n  \ttransformMultiLineString: function transformMultiLineString(geom, parent) {\n  \t\tvar transGeomList = new ArrayList();\n  \t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n  \t\t\tvar transformGeom = this.transformLineString(geom.getGeometryN(i), geom);\n  \t\t\tif (transformGeom === null) continue;\n  \t\t\tif (transformGeom.isEmpty()) continue;\n  \t\t\ttransGeomList.add(transformGeom);\n  \t\t}\n  \t\treturn this._factory.buildGeometry(transGeomList);\n  \t},\n  \ttransformCoordinates: function transformCoordinates(coords, parent) {\n  \t\treturn this.copy(coords);\n  \t},\n  \ttransformLineString: function transformLineString(geom, parent) {\n  \t\treturn this._factory.createLineString(this.transformCoordinates(geom.getCoordinateSequence(), geom));\n  \t},\n  \ttransformMultiPoint: function transformMultiPoint(geom, parent) {\n  \t\tvar transGeomList = new ArrayList();\n  \t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n  \t\t\tvar transformGeom = this.transformPoint(geom.getGeometryN(i), geom);\n  \t\t\tif (transformGeom === null) continue;\n  \t\t\tif (transformGeom.isEmpty()) continue;\n  \t\t\ttransGeomList.add(transformGeom);\n  \t\t}\n  \t\treturn this._factory.buildGeometry(transGeomList);\n  \t},\n  \ttransformMultiPolygon: function transformMultiPolygon(geom, parent) {\n  \t\tvar transGeomList = new ArrayList();\n  \t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n  \t\t\tvar transformGeom = this.transformPolygon(geom.getGeometryN(i), geom);\n  \t\t\tif (transformGeom === null) continue;\n  \t\t\tif (transformGeom.isEmpty()) continue;\n  \t\t\ttransGeomList.add(transformGeom);\n  \t\t}\n  \t\treturn this._factory.buildGeometry(transGeomList);\n  \t},\n  \tcopy: function copy(seq) {\n  \t\treturn seq.copy();\n  \t},\n  \ttransformGeometryCollection: function transformGeometryCollection(geom, parent) {\n  \t\tvar transGeomList = new ArrayList();\n  \t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n  \t\t\tvar transformGeom = this.transform(geom.getGeometryN(i));\n  \t\t\tif (transformGeom === null) continue;\n  \t\t\tif (this._pruneEmptyGeometry && transformGeom.isEmpty()) continue;\n  \t\t\ttransGeomList.add(transformGeom);\n  \t\t}\n  \t\tif (this._preserveGeometryCollectionType) return this._factory.createGeometryCollection(GeometryFactory.toGeometryArray(transGeomList));\n  \t\treturn this._factory.buildGeometry(transGeomList);\n  \t},\n  \ttransform: function transform(inputGeom) {\n  \t\tthis._inputGeom = inputGeom;\n  \t\tthis._factory = inputGeom.getFactory();\n  \t\tif (inputGeom instanceof Point) return this.transformPoint(inputGeom, null);\n  \t\tif (inputGeom instanceof MultiPoint) return this.transformMultiPoint(inputGeom, null);\n  \t\tif (inputGeom instanceof LinearRing) return this.transformLinearRing(inputGeom, null);\n  \t\tif (inputGeom instanceof LineString) return this.transformLineString(inputGeom, null);\n  \t\tif (inputGeom instanceof MultiLineString) return this.transformMultiLineString(inputGeom, null);\n  \t\tif (inputGeom instanceof Polygon) return this.transformPolygon(inputGeom, null);\n  \t\tif (inputGeom instanceof MultiPolygon) return this.transformMultiPolygon(inputGeom, null);\n  \t\tif (inputGeom instanceof GeometryCollection) return this.transformGeometryCollection(inputGeom, null);\n  \t\tthrow new IllegalArgumentException(\"Unknown Geometry subtype: \" + inputGeom.getClass().getName());\n  \t},\n  \ttransformLinearRing: function transformLinearRing(geom, parent) {\n  \t\tvar seq = this.transformCoordinates(geom.getCoordinateSequence(), geom);\n  \t\tif (seq === null) return this._factory.createLinearRing(null);\n  \t\tvar seqSize = seq.size();\n  \t\tif (seqSize > 0 && seqSize < 4 && !this._preserveType) return this._factory.createLineString(seq);\n  \t\treturn this._factory.createLinearRing(seq);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn GeometryTransformer;\n  \t}\n  });\n\n  function LineStringSnapper() {\n  \tthis._snapTolerance = 0.0;\n  \tthis._srcPts = null;\n  \tthis._seg = new LineSegment();\n  \tthis._allowSnappingToSourceVertices = false;\n  \tthis._isClosed = false;\n  \tif (arguments[0] instanceof LineString && typeof arguments[1] === \"number\") {\n  \t\tvar srcLine = arguments[0],\n  \t\t    snapTolerance = arguments[1];\n  \t\tLineStringSnapper.call(this, srcLine.getCoordinates(), snapTolerance);\n  \t} else if (arguments[0] instanceof Array && typeof arguments[1] === \"number\") {\n  \t\tvar srcPts = arguments[0],\n  \t\t    snapTolerance = arguments[1];\n  \t\tthis._srcPts = srcPts;\n  \t\tthis._isClosed = LineStringSnapper.isClosed(srcPts);\n  \t\tthis._snapTolerance = snapTolerance;\n  \t}\n  }\n  extend(LineStringSnapper.prototype, {\n  \tsnapVertices: function snapVertices(srcCoords, snapPts) {\n  \t\tvar end = this._isClosed ? srcCoords.size() - 1 : srcCoords.size();\n  \t\tfor (var i = 0; i < end; i++) {\n  \t\t\tvar srcPt = srcCoords.get(i);\n  \t\t\tvar snapVert = this.findSnapForVertex(srcPt, snapPts);\n  \t\t\tif (snapVert !== null) {\n  \t\t\t\tsrcCoords.set(i, new Coordinate(snapVert));\n  \t\t\t\tif (i === 0 && this._isClosed) srcCoords.set(srcCoords.size() - 1, new Coordinate(snapVert));\n  \t\t\t}\n  \t\t}\n  \t},\n  \tfindSnapForVertex: function findSnapForVertex(pt, snapPts) {\n  \t\tfor (var i = 0; i < snapPts.length; i++) {\n  \t\t\tif (pt.equals2D(snapPts[i])) return null;\n  \t\t\tif (pt.distance(snapPts[i]) < this._snapTolerance) return snapPts[i];\n  \t\t}\n  \t\treturn null;\n  \t},\n  \tsnapTo: function snapTo(snapPts) {\n  \t\tvar coordList = new CoordinateList(this._srcPts);\n  \t\tthis.snapVertices(coordList, snapPts);\n  \t\tthis.snapSegments(coordList, snapPts);\n  \t\tvar newPts = coordList.toCoordinateArray();\n  \t\treturn newPts;\n  \t},\n  \tsnapSegments: function snapSegments(srcCoords, snapPts) {\n  \t\tif (snapPts.length === 0) return null;\n  \t\tvar distinctPtCount = snapPts.length;\n  \t\tif (snapPts[0].equals2D(snapPts[snapPts.length - 1])) distinctPtCount = snapPts.length - 1;\n  \t\tfor (var i = 0; i < distinctPtCount; i++) {\n  \t\t\tvar snapPt = snapPts[i];\n  \t\t\tvar index = this.findSegmentIndexToSnap(snapPt, srcCoords);\n  \t\t\tif (index >= 0) {\n  \t\t\t\tsrcCoords.add(index + 1, new Coordinate(snapPt), false);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tfindSegmentIndexToSnap: function findSegmentIndexToSnap(snapPt, srcCoords) {\n  \t\tvar minDist = Double.MAX_VALUE;\n  \t\tvar snapIndex = -1;\n  \t\tfor (var i = 0; i < srcCoords.size() - 1; i++) {\n  \t\t\tthis._seg.p0 = srcCoords.get(i);\n  \t\t\tthis._seg.p1 = srcCoords.get(i + 1);\n  \t\t\tif (this._seg.p0.equals2D(snapPt) || this._seg.p1.equals2D(snapPt)) {\n  \t\t\t\tif (this._allowSnappingToSourceVertices) continue;else return -1;\n  \t\t\t}\n  \t\t\tvar dist = this._seg.distance(snapPt);\n  \t\t\tif (dist < this._snapTolerance && dist < minDist) {\n  \t\t\t\tminDist = dist;\n  \t\t\t\tsnapIndex = i;\n  \t\t\t}\n  \t\t}\n  \t\treturn snapIndex;\n  \t},\n  \tsetAllowSnappingToSourceVertices: function setAllowSnappingToSourceVertices(allowSnappingToSourceVertices) {\n  \t\tthis._allowSnappingToSourceVertices = allowSnappingToSourceVertices;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LineStringSnapper;\n  \t}\n  });\n  LineStringSnapper.isClosed = function (pts) {\n  \tif (pts.length <= 1) return false;\n  \treturn pts[0].equals2D(pts[pts.length - 1]);\n  };\n\n  function GeometrySnapper() {\n  \tthis._srcGeom = null;\n  \tvar srcGeom = arguments[0];\n  \tthis._srcGeom = srcGeom;\n  }\n  extend(GeometrySnapper.prototype, {\n  \tsnapTo: function snapTo(snapGeom, snapTolerance) {\n  \t\tvar snapPts = this.extractTargetCoordinates(snapGeom);\n  \t\tvar snapTrans = new SnapTransformer(snapTolerance, snapPts);\n  \t\treturn snapTrans.transform(this._srcGeom);\n  \t},\n  \tsnapToSelf: function snapToSelf(snapTolerance, cleanResult) {\n  \t\tvar snapPts = this.extractTargetCoordinates(this._srcGeom);\n  \t\tvar snapTrans = new SnapTransformer(snapTolerance, snapPts, true);\n  \t\tvar snappedGeom = snapTrans.transform(this._srcGeom);\n  \t\tvar result = snappedGeom;\n  \t\tif (cleanResult && hasInterface(result, Polygonal)) {\n  \t\t\tresult = snappedGeom.buffer(0);\n  \t\t}\n  \t\treturn result;\n  \t},\n  \tcomputeSnapTolerance: function computeSnapTolerance(ringPts) {\n  \t\tvar minSegLen = this.computeMinimumSegmentLength(ringPts);\n  \t\tvar snapTol = minSegLen / 10;\n  \t\treturn snapTol;\n  \t},\n  \textractTargetCoordinates: function extractTargetCoordinates(g) {\n  \t\tvar ptSet = new TreeSet();\n  \t\tvar pts = g.getCoordinates();\n  \t\tfor (var i = 0; i < pts.length; i++) {\n  \t\t\tptSet.add(pts[i]);\n  \t\t}\n  \t\treturn ptSet.toArray(new Array(0).fill(null));\n  \t},\n  \tcomputeMinimumSegmentLength: function computeMinimumSegmentLength(pts) {\n  \t\tvar minSegLen = Double.MAX_VALUE;\n  \t\tfor (var i = 0; i < pts.length - 1; i++) {\n  \t\t\tvar segLen = pts[i].distance(pts[i + 1]);\n  \t\t\tif (segLen < minSegLen) minSegLen = segLen;\n  \t\t}\n  \t\treturn minSegLen;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn GeometrySnapper;\n  \t}\n  });\n  GeometrySnapper.snap = function (g0, g1, snapTolerance) {\n  \tvar snapGeom = new Array(2).fill(null);\n  \tvar snapper0 = new GeometrySnapper(g0);\n  \tsnapGeom[0] = snapper0.snapTo(g1, snapTolerance);\n  \tvar snapper1 = new GeometrySnapper(g1);\n  \tsnapGeom[1] = snapper1.snapTo(snapGeom[0], snapTolerance);\n  \treturn snapGeom;\n  };\n  GeometrySnapper.computeOverlaySnapTolerance = function () {\n  \tif (arguments.length === 1) {\n  \t\tvar g = arguments[0];\n  \t\tvar snapTolerance = GeometrySnapper.computeSizeBasedSnapTolerance(g);\n  \t\tvar pm = g.getPrecisionModel();\n  \t\tif (pm.getType() === PrecisionModel.FIXED) {\n  \t\t\tvar fixedSnapTol = 1 / pm.getScale() * 2 / 1.415;\n  \t\t\tif (fixedSnapTol > snapTolerance) snapTolerance = fixedSnapTol;\n  \t\t}\n  \t\treturn snapTolerance;\n  \t} else if (arguments.length === 2) {\n  \t\tvar g0 = arguments[0],\n  \t\t    g1 = arguments[1];\n  \t\treturn Math.min(GeometrySnapper.computeOverlaySnapTolerance(g0), GeometrySnapper.computeOverlaySnapTolerance(g1));\n  \t}\n  };\n  GeometrySnapper.computeSizeBasedSnapTolerance = function (g) {\n  \tvar env = g.getEnvelopeInternal();\n  \tvar minDimension = Math.min(env.getHeight(), env.getWidth());\n  \tvar snapTol = minDimension * GeometrySnapper.SNAP_PRECISION_FACTOR;\n  \treturn snapTol;\n  };\n  GeometrySnapper.snapToSelf = function (geom, snapTolerance, cleanResult) {\n  \tvar snapper0 = new GeometrySnapper(geom);\n  \treturn snapper0.snapToSelf(snapTolerance, cleanResult);\n  };\n  GeometrySnapper.SNAP_PRECISION_FACTOR = 1e-9;\n  function SnapTransformer() {\n  \tGeometryTransformer.apply(this);\n  \tthis._snapTolerance = null;\n  \tthis._snapPts = null;\n  \tthis._isSelfSnap = false;\n  \tif (arguments.length === 2) {\n  \t\tvar snapTolerance = arguments[0],\n  \t\t    snapPts = arguments[1];\n  \t\tthis._snapTolerance = snapTolerance;\n  \t\tthis._snapPts = snapPts;\n  \t} else if (arguments.length === 3) {\n  \t\tvar snapTolerance = arguments[0],\n  \t\t    snapPts = arguments[1],\n  \t\t    isSelfSnap = arguments[2];\n  \t\tthis._snapTolerance = snapTolerance;\n  \t\tthis._snapPts = snapPts;\n  \t\tthis._isSelfSnap = isSelfSnap;\n  \t}\n  }\n  inherits$1(SnapTransformer, GeometryTransformer);\n  extend(SnapTransformer.prototype, {\n  \tsnapLine: function snapLine(srcPts, snapPts) {\n  \t\tvar snapper = new LineStringSnapper(srcPts, this._snapTolerance);\n  \t\tsnapper.setAllowSnappingToSourceVertices(this._isSelfSnap);\n  \t\treturn snapper.snapTo(snapPts);\n  \t},\n  \ttransformCoordinates: function transformCoordinates(coords, parent) {\n  \t\tvar srcPts = coords.toCoordinateArray();\n  \t\tvar newPts = this.snapLine(srcPts, this._snapPts);\n  \t\treturn this._factory.getCoordinateSequenceFactory().create(newPts);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SnapTransformer;\n  \t}\n  });\n\n  function CommonBits() {\n  \tthis._isFirst = true;\n  \tthis._commonMantissaBitsCount = 53;\n  \tthis._commonBits = 0;\n  \tthis._commonSignExp = null;\n  }\n  extend(CommonBits.prototype, {\n  \tgetCommon: function getCommon() {\n  \t\treturn Double.longBitsToDouble(this._commonBits);\n  \t},\n  \tadd: function add(num) {\n  \t\tvar numBits = Double.doubleToLongBits(num);\n  \t\tif (this._isFirst) {\n  \t\t\tthis._commonBits = numBits;\n  \t\t\tthis._commonSignExp = CommonBits.signExpBits(this._commonBits);\n  \t\t\tthis._isFirst = false;\n  \t\t\treturn null;\n  \t\t}\n  \t\tvar numSignExp = CommonBits.signExpBits(numBits);\n  \t\tif (numSignExp !== this._commonSignExp) {\n  \t\t\tthis._commonBits = 0;\n  \t\t\treturn null;\n  \t\t}\n  \t\tthis._commonMantissaBitsCount = CommonBits.numCommonMostSigMantissaBits(this._commonBits, numBits);\n  \t\tthis._commonBits = CommonBits.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount));\n  \t},\n  \ttoString: function toString() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar bits = arguments[0];\n  \t\t\tvar x = Double.longBitsToDouble(bits);\n  \t\t\tvar numStr = Long.toBinaryString(bits);\n  \t\t\tvar padStr = \"0000000000000000000000000000000000000000000000000000000000000000\" + numStr;\n  \t\t\tvar bitStr = padStr.substring(padStr.length - 64);\n  \t\t\tvar str = bitStr.substring(0, 1) + \"  \" + bitStr.substring(1, 12) + \"(exp) \" + bitStr.substring(12) + \" [ \" + x + \" ]\";\n  \t\t\treturn str;\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn CommonBits;\n  \t}\n  });\n  CommonBits.getBit = function (bits, i) {\n  \tvar mask = 1 << i;\n  \treturn (bits & mask) !== 0 ? 1 : 0;\n  };\n  CommonBits.signExpBits = function (num) {\n  \treturn num >> 52;\n  };\n  CommonBits.zeroLowerBits = function (bits, nBits) {\n  \tvar invMask = (1 << nBits) - 1;\n  \tvar mask = ~invMask;\n  \tvar zeroed = bits & mask;\n  \treturn zeroed;\n  };\n  CommonBits.numCommonMostSigMantissaBits = function (num1, num2) {\n  \tvar count = 0;\n  \tfor (var i = 52; i >= 0; i--) {\n  \t\tif (CommonBits.getBit(num1, i) !== CommonBits.getBit(num2, i)) return count;\n  \t\tcount++;\n  \t}\n  \treturn 52;\n  };\n\n  function CommonBitsRemover() {\n  \tthis._commonCoord = null;\n  \tthis._ccFilter = new CommonCoordinateFilter();\n  }\n  extend(CommonBitsRemover.prototype, {\n  \taddCommonBits: function addCommonBits(geom) {\n  \t\tvar trans = new Translater(this._commonCoord);\n  \t\tgeom.apply(trans);\n  \t\tgeom.geometryChanged();\n  \t},\n  \tremoveCommonBits: function removeCommonBits(geom) {\n  \t\tif (this._commonCoord.x === 0.0 && this._commonCoord.y === 0.0) return geom;\n  \t\tvar invCoord = new Coordinate(this._commonCoord);\n  \t\tinvCoord.x = -invCoord.x;\n  \t\tinvCoord.y = -invCoord.y;\n  \t\tvar trans = new Translater(invCoord);\n  \t\tgeom.apply(trans);\n  \t\tgeom.geometryChanged();\n  \t\treturn geom;\n  \t},\n  \tgetCommonCoordinate: function getCommonCoordinate() {\n  \t\treturn this._commonCoord;\n  \t},\n  \tadd: function add(geom) {\n  \t\tgeom.apply(this._ccFilter);\n  \t\tthis._commonCoord = this._ccFilter.getCommonCoordinate();\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn CommonBitsRemover;\n  \t}\n  });\n  function CommonCoordinateFilter() {\n  \tthis._commonBitsX = new CommonBits();\n  \tthis._commonBitsY = new CommonBits();\n  }\n  extend(CommonCoordinateFilter.prototype, {\n  \tfilter: function filter(coord) {\n  \t\tthis._commonBitsX.add(coord.x);\n  \t\tthis._commonBitsY.add(coord.y);\n  \t},\n  \tgetCommonCoordinate: function getCommonCoordinate() {\n  \t\treturn new Coordinate(this._commonBitsX.getCommon(), this._commonBitsY.getCommon());\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [CoordinateFilter];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn CommonCoordinateFilter;\n  \t}\n  });\n  function Translater() {\n  \tthis.trans = null;\n  \tvar trans = arguments[0];\n  \tthis.trans = trans;\n  }\n  extend(Translater.prototype, {\n  \tfilter: function filter(seq, i) {\n  \t\tvar xp = seq.getOrdinate(i, 0) + this.trans.x;\n  \t\tvar yp = seq.getOrdinate(i, 1) + this.trans.y;\n  \t\tseq.setOrdinate(i, 0, xp);\n  \t\tseq.setOrdinate(i, 1, yp);\n  \t},\n  \tisDone: function isDone() {\n  \t\treturn false;\n  \t},\n  \tisGeometryChanged: function isGeometryChanged() {\n  \t\treturn true;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [CoordinateSequenceFilter];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Translater;\n  \t}\n  });\n  CommonBitsRemover.CommonCoordinateFilter = CommonCoordinateFilter;\n  CommonBitsRemover.Translater = Translater;\n\n  function GeometryCollectionIterator() {\n  \tthis._parent = null;\n  \tthis._atStart = null;\n  \tthis._max = null;\n  \tthis._index = null;\n  \tthis._subcollectionIterator = null;\n  \tvar parent = arguments[0];\n  \tthis._parent = parent;\n  \tthis._atStart = true;\n  \tthis._index = 0;\n  \tthis._max = parent.getNumGeometries();\n  }\n  extend(GeometryCollectionIterator.prototype, {\n  \tnext: function next() {\n  \t\tif (this._atStart) {\n  \t\t\tthis._atStart = false;\n  \t\t\tif (GeometryCollectionIterator.isAtomic(this._parent)) this._index++;\n  \t\t\treturn this._parent;\n  \t\t}\n  \t\tif (this._subcollectionIterator !== null) {\n  \t\t\tif (this._subcollectionIterator.hasNext()) {\n  \t\t\t\treturn this._subcollectionIterator.next();\n  \t\t\t} else {\n  \t\t\t\tthis._subcollectionIterator = null;\n  \t\t\t}\n  \t\t}\n  \t\tif (this._index >= this._max) {\n  \t\t\tthrow new NoSuchElementException();\n  \t\t}\n  \t\tvar obj = this._parent.getGeometryN(this._index++);\n  \t\tif (obj instanceof GeometryCollection) {\n  \t\t\tthis._subcollectionIterator = new GeometryCollectionIterator(obj);\n  \t\t\treturn this._subcollectionIterator.next();\n  \t\t}\n  \t\treturn obj;\n  \t},\n  \tremove: function remove() {\n  \t\tthrow new UnsupportedOperationException(this.getClass().getName());\n  \t},\n  \thasNext: function hasNext() {\n  \t\tif (this._atStart) {\n  \t\t\treturn true;\n  \t\t}\n  \t\tif (this._subcollectionIterator !== null) {\n  \t\t\tif (this._subcollectionIterator.hasNext()) {\n  \t\t\t\treturn true;\n  \t\t\t}\n  \t\t\tthis._subcollectionIterator = null;\n  \t\t}\n  \t\tif (this._index >= this._max) {\n  \t\t\treturn false;\n  \t\t}\n  \t\treturn true;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Iterator];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn GeometryCollectionIterator;\n  \t}\n  });\n  GeometryCollectionIterator.isAtomic = function (geom) {\n  \treturn !(geom instanceof GeometryCollection);\n  };\n\n  function PointLocator() {\n  \tthis._boundaryRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;\n  \tthis._isIn = null;\n  \tthis._numBoundaries = null;\n  \tif (arguments.length === 0) ; else if (arguments.length === 1) {\n  \t\tvar boundaryRule = arguments[0];\n  \t\tif (boundaryRule === null) throw new IllegalArgumentException(\"Rule must be non-null\");\n  \t\tthis._boundaryRule = boundaryRule;\n  \t}\n  }\n  extend(PointLocator.prototype, {\n  \tlocateInternal: function locateInternal() {\n  \t\tif (arguments[0] instanceof Coordinate && arguments[1] instanceof Polygon) {\n  \t\t\tvar p = arguments[0],\n  \t\t\t    poly = arguments[1];\n  \t\t\tif (poly.isEmpty()) return Location.EXTERIOR;\n  \t\t\tvar shell = poly.getExteriorRing();\n  \t\t\tvar shellLoc = this.locateInPolygonRing(p, shell);\n  \t\t\tif (shellLoc === Location.EXTERIOR) return Location.EXTERIOR;\n  \t\t\tif (shellLoc === Location.BOUNDARY) return Location.BOUNDARY;\n  \t\t\tfor (var i = 0; i < poly.getNumInteriorRing(); i++) {\n  \t\t\t\tvar hole = poly.getInteriorRingN(i);\n  \t\t\t\tvar holeLoc = this.locateInPolygonRing(p, hole);\n  \t\t\t\tif (holeLoc === Location.INTERIOR) return Location.EXTERIOR;\n  \t\t\t\tif (holeLoc === Location.BOUNDARY) return Location.BOUNDARY;\n  \t\t\t}\n  \t\t\treturn Location.INTERIOR;\n  \t\t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof LineString) {\n  \t\t\tvar p = arguments[0],\n  \t\t\t    l = arguments[1];\n  \t\t\tif (!l.getEnvelopeInternal().intersects(p)) return Location.EXTERIOR;\n  \t\t\tvar pt = l.getCoordinates();\n  \t\t\tif (!l.isClosed()) {\n  \t\t\t\tif (p.equals(pt[0]) || p.equals(pt[pt.length - 1])) {\n  \t\t\t\t\treturn Location.BOUNDARY;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\tif (CGAlgorithms.isOnLine(p, pt)) return Location.INTERIOR;\n  \t\t\treturn Location.EXTERIOR;\n  \t\t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Point) {\n  \t\t\tvar p = arguments[0],\n  \t\t\t    pt = arguments[1];\n  \t\t\tvar ptCoord = pt.getCoordinate();\n  \t\t\tif (ptCoord.equals2D(p)) return Location.INTERIOR;\n  \t\t\treturn Location.EXTERIOR;\n  \t\t}\n  \t},\n  \tlocateInPolygonRing: function locateInPolygonRing(p, ring) {\n  \t\tif (!ring.getEnvelopeInternal().intersects(p)) return Location.EXTERIOR;\n  \t\treturn CGAlgorithms.locatePointInRing(p, ring.getCoordinates());\n  \t},\n  \tintersects: function intersects(p, geom) {\n  \t\treturn this.locate(p, geom) !== Location.EXTERIOR;\n  \t},\n  \tupdateLocationInfo: function updateLocationInfo(loc) {\n  \t\tif (loc === Location.INTERIOR) this._isIn = true;\n  \t\tif (loc === Location.BOUNDARY) this._numBoundaries++;\n  \t},\n  \tcomputeLocation: function computeLocation(p, geom) {\n  \t\tif (geom instanceof Point) {\n  \t\t\tthis.updateLocationInfo(this.locateInternal(p, geom));\n  \t\t}\n  \t\tif (geom instanceof LineString) {\n  \t\t\tthis.updateLocationInfo(this.locateInternal(p, geom));\n  \t\t} else if (geom instanceof Polygon) {\n  \t\t\tthis.updateLocationInfo(this.locateInternal(p, geom));\n  \t\t} else if (geom instanceof MultiLineString) {\n  \t\t\tvar ml = geom;\n  \t\t\tfor (var i = 0; i < ml.getNumGeometries(); i++) {\n  \t\t\t\tvar l = ml.getGeometryN(i);\n  \t\t\t\tthis.updateLocationInfo(this.locateInternal(p, l));\n  \t\t\t}\n  \t\t} else if (geom instanceof MultiPolygon) {\n  \t\t\tvar mpoly = geom;\n  \t\t\tfor (var i = 0; i < mpoly.getNumGeometries(); i++) {\n  \t\t\t\tvar poly = mpoly.getGeometryN(i);\n  \t\t\t\tthis.updateLocationInfo(this.locateInternal(p, poly));\n  \t\t\t}\n  \t\t} else if (geom instanceof GeometryCollection) {\n  \t\t\tvar geomi = new GeometryCollectionIterator(geom);\n  \t\t\twhile (geomi.hasNext()) {\n  \t\t\t\tvar g2 = geomi.next();\n  \t\t\t\tif (g2 !== geom) this.computeLocation(p, g2);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tlocate: function locate(p, geom) {\n  \t\tif (geom.isEmpty()) return Location.EXTERIOR;\n  \t\tif (geom instanceof LineString) {\n  \t\t\treturn this.locateInternal(p, geom);\n  \t\t} else if (geom instanceof Polygon) {\n  \t\t\treturn this.locateInternal(p, geom);\n  \t\t}\n  \t\tthis._isIn = false;\n  \t\tthis._numBoundaries = 0;\n  \t\tthis.computeLocation(p, geom);\n  \t\tif (this._boundaryRule.isInBoundary(this._numBoundaries)) return Location.BOUNDARY;\n  \t\tif (this._numBoundaries > 0 || this._isIn) return Location.INTERIOR;\n  \t\treturn Location.EXTERIOR;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn PointLocator;\n  \t}\n  });\n\n  function Octant() {}\n  extend(Octant.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Octant;\n  \t}\n  });\n  Octant.octant = function () {\n  \tif (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\") {\n  \t\tvar dx = arguments[0],\n  \t\t    dy = arguments[1];\n  \t\tif (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException(\"Cannot compute the octant for point ( \" + dx + \", \" + dy + \" )\");\n  \t\tvar adx = Math.abs(dx);\n  \t\tvar ady = Math.abs(dy);\n  \t\tif (dx >= 0) {\n  \t\t\tif (dy >= 0) {\n  \t\t\t\tif (adx >= ady) return 0;else return 1;\n  \t\t\t} else {\n  \t\t\t\tif (adx >= ady) return 7;else return 6;\n  \t\t\t}\n  \t\t} else {\n  \t\t\tif (dy >= 0) {\n  \t\t\t\tif (adx >= ady) return 3;else return 2;\n  \t\t\t} else {\n  \t\t\t\tif (adx >= ady) return 4;else return 5;\n  \t\t\t}\n  \t\t}\n  \t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n  \t\tvar p0 = arguments[0],\n  \t\t    p1 = arguments[1];\n  \t\tvar dx = p1.x - p0.x;\n  \t\tvar dy = p1.y - p0.y;\n  \t\tif (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException(\"Cannot compute the octant for two identical points \" + p0);\n  \t\treturn Octant.octant(dx, dy);\n  \t}\n  };\n\n  function SegmentString() {}\n  extend(SegmentString.prototype, {\n  \tgetCoordinates: function getCoordinates() {},\n  \tsize: function size() {},\n  \tgetCoordinate: function getCoordinate(i) {},\n  \tisClosed: function isClosed() {},\n  \tsetData: function setData(data) {},\n  \tgetData: function getData() {},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SegmentString;\n  \t}\n  });\n\n  function BasicSegmentString() {\n  \tthis._pts = null;\n  \tthis._data = null;\n  \tvar pts = arguments[0],\n  \t    data = arguments[1];\n  \tthis._pts = pts;\n  \tthis._data = data;\n  }\n  extend(BasicSegmentString.prototype, {\n  \tgetCoordinates: function getCoordinates() {\n  \t\treturn this._pts;\n  \t},\n  \tsize: function size() {\n  \t\treturn this._pts.length;\n  \t},\n  \tgetCoordinate: function getCoordinate(i) {\n  \t\treturn this._pts[i];\n  \t},\n  \tisClosed: function isClosed() {\n  \t\treturn this._pts[0].equals(this._pts[this._pts.length - 1]);\n  \t},\n  \tgetSegmentOctant: function getSegmentOctant(index) {\n  \t\tif (index === this._pts.length - 1) return -1;\n  \t\treturn Octant.octant(this.getCoordinate(index), this.getCoordinate(index + 1));\n  \t},\n  \tsetData: function setData(data) {\n  \t\tthis._data = data;\n  \t},\n  \tgetData: function getData() {\n  \t\treturn this._data;\n  \t},\n  \ttoString: function toString() {\n  \t\treturn WKTWriter.toLineString(new CoordinateArraySequence(this._pts));\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [SegmentString];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn BasicSegmentString;\n  \t}\n  });\n\n  function Boundable() {}\n  extend(Boundable.prototype, {\n  \tgetBounds: function getBounds() {},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Boundable;\n  \t}\n  });\n\n  function ItemBoundable() {\n  \tthis._bounds = null;\n  \tthis._item = null;\n  \tvar bounds = arguments[0],\n  \t    item = arguments[1];\n  \tthis._bounds = bounds;\n  \tthis._item = item;\n  }\n  extend(ItemBoundable.prototype, {\n  \tgetItem: function getItem() {\n  \t\treturn this._item;\n  \t},\n  \tgetBounds: function getBounds() {\n  \t\treturn this._bounds;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Boundable, Serializable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn ItemBoundable;\n  \t}\n  });\n\n  function PriorityQueue() {\n  \tthis._size = null;\n  \tthis._items = null;\n  \tthis._size = 0;\n  \tthis._items = new ArrayList();\n  \tthis._items.add(null);\n  }\n  extend(PriorityQueue.prototype, {\n  \tpoll: function poll() {\n  \t\tif (this.isEmpty()) return null;\n  \t\tvar minItem = this._items.get(1);\n  \t\tthis._items.set(1, this._items.get(this._size));\n  \t\tthis._size -= 1;\n  \t\tthis.reorder(1);\n  \t\treturn minItem;\n  \t},\n  \tsize: function size() {\n  \t\treturn this._size;\n  \t},\n  \treorder: function reorder(hole) {\n  \t\tvar child = null;\n  \t\tvar tmp = this._items.get(hole);\n  \t\tfor (; hole * 2 <= this._size; hole = child) {\n  \t\t\tchild = hole * 2;\n  \t\t\tif (child !== this._size && this._items.get(child + 1).compareTo(this._items.get(child)) < 0) child++;\n  \t\t\tif (this._items.get(child).compareTo(tmp) < 0) this._items.set(hole, this._items.get(child));else break;\n  \t\t}\n  \t\tthis._items.set(hole, tmp);\n  \t},\n  \tclear: function clear() {\n  \t\tthis._size = 0;\n  \t\tthis._items.clear();\n  \t},\n  \tisEmpty: function isEmpty() {\n  \t\treturn this._size === 0;\n  \t},\n  \tadd: function add(x) {\n  \t\tthis._items.add(null);\n  \t\tthis._size += 1;\n  \t\tvar hole = this._size;\n  \t\tthis._items.set(0, x);\n  \t\tfor (; x.compareTo(this._items.get(Math.trunc(hole / 2))) < 0; hole /= 2) {\n  \t\t\tthis._items.set(hole, this._items.get(Math.trunc(hole / 2)));\n  \t\t}\n  \t\tthis._items.set(hole, x);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn PriorityQueue;\n  \t}\n  });\n\n  function ItemVisitor() {}\n  extend(ItemVisitor.prototype, {\n  \tvisitItem: function visitItem(item) {},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn ItemVisitor;\n  \t}\n  });\n\n  function SpatialIndex() {}\n  extend(SpatialIndex.prototype, {\n  \tinsert: function insert(itemEnv, item) {},\n  \tremove: function remove(itemEnv, item) {},\n  \tquery: function query() {\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SpatialIndex;\n  \t}\n  });\n\n  function AbstractNode() {\n  \tthis._childBoundables = new ArrayList();\n  \tthis._bounds = null;\n  \tthis._level = null;\n  \tif (arguments.length === 0) ; else if (arguments.length === 1) {\n  \t\tvar level = arguments[0];\n  \t\tthis._level = level;\n  \t}\n  }\n  extend(AbstractNode.prototype, {\n  \tgetLevel: function getLevel() {\n  \t\treturn this._level;\n  \t},\n  \tsize: function size() {\n  \t\treturn this._childBoundables.size();\n  \t},\n  \tgetChildBoundables: function getChildBoundables() {\n  \t\treturn this._childBoundables;\n  \t},\n  \taddChildBoundable: function addChildBoundable(childBoundable) {\n  \t\tAssert.isTrue(this._bounds === null);\n  \t\tthis._childBoundables.add(childBoundable);\n  \t},\n  \tisEmpty: function isEmpty() {\n  \t\treturn this._childBoundables.isEmpty();\n  \t},\n  \tgetBounds: function getBounds() {\n  \t\tif (this._bounds === null) {\n  \t\t\tthis._bounds = this.computeBounds();\n  \t\t}\n  \t\treturn this._bounds;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Boundable, Serializable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn AbstractNode;\n  \t}\n  });\n  AbstractNode.serialVersionUID = 6493722185909573708;\n\n  var Collections = {\n    reverseOrder: function reverseOrder() {\n      return {\n        compare: function compare(a, b) {\n          return b.compareTo(a);\n        }\n      };\n    },\n    min: function min(l) {\n      Collections.sort(l);\n      return l.get(0);\n    },\n    sort: function sort(l, c) {\n      var a = l.toArray();\n      if (c) {\n        Arrays.sort(a, c);\n      } else {\n        Arrays.sort(a);\n      }\n      var i = l.iterator();\n      for (var pos = 0, alen = a.length; pos < alen; pos++) {\n        i.next();\n        i.set(a[pos]);\n      }\n    },\n    singletonList: function singletonList(o) {\n      var arrayList = new ArrayList();\n      arrayList.add(o);\n      return arrayList;\n    }\n  };\n\n  function BoundablePair() {\n  \tthis._boundable1 = null;\n  \tthis._boundable2 = null;\n  \tthis._distance = null;\n  \tthis._itemDistance = null;\n  \tvar boundable1 = arguments[0],\n  \t    boundable2 = arguments[1],\n  \t    itemDistance = arguments[2];\n  \tthis._boundable1 = boundable1;\n  \tthis._boundable2 = boundable2;\n  \tthis._itemDistance = itemDistance;\n  \tthis._distance = this.distance();\n  }\n  extend(BoundablePair.prototype, {\n  \texpandToQueue: function expandToQueue(priQ, minDistance) {\n  \t\tvar isComp1 = BoundablePair.isComposite(this._boundable1);\n  \t\tvar isComp2 = BoundablePair.isComposite(this._boundable2);\n  \t\tif (isComp1 && isComp2) {\n  \t\t\tif (BoundablePair.area(this._boundable1) > BoundablePair.area(this._boundable2)) {\n  \t\t\t\tthis.expand(this._boundable1, this._boundable2, priQ, minDistance);\n  \t\t\t\treturn null;\n  \t\t\t} else {\n  \t\t\t\tthis.expand(this._boundable2, this._boundable1, priQ, minDistance);\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t} else if (isComp1) {\n  \t\t\tthis.expand(this._boundable1, this._boundable2, priQ, minDistance);\n  \t\t\treturn null;\n  \t\t} else if (isComp2) {\n  \t\t\tthis.expand(this._boundable2, this._boundable1, priQ, minDistance);\n  \t\t\treturn null;\n  \t\t}\n  \t\tthrow new IllegalArgumentException(\"neither boundable is composite\");\n  \t},\n  \tisLeaves: function isLeaves() {\n  \t\treturn !(BoundablePair.isComposite(this._boundable1) || BoundablePair.isComposite(this._boundable2));\n  \t},\n  \tcompareTo: function compareTo(o) {\n  \t\tvar nd = o;\n  \t\tif (this._distance < nd._distance) return -1;\n  \t\tif (this._distance > nd._distance) return 1;\n  \t\treturn 0;\n  \t},\n  \texpand: function expand(bndComposite, bndOther, priQ, minDistance) {\n  \t\tvar children = bndComposite.getChildBoundables();\n  \t\tfor (var i = children.iterator(); i.hasNext();) {\n  \t\t\tvar child = i.next();\n  \t\t\tvar bp = new BoundablePair(child, bndOther, this._itemDistance);\n  \t\t\tif (bp.getDistance() < minDistance) {\n  \t\t\t\tpriQ.add(bp);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetBoundable: function getBoundable(i) {\n  \t\tif (i === 0) return this._boundable1;\n  \t\treturn this._boundable2;\n  \t},\n  \tgetDistance: function getDistance() {\n  \t\treturn this._distance;\n  \t},\n  \tdistance: function distance() {\n  \t\tif (this.isLeaves()) {\n  \t\t\treturn this._itemDistance.distance(this._boundable1, this._boundable2);\n  \t\t}\n  \t\treturn this._boundable1.getBounds().distance(this._boundable2.getBounds());\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn BoundablePair;\n  \t}\n  });\n  BoundablePair.area = function (b) {\n  \treturn b.getBounds().getArea();\n  };\n  BoundablePair.isComposite = function (item) {\n  \treturn item instanceof AbstractNode;\n  };\n\n  function AbstractSTRtree() {\n  \tthis._root = null;\n  \tthis._built = false;\n  \tthis._itemBoundables = new ArrayList();\n  \tthis._nodeCapacity = null;\n  \tif (arguments.length === 0) {\n  \t\tAbstractSTRtree.call(this, AbstractSTRtree.DEFAULT_NODE_CAPACITY);\n  \t} else if (arguments.length === 1) {\n  \t\tvar nodeCapacity = arguments[0];\n  \t\tAssert.isTrue(nodeCapacity > 1, \"Node capacity must be greater than 1\");\n  \t\tthis._nodeCapacity = nodeCapacity;\n  \t}\n  }\n  extend(AbstractSTRtree.prototype, {\n  \tgetNodeCapacity: function getNodeCapacity() {\n  \t\treturn this._nodeCapacity;\n  \t},\n  \tlastNode: function lastNode(nodes) {\n  \t\treturn nodes.get(nodes.size() - 1);\n  \t},\n  \tsize: function size() {\n  \t\tif (arguments.length === 0) {\n  \t\t\tif (this.isEmpty()) {\n  \t\t\t\treturn 0;\n  \t\t\t}\n  \t\t\tthis.build();\n  \t\t\treturn this.size(this._root);\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tvar node = arguments[0];\n  \t\t\tvar size = 0;\n  \t\t\tfor (var i = node.getChildBoundables().iterator(); i.hasNext();) {\n  \t\t\t\tvar childBoundable = i.next();\n  \t\t\t\tif (childBoundable instanceof AbstractNode) {\n  \t\t\t\t\tsize += this.size(childBoundable);\n  \t\t\t\t} else if (childBoundable instanceof ItemBoundable) {\n  \t\t\t\t\tsize += 1;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\treturn size;\n  \t\t}\n  \t},\n  \tremoveItem: function removeItem(node, item) {\n  \t\tvar childToRemove = null;\n  \t\tfor (var i = node.getChildBoundables().iterator(); i.hasNext();) {\n  \t\t\tvar childBoundable = i.next();\n  \t\t\tif (childBoundable instanceof ItemBoundable) {\n  \t\t\t\tif (childBoundable.getItem() === item) childToRemove = childBoundable;\n  \t\t\t}\n  \t\t}\n  \t\tif (childToRemove !== null) {\n  \t\t\tnode.getChildBoundables().remove(childToRemove);\n  \t\t\treturn true;\n  \t\t}\n  \t\treturn false;\n  \t},\n  \titemsTree: function itemsTree() {\n  \t\tif (arguments.length === 0) {\n  \t\t\tthis.build();\n  \t\t\tvar valuesTree = this.itemsTree(this._root);\n  \t\t\tif (valuesTree === null) return new ArrayList();\n  \t\t\treturn valuesTree;\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tvar node = arguments[0];\n  \t\t\tvar valuesTreeForNode = new ArrayList();\n  \t\t\tfor (var i = node.getChildBoundables().iterator(); i.hasNext();) {\n  \t\t\t\tvar childBoundable = i.next();\n  \t\t\t\tif (childBoundable instanceof AbstractNode) {\n  \t\t\t\t\tvar valuesTreeForChild = this.itemsTree(childBoundable);\n  \t\t\t\t\tif (valuesTreeForChild !== null) valuesTreeForNode.add(valuesTreeForChild);\n  \t\t\t\t} else if (childBoundable instanceof ItemBoundable) {\n  \t\t\t\t\tvaluesTreeForNode.add(childBoundable.getItem());\n  \t\t\t\t} else {\n  \t\t\t\t\tAssert.shouldNeverReachHere();\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\tif (valuesTreeForNode.size() <= 0) return null;\n  \t\t\treturn valuesTreeForNode;\n  \t\t}\n  \t},\n  \tinsert: function insert(bounds, item) {\n  \t\tAssert.isTrue(!this._built, \"Cannot insert items into an STR packed R-tree after it has been built.\");\n  \t\tthis._itemBoundables.add(new ItemBoundable(bounds, item));\n  \t},\n  \tboundablesAtLevel: function boundablesAtLevel() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar level = arguments[0];\n  \t\t\tvar boundables = new ArrayList();\n  \t\t\tthis.boundablesAtLevel(level, this._root, boundables);\n  \t\t\treturn boundables;\n  \t\t} else if (arguments.length === 3) {\n  \t\t\tvar level = arguments[0],\n  \t\t\t    top = arguments[1],\n  \t\t\t    boundables = arguments[2];\n  \t\t\tAssert.isTrue(level > -2);\n  \t\t\tif (top.getLevel() === level) {\n  \t\t\t\tboundables.add(top);\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t\tfor (var i = top.getChildBoundables().iterator(); i.hasNext();) {\n  \t\t\t\tvar boundable = i.next();\n  \t\t\t\tif (boundable instanceof AbstractNode) {\n  \t\t\t\t\tthis.boundablesAtLevel(level, boundable, boundables);\n  \t\t\t\t} else {\n  \t\t\t\t\tAssert.isTrue(boundable instanceof ItemBoundable);\n  \t\t\t\t\tif (level === -1) {\n  \t\t\t\t\t\tboundables.add(boundable);\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\treturn null;\n  \t\t}\n  \t},\n  \tquery: function query() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar searchBounds = arguments[0];\n  \t\t\tthis.build();\n  \t\t\tvar matches = new ArrayList();\n  \t\t\tif (this.isEmpty()) {\n  \t\t\t\treturn matches;\n  \t\t\t}\n  \t\t\tif (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {\n  \t\t\t\tthis.query(searchBounds, this._root, matches);\n  \t\t\t}\n  \t\t\treturn matches;\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar searchBounds = arguments[0],\n  \t\t\t    visitor = arguments[1];\n  \t\t\tthis.build();\n  \t\t\tif (this.isEmpty()) {\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t\tif (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {\n  \t\t\t\tthis.query(searchBounds, this._root, visitor);\n  \t\t\t}\n  \t\t} else if (arguments.length === 3) {\n  \t\t\tif (hasInterface(arguments[2], ItemVisitor) && arguments[0] instanceof Object && arguments[1] instanceof AbstractNode) {\n  \t\t\t\tvar searchBounds = arguments[0],\n  \t\t\t\t    node = arguments[1],\n  \t\t\t\t    visitor = arguments[2];\n  \t\t\t\tvar childBoundables = node.getChildBoundables();\n  \t\t\t\tfor (var i = 0; i < childBoundables.size(); i++) {\n  \t\t\t\t\tvar childBoundable = childBoundables.get(i);\n  \t\t\t\t\tif (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) {\n  \t\t\t\t\t\tcontinue;\n  \t\t\t\t\t}\n  \t\t\t\t\tif (childBoundable instanceof AbstractNode) {\n  \t\t\t\t\t\tthis.query(searchBounds, childBoundable, visitor);\n  \t\t\t\t\t} else if (childBoundable instanceof ItemBoundable) {\n  \t\t\t\t\t\tvisitor.visitItem(childBoundable.getItem());\n  \t\t\t\t\t} else {\n  \t\t\t\t\t\tAssert.shouldNeverReachHere();\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t} else if (hasInterface(arguments[2], List) && arguments[0] instanceof Object && arguments[1] instanceof AbstractNode) {\n  \t\t\t\tvar searchBounds = arguments[0],\n  \t\t\t\t    node = arguments[1],\n  \t\t\t\t    matches = arguments[2];\n  \t\t\t\tvar childBoundables = node.getChildBoundables();\n  \t\t\t\tfor (var i = 0; i < childBoundables.size(); i++) {\n  \t\t\t\t\tvar childBoundable = childBoundables.get(i);\n  \t\t\t\t\tif (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) {\n  \t\t\t\t\t\tcontinue;\n  \t\t\t\t\t}\n  \t\t\t\t\tif (childBoundable instanceof AbstractNode) {\n  \t\t\t\t\t\tthis.query(searchBounds, childBoundable, matches);\n  \t\t\t\t\t} else if (childBoundable instanceof ItemBoundable) {\n  \t\t\t\t\t\tmatches.add(childBoundable.getItem());\n  \t\t\t\t\t} else {\n  \t\t\t\t\t\tAssert.shouldNeverReachHere();\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tbuild: function build() {\n  \t\tif (this._built) return null;\n  \t\tthis._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1);\n  \t\tthis._itemBoundables = null;\n  \t\tthis._built = true;\n  \t},\n  \tgetRoot: function getRoot() {\n  \t\tthis.build();\n  \t\treturn this._root;\n  \t},\n  \tremove: function remove() {\n  \t\tif (arguments.length === 2) {\n  \t\t\tvar searchBounds = arguments[0],\n  \t\t\t    item = arguments[1];\n  \t\t\tthis.build();\n  \t\t\tif (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {\n  \t\t\t\treturn this.remove(searchBounds, this._root, item);\n  \t\t\t}\n  \t\t\treturn false;\n  \t\t} else if (arguments.length === 3) {\n  \t\t\tvar searchBounds = arguments[0],\n  \t\t\t    node = arguments[1],\n  \t\t\t    item = arguments[2];\n  \t\t\tvar found = this.removeItem(node, item);\n  \t\t\tif (found) return true;\n  \t\t\tvar childToPrune = null;\n  \t\t\tfor (var i = node.getChildBoundables().iterator(); i.hasNext();) {\n  \t\t\t\tvar childBoundable = i.next();\n  \t\t\t\tif (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) {\n  \t\t\t\t\tcontinue;\n  \t\t\t\t}\n  \t\t\t\tif (childBoundable instanceof AbstractNode) {\n  \t\t\t\t\tfound = this.remove(searchBounds, childBoundable, item);\n  \t\t\t\t\tif (found) {\n  \t\t\t\t\t\tchildToPrune = childBoundable;\n  \t\t\t\t\t\tbreak;\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\tif (childToPrune !== null) {\n  \t\t\t\tif (childToPrune.getChildBoundables().isEmpty()) {\n  \t\t\t\t\tnode.getChildBoundables().remove(childToPrune);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\treturn found;\n  \t\t}\n  \t},\n  \tcreateHigherLevels: function createHigherLevels(boundablesOfALevel, level) {\n  \t\tAssert.isTrue(!boundablesOfALevel.isEmpty());\n  \t\tvar parentBoundables = this.createParentBoundables(boundablesOfALevel, level + 1);\n  \t\tif (parentBoundables.size() === 1) {\n  \t\t\treturn parentBoundables.get(0);\n  \t\t}\n  \t\treturn this.createHigherLevels(parentBoundables, level + 1);\n  \t},\n  \tdepth: function depth() {\n  \t\tif (arguments.length === 0) {\n  \t\t\tif (this.isEmpty()) {\n  \t\t\t\treturn 0;\n  \t\t\t}\n  \t\t\tthis.build();\n  \t\t\treturn this.depth(this._root);\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tvar node = arguments[0];\n  \t\t\tvar maxChildDepth = 0;\n  \t\t\tfor (var i = node.getChildBoundables().iterator(); i.hasNext();) {\n  \t\t\t\tvar childBoundable = i.next();\n  \t\t\t\tif (childBoundable instanceof AbstractNode) {\n  \t\t\t\t\tvar childDepth = this.depth(childBoundable);\n  \t\t\t\t\tif (childDepth > maxChildDepth) maxChildDepth = childDepth;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\treturn maxChildDepth + 1;\n  \t\t}\n  \t},\n  \tcreateParentBoundables: function createParentBoundables(childBoundables, newLevel) {\n  \t\tAssert.isTrue(!childBoundables.isEmpty());\n  \t\tvar parentBoundables = new ArrayList();\n  \t\tparentBoundables.add(this.createNode(newLevel));\n  \t\tvar sortedChildBoundables = new ArrayList(childBoundables);\n  \t\tCollections.sort(sortedChildBoundables, this.getComparator());\n  \t\tfor (var i = sortedChildBoundables.iterator(); i.hasNext();) {\n  \t\t\tvar childBoundable = i.next();\n  \t\t\tif (this.lastNode(parentBoundables).getChildBoundables().size() === this.getNodeCapacity()) {\n  \t\t\t\tparentBoundables.add(this.createNode(newLevel));\n  \t\t\t}\n  \t\t\tthis.lastNode(parentBoundables).addChildBoundable(childBoundable);\n  \t\t}\n  \t\treturn parentBoundables;\n  \t},\n  \tisEmpty: function isEmpty() {\n  \t\tif (!this._built) return this._itemBoundables.isEmpty();\n  \t\treturn this._root.isEmpty();\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Serializable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn AbstractSTRtree;\n  \t}\n  });\n  AbstractSTRtree.compareDoubles = function (a, b) {\n  \treturn a > b ? 1 : a < b ? -1 : 0;\n  };\n  function IntersectsOp$1() {}\n  AbstractSTRtree.IntersectsOp = IntersectsOp$1;\n  AbstractSTRtree.serialVersionUID = -3886435814360241337;\n  AbstractSTRtree.DEFAULT_NODE_CAPACITY = 10;\n\n  function ItemDistance() {}\n  extend(ItemDistance.prototype, {\n  \tdistance: function distance(item1, item2) {},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn ItemDistance;\n  \t}\n  });\n\n  function STRtree() {\n  \tif (arguments.length === 0) {\n  \t\tSTRtree.call(this, STRtree.DEFAULT_NODE_CAPACITY);\n  \t} else if (arguments.length === 1) {\n  \t\tvar nodeCapacity = arguments[0];\n  \t\tAbstractSTRtree.call(this, nodeCapacity);\n  \t}\n  }\n  inherits$1(STRtree, AbstractSTRtree);\n  extend(STRtree.prototype, {\n  \tcreateParentBoundablesFromVerticalSlices: function createParentBoundablesFromVerticalSlices(verticalSlices, newLevel) {\n  \t\tAssert.isTrue(verticalSlices.length > 0);\n  \t\tvar parentBoundables = new ArrayList();\n  \t\tfor (var i = 0; i < verticalSlices.length; i++) {\n  \t\t\tparentBoundables.addAll(this.createParentBoundablesFromVerticalSlice(verticalSlices[i], newLevel));\n  \t\t}\n  \t\treturn parentBoundables;\n  \t},\n  \tcreateNode: function createNode(level) {\n  \t\treturn new STRtreeNode(level);\n  \t},\n  \tsize: function size() {\n  \t\tif (arguments.length === 0) {\n  \t\t\treturn AbstractSTRtree.prototype.size.call(this);\n  \t\t} else return AbstractSTRtree.prototype.size.apply(this, arguments);\n  \t},\n  \tinsert: function insert() {\n  \t\tif (arguments.length === 2) {\n  \t\t\tvar itemEnv = arguments[0],\n  \t\t\t    item = arguments[1];\n  \t\t\tif (itemEnv.isNull()) {\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t\tAbstractSTRtree.prototype.insert.call(this, itemEnv, item);\n  \t\t} else return AbstractSTRtree.prototype.insert.apply(this, arguments);\n  \t},\n  \tgetIntersectsOp: function getIntersectsOp() {\n  \t\treturn STRtree.intersectsOp;\n  \t},\n  \tverticalSlices: function verticalSlices(childBoundables, sliceCount) {\n  \t\tvar sliceCapacity = Math.trunc(Math.ceil(childBoundables.size() / sliceCount));\n  \t\tvar slices = new Array(sliceCount).fill(null);\n  \t\tvar i = childBoundables.iterator();\n  \t\tfor (var j = 0; j < sliceCount; j++) {\n  \t\t\tslices[j] = new ArrayList();\n  \t\t\tvar boundablesAddedToSlice = 0;\n  \t\t\twhile (i.hasNext() && boundablesAddedToSlice < sliceCapacity) {\n  \t\t\t\tvar childBoundable = i.next();\n  \t\t\t\tslices[j].add(childBoundable);\n  \t\t\t\tboundablesAddedToSlice++;\n  \t\t\t}\n  \t\t}\n  \t\treturn slices;\n  \t},\n  \tquery: function query() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar searchEnv = arguments[0];\n  \t\t\treturn AbstractSTRtree.prototype.query.call(this, searchEnv);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar searchEnv = arguments[0],\n  \t\t\t    visitor = arguments[1];\n  \t\t\tAbstractSTRtree.prototype.query.call(this, searchEnv, visitor);\n  \t\t} else if (arguments.length === 3) {\n  \t\t\tif (hasInterface(arguments[2], ItemVisitor) && arguments[0] instanceof Object && arguments[1] instanceof AbstractNode) {\n  \t\t\t\tvar searchBounds = arguments[0],\n  \t\t\t\t    node = arguments[1],\n  \t\t\t\t    visitor = arguments[2];\n  \t\t\t\tAbstractSTRtree.prototype.query.call(this, searchBounds, node, visitor);\n  \t\t\t} else if (hasInterface(arguments[2], List) && arguments[0] instanceof Object && arguments[1] instanceof AbstractNode) {\n  \t\t\t\tvar searchBounds = arguments[0],\n  \t\t\t\t    node = arguments[1],\n  \t\t\t\t    matches = arguments[2];\n  \t\t\t\tAbstractSTRtree.prototype.query.call(this, searchBounds, node, matches);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetComparator: function getComparator() {\n  \t\treturn STRtree.yComparator;\n  \t},\n  \tcreateParentBoundablesFromVerticalSlice: function createParentBoundablesFromVerticalSlice(childBoundables, newLevel) {\n  \t\treturn AbstractSTRtree.prototype.createParentBoundables.call(this, childBoundables, newLevel);\n  \t},\n  \tremove: function remove() {\n  \t\tif (arguments.length === 2) {\n  \t\t\tvar itemEnv = arguments[0],\n  \t\t\t    item = arguments[1];\n  \t\t\treturn AbstractSTRtree.prototype.remove.call(this, itemEnv, item);\n  \t\t} else return AbstractSTRtree.prototype.remove.apply(this, arguments);\n  \t},\n  \tdepth: function depth() {\n  \t\tif (arguments.length === 0) {\n  \t\t\treturn AbstractSTRtree.prototype.depth.call(this);\n  \t\t} else return AbstractSTRtree.prototype.depth.apply(this, arguments);\n  \t},\n  \tcreateParentBoundables: function createParentBoundables(childBoundables, newLevel) {\n  \t\tAssert.isTrue(!childBoundables.isEmpty());\n  \t\tvar minLeafCount = Math.trunc(Math.ceil(childBoundables.size() / this.getNodeCapacity()));\n  \t\tvar sortedChildBoundables = new ArrayList(childBoundables);\n  \t\tCollections.sort(sortedChildBoundables, STRtree.xComparator);\n  \t\tvar verticalSlices = this.verticalSlices(sortedChildBoundables, Math.trunc(Math.ceil(Math.sqrt(minLeafCount))));\n  \t\treturn this.createParentBoundablesFromVerticalSlices(verticalSlices, newLevel);\n  \t},\n  \tnearestNeighbour: function nearestNeighbour() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tif (hasInterface(arguments[0], ItemDistance)) {\n  \t\t\t\tvar itemDist = arguments[0];\n  \t\t\t\tvar bp = new BoundablePair(this.getRoot(), this.getRoot(), itemDist);\n  \t\t\t\treturn this.nearestNeighbour(bp);\n  \t\t\t} else if (arguments[0] instanceof BoundablePair) {\n  \t\t\t\tvar initBndPair = arguments[0];\n  \t\t\t\treturn this.nearestNeighbour(initBndPair, Double.POSITIVE_INFINITY);\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tif (arguments[0] instanceof STRtree && hasInterface(arguments[1], ItemDistance)) {\n  \t\t\t\tvar tree = arguments[0],\n  \t\t\t\t    itemDist = arguments[1];\n  \t\t\t\tvar bp = new BoundablePair(this.getRoot(), tree.getRoot(), itemDist);\n  \t\t\t\treturn this.nearestNeighbour(bp);\n  \t\t\t} else if (arguments[0] instanceof BoundablePair && typeof arguments[1] === \"number\") {\n  \t\t\t\tvar initBndPair = arguments[0],\n  \t\t\t\t    maxDistance = arguments[1];\n  \t\t\t\tvar distanceLowerBound = maxDistance;\n  \t\t\t\tvar minPair = null;\n  \t\t\t\tvar priQ = new PriorityQueue();\n  \t\t\t\tpriQ.add(initBndPair);\n  \t\t\t\twhile (!priQ.isEmpty() && distanceLowerBound > 0.0) {\n  \t\t\t\t\tvar bndPair = priQ.poll();\n  \t\t\t\t\tvar currentDistance = bndPair.getDistance();\n  \t\t\t\t\tif (currentDistance >= distanceLowerBound) break;\n  \t\t\t\t\tif (bndPair.isLeaves()) {\n  \t\t\t\t\t\tdistanceLowerBound = currentDistance;\n  \t\t\t\t\t\tminPair = bndPair;\n  \t\t\t\t\t} else {\n  \t\t\t\t\t\tbndPair.expandToQueue(priQ, distanceLowerBound);\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t\treturn [minPair.getBoundable(0).getItem(), minPair.getBoundable(1).getItem()];\n  \t\t\t}\n  \t\t} else if (arguments.length === 3) {\n  \t\t\tvar env = arguments[0],\n  \t\t\t    item = arguments[1],\n  \t\t\t    itemDist = arguments[2];\n  \t\t\tvar bnd = new ItemBoundable(env, item);\n  \t\t\tvar bp = new BoundablePair(this.getRoot(), bnd, itemDist);\n  \t\t\treturn this.nearestNeighbour(bp)[0];\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [SpatialIndex, Serializable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn STRtree;\n  \t}\n  });\n  STRtree.centreX = function (e) {\n  \treturn STRtree.avg(e.getMinX(), e.getMaxX());\n  };\n  STRtree.avg = function (a, b) {\n  \treturn (a + b) / 2;\n  };\n  STRtree.centreY = function (e) {\n  \treturn STRtree.avg(e.getMinY(), e.getMaxY());\n  };\n  function STRtreeNode() {\n  \tvar level = arguments[0];\n  \tAbstractNode.call(this, level);\n  }\n  inherits$1(STRtreeNode, AbstractNode);\n  extend(STRtreeNode.prototype, {\n  \tcomputeBounds: function computeBounds() {\n  \t\tvar bounds = null;\n  \t\tfor (var i = this.getChildBoundables().iterator(); i.hasNext();) {\n  \t\t\tvar childBoundable = i.next();\n  \t\t\tif (bounds === null) {\n  \t\t\t\tbounds = new Envelope(childBoundable.getBounds());\n  \t\t\t} else {\n  \t\t\t\tbounds.expandToInclude(childBoundable.getBounds());\n  \t\t\t}\n  \t\t}\n  \t\treturn bounds;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn STRtreeNode;\n  \t}\n  });\n  STRtree.STRtreeNode = STRtreeNode;\n  STRtree.serialVersionUID = 259274702368956900;\n  STRtree.xComparator = {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparator];\n  \t},\n  \tcompare: function compare(o1, o2) {\n  \t\treturn AbstractSTRtree.compareDoubles(STRtree.centreX(o1.getBounds()), STRtree.centreX(o2.getBounds()));\n  \t}\n  };\n  STRtree.yComparator = {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparator];\n  \t},\n  \tcompare: function compare(o1, o2) {\n  \t\treturn AbstractSTRtree.compareDoubles(STRtree.centreY(o1.getBounds()), STRtree.centreY(o2.getBounds()));\n  \t}\n  };\n  STRtree.intersectsOp = {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [IntersectsOp];\n  \t},\n  \tintersects: function intersects(aBounds, bBounds) {\n  \t\treturn aBounds.intersects(bBounds);\n  \t}\n  };\n  STRtree.DEFAULT_NODE_CAPACITY = 10;\n\n  function SegmentPointComparator() {}\n  extend(SegmentPointComparator.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SegmentPointComparator;\n  \t}\n  });\n  SegmentPointComparator.relativeSign = function (x0, x1) {\n  \tif (x0 < x1) return -1;\n  \tif (x0 > x1) return 1;\n  \treturn 0;\n  };\n  SegmentPointComparator.compare = function (octant, p0, p1) {\n  \tif (p0.equals2D(p1)) return 0;\n  \tvar xSign = SegmentPointComparator.relativeSign(p0.x, p1.x);\n  \tvar ySign = SegmentPointComparator.relativeSign(p0.y, p1.y);\n  \tswitch (octant) {\n  \t\tcase 0:\n  \t\t\treturn SegmentPointComparator.compareValue(xSign, ySign);\n  \t\tcase 1:\n  \t\t\treturn SegmentPointComparator.compareValue(ySign, xSign);\n  \t\tcase 2:\n  \t\t\treturn SegmentPointComparator.compareValue(ySign, -xSign);\n  \t\tcase 3:\n  \t\t\treturn SegmentPointComparator.compareValue(-xSign, ySign);\n  \t\tcase 4:\n  \t\t\treturn SegmentPointComparator.compareValue(-xSign, -ySign);\n  \t\tcase 5:\n  \t\t\treturn SegmentPointComparator.compareValue(-ySign, -xSign);\n  \t\tcase 6:\n  \t\t\treturn SegmentPointComparator.compareValue(-ySign, xSign);\n  \t\tcase 7:\n  \t\t\treturn SegmentPointComparator.compareValue(xSign, -ySign);\n  \t}\n  \tAssert.shouldNeverReachHere(\"invalid octant value\");\n  \treturn 0;\n  };\n  SegmentPointComparator.compareValue = function (compareSign0, compareSign1) {\n  \tif (compareSign0 < 0) return -1;\n  \tif (compareSign0 > 0) return 1;\n  \tif (compareSign1 < 0) return -1;\n  \tif (compareSign1 > 0) return 1;\n  \treturn 0;\n  };\n\n  function SegmentNode() {\n  \tthis._segString = null;\n  \tthis.coord = null;\n  \tthis.segmentIndex = null;\n  \tthis._segmentOctant = null;\n  \tthis._isInterior = null;\n  \tvar segString = arguments[0],\n  \t    coord = arguments[1],\n  \t    segmentIndex = arguments[2],\n  \t    segmentOctant = arguments[3];\n  \tthis._segString = segString;\n  \tthis.coord = new Coordinate(coord);\n  \tthis.segmentIndex = segmentIndex;\n  \tthis._segmentOctant = segmentOctant;\n  \tthis._isInterior = !coord.equals2D(segString.getCoordinate(segmentIndex));\n  }\n  extend(SegmentNode.prototype, {\n  \tgetCoordinate: function getCoordinate() {\n  \t\treturn this.coord;\n  \t},\n  \tprint: function print(out) {\n  \t\tout.print(this.coord);\n  \t\tout.print(\" seg # = \" + this.segmentIndex);\n  \t},\n  \tcompareTo: function compareTo(obj) {\n  \t\tvar other = obj;\n  \t\tif (this.segmentIndex < other.segmentIndex) return -1;\n  \t\tif (this.segmentIndex > other.segmentIndex) return 1;\n  \t\tif (this.coord.equals2D(other.coord)) return 0;\n  \t\treturn SegmentPointComparator.compare(this._segmentOctant, this.coord, other.coord);\n  \t},\n  \tisEndPoint: function isEndPoint(maxSegmentIndex) {\n  \t\tif (this.segmentIndex === 0 && !this._isInterior) return true;\n  \t\tif (this.segmentIndex === maxSegmentIndex) return true;\n  \t\treturn false;\n  \t},\n  \tisInterior: function isInterior() {\n  \t\treturn this._isInterior;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SegmentNode;\n  \t}\n  });\n\n  function SegmentNodeList() {\n  \tthis._nodeMap = new TreeMap();\n  \tthis._edge = null;\n  \tvar edge = arguments[0];\n  \tthis._edge = edge;\n  }\n  extend(SegmentNodeList.prototype, {\n  \tgetSplitCoordinates: function getSplitCoordinates() {\n  \t\tvar coordList = new CoordinateList();\n  \t\tthis.addEndpoints();\n  \t\tvar it = this.iterator();\n  \t\tvar eiPrev = it.next();\n  \t\twhile (it.hasNext()) {\n  \t\t\tvar ei = it.next();\n  \t\t\tthis.addEdgeCoordinates(eiPrev, ei, coordList);\n  \t\t\teiPrev = ei;\n  \t\t}\n  \t\treturn coordList.toCoordinateArray();\n  \t},\n  \taddCollapsedNodes: function addCollapsedNodes() {\n  \t\tvar collapsedVertexIndexes = new ArrayList();\n  \t\tthis.findCollapsesFromInsertedNodes(collapsedVertexIndexes);\n  \t\tthis.findCollapsesFromExistingVertices(collapsedVertexIndexes);\n  \t\tfor (var it = collapsedVertexIndexes.iterator(); it.hasNext();) {\n  \t\t\tvar vertexIndex = it.next().intValue();\n  \t\t\tthis.add(this._edge.getCoordinate(vertexIndex), vertexIndex);\n  \t\t}\n  \t},\n  \tprint: function print(out) {\n  \t\tout.println(\"Intersections:\");\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar ei = it.next();\n  \t\t\tei.print(out);\n  \t\t}\n  \t},\n  \tfindCollapsesFromExistingVertices: function findCollapsesFromExistingVertices(collapsedVertexIndexes) {\n  \t\tfor (var i = 0; i < this._edge.size() - 2; i++) {\n  \t\t\tvar p0 = this._edge.getCoordinate(i);\n  \t\t\tvar p1 = this._edge.getCoordinate(i + 1);\n  \t\t\tvar p2 = this._edge.getCoordinate(i + 2);\n  \t\t\tif (p0.equals2D(p2)) {\n  \t\t\t\tcollapsedVertexIndexes.add(new Integer(i + 1));\n  \t\t\t}\n  \t\t}\n  \t},\n  \taddEdgeCoordinates: function addEdgeCoordinates(ei0, ei1, coordList) {\n  \t\tvar npts = ei1.segmentIndex - ei0.segmentIndex + 2;\n  \t\tvar lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);\n  \t\tvar useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);\n  \t\tif (!useIntPt1) {\n  \t\t\tnpts--;\n  \t\t}\n  \t\tcoordList.add(new Coordinate(ei0.coord), false);\n  \t\tfor (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {\n  \t\t\tcoordList.add(this._edge.getCoordinate(i));\n  \t\t}\n  \t\tif (useIntPt1) {\n  \t\t\tcoordList.add(new Coordinate(ei1.coord));\n  \t\t}\n  \t},\n  \titerator: function iterator() {\n  \t\treturn this._nodeMap.values().iterator();\n  \t},\n  \taddSplitEdges: function addSplitEdges(edgeList) {\n  \t\tthis.addEndpoints();\n  \t\tthis.addCollapsedNodes();\n  \t\tvar it = this.iterator();\n  \t\tvar eiPrev = it.next();\n  \t\twhile (it.hasNext()) {\n  \t\t\tvar ei = it.next();\n  \t\t\tvar newEdge = this.createSplitEdge(eiPrev, ei);\n  \t\t\tedgeList.add(newEdge);\n  \t\t\teiPrev = ei;\n  \t\t}\n  \t},\n  \tfindCollapseIndex: function findCollapseIndex(ei0, ei1, collapsedVertexIndex) {\n  \t\tif (!ei0.coord.equals2D(ei1.coord)) return false;\n  \t\tvar numVerticesBetween = ei1.segmentIndex - ei0.segmentIndex;\n  \t\tif (!ei1.isInterior()) {\n  \t\t\tnumVerticesBetween--;\n  \t\t}\n  \t\tif (numVerticesBetween === 1) {\n  \t\t\tcollapsedVertexIndex[0] = ei0.segmentIndex + 1;\n  \t\t\treturn true;\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tfindCollapsesFromInsertedNodes: function findCollapsesFromInsertedNodes(collapsedVertexIndexes) {\n  \t\tvar collapsedVertexIndex = new Array(1).fill(null);\n  \t\tvar it = this.iterator();\n  \t\tvar eiPrev = it.next();\n  \t\twhile (it.hasNext()) {\n  \t\t\tvar ei = it.next();\n  \t\t\tvar isCollapsed = this.findCollapseIndex(eiPrev, ei, collapsedVertexIndex);\n  \t\t\tif (isCollapsed) collapsedVertexIndexes.add(new Integer(collapsedVertexIndex[0]));\n  \t\t\teiPrev = ei;\n  \t\t}\n  \t},\n  \tgetEdge: function getEdge() {\n  \t\treturn this._edge;\n  \t},\n  \taddEndpoints: function addEndpoints() {\n  \t\tvar maxSegIndex = this._edge.size() - 1;\n  \t\tthis.add(this._edge.getCoordinate(0), 0);\n  \t\tthis.add(this._edge.getCoordinate(maxSegIndex), maxSegIndex);\n  \t},\n  \tcreateSplitEdge: function createSplitEdge(ei0, ei1) {\n  \t\tvar npts = ei1.segmentIndex - ei0.segmentIndex + 2;\n  \t\tvar lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);\n  \t\tvar useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);\n  \t\tif (!useIntPt1) {\n  \t\t\tnpts--;\n  \t\t}\n  \t\tvar pts = new Array(npts).fill(null);\n  \t\tvar ipt = 0;\n  \t\tpts[ipt++] = new Coordinate(ei0.coord);\n  \t\tfor (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {\n  \t\t\tpts[ipt++] = this._edge.getCoordinate(i);\n  \t\t}\n  \t\tif (useIntPt1) pts[ipt] = new Coordinate(ei1.coord);\n  \t\treturn new NodedSegmentString(pts, this._edge.getData());\n  \t},\n  \tadd: function add(intPt, segmentIndex) {\n  \t\tvar eiNew = new SegmentNode(this._edge, intPt, segmentIndex, this._edge.getSegmentOctant(segmentIndex));\n  \t\tvar ei = this._nodeMap.get(eiNew);\n  \t\tif (ei !== null) {\n  \t\t\tAssert.isTrue(ei.coord.equals2D(intPt), \"Found equal nodes with different coordinates\");\n  \t\t\treturn ei;\n  \t\t}\n  \t\tthis._nodeMap.put(eiNew, eiNew);\n  \t\treturn eiNew;\n  \t},\n  \tcheckSplitEdgesCorrectness: function checkSplitEdgesCorrectness(splitEdges) {\n  \t\tvar edgePts = this._edge.getCoordinates();\n  \t\tvar split0 = splitEdges.get(0);\n  \t\tvar pt0 = split0.getCoordinate(0);\n  \t\tif (!pt0.equals2D(edgePts[0])) throw new RuntimeException(\"bad split edge start point at \" + pt0);\n  \t\tvar splitn = splitEdges.get(splitEdges.size() - 1);\n  \t\tvar splitnPts = splitn.getCoordinates();\n  \t\tvar ptn = splitnPts[splitnPts.length - 1];\n  \t\tif (!ptn.equals2D(edgePts[edgePts.length - 1])) throw new RuntimeException(\"bad split edge end point at \" + ptn);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SegmentNodeList;\n  \t}\n  });\n  function NodeVertexIterator() {\n  \tthis._nodeList = null;\n  \tthis._edge = null;\n  \tthis._nodeIt = null;\n  \tthis._currNode = null;\n  \tthis._nextNode = null;\n  \tthis._currSegIndex = 0;\n  \tvar nodeList = arguments[0];\n  \tthis._nodeList = nodeList;\n  \tthis._edge = nodeList.getEdge();\n  \tthis._nodeIt = nodeList.iterator();\n  \tthis.readNextNode();\n  }\n  extend(NodeVertexIterator.prototype, {\n  \tnext: function next() {\n  \t\tif (this._currNode === null) {\n  \t\t\tthis._currNode = this._nextNode;\n  \t\t\tthis._currSegIndex = this._currNode.segmentIndex;\n  \t\t\tthis.readNextNode();\n  \t\t\treturn this._currNode;\n  \t\t}\n  \t\tif (this._nextNode === null) return null;\n  \t\tif (this._nextNode.segmentIndex === this._currNode.segmentIndex) {\n  \t\t\tthis._currNode = this._nextNode;\n  \t\t\tthis._currSegIndex = this._currNode.segmentIndex;\n  \t\t\tthis.readNextNode();\n  \t\t\treturn this._currNode;\n  \t\t}\n  \t\tif (this._nextNode.segmentIndex > this._currNode.segmentIndex) ;\n  \t\treturn null;\n  \t},\n  \tremove: function remove() {\n  \t\tthrow new UnsupportedOperationException(this.getClass().getName());\n  \t},\n  \thasNext: function hasNext() {\n  \t\tif (this._nextNode === null) return false;\n  \t\treturn true;\n  \t},\n  \treadNextNode: function readNextNode() {\n  \t\tif (this._nodeIt.hasNext()) this._nextNode = this._nodeIt.next();else this._nextNode = null;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Iterator];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn NodeVertexIterator;\n  \t}\n  });\n\n  function NodableSegmentString() {}\n  extend(NodableSegmentString.prototype, {\n  \taddIntersection: function addIntersection(intPt, segmentIndex) {},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [SegmentString];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn NodableSegmentString;\n  \t}\n  });\n\n  function NodedSegmentString() {\n  \tthis._nodeList = new SegmentNodeList(this);\n  \tthis._pts = null;\n  \tthis._data = null;\n  \tvar pts = arguments[0],\n  \t    data = arguments[1];\n  \tthis._pts = pts;\n  \tthis._data = data;\n  }\n  extend(NodedSegmentString.prototype, {\n  \tgetCoordinates: function getCoordinates() {\n  \t\treturn this._pts;\n  \t},\n  \tsize: function size() {\n  \t\treturn this._pts.length;\n  \t},\n  \tgetCoordinate: function getCoordinate(i) {\n  \t\treturn this._pts[i];\n  \t},\n  \tisClosed: function isClosed() {\n  \t\treturn this._pts[0].equals(this._pts[this._pts.length - 1]);\n  \t},\n  \tgetSegmentOctant: function getSegmentOctant(index) {\n  \t\tif (index === this._pts.length - 1) return -1;\n  \t\treturn this.safeOctant(this.getCoordinate(index), this.getCoordinate(index + 1));\n  \t},\n  \tsetData: function setData(data) {\n  \t\tthis._data = data;\n  \t},\n  \tsafeOctant: function safeOctant(p0, p1) {\n  \t\tif (p0.equals2D(p1)) return 0;\n  \t\treturn Octant.octant(p0, p1);\n  \t},\n  \tgetData: function getData() {\n  \t\treturn this._data;\n  \t},\n  \taddIntersection: function addIntersection() {\n  \t\tif (arguments.length === 2) {\n  \t\t\tvar intPt = arguments[0],\n  \t\t\t    segmentIndex = arguments[1];\n  \t\t\tthis.addIntersectionNode(intPt, segmentIndex);\n  \t\t} else if (arguments.length === 4) {\n  \t\t\tvar li = arguments[0],\n  \t\t\t    segmentIndex = arguments[1],\n  \t\t\t    intIndex = arguments[3];\n  \t\t\tvar intPt = new Coordinate(li.getIntersection(intIndex));\n  \t\t\tthis.addIntersection(intPt, segmentIndex);\n  \t\t}\n  \t},\n  \ttoString: function toString() {\n  \t\treturn WKTWriter.toLineString(new CoordinateArraySequence(this._pts));\n  \t},\n  \tgetNodeList: function getNodeList() {\n  \t\treturn this._nodeList;\n  \t},\n  \taddIntersectionNode: function addIntersectionNode(intPt, segmentIndex) {\n  \t\tvar normalizedSegmentIndex = segmentIndex;\n  \t\tvar nextSegIndex = normalizedSegmentIndex + 1;\n  \t\tif (nextSegIndex < this._pts.length) {\n  \t\t\tvar nextPt = this._pts[nextSegIndex];\n  \t\t\tif (intPt.equals2D(nextPt)) {\n  \t\t\t\tnormalizedSegmentIndex = nextSegIndex;\n  \t\t\t}\n  \t\t}\n  \t\tvar ei = this._nodeList.add(intPt, normalizedSegmentIndex);\n  \t\treturn ei;\n  \t},\n  \taddIntersections: function addIntersections(li, segmentIndex, geomIndex) {\n  \t\tfor (var i = 0; i < li.getIntersectionNum(); i++) {\n  \t\t\tthis.addIntersection(li, segmentIndex, geomIndex, i);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [NodableSegmentString];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn NodedSegmentString;\n  \t}\n  });\n  NodedSegmentString.getNodedSubstrings = function () {\n  \tif (arguments.length === 1) {\n  \t\tvar segStrings = arguments[0];\n  \t\tvar resultEdgelist = new ArrayList();\n  \t\tNodedSegmentString.getNodedSubstrings(segStrings, resultEdgelist);\n  \t\treturn resultEdgelist;\n  \t} else if (arguments.length === 2) {\n  \t\tvar segStrings = arguments[0],\n  \t\t    resultEdgelist = arguments[1];\n  \t\tfor (var i = segStrings.iterator(); i.hasNext();) {\n  \t\t\tvar ss = i.next();\n  \t\t\tss.getNodeList().addSplitEdges(resultEdgelist);\n  \t\t}\n  \t}\n  };\n\n  function MonotoneChainOverlapAction() {\n  \tthis.tempEnv1 = new Envelope();\n  \tthis.tempEnv2 = new Envelope();\n  \tthis._overlapSeg1 = new LineSegment();\n  \tthis._overlapSeg2 = new LineSegment();\n  }\n  extend(MonotoneChainOverlapAction.prototype, {\n  \toverlap: function overlap() {\n  \t\tif (arguments.length === 2) ; else if (arguments.length === 4) {\n  \t\t\tvar mc1 = arguments[0],\n  \t\t\t    start1 = arguments[1],\n  \t\t\t    mc2 = arguments[2],\n  \t\t\t    start2 = arguments[3];\n  \t\t\tmc1.getLineSegment(start1, this._overlapSeg1);\n  \t\t\tmc2.getLineSegment(start2, this._overlapSeg2);\n  \t\t\tthis.overlap(this._overlapSeg1, this._overlapSeg2);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MonotoneChainOverlapAction;\n  \t}\n  });\n\n  function MonotoneChain() {\n  \tthis._pts = null;\n  \tthis._start = null;\n  \tthis._end = null;\n  \tthis._env = null;\n  \tthis._context = null;\n  \tthis._id = null;\n  \tvar pts = arguments[0],\n  \t    start = arguments[1],\n  \t    end = arguments[2],\n  \t    context = arguments[3];\n  \tthis._pts = pts;\n  \tthis._start = start;\n  \tthis._end = end;\n  \tthis._context = context;\n  }\n  extend(MonotoneChain.prototype, {\n  \tgetLineSegment: function getLineSegment(index, ls) {\n  \t\tls.p0 = this._pts[index];\n  \t\tls.p1 = this._pts[index + 1];\n  \t},\n  \tcomputeSelect: function computeSelect(searchEnv, start0, end0, mcs) {\n  \t\tvar p0 = this._pts[start0];\n  \t\tvar p1 = this._pts[end0];\n  \t\tmcs.tempEnv1.init(p0, p1);\n  \t\tif (end0 - start0 === 1) {\n  \t\t\tmcs.select(this, start0);\n  \t\t\treturn null;\n  \t\t}\n  \t\tif (!searchEnv.intersects(mcs.tempEnv1)) return null;\n  \t\tvar mid = Math.trunc((start0 + end0) / 2);\n  \t\tif (start0 < mid) {\n  \t\t\tthis.computeSelect(searchEnv, start0, mid, mcs);\n  \t\t}\n  \t\tif (mid < end0) {\n  \t\t\tthis.computeSelect(searchEnv, mid, end0, mcs);\n  \t\t}\n  \t},\n  \tgetCoordinates: function getCoordinates() {\n  \t\tvar coord = new Array(this._end - this._start + 1).fill(null);\n  \t\tvar index = 0;\n  \t\tfor (var i = this._start; i <= this._end; i++) {\n  \t\t\tcoord[index++] = this._pts[i];\n  \t\t}\n  \t\treturn coord;\n  \t},\n  \tcomputeOverlaps: function computeOverlaps(mc, mco) {\n  \t\tthis.computeOverlapsInternal(this._start, this._end, mc, mc._start, mc._end, mco);\n  \t},\n  \tsetId: function setId(id) {\n  \t\tthis._id = id;\n  \t},\n  \tselect: function select(searchEnv, mcs) {\n  \t\tthis.computeSelect(searchEnv, this._start, this._end, mcs);\n  \t},\n  \tgetEnvelope: function getEnvelope() {\n  \t\tif (this._env === null) {\n  \t\t\tvar p0 = this._pts[this._start];\n  \t\t\tvar p1 = this._pts[this._end];\n  \t\t\tthis._env = new Envelope(p0, p1);\n  \t\t}\n  \t\treturn this._env;\n  \t},\n  \tgetEndIndex: function getEndIndex() {\n  \t\treturn this._end;\n  \t},\n  \tgetStartIndex: function getStartIndex() {\n  \t\treturn this._start;\n  \t},\n  \tgetContext: function getContext() {\n  \t\treturn this._context;\n  \t},\n  \tgetId: function getId() {\n  \t\treturn this._id;\n  \t},\n  \tcomputeOverlapsInternal: function computeOverlapsInternal(start0, end0, mc, start1, end1, mco) {\n  \t\tvar p00 = this._pts[start0];\n  \t\tvar p01 = this._pts[end0];\n  \t\tvar p10 = mc._pts[start1];\n  \t\tvar p11 = mc._pts[end1];\n  \t\tif (end0 - start0 === 1 && end1 - start1 === 1) {\n  \t\t\tmco.overlap(this, start0, mc, start1);\n  \t\t\treturn null;\n  \t\t}\n  \t\tmco.tempEnv1.init(p00, p01);\n  \t\tmco.tempEnv2.init(p10, p11);\n  \t\tif (!mco.tempEnv1.intersects(mco.tempEnv2)) return null;\n  \t\tvar mid0 = Math.trunc((start0 + end0) / 2);\n  \t\tvar mid1 = Math.trunc((start1 + end1) / 2);\n  \t\tif (start0 < mid0) {\n  \t\t\tif (start1 < mid1) this.computeOverlapsInternal(start0, mid0, mc, start1, mid1, mco);\n  \t\t\tif (mid1 < end1) this.computeOverlapsInternal(start0, mid0, mc, mid1, end1, mco);\n  \t\t}\n  \t\tif (mid0 < end0) {\n  \t\t\tif (start1 < mid1) this.computeOverlapsInternal(mid0, end0, mc, start1, mid1, mco);\n  \t\t\tif (mid1 < end1) this.computeOverlapsInternal(mid0, end0, mc, mid1, end1, mco);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MonotoneChain;\n  \t}\n  });\n\n  function Quadrant() {}\n  extend(Quadrant.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Quadrant;\n  \t}\n  });\n  Quadrant.isNorthern = function (quad) {\n  \treturn quad === Quadrant.NE || quad === Quadrant.NW;\n  };\n  Quadrant.isOpposite = function (quad1, quad2) {\n  \tif (quad1 === quad2) return false;\n  \tvar diff = (quad1 - quad2 + 4) % 4;\n  \tif (diff === 2) return true;\n  \treturn false;\n  };\n  Quadrant.commonHalfPlane = function (quad1, quad2) {\n  \tif (quad1 === quad2) return quad1;\n  \tvar diff = (quad1 - quad2 + 4) % 4;\n  \tif (diff === 2) return -1;\n  \tvar min = quad1 < quad2 ? quad1 : quad2;\n  \tvar max = quad1 > quad2 ? quad1 : quad2;\n  \tif (min === 0 && max === 3) return 3;\n  \treturn min;\n  };\n  Quadrant.isInHalfPlane = function (quad, halfPlane) {\n  \tif (halfPlane === Quadrant.SE) {\n  \t\treturn quad === Quadrant.SE || quad === Quadrant.SW;\n  \t}\n  \treturn quad === halfPlane || quad === halfPlane + 1;\n  };\n  Quadrant.quadrant = function () {\n  \tif (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\") {\n  \t\tvar dx = arguments[0],\n  \t\t    dy = arguments[1];\n  \t\tif (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException(\"Cannot compute the quadrant for point ( \" + dx + \", \" + dy + \" )\");\n  \t\tif (dx >= 0.0) {\n  \t\t\tif (dy >= 0.0) return Quadrant.NE;else return Quadrant.SE;\n  \t\t} else {\n  \t\t\tif (dy >= 0.0) return Quadrant.NW;else return Quadrant.SW;\n  \t\t}\n  \t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n  \t\tvar p0 = arguments[0],\n  \t\t    p1 = arguments[1];\n  \t\tif (p1.x === p0.x && p1.y === p0.y) throw new IllegalArgumentException(\"Cannot compute the quadrant for two identical points \" + p0);\n  \t\tif (p1.x >= p0.x) {\n  \t\t\tif (p1.y >= p0.y) return Quadrant.NE;else return Quadrant.SE;\n  \t\t} else {\n  \t\t\tif (p1.y >= p0.y) return Quadrant.NW;else return Quadrant.SW;\n  \t\t}\n  \t}\n  };\n  Quadrant.NE = 0;\n  Quadrant.NW = 1;\n  Quadrant.SW = 2;\n  Quadrant.SE = 3;\n\n  function MonotoneChainBuilder() {}\n  extend(MonotoneChainBuilder.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MonotoneChainBuilder;\n  \t}\n  });\n  MonotoneChainBuilder.getChainStartIndices = function (pts) {\n  \tvar start = 0;\n  \tvar startIndexList = new ArrayList();\n  \tstartIndexList.add(new Integer(start));\n  \tdo {\n  \t\tvar last = MonotoneChainBuilder.findChainEnd(pts, start);\n  \t\tstartIndexList.add(new Integer(last));\n  \t\tstart = last;\n  \t} while (start < pts.length - 1);\n  \tvar startIndex = MonotoneChainBuilder.toIntArray(startIndexList);\n  \treturn startIndex;\n  };\n  MonotoneChainBuilder.findChainEnd = function (pts, start) {\n  \tvar safeStart = start;\n  \twhile (safeStart < pts.length - 1 && pts[safeStart].equals2D(pts[safeStart + 1])) {\n  \t\tsafeStart++;\n  \t}\n  \tif (safeStart >= pts.length - 1) {\n  \t\treturn pts.length - 1;\n  \t}\n  \tvar chainQuad = Quadrant.quadrant(pts[safeStart], pts[safeStart + 1]);\n  \tvar last = start + 1;\n  \twhile (last < pts.length) {\n  \t\tif (!pts[last - 1].equals2D(pts[last])) {\n  \t\t\tvar quad = Quadrant.quadrant(pts[last - 1], pts[last]);\n  \t\t\tif (quad !== chainQuad) break;\n  \t\t}\n  \t\tlast++;\n  \t}\n  \treturn last - 1;\n  };\n  MonotoneChainBuilder.getChains = function () {\n  \tif (arguments.length === 1) {\n  \t\tvar pts = arguments[0];\n  \t\treturn MonotoneChainBuilder.getChains(pts, null);\n  \t} else if (arguments.length === 2) {\n  \t\tvar pts = arguments[0],\n  \t\t    context = arguments[1];\n  \t\tvar mcList = new ArrayList();\n  \t\tvar startIndex = MonotoneChainBuilder.getChainStartIndices(pts);\n  \t\tfor (var i = 0; i < startIndex.length - 1; i++) {\n  \t\t\tvar mc = new MonotoneChain(pts, startIndex[i], startIndex[i + 1], context);\n  \t\t\tmcList.add(mc);\n  \t\t}\n  \t\treturn mcList;\n  \t}\n  };\n  MonotoneChainBuilder.toIntArray = function (list) {\n  \tvar array = new Array(list.size()).fill(null);\n  \tfor (var i = 0; i < array.length; i++) {\n  \t\tarray[i] = list.get(i).intValue();\n  \t}\n  \treturn array;\n  };\n\n  function Noder() {}\n  extend(Noder.prototype, {\n  \tcomputeNodes: function computeNodes(segStrings) {},\n  \tgetNodedSubstrings: function getNodedSubstrings() {},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Noder;\n  \t}\n  });\n\n  function SinglePassNoder() {\n  \tthis._segInt = null;\n  \tif (arguments.length === 0) ; else if (arguments.length === 1) {\n  \t\tvar segInt = arguments[0];\n  \t\tthis.setSegmentIntersector(segInt);\n  \t}\n  }\n  extend(SinglePassNoder.prototype, {\n  \tsetSegmentIntersector: function setSegmentIntersector(segInt) {\n  \t\tthis._segInt = segInt;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Noder];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SinglePassNoder;\n  \t}\n  });\n\n  function MCIndexNoder() {\n  \tthis._monoChains = new ArrayList();\n  \tthis._index = new STRtree();\n  \tthis._idCounter = 0;\n  \tthis._nodedSegStrings = null;\n  \tthis._nOverlaps = 0;\n  \tif (arguments.length === 0) ; else if (arguments.length === 1) {\n  \t\tvar si = arguments[0];\n  \t\tSinglePassNoder.call(this, si);\n  \t}\n  }\n  inherits$1(MCIndexNoder, SinglePassNoder);\n  extend(MCIndexNoder.prototype, {\n  \tgetMonotoneChains: function getMonotoneChains() {\n  \t\treturn this._monoChains;\n  \t},\n  \tgetNodedSubstrings: function getNodedSubstrings() {\n  \t\treturn NodedSegmentString.getNodedSubstrings(this._nodedSegStrings);\n  \t},\n  \tgetIndex: function getIndex() {\n  \t\treturn this._index;\n  \t},\n  \tadd: function add(segStr) {\n  \t\tvar segChains = MonotoneChainBuilder.getChains(segStr.getCoordinates(), segStr);\n  \t\tfor (var i = segChains.iterator(); i.hasNext();) {\n  \t\t\tvar mc = i.next();\n  \t\t\tmc.setId(this._idCounter++);\n  \t\t\tthis._index.insert(mc.getEnvelope(), mc);\n  \t\t\tthis._monoChains.add(mc);\n  \t\t}\n  \t},\n  \tcomputeNodes: function computeNodes(inputSegStrings) {\n  \t\tthis._nodedSegStrings = inputSegStrings;\n  \t\tfor (var i = inputSegStrings.iterator(); i.hasNext();) {\n  \t\t\tthis.add(i.next());\n  \t\t}\n  \t\tthis.intersectChains();\n  \t},\n  \tintersectChains: function intersectChains() {\n  \t\tvar overlapAction = new SegmentOverlapAction(this._segInt);\n  \t\tfor (var i = this._monoChains.iterator(); i.hasNext();) {\n  \t\t\tvar queryChain = i.next();\n  \t\t\tvar overlapChains = this._index.query(queryChain.getEnvelope());\n  \t\t\tfor (var j = overlapChains.iterator(); j.hasNext();) {\n  \t\t\t\tvar testChain = j.next();\n  \t\t\t\tif (testChain.getId() > queryChain.getId()) {\n  \t\t\t\t\tqueryChain.computeOverlaps(testChain, overlapAction);\n  \t\t\t\t\tthis._nOverlaps++;\n  \t\t\t\t}\n  \t\t\t\tif (this._segInt.isDone()) return null;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MCIndexNoder;\n  \t}\n  });\n  function SegmentOverlapAction() {\n  \tMonotoneChainOverlapAction.apply(this);\n  \tthis._si = null;\n  \tvar si = arguments[0];\n  \tthis._si = si;\n  }\n  inherits$1(SegmentOverlapAction, MonotoneChainOverlapAction);\n  extend(SegmentOverlapAction.prototype, {\n  \toverlap: function overlap() {\n  \t\tif (arguments.length === 4) {\n  \t\t\tvar mc1 = arguments[0],\n  \t\t\t    start1 = arguments[1],\n  \t\t\t    mc2 = arguments[2],\n  \t\t\t    start2 = arguments[3];\n  \t\t\tvar ss1 = mc1.getContext();\n  \t\t\tvar ss2 = mc2.getContext();\n  \t\t\tthis._si.processIntersections(ss1, start1, ss2, start2);\n  \t\t} else return MonotoneChainOverlapAction.prototype.overlap.apply(this, arguments);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SegmentOverlapAction;\n  \t}\n  });\n  MCIndexNoder.SegmentOverlapAction = SegmentOverlapAction;\n\n  function TopologyException() {\n  \tthis.pt = null;\n  \tif (arguments.length === 1) {\n  \t\tvar msg = arguments[0];\n  \t\tRuntimeException.call(this, msg);\n  \t} else if (arguments.length === 2) {\n  \t\tvar msg = arguments[0],\n  \t\t    pt = arguments[1];\n  \t\tRuntimeException.call(this, TopologyException.msgWithCoord(msg, pt));\n  \t\tthis.name = 'TopologyException';\n  \t\tthis.pt = new Coordinate(pt);\n  \t}\n  }\n  inherits$1(TopologyException, RuntimeException);\n  extend(TopologyException.prototype, {\n  \tgetCoordinate: function getCoordinate() {\n  \t\treturn this.pt;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn TopologyException;\n  \t}\n  });\n  TopologyException.msgWithCoord = function (msg, pt) {\n  \tif (pt !== null) return msg + \" [ \" + pt + \" ]\";\n  \treturn msg;\n  };\n\n  function SegmentIntersector() {}\n  extend(SegmentIntersector.prototype, {\n  \tprocessIntersections: function processIntersections(e0, segIndex0, e1, segIndex1) {},\n  \tisDone: function isDone() {},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SegmentIntersector;\n  \t}\n  });\n\n  function InteriorIntersectionFinder() {\n  \tthis._findAllIntersections = false;\n  \tthis._isCheckEndSegmentsOnly = false;\n  \tthis._li = null;\n  \tthis._interiorIntersection = null;\n  \tthis._intSegments = null;\n  \tthis._intersections = new ArrayList();\n  \tthis._intersectionCount = 0;\n  \tthis._keepIntersections = true;\n  \tvar li = arguments[0];\n  \tthis._li = li;\n  \tthis._interiorIntersection = null;\n  }\n  extend(InteriorIntersectionFinder.prototype, {\n  \tgetInteriorIntersection: function getInteriorIntersection() {\n  \t\treturn this._interiorIntersection;\n  \t},\n  \tsetCheckEndSegmentsOnly: function setCheckEndSegmentsOnly(isCheckEndSegmentsOnly) {\n  \t\tthis._isCheckEndSegmentsOnly = isCheckEndSegmentsOnly;\n  \t},\n  \tgetIntersectionSegments: function getIntersectionSegments() {\n  \t\treturn this._intSegments;\n  \t},\n  \tcount: function count() {\n  \t\treturn this._intersectionCount;\n  \t},\n  \tgetIntersections: function getIntersections() {\n  \t\treturn this._intersections;\n  \t},\n  \tsetFindAllIntersections: function setFindAllIntersections(findAllIntersections) {\n  \t\tthis._findAllIntersections = findAllIntersections;\n  \t},\n  \tsetKeepIntersections: function setKeepIntersections(keepIntersections) {\n  \t\tthis._keepIntersections = keepIntersections;\n  \t},\n  \tprocessIntersections: function processIntersections(e0, segIndex0, e1, segIndex1) {\n  \t\tif (!this._findAllIntersections && this.hasIntersection()) return null;\n  \t\tif (e0 === e1 && segIndex0 === segIndex1) return null;\n  \t\tif (this._isCheckEndSegmentsOnly) {\n  \t\t\tvar isEndSegPresent = this.isEndSegment(e0, segIndex0) || this.isEndSegment(e1, segIndex1);\n  \t\t\tif (!isEndSegPresent) return null;\n  \t\t}\n  \t\tvar p00 = e0.getCoordinates()[segIndex0];\n  \t\tvar p01 = e0.getCoordinates()[segIndex0 + 1];\n  \t\tvar p10 = e1.getCoordinates()[segIndex1];\n  \t\tvar p11 = e1.getCoordinates()[segIndex1 + 1];\n  \t\tthis._li.computeIntersection(p00, p01, p10, p11);\n  \t\tif (this._li.hasIntersection()) {\n  \t\t\tif (this._li.isInteriorIntersection()) {\n  \t\t\t\tthis._intSegments = new Array(4).fill(null);\n  \t\t\t\tthis._intSegments[0] = p00;\n  \t\t\t\tthis._intSegments[1] = p01;\n  \t\t\t\tthis._intSegments[2] = p10;\n  \t\t\t\tthis._intSegments[3] = p11;\n  \t\t\t\tthis._interiorIntersection = this._li.getIntersection(0);\n  \t\t\t\tif (this._keepIntersections) this._intersections.add(this._interiorIntersection);\n  \t\t\t\tthis._intersectionCount++;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tisEndSegment: function isEndSegment(segStr, index) {\n  \t\tif (index === 0) return true;\n  \t\tif (index >= segStr.size() - 2) return true;\n  \t\treturn false;\n  \t},\n  \thasIntersection: function hasIntersection() {\n  \t\treturn this._interiorIntersection !== null;\n  \t},\n  \tisDone: function isDone() {\n  \t\tif (this._findAllIntersections) return false;\n  \t\treturn this._interiorIntersection !== null;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [SegmentIntersector];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn InteriorIntersectionFinder;\n  \t}\n  });\n  InteriorIntersectionFinder.createAllIntersectionsFinder = function (li) {\n  \tvar finder = new InteriorIntersectionFinder(li);\n  \tfinder.setFindAllIntersections(true);\n  \treturn finder;\n  };\n  InteriorIntersectionFinder.createAnyIntersectionFinder = function (li) {\n  \treturn new InteriorIntersectionFinder(li);\n  };\n  InteriorIntersectionFinder.createIntersectionCounter = function (li) {\n  \tvar finder = new InteriorIntersectionFinder(li);\n  \tfinder.setFindAllIntersections(true);\n  \tfinder.setKeepIntersections(false);\n  \treturn finder;\n  };\n\n  function FastNodingValidator() {\n  \tthis._li = new RobustLineIntersector();\n  \tthis._segStrings = null;\n  \tthis._findAllIntersections = false;\n  \tthis._segInt = null;\n  \tthis._isValid = true;\n  \tvar segStrings = arguments[0];\n  \tthis._segStrings = segStrings;\n  }\n  extend(FastNodingValidator.prototype, {\n  \texecute: function execute() {\n  \t\tif (this._segInt !== null) return null;\n  \t\tthis.checkInteriorIntersections();\n  \t},\n  \tgetIntersections: function getIntersections() {\n  \t\treturn this._segInt.getIntersections();\n  \t},\n  \tisValid: function isValid() {\n  \t\tthis.execute();\n  \t\treturn this._isValid;\n  \t},\n  \tsetFindAllIntersections: function setFindAllIntersections(findAllIntersections) {\n  \t\tthis._findAllIntersections = findAllIntersections;\n  \t},\n  \tcheckInteriorIntersections: function checkInteriorIntersections() {\n  \t\tthis._isValid = true;\n  \t\tthis._segInt = new InteriorIntersectionFinder(this._li);\n  \t\tthis._segInt.setFindAllIntersections(this._findAllIntersections);\n  \t\tvar noder = new MCIndexNoder();\n  \t\tnoder.setSegmentIntersector(this._segInt);\n  \t\tnoder.computeNodes(this._segStrings);\n  \t\tif (this._segInt.hasIntersection()) {\n  \t\t\tthis._isValid = false;\n  \t\t\treturn null;\n  \t\t}\n  \t},\n  \tcheckValid: function checkValid() {\n  \t\tthis.execute();\n  \t\tif (!this._isValid) throw new TopologyException(this.getErrorMessage(), this._segInt.getInteriorIntersection());\n  \t},\n  \tgetErrorMessage: function getErrorMessage() {\n  \t\tif (this._isValid) return \"no intersections found\";\n  \t\tvar intSegs = this._segInt.getIntersectionSegments();\n  \t\treturn \"found non-noded intersection between \" + WKTWriter.toLineString(intSegs[0], intSegs[1]) + \" and \" + WKTWriter.toLineString(intSegs[2], intSegs[3]);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn FastNodingValidator;\n  \t}\n  });\n  FastNodingValidator.computeIntersections = function (segStrings) {\n  \tvar nv = new FastNodingValidator(segStrings);\n  \tnv.setFindAllIntersections(true);\n  \tnv.isValid();\n  \treturn nv.getIntersections();\n  };\n\n  function EdgeNodingValidator() {\n  \tthis._nv = null;\n  \tvar edges = arguments[0];\n  \tthis._nv = new FastNodingValidator(EdgeNodingValidator.toSegmentStrings(edges));\n  }\n  extend(EdgeNodingValidator.prototype, {\n  \tcheckValid: function checkValid() {\n  \t\tthis._nv.checkValid();\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn EdgeNodingValidator;\n  \t}\n  });\n  EdgeNodingValidator.toSegmentStrings = function (edges) {\n  \tvar segStrings = new ArrayList();\n  \tfor (var i = edges.iterator(); i.hasNext();) {\n  \t\tvar e = i.next();\n  \t\tsegStrings.add(new BasicSegmentString(e.getCoordinates(), e));\n  \t}\n  \treturn segStrings;\n  };\n  EdgeNodingValidator.checkValid = function (edges) {\n  \tvar validator = new EdgeNodingValidator(edges);\n  \tvalidator.checkValid();\n  };\n\n  function GeometryCollectionMapper() {\n  \tthis._mapOp = null;\n  \tvar mapOp = arguments[0];\n  \tthis._mapOp = mapOp;\n  }\n  extend(GeometryCollectionMapper.prototype, {\n  \tmap: function map(gc) {\n  \t\tvar mapped = new ArrayList();\n  \t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n  \t\t\tvar g = this._mapOp.map(gc.getGeometryN(i));\n  \t\t\tif (!g.isEmpty()) mapped.add(g);\n  \t\t}\n  \t\treturn gc.getFactory().createGeometryCollection(GeometryFactory.toGeometryArray(mapped));\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn GeometryCollectionMapper;\n  \t}\n  });\n  GeometryCollectionMapper.map = function (gc, op) {\n  \tvar mapper = new GeometryCollectionMapper(op);\n  \treturn mapper.map(gc);\n  };\n\n  function Position() {}\n  extend(Position.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Position;\n  \t}\n  });\n  Position.opposite = function (position) {\n  \tif (position === Position.LEFT) return Position.RIGHT;\n  \tif (position === Position.RIGHT) return Position.LEFT;\n  \treturn position;\n  };\n  Position.ON = 0;\n  Position.LEFT = 1;\n  Position.RIGHT = 2;\n\n  function TopologyLocation() {\n  \tthis.location = null;\n  \tif (arguments.length === 1) {\n  \t\tif (arguments[0] instanceof Array) {\n  \t\t\tvar location = arguments[0];\n  \t\t\tthis.init(location.length);\n  \t\t} else if (Number.isInteger(arguments[0])) {\n  \t\t\tvar on = arguments[0];\n  \t\t\tthis.init(1);\n  \t\t\tthis.location[Position.ON] = on;\n  \t\t} else if (arguments[0] instanceof TopologyLocation) {\n  \t\t\tvar gl = arguments[0];\n  \t\t\tthis.init(gl.location.length);\n  \t\t\tif (gl !== null) {\n  \t\t\t\tfor (var i = 0; i < this.location.length; i++) {\n  \t\t\t\t\tthis.location[i] = gl.location[i];\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t} else if (arguments.length === 3) {\n  \t\tvar on = arguments[0],\n  \t\t    left = arguments[1],\n  \t\t    right = arguments[2];\n  \t\tthis.init(3);\n  \t\tthis.location[Position.ON] = on;\n  \t\tthis.location[Position.LEFT] = left;\n  \t\tthis.location[Position.RIGHT] = right;\n  \t}\n  }\n  extend(TopologyLocation.prototype, {\n  \tsetAllLocations: function setAllLocations(locValue) {\n  \t\tfor (var i = 0; i < this.location.length; i++) {\n  \t\t\tthis.location[i] = locValue;\n  \t\t}\n  \t},\n  \tisNull: function isNull() {\n  \t\tfor (var i = 0; i < this.location.length; i++) {\n  \t\t\tif (this.location[i] !== Location.NONE) return false;\n  \t\t}\n  \t\treturn true;\n  \t},\n  \tsetAllLocationsIfNull: function setAllLocationsIfNull(locValue) {\n  \t\tfor (var i = 0; i < this.location.length; i++) {\n  \t\t\tif (this.location[i] === Location.NONE) this.location[i] = locValue;\n  \t\t}\n  \t},\n  \tisLine: function isLine() {\n  \t\treturn this.location.length === 1;\n  \t},\n  \tmerge: function merge(gl) {\n  \t\tif (gl.location.length > this.location.length) {\n  \t\t\tvar newLoc = new Array(3).fill(null);\n  \t\t\tnewLoc[Position.ON] = this.location[Position.ON];\n  \t\t\tnewLoc[Position.LEFT] = Location.NONE;\n  \t\t\tnewLoc[Position.RIGHT] = Location.NONE;\n  \t\t\tthis.location = newLoc;\n  \t\t}\n  \t\tfor (var i = 0; i < this.location.length; i++) {\n  \t\t\tif (this.location[i] === Location.NONE && i < gl.location.length) this.location[i] = gl.location[i];\n  \t\t}\n  \t},\n  \tgetLocations: function getLocations() {\n  \t\treturn this.location;\n  \t},\n  \tflip: function flip() {\n  \t\tif (this.location.length <= 1) return null;\n  \t\tvar temp = this.location[Position.LEFT];\n  \t\tthis.location[Position.LEFT] = this.location[Position.RIGHT];\n  \t\tthis.location[Position.RIGHT] = temp;\n  \t},\n  \ttoString: function toString() {\n  \t\tvar buf = new StringBuffer();\n  \t\tif (this.location.length > 1) buf.append(Location.toLocationSymbol(this.location[Position.LEFT]));\n  \t\tbuf.append(Location.toLocationSymbol(this.location[Position.ON]));\n  \t\tif (this.location.length > 1) buf.append(Location.toLocationSymbol(this.location[Position.RIGHT]));\n  \t\treturn buf.toString();\n  \t},\n  \tsetLocations: function setLocations(on, left, right) {\n  \t\tthis.location[Position.ON] = on;\n  \t\tthis.location[Position.LEFT] = left;\n  \t\tthis.location[Position.RIGHT] = right;\n  \t},\n  \tget: function get(posIndex) {\n  \t\tif (posIndex < this.location.length) return this.location[posIndex];\n  \t\treturn Location.NONE;\n  \t},\n  \tisArea: function isArea() {\n  \t\treturn this.location.length > 1;\n  \t},\n  \tisAnyNull: function isAnyNull() {\n  \t\tfor (var i = 0; i < this.location.length; i++) {\n  \t\t\tif (this.location[i] === Location.NONE) return true;\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tsetLocation: function setLocation() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar locValue = arguments[0];\n  \t\t\tthis.setLocation(Position.ON, locValue);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar locIndex = arguments[0],\n  \t\t\t    locValue = arguments[1];\n  \t\t\tthis.location[locIndex] = locValue;\n  \t\t}\n  \t},\n  \tinit: function init(size) {\n  \t\tthis.location = new Array(size).fill(null);\n  \t\tthis.setAllLocations(Location.NONE);\n  \t},\n  \tisEqualOnSide: function isEqualOnSide(le, locIndex) {\n  \t\treturn this.location[locIndex] === le.location[locIndex];\n  \t},\n  \tallPositionsEqual: function allPositionsEqual(loc) {\n  \t\tfor (var i = 0; i < this.location.length; i++) {\n  \t\t\tif (this.location[i] !== loc) return false;\n  \t\t}\n  \t\treturn true;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn TopologyLocation;\n  \t}\n  });\n\n  function Label() {\n  \tthis.elt = new Array(2).fill(null);\n  \tif (arguments.length === 1) {\n  \t\tif (Number.isInteger(arguments[0])) {\n  \t\t\tvar onLoc = arguments[0];\n  \t\t\tthis.elt[0] = new TopologyLocation(onLoc);\n  \t\t\tthis.elt[1] = new TopologyLocation(onLoc);\n  \t\t} else if (arguments[0] instanceof Label) {\n  \t\t\tvar lbl = arguments[0];\n  \t\t\tthis.elt[0] = new TopologyLocation(lbl.elt[0]);\n  \t\t\tthis.elt[1] = new TopologyLocation(lbl.elt[1]);\n  \t\t}\n  \t} else if (arguments.length === 2) {\n  \t\tvar geomIndex = arguments[0],\n  \t\t    onLoc = arguments[1];\n  \t\tthis.elt[0] = new TopologyLocation(Location.NONE);\n  \t\tthis.elt[1] = new TopologyLocation(Location.NONE);\n  \t\tthis.elt[geomIndex].setLocation(onLoc);\n  \t} else if (arguments.length === 3) {\n  \t\tvar onLoc = arguments[0],\n  \t\t    leftLoc = arguments[1],\n  \t\t    rightLoc = arguments[2];\n  \t\tthis.elt[0] = new TopologyLocation(onLoc, leftLoc, rightLoc);\n  \t\tthis.elt[1] = new TopologyLocation(onLoc, leftLoc, rightLoc);\n  \t} else if (arguments.length === 4) {\n  \t\tvar geomIndex = arguments[0],\n  \t\t    onLoc = arguments[1],\n  \t\t    leftLoc = arguments[2],\n  \t\t    rightLoc = arguments[3];\n  \t\tthis.elt[0] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);\n  \t\tthis.elt[1] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);\n  \t\tthis.elt[geomIndex].setLocations(onLoc, leftLoc, rightLoc);\n  \t}\n  }\n  extend(Label.prototype, {\n  \tgetGeometryCount: function getGeometryCount() {\n  \t\tvar count = 0;\n  \t\tif (!this.elt[0].isNull()) count++;\n  \t\tif (!this.elt[1].isNull()) count++;\n  \t\treturn count;\n  \t},\n  \tsetAllLocations: function setAllLocations(geomIndex, location) {\n  \t\tthis.elt[geomIndex].setAllLocations(location);\n  \t},\n  \tisNull: function isNull(geomIndex) {\n  \t\treturn this.elt[geomIndex].isNull();\n  \t},\n  \tsetAllLocationsIfNull: function setAllLocationsIfNull() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar location = arguments[0];\n  \t\t\tthis.setAllLocationsIfNull(0, location);\n  \t\t\tthis.setAllLocationsIfNull(1, location);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar geomIndex = arguments[0],\n  \t\t\t    location = arguments[1];\n  \t\t\tthis.elt[geomIndex].setAllLocationsIfNull(location);\n  \t\t}\n  \t},\n  \tisLine: function isLine(geomIndex) {\n  \t\treturn this.elt[geomIndex].isLine();\n  \t},\n  \tmerge: function merge(lbl) {\n  \t\tfor (var i = 0; i < 2; i++) {\n  \t\t\tif (this.elt[i] === null && lbl.elt[i] !== null) {\n  \t\t\t\tthis.elt[i] = new TopologyLocation(lbl.elt[i]);\n  \t\t\t} else {\n  \t\t\t\tthis.elt[i].merge(lbl.elt[i]);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tflip: function flip() {\n  \t\tthis.elt[0].flip();\n  \t\tthis.elt[1].flip();\n  \t},\n  \tgetLocation: function getLocation() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar geomIndex = arguments[0];\n  \t\t\treturn this.elt[geomIndex].get(Position.ON);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar geomIndex = arguments[0],\n  \t\t\t    posIndex = arguments[1];\n  \t\t\treturn this.elt[geomIndex].get(posIndex);\n  \t\t}\n  \t},\n  \ttoString: function toString() {\n  \t\tvar buf = new StringBuffer();\n  \t\tif (this.elt[0] !== null) {\n  \t\t\tbuf.append(\"A:\");\n  \t\t\tbuf.append(this.elt[0].toString());\n  \t\t}\n  \t\tif (this.elt[1] !== null) {\n  \t\t\tbuf.append(\" B:\");\n  \t\t\tbuf.append(this.elt[1].toString());\n  \t\t}\n  \t\treturn buf.toString();\n  \t},\n  \tisArea: function isArea() {\n  \t\tif (arguments.length === 0) {\n  \t\t\treturn this.elt[0].isArea() || this.elt[1].isArea();\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tvar geomIndex = arguments[0];\n  \t\t\treturn this.elt[geomIndex].isArea();\n  \t\t}\n  \t},\n  \tisAnyNull: function isAnyNull(geomIndex) {\n  \t\treturn this.elt[geomIndex].isAnyNull();\n  \t},\n  \tsetLocation: function setLocation() {\n  \t\tif (arguments.length === 2) {\n  \t\t\tvar geomIndex = arguments[0],\n  \t\t\t    location = arguments[1];\n  \t\t\tthis.elt[geomIndex].setLocation(Position.ON, location);\n  \t\t} else if (arguments.length === 3) {\n  \t\t\tvar geomIndex = arguments[0],\n  \t\t\t    posIndex = arguments[1],\n  \t\t\t    location = arguments[2];\n  \t\t\tthis.elt[geomIndex].setLocation(posIndex, location);\n  \t\t}\n  \t},\n  \tisEqualOnSide: function isEqualOnSide(lbl, side) {\n  \t\treturn this.elt[0].isEqualOnSide(lbl.elt[0], side) && this.elt[1].isEqualOnSide(lbl.elt[1], side);\n  \t},\n  \tallPositionsEqual: function allPositionsEqual(geomIndex, loc) {\n  \t\treturn this.elt[geomIndex].allPositionsEqual(loc);\n  \t},\n  \ttoLine: function toLine(geomIndex) {\n  \t\tif (this.elt[geomIndex].isArea()) this.elt[geomIndex] = new TopologyLocation(this.elt[geomIndex].location[0]);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Label;\n  \t}\n  });\n  Label.toLineLabel = function (label) {\n  \tvar lineLabel = new Label(Location.NONE);\n  \tfor (var i = 0; i < 2; i++) {\n  \t\tlineLabel.setLocation(i, label.getLocation(i));\n  \t}\n  \treturn lineLabel;\n  };\n\n  function EdgeRing() {\n  \tthis._startDe = null;\n  \tthis._maxNodeDegree = -1;\n  \tthis._edges = new ArrayList();\n  \tthis._pts = new ArrayList();\n  \tthis._label = new Label(Location.NONE);\n  \tthis._ring = null;\n  \tthis._isHole = null;\n  \tthis._shell = null;\n  \tthis._holes = new ArrayList();\n  \tthis._geometryFactory = null;\n  \tvar start = arguments[0],\n  \t    geometryFactory = arguments[1];\n  \tthis._geometryFactory = geometryFactory;\n  \tthis.computePoints(start);\n  \tthis.computeRing();\n  }\n  extend(EdgeRing.prototype, {\n  \tcomputeRing: function computeRing() {\n  \t\tif (this._ring !== null) return null;\n  \t\tvar coord = new Array(this._pts.size()).fill(null);\n  \t\tfor (var i = 0; i < this._pts.size(); i++) {\n  \t\t\tcoord[i] = this._pts.get(i);\n  \t\t}\n  \t\tthis._ring = this._geometryFactory.createLinearRing(coord);\n  \t\tthis._isHole = CGAlgorithms.isCCW(this._ring.getCoordinates());\n  \t},\n  \tisIsolated: function isIsolated() {\n  \t\treturn this._label.getGeometryCount() === 1;\n  \t},\n  \tcomputePoints: function computePoints(start) {\n  \t\tthis._startDe = start;\n  \t\tvar de = start;\n  \t\tvar isFirstEdge = true;\n  \t\tdo {\n  \t\t\tif (de === null) throw new TopologyException(\"Found null DirectedEdge\");\n  \t\t\tif (de.getEdgeRing() === this) throw new TopologyException(\"Directed Edge visited twice during ring-building at \" + de.getCoordinate());\n  \t\t\tthis._edges.add(de);\n  \t\t\tvar label = de.getLabel();\n  \t\t\tAssert.isTrue(label.isArea());\n  \t\t\tthis.mergeLabel(label);\n  \t\t\tthis.addPoints(de.getEdge(), de.isForward(), isFirstEdge);\n  \t\t\tisFirstEdge = false;\n  \t\t\tthis.setEdgeRing(de, this);\n  \t\t\tde = this.getNext(de);\n  \t\t} while (de !== this._startDe);\n  \t},\n  \tgetLinearRing: function getLinearRing() {\n  \t\treturn this._ring;\n  \t},\n  \tgetCoordinate: function getCoordinate(i) {\n  \t\treturn this._pts.get(i);\n  \t},\n  \tcomputeMaxNodeDegree: function computeMaxNodeDegree() {\n  \t\tthis._maxNodeDegree = 0;\n  \t\tvar de = this._startDe;\n  \t\tdo {\n  \t\t\tvar node = de.getNode();\n  \t\t\tvar degree = node.getEdges().getOutgoingDegree(this);\n  \t\t\tif (degree > this._maxNodeDegree) this._maxNodeDegree = degree;\n  \t\t\tde = this.getNext(de);\n  \t\t} while (de !== this._startDe);\n  \t\tthis._maxNodeDegree *= 2;\n  \t},\n  \taddPoints: function addPoints(edge, isForward, isFirstEdge) {\n  \t\tvar edgePts = edge.getCoordinates();\n  \t\tif (isForward) {\n  \t\t\tvar startIndex = 1;\n  \t\t\tif (isFirstEdge) startIndex = 0;\n  \t\t\tfor (var i = startIndex; i < edgePts.length; i++) {\n  \t\t\t\tthis._pts.add(edgePts[i]);\n  \t\t\t}\n  \t\t} else {\n  \t\t\tvar startIndex = edgePts.length - 2;\n  \t\t\tif (isFirstEdge) startIndex = edgePts.length - 1;\n  \t\t\tfor (var i = startIndex; i >= 0; i--) {\n  \t\t\t\tthis._pts.add(edgePts[i]);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tisHole: function isHole() {\n  \t\treturn this._isHole;\n  \t},\n  \tsetInResult: function setInResult() {\n  \t\tvar de = this._startDe;\n  \t\tdo {\n  \t\t\tde.getEdge().setInResult(true);\n  \t\t\tde = de.getNext();\n  \t\t} while (de !== this._startDe);\n  \t},\n  \tcontainsPoint: function containsPoint(p) {\n  \t\tvar shell = this.getLinearRing();\n  \t\tvar env = shell.getEnvelopeInternal();\n  \t\tif (!env.contains(p)) return false;\n  \t\tif (!CGAlgorithms.isPointInRing(p, shell.getCoordinates())) return false;\n  \t\tfor (var i = this._holes.iterator(); i.hasNext();) {\n  \t\t\tvar hole = i.next();\n  \t\t\tif (hole.containsPoint(p)) return false;\n  \t\t}\n  \t\treturn true;\n  \t},\n  \taddHole: function addHole(ring) {\n  \t\tthis._holes.add(ring);\n  \t},\n  \tisShell: function isShell() {\n  \t\treturn this._shell === null;\n  \t},\n  \tgetLabel: function getLabel() {\n  \t\treturn this._label;\n  \t},\n  \tgetEdges: function getEdges() {\n  \t\treturn this._edges;\n  \t},\n  \tgetMaxNodeDegree: function getMaxNodeDegree() {\n  \t\tif (this._maxNodeDegree < 0) this.computeMaxNodeDegree();\n  \t\treturn this._maxNodeDegree;\n  \t},\n  \tgetShell: function getShell() {\n  \t\treturn this._shell;\n  \t},\n  \tmergeLabel: function mergeLabel() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar deLabel = arguments[0];\n  \t\t\tthis.mergeLabel(deLabel, 0);\n  \t\t\tthis.mergeLabel(deLabel, 1);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar deLabel = arguments[0],\n  \t\t\t    geomIndex = arguments[1];\n  \t\t\tvar loc = deLabel.getLocation(geomIndex, Position.RIGHT);\n  \t\t\tif (loc === Location.NONE) return null;\n  \t\t\tif (this._label.getLocation(geomIndex) === Location.NONE) {\n  \t\t\t\tthis._label.setLocation(geomIndex, loc);\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tsetShell: function setShell(shell) {\n  \t\tthis._shell = shell;\n  \t\tif (shell !== null) shell.addHole(this);\n  \t},\n  \ttoPolygon: function toPolygon(geometryFactory) {\n  \t\tvar holeLR = new Array(this._holes.size()).fill(null);\n  \t\tfor (var i = 0; i < this._holes.size(); i++) {\n  \t\t\tholeLR[i] = this._holes.get(i).getLinearRing();\n  \t\t}\n  \t\tvar poly = geometryFactory.createPolygon(this.getLinearRing(), holeLR);\n  \t\treturn poly;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn EdgeRing;\n  \t}\n  });\n\n  function MinimalEdgeRing() {\n  \tvar start = arguments[0],\n  \t    geometryFactory = arguments[1];\n  \tEdgeRing.call(this, start, geometryFactory);\n  }\n  inherits$1(MinimalEdgeRing, EdgeRing);\n  extend(MinimalEdgeRing.prototype, {\n  \tsetEdgeRing: function setEdgeRing(de, er) {\n  \t\tde.setMinEdgeRing(er);\n  \t},\n  \tgetNext: function getNext(de) {\n  \t\treturn de.getNextMin();\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MinimalEdgeRing;\n  \t}\n  });\n\n  function MaximalEdgeRing() {\n  \tvar start = arguments[0],\n  \t    geometryFactory = arguments[1];\n  \tEdgeRing.call(this, start, geometryFactory);\n  }\n  inherits$1(MaximalEdgeRing, EdgeRing);\n  extend(MaximalEdgeRing.prototype, {\n  \tbuildMinimalRings: function buildMinimalRings() {\n  \t\tvar minEdgeRings = new ArrayList();\n  \t\tvar de = this._startDe;\n  \t\tdo {\n  \t\t\tif (de.getMinEdgeRing() === null) {\n  \t\t\t\tvar minEr = new MinimalEdgeRing(de, this._geometryFactory);\n  \t\t\t\tminEdgeRings.add(minEr);\n  \t\t\t}\n  \t\t\tde = de.getNext();\n  \t\t} while (de !== this._startDe);\n  \t\treturn minEdgeRings;\n  \t},\n  \tsetEdgeRing: function setEdgeRing(de, er) {\n  \t\tde.setEdgeRing(er);\n  \t},\n  \tlinkDirectedEdgesForMinimalEdgeRings: function linkDirectedEdgesForMinimalEdgeRings() {\n  \t\tvar de = this._startDe;\n  \t\tdo {\n  \t\t\tvar node = de.getNode();\n  \t\t\tnode.getEdges().linkMinimalDirectedEdges(this);\n  \t\t\tde = de.getNext();\n  \t\t} while (de !== this._startDe);\n  \t},\n  \tgetNext: function getNext(de) {\n  \t\treturn de.getNext();\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MaximalEdgeRing;\n  \t}\n  });\n\n  function GraphComponent() {\n  \tthis._label = null;\n  \tthis._isInResult = false;\n  \tthis._isCovered = false;\n  \tthis._isCoveredSet = false;\n  \tthis._isVisited = false;\n  \tif (arguments.length === 0) ; else if (arguments.length === 1) {\n  \t\tvar label = arguments[0];\n  \t\tthis._label = label;\n  \t}\n  }\n  extend(GraphComponent.prototype, {\n  \tsetVisited: function setVisited(isVisited) {\n  \t\tthis._isVisited = isVisited;\n  \t},\n  \tsetInResult: function setInResult(isInResult) {\n  \t\tthis._isInResult = isInResult;\n  \t},\n  \tisCovered: function isCovered() {\n  \t\treturn this._isCovered;\n  \t},\n  \tisCoveredSet: function isCoveredSet() {\n  \t\treturn this._isCoveredSet;\n  \t},\n  \tsetLabel: function setLabel(label) {\n  \t\tthis._label = label;\n  \t},\n  \tgetLabel: function getLabel() {\n  \t\treturn this._label;\n  \t},\n  \tsetCovered: function setCovered(isCovered) {\n  \t\tthis._isCovered = isCovered;\n  \t\tthis._isCoveredSet = true;\n  \t},\n  \tupdateIM: function updateIM(im) {\n  \t\tAssert.isTrue(this._label.getGeometryCount() >= 2, \"found partial label\");\n  \t\tthis.computeIM(im);\n  \t},\n  \tisInResult: function isInResult() {\n  \t\treturn this._isInResult;\n  \t},\n  \tisVisited: function isVisited() {\n  \t\treturn this._isVisited;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn GraphComponent;\n  \t}\n  });\n\n  function Node() {\n  \tGraphComponent.apply(this);\n  \tthis._coord = null;\n  \tthis._edges = null;\n  \tvar coord = arguments[0],\n  \t    edges = arguments[1];\n  \tthis._coord = coord;\n  \tthis._edges = edges;\n  \tthis._label = new Label(0, Location.NONE);\n  }\n  inherits$1(Node, GraphComponent);\n  extend(Node.prototype, {\n  \tisIncidentEdgeInResult: function isIncidentEdgeInResult() {\n  \t\tfor (var it = this.getEdges().getEdges().iterator(); it.hasNext();) {\n  \t\t\tvar de = it.next();\n  \t\t\tif (de.getEdge().isInResult()) return true;\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tisIsolated: function isIsolated() {\n  \t\treturn this._label.getGeometryCount() === 1;\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\treturn this._coord;\n  \t},\n  \tprint: function print(out) {\n  \t\tout.println(\"node \" + this._coord + \" lbl: \" + this._label);\n  \t},\n  \tcomputeIM: function computeIM(im) {},\n  \tcomputeMergedLocation: function computeMergedLocation(label2, eltIndex) {\n  \t\tvar loc = Location.NONE;\n  \t\tloc = this._label.getLocation(eltIndex);\n  \t\tif (!label2.isNull(eltIndex)) {\n  \t\t\tvar nLoc = label2.getLocation(eltIndex);\n  \t\t\tif (loc !== Location.BOUNDARY) loc = nLoc;\n  \t\t}\n  \t\treturn loc;\n  \t},\n  \tsetLabel: function setLabel() {\n  \t\tif (arguments.length === 2) {\n  \t\t\tvar argIndex = arguments[0],\n  \t\t\t    onLocation = arguments[1];\n  \t\t\tif (this._label === null) {\n  \t\t\t\tthis._label = new Label(argIndex, onLocation);\n  \t\t\t} else this._label.setLocation(argIndex, onLocation);\n  \t\t} else return GraphComponent.prototype.setLabel.apply(this, arguments);\n  \t},\n  \tgetEdges: function getEdges() {\n  \t\treturn this._edges;\n  \t},\n  \tmergeLabel: function mergeLabel() {\n  \t\tif (arguments[0] instanceof Node) {\n  \t\t\tvar n = arguments[0];\n  \t\t\tthis.mergeLabel(n._label);\n  \t\t} else if (arguments[0] instanceof Label) {\n  \t\t\tvar label2 = arguments[0];\n  \t\t\tfor (var i = 0; i < 2; i++) {\n  \t\t\t\tvar loc = this.computeMergedLocation(label2, i);\n  \t\t\t\tvar thisLoc = this._label.getLocation(i);\n  \t\t\t\tif (thisLoc === Location.NONE) this._label.setLocation(i, loc);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tadd: function add(e) {\n  \t\tthis._edges.insert(e);\n  \t\te.setNode(this);\n  \t},\n  \tsetLabelBoundary: function setLabelBoundary(argIndex) {\n  \t\tif (this._label === null) return null;\n  \t\tvar loc = Location.NONE;\n  \t\tif (this._label !== null) loc = this._label.getLocation(argIndex);\n  \t\tvar newLoc = null;\n  \t\tswitch (loc) {\n  \t\t\tcase Location.BOUNDARY:\n  \t\t\t\tnewLoc = Location.INTERIOR;\n  \t\t\t\tbreak;\n  \t\t\tcase Location.INTERIOR:\n  \t\t\t\tnewLoc = Location.BOUNDARY;\n  \t\t\t\tbreak;\n  \t\t\tdefault:\n  \t\t\t\tnewLoc = Location.BOUNDARY;\n  \t\t\t\tbreak;\n  \t\t}\n  \t\tthis._label.setLocation(argIndex, newLoc);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Node;\n  \t}\n  });\n\n  function NodeMap() {\n  \tthis.nodeMap = new TreeMap();\n  \tthis.nodeFact = null;\n  \tvar nodeFact = arguments[0];\n  \tthis.nodeFact = nodeFact;\n  }\n  extend(NodeMap.prototype, {\n  \tfind: function find(coord) {\n  \t\treturn this.nodeMap.get(coord);\n  \t},\n  \taddNode: function addNode() {\n  \t\tif (arguments[0] instanceof Coordinate) {\n  \t\t\tvar coord = arguments[0];\n  \t\t\tvar node = this.nodeMap.get(coord);\n  \t\t\tif (node === null) {\n  \t\t\t\tnode = this.nodeFact.createNode(coord);\n  \t\t\t\tthis.nodeMap.put(coord, node);\n  \t\t\t}\n  \t\t\treturn node;\n  \t\t} else if (arguments[0] instanceof Node) {\n  \t\t\tvar n = arguments[0];\n  \t\t\tvar node = this.nodeMap.get(n.getCoordinate());\n  \t\t\tif (node === null) {\n  \t\t\t\tthis.nodeMap.put(n.getCoordinate(), n);\n  \t\t\t\treturn n;\n  \t\t\t}\n  \t\t\tnode.mergeLabel(n);\n  \t\t\treturn node;\n  \t\t}\n  \t},\n  \tprint: function print(out) {\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar n = it.next();\n  \t\t\tn.print(out);\n  \t\t}\n  \t},\n  \titerator: function iterator() {\n  \t\treturn this.nodeMap.values().iterator();\n  \t},\n  \tvalues: function values() {\n  \t\treturn this.nodeMap.values();\n  \t},\n  \tgetBoundaryNodes: function getBoundaryNodes(geomIndex) {\n  \t\tvar bdyNodes = new ArrayList();\n  \t\tfor (var i = this.iterator(); i.hasNext();) {\n  \t\t\tvar node = i.next();\n  \t\t\tif (node.getLabel().getLocation(geomIndex) === Location.BOUNDARY) bdyNodes.add(node);\n  \t\t}\n  \t\treturn bdyNodes;\n  \t},\n  \tadd: function add(e) {\n  \t\tvar p = e.getCoordinate();\n  \t\tvar n = this.addNode(p);\n  \t\tn.add(e);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn NodeMap;\n  \t}\n  });\n\n  function EdgeEnd() {\n  \tthis._edge = null;\n  \tthis._label = null;\n  \tthis._node = null;\n  \tthis._p0 = null;\n  \tthis._p1 = null;\n  \tthis._dx = null;\n  \tthis._dy = null;\n  \tthis._quadrant = null;\n  \tif (arguments.length === 1) {\n  \t\tvar edge = arguments[0];\n  \t\tthis._edge = edge;\n  \t} else if (arguments.length === 3) {\n  \t\tvar edge = arguments[0],\n  \t\t    p0 = arguments[1],\n  \t\t    p1 = arguments[2];\n  \t\tEdgeEnd.call(this, edge, p0, p1, null);\n  \t} else if (arguments.length === 4) {\n  \t\tvar edge = arguments[0],\n  \t\t    p0 = arguments[1],\n  \t\t    p1 = arguments[2],\n  \t\t    label = arguments[3];\n  \t\tEdgeEnd.call(this, edge);\n  \t\tthis.init(p0, p1);\n  \t\tthis._label = label;\n  \t}\n  }\n  extend(EdgeEnd.prototype, {\n  \tcompareDirection: function compareDirection(e) {\n  \t\tif (this._dx === e._dx && this._dy === e._dy) return 0;\n  \t\tif (this._quadrant > e._quadrant) return 1;\n  \t\tif (this._quadrant < e._quadrant) return -1;\n  \t\treturn CGAlgorithms.computeOrientation(e._p0, e._p1, this._p1);\n  \t},\n  \tgetDy: function getDy() {\n  \t\treturn this._dy;\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\treturn this._p0;\n  \t},\n  \tsetNode: function setNode(node) {\n  \t\tthis._node = node;\n  \t},\n  \tprint: function print(out) {\n  \t\tvar angle = Math.atan2(this._dy, this._dx);\n  \t\tvar className = this.getClass().getName();\n  \t\tvar lastDotPos = className.lastIndexOf('.');\n  \t\tvar name = className.substring(lastDotPos + 1);\n  \t\tout.print(\"  \" + name + \": \" + this._p0 + \" - \" + this._p1 + \" \" + this._quadrant + \":\" + angle + \"   \" + this._label);\n  \t},\n  \tcompareTo: function compareTo(obj) {\n  \t\tvar e = obj;\n  \t\treturn this.compareDirection(e);\n  \t},\n  \tgetDirectedCoordinate: function getDirectedCoordinate() {\n  \t\treturn this._p1;\n  \t},\n  \tgetDx: function getDx() {\n  \t\treturn this._dx;\n  \t},\n  \tgetLabel: function getLabel() {\n  \t\treturn this._label;\n  \t},\n  \tgetEdge: function getEdge() {\n  \t\treturn this._edge;\n  \t},\n  \tgetQuadrant: function getQuadrant() {\n  \t\treturn this._quadrant;\n  \t},\n  \tgetNode: function getNode() {\n  \t\treturn this._node;\n  \t},\n  \ttoString: function toString() {\n  \t\tvar angle = Math.atan2(this._dy, this._dx);\n  \t\tvar className = this.getClass().getName();\n  \t\tvar lastDotPos = className.lastIndexOf('.');\n  \t\tvar name = className.substring(lastDotPos + 1);\n  \t\treturn \"  \" + name + \": \" + this._p0 + \" - \" + this._p1 + \" \" + this._quadrant + \":\" + angle + \"   \" + this._label;\n  \t},\n  \tcomputeLabel: function computeLabel(boundaryNodeRule) {},\n  \tinit: function init(p0, p1) {\n  \t\tthis._p0 = p0;\n  \t\tthis._p1 = p1;\n  \t\tthis._dx = p1.x - p0.x;\n  \t\tthis._dy = p1.y - p0.y;\n  \t\tthis._quadrant = Quadrant.quadrant(this._dx, this._dy);\n  \t\tAssert.isTrue(!(this._dx === 0 && this._dy === 0), \"EdgeEnd with identical endpoints found\");\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn EdgeEnd;\n  \t}\n  });\n\n  function DirectedEdge() {\n  \tthis._isForward = null;\n  \tthis._isInResult = false;\n  \tthis._isVisited = false;\n  \tthis._sym = null;\n  \tthis._next = null;\n  \tthis._nextMin = null;\n  \tthis._edgeRing = null;\n  \tthis._minEdgeRing = null;\n  \tthis._depth = [0, -999, -999];\n  \tvar edge = arguments[0],\n  \t    isForward = arguments[1];\n  \tEdgeEnd.call(this, edge);\n  \tthis._isForward = isForward;\n  \tif (isForward) {\n  \t\tthis.init(edge.getCoordinate(0), edge.getCoordinate(1));\n  \t} else {\n  \t\tvar n = edge.getNumPoints() - 1;\n  \t\tthis.init(edge.getCoordinate(n), edge.getCoordinate(n - 1));\n  \t}\n  \tthis.computeDirectedLabel();\n  }\n  inherits$1(DirectedEdge, EdgeEnd);\n  extend(DirectedEdge.prototype, {\n  \tgetNextMin: function getNextMin() {\n  \t\treturn this._nextMin;\n  \t},\n  \tgetDepth: function getDepth(position) {\n  \t\treturn this._depth[position];\n  \t},\n  \tsetVisited: function setVisited(isVisited) {\n  \t\tthis._isVisited = isVisited;\n  \t},\n  \tcomputeDirectedLabel: function computeDirectedLabel() {\n  \t\tthis._label = new Label(this._edge.getLabel());\n  \t\tif (!this._isForward) this._label.flip();\n  \t},\n  \tgetNext: function getNext() {\n  \t\treturn this._next;\n  \t},\n  \tsetDepth: function setDepth(position, depthVal) {\n  \t\tif (this._depth[position] !== -999) {\n  \t\t\tif (this._depth[position] !== depthVal) throw new TopologyException(\"assigned depths do not match\", this.getCoordinate());\n  \t\t}\n  \t\tthis._depth[position] = depthVal;\n  \t},\n  \tisInteriorAreaEdge: function isInteriorAreaEdge() {\n  \t\tvar isInteriorAreaEdge = true;\n  \t\tfor (var i = 0; i < 2; i++) {\n  \t\t\tif (!(this._label.isArea(i) && this._label.getLocation(i, Position.LEFT) === Location.INTERIOR && this._label.getLocation(i, Position.RIGHT) === Location.INTERIOR)) {\n  \t\t\t\tisInteriorAreaEdge = false;\n  \t\t\t}\n  \t\t}\n  \t\treturn isInteriorAreaEdge;\n  \t},\n  \tsetNextMin: function setNextMin(nextMin) {\n  \t\tthis._nextMin = nextMin;\n  \t},\n  \tprint: function print(out) {\n  \t\tEdgeEnd.prototype.print.call(this, out);\n  \t\tout.print(\" \" + this._depth[Position.LEFT] + \"/\" + this._depth[Position.RIGHT]);\n  \t\tout.print(\" (\" + this.getDepthDelta() + \")\");\n  \t\tif (this._isInResult) out.print(\" inResult\");\n  \t},\n  \tsetMinEdgeRing: function setMinEdgeRing(minEdgeRing) {\n  \t\tthis._minEdgeRing = minEdgeRing;\n  \t},\n  \tisLineEdge: function isLineEdge() {\n  \t\tvar isLine = this._label.isLine(0) || this._label.isLine(1);\n  \t\tvar isExteriorIfArea0 = !this._label.isArea(0) || this._label.allPositionsEqual(0, Location.EXTERIOR);\n  \t\tvar isExteriorIfArea1 = !this._label.isArea(1) || this._label.allPositionsEqual(1, Location.EXTERIOR);\n  \t\treturn isLine && isExteriorIfArea0 && isExteriorIfArea1;\n  \t},\n  \tsetEdgeRing: function setEdgeRing(edgeRing) {\n  \t\tthis._edgeRing = edgeRing;\n  \t},\n  \tgetMinEdgeRing: function getMinEdgeRing() {\n  \t\treturn this._minEdgeRing;\n  \t},\n  \tgetDepthDelta: function getDepthDelta() {\n  \t\tvar depthDelta = this._edge.getDepthDelta();\n  \t\tif (!this._isForward) depthDelta = -depthDelta;\n  \t\treturn depthDelta;\n  \t},\n  \tsetInResult: function setInResult(isInResult) {\n  \t\tthis._isInResult = isInResult;\n  \t},\n  \tgetSym: function getSym() {\n  \t\treturn this._sym;\n  \t},\n  \tisForward: function isForward() {\n  \t\treturn this._isForward;\n  \t},\n  \tgetEdge: function getEdge() {\n  \t\treturn this._edge;\n  \t},\n  \tprintEdge: function printEdge(out) {\n  \t\tthis.print(out);\n  \t\tout.print(\" \");\n  \t\tif (this._isForward) this._edge.print(out);else this._edge.printReverse(out);\n  \t},\n  \tsetSym: function setSym(de) {\n  \t\tthis._sym = de;\n  \t},\n  \tsetVisitedEdge: function setVisitedEdge(isVisited) {\n  \t\tthis.setVisited(isVisited);\n  \t\tthis._sym.setVisited(isVisited);\n  \t},\n  \tsetEdgeDepths: function setEdgeDepths(position, depth) {\n  \t\tvar depthDelta = this.getEdge().getDepthDelta();\n  \t\tif (!this._isForward) depthDelta = -depthDelta;\n  \t\tvar directionFactor = 1;\n  \t\tif (position === Position.LEFT) directionFactor = -1;\n  \t\tvar oppositePos = Position.opposite(position);\n  \t\tvar delta = depthDelta * directionFactor;\n  \t\tvar oppositeDepth = depth + delta;\n  \t\tthis.setDepth(position, depth);\n  \t\tthis.setDepth(oppositePos, oppositeDepth);\n  \t},\n  \tgetEdgeRing: function getEdgeRing() {\n  \t\treturn this._edgeRing;\n  \t},\n  \tisInResult: function isInResult() {\n  \t\treturn this._isInResult;\n  \t},\n  \tsetNext: function setNext(next) {\n  \t\tthis._next = next;\n  \t},\n  \tisVisited: function isVisited() {\n  \t\treturn this._isVisited;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn DirectedEdge;\n  \t}\n  });\n  DirectedEdge.depthFactor = function (currLocation, nextLocation) {\n  \tif (currLocation === Location.EXTERIOR && nextLocation === Location.INTERIOR) return 1;else if (currLocation === Location.INTERIOR && nextLocation === Location.EXTERIOR) return -1;\n  \treturn 0;\n  };\n\n  function NodeFactory() {}\n  extend(NodeFactory.prototype, {\n  \tcreateNode: function createNode(coord) {\n  \t\treturn new Node(coord, null);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn NodeFactory;\n  \t}\n  });\n\n  function PlanarGraph() {\n  \tthis._edges = new ArrayList();\n  \tthis._nodes = null;\n  \tthis._edgeEndList = new ArrayList();\n  \tif (arguments.length === 0) {\n  \t\tthis._nodes = new NodeMap(new NodeFactory());\n  \t} else if (arguments.length === 1) {\n  \t\tvar nodeFact = arguments[0];\n  \t\tthis._nodes = new NodeMap(nodeFact);\n  \t}\n  }\n  extend(PlanarGraph.prototype, {\n  \tprintEdges: function printEdges(out) {\n  \t\tout.println(\"Edges:\");\n  \t\tfor (var i = 0; i < this._edges.size(); i++) {\n  \t\t\tout.println(\"edge \" + i + \":\");\n  \t\t\tvar e = this._edges.get(i);\n  \t\t\te.print(out);\n  \t\t\te.eiList.print(out);\n  \t\t}\n  \t},\n  \tfind: function find(coord) {\n  \t\treturn this._nodes.find(coord);\n  \t},\n  \taddNode: function addNode() {\n  \t\tif (arguments[0] instanceof Node) {\n  \t\t\tvar node = arguments[0];\n  \t\t\treturn this._nodes.addNode(node);\n  \t\t} else if (arguments[0] instanceof Coordinate) {\n  \t\t\tvar coord = arguments[0];\n  \t\t\treturn this._nodes.addNode(coord);\n  \t\t}\n  \t},\n  \tgetNodeIterator: function getNodeIterator() {\n  \t\treturn this._nodes.iterator();\n  \t},\n  \tlinkResultDirectedEdges: function linkResultDirectedEdges() {\n  \t\tfor (var nodeit = this._nodes.iterator(); nodeit.hasNext();) {\n  \t\t\tvar node = nodeit.next();\n  \t\t\tnode.getEdges().linkResultDirectedEdges();\n  \t\t}\n  \t},\n  \tdebugPrintln: function debugPrintln(o) {\n  \t\tSystem.out.println(o);\n  \t},\n  \tisBoundaryNode: function isBoundaryNode(geomIndex, coord) {\n  \t\tvar node = this._nodes.find(coord);\n  \t\tif (node === null) return false;\n  \t\tvar label = node.getLabel();\n  \t\tif (label !== null && label.getLocation(geomIndex) === Location.BOUNDARY) return true;\n  \t\treturn false;\n  \t},\n  \tlinkAllDirectedEdges: function linkAllDirectedEdges() {\n  \t\tfor (var nodeit = this._nodes.iterator(); nodeit.hasNext();) {\n  \t\t\tvar node = nodeit.next();\n  \t\t\tnode.getEdges().linkAllDirectedEdges();\n  \t\t}\n  \t},\n  \tmatchInSameDirection: function matchInSameDirection(p0, p1, ep0, ep1) {\n  \t\tif (!p0.equals(ep0)) return false;\n  \t\tif (CGAlgorithms.computeOrientation(p0, p1, ep1) === CGAlgorithms.COLLINEAR && Quadrant.quadrant(p0, p1) === Quadrant.quadrant(ep0, ep1)) return true;\n  \t\treturn false;\n  \t},\n  \tgetEdgeEnds: function getEdgeEnds() {\n  \t\treturn this._edgeEndList;\n  \t},\n  \tdebugPrint: function debugPrint(o) {\n  \t\tSystem.out.print(o);\n  \t},\n  \tgetEdgeIterator: function getEdgeIterator() {\n  \t\treturn this._edges.iterator();\n  \t},\n  \tfindEdgeInSameDirection: function findEdgeInSameDirection(p0, p1) {\n  \t\tfor (var i = 0; i < this._edges.size(); i++) {\n  \t\t\tvar e = this._edges.get(i);\n  \t\t\tvar eCoord = e.getCoordinates();\n  \t\t\tif (this.matchInSameDirection(p0, p1, eCoord[0], eCoord[1])) return e;\n  \t\t\tif (this.matchInSameDirection(p0, p1, eCoord[eCoord.length - 1], eCoord[eCoord.length - 2])) return e;\n  \t\t}\n  \t\treturn null;\n  \t},\n  \tinsertEdge: function insertEdge(e) {\n  \t\tthis._edges.add(e);\n  \t},\n  \tfindEdgeEnd: function findEdgeEnd(e) {\n  \t\tfor (var i = this.getEdgeEnds().iterator(); i.hasNext();) {\n  \t\t\tvar ee = i.next();\n  \t\t\tif (ee.getEdge() === e) return ee;\n  \t\t}\n  \t\treturn null;\n  \t},\n  \taddEdges: function addEdges(edgesToAdd) {\n  \t\tfor (var it = edgesToAdd.iterator(); it.hasNext();) {\n  \t\t\tvar e = it.next();\n  \t\t\tthis._edges.add(e);\n  \t\t\tvar de1 = new DirectedEdge(e, true);\n  \t\t\tvar de2 = new DirectedEdge(e, false);\n  \t\t\tde1.setSym(de2);\n  \t\t\tde2.setSym(de1);\n  \t\t\tthis.add(de1);\n  \t\t\tthis.add(de2);\n  \t\t}\n  \t},\n  \tadd: function add(e) {\n  \t\tthis._nodes.add(e);\n  \t\tthis._edgeEndList.add(e);\n  \t},\n  \tgetNodes: function getNodes() {\n  \t\treturn this._nodes.values();\n  \t},\n  \tfindEdge: function findEdge(p0, p1) {\n  \t\tfor (var i = 0; i < this._edges.size(); i++) {\n  \t\t\tvar e = this._edges.get(i);\n  \t\t\tvar eCoord = e.getCoordinates();\n  \t\t\tif (p0.equals(eCoord[0]) && p1.equals(eCoord[1])) return e;\n  \t\t}\n  \t\treturn null;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn PlanarGraph;\n  \t}\n  });\n  PlanarGraph.linkResultDirectedEdges = function (nodes) {\n  \tfor (var nodeit = nodes.iterator(); nodeit.hasNext();) {\n  \t\tvar node = nodeit.next();\n  \t\tnode.getEdges().linkResultDirectedEdges();\n  \t}\n  };\n\n  function PolygonBuilder() {\n  \tthis._geometryFactory = null;\n  \tthis._shellList = new ArrayList();\n  \tvar geometryFactory = arguments[0];\n  \tthis._geometryFactory = geometryFactory;\n  }\n  extend(PolygonBuilder.prototype, {\n  \tsortShellsAndHoles: function sortShellsAndHoles(edgeRings, shellList, freeHoleList) {\n  \t\tfor (var it = edgeRings.iterator(); it.hasNext();) {\n  \t\t\tvar er = it.next();\n  \t\t\tif (er.isHole()) {\n  \t\t\t\tfreeHoleList.add(er);\n  \t\t\t} else {\n  \t\t\t\tshellList.add(er);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcomputePolygons: function computePolygons(shellList) {\n  \t\tvar resultPolyList = new ArrayList();\n  \t\tfor (var it = shellList.iterator(); it.hasNext();) {\n  \t\t\tvar er = it.next();\n  \t\t\tvar poly = er.toPolygon(this._geometryFactory);\n  \t\t\tresultPolyList.add(poly);\n  \t\t}\n  \t\treturn resultPolyList;\n  \t},\n  \tplaceFreeHoles: function placeFreeHoles(shellList, freeHoleList) {\n  \t\tfor (var it = freeHoleList.iterator(); it.hasNext();) {\n  \t\t\tvar hole = it.next();\n  \t\t\tif (hole.getShell() === null) {\n  \t\t\t\tvar shell = this.findEdgeRingContaining(hole, shellList);\n  \t\t\t\tif (shell === null) throw new TopologyException(\"unable to assign hole to a shell\", hole.getCoordinate(0));\n  \t\t\t\thole.setShell(shell);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tbuildMinimalEdgeRings: function buildMinimalEdgeRings(maxEdgeRings, shellList, freeHoleList) {\n  \t\tvar edgeRings = new ArrayList();\n  \t\tfor (var it = maxEdgeRings.iterator(); it.hasNext();) {\n  \t\t\tvar er = it.next();\n  \t\t\tif (er.getMaxNodeDegree() > 2) {\n  \t\t\t\ter.linkDirectedEdgesForMinimalEdgeRings();\n  \t\t\t\tvar minEdgeRings = er.buildMinimalRings();\n  \t\t\t\tvar shell = this.findShell(minEdgeRings);\n  \t\t\t\tif (shell !== null) {\n  \t\t\t\t\tthis.placePolygonHoles(shell, minEdgeRings);\n  \t\t\t\t\tshellList.add(shell);\n  \t\t\t\t} else {\n  \t\t\t\t\tfreeHoleList.addAll(minEdgeRings);\n  \t\t\t\t}\n  \t\t\t} else {\n  \t\t\t\tedgeRings.add(er);\n  \t\t\t}\n  \t\t}\n  \t\treturn edgeRings;\n  \t},\n  \tcontainsPoint: function containsPoint(p) {\n  \t\tfor (var it = this._shellList.iterator(); it.hasNext();) {\n  \t\t\tvar er = it.next();\n  \t\t\tif (er.containsPoint(p)) return true;\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tbuildMaximalEdgeRings: function buildMaximalEdgeRings(dirEdges) {\n  \t\tvar maxEdgeRings = new ArrayList();\n  \t\tfor (var it = dirEdges.iterator(); it.hasNext();) {\n  \t\t\tvar de = it.next();\n  \t\t\tif (de.isInResult() && de.getLabel().isArea()) {\n  \t\t\t\tif (de.getEdgeRing() === null) {\n  \t\t\t\t\tvar er = new MaximalEdgeRing(de, this._geometryFactory);\n  \t\t\t\t\tmaxEdgeRings.add(er);\n  \t\t\t\t\ter.setInResult();\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\treturn maxEdgeRings;\n  \t},\n  \tplacePolygonHoles: function placePolygonHoles(shell, minEdgeRings) {\n  \t\tfor (var it = minEdgeRings.iterator(); it.hasNext();) {\n  \t\t\tvar er = it.next();\n  \t\t\tif (er.isHole()) {\n  \t\t\t\ter.setShell(shell);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetPolygons: function getPolygons() {\n  \t\tvar resultPolyList = this.computePolygons(this._shellList);\n  \t\treturn resultPolyList;\n  \t},\n  \tfindEdgeRingContaining: function findEdgeRingContaining(testEr, shellList) {\n  \t\tvar testRing = testEr.getLinearRing();\n  \t\tvar testEnv = testRing.getEnvelopeInternal();\n  \t\tvar testPt = testRing.getCoordinateN(0);\n  \t\tvar minShell = null;\n  \t\tvar minEnv = null;\n  \t\tfor (var it = shellList.iterator(); it.hasNext();) {\n  \t\t\tvar tryShell = it.next();\n  \t\t\tvar tryRing = tryShell.getLinearRing();\n  \t\t\tvar tryEnv = tryRing.getEnvelopeInternal();\n  \t\t\tif (minShell !== null) minEnv = minShell.getLinearRing().getEnvelopeInternal();\n  \t\t\tvar isContained = false;\n  \t\t\tif (tryEnv.contains(testEnv) && CGAlgorithms.isPointInRing(testPt, tryRing.getCoordinates())) isContained = true;\n  \t\t\tif (isContained) {\n  \t\t\t\tif (minShell === null || minEnv.contains(tryEnv)) {\n  \t\t\t\t\tminShell = tryShell;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\treturn minShell;\n  \t},\n  \tfindShell: function findShell(minEdgeRings) {\n  \t\tvar shellCount = 0;\n  \t\tvar shell = null;\n  \t\tfor (var it = minEdgeRings.iterator(); it.hasNext();) {\n  \t\t\tvar er = it.next();\n  \t\t\tif (!er.isHole()) {\n  \t\t\t\tshell = er;\n  \t\t\t\tshellCount++;\n  \t\t\t}\n  \t\t}\n  \t\tAssert.isTrue(shellCount <= 1, \"found two shells in MinimalEdgeRing list\");\n  \t\treturn shell;\n  \t},\n  \tadd: function add() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar graph = arguments[0];\n  \t\t\tthis.add(graph.getEdgeEnds(), graph.getNodes());\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar dirEdges = arguments[0],\n  \t\t\t    nodes = arguments[1];\n  \t\t\tPlanarGraph.linkResultDirectedEdges(nodes);\n  \t\t\tvar maxEdgeRings = this.buildMaximalEdgeRings(dirEdges);\n  \t\t\tvar freeHoleList = new ArrayList();\n  \t\t\tvar edgeRings = this.buildMinimalEdgeRings(maxEdgeRings, this._shellList, freeHoleList);\n  \t\t\tthis.sortShellsAndHoles(edgeRings, this._shellList, freeHoleList);\n  \t\t\tthis.placeFreeHoles(this._shellList, freeHoleList);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn PolygonBuilder;\n  \t}\n  });\n\n  function LineBuilder() {\n  \tthis._op = null;\n  \tthis._geometryFactory = null;\n  \tthis._ptLocator = null;\n  \tthis._lineEdgesList = new ArrayList();\n  \tthis._resultLineList = new ArrayList();\n  \tvar op = arguments[0],\n  \t    geometryFactory = arguments[1],\n  \t    ptLocator = arguments[2];\n  \tthis._op = op;\n  \tthis._geometryFactory = geometryFactory;\n  \tthis._ptLocator = ptLocator;\n  }\n  extend(LineBuilder.prototype, {\n  \tcollectLines: function collectLines(opCode) {\n  \t\tfor (var it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext();) {\n  \t\t\tvar de = it.next();\n  \t\t\tthis.collectLineEdge(de, opCode, this._lineEdgesList);\n  \t\t\tthis.collectBoundaryTouchEdge(de, opCode, this._lineEdgesList);\n  \t\t}\n  \t},\n  \tlabelIsolatedLine: function labelIsolatedLine(e, targetIndex) {\n  \t\tvar loc = this._ptLocator.locate(e.getCoordinate(), this._op.getArgGeometry(targetIndex));\n  \t\te.getLabel().setLocation(targetIndex, loc);\n  \t},\n  \tbuild: function build(opCode) {\n  \t\tthis.findCoveredLineEdges();\n  \t\tthis.collectLines(opCode);\n  \t\tthis.buildLines(opCode);\n  \t\treturn this._resultLineList;\n  \t},\n  \tcollectLineEdge: function collectLineEdge(de, opCode, edges) {\n  \t\tvar label = de.getLabel();\n  \t\tvar e = de.getEdge();\n  \t\tif (de.isLineEdge()) {\n  \t\t\tif (!de.isVisited() && OverlayOp.isResultOfOp(label, opCode) && !e.isCovered()) {\n  \t\t\t\tedges.add(e);\n  \t\t\t\tde.setVisitedEdge(true);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tfindCoveredLineEdges: function findCoveredLineEdges() {\n  \t\tfor (var nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext();) {\n  \t\t\tvar node = nodeit.next();\n  \t\t\tnode.getEdges().findCoveredLineEdges();\n  \t\t}\n  \t\tfor (var it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext();) {\n  \t\t\tvar de = it.next();\n  \t\t\tvar e = de.getEdge();\n  \t\t\tif (de.isLineEdge() && !e.isCoveredSet()) {\n  \t\t\t\tvar isCovered = this._op.isCoveredByA(de.getCoordinate());\n  \t\t\t\te.setCovered(isCovered);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tlabelIsolatedLines: function labelIsolatedLines(edgesList) {\n  \t\tfor (var it = edgesList.iterator(); it.hasNext();) {\n  \t\t\tvar e = it.next();\n  \t\t\tvar label = e.getLabel();\n  \t\t\tif (e.isIsolated()) {\n  \t\t\t\tif (label.isNull(0)) this.labelIsolatedLine(e, 0);else this.labelIsolatedLine(e, 1);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tbuildLines: function buildLines(opCode) {\n  \t\tfor (var it = this._lineEdgesList.iterator(); it.hasNext();) {\n  \t\t\tvar e = it.next();\n  \t\t\tvar label = e.getLabel();\n  \t\t\tvar line = this._geometryFactory.createLineString(e.getCoordinates());\n  \t\t\tthis._resultLineList.add(line);\n  \t\t\te.setInResult(true);\n  \t\t}\n  \t},\n  \tcollectBoundaryTouchEdge: function collectBoundaryTouchEdge(de, opCode, edges) {\n  \t\tvar label = de.getLabel();\n  \t\tif (de.isLineEdge()) return null;\n  \t\tif (de.isVisited()) return null;\n  \t\tif (de.isInteriorAreaEdge()) return null;\n  \t\tif (de.getEdge().isInResult()) return null;\n  \t\tAssert.isTrue(!(de.isInResult() || de.getSym().isInResult()) || !de.getEdge().isInResult());\n  \t\tif (OverlayOp.isResultOfOp(label, opCode) && opCode === OverlayOp.INTERSECTION) {\n  \t\t\tedges.add(de.getEdge());\n  \t\t\tde.setVisitedEdge(true);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LineBuilder;\n  \t}\n  });\n\n  function PointBuilder() {\n  \tthis._op = null;\n  \tthis._geometryFactory = null;\n  \tthis._resultPointList = new ArrayList();\n  \tvar op = arguments[0],\n  \t    geometryFactory = arguments[1];\n  \tthis._op = op;\n  \tthis._geometryFactory = geometryFactory;\n  }\n  extend(PointBuilder.prototype, {\n  \tfilterCoveredNodeToPoint: function filterCoveredNodeToPoint(n) {\n  \t\tvar coord = n.getCoordinate();\n  \t\tif (!this._op.isCoveredByLA(coord)) {\n  \t\t\tvar pt = this._geometryFactory.createPoint(coord);\n  \t\t\tthis._resultPointList.add(pt);\n  \t\t}\n  \t},\n  \textractNonCoveredResultNodes: function extractNonCoveredResultNodes(opCode) {\n  \t\tfor (var nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext();) {\n  \t\t\tvar n = nodeit.next();\n  \t\t\tif (n.isInResult()) continue;\n  \t\t\tif (n.isIncidentEdgeInResult()) continue;\n  \t\t\tif (n.getEdges().getDegree() === 0 || opCode === OverlayOp.INTERSECTION) {\n  \t\t\t\tvar label = n.getLabel();\n  \t\t\t\tif (OverlayOp.isResultOfOp(label, opCode)) {\n  \t\t\t\t\tthis.filterCoveredNodeToPoint(n);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tbuild: function build(opCode) {\n  \t\tthis.extractNonCoveredResultNodes(opCode);\n  \t\treturn this._resultPointList;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn PointBuilder;\n  \t}\n  });\n\n  function PointOnGeometryLocator() {}\n  extend(PointOnGeometryLocator.prototype, {\n  \tlocate: function locate(p) {},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn PointOnGeometryLocator;\n  \t}\n  });\n\n  function SimplePointInAreaLocator() {\n  \tthis._geom = null;\n  \tvar geom = arguments[0];\n  \tthis._geom = geom;\n  }\n  extend(SimplePointInAreaLocator.prototype, {\n  \tlocate: function locate(p) {\n  \t\treturn SimplePointInAreaLocator.locate(p, this._geom);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [PointOnGeometryLocator];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SimplePointInAreaLocator;\n  \t}\n  });\n  SimplePointInAreaLocator.isPointInRing = function (p, ring) {\n  \tif (!ring.getEnvelopeInternal().intersects(p)) return false;\n  \treturn CGAlgorithms.isPointInRing(p, ring.getCoordinates());\n  };\n  SimplePointInAreaLocator.containsPointInPolygon = function (p, poly) {\n  \tif (poly.isEmpty()) return false;\n  \tvar shell = poly.getExteriorRing();\n  \tif (!SimplePointInAreaLocator.isPointInRing(p, shell)) return false;\n  \tfor (var i = 0; i < poly.getNumInteriorRing(); i++) {\n  \t\tvar hole = poly.getInteriorRingN(i);\n  \t\tif (SimplePointInAreaLocator.isPointInRing(p, hole)) return false;\n  \t}\n  \treturn true;\n  };\n  SimplePointInAreaLocator.containsPoint = function (p, geom) {\n  \tif (geom instanceof Polygon) {\n  \t\treturn SimplePointInAreaLocator.containsPointInPolygon(p, geom);\n  \t} else if (geom instanceof GeometryCollection) {\n  \t\tvar geomi = new GeometryCollectionIterator(geom);\n  \t\twhile (geomi.hasNext()) {\n  \t\t\tvar g2 = geomi.next();\n  \t\t\tif (g2 !== geom) if (SimplePointInAreaLocator.containsPoint(p, g2)) return true;\n  \t\t}\n  \t}\n  \treturn false;\n  };\n  SimplePointInAreaLocator.locate = function (p, geom) {\n  \tif (geom.isEmpty()) return Location.EXTERIOR;\n  \tif (SimplePointInAreaLocator.containsPoint(p, geom)) return Location.INTERIOR;\n  \treturn Location.EXTERIOR;\n  };\n\n  function EdgeEndStar() {\n  \tthis._edgeMap = new TreeMap();\n  \tthis._edgeList = null;\n  \tthis._ptInAreaLocation = [Location.NONE, Location.NONE];\n  }\n  extend(EdgeEndStar.prototype, {\n  \tgetNextCW: function getNextCW(ee) {\n  \t\tthis.getEdges();\n  \t\tvar i = this._edgeList.indexOf(ee);\n  \t\tvar iNextCW = i - 1;\n  \t\tif (i === 0) iNextCW = this._edgeList.size() - 1;\n  \t\treturn this._edgeList.get(iNextCW);\n  \t},\n  \tpropagateSideLabels: function propagateSideLabels(geomIndex) {\n  \t\tvar startLoc = Location.NONE;\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar e = it.next();\n  \t\t\tvar label = e.getLabel();\n  \t\t\tif (label.isArea(geomIndex) && label.getLocation(geomIndex, Position.LEFT) !== Location.NONE) startLoc = label.getLocation(geomIndex, Position.LEFT);\n  \t\t}\n  \t\tif (startLoc === Location.NONE) return null;\n  \t\tvar currLoc = startLoc;\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar e = it.next();\n  \t\t\tvar label = e.getLabel();\n  \t\t\tif (label.getLocation(geomIndex, Position.ON) === Location.NONE) label.setLocation(geomIndex, Position.ON, currLoc);\n  \t\t\tif (label.isArea(geomIndex)) {\n  \t\t\t\tvar leftLoc = label.getLocation(geomIndex, Position.LEFT);\n  \t\t\t\tvar rightLoc = label.getLocation(geomIndex, Position.RIGHT);\n  \t\t\t\tif (rightLoc !== Location.NONE) {\n  \t\t\t\t\tif (rightLoc !== currLoc) throw new TopologyException(\"side location conflict\", e.getCoordinate());\n  \t\t\t\t\tif (leftLoc === Location.NONE) {\n  \t\t\t\t\t\tAssert.shouldNeverReachHere(\"found single null side (at \" + e.getCoordinate() + \")\");\n  \t\t\t\t\t}\n  \t\t\t\t\tcurrLoc = leftLoc;\n  \t\t\t\t} else {\n  \t\t\t\t\tAssert.isTrue(label.getLocation(geomIndex, Position.LEFT) === Location.NONE, \"found single null side\");\n  \t\t\t\t\tlabel.setLocation(geomIndex, Position.RIGHT, currLoc);\n  \t\t\t\t\tlabel.setLocation(geomIndex, Position.LEFT, currLoc);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\tvar it = this.iterator();\n  \t\tif (!it.hasNext()) return null;\n  \t\tvar e = it.next();\n  \t\treturn e.getCoordinate();\n  \t},\n  \tprint: function print(out) {\n  \t\tSystem.out.println(\"EdgeEndStar:   \" + this.getCoordinate());\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar e = it.next();\n  \t\t\te.print(out);\n  \t\t}\n  \t},\n  \tisAreaLabelsConsistent: function isAreaLabelsConsistent(geomGraph) {\n  \t\tthis.computeEdgeEndLabels(geomGraph.getBoundaryNodeRule());\n  \t\treturn this.checkAreaLabelsConsistent(0);\n  \t},\n  \tcheckAreaLabelsConsistent: function checkAreaLabelsConsistent(geomIndex) {\n  \t\tvar edges = this.getEdges();\n  \t\tif (edges.size() <= 0) return true;\n  \t\tvar lastEdgeIndex = edges.size() - 1;\n  \t\tvar startLabel = edges.get(lastEdgeIndex).getLabel();\n  \t\tvar startLoc = startLabel.getLocation(geomIndex, Position.LEFT);\n  \t\tAssert.isTrue(startLoc !== Location.NONE, \"Found unlabelled area edge\");\n  \t\tvar currLoc = startLoc;\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar e = it.next();\n  \t\t\tvar label = e.getLabel();\n  \t\t\tAssert.isTrue(label.isArea(geomIndex), \"Found non-area edge\");\n  \t\t\tvar leftLoc = label.getLocation(geomIndex, Position.LEFT);\n  \t\t\tvar rightLoc = label.getLocation(geomIndex, Position.RIGHT);\n  \t\t\tif (leftLoc === rightLoc) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t\tif (rightLoc !== currLoc) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t\tcurrLoc = leftLoc;\n  \t\t}\n  \t\treturn true;\n  \t},\n  \tfindIndex: function findIndex(eSearch) {\n  \t\tthis.iterator();\n  \t\tfor (var i = 0; i < this._edgeList.size(); i++) {\n  \t\t\tvar e = this._edgeList.get(i);\n  \t\t\tif (e === eSearch) return i;\n  \t\t}\n  \t\treturn -1;\n  \t},\n  \titerator: function iterator() {\n  \t\treturn this.getEdges().iterator();\n  \t},\n  \tgetEdges: function getEdges() {\n  \t\tif (this._edgeList === null) {\n  \t\t\tthis._edgeList = new ArrayList(this._edgeMap.values());\n  \t\t}\n  \t\treturn this._edgeList;\n  \t},\n  \tgetLocation: function getLocation(geomIndex, p, geom) {\n  \t\tif (this._ptInAreaLocation[geomIndex] === Location.NONE) {\n  \t\t\tthis._ptInAreaLocation[geomIndex] = SimplePointInAreaLocator.locate(p, geom[geomIndex].getGeometry());\n  \t\t}\n  \t\treturn this._ptInAreaLocation[geomIndex];\n  \t},\n  \ttoString: function toString() {\n  \t\tvar buf = new StringBuffer();\n  \t\tbuf.append(\"EdgeEndStar:   \" + this.getCoordinate());\n  \t\tbuf.append(\"\\n\");\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar e = it.next();\n  \t\t\tbuf.append(e);\n  \t\t\tbuf.append(\"\\n\");\n  \t\t}\n  \t\treturn buf.toString();\n  \t},\n  \tcomputeEdgeEndLabels: function computeEdgeEndLabels(boundaryNodeRule) {\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar ee = it.next();\n  \t\t\tee.computeLabel(boundaryNodeRule);\n  \t\t}\n  \t},\n  \tcomputeLabelling: function computeLabelling(geomGraph) {\n  \t\tthis.computeEdgeEndLabels(geomGraph[0].getBoundaryNodeRule());\n  \t\tthis.propagateSideLabels(0);\n  \t\tthis.propagateSideLabels(1);\n  \t\tvar hasDimensionalCollapseEdge = [false, false];\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar e = it.next();\n  \t\t\tvar label = e.getLabel();\n  \t\t\tfor (var geomi = 0; geomi < 2; geomi++) {\n  \t\t\t\tif (label.isLine(geomi) && label.getLocation(geomi) === Location.BOUNDARY) hasDimensionalCollapseEdge[geomi] = true;\n  \t\t\t}\n  \t\t}\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar e = it.next();\n  \t\t\tvar label = e.getLabel();\n  \t\t\tfor (var geomi = 0; geomi < 2; geomi++) {\n  \t\t\t\tif (label.isAnyNull(geomi)) {\n  \t\t\t\t\tvar loc = Location.NONE;\n  \t\t\t\t\tif (hasDimensionalCollapseEdge[geomi]) {\n  \t\t\t\t\t\tloc = Location.EXTERIOR;\n  \t\t\t\t\t} else {\n  \t\t\t\t\t\tvar p = e.getCoordinate();\n  \t\t\t\t\t\tloc = this.getLocation(geomi, p, geomGraph);\n  \t\t\t\t\t}\n  \t\t\t\t\tlabel.setAllLocationsIfNull(geomi, loc);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetDegree: function getDegree() {\n  \t\treturn this._edgeMap.size();\n  \t},\n  \tinsertEdgeEnd: function insertEdgeEnd(e, obj) {\n  \t\tthis._edgeMap.put(e, obj);\n  \t\tthis._edgeList = null;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn EdgeEndStar;\n  \t}\n  });\n\n  function DirectedEdgeStar() {\n  \tEdgeEndStar.apply(this);\n  \tthis._resultAreaEdgeList = null;\n  \tthis._label = null;\n  \tthis._SCANNING_FOR_INCOMING = 1;\n  \tthis._LINKING_TO_OUTGOING = 2;\n  }\n  inherits$1(DirectedEdgeStar, EdgeEndStar);\n  extend(DirectedEdgeStar.prototype, {\n  \tlinkResultDirectedEdges: function linkResultDirectedEdges() {\n  \t\tthis.getResultAreaEdges();\n  \t\tvar firstOut = null;\n  \t\tvar incoming = null;\n  \t\tvar state = this._SCANNING_FOR_INCOMING;\n  \t\tfor (var i = 0; i < this._resultAreaEdgeList.size(); i++) {\n  \t\t\tvar nextOut = this._resultAreaEdgeList.get(i);\n  \t\t\tvar nextIn = nextOut.getSym();\n  \t\t\tif (!nextOut.getLabel().isArea()) continue;\n  \t\t\tif (firstOut === null && nextOut.isInResult()) firstOut = nextOut;\n  \t\t\tswitch (state) {\n  \t\t\t\tcase this._SCANNING_FOR_INCOMING:\n  \t\t\t\t\tif (!nextIn.isInResult()) continue;\n  \t\t\t\t\tincoming = nextIn;\n  \t\t\t\t\tstate = this._LINKING_TO_OUTGOING;\n  \t\t\t\t\tbreak;\n  \t\t\t\tcase this._LINKING_TO_OUTGOING:\n  \t\t\t\t\tif (!nextOut.isInResult()) continue;\n  \t\t\t\t\tincoming.setNext(nextOut);\n  \t\t\t\t\tstate = this._SCANNING_FOR_INCOMING;\n  \t\t\t\t\tbreak;\n  \t\t\t}\n  \t\t}\n  \t\tif (state === this._LINKING_TO_OUTGOING) {\n  \t\t\tif (firstOut === null) throw new TopologyException(\"no outgoing dirEdge found\", this.getCoordinate());\n  \t\t\tAssert.isTrue(firstOut.isInResult(), \"unable to link last incoming dirEdge\");\n  \t\t\tincoming.setNext(firstOut);\n  \t\t}\n  \t},\n  \tinsert: function insert(ee) {\n  \t\tvar de = ee;\n  \t\tthis.insertEdgeEnd(de, de);\n  \t},\n  \tgetRightmostEdge: function getRightmostEdge() {\n  \t\tvar edges = this.getEdges();\n  \t\tvar size = edges.size();\n  \t\tif (size < 1) return null;\n  \t\tvar de0 = edges.get(0);\n  \t\tif (size === 1) return de0;\n  \t\tvar deLast = edges.get(size - 1);\n  \t\tvar quad0 = de0.getQuadrant();\n  \t\tvar quad1 = deLast.getQuadrant();\n  \t\tif (Quadrant.isNorthern(quad0) && Quadrant.isNorthern(quad1)) return de0;else if (!Quadrant.isNorthern(quad0) && !Quadrant.isNorthern(quad1)) return deLast;else {\n  \t\t\tif (de0.getDy() !== 0) return de0;else if (deLast.getDy() !== 0) return deLast;\n  \t\t}\n  \t\tAssert.shouldNeverReachHere(\"found two horizontal edges incident on node\");\n  \t\treturn null;\n  \t},\n  \tprint: function print(out) {\n  \t\tSystem.out.println(\"DirectedEdgeStar: \" + this.getCoordinate());\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar de = it.next();\n  \t\t\tout.print(\"out \");\n  \t\t\tde.print(out);\n  \t\t\tout.println();\n  \t\t\tout.print(\"in \");\n  \t\t\tde.getSym().print(out);\n  \t\t\tout.println();\n  \t\t}\n  \t},\n  \tgetResultAreaEdges: function getResultAreaEdges() {\n  \t\tif (this._resultAreaEdgeList !== null) return this._resultAreaEdgeList;\n  \t\tthis._resultAreaEdgeList = new ArrayList();\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar de = it.next();\n  \t\t\tif (de.isInResult() || de.getSym().isInResult()) this._resultAreaEdgeList.add(de);\n  \t\t}\n  \t\treturn this._resultAreaEdgeList;\n  \t},\n  \tupdateLabelling: function updateLabelling(nodeLabel) {\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar de = it.next();\n  \t\t\tvar label = de.getLabel();\n  \t\t\tlabel.setAllLocationsIfNull(0, nodeLabel.getLocation(0));\n  \t\t\tlabel.setAllLocationsIfNull(1, nodeLabel.getLocation(1));\n  \t\t}\n  \t},\n  \tlinkAllDirectedEdges: function linkAllDirectedEdges() {\n  \t\tthis.getEdges();\n  \t\tvar prevOut = null;\n  \t\tvar firstIn = null;\n  \t\tfor (var i = this._edgeList.size() - 1; i >= 0; i--) {\n  \t\t\tvar nextOut = this._edgeList.get(i);\n  \t\t\tvar nextIn = nextOut.getSym();\n  \t\t\tif (firstIn === null) firstIn = nextIn;\n  \t\t\tif (prevOut !== null) nextIn.setNext(prevOut);\n  \t\t\tprevOut = nextOut;\n  \t\t}\n  \t\tfirstIn.setNext(prevOut);\n  \t},\n  \tcomputeDepths: function computeDepths() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar de = arguments[0];\n  \t\t\tvar edgeIndex = this.findIndex(de);\n  \t\t\tvar label = de.getLabel();\n  \t\t\tvar startDepth = de.getDepth(Position.LEFT);\n  \t\t\tvar targetLastDepth = de.getDepth(Position.RIGHT);\n  \t\t\tvar nextDepth = this.computeDepths(edgeIndex + 1, this._edgeList.size(), startDepth);\n  \t\t\tvar lastDepth = this.computeDepths(0, edgeIndex, nextDepth);\n  \t\t\tif (lastDepth !== targetLastDepth) throw new TopologyException(\"depth mismatch at \" + de.getCoordinate());\n  \t\t} else if (arguments.length === 3) {\n  \t\t\tvar startIndex = arguments[0],\n  \t\t\t    endIndex = arguments[1],\n  \t\t\t    startDepth = arguments[2];\n  \t\t\tvar currDepth = startDepth;\n  \t\t\tfor (var i = startIndex; i < endIndex; i++) {\n  \t\t\t\tvar nextDe = this._edgeList.get(i);\n  \t\t\t\tvar label = nextDe.getLabel();\n  \t\t\t\tnextDe.setEdgeDepths(Position.RIGHT, currDepth);\n  \t\t\t\tcurrDepth = nextDe.getDepth(Position.LEFT);\n  \t\t\t}\n  \t\t\treturn currDepth;\n  \t\t}\n  \t},\n  \tmergeSymLabels: function mergeSymLabels() {\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar de = it.next();\n  \t\t\tvar label = de.getLabel();\n  \t\t\tlabel.merge(de.getSym().getLabel());\n  \t\t}\n  \t},\n  \tlinkMinimalDirectedEdges: function linkMinimalDirectedEdges(er) {\n  \t\tvar firstOut = null;\n  \t\tvar incoming = null;\n  \t\tvar state = this._SCANNING_FOR_INCOMING;\n  \t\tfor (var i = this._resultAreaEdgeList.size() - 1; i >= 0; i--) {\n  \t\t\tvar nextOut = this._resultAreaEdgeList.get(i);\n  \t\t\tvar nextIn = nextOut.getSym();\n  \t\t\tif (firstOut === null && nextOut.getEdgeRing() === er) firstOut = nextOut;\n  \t\t\tswitch (state) {\n  \t\t\t\tcase this._SCANNING_FOR_INCOMING:\n  \t\t\t\t\tif (nextIn.getEdgeRing() !== er) continue;\n  \t\t\t\t\tincoming = nextIn;\n  \t\t\t\t\tstate = this._LINKING_TO_OUTGOING;\n  \t\t\t\t\tbreak;\n  \t\t\t\tcase this._LINKING_TO_OUTGOING:\n  \t\t\t\t\tif (nextOut.getEdgeRing() !== er) continue;\n  \t\t\t\t\tincoming.setNextMin(nextOut);\n  \t\t\t\t\tstate = this._SCANNING_FOR_INCOMING;\n  \t\t\t\t\tbreak;\n  \t\t\t}\n  \t\t}\n  \t\tif (state === this._LINKING_TO_OUTGOING) {\n  \t\t\tAssert.isTrue(firstOut !== null, \"found null for first outgoing dirEdge\");\n  \t\t\tAssert.isTrue(firstOut.getEdgeRing() === er, \"unable to link last incoming dirEdge\");\n  \t\t\tincoming.setNextMin(firstOut);\n  \t\t}\n  \t},\n  \tgetOutgoingDegree: function getOutgoingDegree() {\n  \t\tif (arguments.length === 0) {\n  \t\t\tvar degree = 0;\n  \t\t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\t\tvar de = it.next();\n  \t\t\t\tif (de.isInResult()) degree++;\n  \t\t\t}\n  \t\t\treturn degree;\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tvar er = arguments[0];\n  \t\t\tvar degree = 0;\n  \t\t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\t\tvar de = it.next();\n  \t\t\t\tif (de.getEdgeRing() === er) degree++;\n  \t\t\t}\n  \t\t\treturn degree;\n  \t\t}\n  \t},\n  \tgetLabel: function getLabel() {\n  \t\treturn this._label;\n  \t},\n  \tfindCoveredLineEdges: function findCoveredLineEdges() {\n  \t\tvar startLoc = Location.NONE;\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar nextOut = it.next();\n  \t\t\tvar nextIn = nextOut.getSym();\n  \t\t\tif (!nextOut.isLineEdge()) {\n  \t\t\t\tif (nextOut.isInResult()) {\n  \t\t\t\t\tstartLoc = Location.INTERIOR;\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t\tif (nextIn.isInResult()) {\n  \t\t\t\t\tstartLoc = Location.EXTERIOR;\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\tif (startLoc === Location.NONE) return null;\n  \t\tvar currLoc = startLoc;\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar nextOut = it.next();\n  \t\t\tvar nextIn = nextOut.getSym();\n  \t\t\tif (nextOut.isLineEdge()) {\n  \t\t\t\tnextOut.getEdge().setCovered(currLoc === Location.INTERIOR);\n  \t\t\t} else {\n  \t\t\t\tif (nextOut.isInResult()) currLoc = Location.EXTERIOR;\n  \t\t\t\tif (nextIn.isInResult()) currLoc = Location.INTERIOR;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcomputeLabelling: function computeLabelling(geom) {\n  \t\tEdgeEndStar.prototype.computeLabelling.call(this, geom);\n  \t\tthis._label = new Label(Location.NONE);\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar ee = it.next();\n  \t\t\tvar e = ee.getEdge();\n  \t\t\tvar eLabel = e.getLabel();\n  \t\t\tfor (var i = 0; i < 2; i++) {\n  \t\t\t\tvar eLoc = eLabel.getLocation(i);\n  \t\t\t\tif (eLoc === Location.INTERIOR || eLoc === Location.BOUNDARY) this._label.setLocation(i, Location.INTERIOR);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn DirectedEdgeStar;\n  \t}\n  });\n\n  function OverlayNodeFactory() {\n  \tNodeFactory.apply(this);\n  }\n  inherits$1(OverlayNodeFactory, NodeFactory);\n  extend(OverlayNodeFactory.prototype, {\n  \tcreateNode: function createNode(coord) {\n  \t\treturn new Node(coord, new DirectedEdgeStar());\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn OverlayNodeFactory;\n  \t}\n  });\n\n  function MonotoneChain$1() {\n  \tthis.mce = null;\n  \tthis.chainIndex = null;\n  \tvar mce = arguments[0],\n  \t    chainIndex = arguments[1];\n  \tthis.mce = mce;\n  \tthis.chainIndex = chainIndex;\n  }\n  extend(MonotoneChain$1.prototype, {\n  \tcomputeIntersections: function computeIntersections(mc, si) {\n  \t\tthis.mce.computeIntersectsForChain(this.chainIndex, mc.mce, mc.chainIndex, si);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MonotoneChain$1;\n  \t}\n  });\n\n  function SweepLineEvent() {\n  \tthis._label = null;\n  \tthis._xValue = null;\n  \tthis._eventType = null;\n  \tthis._insertEvent = null;\n  \tthis._deleteEventIndex = null;\n  \tthis._obj = null;\n  \tif (arguments.length === 2) {\n  \t\tvar x = arguments[0],\n  \t\t    insertEvent = arguments[1];\n  \t\tthis._eventType = SweepLineEvent.DELETE;\n  \t\tthis._xValue = x;\n  \t\tthis._insertEvent = insertEvent;\n  \t} else if (arguments.length === 3) {\n  \t\tvar label = arguments[0],\n  \t\t    x = arguments[1],\n  \t\t    obj = arguments[2];\n  \t\tthis._eventType = SweepLineEvent.INSERT;\n  \t\tthis._label = label;\n  \t\tthis._xValue = x;\n  \t\tthis._obj = obj;\n  \t}\n  }\n  extend(SweepLineEvent.prototype, {\n  \tisDelete: function isDelete() {\n  \t\treturn this._eventType === SweepLineEvent.DELETE;\n  \t},\n  \tsetDeleteEventIndex: function setDeleteEventIndex(deleteEventIndex) {\n  \t\tthis._deleteEventIndex = deleteEventIndex;\n  \t},\n  \tgetObject: function getObject() {\n  \t\treturn this._obj;\n  \t},\n  \tcompareTo: function compareTo(o) {\n  \t\tvar pe = o;\n  \t\tif (this._xValue < pe._xValue) return -1;\n  \t\tif (this._xValue > pe._xValue) return 1;\n  \t\tif (this._eventType < pe._eventType) return -1;\n  \t\tif (this._eventType > pe._eventType) return 1;\n  \t\treturn 0;\n  \t},\n  \tgetInsertEvent: function getInsertEvent() {\n  \t\treturn this._insertEvent;\n  \t},\n  \tisInsert: function isInsert() {\n  \t\treturn this._eventType === SweepLineEvent.INSERT;\n  \t},\n  \tisSameLabel: function isSameLabel(ev) {\n  \t\tif (this._label === null) return false;\n  \t\treturn this._label === ev._label;\n  \t},\n  \tgetDeleteEventIndex: function getDeleteEventIndex() {\n  \t\treturn this._deleteEventIndex;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SweepLineEvent;\n  \t}\n  });\n  SweepLineEvent.INSERT = 1;\n  SweepLineEvent.DELETE = 2;\n\n  function EdgeSetIntersector() {}\n  extend(EdgeSetIntersector.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn EdgeSetIntersector;\n  \t}\n  });\n\n  function SegmentIntersector$1() {\n  \tthis._hasIntersection = false;\n  \tthis._hasProper = false;\n  \tthis._hasProperInterior = false;\n  \tthis._properIntersectionPoint = null;\n  \tthis._li = null;\n  \tthis._includeProper = null;\n  \tthis._recordIsolated = null;\n  \tthis._isSelfIntersection = null;\n  \tthis._numIntersections = 0;\n  \tthis.numTests = 0;\n  \tthis._bdyNodes = null;\n  \tthis._isDone = false;\n  \tthis._isDoneWhenProperInt = false;\n  \tvar li = arguments[0],\n  \t    includeProper = arguments[1],\n  \t    recordIsolated = arguments[2];\n  \tthis._li = li;\n  \tthis._includeProper = includeProper;\n  \tthis._recordIsolated = recordIsolated;\n  }\n  extend(SegmentIntersector$1.prototype, {\n  \tisTrivialIntersection: function isTrivialIntersection(e0, segIndex0, e1, segIndex1) {\n  \t\tif (e0 === e1) {\n  \t\t\tif (this._li.getIntersectionNum() === 1) {\n  \t\t\t\tif (SegmentIntersector$1.isAdjacentSegments(segIndex0, segIndex1)) return true;\n  \t\t\t\tif (e0.isClosed()) {\n  \t\t\t\t\tvar maxSegIndex = e0.getNumPoints() - 1;\n  \t\t\t\t\tif (segIndex0 === 0 && segIndex1 === maxSegIndex || segIndex1 === 0 && segIndex0 === maxSegIndex) {\n  \t\t\t\t\t\treturn true;\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tgetProperIntersectionPoint: function getProperIntersectionPoint() {\n  \t\treturn this._properIntersectionPoint;\n  \t},\n  \tsetIsDoneIfProperInt: function setIsDoneIfProperInt(isDoneWhenProperInt) {\n  \t\tthis._isDoneWhenProperInt = isDoneWhenProperInt;\n  \t},\n  \thasProperInteriorIntersection: function hasProperInteriorIntersection() {\n  \t\treturn this._hasProperInterior;\n  \t},\n  \tisBoundaryPointInternal: function isBoundaryPointInternal(li, bdyNodes) {\n  \t\tfor (var i = bdyNodes.iterator(); i.hasNext();) {\n  \t\t\tvar node = i.next();\n  \t\t\tvar pt = node.getCoordinate();\n  \t\t\tif (li.isIntersection(pt)) return true;\n  \t\t}\n  \t\treturn false;\n  \t},\n  \thasProperIntersection: function hasProperIntersection() {\n  \t\treturn this._hasProper;\n  \t},\n  \thasIntersection: function hasIntersection() {\n  \t\treturn this._hasIntersection;\n  \t},\n  \tisDone: function isDone() {\n  \t\treturn this._isDone;\n  \t},\n  \tisBoundaryPoint: function isBoundaryPoint(li, bdyNodes) {\n  \t\tif (bdyNodes === null) return false;\n  \t\tif (this.isBoundaryPointInternal(li, bdyNodes[0])) return true;\n  \t\tif (this.isBoundaryPointInternal(li, bdyNodes[1])) return true;\n  \t\treturn false;\n  \t},\n  \tsetBoundaryNodes: function setBoundaryNodes(bdyNodes0, bdyNodes1) {\n  \t\tthis._bdyNodes = new Array(2).fill(null);\n  \t\tthis._bdyNodes[0] = bdyNodes0;\n  \t\tthis._bdyNodes[1] = bdyNodes1;\n  \t},\n  \taddIntersections: function addIntersections(e0, segIndex0, e1, segIndex1) {\n  \t\tif (e0 === e1 && segIndex0 === segIndex1) return null;\n  \t\tthis.numTests++;\n  \t\tvar p00 = e0.getCoordinates()[segIndex0];\n  \t\tvar p01 = e0.getCoordinates()[segIndex0 + 1];\n  \t\tvar p10 = e1.getCoordinates()[segIndex1];\n  \t\tvar p11 = e1.getCoordinates()[segIndex1 + 1];\n  \t\tthis._li.computeIntersection(p00, p01, p10, p11);\n  \t\tif (this._li.hasIntersection()) {\n  \t\t\tif (this._recordIsolated) {\n  \t\t\t\te0.setIsolated(false);\n  \t\t\t\te1.setIsolated(false);\n  \t\t\t}\n  \t\t\tthis._numIntersections++;\n  \t\t\tif (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {\n  \t\t\t\tthis._hasIntersection = true;\n  \t\t\t\tif (this._includeProper || !this._li.isProper()) {\n  \t\t\t\t\te0.addIntersections(this._li, segIndex0, 0);\n  \t\t\t\t\te1.addIntersections(this._li, segIndex1, 1);\n  \t\t\t\t}\n  \t\t\t\tif (this._li.isProper()) {\n  \t\t\t\t\tthis._properIntersectionPoint = this._li.getIntersection(0).copy();\n  \t\t\t\t\tthis._hasProper = true;\n  \t\t\t\t\tif (this._isDoneWhenProperInt) {\n  \t\t\t\t\t\tthis._isDone = true;\n  \t\t\t\t\t}\n  \t\t\t\t\tif (!this.isBoundaryPoint(this._li, this._bdyNodes)) this._hasProperInterior = true;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SegmentIntersector$1;\n  \t}\n  });\n  SegmentIntersector$1.isAdjacentSegments = function (i1, i2) {\n  \treturn Math.abs(i1 - i2) === 1;\n  };\n\n  function SimpleMCSweepLineIntersector() {\n  \tEdgeSetIntersector.apply(this);\n  \tthis.events = new ArrayList();\n  \tthis.nOverlaps = null;\n  }\n  inherits$1(SimpleMCSweepLineIntersector, EdgeSetIntersector);\n  extend(SimpleMCSweepLineIntersector.prototype, {\n  \tprepareEvents: function prepareEvents() {\n  \t\tCollections.sort(this.events);\n  \t\tfor (var i = 0; i < this.events.size(); i++) {\n  \t\t\tvar ev = this.events.get(i);\n  \t\t\tif (ev.isDelete()) {\n  \t\t\t\tev.getInsertEvent().setDeleteEventIndex(i);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcomputeIntersections: function computeIntersections() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar si = arguments[0];\n  \t\t\tthis.nOverlaps = 0;\n  \t\t\tthis.prepareEvents();\n  \t\t\tfor (var i = 0; i < this.events.size(); i++) {\n  \t\t\t\tvar ev = this.events.get(i);\n  \t\t\t\tif (ev.isInsert()) {\n  \t\t\t\t\tthis.processOverlaps(i, ev.getDeleteEventIndex(), ev, si);\n  \t\t\t\t}\n  \t\t\t\tif (si.isDone()) {\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} else if (arguments.length === 3) {\n  \t\t\tif (arguments[2] instanceof SegmentIntersector$1 && hasInterface(arguments[0], List) && hasInterface(arguments[1], List)) {\n  \t\t\t\tvar edges0 = arguments[0],\n  \t\t\t\t    edges1 = arguments[1],\n  \t\t\t\t    si = arguments[2];\n  \t\t\t\tthis.addEdges(edges0, edges0);\n  \t\t\t\tthis.addEdges(edges1, edges1);\n  \t\t\t\tthis.computeIntersections(si);\n  \t\t\t} else if (typeof arguments[2] === \"boolean\" && hasInterface(arguments[0], List) && arguments[1] instanceof SegmentIntersector$1) {\n  \t\t\t\tvar edges = arguments[0],\n  \t\t\t\t    si = arguments[1],\n  \t\t\t\t    testAllSegments = arguments[2];\n  \t\t\t\tif (testAllSegments) this.addEdges(edges, null);else this.addEdges(edges);\n  \t\t\t\tthis.computeIntersections(si);\n  \t\t\t}\n  \t\t}\n  \t},\n  \taddEdge: function addEdge(edge, edgeSet) {\n  \t\tvar mce = edge.getMonotoneChainEdge();\n  \t\tvar startIndex = mce.getStartIndexes();\n  \t\tfor (var i = 0; i < startIndex.length - 1; i++) {\n  \t\t\tvar mc = new MonotoneChain$1(mce, i);\n  \t\t\tvar insertEvent = new SweepLineEvent(edgeSet, mce.getMinX(i), mc);\n  \t\t\tthis.events.add(insertEvent);\n  \t\t\tthis.events.add(new SweepLineEvent(mce.getMaxX(i), insertEvent));\n  \t\t}\n  \t},\n  \tprocessOverlaps: function processOverlaps(start, end, ev0, si) {\n  \t\tvar mc0 = ev0.getObject();\n  \t\tfor (var i = start; i < end; i++) {\n  \t\t\tvar ev1 = this.events.get(i);\n  \t\t\tif (ev1.isInsert()) {\n  \t\t\t\tvar mc1 = ev1.getObject();\n  \t\t\t\tif (!ev0.isSameLabel(ev1)) {\n  \t\t\t\t\tmc0.computeIntersections(mc1, si);\n  \t\t\t\t\tthis.nOverlaps++;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \taddEdges: function addEdges() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar edges = arguments[0];\n  \t\t\tfor (var i = edges.iterator(); i.hasNext();) {\n  \t\t\t\tvar edge = i.next();\n  \t\t\t\tthis.addEdge(edge, edge);\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar edges = arguments[0],\n  \t\t\t    edgeSet = arguments[1];\n  \t\t\tfor (var i = edges.iterator(); i.hasNext();) {\n  \t\t\t\tvar edge = i.next();\n  \t\t\t\tthis.addEdge(edge, edgeSet);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SimpleMCSweepLineIntersector;\n  \t}\n  });\n\n  function IntervalRTreeNode$1() {\n  \tthis._min = Double.POSITIVE_INFINITY;\n  \tthis._max = Double.NEGATIVE_INFINITY;\n  }\n  extend(IntervalRTreeNode$1.prototype, {\n  \tgetMin: function getMin() {\n  \t\treturn this._min;\n  \t},\n  \tintersects: function intersects(queryMin, queryMax) {\n  \t\tif (this._min > queryMax || this._max < queryMin) return false;\n  \t\treturn true;\n  \t},\n  \tgetMax: function getMax() {\n  \t\treturn this._max;\n  \t},\n  \ttoString: function toString() {\n  \t\treturn WKTWriter.toLineString(new Coordinate(this._min, 0), new Coordinate(this._max, 0));\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn IntervalRTreeNode$1;\n  \t}\n  });\n  function NodeComparator() {}\n  extend(NodeComparator.prototype, {\n  \tcompare: function compare(o1, o2) {\n  \t\tvar n1 = o1;\n  \t\tvar n2 = o2;\n  \t\tvar mid1 = (n1._min + n1._max) / 2;\n  \t\tvar mid2 = (n2._min + n2._max) / 2;\n  \t\tif (mid1 < mid2) return -1;\n  \t\tif (mid1 > mid2) return 1;\n  \t\treturn 0;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparator];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn NodeComparator;\n  \t}\n  });\n  IntervalRTreeNode$1.NodeComparator = NodeComparator;\n\n  function IntervalRTreeLeafNode() {\n  \tIntervalRTreeNode$1.apply(this);\n  \tthis._item = null;\n  \tvar min = arguments[0],\n  \t    max = arguments[1],\n  \t    item = arguments[2];\n  \tthis._min = min;\n  \tthis._max = max;\n  \tthis._item = item;\n  }\n  inherits$1(IntervalRTreeLeafNode, IntervalRTreeNode$1);\n  extend(IntervalRTreeLeafNode.prototype, {\n  \tquery: function query(queryMin, queryMax, visitor) {\n  \t\tif (!this.intersects(queryMin, queryMax)) return null;\n  \t\tvisitor.visitItem(this._item);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn IntervalRTreeLeafNode;\n  \t}\n  });\n\n  function IntervalRTreeBranchNode() {\n  \tIntervalRTreeNode$1.apply(this);\n  \tthis._node1 = null;\n  \tthis._node2 = null;\n  \tvar n1 = arguments[0],\n  \t    n2 = arguments[1];\n  \tthis._node1 = n1;\n  \tthis._node2 = n2;\n  \tthis.buildExtent(this._node1, this._node2);\n  }\n  inherits$1(IntervalRTreeBranchNode, IntervalRTreeNode$1);\n  extend(IntervalRTreeBranchNode.prototype, {\n  \tbuildExtent: function buildExtent(n1, n2) {\n  \t\tthis._min = Math.min(n1._min, n2._min);\n  \t\tthis._max = Math.max(n1._max, n2._max);\n  \t},\n  \tquery: function query(queryMin, queryMax, visitor) {\n  \t\tif (!this.intersects(queryMin, queryMax)) {\n  \t\t\treturn null;\n  \t\t}\n  \t\tif (this._node1 !== null) this._node1.query(queryMin, queryMax, visitor);\n  \t\tif (this._node2 !== null) this._node2.query(queryMin, queryMax, visitor);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn IntervalRTreeBranchNode;\n  \t}\n  });\n\n  function SortedPackedIntervalRTree() {\n  \tthis._leaves = new ArrayList();\n  \tthis._root = null;\n  \tthis._level = 0;\n  }\n  extend(SortedPackedIntervalRTree.prototype, {\n  \tbuildTree: function buildTree() {\n  \t\tCollections.sort(this._leaves, new IntervalRTreeNode.NodeComparator());\n  \t\tvar src = this._leaves;\n  \t\tvar temp = null;\n  \t\tvar dest = new ArrayList();\n  \t\twhile (true) {\n  \t\t\tthis.buildLevel(src, dest);\n  \t\t\tif (dest.size() === 1) return dest.get(0);\n  \t\t\ttemp = src;\n  \t\t\tsrc = dest;\n  \t\t\tdest = temp;\n  \t\t}\n  \t},\n  \tinsert: function insert(min, max, item) {\n  \t\tif (this._root !== null) throw new IllegalStateException(\"Index cannot be added to once it has been queried\");\n  \t\tthis._leaves.add(new IntervalRTreeLeafNode(min, max, item));\n  \t},\n  \tquery: function query(min, max, visitor) {\n  \t\tthis.init();\n  \t\tthis._root.query(min, max, visitor);\n  \t},\n  \tbuildRoot: function buildRoot() {\n  \t\tif (this._root !== null) return null;\n  \t\tthis._root = this.buildTree();\n  \t},\n  \tprintNode: function printNode(node) {\n  \t\tSystem.out.println(WKTWriter.toLineString(new Coordinate(node._min, this._level), new Coordinate(node._max, this._level)));\n  \t},\n  \tinit: function init() {\n  \t\tif (this._root !== null) return null;\n  \t\tthis.buildRoot();\n  \t},\n  \tbuildLevel: function buildLevel(src, dest) {\n  \t\tthis._level++;\n  \t\tdest.clear();\n  \t\tfor (var i = 0; i < src.size(); i += 2) {\n  \t\t\tvar n1 = src.get(i);\n  \t\t\tvar n2 = i + 1 < src.size() ? src.get(i) : null;\n  \t\t\tif (n2 === null) {\n  \t\t\t\tdest.add(n1);\n  \t\t\t} else {\n  \t\t\t\tvar node = new IntervalRTreeBranchNode(src.get(i), src.get(i + 1));\n  \t\t\t\tdest.add(node);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SortedPackedIntervalRTree;\n  \t}\n  });\n\n  function LinearComponentExtracter() {\n  \tthis._lines = null;\n  \tthis._isForcedToLineString = false;\n  \tif (arguments.length === 1) {\n  \t\tvar lines = arguments[0];\n  \t\tthis._lines = lines;\n  \t} else if (arguments.length === 2) {\n  \t\tvar lines = arguments[0],\n  \t\t    isForcedToLineString = arguments[1];\n  \t\tthis._lines = lines;\n  \t\tthis._isForcedToLineString = isForcedToLineString;\n  \t}\n  }\n  extend(LinearComponentExtracter.prototype, {\n  \tfilter: function filter(geom) {\n  \t\tif (this._isForcedToLineString && geom instanceof LinearRing) {\n  \t\t\tvar line = geom.getFactory().createLineString(geom.getCoordinateSequence());\n  \t\t\tthis._lines.add(line);\n  \t\t\treturn null;\n  \t\t}\n  \t\tif (geom instanceof LineString) this._lines.add(geom);\n  \t},\n  \tsetForceToLineString: function setForceToLineString(isForcedToLineString) {\n  \t\tthis._isForcedToLineString = isForcedToLineString;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [GeometryComponentFilter];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LinearComponentExtracter;\n  \t}\n  });\n  LinearComponentExtracter.getGeometry = function () {\n  \tif (arguments.length === 1) {\n  \t\tvar geom = arguments[0];\n  \t\treturn geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom));\n  \t} else if (arguments.length === 2) {\n  \t\tvar geom = arguments[0],\n  \t\t    forceToLineString = arguments[1];\n  \t\treturn geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom, forceToLineString));\n  \t}\n  };\n  LinearComponentExtracter.getLines = function () {\n  \tif (arguments.length === 1) {\n  \t\tvar geom = arguments[0];\n  \t\treturn LinearComponentExtracter.getLines(geom, false);\n  \t} else if (arguments.length === 2) {\n  \t\tif (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection)) {\n  \t\t\tvar geoms = arguments[0],\n  \t\t\t    lines = arguments[1];\n  \t\t\tfor (var i = geoms.iterator(); i.hasNext();) {\n  \t\t\t\tvar g = i.next();\n  \t\t\t\tLinearComponentExtracter.getLines(g, lines);\n  \t\t\t}\n  \t\t\treturn lines;\n  \t\t} else if (arguments[0] instanceof Geometry && typeof arguments[1] === \"boolean\") {\n  \t\t\tvar geom = arguments[0],\n  \t\t\t    forceToLineString = arguments[1];\n  \t\t\tvar lines = new ArrayList();\n  \t\t\tgeom.apply(new LinearComponentExtracter(lines, forceToLineString));\n  \t\t\treturn lines;\n  \t\t} else if (arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection)) {\n  \t\t\tvar geom = arguments[0],\n  \t\t\t    lines = arguments[1];\n  \t\t\tif (geom instanceof LineString) {\n  \t\t\t\tlines.add(geom);\n  \t\t\t} else {\n  \t\t\t\tgeom.apply(new LinearComponentExtracter(lines));\n  \t\t\t}\n  \t\t\treturn lines;\n  \t\t}\n  \t} else if (arguments.length === 3) {\n  \t\tif (typeof arguments[2] === \"boolean\" && hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection)) {\n  \t\t\tvar geoms = arguments[0],\n  \t\t\t    lines = arguments[1],\n  \t\t\t    forceToLineString = arguments[2];\n  \t\t\tfor (var i = geoms.iterator(); i.hasNext();) {\n  \t\t\t\tvar g = i.next();\n  \t\t\t\tLinearComponentExtracter.getLines(g, lines, forceToLineString);\n  \t\t\t}\n  \t\t\treturn lines;\n  \t\t} else if (typeof arguments[2] === \"boolean\" && arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection)) {\n  \t\t\tvar geom = arguments[0],\n  \t\t\t    lines = arguments[1],\n  \t\t\t    forceToLineString = arguments[2];\n  \t\t\tgeom.apply(new LinearComponentExtracter(lines, forceToLineString));\n  \t\t\treturn lines;\n  \t\t}\n  \t}\n  };\n\n  function ArrayListVisitor() {\n  \tthis._items = new ArrayList();\n  }\n  extend(ArrayListVisitor.prototype, {\n  \tvisitItem: function visitItem(item) {\n  \t\tthis._items.add(item);\n  \t},\n  \tgetItems: function getItems() {\n  \t\treturn this._items;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [ItemVisitor];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn ArrayListVisitor;\n  \t}\n  });\n\n  function IndexedPointInAreaLocator() {\n  \tthis._index = null;\n  \tvar g = arguments[0];\n  \tif (!hasInterface(g, Polygonal)) throw new IllegalArgumentException(\"Argument must be Polygonal\");\n  \tthis._index = new IntervalIndexedGeometry(g);\n  }\n  extend(IndexedPointInAreaLocator.prototype, {\n  \tlocate: function locate(p) {\n  \t\tvar rcc = new RayCrossingCounter(p);\n  \t\tvar visitor = new SegmentVisitor(rcc);\n  \t\tthis._index.query(p.y, p.y, visitor);\n  \t\treturn rcc.getLocation();\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [PointOnGeometryLocator];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn IndexedPointInAreaLocator;\n  \t}\n  });\n  function SegmentVisitor() {\n  \tthis._counter = null;\n  \tvar counter = arguments[0];\n  \tthis._counter = counter;\n  }\n  extend(SegmentVisitor.prototype, {\n  \tvisitItem: function visitItem(item) {\n  \t\tvar seg = item;\n  \t\tthis._counter.countSegment(seg.getCoordinate(0), seg.getCoordinate(1));\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [ItemVisitor];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SegmentVisitor;\n  \t}\n  });\n  function IntervalIndexedGeometry() {\n  \tthis._index = new SortedPackedIntervalRTree();\n  \tvar geom = arguments[0];\n  \tthis.init(geom);\n  }\n  extend(IntervalIndexedGeometry.prototype, {\n  \tinit: function init(geom) {\n  \t\tvar lines = LinearComponentExtracter.getLines(geom);\n  \t\tfor (var i = lines.iterator(); i.hasNext();) {\n  \t\t\tvar line = i.next();\n  \t\t\tvar pts = line.getCoordinates();\n  \t\t\tthis.addLine(pts);\n  \t\t}\n  \t},\n  \taddLine: function addLine(pts) {\n  \t\tfor (var i = 1; i < pts.length; i++) {\n  \t\t\tvar seg = new LineSegment(pts[i - 1], pts[i]);\n  \t\t\tvar min = Math.min(seg.p0.y, seg.p1.y);\n  \t\t\tvar max = Math.max(seg.p0.y, seg.p1.y);\n  \t\t\tthis._index.insert(min, max, seg);\n  \t\t}\n  \t},\n  \tquery: function query() {\n  \t\tif (arguments.length === 2) {\n  \t\t\tvar min = arguments[0],\n  \t\t\t    max = arguments[1];\n  \t\t\tvar visitor = new ArrayListVisitor();\n  \t\t\tthis._index.query(min, max, visitor);\n  \t\t\treturn visitor.getItems();\n  \t\t} else if (arguments.length === 3) {\n  \t\t\tvar min = arguments[0],\n  \t\t\t    max = arguments[1],\n  \t\t\t    visitor = arguments[2];\n  \t\t\tthis._index.query(min, max, visitor);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn IntervalIndexedGeometry;\n  \t}\n  });\n  IndexedPointInAreaLocator.SegmentVisitor = SegmentVisitor;\n  IndexedPointInAreaLocator.IntervalIndexedGeometry = IntervalIndexedGeometry;\n\n  function EdgeIntersection() {\n  \tthis.coord = null;\n  \tthis.segmentIndex = null;\n  \tthis.dist = null;\n  \tvar coord = arguments[0],\n  \t    segmentIndex = arguments[1],\n  \t    dist = arguments[2];\n  \tthis.coord = new Coordinate(coord);\n  \tthis.segmentIndex = segmentIndex;\n  \tthis.dist = dist;\n  }\n  extend(EdgeIntersection.prototype, {\n  \tgetSegmentIndex: function getSegmentIndex() {\n  \t\treturn this.segmentIndex;\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\treturn this.coord;\n  \t},\n  \tprint: function print(out) {\n  \t\tout.print(this.coord);\n  \t\tout.print(\" seg # = \" + this.segmentIndex);\n  \t\tout.println(\" dist = \" + this.dist);\n  \t},\n  \tcompareTo: function compareTo(obj) {\n  \t\tvar other = obj;\n  \t\treturn this.compare(other.segmentIndex, other.dist);\n  \t},\n  \tisEndPoint: function isEndPoint(maxSegmentIndex) {\n  \t\tif (this.segmentIndex === 0 && this.dist === 0.0) return true;\n  \t\tif (this.segmentIndex === maxSegmentIndex) return true;\n  \t\treturn false;\n  \t},\n  \ttoString: function toString() {\n  \t\treturn this.coord + \" seg # = \" + this.segmentIndex + \" dist = \" + this.dist;\n  \t},\n  \tgetDistance: function getDistance() {\n  \t\treturn this.dist;\n  \t},\n  \tcompare: function compare(segmentIndex, dist) {\n  \t\tif (this.segmentIndex < segmentIndex) return -1;\n  \t\tif (this.segmentIndex > segmentIndex) return 1;\n  \t\tif (this.dist < dist) return -1;\n  \t\tif (this.dist > dist) return 1;\n  \t\treturn 0;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn EdgeIntersection;\n  \t}\n  });\n\n  function EdgeIntersectionList() {\n  \tthis._nodeMap = new TreeMap();\n  \tthis.edge = null;\n  \tvar edge = arguments[0];\n  \tthis.edge = edge;\n  }\n  extend(EdgeIntersectionList.prototype, {\n  \tprint: function print(out) {\n  \t\tout.println(\"Intersections:\");\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar ei = it.next();\n  \t\t\tei.print(out);\n  \t\t}\n  \t},\n  \titerator: function iterator() {\n  \t\treturn this._nodeMap.values().iterator();\n  \t},\n  \taddSplitEdges: function addSplitEdges(edgeList) {\n  \t\tthis.addEndpoints();\n  \t\tvar it = this.iterator();\n  \t\tvar eiPrev = it.next();\n  \t\twhile (it.hasNext()) {\n  \t\t\tvar ei = it.next();\n  \t\t\tvar newEdge = this.createSplitEdge(eiPrev, ei);\n  \t\t\tedgeList.add(newEdge);\n  \t\t\teiPrev = ei;\n  \t\t}\n  \t},\n  \taddEndpoints: function addEndpoints() {\n  \t\tvar maxSegIndex = this.edge.pts.length - 1;\n  \t\tthis.add(this.edge.pts[0], 0, 0.0);\n  \t\tthis.add(this.edge.pts[maxSegIndex], maxSegIndex, 0.0);\n  \t},\n  \tcreateSplitEdge: function createSplitEdge(ei0, ei1) {\n  \t\tvar npts = ei1.segmentIndex - ei0.segmentIndex + 2;\n  \t\tvar lastSegStartPt = this.edge.pts[ei1.segmentIndex];\n  \t\tvar useIntPt1 = ei1.dist > 0.0 || !ei1.coord.equals2D(lastSegStartPt);\n  \t\tif (!useIntPt1) {\n  \t\t\tnpts--;\n  \t\t}\n  \t\tvar pts = new Array(npts).fill(null);\n  \t\tvar ipt = 0;\n  \t\tpts[ipt++] = new Coordinate(ei0.coord);\n  \t\tfor (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {\n  \t\t\tpts[ipt++] = this.edge.pts[i];\n  \t\t}\n  \t\tif (useIntPt1) pts[ipt] = ei1.coord;\n  \t\treturn new Edge(pts, new Label(this.edge._label));\n  \t},\n  \tadd: function add(intPt, segmentIndex, dist) {\n  \t\tvar eiNew = new EdgeIntersection(intPt, segmentIndex, dist);\n  \t\tvar ei = this._nodeMap.get(eiNew);\n  \t\tif (ei !== null) {\n  \t\t\treturn ei;\n  \t\t}\n  \t\tthis._nodeMap.put(eiNew, eiNew);\n  \t\treturn eiNew;\n  \t},\n  \tisIntersection: function isIntersection(pt) {\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar ei = it.next();\n  \t\t\tif (ei.coord.equals(pt)) return true;\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn EdgeIntersectionList;\n  \t}\n  });\n\n  function MonotoneChainIndexer() {}\n  extend(MonotoneChainIndexer.prototype, {\n  \tgetChainStartIndices: function getChainStartIndices(pts) {\n  \t\tvar start = 0;\n  \t\tvar startIndexList = new ArrayList();\n  \t\tstartIndexList.add(new Integer(start));\n  \t\tdo {\n  \t\t\tvar last = this.findChainEnd(pts, start);\n  \t\t\tstartIndexList.add(new Integer(last));\n  \t\t\tstart = last;\n  \t\t} while (start < pts.length - 1);\n  \t\tvar startIndex = MonotoneChainIndexer.toIntArray(startIndexList);\n  \t\treturn startIndex;\n  \t},\n  \tfindChainEnd: function findChainEnd(pts, start) {\n  \t\tvar chainQuad = Quadrant.quadrant(pts[start], pts[start + 1]);\n  \t\tvar last = start + 1;\n  \t\twhile (last < pts.length) {\n  \t\t\tvar quad = Quadrant.quadrant(pts[last - 1], pts[last]);\n  \t\t\tif (quad !== chainQuad) break;\n  \t\t\tlast++;\n  \t\t}\n  \t\treturn last - 1;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MonotoneChainIndexer;\n  \t}\n  });\n  MonotoneChainIndexer.toIntArray = function (list) {\n  \tvar array = new Array(list.size()).fill(null);\n  \tfor (var i = 0; i < array.length; i++) {\n  \t\tarray[i] = list.get(i).intValue();\n  \t}\n  \treturn array;\n  };\n\n  function MonotoneChainEdge() {\n  \tthis.e = null;\n  \tthis.pts = null;\n  \tthis.startIndex = null;\n  \tthis.env1 = new Envelope();\n  \tthis.env2 = new Envelope();\n  \tvar e = arguments[0];\n  \tthis.e = e;\n  \tthis.pts = e.getCoordinates();\n  \tvar mcb = new MonotoneChainIndexer();\n  \tthis.startIndex = mcb.getChainStartIndices(this.pts);\n  }\n  extend(MonotoneChainEdge.prototype, {\n  \tgetCoordinates: function getCoordinates() {\n  \t\treturn this.pts;\n  \t},\n  \tgetMaxX: function getMaxX(chainIndex) {\n  \t\tvar x1 = this.pts[this.startIndex[chainIndex]].x;\n  \t\tvar x2 = this.pts[this.startIndex[chainIndex + 1]].x;\n  \t\treturn x1 > x2 ? x1 : x2;\n  \t},\n  \tgetMinX: function getMinX(chainIndex) {\n  \t\tvar x1 = this.pts[this.startIndex[chainIndex]].x;\n  \t\tvar x2 = this.pts[this.startIndex[chainIndex + 1]].x;\n  \t\treturn x1 < x2 ? x1 : x2;\n  \t},\n  \tcomputeIntersectsForChain: function computeIntersectsForChain() {\n  \t\tif (arguments.length === 4) {\n  \t\t\tvar chainIndex0 = arguments[0],\n  \t\t\t    mce = arguments[1],\n  \t\t\t    chainIndex1 = arguments[2],\n  \t\t\t    si = arguments[3];\n  \t\t\tthis.computeIntersectsForChain(this.startIndex[chainIndex0], this.startIndex[chainIndex0 + 1], mce, mce.startIndex[chainIndex1], mce.startIndex[chainIndex1 + 1], si);\n  \t\t} else if (arguments.length === 6) {\n  \t\t\tvar start0 = arguments[0],\n  \t\t\t    end0 = arguments[1],\n  \t\t\t    mce = arguments[2],\n  \t\t\t    start1 = arguments[3],\n  \t\t\t    end1 = arguments[4],\n  \t\t\t    ei = arguments[5];\n  \t\t\tvar p00 = this.pts[start0];\n  \t\t\tvar p01 = this.pts[end0];\n  \t\t\tvar p10 = mce.pts[start1];\n  \t\t\tvar p11 = mce.pts[end1];\n  \t\t\tif (end0 - start0 === 1 && end1 - start1 === 1) {\n  \t\t\t\tei.addIntersections(this.e, start0, mce.e, start1);\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t\tthis.env1.init(p00, p01);\n  \t\t\tthis.env2.init(p10, p11);\n  \t\t\tif (!this.env1.intersects(this.env2)) return null;\n  \t\t\tvar mid0 = Math.trunc((start0 + end0) / 2);\n  \t\t\tvar mid1 = Math.trunc((start1 + end1) / 2);\n  \t\t\tif (start0 < mid0) {\n  \t\t\t\tif (start1 < mid1) this.computeIntersectsForChain(start0, mid0, mce, start1, mid1, ei);\n  \t\t\t\tif (mid1 < end1) this.computeIntersectsForChain(start0, mid0, mce, mid1, end1, ei);\n  \t\t\t}\n  \t\t\tif (mid0 < end0) {\n  \t\t\t\tif (start1 < mid1) this.computeIntersectsForChain(mid0, end0, mce, start1, mid1, ei);\n  \t\t\t\tif (mid1 < end1) this.computeIntersectsForChain(mid0, end0, mce, mid1, end1, ei);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetStartIndexes: function getStartIndexes() {\n  \t\treturn this.startIndex;\n  \t},\n  \tcomputeIntersects: function computeIntersects(mce, si) {\n  \t\tfor (var i = 0; i < this.startIndex.length - 1; i++) {\n  \t\t\tfor (var j = 0; j < mce.startIndex.length - 1; j++) {\n  \t\t\t\tthis.computeIntersectsForChain(i, mce, j, si);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MonotoneChainEdge;\n  \t}\n  });\n\n  function Depth() {\n  \tthis._depth = Array(2).fill().map(function () {\n  \t\treturn Array(3);\n  \t});\n  \tfor (var i = 0; i < 2; i++) {\n  \t\tfor (var j = 0; j < 3; j++) {\n  \t\t\tthis._depth[i][j] = Depth.NULL_VALUE;\n  \t\t}\n  \t}\n  }\n  extend(Depth.prototype, {\n  \tgetDepth: function getDepth(geomIndex, posIndex) {\n  \t\treturn this._depth[geomIndex][posIndex];\n  \t},\n  \tsetDepth: function setDepth(geomIndex, posIndex, depthValue) {\n  \t\tthis._depth[geomIndex][posIndex] = depthValue;\n  \t},\n  \tisNull: function isNull() {\n  \t\tif (arguments.length === 0) {\n  \t\t\tfor (var i = 0; i < 2; i++) {\n  \t\t\t\tfor (var j = 0; j < 3; j++) {\n  \t\t\t\t\tif (this._depth[i][j] !== Depth.NULL_VALUE) return false;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\treturn true;\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tvar geomIndex = arguments[0];\n  \t\t\treturn this._depth[geomIndex][1] === Depth.NULL_VALUE;\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar geomIndex = arguments[0],\n  \t\t\t    posIndex = arguments[1];\n  \t\t\treturn this._depth[geomIndex][posIndex] === Depth.NULL_VALUE;\n  \t\t}\n  \t},\n  \tnormalize: function normalize() {\n  \t\tfor (var i = 0; i < 2; i++) {\n  \t\t\tif (!this.isNull(i)) {\n  \t\t\t\tvar minDepth = this._depth[i][1];\n  \t\t\t\tif (this._depth[i][2] < minDepth) minDepth = this._depth[i][2];\n  \t\t\t\tif (minDepth < 0) minDepth = 0;\n  \t\t\t\tfor (var j = 1; j < 3; j++) {\n  \t\t\t\t\tvar newValue = 0;\n  \t\t\t\t\tif (this._depth[i][j] > minDepth) newValue = 1;\n  \t\t\t\t\tthis._depth[i][j] = newValue;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetDelta: function getDelta(geomIndex) {\n  \t\treturn this._depth[geomIndex][Position.RIGHT] - this._depth[geomIndex][Position.LEFT];\n  \t},\n  \tgetLocation: function getLocation(geomIndex, posIndex) {\n  \t\tif (this._depth[geomIndex][posIndex] <= 0) return Location.EXTERIOR;\n  \t\treturn Location.INTERIOR;\n  \t},\n  \ttoString: function toString() {\n  \t\treturn \"A: \" + this._depth[0][1] + \",\" + this._depth[0][2] + \" B: \" + this._depth[1][1] + \",\" + this._depth[1][2];\n  \t},\n  \tadd: function add() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar lbl = arguments[0];\n  \t\t\tfor (var i = 0; i < 2; i++) {\n  \t\t\t\tfor (var j = 1; j < 3; j++) {\n  \t\t\t\t\tvar loc = lbl.getLocation(i, j);\n  \t\t\t\t\tif (loc === Location.EXTERIOR || loc === Location.INTERIOR) {\n  \t\t\t\t\t\tif (this.isNull(i, j)) {\n  \t\t\t\t\t\t\tthis._depth[i][j] = Depth.depthAtLocation(loc);\n  \t\t\t\t\t\t} else this._depth[i][j] += Depth.depthAtLocation(loc);\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} else if (arguments.length === 3) {\n  \t\t\tvar geomIndex = arguments[0],\n  \t\t\t    posIndex = arguments[1],\n  \t\t\t    location = arguments[2];\n  \t\t\tif (location === Location.INTERIOR) this._depth[geomIndex][posIndex]++;\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Depth;\n  \t}\n  });\n  Depth.depthAtLocation = function (location) {\n  \tif (location === Location.EXTERIOR) return 0;\n  \tif (location === Location.INTERIOR) return 1;\n  \treturn Depth.NULL_VALUE;\n  };\n  Depth.NULL_VALUE = -1;\n\n  function Edge() {\n  \tGraphComponent.apply(this);\n  \tthis.pts = null;\n  \tthis._env = null;\n  \tthis.eiList = new EdgeIntersectionList(this);\n  \tthis._name = null;\n  \tthis._mce = null;\n  \tthis._isIsolated = true;\n  \tthis._depth = new Depth();\n  \tthis._depthDelta = 0;\n  \tif (arguments.length === 1) {\n  \t\tvar pts = arguments[0];\n  \t\tEdge.call(this, pts, null);\n  \t} else if (arguments.length === 2) {\n  \t\tvar pts = arguments[0],\n  \t\t    label = arguments[1];\n  \t\tthis.pts = pts;\n  \t\tthis._label = label;\n  \t}\n  }\n  inherits$1(Edge, GraphComponent);\n  extend(Edge.prototype, {\n  \tgetDepth: function getDepth() {\n  \t\treturn this._depth;\n  \t},\n  \tgetCollapsedEdge: function getCollapsedEdge() {\n  \t\tvar newPts = new Array(2).fill(null);\n  \t\tnewPts[0] = this.pts[0];\n  \t\tnewPts[1] = this.pts[1];\n  \t\tvar newe = new Edge(newPts, Label.toLineLabel(this._label));\n  \t\treturn newe;\n  \t},\n  \tisIsolated: function isIsolated() {\n  \t\treturn this._isIsolated;\n  \t},\n  \tgetCoordinates: function getCoordinates() {\n  \t\treturn this.pts;\n  \t},\n  \tsetIsolated: function setIsolated(isIsolated) {\n  \t\tthis._isIsolated = isIsolated;\n  \t},\n  \tsetName: function setName(name) {\n  \t\tthis._name = name;\n  \t},\n  \tequals: function equals(o) {\n  \t\tif (!(o instanceof Edge)) return false;\n  \t\tvar e = o;\n  \t\tif (this.pts.length !== e.pts.length) return false;\n  \t\tvar isEqualForward = true;\n  \t\tvar isEqualReverse = true;\n  \t\tvar iRev = this.pts.length;\n  \t\tfor (var i = 0; i < this.pts.length; i++) {\n  \t\t\tif (!this.pts[i].equals2D(e.pts[i])) {\n  \t\t\t\tisEqualForward = false;\n  \t\t\t}\n  \t\t\tif (!this.pts[i].equals2D(e.pts[--iRev])) {\n  \t\t\t\tisEqualReverse = false;\n  \t\t\t}\n  \t\t\tif (!isEqualForward && !isEqualReverse) return false;\n  \t\t}\n  \t\treturn true;\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\tif (arguments.length === 0) {\n  \t\t\tif (this.pts.length > 0) return this.pts[0];\n  \t\t\treturn null;\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tvar i = arguments[0];\n  \t\t\treturn this.pts[i];\n  \t\t}\n  \t},\n  \tprint: function print(out) {\n  \t\tout.print(\"edge \" + this._name + \": \");\n  \t\tout.print(\"LINESTRING (\");\n  \t\tfor (var i = 0; i < this.pts.length; i++) {\n  \t\t\tif (i > 0) out.print(\",\");\n  \t\t\tout.print(this.pts[i].x + \" \" + this.pts[i].y);\n  \t\t}\n  \t\tout.print(\")  \" + this._label + \" \" + this._depthDelta);\n  \t},\n  \tcomputeIM: function computeIM(im) {\n  \t\tEdge.updateIM(this._label, im);\n  \t},\n  \tisCollapsed: function isCollapsed() {\n  \t\tif (!this._label.isArea()) return false;\n  \t\tif (this.pts.length !== 3) return false;\n  \t\tif (this.pts[0].equals(this.pts[2])) return true;\n  \t\treturn false;\n  \t},\n  \tisClosed: function isClosed() {\n  \t\treturn this.pts[0].equals(this.pts[this.pts.length - 1]);\n  \t},\n  \tgetMaximumSegmentIndex: function getMaximumSegmentIndex() {\n  \t\treturn this.pts.length - 1;\n  \t},\n  \tgetDepthDelta: function getDepthDelta() {\n  \t\treturn this._depthDelta;\n  \t},\n  \tgetNumPoints: function getNumPoints() {\n  \t\treturn this.pts.length;\n  \t},\n  \tprintReverse: function printReverse(out) {\n  \t\tout.print(\"edge \" + this._name + \": \");\n  \t\tfor (var i = this.pts.length - 1; i >= 0; i--) {\n  \t\t\tout.print(this.pts[i] + \" \");\n  \t\t}\n  \t\tout.println(\"\");\n  \t},\n  \tgetMonotoneChainEdge: function getMonotoneChainEdge() {\n  \t\tif (this._mce === null) this._mce = new MonotoneChainEdge(this);\n  \t\treturn this._mce;\n  \t},\n  \tgetEnvelope: function getEnvelope() {\n  \t\tif (this._env === null) {\n  \t\t\tthis._env = new Envelope();\n  \t\t\tfor (var i = 0; i < this.pts.length; i++) {\n  \t\t\t\tthis._env.expandToInclude(this.pts[i]);\n  \t\t\t}\n  \t\t}\n  \t\treturn this._env;\n  \t},\n  \taddIntersection: function addIntersection(li, segmentIndex, geomIndex, intIndex) {\n  \t\tvar intPt = new Coordinate(li.getIntersection(intIndex));\n  \t\tvar normalizedSegmentIndex = segmentIndex;\n  \t\tvar dist = li.getEdgeDistance(geomIndex, intIndex);\n  \t\tvar nextSegIndex = normalizedSegmentIndex + 1;\n  \t\tif (nextSegIndex < this.pts.length) {\n  \t\t\tvar nextPt = this.pts[nextSegIndex];\n  \t\t\tif (intPt.equals2D(nextPt)) {\n  \t\t\t\tnormalizedSegmentIndex = nextSegIndex;\n  \t\t\t\tdist = 0.0;\n  \t\t\t}\n  \t\t}\n  \t\tvar ei = this.eiList.add(intPt, normalizedSegmentIndex, dist);\n  \t},\n  \ttoString: function toString() {\n  \t\tvar buf = new StringBuffer();\n  \t\tbuf.append(\"edge \" + this._name + \": \");\n  \t\tbuf.append(\"LINESTRING (\");\n  \t\tfor (var i = 0; i < this.pts.length; i++) {\n  \t\t\tif (i > 0) buf.append(\",\");\n  \t\t\tbuf.append(this.pts[i].x + \" \" + this.pts[i].y);\n  \t\t}\n  \t\tbuf.append(\")  \" + this._label + \" \" + this._depthDelta);\n  \t\treturn buf.toString();\n  \t},\n  \tisPointwiseEqual: function isPointwiseEqual(e) {\n  \t\tif (this.pts.length !== e.pts.length) return false;\n  \t\tfor (var i = 0; i < this.pts.length; i++) {\n  \t\t\tif (!this.pts[i].equals2D(e.pts[i])) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t}\n  \t\treturn true;\n  \t},\n  \tsetDepthDelta: function setDepthDelta(depthDelta) {\n  \t\tthis._depthDelta = depthDelta;\n  \t},\n  \tgetEdgeIntersectionList: function getEdgeIntersectionList() {\n  \t\treturn this.eiList;\n  \t},\n  \taddIntersections: function addIntersections(li, segmentIndex, geomIndex) {\n  \t\tfor (var i = 0; i < li.getIntersectionNum(); i++) {\n  \t\t\tthis.addIntersection(li, segmentIndex, geomIndex, i);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Edge;\n  \t}\n  });\n  Edge.updateIM = function () {\n  \tif (arguments.length === 2) {\n  \t\tvar label = arguments[0],\n  \t\t    im = arguments[1];\n  \t\tim.setAtLeastIfValid(label.getLocation(0, Position.ON), label.getLocation(1, Position.ON), 1);\n  \t\tif (label.isArea()) {\n  \t\t\tim.setAtLeastIfValid(label.getLocation(0, Position.LEFT), label.getLocation(1, Position.LEFT), 2);\n  \t\t\tim.setAtLeastIfValid(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), 2);\n  \t\t}\n  \t} else return GraphComponent.prototype.updateIM.apply(this, arguments);\n  };\n\n  function GeometryGraph() {\n  \tPlanarGraph.apply(this);\n  \tthis._parentGeom = null;\n  \tthis._lineEdgeMap = new HashMap();\n  \tthis._boundaryNodeRule = null;\n  \tthis._useBoundaryDeterminationRule = true;\n  \tthis._argIndex = null;\n  \tthis._boundaryNodes = null;\n  \tthis._hasTooFewPoints = false;\n  \tthis._invalidPoint = null;\n  \tthis._areaPtLocator = null;\n  \tthis._ptLocator = new PointLocator();\n  \tif (arguments.length === 2) {\n  \t\tvar argIndex = arguments[0],\n  \t\t    parentGeom = arguments[1];\n  \t\tGeometryGraph.call(this, argIndex, parentGeom, BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE);\n  \t} else if (arguments.length === 3) {\n  \t\tvar argIndex = arguments[0],\n  \t\t    parentGeom = arguments[1],\n  \t\t    boundaryNodeRule = arguments[2];\n  \t\tthis._argIndex = argIndex;\n  \t\tthis._parentGeom = parentGeom;\n  \t\tthis._boundaryNodeRule = boundaryNodeRule;\n  \t\tif (parentGeom !== null) {\n  \t\t\tthis.add(parentGeom);\n  \t\t}\n  \t}\n  }\n  inherits$1(GeometryGraph, PlanarGraph);\n  extend(GeometryGraph.prototype, {\n  \tinsertBoundaryPoint: function insertBoundaryPoint(argIndex, coord) {\n  \t\tvar n = this._nodes.addNode(coord);\n  \t\tvar lbl = n.getLabel();\n  \t\tvar boundaryCount = 1;\n  \t\tvar loc = Location.NONE;\n  \t\tloc = lbl.getLocation(argIndex, Position.ON);\n  \t\tif (loc === Location.BOUNDARY) boundaryCount++;\n  \t\tvar newLoc = GeometryGraph.determineBoundary(this._boundaryNodeRule, boundaryCount);\n  \t\tlbl.setLocation(argIndex, newLoc);\n  \t},\n  \tcomputeSelfNodes: function computeSelfNodes() {\n  \t\tif (arguments.length === 2) {\n  \t\t\tvar li = arguments[0],\n  \t\t\t    computeRingSelfNodes = arguments[1];\n  \t\t\treturn this.computeSelfNodes(li, computeRingSelfNodes, false);\n  \t\t} else if (arguments.length === 3) {\n  \t\t\tvar li = arguments[0],\n  \t\t\t    computeRingSelfNodes = arguments[1],\n  \t\t\t    isDoneIfProperInt = arguments[2];\n  \t\t\tvar si = new SegmentIntersector$1(li, true, false);\n  \t\t\tsi.setIsDoneIfProperInt(isDoneIfProperInt);\n  \t\t\tvar esi = this.createEdgeSetIntersector();\n  \t\t\tvar isRings = this._parentGeom instanceof LinearRing || this._parentGeom instanceof Polygon || this._parentGeom instanceof MultiPolygon;\n  \t\t\tvar computeAllSegments = computeRingSelfNodes || !isRings;\n  \t\t\tesi.computeIntersections(this._edges, si, computeAllSegments);\n  \t\t\tthis.addSelfIntersectionNodes(this._argIndex);\n  \t\t\treturn si;\n  \t\t}\n  \t},\n  \tcomputeSplitEdges: function computeSplitEdges(edgelist) {\n  \t\tfor (var i = this._edges.iterator(); i.hasNext();) {\n  \t\t\tvar e = i.next();\n  \t\t\te.eiList.addSplitEdges(edgelist);\n  \t\t}\n  \t},\n  \tcomputeEdgeIntersections: function computeEdgeIntersections(g, li, includeProper) {\n  \t\tvar si = new SegmentIntersector$1(li, includeProper, true);\n  \t\tsi.setBoundaryNodes(this.getBoundaryNodes(), g.getBoundaryNodes());\n  \t\tvar esi = this.createEdgeSetIntersector();\n  \t\tesi.computeIntersections(this._edges, g._edges, si);\n  \t\treturn si;\n  \t},\n  \tgetGeometry: function getGeometry() {\n  \t\treturn this._parentGeom;\n  \t},\n  \tgetBoundaryNodeRule: function getBoundaryNodeRule() {\n  \t\treturn this._boundaryNodeRule;\n  \t},\n  \thasTooFewPoints: function hasTooFewPoints() {\n  \t\treturn this._hasTooFewPoints;\n  \t},\n  \taddPoint: function addPoint() {\n  \t\tif (arguments[0] instanceof Point) {\n  \t\t\tvar p = arguments[0];\n  \t\t\tvar coord = p.getCoordinate();\n  \t\t\tthis.insertPoint(this._argIndex, coord, Location.INTERIOR);\n  \t\t} else if (arguments[0] instanceof Coordinate) {\n  \t\t\tvar pt = arguments[0];\n  \t\t\tthis.insertPoint(this._argIndex, pt, Location.INTERIOR);\n  \t\t}\n  \t},\n  \taddPolygon: function addPolygon(p) {\n  \t\tthis.addPolygonRing(p.getExteriorRing(), Location.EXTERIOR, Location.INTERIOR);\n  \t\tfor (var i = 0; i < p.getNumInteriorRing(); i++) {\n  \t\t\tvar hole = p.getInteriorRingN(i);\n  \t\t\tthis.addPolygonRing(hole, Location.INTERIOR, Location.EXTERIOR);\n  \t\t}\n  \t},\n  \taddEdge: function addEdge(e) {\n  \t\tthis.insertEdge(e);\n  \t\tvar coord = e.getCoordinates();\n  \t\tthis.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);\n  \t\tthis.insertPoint(this._argIndex, coord[coord.length - 1], Location.BOUNDARY);\n  \t},\n  \taddLineString: function addLineString(line) {\n  \t\tvar coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());\n  \t\tif (coord.length < 2) {\n  \t\t\tthis._hasTooFewPoints = true;\n  \t\t\tthis._invalidPoint = coord[0];\n  \t\t\treturn null;\n  \t\t}\n  \t\tvar e = new Edge(coord, new Label(this._argIndex, Location.INTERIOR));\n  \t\tthis._lineEdgeMap.put(line, e);\n  \t\tthis.insertEdge(e);\n  \t\tAssert.isTrue(coord.length >= 2, \"found LineString with single point\");\n  \t\tthis.insertBoundaryPoint(this._argIndex, coord[0]);\n  \t\tthis.insertBoundaryPoint(this._argIndex, coord[coord.length - 1]);\n  \t},\n  \tgetInvalidPoint: function getInvalidPoint() {\n  \t\treturn this._invalidPoint;\n  \t},\n  \tgetBoundaryPoints: function getBoundaryPoints() {\n  \t\tvar coll = this.getBoundaryNodes();\n  \t\tvar pts = new Array(coll.size()).fill(null);\n  \t\tvar i = 0;\n  \t\tfor (var it = coll.iterator(); it.hasNext();) {\n  \t\t\tvar node = it.next();\n  \t\t\tpts[i++] = node.getCoordinate().copy();\n  \t\t}\n  \t\treturn pts;\n  \t},\n  \tgetBoundaryNodes: function getBoundaryNodes() {\n  \t\tif (this._boundaryNodes === null) this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex);\n  \t\treturn this._boundaryNodes;\n  \t},\n  \taddSelfIntersectionNode: function addSelfIntersectionNode(argIndex, coord, loc) {\n  \t\tif (this.isBoundaryNode(argIndex, coord)) return null;\n  \t\tif (loc === Location.BOUNDARY && this._useBoundaryDeterminationRule) this.insertBoundaryPoint(argIndex, coord);else this.insertPoint(argIndex, coord, loc);\n  \t},\n  \taddPolygonRing: function addPolygonRing(lr, cwLeft, cwRight) {\n  \t\tif (lr.isEmpty()) return null;\n  \t\tvar coord = CoordinateArrays.removeRepeatedPoints(lr.getCoordinates());\n  \t\tif (coord.length < 4) {\n  \t\t\tthis._hasTooFewPoints = true;\n  \t\t\tthis._invalidPoint = coord[0];\n  \t\t\treturn null;\n  \t\t}\n  \t\tvar left = cwLeft;\n  \t\tvar right = cwRight;\n  \t\tif (CGAlgorithms.isCCW(coord)) {\n  \t\t\tleft = cwRight;\n  \t\t\tright = cwLeft;\n  \t\t}\n  \t\tvar e = new Edge(coord, new Label(this._argIndex, Location.BOUNDARY, left, right));\n  \t\tthis._lineEdgeMap.put(lr, e);\n  \t\tthis.insertEdge(e);\n  \t\tthis.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);\n  \t},\n  \tinsertPoint: function insertPoint(argIndex, coord, onLocation) {\n  \t\tvar n = this._nodes.addNode(coord);\n  \t\tvar lbl = n.getLabel();\n  \t\tif (lbl === null) {\n  \t\t\tn._label = new Label(argIndex, onLocation);\n  \t\t} else lbl.setLocation(argIndex, onLocation);\n  \t},\n  \tcreateEdgeSetIntersector: function createEdgeSetIntersector() {\n  \t\treturn new SimpleMCSweepLineIntersector();\n  \t},\n  \taddSelfIntersectionNodes: function addSelfIntersectionNodes(argIndex) {\n  \t\tfor (var i = this._edges.iterator(); i.hasNext();) {\n  \t\t\tvar e = i.next();\n  \t\t\tvar eLoc = e.getLabel().getLocation(argIndex);\n  \t\t\tfor (var eiIt = e.eiList.iterator(); eiIt.hasNext();) {\n  \t\t\t\tvar ei = eiIt.next();\n  \t\t\t\tthis.addSelfIntersectionNode(argIndex, ei.coord, eLoc);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tadd: function add() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar g = arguments[0];\n  \t\t\tif (g.isEmpty()) return null;\n  \t\t\tif (g instanceof MultiPolygon) this._useBoundaryDeterminationRule = false;\n  \t\t\tif (g instanceof Polygon) this.addPolygon(g);else if (g instanceof LineString) this.addLineString(g);else if (g instanceof Point) this.addPoint(g);else if (g instanceof MultiPoint) this.addCollection(g);else if (g instanceof MultiLineString) this.addCollection(g);else if (g instanceof MultiPolygon) this.addCollection(g);else if (g instanceof GeometryCollection) this.addCollection(g);else throw new UnsupportedOperationException(g.getClass().getName());\n  \t\t} else return PlanarGraph.prototype.add.apply(this, arguments);\n  \t},\n  \taddCollection: function addCollection(gc) {\n  \t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n  \t\t\tvar g = gc.getGeometryN(i);\n  \t\t\tthis.add(g);\n  \t\t}\n  \t},\n  \tlocate: function locate(pt) {\n  \t\tif (hasInterface(this._parentGeom, Polygonal) && this._parentGeom.getNumGeometries() > 50) {\n  \t\t\tif (this._areaPtLocator === null) {\n  \t\t\t\tthis._areaPtLocator = new IndexedPointInAreaLocator(this._parentGeom);\n  \t\t\t}\n  \t\t\treturn this._areaPtLocator.locate(pt);\n  \t\t}\n  \t\treturn this._ptLocator.locate(pt, this._parentGeom);\n  \t},\n  \tfindEdge: function findEdge() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar line = arguments[0];\n  \t\t\treturn this._lineEdgeMap.get(line);\n  \t\t} else return PlanarGraph.prototype.findEdge.apply(this, arguments);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn GeometryGraph;\n  \t}\n  });\n  GeometryGraph.determineBoundary = function (boundaryNodeRule, boundaryCount) {\n  \treturn boundaryNodeRule.isInBoundary(boundaryCount) ? Location.BOUNDARY : Location.INTERIOR;\n  };\n\n  function GeometryGraphOperation() {\n  \tthis._li = new RobustLineIntersector();\n  \tthis._resultPrecisionModel = null;\n  \tthis._arg = null;\n  \tif (arguments.length === 1) {\n  \t\tvar g0 = arguments[0];\n  \t\tthis.setComputationPrecision(g0.getPrecisionModel());\n  \t\tthis._arg = new Array(1).fill(null);\n  \t\tthis._arg[0] = new GeometryGraph(0, g0);\n  \t} else if (arguments.length === 2) {\n  \t\tvar g0 = arguments[0],\n  \t\t    g1 = arguments[1];\n  \t\tGeometryGraphOperation.call(this, g0, g1, BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE);\n  \t} else if (arguments.length === 3) {\n  \t\tvar g0 = arguments[0],\n  \t\t    g1 = arguments[1],\n  \t\t    boundaryNodeRule = arguments[2];\n  \t\tif (g0.getPrecisionModel().compareTo(g1.getPrecisionModel()) >= 0) this.setComputationPrecision(g0.getPrecisionModel());else this.setComputationPrecision(g1.getPrecisionModel());\n  \t\tthis._arg = new Array(2).fill(null);\n  \t\tthis._arg[0] = new GeometryGraph(0, g0, boundaryNodeRule);\n  \t\tthis._arg[1] = new GeometryGraph(1, g1, boundaryNodeRule);\n  \t}\n  }\n  extend(GeometryGraphOperation.prototype, {\n  \tgetArgGeometry: function getArgGeometry(i) {\n  \t\treturn this._arg[i].getGeometry();\n  \t},\n  \tsetComputationPrecision: function setComputationPrecision(pm) {\n  \t\tthis._resultPrecisionModel = pm;\n  \t\tthis._li.setPrecisionModel(this._resultPrecisionModel);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn GeometryGraphOperation;\n  \t}\n  });\n\n  function OrientedCoordinateArray() {\n  \tthis._pts = null;\n  \tthis._orientation = null;\n  \tvar pts = arguments[0];\n  \tthis._pts = pts;\n  \tthis._orientation = OrientedCoordinateArray.orientation(pts);\n  }\n  extend(OrientedCoordinateArray.prototype, {\n  \tcompareTo: function compareTo(o1) {\n  \t\tvar oca = o1;\n  \t\tvar comp = OrientedCoordinateArray.compareOriented(this._pts, this._orientation, oca._pts, oca._orientation);\n  \t\treturn comp;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn OrientedCoordinateArray;\n  \t}\n  });\n  OrientedCoordinateArray.orientation = function (pts) {\n  \treturn CoordinateArrays.increasingDirection(pts) === 1;\n  };\n  OrientedCoordinateArray.compareOriented = function (pts1, orientation1, pts2, orientation2) {\n  \tvar dir1 = orientation1 ? 1 : -1;\n  \tvar dir2 = orientation2 ? 1 : -1;\n  \tvar limit1 = orientation1 ? pts1.length : -1;\n  \tvar limit2 = orientation2 ? pts2.length : -1;\n  \tvar i1 = orientation1 ? 0 : pts1.length - 1;\n  \tvar i2 = orientation2 ? 0 : pts2.length - 1;\n  \twhile (true) {\n  \t\tvar compPt = pts1[i1].compareTo(pts2[i2]);\n  \t\tif (compPt !== 0) return compPt;\n  \t\ti1 += dir1;\n  \t\ti2 += dir2;\n  \t\tvar done1 = i1 === limit1;\n  \t\tvar done2 = i2 === limit2;\n  \t\tif (done1 && !done2) return -1;\n  \t\tif (!done1 && done2) return 1;\n  \t\tif (done1 && done2) return 0;\n  \t}\n  };\n\n  function EdgeList() {\n  \tthis._edges = new ArrayList();\n  \tthis._ocaMap = new TreeMap();\n  }\n  extend(EdgeList.prototype, {\n  \tprint: function print(out) {\n  \t\tout.print(\"MULTILINESTRING ( \");\n  \t\tfor (var j = 0; j < this._edges.size(); j++) {\n  \t\t\tvar e = this._edges.get(j);\n  \t\t\tif (j > 0) out.print(\",\");\n  \t\t\tout.print(\"(\");\n  \t\t\tvar pts = e.getCoordinates();\n  \t\t\tfor (var i = 0; i < pts.length; i++) {\n  \t\t\t\tif (i > 0) out.print(\",\");\n  \t\t\t\tout.print(pts[i].x + \" \" + pts[i].y);\n  \t\t\t}\n  \t\t\tout.println(\")\");\n  \t\t}\n  \t\tout.print(\")  \");\n  \t},\n  \taddAll: function addAll(edgeColl) {\n  \t\tfor (var i = edgeColl.iterator(); i.hasNext();) {\n  \t\t\tthis.add(i.next());\n  \t\t}\n  \t},\n  \tfindEdgeIndex: function findEdgeIndex(e) {\n  \t\tfor (var i = 0; i < this._edges.size(); i++) {\n  \t\t\tif (this._edges.get(i).equals(e)) return i;\n  \t\t}\n  \t\treturn -1;\n  \t},\n  \titerator: function iterator() {\n  \t\treturn this._edges.iterator();\n  \t},\n  \tgetEdges: function getEdges() {\n  \t\treturn this._edges;\n  \t},\n  \tget: function get(i) {\n  \t\treturn this._edges.get(i);\n  \t},\n  \tfindEqualEdge: function findEqualEdge(e) {\n  \t\tvar oca = new OrientedCoordinateArray(e.getCoordinates());\n  \t\tvar matchEdge = this._ocaMap.get(oca);\n  \t\treturn matchEdge;\n  \t},\n  \tadd: function add(e) {\n  \t\tthis._edges.add(e);\n  \t\tvar oca = new OrientedCoordinateArray(e.getCoordinates());\n  \t\tthis._ocaMap.put(oca, e);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn EdgeList;\n  \t}\n  });\n\n  function OverlayOp() {\n  \tthis._ptLocator = new PointLocator();\n  \tthis._geomFact = null;\n  \tthis._resultGeom = null;\n  \tthis._graph = null;\n  \tthis._edgeList = new EdgeList();\n  \tthis._resultPolyList = new ArrayList();\n  \tthis._resultLineList = new ArrayList();\n  \tthis._resultPointList = new ArrayList();\n  \tvar g0 = arguments[0],\n  \t    g1 = arguments[1];\n  \tGeometryGraphOperation.call(this, g0, g1);\n  \tthis._graph = new PlanarGraph(new OverlayNodeFactory());\n  \tthis._geomFact = g0.getFactory();\n  }\n  inherits$1(OverlayOp, GeometryGraphOperation);\n  extend(OverlayOp.prototype, {\n  \tinsertUniqueEdge: function insertUniqueEdge(e) {\n  \t\tvar existingEdge = this._edgeList.findEqualEdge(e);\n  \t\tif (existingEdge !== null) {\n  \t\t\tvar existingLabel = existingEdge.getLabel();\n  \t\t\tvar labelToMerge = e.getLabel();\n  \t\t\tif (!existingEdge.isPointwiseEqual(e)) {\n  \t\t\t\tlabelToMerge = new Label(e.getLabel());\n  \t\t\t\tlabelToMerge.flip();\n  \t\t\t}\n  \t\t\tvar depth = existingEdge.getDepth();\n  \t\t\tif (depth.isNull()) {\n  \t\t\t\tdepth.add(existingLabel);\n  \t\t\t}\n  \t\t\tdepth.add(labelToMerge);\n  \t\t\texistingLabel.merge(labelToMerge);\n  \t\t} else {\n  \t\t\tthis._edgeList.add(e);\n  \t\t}\n  \t},\n  \tgetGraph: function getGraph() {\n  \t\treturn this._graph;\n  \t},\n  \tcancelDuplicateResultEdges: function cancelDuplicateResultEdges() {\n  \t\tfor (var it = this._graph.getEdgeEnds().iterator(); it.hasNext();) {\n  \t\t\tvar de = it.next();\n  \t\t\tvar sym = de.getSym();\n  \t\t\tif (de.isInResult() && sym.isInResult()) {\n  \t\t\t\tde.setInResult(false);\n  \t\t\t\tsym.setInResult(false);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tisCoveredByLA: function isCoveredByLA(coord) {\n  \t\tif (this.isCovered(coord, this._resultLineList)) return true;\n  \t\tif (this.isCovered(coord, this._resultPolyList)) return true;\n  \t\treturn false;\n  \t},\n  \tcomputeGeometry: function computeGeometry(resultPointList, resultLineList, resultPolyList, opcode) {\n  \t\tvar geomList = new ArrayList();\n  \t\tgeomList.addAll(resultPointList);\n  \t\tgeomList.addAll(resultLineList);\n  \t\tgeomList.addAll(resultPolyList);\n  \t\tif (geomList.isEmpty()) return OverlayOp.createEmptyResult(opcode, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact);\n  \t\treturn this._geomFact.buildGeometry(geomList);\n  \t},\n  \tmergeSymLabels: function mergeSymLabels() {\n  \t\tfor (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {\n  \t\t\tvar node = nodeit.next();\n  \t\t\tnode.getEdges().mergeSymLabels();\n  \t\t}\n  \t},\n  \tisCovered: function isCovered(coord, geomList) {\n  \t\tfor (var it = geomList.iterator(); it.hasNext();) {\n  \t\t\tvar geom = it.next();\n  \t\t\tvar loc = this._ptLocator.locate(coord, geom);\n  \t\t\tif (loc !== Location.EXTERIOR) return true;\n  \t\t}\n  \t\treturn false;\n  \t},\n  \treplaceCollapsedEdges: function replaceCollapsedEdges() {\n  \t\tvar newEdges = new ArrayList();\n  \t\tfor (var it = this._edgeList.iterator(); it.hasNext();) {\n  \t\t\tvar e = it.next();\n  \t\t\tif (e.isCollapsed()) {\n  \t\t\t\tit.remove();\n  \t\t\t\tnewEdges.add(e.getCollapsedEdge());\n  \t\t\t}\n  \t\t}\n  \t\tthis._edgeList.addAll(newEdges);\n  \t},\n  \tupdateNodeLabelling: function updateNodeLabelling() {\n  \t\tfor (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {\n  \t\t\tvar node = nodeit.next();\n  \t\t\tvar lbl = node.getEdges().getLabel();\n  \t\t\tnode.getLabel().merge(lbl);\n  \t\t}\n  \t},\n  \tgetResultGeometry: function getResultGeometry(overlayOpCode) {\n  \t\tthis.computeOverlay(overlayOpCode);\n  \t\treturn this._resultGeom;\n  \t},\n  \tinsertUniqueEdges: function insertUniqueEdges(edges) {\n  \t\tfor (var i = edges.iterator(); i.hasNext();) {\n  \t\t\tvar e = i.next();\n  \t\t\tthis.insertUniqueEdge(e);\n  \t\t}\n  \t},\n  \tcomputeOverlay: function computeOverlay(opCode) {\n  \t\tthis.copyPoints(0);\n  \t\tthis.copyPoints(1);\n  \t\tthis._arg[0].computeSelfNodes(this._li, false);\n  \t\tthis._arg[1].computeSelfNodes(this._li, false);\n  \t\tthis._arg[0].computeEdgeIntersections(this._arg[1], this._li, true);\n  \t\tvar baseSplitEdges = new ArrayList();\n  \t\tthis._arg[0].computeSplitEdges(baseSplitEdges);\n  \t\tthis._arg[1].computeSplitEdges(baseSplitEdges);\n  \t\tthis.insertUniqueEdges(baseSplitEdges);\n  \t\tthis.computeLabelsFromDepths();\n  \t\tthis.replaceCollapsedEdges();\n  \t\tEdgeNodingValidator.checkValid(this._edgeList.getEdges());\n  \t\tthis._graph.addEdges(this._edgeList.getEdges());\n  \t\tthis.computeLabelling();\n  \t\tthis.labelIncompleteNodes();\n  \t\tthis.findResultAreaEdges(opCode);\n  \t\tthis.cancelDuplicateResultEdges();\n  \t\tvar polyBuilder = new PolygonBuilder(this._geomFact);\n  \t\tpolyBuilder.add(this._graph);\n  \t\tthis._resultPolyList = polyBuilder.getPolygons();\n  \t\tvar lineBuilder = new LineBuilder(this, this._geomFact, this._ptLocator);\n  \t\tthis._resultLineList = lineBuilder.build(opCode);\n  \t\tvar pointBuilder = new PointBuilder(this, this._geomFact, this._ptLocator);\n  \t\tthis._resultPointList = pointBuilder.build(opCode);\n  \t\tthis._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, opCode);\n  \t},\n  \tlabelIncompleteNode: function labelIncompleteNode(n, targetIndex) {\n  \t\tvar loc = this._ptLocator.locate(n.getCoordinate(), this._arg[targetIndex].getGeometry());\n  \t\tn.getLabel().setLocation(targetIndex, loc);\n  \t},\n  \tcopyPoints: function copyPoints(argIndex) {\n  \t\tfor (var i = this._arg[argIndex].getNodeIterator(); i.hasNext();) {\n  \t\t\tvar graphNode = i.next();\n  \t\t\tvar newNode = this._graph.addNode(graphNode.getCoordinate());\n  \t\t\tnewNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));\n  \t\t}\n  \t},\n  \tfindResultAreaEdges: function findResultAreaEdges(opCode) {\n  \t\tfor (var it = this._graph.getEdgeEnds().iterator(); it.hasNext();) {\n  \t\t\tvar de = it.next();\n  \t\t\tvar label = de.getLabel();\n  \t\t\tif (label.isArea() && !de.isInteriorAreaEdge() && OverlayOp.isResultOfOp(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), opCode)) {\n  \t\t\t\tde.setInResult(true);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcomputeLabelsFromDepths: function computeLabelsFromDepths() {\n  \t\tfor (var it = this._edgeList.iterator(); it.hasNext();) {\n  \t\t\tvar e = it.next();\n  \t\t\tvar lbl = e.getLabel();\n  \t\t\tvar depth = e.getDepth();\n  \t\t\tif (!depth.isNull()) {\n  \t\t\t\tdepth.normalize();\n  \t\t\t\tfor (var i = 0; i < 2; i++) {\n  \t\t\t\t\tif (!lbl.isNull(i) && lbl.isArea() && !depth.isNull(i)) {\n  \t\t\t\t\t\tif (depth.getDelta(i) === 0) {\n  \t\t\t\t\t\t\tlbl.toLine(i);\n  \t\t\t\t\t\t} else {\n  \t\t\t\t\t\t\tAssert.isTrue(!depth.isNull(i, Position.LEFT), \"depth of LEFT side has not been initialized\");\n  \t\t\t\t\t\t\tlbl.setLocation(i, Position.LEFT, depth.getLocation(i, Position.LEFT));\n  \t\t\t\t\t\t\tAssert.isTrue(!depth.isNull(i, Position.RIGHT), \"depth of RIGHT side has not been initialized\");\n  \t\t\t\t\t\t\tlbl.setLocation(i, Position.RIGHT, depth.getLocation(i, Position.RIGHT));\n  \t\t\t\t\t\t}\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcomputeLabelling: function computeLabelling() {\n  \t\tfor (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {\n  \t\t\tvar node = nodeit.next();\n  \t\t\tnode.getEdges().computeLabelling(this._arg);\n  \t\t}\n  \t\tthis.mergeSymLabels();\n  \t\tthis.updateNodeLabelling();\n  \t},\n  \tlabelIncompleteNodes: function labelIncompleteNodes() {\n  \t\tfor (var ni = this._graph.getNodes().iterator(); ni.hasNext();) {\n  \t\t\tvar n = ni.next();\n  \t\t\tvar label = n.getLabel();\n  \t\t\tif (n.isIsolated()) {\n  \t\t\t\tif (label.isNull(0)) this.labelIncompleteNode(n, 0);else this.labelIncompleteNode(n, 1);\n  \t\t\t}\n  \t\t\tn.getEdges().updateLabelling(label);\n  \t\t}\n  \t},\n  \tisCoveredByA: function isCoveredByA(coord) {\n  \t\tif (this.isCovered(coord, this._resultPolyList)) return true;\n  \t\treturn false;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn OverlayOp;\n  \t}\n  });\n  OverlayOp.overlayOp = function (geom0, geom1, opCode) {\n  \tvar gov = new OverlayOp(geom0, geom1);\n  \tvar geomOv = gov.getResultGeometry(opCode);\n  \treturn geomOv;\n  };\n  OverlayOp.intersection = function (g, other) {\n  \tif (g.isEmpty() || other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.INTERSECTION, g, other, g.getFactory());\n  \tif (g.isGeometryCollection()) {\n  \t\tvar g2 = other;\n  \t\treturn GeometryCollectionMapper.map(g, {\n  \t\t\tinterfaces_: function interfaces_() {\n  \t\t\t\treturn [MapOp];\n  \t\t\t},\n  \t\t\tmap: function map(g) {\n  \t\t\t\treturn g.intersection(g2);\n  \t\t\t}\n  \t\t});\n  \t}\n  \tg.checkNotGeometryCollection(g);\n  \tg.checkNotGeometryCollection(other);\n  \treturn SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.INTERSECTION);\n  };\n  OverlayOp.symDifference = function (g, other) {\n  \tif (g.isEmpty() || other.isEmpty()) {\n  \t\tif (g.isEmpty() && other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.SYMDIFFERENCE, g, other, g.getFactory());\n  \t\tif (g.isEmpty()) return other.copy();\n  \t\tif (other.isEmpty()) return g.copy();\n  \t}\n  \tg.checkNotGeometryCollection(g);\n  \tg.checkNotGeometryCollection(other);\n  \treturn SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.SYMDIFFERENCE);\n  };\n  OverlayOp.resultDimension = function (opCode, g0, g1) {\n  \tvar dim0 = g0.getDimension();\n  \tvar dim1 = g1.getDimension();\n  \tvar resultDimension = -1;\n  \tswitch (opCode) {\n  \t\tcase OverlayOp.INTERSECTION:\n  \t\t\tresultDimension = Math.min(dim0, dim1);\n  \t\t\tbreak;\n  \t\tcase OverlayOp.UNION:\n  \t\t\tresultDimension = Math.max(dim0, dim1);\n  \t\t\tbreak;\n  \t\tcase OverlayOp.DIFFERENCE:\n  \t\t\tresultDimension = dim0;\n  \t\t\tbreak;\n  \t\tcase OverlayOp.SYMDIFFERENCE:\n  \t\t\tresultDimension = Math.max(dim0, dim1);\n  \t\t\tbreak;\n  \t}\n  \treturn resultDimension;\n  };\n  OverlayOp.createEmptyResult = function (overlayOpCode, a, b, geomFact) {\n  \tvar result = null;\n  \tswitch (OverlayOp.resultDimension(overlayOpCode, a, b)) {\n  \t\tcase -1:\n  \t\t\tresult = geomFact.createGeometryCollection(new Array(0).fill(null));\n  \t\t\tbreak;\n  \t\tcase 0:\n  \t\t\tresult = geomFact.createPoint();\n  \t\t\tbreak;\n  \t\tcase 1:\n  \t\t\tresult = geomFact.createLineString();\n  \t\t\tbreak;\n  \t\tcase 2:\n  \t\t\tresult = geomFact.createPolygon();\n  \t\t\tbreak;\n  \t}\n  \treturn result;\n  };\n  OverlayOp.difference = function (g, other) {\n  \tif (g.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.DIFFERENCE, g, other, g.getFactory());\n  \tif (other.isEmpty()) return g.copy();\n  \tg.checkNotGeometryCollection(g);\n  \tg.checkNotGeometryCollection(other);\n  \treturn SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.DIFFERENCE);\n  };\n  OverlayOp.isResultOfOp = function () {\n  \tif (arguments.length === 2) {\n  \t\tvar label = arguments[0],\n  \t\t    opCode = arguments[1];\n  \t\tvar loc0 = label.getLocation(0);\n  \t\tvar loc1 = label.getLocation(1);\n  \t\treturn OverlayOp.isResultOfOp(loc0, loc1, opCode);\n  \t} else if (arguments.length === 3) {\n  \t\tvar loc0 = arguments[0],\n  \t\t    loc1 = arguments[1],\n  \t\t    overlayOpCode = arguments[2];\n  \t\tif (loc0 === Location.BOUNDARY) loc0 = Location.INTERIOR;\n  \t\tif (loc1 === Location.BOUNDARY) loc1 = Location.INTERIOR;\n  \t\tswitch (overlayOpCode) {\n  \t\t\tcase OverlayOp.INTERSECTION:\n  \t\t\t\treturn loc0 === Location.INTERIOR && loc1 === Location.INTERIOR;\n  \t\t\tcase OverlayOp.UNION:\n  \t\t\t\treturn loc0 === Location.INTERIOR || loc1 === Location.INTERIOR;\n  \t\t\tcase OverlayOp.DIFFERENCE:\n  \t\t\t\treturn loc0 === Location.INTERIOR && loc1 !== Location.INTERIOR;\n  \t\t\tcase OverlayOp.SYMDIFFERENCE:\n  \t\t\t\treturn loc0 === Location.INTERIOR && loc1 !== Location.INTERIOR || loc0 !== Location.INTERIOR && loc1 === Location.INTERIOR;\n  \t\t}\n  \t\treturn false;\n  \t}\n  };\n  OverlayOp.INTERSECTION = 1;\n  OverlayOp.UNION = 2;\n  OverlayOp.DIFFERENCE = 3;\n  OverlayOp.SYMDIFFERENCE = 4;\n\n  function SnapOverlayOp() {\n  \tthis._geom = new Array(2).fill(null);\n  \tthis._snapTolerance = null;\n  \tthis._cbr = null;\n  \tvar g1 = arguments[0],\n  \t    g2 = arguments[1];\n  \tthis._geom[0] = g1;\n  \tthis._geom[1] = g2;\n  \tthis.computeSnapTolerance();\n  }\n  extend(SnapOverlayOp.prototype, {\n  \tselfSnap: function selfSnap(geom) {\n  \t\tvar snapper0 = new GeometrySnapper(geom);\n  \t\tvar snapGeom = snapper0.snapTo(geom, this._snapTolerance);\n  \t\treturn snapGeom;\n  \t},\n  \tremoveCommonBits: function removeCommonBits(geom) {\n  \t\tthis._cbr = new CommonBitsRemover();\n  \t\tthis._cbr.add(geom[0]);\n  \t\tthis._cbr.add(geom[1]);\n  \t\tvar remGeom = new Array(2).fill(null);\n  \t\tremGeom[0] = this._cbr.removeCommonBits(geom[0].copy());\n  \t\tremGeom[1] = this._cbr.removeCommonBits(geom[1].copy());\n  \t\treturn remGeom;\n  \t},\n  \tprepareResult: function prepareResult(geom) {\n  \t\tthis._cbr.addCommonBits(geom);\n  \t\treturn geom;\n  \t},\n  \tgetResultGeometry: function getResultGeometry(opCode) {\n  \t\tvar prepGeom = this.snap(this._geom);\n  \t\tvar result = OverlayOp.overlayOp(prepGeom[0], prepGeom[1], opCode);\n  \t\treturn this.prepareResult(result);\n  \t},\n  \tcheckValid: function checkValid(g) {\n  \t\tif (!g.isValid()) {\n  \t\t\tSystem.out.println(\"Snapped geometry is invalid\");\n  \t\t}\n  \t},\n  \tcomputeSnapTolerance: function computeSnapTolerance() {\n  \t\tthis._snapTolerance = GeometrySnapper.computeOverlaySnapTolerance(this._geom[0], this._geom[1]);\n  \t},\n  \tsnap: function snap(geom) {\n  \t\tvar remGeom = this.removeCommonBits(geom);\n  \t\tvar snapGeom = GeometrySnapper.snap(remGeom[0], remGeom[1], this._snapTolerance);\n  \t\treturn snapGeom;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SnapOverlayOp;\n  \t}\n  });\n  SnapOverlayOp.overlayOp = function (g0, g1, opCode) {\n  \tvar op = new SnapOverlayOp(g0, g1);\n  \treturn op.getResultGeometry(opCode);\n  };\n  SnapOverlayOp.union = function (g0, g1) {\n  \treturn SnapOverlayOp.overlayOp(g0, g1, OverlayOp.UNION);\n  };\n  SnapOverlayOp.intersection = function (g0, g1) {\n  \treturn SnapOverlayOp.overlayOp(g0, g1, OverlayOp.INTERSECTION);\n  };\n  SnapOverlayOp.symDifference = function (g0, g1) {\n  \treturn SnapOverlayOp.overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE);\n  };\n  SnapOverlayOp.difference = function (g0, g1) {\n  \treturn SnapOverlayOp.overlayOp(g0, g1, OverlayOp.DIFFERENCE);\n  };\n\n  function SnapIfNeededOverlayOp() {\n  \tthis._geom = new Array(2).fill(null);\n  \tvar g1 = arguments[0],\n  \t    g2 = arguments[1];\n  \tthis._geom[0] = g1;\n  \tthis._geom[1] = g2;\n  }\n  extend(SnapIfNeededOverlayOp.prototype, {\n  \tgetResultGeometry: function getResultGeometry(opCode) {\n  \t\tvar result = null;\n  \t\tvar isSuccess = false;\n  \t\tvar savedException = null;\n  \t\ttry {\n  \t\t\tresult = OverlayOp.overlayOp(this._geom[0], this._geom[1], opCode);\n  \t\t\tvar isValid = true;\n  \t\t\tif (isValid) isSuccess = true;\n  \t\t} catch (ex) {\n  \t\t\tif (ex instanceof RuntimeException) {\n  \t\t\t\tsavedException = ex;\n  \t\t\t} else throw ex;\n  \t\t} finally {}\n  \t\tif (!isSuccess) {\n  \t\t\ttry {\n  \t\t\t\tresult = SnapOverlayOp.overlayOp(this._geom[0], this._geom[1], opCode);\n  \t\t\t} catch (ex) {\n  \t\t\t\tif (ex instanceof RuntimeException) {\n  \t\t\t\t\tthrow savedException;\n  \t\t\t\t} else throw ex;\n  \t\t\t} finally {}\n  \t\t}\n  \t\treturn result;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SnapIfNeededOverlayOp;\n  \t}\n  });\n  SnapIfNeededOverlayOp.overlayOp = function (g0, g1, opCode) {\n  \tvar op = new SnapIfNeededOverlayOp(g0, g1);\n  \treturn op.getResultGeometry(opCode);\n  };\n  SnapIfNeededOverlayOp.union = function (g0, g1) {\n  \treturn SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.UNION);\n  };\n  SnapIfNeededOverlayOp.intersection = function (g0, g1) {\n  \treturn SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.INTERSECTION);\n  };\n  SnapIfNeededOverlayOp.symDifference = function (g0, g1) {\n  \treturn SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE);\n  };\n  SnapIfNeededOverlayOp.difference = function (g0, g1) {\n  \treturn SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.DIFFERENCE);\n  };\n\n  function InteriorPointArea() {\n  \tthis._factory = null;\n  \tthis._interiorPoint = null;\n  \tthis._maxWidth = 0.0;\n  \tvar g = arguments[0];\n  \tthis._factory = g.getFactory();\n  \tthis.add(g);\n  }\n  extend(InteriorPointArea.prototype, {\n  \taddPolygon: function addPolygon(geometry) {\n  \t\tif (geometry.isEmpty()) return null;\n  \t\tvar intPt = null;\n  \t\tvar width = 0;\n  \t\tvar bisector = this.horizontalBisector(geometry);\n  \t\tif (bisector.getLength() === 0.0) {\n  \t\t\twidth = 0;\n  \t\t\tintPt = bisector.getCoordinate();\n  \t\t} else {\n  \t\t\tvar intersections = SnapIfNeededOverlayOp.overlayOp(bisector, geometry, OverlayOp.INTERSECTION);\n  \t\t\tvar widestIntersection = this.widestGeometry(intersections);\n  \t\t\twidth = widestIntersection.getEnvelopeInternal().getWidth();\n  \t\t\tintPt = InteriorPointArea.centre(widestIntersection.getEnvelopeInternal());\n  \t\t}\n  \t\tif (this._interiorPoint === null || width > this._maxWidth) {\n  \t\t\tthis._interiorPoint = intPt;\n  \t\t\tthis._maxWidth = width;\n  \t\t}\n  \t},\n  \tgetInteriorPoint: function getInteriorPoint() {\n  \t\treturn this._interiorPoint;\n  \t},\n  \twidestGeometry: function widestGeometry() {\n  \t\tif (arguments[0] instanceof GeometryCollection) {\n  \t\t\tvar gc = arguments[0];\n  \t\t\tif (gc.isEmpty()) {\n  \t\t\t\treturn gc;\n  \t\t\t}\n  \t\t\tvar widestGeometry = gc.getGeometryN(0);\n  \t\t\tfor (var i = 1; i < gc.getNumGeometries(); i++) {\n  \t\t\t\tif (gc.getGeometryN(i).getEnvelopeInternal().getWidth() > widestGeometry.getEnvelopeInternal().getWidth()) {\n  \t\t\t\t\twidestGeometry = gc.getGeometryN(i);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\treturn widestGeometry;\n  \t\t} else if (arguments[0] instanceof Geometry) {\n  \t\t\tvar geometry = arguments[0];\n  \t\t\tif (!(geometry instanceof GeometryCollection)) {\n  \t\t\t\treturn geometry;\n  \t\t\t}\n  \t\t\treturn this.widestGeometry(geometry);\n  \t\t}\n  \t},\n  \thorizontalBisector: function horizontalBisector(geometry) {\n  \t\tvar envelope = geometry.getEnvelopeInternal();\n  \t\tvar bisectY = SafeBisectorFinder.getBisectorY(geometry);\n  \t\treturn this._factory.createLineString([new Coordinate(envelope.getMinX(), bisectY), new Coordinate(envelope.getMaxX(), bisectY)]);\n  \t},\n  \tadd: function add(geom) {\n  \t\tif (geom instanceof Polygon) {\n  \t\t\tthis.addPolygon(geom);\n  \t\t} else if (geom instanceof GeometryCollection) {\n  \t\t\tvar gc = geom;\n  \t\t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n  \t\t\t\tthis.add(gc.getGeometryN(i));\n  \t\t\t}\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn InteriorPointArea;\n  \t}\n  });\n  InteriorPointArea.centre = function (envelope) {\n  \treturn new Coordinate(InteriorPointArea.avg(envelope.getMinX(), envelope.getMaxX()), InteriorPointArea.avg(envelope.getMinY(), envelope.getMaxY()));\n  };\n  InteriorPointArea.avg = function (a, b) {\n  \treturn (a + b) / 2.0;\n  };\n  function SafeBisectorFinder() {\n  \tthis._poly = null;\n  \tthis._centreY = null;\n  \tthis._hiY = Double.MAX_VALUE;\n  \tthis._loY = -Double.MAX_VALUE;\n  \tvar poly = arguments[0];\n  \tthis._poly = poly;\n  \tthis._hiY = poly.getEnvelopeInternal().getMaxY();\n  \tthis._loY = poly.getEnvelopeInternal().getMinY();\n  \tthis._centreY = InteriorPointArea.avg(this._loY, this._hiY);\n  }\n  extend(SafeBisectorFinder.prototype, {\n  \tupdateInterval: function updateInterval(y) {\n  \t\tif (y <= this._centreY) {\n  \t\t\tif (y > this._loY) this._loY = y;\n  \t\t} else if (y > this._centreY) {\n  \t\t\tif (y < this._hiY) {\n  \t\t\t\tthis._hiY = y;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetBisectorY: function getBisectorY() {\n  \t\tthis.process(this._poly.getExteriorRing());\n  \t\tfor (var i = 0; i < this._poly.getNumInteriorRing(); i++) {\n  \t\t\tthis.process(this._poly.getInteriorRingN(i));\n  \t\t}\n  \t\tvar bisectY = InteriorPointArea.avg(this._hiY, this._loY);\n  \t\treturn bisectY;\n  \t},\n  \tprocess: function process(line) {\n  \t\tvar seq = line.getCoordinateSequence();\n  \t\tfor (var i = 0; i < seq.size(); i++) {\n  \t\t\tvar y = seq.getY(i);\n  \t\t\tthis.updateInterval(y);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SafeBisectorFinder;\n  \t}\n  });\n  SafeBisectorFinder.getBisectorY = function (poly) {\n  \tvar finder = new SafeBisectorFinder(poly);\n  \treturn finder.getBisectorY();\n  };\n  InteriorPointArea.SafeBisectorFinder = SafeBisectorFinder;\n\n  function InteriorPointLine() {\n  \tthis._centroid = null;\n  \tthis._minDistance = Double.MAX_VALUE;\n  \tthis._interiorPoint = null;\n  \tvar g = arguments[0];\n  \tthis._centroid = g.getCentroid().getCoordinate();\n  \tthis.addInterior(g);\n  \tif (this._interiorPoint === null) this.addEndpoints(g);\n  }\n  extend(InteriorPointLine.prototype, {\n  \taddEndpoints: function addEndpoints() {\n  \t\tif (arguments[0] instanceof Geometry) {\n  \t\t\tvar geom = arguments[0];\n  \t\t\tif (geom instanceof LineString) {\n  \t\t\t\tthis.addEndpoints(geom.getCoordinates());\n  \t\t\t} else if (geom instanceof GeometryCollection) {\n  \t\t\t\tvar gc = geom;\n  \t\t\t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n  \t\t\t\t\tthis.addEndpoints(gc.getGeometryN(i));\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} else if (arguments[0] instanceof Array) {\n  \t\t\tvar pts = arguments[0];\n  \t\t\tthis.add(pts[0]);\n  \t\t\tthis.add(pts[pts.length - 1]);\n  \t\t}\n  \t},\n  \tgetInteriorPoint: function getInteriorPoint() {\n  \t\treturn this._interiorPoint;\n  \t},\n  \taddInterior: function addInterior() {\n  \t\tif (arguments[0] instanceof Geometry) {\n  \t\t\tvar geom = arguments[0];\n  \t\t\tif (geom instanceof LineString) {\n  \t\t\t\tthis.addInterior(geom.getCoordinates());\n  \t\t\t} else if (geom instanceof GeometryCollection) {\n  \t\t\t\tvar gc = geom;\n  \t\t\t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n  \t\t\t\t\tthis.addInterior(gc.getGeometryN(i));\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} else if (arguments[0] instanceof Array) {\n  \t\t\tvar pts = arguments[0];\n  \t\t\tfor (var i = 1; i < pts.length - 1; i++) {\n  \t\t\t\tthis.add(pts[i]);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tadd: function add(point) {\n  \t\tvar dist = point.distance(this._centroid);\n  \t\tif (dist < this._minDistance) {\n  \t\t\tthis._interiorPoint = new Coordinate(point);\n  \t\t\tthis._minDistance = dist;\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn InteriorPointLine;\n  \t}\n  });\n\n  function InteriorPointPoint() {\n  \tthis._centroid = null;\n  \tthis._minDistance = Double.MAX_VALUE;\n  \tthis._interiorPoint = null;\n  \tvar g = arguments[0];\n  \tthis._centroid = g.getCentroid().getCoordinate();\n  \tthis.add(g);\n  }\n  extend(InteriorPointPoint.prototype, {\n  \tgetInteriorPoint: function getInteriorPoint() {\n  \t\treturn this._interiorPoint;\n  \t},\n  \tadd: function add() {\n  \t\tif (arguments[0] instanceof Geometry) {\n  \t\t\tvar geom = arguments[0];\n  \t\t\tif (geom instanceof Point) {\n  \t\t\t\tthis.add(geom.getCoordinate());\n  \t\t\t} else if (geom instanceof GeometryCollection) {\n  \t\t\t\tvar gc = geom;\n  \t\t\t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n  \t\t\t\t\tthis.add(gc.getGeometryN(i));\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} else if (arguments[0] instanceof Coordinate) {\n  \t\t\tvar point = arguments[0];\n  \t\t\tvar dist = point.distance(this._centroid);\n  \t\t\tif (dist < this._minDistance) {\n  \t\t\t\tthis._interiorPoint = new Coordinate(point);\n  \t\t\t\tthis._minDistance = dist;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn InteriorPointPoint;\n  \t}\n  });\n\n  function MonotoneChainSelectAction() {\n  \tthis.tempEnv1 = new Envelope();\n  \tthis.selectedSegment = new LineSegment();\n  }\n  extend(MonotoneChainSelectAction.prototype, {\n  \tselect: function select() {\n  \t\tif (arguments.length === 1) ; else if (arguments.length === 2) {\n  \t\t\tvar mc = arguments[0],\n  \t\t\t    startIndex = arguments[1];\n  \t\t\tmc.getLineSegment(startIndex, this.selectedSegment);\n  \t\t\tthis.select(this.selectedSegment);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MonotoneChainSelectAction;\n  \t}\n  });\n\n  function NodeBase() {\n  \tthis._items = new ArrayList();\n  \tthis._subnode = [null, null];\n  }\n  extend(NodeBase.prototype, {\n  \thasChildren: function hasChildren() {\n  \t\tfor (var i = 0; i < 2; i++) {\n  \t\t\tif (this._subnode[i] !== null) return true;\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tisPrunable: function isPrunable() {\n  \t\treturn !(this.hasChildren() || this.hasItems());\n  \t},\n  \taddAllItems: function addAllItems(items) {\n  \t\titems.addAll(this._items);\n  \t\tfor (var i = 0; i < 2; i++) {\n  \t\t\tif (this._subnode[i] !== null) {\n  \t\t\t\tthis._subnode[i].addAllItems(items);\n  \t\t\t}\n  \t\t}\n  \t\treturn items;\n  \t},\n  \tsize: function size() {\n  \t\tvar subSize = 0;\n  \t\tfor (var i = 0; i < 2; i++) {\n  \t\t\tif (this._subnode[i] !== null) {\n  \t\t\t\tsubSize += this._subnode[i].size();\n  \t\t\t}\n  \t\t}\n  \t\treturn subSize + this._items.size();\n  \t},\n  \taddAllItemsFromOverlapping: function addAllItemsFromOverlapping(interval, resultItems) {\n  \t\tif (interval !== null && !this.isSearchMatch(interval)) return null;\n  \t\tresultItems.addAll(this._items);\n  \t\tif (this._subnode[0] !== null) this._subnode[0].addAllItemsFromOverlapping(interval, resultItems);\n  \t\tif (this._subnode[1] !== null) this._subnode[1].addAllItemsFromOverlapping(interval, resultItems);\n  \t},\n  \thasItems: function hasItems() {\n  \t\treturn !this._items.isEmpty();\n  \t},\n  \tremove: function remove(itemInterval, item) {\n  \t\tif (!this.isSearchMatch(itemInterval)) return false;\n  \t\tvar found = false;\n  \t\tfor (var i = 0; i < 2; i++) {\n  \t\t\tif (this._subnode[i] !== null) {\n  \t\t\t\tfound = this._subnode[i].remove(itemInterval, item);\n  \t\t\t\tif (found) {\n  \t\t\t\t\tif (this._subnode[i].isPrunable()) this._subnode[i] = null;\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\tif (found) return found;\n  \t\tfound = this._items.remove(item);\n  \t\treturn found;\n  \t},\n  \tgetItems: function getItems() {\n  \t\treturn this._items;\n  \t},\n  \tdepth: function depth() {\n  \t\tvar maxSubDepth = 0;\n  \t\tfor (var i = 0; i < 2; i++) {\n  \t\t\tif (this._subnode[i] !== null) {\n  \t\t\t\tvar sqd = this._subnode[i].depth();\n  \t\t\t\tif (sqd > maxSubDepth) maxSubDepth = sqd;\n  \t\t\t}\n  \t\t}\n  \t\treturn maxSubDepth + 1;\n  \t},\n  \tnodeSize: function nodeSize() {\n  \t\tvar subSize = 0;\n  \t\tfor (var i = 0; i < 2; i++) {\n  \t\t\tif (this._subnode[i] !== null) {\n  \t\t\t\tsubSize += this._subnode[i].nodeSize();\n  \t\t\t}\n  \t\t}\n  \t\treturn subSize + 1;\n  \t},\n  \tadd: function add(item) {\n  \t\tthis._items.add(item);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn NodeBase;\n  \t}\n  });\n  NodeBase.getSubnodeIndex = function (interval, centre) {\n  \tvar subnodeIndex = -1;\n  \tif (interval.min >= centre) subnodeIndex = 1;\n  \tif (interval.max <= centre) subnodeIndex = 0;\n  \treturn subnodeIndex;\n  };\n\n  function Interval() {\n  \tthis.min = null;\n  \tthis.max = null;\n  \tif (arguments.length === 0) {\n  \t\tthis.min = 0.0;\n  \t\tthis.max = 0.0;\n  \t} else if (arguments.length === 1) {\n  \t\tvar interval = arguments[0];\n  \t\tthis.init(interval.min, interval.max);\n  \t} else if (arguments.length === 2) {\n  \t\tvar min = arguments[0],\n  \t\t    max = arguments[1];\n  \t\tthis.init(min, max);\n  \t}\n  }\n  extend(Interval.prototype, {\n  \texpandToInclude: function expandToInclude(interval) {\n  \t\tif (interval.max > this.max) this.max = interval.max;\n  \t\tif (interval.min < this.min) this.min = interval.min;\n  \t},\n  \tgetWidth: function getWidth() {\n  \t\treturn this.max - this.min;\n  \t},\n  \toverlaps: function overlaps() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar interval = arguments[0];\n  \t\t\treturn this.overlaps(interval.min, interval.max);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar min = arguments[0],\n  \t\t\t    max = arguments[1];\n  \t\t\tif (this.min > max || this.max < min) return false;\n  \t\t\treturn true;\n  \t\t}\n  \t},\n  \tgetMin: function getMin() {\n  \t\treturn this.min;\n  \t},\n  \ttoString: function toString() {\n  \t\treturn \"[\" + this.min + \", \" + this.max + \"]\";\n  \t},\n  \tcontains: function contains() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tif (arguments[0] instanceof Interval) {\n  \t\t\t\tvar interval = arguments[0];\n  \t\t\t\treturn this.contains(interval.min, interval.max);\n  \t\t\t} else if (typeof arguments[0] === \"number\") {\n  \t\t\t\tvar p = arguments[0];\n  \t\t\t\treturn p >= this.min && p <= this.max;\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar min = arguments[0],\n  \t\t\t    max = arguments[1];\n  \t\t\treturn min >= this.min && max <= this.max;\n  \t\t}\n  \t},\n  \tinit: function init(min, max) {\n  \t\tthis.min = min;\n  \t\tthis.max = max;\n  \t\tif (min > max) {\n  \t\t\tthis.min = max;\n  \t\t\tthis.max = min;\n  \t\t}\n  \t},\n  \tgetMax: function getMax() {\n  \t\treturn this.max;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Interval;\n  \t}\n  });\n\n  function DoubleBits() {}\n  DoubleBits.exponent = function (d) {\n    return CVTFWD(64, d) - 1023;\n  };\n  DoubleBits.powerOf2 = function (exp) {\n    return Math.pow(2, exp);\n  };\n  function CVTFWD(NumW, Qty) {\n    var Sign;\n    var Expo;\n    var Mant;\n    var Bin;\n    var Inf = {\n      32: {\n        d: 0x7F,\n        c: 0x80,\n        b: 0,\n        a: 0\n      },\n      64: {\n        d: 0x7FF0,\n        c: 0,\n        b: 0,\n        a: 0\n      }\n    };\n    var ExW = {\n      32: 8,\n      64: 11\n    }[NumW];\n    if (!Bin) {\n      Sign = Qty < 0 || 1 / Qty < 0;\n      if (!isFinite(Qty)) {\n        Bin = Inf[NumW];\n        if (Sign) {\n          Bin.d += 1 << NumW / 4 - 1;\n        }\n        Expo = Math.pow(2, ExW) - 1;\n        Mant = 0;\n      }\n    }\n    if (!Bin) {\n      Expo = {\n        32: 127,\n        64: 1023\n      }[NumW];\n      Mant = Math.abs(Qty);\n      while (Mant >= 2) {\n        Expo++;\n        Mant /= 2;\n      }\n      while (Mant < 1 && Expo > 0) {\n        Expo--;\n        Mant *= 2;\n      }\n      if (Expo <= 0) {\n        Mant /= 2;\n      }\n      if (NumW === 32 && Expo > 254) {\n        Bin = {\n          d: Sign ? 0xFF : 0x7F,\n          c: 0x80,\n          b: 0,\n          a: 0\n        };\n        Expo = Math.pow(2, ExW) - 1;\n        Mant = 0;\n      }\n    }\n    return Expo;\n  }\n\n  function Key() {\n  \tthis._pt = 0.0;\n  \tthis._level = 0;\n  \tthis._interval = null;\n  \tvar interval = arguments[0];\n  \tthis.computeKey(interval);\n  }\n  extend(Key.prototype, {\n  \tgetInterval: function getInterval() {\n  \t\treturn this._interval;\n  \t},\n  \tgetLevel: function getLevel() {\n  \t\treturn this._level;\n  \t},\n  \tcomputeKey: function computeKey(itemInterval) {\n  \t\tthis._level = Key.computeLevel(itemInterval);\n  \t\tthis._interval = new Interval();\n  \t\tthis.computeInterval(this._level, itemInterval);\n  \t\twhile (!this._interval.contains(itemInterval)) {\n  \t\t\tthis._level += 1;\n  \t\t\tthis.computeInterval(this._level, itemInterval);\n  \t\t}\n  \t},\n  \tcomputeInterval: function computeInterval(level, itemInterval) {\n  \t\tvar size = DoubleBits.powerOf2(level);\n  \t\tthis._pt = Math.floor(itemInterval.getMin() / size) * size;\n  \t\tthis._interval.init(this._pt, this._pt + size);\n  \t},\n  \tgetPoint: function getPoint() {\n  \t\treturn this._pt;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Key;\n  \t}\n  });\n  Key.computeLevel = function (interval) {\n  \tvar dx = interval.getWidth();\n  \tvar level = DoubleBits.exponent(dx) + 1;\n  \treturn level;\n  };\n\n  function Node$1() {\n  \tNodeBase.apply(this);\n  \tthis._interval = null;\n  \tthis._centre = null;\n  \tthis._level = null;\n  \tvar interval = arguments[0],\n  \t    level = arguments[1];\n  \tthis._interval = interval;\n  \tthis._level = level;\n  \tthis._centre = (interval.getMin() + interval.getMax()) / 2;\n  }\n  inherits$1(Node$1, NodeBase);\n  extend(Node$1.prototype, {\n  \tgetInterval: function getInterval() {\n  \t\treturn this._interval;\n  \t},\n  \tfind: function find(searchInterval) {\n  \t\tvar subnodeIndex = NodeBase.getSubnodeIndex(searchInterval, this._centre);\n  \t\tif (subnodeIndex === -1) return this;\n  \t\tif (this._subnode[subnodeIndex] !== null) {\n  \t\t\tvar node = this._subnode[subnodeIndex];\n  \t\t\treturn node.find(searchInterval);\n  \t\t}\n  \t\treturn this;\n  \t},\n  \tinsert: function insert(node) {\n  \t\tAssert.isTrue(this._interval === null || this._interval.contains(node._interval));\n  \t\tvar index = NodeBase.getSubnodeIndex(node._interval, this._centre);\n  \t\tif (node._level === this._level - 1) {\n  \t\t\tthis._subnode[index] = node;\n  \t\t} else {\n  \t\t\tvar childNode = this.createSubnode(index);\n  \t\t\tchildNode.insert(node);\n  \t\t\tthis._subnode[index] = childNode;\n  \t\t}\n  \t},\n  \tisSearchMatch: function isSearchMatch(itemInterval) {\n  \t\treturn itemInterval.overlaps(this._interval);\n  \t},\n  \tgetSubnode: function getSubnode(index) {\n  \t\tif (this._subnode[index] === null) {\n  \t\t\tthis._subnode[index] = this.createSubnode(index);\n  \t\t}\n  \t\treturn this._subnode[index];\n  \t},\n  \tgetNode: function getNode(searchInterval) {\n  \t\tvar subnodeIndex = NodeBase.getSubnodeIndex(searchInterval, this._centre);\n  \t\tif (subnodeIndex !== -1) {\n  \t\t\tvar node = this.getSubnode(subnodeIndex);\n  \t\t\treturn node.getNode(searchInterval);\n  \t\t} else {\n  \t\t\treturn this;\n  \t\t}\n  \t},\n  \tcreateSubnode: function createSubnode(index) {\n  \t\tvar min = 0.0;\n  \t\tvar max = 0.0;\n  \t\tswitch (index) {\n  \t\t\tcase 0:\n  \t\t\t\tmin = this._interval.getMin();\n  \t\t\t\tmax = this._centre;\n  \t\t\t\tbreak;\n  \t\t\tcase 1:\n  \t\t\t\tmin = this._centre;\n  \t\t\t\tmax = this._interval.getMax();\n  \t\t\t\tbreak;\n  \t\t}\n  \t\tvar subInt = new Interval(min, max);\n  \t\tvar node = new Node$1(subInt, this._level - 1);\n  \t\treturn node;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Node$1;\n  \t}\n  });\n  Node$1.createNode = function (itemInterval) {\n  \tvar key = new Key(itemInterval);\n  \tvar node = new Node$1(key.getInterval(), key.getLevel());\n  \treturn node;\n  };\n  Node$1.createExpanded = function (node, addInterval) {\n  \tvar expandInt = new Interval(addInterval);\n  \tif (node !== null) expandInt.expandToInclude(node._interval);\n  \tvar largerNode = Node$1.createNode(expandInt);\n  \tif (node !== null) largerNode.insert(node);\n  \treturn largerNode;\n  };\n\n  function IntervalSize() {}\n  extend(IntervalSize.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn IntervalSize;\n  \t}\n  });\n  IntervalSize.isZeroWidth = function (min, max) {\n  \tvar width = max - min;\n  \tif (width === 0.0) return true;\n  \tvar maxAbs = Math.max(Math.abs(min), Math.abs(max));\n  \tvar scaledInterval = width / maxAbs;\n  \tvar level = DoubleBits.exponent(scaledInterval);\n  \treturn level <= IntervalSize.MIN_BINARY_EXPONENT;\n  };\n  IntervalSize.MIN_BINARY_EXPONENT = -50;\n\n  function Root() {\n  \tNodeBase.apply(this);\n  }\n  inherits$1(Root, NodeBase);\n  extend(Root.prototype, {\n  \tinsert: function insert(itemInterval, item) {\n  \t\tvar index = NodeBase.getSubnodeIndex(itemInterval, Root.origin);\n  \t\tif (index === -1) {\n  \t\t\tthis.add(item);\n  \t\t\treturn null;\n  \t\t}\n  \t\tvar node = this._subnode[index];\n  \t\tif (node === null || !node.getInterval().contains(itemInterval)) {\n  \t\t\tvar largerNode = Node$1.createExpanded(node, itemInterval);\n  \t\t\tthis._subnode[index] = largerNode;\n  \t\t}\n  \t\tthis.insertContained(this._subnode[index], itemInterval, item);\n  \t},\n  \tisSearchMatch: function isSearchMatch(interval) {\n  \t\treturn true;\n  \t},\n  \tinsertContained: function insertContained(tree, itemInterval, item) {\n  \t\tAssert.isTrue(tree.getInterval().contains(itemInterval));\n  \t\tvar isZeroArea = IntervalSize.isZeroWidth(itemInterval.getMin(), itemInterval.getMax());\n  \t\tvar node = null;\n  \t\tif (isZeroArea) node = tree.find(itemInterval);else node = tree.getNode(itemInterval);\n  \t\tnode.add(item);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Root;\n  \t}\n  });\n  Root.origin = 0.0;\n\n  function Bintree() {\n  \tthis._root = null;\n  \tthis._minExtent = 1.0;\n  \tthis._root = new Root();\n  }\n  extend(Bintree.prototype, {\n  \tsize: function size() {\n  \t\tif (this._root !== null) return this._root.size();\n  \t\treturn 0;\n  \t},\n  \tinsert: function insert(itemInterval, item) {\n  \t\tthis.collectStats(itemInterval);\n  \t\tvar insertInterval = Bintree.ensureExtent(itemInterval, this._minExtent);\n  \t\tthis._root.insert(insertInterval, item);\n  \t},\n  \tquery: function query() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tif (typeof arguments[0] === \"number\") {\n  \t\t\t\tvar x = arguments[0];\n  \t\t\t\treturn this.query(new Interval(x, x));\n  \t\t\t} else if (arguments[0] instanceof Interval) {\n  \t\t\t\tvar interval = arguments[0];\n  \t\t\t\tvar foundItems = new ArrayList();\n  \t\t\t\tthis.query(interval, foundItems);\n  \t\t\t\treturn foundItems;\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar interval = arguments[0],\n  \t\t\t    foundItems = arguments[1];\n  \t\t\tthis._root.addAllItemsFromOverlapping(interval, foundItems);\n  \t\t}\n  \t},\n  \titerator: function iterator() {\n  \t\tvar foundItems = new ArrayList();\n  \t\tthis._root.addAllItems(foundItems);\n  \t\treturn foundItems.iterator();\n  \t},\n  \tremove: function remove(itemInterval, item) {\n  \t\tvar insertInterval = Bintree.ensureExtent(itemInterval, this._minExtent);\n  \t\treturn this._root.remove(insertInterval, item);\n  \t},\n  \tcollectStats: function collectStats(interval) {\n  \t\tvar del = interval.getWidth();\n  \t\tif (del < this._minExtent && del > 0.0) this._minExtent = del;\n  \t},\n  \tdepth: function depth() {\n  \t\tif (this._root !== null) return this._root.depth();\n  \t\treturn 0;\n  \t},\n  \tnodeSize: function nodeSize() {\n  \t\tif (this._root !== null) return this._root.nodeSize();\n  \t\treturn 0;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Bintree;\n  \t}\n  });\n  Bintree.ensureExtent = function (itemInterval, minExtent) {\n  \tvar min = itemInterval.getMin();\n  \tvar max = itemInterval.getMax();\n  \tif (min !== max) return itemInterval;\n  \tif (min === max) {\n  \t\tmin = min - minExtent / 2.0;\n  \t\tmax = min + minExtent / 2.0;\n  \t}\n  \treturn new Interval(min, max);\n  };\n\n  function PointInRing() {}\n  extend(PointInRing.prototype, {\n  \tisInside: function isInside(pt) {},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn PointInRing;\n  \t}\n  });\n\n  function MCPointInRing() {\n  \tthis._ring = null;\n  \tthis._tree = null;\n  \tthis._crossings = 0;\n  \tthis._interval = new Interval();\n  \tvar ring = arguments[0];\n  \tthis._ring = ring;\n  \tthis.buildIndex();\n  }\n  extend(MCPointInRing.prototype, {\n  \ttestLineSegment: function testLineSegment(p, seg) {\n  \t\tvar xInt = null;\n  \t\tvar x1 = null;\n  \t\tvar y1 = null;\n  \t\tvar x2 = null;\n  \t\tvar y2 = null;\n  \t\tvar p1 = seg.p0;\n  \t\tvar p2 = seg.p1;\n  \t\tx1 = p1.x - p.x;\n  \t\ty1 = p1.y - p.y;\n  \t\tx2 = p2.x - p.x;\n  \t\ty2 = p2.y - p.y;\n  \t\tif (y1 > 0 && y2 <= 0 || y2 > 0 && y1 <= 0) {\n  \t\t\txInt = RobustDeterminant.signOfDet2x2(x1, y1, x2, y2) / (y2 - y1);\n  \t\t\tif (0.0 < xInt) {\n  \t\t\t\tthis._crossings++;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tbuildIndex: function buildIndex() {\n  \t\tthis._tree = new Bintree();\n  \t\tvar pts = CoordinateArrays.removeRepeatedPoints(this._ring.getCoordinates());\n  \t\tvar mcList = MonotoneChainBuilder.getChains(pts);\n  \t\tfor (var i = 0; i < mcList.size(); i++) {\n  \t\t\tvar mc = mcList.get(i);\n  \t\t\tvar mcEnv = mc.getEnvelope();\n  \t\t\tthis._interval.min = mcEnv.getMinY();\n  \t\t\tthis._interval.max = mcEnv.getMaxY();\n  \t\t\tthis._tree.insert(this._interval, mc);\n  \t\t}\n  \t},\n  \ttestMonotoneChain: function testMonotoneChain(rayEnv, mcSelecter, mc) {\n  \t\tmc.select(rayEnv, mcSelecter);\n  \t},\n  \tisInside: function isInside(pt) {\n  \t\tthis._crossings = 0;\n  \t\tvar rayEnv = new Envelope(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, pt.y, pt.y);\n  \t\tthis._interval.min = pt.y;\n  \t\tthis._interval.max = pt.y;\n  \t\tvar segs = this._tree.query(this._interval);\n  \t\tvar mcSelecter = new MCSelecter(this, pt);\n  \t\tfor (var i = segs.iterator(); i.hasNext();) {\n  \t\t\tvar mc = i.next();\n  \t\t\tthis.testMonotoneChain(rayEnv, mcSelecter, mc);\n  \t\t}\n  \t\tif (this._crossings % 2 === 1) {\n  \t\t\treturn true;\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [PointInRing];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MCPointInRing;\n  \t}\n  });\n  function MCSelecter() {\n  \tMonotoneChainSelectAction.apply(this);\n  \tthis.mcp = null;\n  \tthis.p = null;\n  \tvar mcp = arguments[0],\n  \t    p = arguments[1];\n  \tthis.mcp = mcp;\n  \tthis.p = p;\n  }\n  inherits$1(MCSelecter, MonotoneChainSelectAction);\n  extend(MCSelecter.prototype, {\n  \tselect: function select() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar ls = arguments[0];\n  \t\t\tthis.mcp.testLineSegment(this.p, ls);\n  \t\t} else return MonotoneChainSelectAction.prototype.select.apply(this, arguments);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MCSelecter;\n  \t}\n  });\n  MCPointInRing.MCSelecter = MCSelecter;\n\n  function Angle() {}\n  extend(Angle.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Angle;\n  \t}\n  });\n  Angle.toDegrees = function (radians) {\n  \treturn radians * 180 / Math.PI;\n  };\n  Angle.normalize = function (angle) {\n  \twhile (angle > Math.PI) {\n  \t\tangle -= Angle.PI_TIMES_2;\n  \t}while (angle <= -Math.PI) {\n  \t\tangle += Angle.PI_TIMES_2;\n  \t}return angle;\n  };\n  Angle.angle = function () {\n  \tif (arguments.length === 1) {\n  \t\tvar p = arguments[0];\n  \t\treturn Math.atan2(p.y, p.x);\n  \t} else if (arguments.length === 2) {\n  \t\tvar p0 = arguments[0],\n  \t\t    p1 = arguments[1];\n  \t\tvar dx = p1.x - p0.x;\n  \t\tvar dy = p1.y - p0.y;\n  \t\treturn Math.atan2(dy, dx);\n  \t}\n  };\n  Angle.isAcute = function (p0, p1, p2) {\n  \tvar dx0 = p0.x - p1.x;\n  \tvar dy0 = p0.y - p1.y;\n  \tvar dx1 = p2.x - p1.x;\n  \tvar dy1 = p2.y - p1.y;\n  \tvar dotprod = dx0 * dx1 + dy0 * dy1;\n  \treturn dotprod > 0;\n  };\n  Angle.isObtuse = function (p0, p1, p2) {\n  \tvar dx0 = p0.x - p1.x;\n  \tvar dy0 = p0.y - p1.y;\n  \tvar dx1 = p2.x - p1.x;\n  \tvar dy1 = p2.y - p1.y;\n  \tvar dotprod = dx0 * dx1 + dy0 * dy1;\n  \treturn dotprod < 0;\n  };\n  Angle.interiorAngle = function (p0, p1, p2) {\n  \tvar anglePrev = Angle.angle(p1, p0);\n  \tvar angleNext = Angle.angle(p1, p2);\n  \treturn Math.abs(angleNext - anglePrev);\n  };\n  Angle.normalizePositive = function (angle) {\n  \tif (angle < 0.0) {\n  \t\twhile (angle < 0.0) {\n  \t\t\tangle += Angle.PI_TIMES_2;\n  \t\t}if (angle >= Angle.PI_TIMES_2) angle = 0.0;\n  \t} else {\n  \t\twhile (angle >= Angle.PI_TIMES_2) {\n  \t\t\tangle -= Angle.PI_TIMES_2;\n  \t\t}if (angle < 0.0) angle = 0.0;\n  \t}\n  \treturn angle;\n  };\n  Angle.angleBetween = function (tip1, tail, tip2) {\n  \tvar a1 = Angle.angle(tail, tip1);\n  \tvar a2 = Angle.angle(tail, tip2);\n  \treturn Angle.diff(a1, a2);\n  };\n  Angle.diff = function (ang1, ang2) {\n  \tvar delAngle = null;\n  \tif (ang1 < ang2) {\n  \t\tdelAngle = ang2 - ang1;\n  \t} else {\n  \t\tdelAngle = ang1 - ang2;\n  \t}\n  \tif (delAngle > Math.PI) {\n  \t\tdelAngle = 2 * Math.PI - delAngle;\n  \t}\n  \treturn delAngle;\n  };\n  Angle.toRadians = function (angleDegrees) {\n  \treturn angleDegrees * Math.PI / 180.0;\n  };\n  Angle.getTurn = function (ang1, ang2) {\n  \tvar crossproduct = Math.sin(ang2 - ang1);\n  \tif (crossproduct > 0) {\n  \t\treturn Angle.COUNTERCLOCKWISE;\n  \t}\n  \tif (crossproduct < 0) {\n  \t\treturn Angle.CLOCKWISE;\n  \t}\n  \treturn Angle.NONE;\n  };\n  Angle.angleBetweenOriented = function (tip1, tail, tip2) {\n  \tvar a1 = Angle.angle(tail, tip1);\n  \tvar a2 = Angle.angle(tail, tip2);\n  \tvar angDel = a2 - a1;\n  \tif (angDel <= -Math.PI) return angDel + Angle.PI_TIMES_2;\n  \tif (angDel > Math.PI) return angDel - Angle.PI_TIMES_2;\n  \treturn angDel;\n  };\n  Angle.PI_TIMES_2 = 2.0 * Math.PI;\n  Angle.PI_OVER_2 = Math.PI / 2.0;\n  Angle.PI_OVER_4 = Math.PI / 4.0;\n  Angle.COUNTERCLOCKWISE = CGAlgorithms.COUNTERCLOCKWISE;\n  Angle.CLOCKWISE = CGAlgorithms.CLOCKWISE;\n  Angle.NONE = CGAlgorithms.COLLINEAR;\n\n  function Triangle$1() {\n  \tthis.p0 = null;\n  \tthis.p1 = null;\n  \tthis.p2 = null;\n  \tvar p0 = arguments[0],\n  \t    p1 = arguments[1],\n  \t    p2 = arguments[2];\n  \tthis.p0 = p0;\n  \tthis.p1 = p1;\n  \tthis.p2 = p2;\n  }\n  extend(Triangle$1.prototype, {\n  \tarea: function area() {\n  \t\treturn Triangle$1.area(this.p0, this.p1, this.p2);\n  \t},\n  \tsignedArea: function signedArea() {\n  \t\treturn Triangle$1.signedArea(this.p0, this.p1, this.p2);\n  \t},\n  \tinterpolateZ: function interpolateZ(p) {\n  \t\tif (p === null) throw new IllegalArgumentException(\"Supplied point is null.\");\n  \t\treturn Triangle$1.interpolateZ(p, this.p0, this.p1, this.p2);\n  \t},\n  \tlongestSideLength: function longestSideLength() {\n  \t\treturn Triangle$1.longestSideLength(this.p0, this.p1, this.p2);\n  \t},\n  \tisAcute: function isAcute() {\n  \t\treturn Triangle$1.isAcute(this.p0, this.p1, this.p2);\n  \t},\n  \tcircumcentre: function circumcentre() {\n  \t\treturn Triangle$1.circumcentre(this.p0, this.p1, this.p2);\n  \t},\n  \tarea3D: function area3D() {\n  \t\treturn Triangle$1.area3D(this.p0, this.p1, this.p2);\n  \t},\n  \tcentroid: function centroid() {\n  \t\treturn Triangle$1.centroid(this.p0, this.p1, this.p2);\n  \t},\n  \tinCentre: function inCentre() {\n  \t\treturn Triangle$1.inCentre(this.p0, this.p1, this.p2);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Triangle$1;\n  \t}\n  });\n  Triangle$1.area = function (a, b, c) {\n  \treturn Math.abs(((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2);\n  };\n  Triangle$1.signedArea = function (a, b, c) {\n  \treturn ((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2;\n  };\n  Triangle$1.det = function (m00, m01, m10, m11) {\n  \treturn m00 * m11 - m01 * m10;\n  };\n  Triangle$1.interpolateZ = function (p, v0, v1, v2) {\n  \tvar x0 = v0.x;\n  \tvar y0 = v0.y;\n  \tvar a = v1.x - x0;\n  \tvar b = v2.x - x0;\n  \tvar c = v1.y - y0;\n  \tvar d = v2.y - y0;\n  \tvar det = a * d - b * c;\n  \tvar dx = p.x - x0;\n  \tvar dy = p.y - y0;\n  \tvar t = (d * dx - b * dy) / det;\n  \tvar u = (-c * dx + a * dy) / det;\n  \tvar z = v0.z + t * (v1.z - v0.z) + u * (v2.z - v0.z);\n  \treturn z;\n  };\n  Triangle$1.longestSideLength = function (a, b, c) {\n  \tvar lenAB = a.distance(b);\n  \tvar lenBC = b.distance(c);\n  \tvar lenCA = c.distance(a);\n  \tvar maxLen = lenAB;\n  \tif (lenBC > maxLen) maxLen = lenBC;\n  \tif (lenCA > maxLen) maxLen = lenCA;\n  \treturn maxLen;\n  };\n  Triangle$1.isAcute = function (a, b, c) {\n  \tif (!Angle.isAcute(a, b, c)) return false;\n  \tif (!Angle.isAcute(b, c, a)) return false;\n  \tif (!Angle.isAcute(c, a, b)) return false;\n  \treturn true;\n  };\n  Triangle$1.circumcentre = function (a, b, c) {\n  \tvar cx = c.x;\n  \tvar cy = c.y;\n  \tvar ax = a.x - cx;\n  \tvar ay = a.y - cy;\n  \tvar bx = b.x - cx;\n  \tvar by = b.y - cy;\n  \tvar denom = 2 * Triangle$1.det(ax, ay, bx, by);\n  \tvar numx = Triangle$1.det(ay, ax * ax + ay * ay, by, bx * bx + by * by);\n  \tvar numy = Triangle$1.det(ax, ax * ax + ay * ay, bx, bx * bx + by * by);\n  \tvar ccx = cx - numx / denom;\n  \tvar ccy = cy + numy / denom;\n  \treturn new Coordinate(ccx, ccy);\n  };\n  Triangle$1.perpendicularBisector = function (a, b) {\n  \tvar dx = b.x - a.x;\n  \tvar dy = b.y - a.y;\n  \tvar l1 = new HCoordinate(a.x + dx / 2.0, a.y + dy / 2.0, 1.0);\n  \tvar l2 = new HCoordinate(a.x - dy + dx / 2.0, a.y + dx + dy / 2.0, 1.0);\n  \treturn new HCoordinate(l1, l2);\n  };\n  Triangle$1.angleBisector = function (a, b, c) {\n  \tvar len0 = b.distance(a);\n  \tvar len2 = b.distance(c);\n  \tvar frac = len0 / (len0 + len2);\n  \tvar dx = c.x - a.x;\n  \tvar dy = c.y - a.y;\n  \tvar splitPt = new Coordinate(a.x + frac * dx, a.y + frac * dy);\n  \treturn splitPt;\n  };\n  Triangle$1.area3D = function (a, b, c) {\n  \tvar ux = b.x - a.x;\n  \tvar uy = b.y - a.y;\n  \tvar uz = b.z - a.z;\n  \tvar vx = c.x - a.x;\n  \tvar vy = c.y - a.y;\n  \tvar vz = c.z - a.z;\n  \tvar crossx = uy * vz - uz * vy;\n  \tvar crossy = uz * vx - ux * vz;\n  \tvar crossz = ux * vy - uy * vx;\n  \tvar absSq = crossx * crossx + crossy * crossy + crossz * crossz;\n  \tvar area3D = Math.sqrt(absSq) / 2;\n  \treturn area3D;\n  };\n  Triangle$1.centroid = function (a, b, c) {\n  \tvar x = (a.x + b.x + c.x) / 3;\n  \tvar y = (a.y + b.y + c.y) / 3;\n  \treturn new Coordinate(x, y);\n  };\n  Triangle$1.inCentre = function (a, b, c) {\n  \tvar len0 = b.distance(c);\n  \tvar len1 = a.distance(c);\n  \tvar len2 = a.distance(b);\n  \tvar circum = len0 + len1 + len2;\n  \tvar inCentreX = (len0 * a.x + len1 * b.x + len2 * c.x) / circum;\n  \tvar inCentreY = (len0 * a.y + len1 * b.y + len2 * c.y) / circum;\n  \treturn new Coordinate(inCentreX, inCentreY);\n  };\n\n  function MinimumBoundingCircle() {\n  \tthis._input = null;\n  \tthis._extremalPts = null;\n  \tthis._centre = null;\n  \tthis._radius = 0.0;\n  \tvar geom = arguments[0];\n  \tthis._input = geom;\n  }\n  extend(MinimumBoundingCircle.prototype, {\n  \tgetRadius: function getRadius() {\n  \t\tthis.compute();\n  \t\treturn this._radius;\n  \t},\n  \tgetDiameter: function getDiameter() {\n  \t\tthis.compute();\n  \t\tswitch (this._extremalPts.length) {\n  \t\t\tcase 0:\n  \t\t\t\treturn this._input.getFactory().createLineString();\n  \t\t\tcase 1:\n  \t\t\t\treturn this._input.getFactory().createPoint(this._centre);\n  \t\t}\n  \t\tvar p0 = this._extremalPts[0];\n  \t\tvar p1 = this._extremalPts[1];\n  \t\treturn this._input.getFactory().createLineString([p0, p1]);\n  \t},\n  \tgetExtremalPoints: function getExtremalPoints() {\n  \t\tthis.compute();\n  \t\treturn this._extremalPts;\n  \t},\n  \tcomputeCirclePoints: function computeCirclePoints() {\n  \t\tif (this._input.isEmpty()) {\n  \t\t\tthis._extremalPts = new Array(0).fill(null);\n  \t\t\treturn null;\n  \t\t}\n  \t\tif (this._input.getNumPoints() === 1) {\n  \t\t\tvar pts = this._input.getCoordinates();\n  \t\t\tthis._extremalPts = [new Coordinate(pts[0])];\n  \t\t\treturn null;\n  \t\t}\n  \t\tvar convexHull = this._input.convexHull();\n  \t\tvar hullPts = convexHull.getCoordinates();\n  \t\tvar pts = hullPts;\n  \t\tif (hullPts[0].equals2D(hullPts[hullPts.length - 1])) {\n  \t\t\tpts = new Array(hullPts.length - 1).fill(null);\n  \t\t\tCoordinateArrays.copyDeep(hullPts, 0, pts, 0, hullPts.length - 1);\n  \t\t}\n  \t\tif (pts.length <= 2) {\n  \t\t\tthis._extremalPts = CoordinateArrays.copyDeep(pts);\n  \t\t\treturn null;\n  \t\t}\n  \t\tvar P = MinimumBoundingCircle.lowestPoint(pts);\n  \t\tvar Q = MinimumBoundingCircle.pointWitMinAngleWithX(pts, P);\n  \t\tfor (var i = 0; i < pts.length; i++) {\n  \t\t\tvar R = MinimumBoundingCircle.pointWithMinAngleWithSegment(pts, P, Q);\n  \t\t\tif (Angle.isObtuse(P, R, Q)) {\n  \t\t\t\tthis._extremalPts = [new Coordinate(P), new Coordinate(Q)];\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t\tif (Angle.isObtuse(R, P, Q)) {\n  \t\t\t\tP = R;\n  \t\t\t\tcontinue;\n  \t\t\t}\n  \t\t\tif (Angle.isObtuse(R, Q, P)) {\n  \t\t\t\tQ = R;\n  \t\t\t\tcontinue;\n  \t\t\t}\n  \t\t\tthis._extremalPts = [new Coordinate(P), new Coordinate(Q), new Coordinate(R)];\n  \t\t\treturn null;\n  \t\t}\n  \t\tAssert.shouldNeverReachHere(\"Logic failure in Minimum Bounding Circle algorithm!\");\n  \t},\n  \tcompute: function compute() {\n  \t\tif (this._extremalPts !== null) return null;\n  \t\tthis.computeCirclePoints();\n  \t\tthis.computeCentre();\n  \t\tif (this._centre !== null) this._radius = this._centre.distance(this._extremalPts[0]);\n  \t},\n  \tgetFarthestPoints: function getFarthestPoints() {\n  \t\tthis.compute();\n  \t\tswitch (this._extremalPts.length) {\n  \t\t\tcase 0:\n  \t\t\t\treturn this._input.getFactory().createLineString();\n  \t\t\tcase 1:\n  \t\t\t\treturn this._input.getFactory().createPoint(this._centre);\n  \t\t}\n  \t\tvar p0 = this._extremalPts[0];\n  \t\tvar p1 = this._extremalPts[this._extremalPts.length - 1];\n  \t\treturn this._input.getFactory().createLineString([p0, p1]);\n  \t},\n  \tgetCircle: function getCircle() {\n  \t\tthis.compute();\n  \t\tif (this._centre === null) return this._input.getFactory().createPolygon();\n  \t\tvar centrePoint = this._input.getFactory().createPoint(this._centre);\n  \t\tif (this._radius === 0.0) return centrePoint;\n  \t\treturn centrePoint.buffer(this._radius);\n  \t},\n  \tgetCentre: function getCentre() {\n  \t\tthis.compute();\n  \t\treturn this._centre;\n  \t},\n  \tcomputeCentre: function computeCentre() {\n  \t\tswitch (this._extremalPts.length) {\n  \t\t\tcase 0:\n  \t\t\t\tthis._centre = null;\n  \t\t\t\tbreak;\n  \t\t\tcase 1:\n  \t\t\t\tthis._centre = this._extremalPts[0];\n  \t\t\t\tbreak;\n  \t\t\tcase 2:\n  \t\t\t\tthis._centre = new Coordinate((this._extremalPts[0].x + this._extremalPts[1].x) / 2.0, (this._extremalPts[0].y + this._extremalPts[1].y) / 2.0);\n  \t\t\t\tbreak;\n  \t\t\tcase 3:\n  \t\t\t\tthis._centre = Triangle$1.circumcentre(this._extremalPts[0], this._extremalPts[1], this._extremalPts[2]);\n  \t\t\t\tbreak;\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MinimumBoundingCircle;\n  \t}\n  });\n  MinimumBoundingCircle.pointWitMinAngleWithX = function (pts, P) {\n  \tvar minSin = Double.MAX_VALUE;\n  \tvar minAngPt = null;\n  \tfor (var i = 0; i < pts.length; i++) {\n  \t\tvar p = pts[i];\n  \t\tif (p === P) continue;\n  \t\tvar dx = p.x - P.x;\n  \t\tvar dy = p.y - P.y;\n  \t\tif (dy < 0) dy = -dy;\n  \t\tvar len = Math.sqrt(dx * dx + dy * dy);\n  \t\tvar sin = dy / len;\n  \t\tif (sin < minSin) {\n  \t\t\tminSin = sin;\n  \t\t\tminAngPt = p;\n  \t\t}\n  \t}\n  \treturn minAngPt;\n  };\n  MinimumBoundingCircle.lowestPoint = function (pts) {\n  \tvar min = pts[0];\n  \tfor (var i = 1; i < pts.length; i++) {\n  \t\tif (pts[i].y < min.y) min = pts[i];\n  \t}\n  \treturn min;\n  };\n  MinimumBoundingCircle.pointWithMinAngleWithSegment = function (pts, P, Q) {\n  \tvar minAng = Double.MAX_VALUE;\n  \tvar minAngPt = null;\n  \tfor (var i = 0; i < pts.length; i++) {\n  \t\tvar p = pts[i];\n  \t\tif (p === P) continue;\n  \t\tif (p === Q) continue;\n  \t\tvar ang = Angle.angleBetween(P, p, Q);\n  \t\tif (ang < minAng) {\n  \t\t\tminAng = ang;\n  \t\t\tminAngPt = p;\n  \t\t}\n  \t}\n  \treturn minAngPt;\n  };\n\n  function MinimumDiameter() {\n  \tthis._inputGeom = null;\n  \tthis._isConvex = null;\n  \tthis._convexHullPts = null;\n  \tthis._minBaseSeg = new LineSegment();\n  \tthis._minWidthPt = null;\n  \tthis._minPtIndex = null;\n  \tthis._minWidth = 0.0;\n  \tif (arguments.length === 1) {\n  \t\tvar inputGeom = arguments[0];\n  \t\tMinimumDiameter.call(this, inputGeom, false);\n  \t} else if (arguments.length === 2) {\n  \t\tvar inputGeom = arguments[0],\n  \t\t    isConvex = arguments[1];\n  \t\tthis._inputGeom = inputGeom;\n  \t\tthis._isConvex = isConvex;\n  \t}\n  }\n  extend(MinimumDiameter.prototype, {\n  \tgetWidthCoordinate: function getWidthCoordinate() {\n  \t\tthis.computeMinimumDiameter();\n  \t\treturn this._minWidthPt;\n  \t},\n  \tgetSupportingSegment: function getSupportingSegment() {\n  \t\tthis.computeMinimumDiameter();\n  \t\treturn this._inputGeom.getFactory().createLineString([this._minBaseSeg.p0, this._minBaseSeg.p1]);\n  \t},\n  \tgetDiameter: function getDiameter() {\n  \t\tthis.computeMinimumDiameter();\n  \t\tif (this._minWidthPt === null) return this._inputGeom.getFactory().createLineString(null);\n  \t\tvar basePt = this._minBaseSeg.project(this._minWidthPt);\n  \t\treturn this._inputGeom.getFactory().createLineString([basePt, this._minWidthPt]);\n  \t},\n  \tcomputeWidthConvex: function computeWidthConvex(convexGeom) {\n  \t\tif (convexGeom instanceof Polygon) this._convexHullPts = convexGeom.getExteriorRing().getCoordinates();else this._convexHullPts = convexGeom.getCoordinates();\n  \t\tif (this._convexHullPts.length === 0) {\n  \t\t\tthis._minWidth = 0.0;\n  \t\t\tthis._minWidthPt = null;\n  \t\t\tthis._minBaseSeg = null;\n  \t\t} else if (this._convexHullPts.length === 1) {\n  \t\t\tthis._minWidth = 0.0;\n  \t\t\tthis._minWidthPt = this._convexHullPts[0];\n  \t\t\tthis._minBaseSeg.p0 = this._convexHullPts[0];\n  \t\t\tthis._minBaseSeg.p1 = this._convexHullPts[0];\n  \t\t} else if (this._convexHullPts.length === 2 || this._convexHullPts.length === 3) {\n  \t\t\tthis._minWidth = 0.0;\n  \t\t\tthis._minWidthPt = this._convexHullPts[0];\n  \t\t\tthis._minBaseSeg.p0 = this._convexHullPts[0];\n  \t\t\tthis._minBaseSeg.p1 = this._convexHullPts[1];\n  \t\t} else this.computeConvexRingMinDiameter(this._convexHullPts);\n  \t},\n  \tcomputeConvexRingMinDiameter: function computeConvexRingMinDiameter(pts) {\n  \t\tthis._minWidth = Double.MAX_VALUE;\n  \t\tvar currMaxIndex = 1;\n  \t\tvar seg = new LineSegment();\n  \t\tfor (var i = 0; i < pts.length - 1; i++) {\n  \t\t\tseg.p0 = pts[i];\n  \t\t\tseg.p1 = pts[i + 1];\n  \t\t\tcurrMaxIndex = this.findMaxPerpDistance(pts, seg, currMaxIndex);\n  \t\t}\n  \t},\n  \tcomputeMinimumDiameter: function computeMinimumDiameter() {\n  \t\tif (this._minWidthPt !== null) return null;\n  \t\tif (this._isConvex) this.computeWidthConvex(this._inputGeom);else {\n  \t\t\tvar convexGeom = new ConvexHull(this._inputGeom).getConvexHull();\n  \t\t\tthis.computeWidthConvex(convexGeom);\n  \t\t}\n  \t},\n  \tgetLength: function getLength() {\n  \t\tthis.computeMinimumDiameter();\n  \t\treturn this._minWidth;\n  \t},\n  \tfindMaxPerpDistance: function findMaxPerpDistance(pts, seg, startIndex) {\n  \t\tvar maxPerpDistance = seg.distancePerpendicular(pts[startIndex]);\n  \t\tvar nextPerpDistance = maxPerpDistance;\n  \t\tvar maxIndex = startIndex;\n  \t\tvar nextIndex = maxIndex;\n  \t\twhile (nextPerpDistance >= maxPerpDistance) {\n  \t\t\tmaxPerpDistance = nextPerpDistance;\n  \t\t\tmaxIndex = nextIndex;\n  \t\t\tnextIndex = MinimumDiameter.nextIndex(pts, maxIndex);\n  \t\t\tnextPerpDistance = seg.distancePerpendicular(pts[nextIndex]);\n  \t\t}\n  \t\tif (maxPerpDistance < this._minWidth) {\n  \t\t\tthis._minPtIndex = maxIndex;\n  \t\t\tthis._minWidth = maxPerpDistance;\n  \t\t\tthis._minWidthPt = pts[this._minPtIndex];\n  \t\t\tthis._minBaseSeg = new LineSegment(seg);\n  \t\t}\n  \t\treturn maxIndex;\n  \t},\n  \tgetMinimumRectangle: function getMinimumRectangle() {\n  \t\tthis.computeMinimumDiameter();\n  \t\tif (this._minWidth === 0.0) {\n  \t\t\tif (this._minBaseSeg.p0.equals2D(this._minBaseSeg.p1)) {\n  \t\t\t\treturn this._inputGeom.getFactory().createPoint(this._minBaseSeg.p0);\n  \t\t\t}\n  \t\t\treturn this._minBaseSeg.toGeometry(this._inputGeom.getFactory());\n  \t\t}\n  \t\tvar dx = this._minBaseSeg.p1.x - this._minBaseSeg.p0.x;\n  \t\tvar dy = this._minBaseSeg.p1.y - this._minBaseSeg.p0.y;\n  \t\tvar minPara = Double.MAX_VALUE;\n  \t\tvar maxPara = -Double.MAX_VALUE;\n  \t\tvar minPerp = Double.MAX_VALUE;\n  \t\tvar maxPerp = -Double.MAX_VALUE;\n  \t\tfor (var i = 0; i < this._convexHullPts.length; i++) {\n  \t\t\tvar paraC = MinimumDiameter.computeC(dx, dy, this._convexHullPts[i]);\n  \t\t\tif (paraC > maxPara) maxPara = paraC;\n  \t\t\tif (paraC < minPara) minPara = paraC;\n  \t\t\tvar perpC = MinimumDiameter.computeC(-dy, dx, this._convexHullPts[i]);\n  \t\t\tif (perpC > maxPerp) maxPerp = perpC;\n  \t\t\tif (perpC < minPerp) minPerp = perpC;\n  \t\t}\n  \t\tvar maxPerpLine = MinimumDiameter.computeSegmentForLine(-dx, -dy, maxPerp);\n  \t\tvar minPerpLine = MinimumDiameter.computeSegmentForLine(-dx, -dy, minPerp);\n  \t\tvar maxParaLine = MinimumDiameter.computeSegmentForLine(-dy, dx, maxPara);\n  \t\tvar minParaLine = MinimumDiameter.computeSegmentForLine(-dy, dx, minPara);\n  \t\tvar p0 = maxParaLine.lineIntersection(maxPerpLine);\n  \t\tvar p1 = minParaLine.lineIntersection(maxPerpLine);\n  \t\tvar p2 = minParaLine.lineIntersection(minPerpLine);\n  \t\tvar p3 = maxParaLine.lineIntersection(minPerpLine);\n  \t\tvar shell = this._inputGeom.getFactory().createLinearRing([p0, p1, p2, p3, p0]);\n  \t\treturn this._inputGeom.getFactory().createPolygon(shell, null);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MinimumDiameter;\n  \t}\n  });\n  MinimumDiameter.nextIndex = function (pts, index) {\n  \tindex++;\n  \tif (index >= pts.length) index = 0;\n  \treturn index;\n  };\n  MinimumDiameter.computeC = function (a, b, p) {\n  \treturn a * p.y - b * p.x;\n  };\n  MinimumDiameter.getMinimumDiameter = function (geom) {\n  \treturn new MinimumDiameter(geom).getDiameter();\n  };\n  MinimumDiameter.getMinimumRectangle = function (geom) {\n  \treturn new MinimumDiameter(geom).getMinimumRectangle();\n  };\n  MinimumDiameter.computeSegmentForLine = function (a, b, c) {\n  \tvar p0 = null;\n  \tvar p1 = null;\n  \tif (Math.abs(b) > Math.abs(a)) {\n  \t\tp0 = new Coordinate(0.0, c / b);\n  \t\tp1 = new Coordinate(1.0, c / b - a / b);\n  \t} else {\n  \t\tp0 = new Coordinate(c / a, 0.0);\n  \t\tp1 = new Coordinate(c / a - b / a, 1.0);\n  \t}\n  \treturn new LineSegment(p0, p1);\n  };\n\n  function Densifier() {\n  \tthis._inputGeom = null;\n  \tthis._distanceTolerance = null;\n  \tvar inputGeom = arguments[0];\n  \tthis._inputGeom = inputGeom;\n  }\n  extend(Densifier.prototype, {\n  \tgetResultGeometry: function getResultGeometry() {\n  \t\treturn new DensifyTransformer(this._distanceTolerance).transform(this._inputGeom);\n  \t},\n  \tsetDistanceTolerance: function setDistanceTolerance(distanceTolerance) {\n  \t\tif (distanceTolerance <= 0.0) throw new IllegalArgumentException(\"Tolerance must be positive\");\n  \t\tthis._distanceTolerance = distanceTolerance;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Densifier;\n  \t}\n  });\n  Densifier.densifyPoints = function (pts, distanceTolerance, precModel) {\n  \tvar seg = new LineSegment();\n  \tvar coordList = new CoordinateList();\n  \tfor (var i = 0; i < pts.length - 1; i++) {\n  \t\tseg.p0 = pts[i];\n  \t\tseg.p1 = pts[i + 1];\n  \t\tcoordList.add(seg.p0, false);\n  \t\tvar len = seg.getLength();\n  \t\tvar densifiedSegCount = Math.trunc(len / distanceTolerance) + 1;\n  \t\tif (densifiedSegCount > 1) {\n  \t\t\tvar densifiedSegLen = len / densifiedSegCount;\n  \t\t\tfor (var j = 1; j < densifiedSegCount; j++) {\n  \t\t\t\tvar segFract = j * densifiedSegLen / len;\n  \t\t\t\tvar p = seg.pointAlong(segFract);\n  \t\t\t\tprecModel.makePrecise(p);\n  \t\t\t\tcoordList.add(p, false);\n  \t\t\t}\n  \t\t}\n  \t}\n  \tcoordList.add(pts[pts.length - 1], false);\n  \treturn coordList.toCoordinateArray();\n  };\n  Densifier.densify = function (geom, distanceTolerance) {\n  \tvar densifier = new Densifier(geom);\n  \tdensifier.setDistanceTolerance(distanceTolerance);\n  \treturn densifier.getResultGeometry();\n  };\n  function DensifyTransformer() {\n  \tGeometryTransformer.apply(this);\n  \tthis.distanceTolerance = null;\n  \tvar distanceTolerance = arguments[0];\n  \tthis.distanceTolerance = distanceTolerance;\n  }\n  inherits$1(DensifyTransformer, GeometryTransformer);\n  extend(DensifyTransformer.prototype, {\n  \ttransformMultiPolygon: function transformMultiPolygon(geom, parent) {\n  \t\tvar roughGeom = GeometryTransformer.prototype.transformMultiPolygon.call(this, geom, parent);\n  \t\treturn this.createValidArea(roughGeom);\n  \t},\n  \ttransformPolygon: function transformPolygon(geom, parent) {\n  \t\tvar roughGeom = GeometryTransformer.prototype.transformPolygon.call(this, geom, parent);\n  \t\tif (parent instanceof MultiPolygon) {\n  \t\t\treturn roughGeom;\n  \t\t}\n  \t\treturn this.createValidArea(roughGeom);\n  \t},\n  \ttransformCoordinates: function transformCoordinates(coords, parent) {\n  \t\tvar inputPts = coords.toCoordinateArray();\n  \t\tvar newPts = Densifier.densifyPoints(inputPts, this.distanceTolerance, parent.getPrecisionModel());\n  \t\tif (parent instanceof LineString && newPts.length === 1) {\n  \t\t\tnewPts = new Array(0).fill(null);\n  \t\t}\n  \t\treturn this._factory.getCoordinateSequenceFactory().create(newPts);\n  \t},\n  \tcreateValidArea: function createValidArea(roughAreaGeom) {\n  \t\treturn roughAreaGeom.buffer(0.0);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn DensifyTransformer;\n  \t}\n  });\n  Densifier.DensifyTransformer = DensifyTransformer;\n\n  function HalfEdge() {\n  \tthis._orig = null;\n  \tthis._sym = null;\n  \tthis._next = null;\n  \tvar orig = arguments[0];\n  \tthis._orig = orig;\n  }\n  extend(HalfEdge.prototype, {\n  \tfind: function find(dest) {\n  \t\tvar oNext = this;\n  \t\tdo {\n  \t\t\tif (oNext === null) return null;\n  \t\t\tif (oNext.dest().equals2D(dest)) return oNext;\n  \t\t\toNext = oNext.oNext();\n  \t\t} while (oNext !== this);\n  \t\treturn null;\n  \t},\n  \tdest: function dest() {\n  \t\treturn this._sym._orig;\n  \t},\n  \toNext: function oNext() {\n  \t\treturn this._sym._next;\n  \t},\n  \tinsert: function insert(e) {\n  \t\tif (this.oNext() === this) {\n  \t\t\tthis.insertAfter(e);\n  \t\t\treturn null;\n  \t\t}\n  \t\tvar ecmp = this.compareTo(e);\n  \t\tvar ePrev = this;\n  \t\tdo {\n  \t\t\tvar oNext = ePrev.oNext();\n  \t\t\tvar cmp = oNext.compareTo(e);\n  \t\t\tif (cmp !== ecmp || oNext === this) {\n  \t\t\t\tePrev.insertAfter(e);\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t\tePrev = oNext;\n  \t\t} while (ePrev !== this);\n  \t\tAssert.shouldNeverReachHere();\n  \t},\n  \tinsertAfter: function insertAfter(e) {\n  \t\tAssert.equals(this._orig, e.orig());\n  \t\tvar save = this.oNext();\n  \t\tthis._sym.setNext(e);\n  \t\te.sym().setNext(save);\n  \t},\n  \tdegree: function degree() {\n  \t\tvar degree = 0;\n  \t\tvar e = this;\n  \t\tdo {\n  \t\t\tdegree++;\n  \t\t\te = e.oNext();\n  \t\t} while (e !== this);\n  \t\treturn degree;\n  \t},\n  \tequals: function equals() {\n  \t\tif (arguments.length === 2) {\n  \t\t\tvar p0 = arguments[0],\n  \t\t\t    p1 = arguments[1];\n  \t\t\treturn this._orig.equals2D(p0) && this._sym._orig.equals(p1);\n  \t\t}\n  \t},\n  \tdeltaY: function deltaY() {\n  \t\treturn this._sym._orig.y - this._orig.y;\n  \t},\n  \tsym: function sym() {\n  \t\treturn this._sym;\n  \t},\n  \tprev: function prev() {\n  \t\treturn this._sym.next()._sym;\n  \t},\n  \tcompareAngularDirection: function compareAngularDirection(e) {\n  \t\tvar dx = this.deltaX();\n  \t\tvar dy = this.deltaY();\n  \t\tvar dx2 = e.deltaX();\n  \t\tvar dy2 = e.deltaY();\n  \t\tif (dx === dx2 && dy === dy2) return 0;\n  \t\tvar quadrant = Quadrant.quadrant(dx, dy);\n  \t\tvar quadrant2 = Quadrant.quadrant(dx2, dy2);\n  \t\tif (quadrant > quadrant2) return 1;\n  \t\tif (quadrant < quadrant2) return -1;\n  \t\treturn CGAlgorithms.computeOrientation(e._orig, e.dest(), this.dest());\n  \t},\n  \tprevNode: function prevNode() {\n  \t\tvar e = this;\n  \t\twhile (e.degree() === 2) {\n  \t\t\te = e.prev();\n  \t\t\tif (e === this) return null;\n  \t\t}\n  \t\treturn e;\n  \t},\n  \tcompareTo: function compareTo(obj) {\n  \t\tvar e = obj;\n  \t\tvar comp = this.compareAngularDirection(e);\n  \t\treturn comp;\n  \t},\n  \tnext: function next() {\n  \t\treturn this._next;\n  \t},\n  \tsetSym: function setSym(e) {\n  \t\tthis._sym = e;\n  \t},\n  \torig: function orig() {\n  \t\treturn this._orig;\n  \t},\n  \ttoString: function toString() {\n  \t\treturn \"HE(\" + this._orig.x + \" \" + this._orig.y + \", \" + this._sym._orig.x + \" \" + this._sym._orig.y + \")\";\n  \t},\n  \tsetNext: function setNext(e) {\n  \t\tthis._next = e;\n  \t},\n  \tinit: function init(e) {\n  \t\tthis.setSym(e);\n  \t\te.setSym(this);\n  \t\tthis.setNext(e);\n  \t\te.setNext(this);\n  \t},\n  \tdeltaX: function deltaX() {\n  \t\treturn this._sym._orig.x - this._orig.x;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn HalfEdge;\n  \t}\n  });\n  HalfEdge.init = function (e0, e1) {\n  \tif (e0._sym !== null || e1._sym !== null || e0._next !== null || e1._next !== null) throw new IllegalStateException(\"Edges are already initialized\");\n  \te0.init(e1);\n  \treturn e0;\n  };\n  HalfEdge.create = function (p0, p1) {\n  \tvar e0 = new HalfEdge(p0);\n  \tvar e1 = new HalfEdge(p1);\n  \te0.init(e1);\n  \treturn e0;\n  };\n\n  function MarkHalfEdge() {\n  \tthis._isMarked = false;\n  \tvar orig = arguments[0];\n  \tHalfEdge.call(this, orig);\n  }\n  inherits$1(MarkHalfEdge, HalfEdge);\n  extend(MarkHalfEdge.prototype, {\n  \tmark: function mark() {\n  \t\tthis._isMarked = true;\n  \t},\n  \tsetMark: function setMark(isMarked) {\n  \t\tthis._isMarked = isMarked;\n  \t},\n  \tisMarked: function isMarked() {\n  \t\treturn this._isMarked;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MarkHalfEdge;\n  \t}\n  });\n  MarkHalfEdge.setMarkBoth = function (e, isMarked) {\n  \te.setMark(isMarked);\n  \te.sym().setMark(isMarked);\n  };\n  MarkHalfEdge.isMarked = function (e) {\n  \treturn e.isMarked();\n  };\n  MarkHalfEdge.setMark = function (e, isMarked) {\n  \te.setMark(isMarked);\n  };\n  MarkHalfEdge.markBoth = function (e) {\n  \te.mark();\n  \te.sym().mark();\n  };\n  MarkHalfEdge.mark = function (e) {\n  \te.mark();\n  };\n\n  function EdgeGraph() {\n  \tthis._vertexMap = new HashMap();\n  }\n  extend(EdgeGraph.prototype, {\n  \tinsert: function insert(orig, dest, eAdj) {\n  \t\tvar e = this.create(orig, dest);\n  \t\tif (eAdj !== null) {\n  \t\t\teAdj.insert(e);\n  \t\t} else {\n  \t\t\tthis._vertexMap.put(orig, e);\n  \t\t}\n  \t\tvar eAdjDest = this._vertexMap.get(dest);\n  \t\tif (eAdjDest !== null) {\n  \t\t\teAdjDest.insert(e.sym());\n  \t\t} else {\n  \t\t\tthis._vertexMap.put(dest, e.sym());\n  \t\t}\n  \t\treturn e;\n  \t},\n  \tcreate: function create(p0, p1) {\n  \t\tvar e0 = this.createEdge(p0);\n  \t\tvar e1 = this.createEdge(p1);\n  \t\tHalfEdge.init(e0, e1);\n  \t\treturn e0;\n  \t},\n  \tcreateEdge: function createEdge(orig) {\n  \t\treturn new HalfEdge(orig);\n  \t},\n  \taddEdge: function addEdge(orig, dest) {\n  \t\tif (!EdgeGraph.isValidEdge(orig, dest)) return null;\n  \t\tvar eAdj = this._vertexMap.get(orig);\n  \t\tvar eSame = null;\n  \t\tif (eAdj !== null) {\n  \t\t\teSame = eAdj.find(dest);\n  \t\t}\n  \t\tif (eSame !== null) {\n  \t\t\treturn eSame;\n  \t\t}\n  \t\tvar e = this.insert(orig, dest, eAdj);\n  \t\treturn e;\n  \t},\n  \tgetVertexEdges: function getVertexEdges() {\n  \t\treturn this._vertexMap.values();\n  \t},\n  \tfindEdge: function findEdge(orig, dest) {\n  \t\tvar e = this._vertexMap.get(orig);\n  \t\tif (e === null) return null;\n  \t\treturn e.find(dest);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn EdgeGraph;\n  \t}\n  });\n  EdgeGraph.isValidEdge = function (orig, dest) {\n  \tvar cmp = dest.compareTo(orig);\n  \treturn cmp !== 0;\n  };\n\n  function DissolveHalfEdge() {\n  \tthis._isStart = false;\n  \tvar orig = arguments[0];\n  \tMarkHalfEdge.call(this, orig);\n  }\n  inherits$1(DissolveHalfEdge, MarkHalfEdge);\n  extend(DissolveHalfEdge.prototype, {\n  \tsetStart: function setStart() {\n  \t\tthis._isStart = true;\n  \t},\n  \tisStart: function isStart() {\n  \t\treturn this._isStart;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn DissolveHalfEdge;\n  \t}\n  });\n\n  function DissolveEdgeGraph() {\n  \tEdgeGraph.apply(this);\n  }\n  inherits$1(DissolveEdgeGraph, EdgeGraph);\n  extend(DissolveEdgeGraph.prototype, {\n  \tcreateEdge: function createEdge(p0) {\n  \t\treturn new DissolveHalfEdge(p0);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn DissolveEdgeGraph;\n  \t}\n  });\n\n  function LineDissolver() {\n  \tthis._result = null;\n  \tthis._factory = null;\n  \tthis._graph = null;\n  \tthis._lines = new ArrayList();\n  \tthis._nodeEdgeStack = new Stack$1();\n  \tthis._ringStartEdge = null;\n  \tthis._graph = new DissolveEdgeGraph();\n  }\n  extend(LineDissolver.prototype, {\n  \taddLine: function addLine(line) {\n  \t\tthis._lines.add(this._factory.createLineString(line.toCoordinateArray()));\n  \t},\n  \tupdateRingStartEdge: function updateRingStartEdge(e) {\n  \t\tif (!e.isStart()) {\n  \t\t\te = e.sym();\n  \t\t\tif (!e.isStart()) return null;\n  \t\t}\n  \t\tif (this._ringStartEdge === null) {\n  \t\t\tthis._ringStartEdge = e;\n  \t\t\treturn null;\n  \t\t}\n  \t\tif (e.orig().compareTo(this._ringStartEdge.orig()) < 0) {\n  \t\t\tthis._ringStartEdge = e;\n  \t\t}\n  \t},\n  \tgetResult: function getResult() {\n  \t\tif (this._result === null) this.computeResult();\n  \t\treturn this._result;\n  \t},\n  \tprocess: function process(e) {\n  \t\tvar eNode = e.prevNode();\n  \t\tif (eNode === null) eNode = e;\n  \t\tthis.stackEdges(eNode);\n  \t\tthis.buildLines();\n  \t},\n  \tbuildRing: function buildRing(eStartRing) {\n  \t\tvar line = new CoordinateList();\n  \t\tvar e = eStartRing;\n  \t\tline.add(e.orig().copy(), false);\n  \t\twhile (e.sym().degree() === 2) {\n  \t\t\tvar eNext = e.next();\n  \t\t\tif (eNext === eStartRing) break;\n  \t\t\tline.add(eNext.orig().copy(), false);\n  \t\t\te = eNext;\n  \t\t}\n  \t\tline.add(e.dest().copy(), false);\n  \t\tthis.addLine(line);\n  \t},\n  \tbuildLine: function buildLine(eStart) {\n  \t\tvar line = new CoordinateList();\n  \t\tvar e = eStart;\n  \t\tthis._ringStartEdge = null;\n  \t\tMarkHalfEdge.markBoth(e);\n  \t\tline.add(e.orig().copy(), false);\n  \t\twhile (e.sym().degree() === 2) {\n  \t\t\tthis.updateRingStartEdge(e);\n  \t\t\tvar eNext = e.next();\n  \t\t\tif (eNext === eStart) {\n  \t\t\t\tthis.buildRing(this._ringStartEdge);\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t\tline.add(eNext.orig().copy(), false);\n  \t\t\te = eNext;\n  \t\t\tMarkHalfEdge.markBoth(e);\n  \t\t}\n  \t\tline.add(e.dest().copy(), false);\n  \t\tthis.stackEdges(e.sym());\n  \t\tthis.addLine(line);\n  \t},\n  \tstackEdges: function stackEdges(node) {\n  \t\tvar e = node;\n  \t\tdo {\n  \t\t\tif (!MarkHalfEdge.isMarked(e)) this._nodeEdgeStack.add(e);\n  \t\t\te = e.oNext();\n  \t\t} while (e !== node);\n  \t},\n  \tcomputeResult: function computeResult() {\n  \t\tvar edges = this._graph.getVertexEdges();\n  \t\tfor (var i = edges.iterator(); i.hasNext();) {\n  \t\t\tvar e = i.next();\n  \t\t\tif (MarkHalfEdge.isMarked(e)) continue;\n  \t\t\tthis.process(e);\n  \t\t}\n  \t\tthis._result = this._factory.buildGeometry(this._lines);\n  \t},\n  \tbuildLines: function buildLines() {\n  \t\twhile (!this._nodeEdgeStack.empty()) {\n  \t\t\tvar e = this._nodeEdgeStack.pop();\n  \t\t\tif (MarkHalfEdge.isMarked(e)) continue;\n  \t\t\tthis.buildLine(e);\n  \t\t}\n  \t},\n  \tadd: function add() {\n  \t\tif (arguments[0] instanceof Geometry) {\n  \t\t\tvar geometry = arguments[0];\n  \t\t\tgeometry.apply({\n  \t\t\t\tinterfaces_: function interfaces_() {\n  \t\t\t\t\treturn [GeometryComponentFilter];\n  \t\t\t\t},\n  \t\t\t\tfilter: function filter(component) {\n  \t\t\t\t\tif (component instanceof LineString) {\n  \t\t\t\t\t\tthis.add(component);\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t});\n  \t\t} else if (hasInterface(arguments[0], Collection)) {\n  \t\t\tvar geometries = arguments[0];\n  \t\t\tfor (var i = geometries.iterator(); i.hasNext();) {\n  \t\t\t\tvar geometry = i.next();\n  \t\t\t\tthis.add(geometry);\n  \t\t\t}\n  \t\t} else if (arguments[0] instanceof LineString) {\n  \t\t\tvar lineString = arguments[0];\n  \t\t\tif (this._factory === null) {\n  \t\t\t\tthis._factory = lineString.getFactory();\n  \t\t\t}\n  \t\t\tvar seq = lineString.getCoordinateSequence();\n  \t\t\tvar doneStart = false;\n  \t\t\tfor (var i = 1; i < seq.size(); i++) {\n  \t\t\t\tvar e = this._graph.addEdge(seq.getCoordinate(i - 1), seq.getCoordinate(i));\n  \t\t\t\tif (e === null) continue;\n  \t\t\t\tif (!doneStart) {\n  \t\t\t\t\te.setStart();\n  \t\t\t\t\tdoneStart = true;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LineDissolver;\n  \t}\n  });\n  LineDissolver.dissolve = function (g) {\n  \tvar d = new LineDissolver();\n  \td.add(g);\n  \treturn d.getResult();\n  };\n\n  function NodeBase$1() {\n  \tthis._items = new ArrayList();\n  \tthis._subnode = new Array(4).fill(null);\n  }\n  extend(NodeBase$1.prototype, {\n  \thasChildren: function hasChildren() {\n  \t\tfor (var i = 0; i < 4; i++) {\n  \t\t\tif (this._subnode[i] !== null) return true;\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tisPrunable: function isPrunable() {\n  \t\treturn !(this.hasChildren() || this.hasItems());\n  \t},\n  \taddAllItems: function addAllItems(resultItems) {\n  \t\tresultItems.addAll(this._items);\n  \t\tfor (var i = 0; i < 4; i++) {\n  \t\t\tif (this._subnode[i] !== null) {\n  \t\t\t\tthis._subnode[i].addAllItems(resultItems);\n  \t\t\t}\n  \t\t}\n  \t\treturn resultItems;\n  \t},\n  \tgetNodeCount: function getNodeCount() {\n  \t\tvar subSize = 0;\n  \t\tfor (var i = 0; i < 4; i++) {\n  \t\t\tif (this._subnode[i] !== null) {\n  \t\t\t\tsubSize += this._subnode[i].size();\n  \t\t\t}\n  \t\t}\n  \t\treturn subSize + 1;\n  \t},\n  \tsize: function size() {\n  \t\tvar subSize = 0;\n  \t\tfor (var i = 0; i < 4; i++) {\n  \t\t\tif (this._subnode[i] !== null) {\n  \t\t\t\tsubSize += this._subnode[i].size();\n  \t\t\t}\n  \t\t}\n  \t\treturn subSize + this._items.size();\n  \t},\n  \taddAllItemsFromOverlapping: function addAllItemsFromOverlapping(searchEnv, resultItems) {\n  \t\tif (!this.isSearchMatch(searchEnv)) return null;\n  \t\tresultItems.addAll(this._items);\n  \t\tfor (var i = 0; i < 4; i++) {\n  \t\t\tif (this._subnode[i] !== null) {\n  \t\t\t\tthis._subnode[i].addAllItemsFromOverlapping(searchEnv, resultItems);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tvisitItems: function visitItems(searchEnv, visitor) {\n  \t\tfor (var i = this._items.iterator(); i.hasNext();) {\n  \t\t\tvisitor.visitItem(i.next());\n  \t\t}\n  \t},\n  \thasItems: function hasItems() {\n  \t\treturn !this._items.isEmpty();\n  \t},\n  \tremove: function remove(itemEnv, item) {\n  \t\tif (!this.isSearchMatch(itemEnv)) return false;\n  \t\tvar found = false;\n  \t\tfor (var i = 0; i < 4; i++) {\n  \t\t\tif (this._subnode[i] !== null) {\n  \t\t\t\tfound = this._subnode[i].remove(itemEnv, item);\n  \t\t\t\tif (found) {\n  \t\t\t\t\tif (this._subnode[i].isPrunable()) this._subnode[i] = null;\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\tif (found) return found;\n  \t\tfound = this._items.remove(item);\n  \t\treturn found;\n  \t},\n  \tvisit: function visit(searchEnv, visitor) {\n  \t\tif (!this.isSearchMatch(searchEnv)) return null;\n  \t\tthis.visitItems(searchEnv, visitor);\n  \t\tfor (var i = 0; i < 4; i++) {\n  \t\t\tif (this._subnode[i] !== null) {\n  \t\t\t\tthis._subnode[i].visit(searchEnv, visitor);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetItems: function getItems() {\n  \t\treturn this._items;\n  \t},\n  \tdepth: function depth() {\n  \t\tvar maxSubDepth = 0;\n  \t\tfor (var i = 0; i < 4; i++) {\n  \t\t\tif (this._subnode[i] !== null) {\n  \t\t\t\tvar sqd = this._subnode[i].depth();\n  \t\t\t\tif (sqd > maxSubDepth) maxSubDepth = sqd;\n  \t\t\t}\n  \t\t}\n  \t\treturn maxSubDepth + 1;\n  \t},\n  \tisEmpty: function isEmpty() {\n  \t\tvar isEmpty = true;\n  \t\tif (!this._items.isEmpty()) isEmpty = false;\n  \t\tfor (var i = 0; i < 4; i++) {\n  \t\t\tif (this._subnode[i] !== null) {\n  \t\t\t\tif (!this._subnode[i].isEmpty()) isEmpty = false;\n  \t\t\t}\n  \t\t}\n  \t\treturn isEmpty;\n  \t},\n  \tadd: function add(item) {\n  \t\tthis._items.add(item);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Serializable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn NodeBase$1;\n  \t}\n  });\n  NodeBase$1.getSubnodeIndex = function (env, centrex, centrey) {\n  \tvar subnodeIndex = -1;\n  \tif (env.getMinX() >= centrex) {\n  \t\tif (env.getMinY() >= centrey) subnodeIndex = 3;\n  \t\tif (env.getMaxY() <= centrey) subnodeIndex = 1;\n  \t}\n  \tif (env.getMaxX() <= centrex) {\n  \t\tif (env.getMinY() >= centrey) subnodeIndex = 2;\n  \t\tif (env.getMaxY() <= centrey) subnodeIndex = 0;\n  \t}\n  \treturn subnodeIndex;\n  };\n\n  function Key$1() {\n  \tthis._pt = new Coordinate();\n  \tthis._level = 0;\n  \tthis._env = null;\n  \tvar itemEnv = arguments[0];\n  \tthis.computeKey(itemEnv);\n  }\n  extend(Key$1.prototype, {\n  \tgetLevel: function getLevel() {\n  \t\treturn this._level;\n  \t},\n  \tcomputeKey: function computeKey() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar itemEnv = arguments[0];\n  \t\t\tthis._level = Key$1.computeQuadLevel(itemEnv);\n  \t\t\tthis._env = new Envelope();\n  \t\t\tthis.computeKey(this._level, itemEnv);\n  \t\t\twhile (!this._env.contains(itemEnv)) {\n  \t\t\t\tthis._level += 1;\n  \t\t\t\tthis.computeKey(this._level, itemEnv);\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar level = arguments[0],\n  \t\t\t    itemEnv = arguments[1];\n  \t\t\tvar quadSize = DoubleBits.powerOf2(level);\n  \t\t\tthis._pt.x = Math.floor(itemEnv.getMinX() / quadSize) * quadSize;\n  \t\t\tthis._pt.y = Math.floor(itemEnv.getMinY() / quadSize) * quadSize;\n  \t\t\tthis._env.init(this._pt.x, this._pt.x + quadSize, this._pt.y, this._pt.y + quadSize);\n  \t\t}\n  \t},\n  \tgetEnvelope: function getEnvelope() {\n  \t\treturn this._env;\n  \t},\n  \tgetCentre: function getCentre() {\n  \t\treturn new Coordinate((this._env.getMinX() + this._env.getMaxX()) / 2, (this._env.getMinY() + this._env.getMaxY()) / 2);\n  \t},\n  \tgetPoint: function getPoint() {\n  \t\treturn this._pt;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Key$1;\n  \t}\n  });\n  Key$1.computeQuadLevel = function (env) {\n  \tvar dx = env.getWidth();\n  \tvar dy = env.getHeight();\n  \tvar dMax = dx > dy ? dx : dy;\n  \tvar level = DoubleBits.exponent(dMax) + 1;\n  \treturn level;\n  };\n\n  function Node$2() {\n  \tNodeBase$1.apply(this);\n  \tthis._env = null;\n  \tthis._centrex = null;\n  \tthis._centrey = null;\n  \tthis._level = null;\n  \tvar env = arguments[0],\n  \t    level = arguments[1];\n  \tthis._env = env;\n  \tthis._level = level;\n  \tthis._centrex = (env.getMinX() + env.getMaxX()) / 2;\n  \tthis._centrey = (env.getMinY() + env.getMaxY()) / 2;\n  }\n  inherits$1(Node$2, NodeBase$1);\n  extend(Node$2.prototype, {\n  \tfind: function find(searchEnv) {\n  \t\tvar subnodeIndex = NodeBase$1.getSubnodeIndex(searchEnv, this._centrex, this._centrey);\n  \t\tif (subnodeIndex === -1) return this;\n  \t\tif (this._subnode[subnodeIndex] !== null) {\n  \t\t\tvar node = this._subnode[subnodeIndex];\n  \t\t\treturn node.find(searchEnv);\n  \t\t}\n  \t\treturn this;\n  \t},\n  \tisSearchMatch: function isSearchMatch(searchEnv) {\n  \t\treturn this._env.intersects(searchEnv);\n  \t},\n  \tgetSubnode: function getSubnode(index) {\n  \t\tif (this._subnode[index] === null) {\n  \t\t\tthis._subnode[index] = this.createSubnode(index);\n  \t\t}\n  \t\treturn this._subnode[index];\n  \t},\n  \tgetEnvelope: function getEnvelope() {\n  \t\treturn this._env;\n  \t},\n  \tgetNode: function getNode(searchEnv) {\n  \t\tvar subnodeIndex = NodeBase$1.getSubnodeIndex(searchEnv, this._centrex, this._centrey);\n  \t\tif (subnodeIndex !== -1) {\n  \t\t\tvar node = this.getSubnode(subnodeIndex);\n  \t\t\treturn node.getNode(searchEnv);\n  \t\t} else {\n  \t\t\treturn this;\n  \t\t}\n  \t},\n  \tcreateSubnode: function createSubnode(index) {\n  \t\tvar minx = 0.0;\n  \t\tvar maxx = 0.0;\n  \t\tvar miny = 0.0;\n  \t\tvar maxy = 0.0;\n  \t\tswitch (index) {\n  \t\t\tcase 0:\n  \t\t\t\tminx = this._env.getMinX();\n  \t\t\t\tmaxx = this._centrex;\n  \t\t\t\tminy = this._env.getMinY();\n  \t\t\t\tmaxy = this._centrey;\n  \t\t\t\tbreak;\n  \t\t\tcase 1:\n  \t\t\t\tminx = this._centrex;\n  \t\t\t\tmaxx = this._env.getMaxX();\n  \t\t\t\tminy = this._env.getMinY();\n  \t\t\t\tmaxy = this._centrey;\n  \t\t\t\tbreak;\n  \t\t\tcase 2:\n  \t\t\t\tminx = this._env.getMinX();\n  \t\t\t\tmaxx = this._centrex;\n  \t\t\t\tminy = this._centrey;\n  \t\t\t\tmaxy = this._env.getMaxY();\n  \t\t\t\tbreak;\n  \t\t\tcase 3:\n  \t\t\t\tminx = this._centrex;\n  \t\t\t\tmaxx = this._env.getMaxX();\n  \t\t\t\tminy = this._centrey;\n  \t\t\t\tmaxy = this._env.getMaxY();\n  \t\t\t\tbreak;\n  \t\t}\n  \t\tvar sqEnv = new Envelope(minx, maxx, miny, maxy);\n  \t\tvar node = new Node$2(sqEnv, this._level - 1);\n  \t\treturn node;\n  \t},\n  \tinsertNode: function insertNode(node) {\n  \t\tAssert.isTrue(this._env === null || this._env.contains(node._env));\n  \t\tvar index = NodeBase$1.getSubnodeIndex(node._env, this._centrex, this._centrey);\n  \t\tif (node._level === this._level - 1) {\n  \t\t\tthis._subnode[index] = node;\n  \t\t} else {\n  \t\t\tvar childNode = this.createSubnode(index);\n  \t\t\tchildNode.insertNode(node);\n  \t\t\tthis._subnode[index] = childNode;\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Node$2;\n  \t}\n  });\n  Node$2.createNode = function (env) {\n  \tvar key = new Key$1(env);\n  \tvar node = new Node$2(key.getEnvelope(), key.getLevel());\n  \treturn node;\n  };\n  Node$2.createExpanded = function (node, addEnv) {\n  \tvar expandEnv = new Envelope(addEnv);\n  \tif (node !== null) expandEnv.expandToInclude(node._env);\n  \tvar largerNode = Node$2.createNode(expandEnv);\n  \tif (node !== null) largerNode.insertNode(node);\n  \treturn largerNode;\n  };\n\n  function Root$1() {\n  \tNodeBase$1.apply(this);\n  }\n  inherits$1(Root$1, NodeBase$1);\n  extend(Root$1.prototype, {\n  \tinsert: function insert(itemEnv, item) {\n  \t\tvar index = NodeBase$1.getSubnodeIndex(itemEnv, Root$1.origin.x, Root$1.origin.y);\n  \t\tif (index === -1) {\n  \t\t\tthis.add(item);\n  \t\t\treturn null;\n  \t\t}\n  \t\tvar node = this._subnode[index];\n  \t\tif (node === null || !node.getEnvelope().contains(itemEnv)) {\n  \t\t\tvar largerNode = Node$2.createExpanded(node, itemEnv);\n  \t\t\tthis._subnode[index] = largerNode;\n  \t\t}\n  \t\tthis.insertContained(this._subnode[index], itemEnv, item);\n  \t},\n  \tisSearchMatch: function isSearchMatch(searchEnv) {\n  \t\treturn true;\n  \t},\n  \tinsertContained: function insertContained(tree, itemEnv, item) {\n  \t\tAssert.isTrue(tree.getEnvelope().contains(itemEnv));\n  \t\tvar isZeroX = IntervalSize.isZeroWidth(itemEnv.getMinX(), itemEnv.getMaxX());\n  \t\tvar isZeroY = IntervalSize.isZeroWidth(itemEnv.getMinY(), itemEnv.getMaxY());\n  \t\tvar node = null;\n  \t\tif (isZeroX || isZeroY) node = tree.find(itemEnv);else node = tree.getNode(itemEnv);\n  \t\tnode.add(item);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Root$1;\n  \t}\n  });\n  Root$1.origin = new Coordinate(0.0, 0.0);\n\n  function Quadtree() {\n  \tthis._root = null;\n  \tthis._minExtent = 1.0;\n  \tthis._root = new Root$1();\n  }\n  extend(Quadtree.prototype, {\n  \tsize: function size() {\n  \t\tif (this._root !== null) return this._root.size();\n  \t\treturn 0;\n  \t},\n  \tinsert: function insert(itemEnv, item) {\n  \t\tthis.collectStats(itemEnv);\n  \t\tvar insertEnv = Quadtree.ensureExtent(itemEnv, this._minExtent);\n  \t\tthis._root.insert(insertEnv, item);\n  \t},\n  \tquery: function query() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar searchEnv = arguments[0];\n  \t\t\tvar visitor = new ArrayListVisitor();\n  \t\t\tthis.query(searchEnv, visitor);\n  \t\t\treturn visitor.getItems();\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar searchEnv = arguments[0],\n  \t\t\t    visitor = arguments[1];\n  \t\t\tthis._root.visit(searchEnv, visitor);\n  \t\t}\n  \t},\n  \tqueryAll: function queryAll() {\n  \t\tvar foundItems = new ArrayList();\n  \t\tthis._root.addAllItems(foundItems);\n  \t\treturn foundItems;\n  \t},\n  \tremove: function remove(itemEnv, item) {\n  \t\tvar posEnv = Quadtree.ensureExtent(itemEnv, this._minExtent);\n  \t\treturn this._root.remove(posEnv, item);\n  \t},\n  \tcollectStats: function collectStats(itemEnv) {\n  \t\tvar delX = itemEnv.getWidth();\n  \t\tif (delX < this._minExtent && delX > 0.0) this._minExtent = delX;\n  \t\tvar delY = itemEnv.getHeight();\n  \t\tif (delY < this._minExtent && delY > 0.0) this._minExtent = delY;\n  \t},\n  \tdepth: function depth() {\n  \t\tif (this._root !== null) return this._root.depth();\n  \t\treturn 0;\n  \t},\n  \tisEmpty: function isEmpty() {\n  \t\tif (this._root === null) return true;\n  \t\treturn false;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [SpatialIndex, Serializable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Quadtree;\n  \t}\n  });\n  Quadtree.ensureExtent = function (itemEnv, minExtent) {\n  \tvar minx = itemEnv.getMinX();\n  \tvar maxx = itemEnv.getMaxX();\n  \tvar miny = itemEnv.getMinY();\n  \tvar maxy = itemEnv.getMaxY();\n  \tif (minx !== maxx && miny !== maxy) return itemEnv;\n  \tif (minx === maxx) {\n  \t\tminx = minx - minExtent / 2.0;\n  \t\tmaxx = minx + minExtent / 2.0;\n  \t}\n  \tif (miny === maxy) {\n  \t\tminy = miny - minExtent / 2.0;\n  \t\tmaxy = miny + minExtent / 2.0;\n  \t}\n  \treturn new Envelope(minx, maxx, miny, maxy);\n  };\n  Quadtree.serialVersionUID = -7461163625812743604;\n\n  var geometryTypes = ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon'];\n  function GeoJSONParser(geometryFactory) {\n    this.geometryFactory = geometryFactory || new GeometryFactory();\n  }\n  extend(GeoJSONParser.prototype, {\n    read: function read(json) {\n      var obj;\n      if (typeof json === 'string') {\n        obj = JSON.parse(json);\n      } else {\n        obj = json;\n      }\n      var type = obj.type;\n      if (!parse$1[type]) {\n        throw new Error('Unknown GeoJSON type: ' + obj.type);\n      }\n      if (geometryTypes.indexOf(type) !== -1) {\n        return parse$1[type].apply(this, [obj.coordinates]);\n      } else if (type === 'GeometryCollection') {\n        return parse$1[type].apply(this, [obj.geometries]);\n      }\n      return parse$1[type].apply(this, [obj]);\n    },\n    write: function write(geometry) {\n      var type = geometry.getGeometryType();\n      if (!extract$2[type]) {\n        throw new Error('Geometry is not supported');\n      }\n      return extract$2[type].apply(this, [geometry]);\n    }\n  });\n  var parse$1 = {\n    Feature: function Feature(obj) {\n      var feature = {};\n      for (var key in obj) {\n        feature[key] = obj[key];\n      }\n      if (obj.geometry) {\n        var type = obj.geometry.type;\n        if (!parse$1[type]) {\n          throw new Error('Unknown GeoJSON type: ' + obj.type);\n        }\n        feature.geometry = this.read(obj.geometry);\n      }\n      if (obj.bbox) {\n        feature.bbox = parse$1.bbox.apply(this, [obj.bbox]);\n      }\n      return feature;\n    },\n    FeatureCollection: function FeatureCollection(obj) {\n      var featureCollection = {};\n      if (obj.features) {\n        featureCollection.features = [];\n        for (var i = 0; i < obj.features.length; ++i) {\n          featureCollection.features.push(this.read(obj.features[i]));\n        }\n      }\n      if (obj.bbox) {\n        featureCollection.bbox = this.parse.bbox.apply(this, [obj.bbox]);\n      }\n      return featureCollection;\n    },\n    coordinates: function coordinates(array) {\n      var coordinates = [];\n      for (var i = 0; i < array.length; ++i) {\n        var sub = array[i];\n        coordinates.push(new Coordinate(sub[0], sub[1]));\n      }\n      return coordinates;\n    },\n    bbox: function bbox(array) {\n      return this.geometryFactory.createLinearRing([new Coordinate(array[0], array[1]), new Coordinate(array[2], array[1]), new Coordinate(array[2], array[3]), new Coordinate(array[0], array[3]), new Coordinate(array[0], array[1])]);\n    },\n    Point: function Point(array) {\n      var coordinate = new Coordinate(array[0], array[1]);\n      return this.geometryFactory.createPoint(coordinate);\n    },\n    MultiPoint: function MultiPoint(array) {\n      var points = [];\n      for (var i = 0; i < array.length; ++i) {\n        points.push(parse$1.Point.apply(this, [array[i]]));\n      }\n      return this.geometryFactory.createMultiPoint(points);\n    },\n    LineString: function LineString(array) {\n      var coordinates = parse$1.coordinates.apply(this, [array]);\n      return this.geometryFactory.createLineString(coordinates);\n    },\n    MultiLineString: function MultiLineString(array) {\n      var lineStrings = [];\n      for (var i = 0; i < array.length; ++i) {\n        lineStrings.push(parse$1.LineString.apply(this, [array[i]]));\n      }\n      return this.geometryFactory.createMultiLineString(lineStrings);\n    },\n    Polygon: function Polygon(array) {\n      var shellCoordinates = parse$1.coordinates.apply(this, [array[0]]);\n      var shell = this.geometryFactory.createLinearRing(shellCoordinates);\n      var holes = [];\n      for (var i = 1; i < array.length; ++i) {\n        var hole = array[i];\n        var coordinates = parse$1.coordinates.apply(this, [hole]);\n        var linearRing = this.geometryFactory.createLinearRing(coordinates);\n        holes.push(linearRing);\n      }\n      return this.geometryFactory.createPolygon(shell, holes);\n    },\n    MultiPolygon: function MultiPolygon(array) {\n      var polygons = [];\n      for (var i = 0; i < array.length; ++i) {\n        var polygon = array[i];\n        polygons.push(parse$1.Polygon.apply(this, [polygon]));\n      }\n      return this.geometryFactory.createMultiPolygon(polygons);\n    },\n    GeometryCollection: function GeometryCollection(array) {\n      var geometries = [];\n      for (var i = 0; i < array.length; ++i) {\n        var geometry = array[i];\n        geometries.push(this.read(geometry));\n      }\n      return this.geometryFactory.createGeometryCollection(geometries);\n    }\n  };\n  var extract$2 = {\n    coordinate: function coordinate(_coordinate) {\n      return [_coordinate.x, _coordinate.y];\n    },\n    Point: function Point(point) {\n      var array = extract$2.coordinate.apply(this, [point.getCoordinate()]);\n      return {\n        type: 'Point',\n        coordinates: array\n      };\n    },\n    MultiPoint: function MultiPoint(multipoint) {\n      var array = [];\n      for (var i = 0; i < multipoint._geometries.length; ++i) {\n        var point = multipoint._geometries[i];\n        var geoJson = extract$2.Point.apply(this, [point]);\n        array.push(geoJson.coordinates);\n      }\n      return {\n        type: 'MultiPoint',\n        coordinates: array\n      };\n    },\n    LineString: function LineString(linestring) {\n      var array = [];\n      var coordinates = linestring.getCoordinates();\n      for (var i = 0; i < coordinates.length; ++i) {\n        var coordinate = coordinates[i];\n        array.push(extract$2.coordinate.apply(this, [coordinate]));\n      }\n      return {\n        type: 'LineString',\n        coordinates: array\n      };\n    },\n    MultiLineString: function MultiLineString(multilinestring) {\n      var array = [];\n      for (var i = 0; i < multilinestring._geometries.length; ++i) {\n        var linestring = multilinestring._geometries[i];\n        var geoJson = extract$2.LineString.apply(this, [linestring]);\n        array.push(geoJson.coordinates);\n      }\n      return {\n        type: 'MultiLineString',\n        coordinates: array\n      };\n    },\n    Polygon: function Polygon(polygon) {\n      var array = [];\n      var shellGeoJson = extract$2.LineString.apply(this, [polygon._shell]);\n      array.push(shellGeoJson.coordinates);\n      for (var i = 0; i < polygon._holes.length; ++i) {\n        var hole = polygon._holes[i];\n        var holeGeoJson = extract$2.LineString.apply(this, [hole]);\n        array.push(holeGeoJson.coordinates);\n      }\n      return {\n        type: 'Polygon',\n        coordinates: array\n      };\n    },\n    MultiPolygon: function MultiPolygon(multipolygon) {\n      var array = [];\n      for (var i = 0; i < multipolygon._geometries.length; ++i) {\n        var polygon = multipolygon._geometries[i];\n        var geoJson = extract$2.Polygon.apply(this, [polygon]);\n        array.push(geoJson.coordinates);\n      }\n      return {\n        type: 'MultiPolygon',\n        coordinates: array\n      };\n    },\n    GeometryCollection: function GeometryCollection(collection) {\n      var array = [];\n      for (var i = 0; i < collection._geometries.length; ++i) {\n        var geometry = collection._geometries[i];\n        var type = geometry.getGeometryType();\n        array.push(extract$2[type].apply(this, [geometry]));\n      }\n      return {\n        type: 'GeometryCollection',\n        geometries: array\n      };\n    }\n  };\n\n  function GeoJSONReader(geometryFactory) {\n    this.geometryFactory = geometryFactory || new GeometryFactory();\n    this.precisionModel = this.geometryFactory.getPrecisionModel();\n    this.parser = new GeoJSONParser(this.geometryFactory);\n  }\n  extend(GeoJSONReader.prototype, {\n    read: function read(geoJson) {\n      var geometry = this.parser.read(geoJson);\n      if (this.precisionModel.getType() === PrecisionModel.FIXED) {\n        this.reducePrecision(geometry);\n      }\n      return geometry;\n    },\n    reducePrecision: function reducePrecision(geometry) {\n      var i, len;\n      if (geometry.coordinate) {\n        this.precisionModel.makePrecise(geometry.coordinate);\n      } else if (geometry.points) {\n        for (i = 0, len = geometry.points.length; i < len; i++) {\n          this.precisionModel.makePrecise(geometry.points[i]);\n        }\n      } else if (geometry.geometries) {\n        for (i = 0, len = geometry.geometries.length; i < len; i++) {\n          this.reducePrecision(geometry.geometries[i]);\n        }\n      }\n    }\n  });\n\n  function GeoJSONWriter() {\n    this.parser = new GeoJSONParser(this.geometryFactory);\n  }\n  extend(GeoJSONWriter.prototype, {\n    write: function write(geometry) {\n      return this.parser.write(geometry);\n    }\n  });\n\n  function WKTReader(geometryFactory) {\n    this.geometryFactory = geometryFactory || new GeometryFactory();\n    this.precisionModel = this.geometryFactory.getPrecisionModel();\n    this.parser = new WKTParser(this.geometryFactory);\n  }\n  extend(WKTReader.prototype, {\n    read: function read(wkt) {\n      var geometry = this.parser.read(wkt);\n      if (this.precisionModel.getType() === PrecisionModel.FIXED) {\n        this.reducePrecision(geometry);\n      }\n      return geometry;\n    },\n    reducePrecision: function reducePrecision(geometry) {\n      if (geometry.coordinate) {\n        this.precisionModel.makePrecise(geometry.coordinate);\n      } else if (geometry._points) {\n        for (var i = 0, len = geometry._points._coordinates.length; i < len; i++) {\n          this.precisionModel.makePrecise(geometry._points._coordinates[i]);\n        }\n      } else if (geometry._geometries) {\n        for (var i = 0, len = geometry._geometries.length; i < len; i++) {\n          this.reducePrecision(geometry._geometries[i]);\n        }\n      }\n    }\n  });\n\n  function p2c(p) {\n    return [p.x, p.y];\n  }\n  function OL3Parser(geometryFactory, olReference) {\n    this.geometryFactory = geometryFactory || new GeometryFactory();\n    this.ol = olReference || typeof ol !== 'undefined' && ol;\n  }\n  extend(OL3Parser.prototype, {\n    read: function read(geometry) {\n      var ol = this.ol;\n      if (geometry instanceof ol.geom.Point) {\n        return this.convertFromPoint(geometry);\n      } else if (geometry instanceof ol.geom.LineString) {\n        return this.convertFromLineString(geometry);\n      } else if (geometry instanceof ol.geom.LinearRing) {\n        return this.convertFromLinearRing(geometry);\n      } else if (geometry instanceof ol.geom.Polygon) {\n        return this.convertFromPolygon(geometry);\n      } else if (geometry instanceof ol.geom.MultiPoint) {\n        return this.convertFromMultiPoint(geometry);\n      } else if (geometry instanceof ol.geom.MultiLineString) {\n        return this.convertFromMultiLineString(geometry);\n      } else if (geometry instanceof ol.geom.MultiPolygon) {\n        return this.convertFromMultiPolygon(geometry);\n      } else if (geometry instanceof ol.geom.GeometryCollection) {\n        return this.convertFromCollection(geometry);\n      }\n    },\n    convertFromPoint: function convertFromPoint(point) {\n      var coordinates = point.getCoordinates();\n      return this.geometryFactory.createPoint(new Coordinate(coordinates[0], coordinates[1]));\n    },\n    convertFromLineString: function convertFromLineString(lineString) {\n      return this.geometryFactory.createLineString(lineString.getCoordinates().map(function (coordinates) {\n        return new Coordinate(coordinates[0], coordinates[1]);\n      }));\n    },\n    convertFromLinearRing: function convertFromLinearRing(linearRing) {\n      return this.geometryFactory.createLinearRing(linearRing.getCoordinates().map(function (coordinates) {\n        return new Coordinate(coordinates[0], coordinates[1]);\n      }));\n    },\n    convertFromPolygon: function convertFromPolygon(polygon) {\n      var linearRings = polygon.getLinearRings();\n      var shell = null;\n      var holes = [];\n      for (var i = 0; i < linearRings.length; i++) {\n        var linearRing = this.convertFromLinearRing(linearRings[i]);\n        if (i === 0) {\n          shell = linearRing;\n        } else {\n          holes.push(linearRing);\n        }\n      }\n      return this.geometryFactory.createPolygon(shell, holes);\n    },\n    convertFromMultiPoint: function convertFromMultiPoint(multiPoint) {\n      var points = multiPoint.getPoints().map(function (point) {\n        return this.convertFromPoint(point);\n      }, this);\n      return this.geometryFactory.createMultiPoint(points);\n    },\n    convertFromMultiLineString: function convertFromMultiLineString(multiLineString) {\n      var lineStrings = multiLineString.getLineStrings().map(function (lineString) {\n        return this.convertFromLineString(lineString);\n      }, this);\n      return this.geometryFactory.createMultiLineString(lineStrings);\n    },\n    convertFromMultiPolygon: function convertFromMultiPolygon(multiPolygon) {\n      var polygons = multiPolygon.getPolygons().map(function (polygon) {\n        return this.convertFromPolygon(polygon);\n      }, this);\n      return this.geometryFactory.createMultiPolygon(polygons);\n    },\n    convertFromCollection: function convertFromCollection(collection) {\n      var geometries = collection.getGeometries().map(function (geometry) {\n        return this.read(geometry);\n      }, this);\n      return this.geometryFactory.createGeometryCollection(geometries);\n    },\n    write: function write(geometry) {\n      if (geometry.getGeometryType() === 'Point') {\n        return this.convertToPoint(geometry.getCoordinate());\n      } else if (geometry.getGeometryType() === 'LineString') {\n        return this.convertToLineString(geometry);\n      } else if (geometry.getGeometryType() === 'LinearRing') {\n        return this.convertToLinearRing(geometry);\n      } else if (geometry.getGeometryType() === 'Polygon') {\n        return this.convertToPolygon(geometry);\n      } else if (geometry.getGeometryType() === 'MultiPoint') {\n        return this.convertToMultiPoint(geometry);\n      } else if (geometry.getGeometryType() === 'MultiLineString') {\n        return this.convertToMultiLineString(geometry);\n      } else if (geometry.getGeometryType() === 'MultiPolygon') {\n        return this.convertToMultiPolygon(geometry);\n      } else if (geometry.getGeometryType() === 'GeometryCollection') {\n        return this.convertToCollection(geometry);\n      }\n    },\n    convertToPoint: function convertToPoint(coordinate) {\n      return new this.ol.geom.Point([coordinate.x, coordinate.y]);\n    },\n    convertToLineString: function convertToLineString(lineString) {\n      var points = lineString.points.coordinates.map(p2c);\n      return new this.ol.geom.LineString(points);\n    },\n    convertToLinearRing: function convertToLinearRing(linearRing) {\n      var points = linearRing.points.coordinates.map(p2c);\n      return new this.ol.geom.LinearRing(points);\n    },\n    convertToPolygon: function convertToPolygon(polygon) {\n      var rings = [polygon.shell.points.coordinates.map(p2c)];\n      for (var i = 0; i < polygon.holes.length; i++) {\n        rings.push(polygon.holes[i].points.coordinates.map(p2c));\n      }\n      return new this.ol.geom.Polygon(rings);\n    },\n    convertToMultiPoint: function convertToMultiPoint(multiPoint) {\n      return new this.ol.geom.MultiPoint(multiPoint.getCoordinates().map(p2c));\n    },\n    convertToMultiLineString: function convertToMultiLineString(multiLineString) {\n      var lineStrings = [];\n      for (var i = 0; i < multiLineString.geometries.length; i++) {\n        lineStrings.push(this.convertToLineString(multiLineString.geometries[i]).getCoordinates());\n      }\n      return new this.ol.geom.MultiLineString(lineStrings);\n    },\n    convertToMultiPolygon: function convertToMultiPolygon(multiPolygon) {\n      var polygons = [];\n      for (var i = 0; i < multiPolygon.geometries.length; i++) {\n        polygons.push(this.convertToPolygon(multiPolygon.geometries[i]).getCoordinates());\n      }\n      return new this.ol.geom.MultiPolygon(polygons);\n    },\n    convertToCollection: function convertToCollection(geometryCollection) {\n      var geometries = [];\n      for (var i = 0; i < geometryCollection.geometries.length; i++) {\n        var geometry = geometryCollection.geometries[i];\n        geometries.push(this.write(geometry));\n      }\n      return new this.ol.geom.GeometryCollection(geometries);\n    }\n  });\n\n  function ScaledNoder() {\n  \tthis._noder = null;\n  \tthis._scaleFactor = null;\n  \tthis._offsetX = null;\n  \tthis._offsetY = null;\n  \tthis._isScaled = false;\n  \tif (arguments.length === 2) {\n  \t\tvar noder = arguments[0],\n  \t\t    scaleFactor = arguments[1];\n  \t\tScaledNoder.call(this, noder, scaleFactor, 0, 0);\n  \t} else if (arguments.length === 4) {\n  \t\tvar noder = arguments[0],\n  \t\t    scaleFactor = arguments[1];\n  \t\tthis._noder = noder;\n  \t\tthis._scaleFactor = scaleFactor;\n  \t\tthis._isScaled = !this.isIntegerPrecision();\n  \t}\n  }\n  extend(ScaledNoder.prototype, {\n  \trescale: function rescale() {\n  \t\tif (hasInterface(arguments[0], Collection)) {\n  \t\t\tvar segStrings = arguments[0];\n  \t\t\tfor (var i = segStrings.iterator(); i.hasNext();) {\n  \t\t\t\tvar ss = i.next();\n  \t\t\t\tthis.rescale(ss.getCoordinates());\n  \t\t\t}\n  \t\t} else if (arguments[0] instanceof Array) {\n  \t\t\tvar pts = arguments[0];\n  \t\t\tvar p0 = null;\n  \t\t\tvar p1 = null;\n  \t\t\tif (pts.length === 2) {\n  \t\t\t\tp0 = new Coordinate(pts[0]);\n  \t\t\t\tp1 = new Coordinate(pts[1]);\n  \t\t\t}\n  \t\t\tfor (var i = 0; i < pts.length; i++) {\n  \t\t\t\tpts[i].x = pts[i].x / this._scaleFactor + this._offsetX;\n  \t\t\t\tpts[i].y = pts[i].y / this._scaleFactor + this._offsetY;\n  \t\t\t}\n  \t\t\tif (pts.length === 2 && pts[0].equals2D(pts[1])) {\n  \t\t\t\tSystem.out.println(pts);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tscale: function scale() {\n  \t\tif (hasInterface(arguments[0], Collection)) {\n  \t\t\tvar segStrings = arguments[0];\n  \t\t\tvar nodedSegmentStrings = new ArrayList();\n  \t\t\tfor (var i = segStrings.iterator(); i.hasNext();) {\n  \t\t\t\tvar ss = i.next();\n  \t\t\t\tnodedSegmentStrings.add(new NodedSegmentString(this.scale(ss.getCoordinates()), ss.getData()));\n  \t\t\t}\n  \t\t\treturn nodedSegmentStrings;\n  \t\t} else if (arguments[0] instanceof Array) {\n  \t\t\tvar pts = arguments[0];\n  \t\t\tvar roundPts = new Array(pts.length).fill(null);\n  \t\t\tfor (var i = 0; i < pts.length; i++) {\n  \t\t\t\troundPts[i] = new Coordinate(Math.round((pts[i].x - this._offsetX) * this._scaleFactor), Math.round((pts[i].y - this._offsetY) * this._scaleFactor), pts[i].z);\n  \t\t\t}\n  \t\t\tvar roundPtsNoDup = CoordinateArrays.removeRepeatedPoints(roundPts);\n  \t\t\treturn roundPtsNoDup;\n  \t\t}\n  \t},\n  \tisIntegerPrecision: function isIntegerPrecision() {\n  \t\treturn this._scaleFactor === 1.0;\n  \t},\n  \tgetNodedSubstrings: function getNodedSubstrings() {\n  \t\tvar splitSS = this._noder.getNodedSubstrings();\n  \t\tif (this._isScaled) this.rescale(splitSS);\n  \t\treturn splitSS;\n  \t},\n  \tcomputeNodes: function computeNodes(inputSegStrings) {\n  \t\tvar intSegStrings = inputSegStrings;\n  \t\tif (this._isScaled) intSegStrings = this.scale(inputSegStrings);\n  \t\tthis._noder.computeNodes(intSegStrings);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Noder];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn ScaledNoder;\n  \t}\n  });\n\n  function IsSimpleOp() {\n  \tthis._inputGeom = null;\n  \tthis._isClosedEndpointsInInterior = true;\n  \tthis._nonSimpleLocation = null;\n  \tif (arguments.length === 1) {\n  \t\tvar geom = arguments[0];\n  \t\tthis._inputGeom = geom;\n  \t} else if (arguments.length === 2) {\n  \t\tvar geom = arguments[0],\n  \t\t    boundaryNodeRule = arguments[1];\n  \t\tthis._inputGeom = geom;\n  \t\tthis._isClosedEndpointsInInterior = !boundaryNodeRule.isInBoundary(2);\n  \t}\n  }\n  extend(IsSimpleOp.prototype, {\n  \tisSimpleMultiPoint: function isSimpleMultiPoint(mp) {\n  \t\tif (mp.isEmpty()) return true;\n  \t\tvar points = new TreeSet();\n  \t\tfor (var i = 0; i < mp.getNumGeometries(); i++) {\n  \t\t\tvar pt = mp.getGeometryN(i);\n  \t\t\tvar p = pt.getCoordinate();\n  \t\t\tif (points.contains(p)) {\n  \t\t\t\tthis._nonSimpleLocation = p;\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t\tpoints.add(p);\n  \t\t}\n  \t\treturn true;\n  \t},\n  \tisSimplePolygonal: function isSimplePolygonal(geom) {\n  \t\tvar rings = LinearComponentExtracter.getLines(geom);\n  \t\tfor (var i = rings.iterator(); i.hasNext();) {\n  \t\t\tvar ring = i.next();\n  \t\t\tif (!this.isSimpleLinearGeometry(ring)) return false;\n  \t\t}\n  \t\treturn true;\n  \t},\n  \thasClosedEndpointIntersection: function hasClosedEndpointIntersection(graph) {\n  \t\tvar endPoints = new TreeMap();\n  \t\tfor (var i = graph.getEdgeIterator(); i.hasNext();) {\n  \t\t\tvar e = i.next();\n  \t\t\tvar maxSegmentIndex = e.getMaximumSegmentIndex();\n  \t\t\tvar isClosed = e.isClosed();\n  \t\t\tvar p0 = e.getCoordinate(0);\n  \t\t\tthis.addEndpoint(endPoints, p0, isClosed);\n  \t\t\tvar p1 = e.getCoordinate(e.getNumPoints() - 1);\n  \t\t\tthis.addEndpoint(endPoints, p1, isClosed);\n  \t\t}\n  \t\tfor (var i = endPoints.values().iterator(); i.hasNext();) {\n  \t\t\tvar eiInfo = i.next();\n  \t\t\tif (eiInfo.isClosed && eiInfo.degree !== 2) {\n  \t\t\t\tthis._nonSimpleLocation = eiInfo.getCoordinate();\n  \t\t\t\treturn true;\n  \t\t\t}\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tgetNonSimpleLocation: function getNonSimpleLocation() {\n  \t\treturn this._nonSimpleLocation;\n  \t},\n  \tisSimpleLinearGeometry: function isSimpleLinearGeometry(geom) {\n  \t\tif (geom.isEmpty()) return true;\n  \t\tvar graph = new GeometryGraph(0, geom);\n  \t\tvar li = new RobustLineIntersector();\n  \t\tvar si = graph.computeSelfNodes(li, true);\n  \t\tif (!si.hasIntersection()) return true;\n  \t\tif (si.hasProperIntersection()) {\n  \t\t\tthis._nonSimpleLocation = si.getProperIntersectionPoint();\n  \t\t\treturn false;\n  \t\t}\n  \t\tif (this.hasNonEndpointIntersection(graph)) return false;\n  \t\tif (this._isClosedEndpointsInInterior) {\n  \t\t\tif (this.hasClosedEndpointIntersection(graph)) return false;\n  \t\t}\n  \t\treturn true;\n  \t},\n  \thasNonEndpointIntersection: function hasNonEndpointIntersection(graph) {\n  \t\tfor (var i = graph.getEdgeIterator(); i.hasNext();) {\n  \t\t\tvar e = i.next();\n  \t\t\tvar maxSegmentIndex = e.getMaximumSegmentIndex();\n  \t\t\tfor (var eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext();) {\n  \t\t\t\tvar ei = eiIt.next();\n  \t\t\t\tif (!ei.isEndPoint(maxSegmentIndex)) {\n  \t\t\t\t\tthis._nonSimpleLocation = ei.getCoordinate();\n  \t\t\t\t\treturn true;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\treturn false;\n  \t},\n  \taddEndpoint: function addEndpoint(endPoints, p, isClosed) {\n  \t\tvar eiInfo = endPoints.get(p);\n  \t\tif (eiInfo === null) {\n  \t\t\teiInfo = new EndpointInfo(p);\n  \t\t\tendPoints.put(p, eiInfo);\n  \t\t}\n  \t\teiInfo.addEndpoint(isClosed);\n  \t},\n  \tcomputeSimple: function computeSimple(geom) {\n  \t\tthis._nonSimpleLocation = null;\n  \t\tif (geom.isEmpty()) return true;\n  \t\tif (geom instanceof LineString) return this.isSimpleLinearGeometry(geom);\n  \t\tif (geom instanceof MultiLineString) return this.isSimpleLinearGeometry(geom);\n  \t\tif (geom instanceof MultiPoint) return this.isSimpleMultiPoint(geom);\n  \t\tif (hasInterface(geom, Polygonal)) return this.isSimplePolygonal(geom);\n  \t\tif (geom instanceof GeometryCollection) return this.isSimpleGeometryCollection(geom);\n  \t\treturn true;\n  \t},\n  \tisSimple: function isSimple() {\n  \t\tthis._nonSimpleLocation = null;\n  \t\treturn this.computeSimple(this._inputGeom);\n  \t},\n  \tisSimpleGeometryCollection: function isSimpleGeometryCollection(geom) {\n  \t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n  \t\t\tvar comp = geom.getGeometryN(i);\n  \t\t\tif (!this.computeSimple(comp)) return false;\n  \t\t}\n  \t\treturn true;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn IsSimpleOp;\n  \t}\n  });\n  function EndpointInfo() {\n  \tthis.pt = null;\n  \tthis.isClosed = null;\n  \tthis.degree = null;\n  \tvar pt = arguments[0];\n  \tthis.pt = pt;\n  \tthis.isClosed = false;\n  \tthis.degree = 0;\n  }\n  extend(EndpointInfo.prototype, {\n  \taddEndpoint: function addEndpoint(isClosed) {\n  \t\tthis.degree++;\n  \t\tthis.isClosed |= isClosed;\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\treturn this.pt;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn EndpointInfo;\n  \t}\n  });\n  IsSimpleOp.EndpointInfo = EndpointInfo;\n\n  function BufferParameters() {\n  \tthis._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;\n  \tthis._endCapStyle = BufferParameters.CAP_ROUND;\n  \tthis._joinStyle = BufferParameters.JOIN_ROUND;\n  \tthis._mitreLimit = BufferParameters.DEFAULT_MITRE_LIMIT;\n  \tthis._isSingleSided = false;\n  \tthis._simplifyFactor = BufferParameters.DEFAULT_SIMPLIFY_FACTOR;\n  \tif (arguments.length === 0) ; else if (arguments.length === 1) {\n  \t\tvar quadrantSegments = arguments[0];\n  \t\tthis.setQuadrantSegments(quadrantSegments);\n  \t} else if (arguments.length === 2) {\n  \t\tvar quadrantSegments = arguments[0],\n  \t\t    endCapStyle = arguments[1];\n  \t\tthis.setQuadrantSegments(quadrantSegments);\n  \t\tthis.setEndCapStyle(endCapStyle);\n  \t} else if (arguments.length === 4) {\n  \t\tvar quadrantSegments = arguments[0],\n  \t\t    endCapStyle = arguments[1],\n  \t\t    joinStyle = arguments[2],\n  \t\t    mitreLimit = arguments[3];\n  \t\tthis.setQuadrantSegments(quadrantSegments);\n  \t\tthis.setEndCapStyle(endCapStyle);\n  \t\tthis.setJoinStyle(joinStyle);\n  \t\tthis.setMitreLimit(mitreLimit);\n  \t}\n  }\n  extend(BufferParameters.prototype, {\n  \tgetEndCapStyle: function getEndCapStyle() {\n  \t\treturn this._endCapStyle;\n  \t},\n  \tisSingleSided: function isSingleSided() {\n  \t\treturn this._isSingleSided;\n  \t},\n  \tsetQuadrantSegments: function setQuadrantSegments(quadSegs) {\n  \t\tthis._quadrantSegments = quadSegs;\n  \t\tif (this._quadrantSegments === 0) this._joinStyle = BufferParameters.JOIN_BEVEL;\n  \t\tif (this._quadrantSegments < 0) {\n  \t\t\tthis._joinStyle = BufferParameters.JOIN_MITRE;\n  \t\t\tthis._mitreLimit = Math.abs(this._quadrantSegments);\n  \t\t}\n  \t\tif (quadSegs <= 0) {\n  \t\t\tthis._quadrantSegments = 1;\n  \t\t}\n  \t\tif (this._joinStyle !== BufferParameters.JOIN_ROUND) {\n  \t\t\tthis._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;\n  \t\t}\n  \t},\n  \tgetJoinStyle: function getJoinStyle() {\n  \t\treturn this._joinStyle;\n  \t},\n  \tsetJoinStyle: function setJoinStyle(joinStyle) {\n  \t\tthis._joinStyle = joinStyle;\n  \t},\n  \tsetSimplifyFactor: function setSimplifyFactor(simplifyFactor) {\n  \t\tthis._simplifyFactor = simplifyFactor < 0 ? 0 : simplifyFactor;\n  \t},\n  \tgetSimplifyFactor: function getSimplifyFactor() {\n  \t\treturn this._simplifyFactor;\n  \t},\n  \tgetQuadrantSegments: function getQuadrantSegments() {\n  \t\treturn this._quadrantSegments;\n  \t},\n  \tsetEndCapStyle: function setEndCapStyle(endCapStyle) {\n  \t\tthis._endCapStyle = endCapStyle;\n  \t},\n  \tgetMitreLimit: function getMitreLimit() {\n  \t\treturn this._mitreLimit;\n  \t},\n  \tsetMitreLimit: function setMitreLimit(mitreLimit) {\n  \t\tthis._mitreLimit = mitreLimit;\n  \t},\n  \tsetSingleSided: function setSingleSided(isSingleSided) {\n  \t\tthis._isSingleSided = isSingleSided;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn BufferParameters;\n  \t}\n  });\n  BufferParameters.bufferDistanceError = function (quadSegs) {\n  \tvar alpha = Math.PI / 2.0 / quadSegs;\n  \treturn 1 - Math.cos(alpha / 2.0);\n  };\n  BufferParameters.CAP_ROUND = 1;\n  BufferParameters.CAP_FLAT = 2;\n  BufferParameters.CAP_SQUARE = 3;\n  BufferParameters.JOIN_ROUND = 1;\n  BufferParameters.JOIN_MITRE = 2;\n  BufferParameters.JOIN_BEVEL = 3;\n  BufferParameters.DEFAULT_QUADRANT_SEGMENTS = 8;\n  BufferParameters.DEFAULT_MITRE_LIMIT = 5.0;\n  BufferParameters.DEFAULT_SIMPLIFY_FACTOR = 0.01;\n\n  function RightmostEdgeFinder() {\n  \tthis._minIndex = -1;\n  \tthis._minCoord = null;\n  \tthis._minDe = null;\n  \tthis._orientedDe = null;\n  }\n  extend(RightmostEdgeFinder.prototype, {\n  \tgetCoordinate: function getCoordinate() {\n  \t\treturn this._minCoord;\n  \t},\n  \tgetRightmostSide: function getRightmostSide(de, index) {\n  \t\tvar side = this.getRightmostSideOfSegment(de, index);\n  \t\tif (side < 0) side = this.getRightmostSideOfSegment(de, index - 1);\n  \t\tif (side < 0) {\n  \t\t\tthis._minCoord = null;\n  \t\t\tthis.checkForRightmostCoordinate(de);\n  \t\t}\n  \t\treturn side;\n  \t},\n  \tfindRightmostEdgeAtVertex: function findRightmostEdgeAtVertex() {\n  \t\tvar pts = this._minDe.getEdge().getCoordinates();\n  \t\tAssert.isTrue(this._minIndex > 0 && this._minIndex < pts.length, \"rightmost point expected to be interior vertex of edge\");\n  \t\tvar pPrev = pts[this._minIndex - 1];\n  \t\tvar pNext = pts[this._minIndex + 1];\n  \t\tvar orientation = CGAlgorithms.computeOrientation(this._minCoord, pNext, pPrev);\n  \t\tvar usePrev = false;\n  \t\tif (pPrev.y < this._minCoord.y && pNext.y < this._minCoord.y && orientation === CGAlgorithms.COUNTERCLOCKWISE) {\n  \t\t\tusePrev = true;\n  \t\t} else if (pPrev.y > this._minCoord.y && pNext.y > this._minCoord.y && orientation === CGAlgorithms.CLOCKWISE) {\n  \t\t\tusePrev = true;\n  \t\t}\n  \t\tif (usePrev) {\n  \t\t\tthis._minIndex = this._minIndex - 1;\n  \t\t}\n  \t},\n  \tgetRightmostSideOfSegment: function getRightmostSideOfSegment(de, i) {\n  \t\tvar e = de.getEdge();\n  \t\tvar coord = e.getCoordinates();\n  \t\tif (i < 0 || i + 1 >= coord.length) return -1;\n  \t\tif (coord[i].y === coord[i + 1].y) return -1;\n  \t\tvar pos = Position.LEFT;\n  \t\tif (coord[i].y < coord[i + 1].y) pos = Position.RIGHT;\n  \t\treturn pos;\n  \t},\n  \tgetEdge: function getEdge() {\n  \t\treturn this._orientedDe;\n  \t},\n  \tcheckForRightmostCoordinate: function checkForRightmostCoordinate(de) {\n  \t\tvar coord = de.getEdge().getCoordinates();\n  \t\tfor (var i = 0; i < coord.length - 1; i++) {\n  \t\t\tif (this._minCoord === null || coord[i].x > this._minCoord.x) {\n  \t\t\t\tthis._minDe = de;\n  \t\t\t\tthis._minIndex = i;\n  \t\t\t\tthis._minCoord = coord[i];\n  \t\t\t}\n  \t\t}\n  \t},\n  \tfindRightmostEdgeAtNode: function findRightmostEdgeAtNode() {\n  \t\tvar node = this._minDe.getNode();\n  \t\tvar star = node.getEdges();\n  \t\tthis._minDe = star.getRightmostEdge();\n  \t\tif (!this._minDe.isForward()) {\n  \t\t\tthis._minDe = this._minDe.getSym();\n  \t\t\tthis._minIndex = this._minDe.getEdge().getCoordinates().length - 1;\n  \t\t}\n  \t},\n  \tfindEdge: function findEdge(dirEdgeList) {\n  \t\tfor (var i = dirEdgeList.iterator(); i.hasNext();) {\n  \t\t\tvar de = i.next();\n  \t\t\tif (!de.isForward()) continue;\n  \t\t\tthis.checkForRightmostCoordinate(de);\n  \t\t}\n  \t\tAssert.isTrue(this._minIndex !== 0 || this._minCoord.equals(this._minDe.getCoordinate()), \"inconsistency in rightmost processing\");\n  \t\tif (this._minIndex === 0) {\n  \t\t\tthis.findRightmostEdgeAtNode();\n  \t\t} else {\n  \t\t\tthis.findRightmostEdgeAtVertex();\n  \t\t}\n  \t\tthis._orientedDe = this._minDe;\n  \t\tvar rightmostSide = this.getRightmostSide(this._minDe, this._minIndex);\n  \t\tif (rightmostSide === Position.LEFT) {\n  \t\t\tthis._orientedDe = this._minDe.getSym();\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn RightmostEdgeFinder;\n  \t}\n  });\n\n  function LinkedList() {\n    this.array_ = [];\n  }\n  LinkedList.prototype.addLast = function (e) {\n    this.array_.push(e);\n  };\n  LinkedList.prototype.removeFirst = function () {\n    return this.array_.shift();\n  };\n  LinkedList.prototype.isEmpty = function () {\n    return this.array_.length === 0;\n  };\n\n  function BufferSubgraph() {\n  \tthis._finder = null;\n  \tthis._dirEdgeList = new ArrayList();\n  \tthis._nodes = new ArrayList();\n  \tthis._rightMostCoord = null;\n  \tthis._env = null;\n  \tthis._finder = new RightmostEdgeFinder();\n  }\n  extend(BufferSubgraph.prototype, {\n  \tclearVisitedEdges: function clearVisitedEdges() {\n  \t\tfor (var it = this._dirEdgeList.iterator(); it.hasNext();) {\n  \t\t\tvar de = it.next();\n  \t\t\tde.setVisited(false);\n  \t\t}\n  \t},\n  \tgetRightmostCoordinate: function getRightmostCoordinate() {\n  \t\treturn this._rightMostCoord;\n  \t},\n  \tcomputeNodeDepth: function computeNodeDepth(n) {\n  \t\tvar startEdge = null;\n  \t\tfor (var i = n.getEdges().iterator(); i.hasNext();) {\n  \t\t\tvar de = i.next();\n  \t\t\tif (de.isVisited() || de.getSym().isVisited()) {\n  \t\t\t\tstartEdge = de;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t}\n  \t\tif (startEdge === null) throw new TopologyException(\"unable to find edge to compute depths at \" + n.getCoordinate());\n  \t\tn.getEdges().computeDepths(startEdge);\n  \t\tfor (var i = n.getEdges().iterator(); i.hasNext();) {\n  \t\t\tvar de = i.next();\n  \t\t\tde.setVisited(true);\n  \t\t\tthis.copySymDepths(de);\n  \t\t}\n  \t},\n  \tcomputeDepth: function computeDepth(outsideDepth) {\n  \t\tthis.clearVisitedEdges();\n  \t\tvar de = this._finder.getEdge();\n  \t\tvar n = de.getNode();\n  \t\tvar label = de.getLabel();\n  \t\tde.setEdgeDepths(Position.RIGHT, outsideDepth);\n  \t\tthis.copySymDepths(de);\n  \t\tthis.computeDepths(de);\n  \t},\n  \tcreate: function create(node) {\n  \t\tthis.addReachable(node);\n  \t\tthis._finder.findEdge(this._dirEdgeList);\n  \t\tthis._rightMostCoord = this._finder.getCoordinate();\n  \t},\n  \tfindResultEdges: function findResultEdges() {\n  \t\tfor (var it = this._dirEdgeList.iterator(); it.hasNext();) {\n  \t\t\tvar de = it.next();\n  \t\t\tif (de.getDepth(Position.RIGHT) >= 1 && de.getDepth(Position.LEFT) <= 0 && !de.isInteriorAreaEdge()) {\n  \t\t\t\tde.setInResult(true);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcomputeDepths: function computeDepths(startEdge) {\n  \t\tvar nodesVisited = new HashSet();\n  \t\tvar nodeQueue = new LinkedList();\n  \t\tvar startNode = startEdge.getNode();\n  \t\tnodeQueue.addLast(startNode);\n  \t\tnodesVisited.add(startNode);\n  \t\tstartEdge.setVisited(true);\n  \t\twhile (!nodeQueue.isEmpty()) {\n  \t\t\tvar n = nodeQueue.removeFirst();\n  \t\t\tnodesVisited.add(n);\n  \t\t\tthis.computeNodeDepth(n);\n  \t\t\tfor (var i = n.getEdges().iterator(); i.hasNext();) {\n  \t\t\t\tvar de = i.next();\n  \t\t\t\tvar sym = de.getSym();\n  \t\t\t\tif (sym.isVisited()) continue;\n  \t\t\t\tvar adjNode = sym.getNode();\n  \t\t\t\tif (!nodesVisited.contains(adjNode)) {\n  \t\t\t\t\tnodeQueue.addLast(adjNode);\n  \t\t\t\t\tnodesVisited.add(adjNode);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcompareTo: function compareTo(o) {\n  \t\tvar graph = o;\n  \t\tif (this._rightMostCoord.x < graph._rightMostCoord.x) {\n  \t\t\treturn -1;\n  \t\t}\n  \t\tif (this._rightMostCoord.x > graph._rightMostCoord.x) {\n  \t\t\treturn 1;\n  \t\t}\n  \t\treturn 0;\n  \t},\n  \tgetEnvelope: function getEnvelope() {\n  \t\tif (this._env === null) {\n  \t\t\tvar edgeEnv = new Envelope();\n  \t\t\tfor (var it = this._dirEdgeList.iterator(); it.hasNext();) {\n  \t\t\t\tvar dirEdge = it.next();\n  \t\t\t\tvar pts = dirEdge.getEdge().getCoordinates();\n  \t\t\t\tfor (var i = 0; i < pts.length - 1; i++) {\n  \t\t\t\t\tedgeEnv.expandToInclude(pts[i]);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\tthis._env = edgeEnv;\n  \t\t}\n  \t\treturn this._env;\n  \t},\n  \taddReachable: function addReachable(startNode) {\n  \t\tvar nodeStack = new Stack$1();\n  \t\tnodeStack.add(startNode);\n  \t\twhile (!nodeStack.empty()) {\n  \t\t\tvar node = nodeStack.pop();\n  \t\t\tthis.add(node, nodeStack);\n  \t\t}\n  \t},\n  \tcopySymDepths: function copySymDepths(de) {\n  \t\tvar sym = de.getSym();\n  \t\tsym.setDepth(Position.LEFT, de.getDepth(Position.RIGHT));\n  \t\tsym.setDepth(Position.RIGHT, de.getDepth(Position.LEFT));\n  \t},\n  \tadd: function add(node, nodeStack) {\n  \t\tnode.setVisited(true);\n  \t\tthis._nodes.add(node);\n  \t\tfor (var i = node.getEdges().iterator(); i.hasNext();) {\n  \t\t\tvar de = i.next();\n  \t\t\tthis._dirEdgeList.add(de);\n  \t\t\tvar sym = de.getSym();\n  \t\t\tvar symNode = sym.getNode();\n  \t\t\tif (!symNode.isVisited()) nodeStack.push(symNode);\n  \t\t}\n  \t},\n  \tgetNodes: function getNodes() {\n  \t\treturn this._nodes;\n  \t},\n  \tgetDirectedEdges: function getDirectedEdges() {\n  \t\treturn this._dirEdgeList;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn BufferSubgraph;\n  \t}\n  });\n\n  function BufferInputLineSimplifier() {\n  \tthis._inputLine = null;\n  \tthis._distanceTol = null;\n  \tthis._isDeleted = null;\n  \tthis._angleOrientation = CGAlgorithms.COUNTERCLOCKWISE;\n  \tvar inputLine = arguments[0];\n  \tthis._inputLine = inputLine;\n  }\n  extend(BufferInputLineSimplifier.prototype, {\n  \tisDeletable: function isDeletable(i0, i1, i2, distanceTol) {\n  \t\tvar p0 = this._inputLine[i0];\n  \t\tvar p1 = this._inputLine[i1];\n  \t\tvar p2 = this._inputLine[i2];\n  \t\tif (!this.isConcave(p0, p1, p2)) return false;\n  \t\tif (!this.isShallow(p0, p1, p2, distanceTol)) return false;\n  \t\treturn this.isShallowSampled(p0, p1, i0, i2, distanceTol);\n  \t},\n  \tdeleteShallowConcavities: function deleteShallowConcavities() {\n  \t\tvar index = 1;\n  \t\tvar maxIndex = this._inputLine.length - 1;\n  \t\tvar midIndex = this.findNextNonDeletedIndex(index);\n  \t\tvar lastIndex = this.findNextNonDeletedIndex(midIndex);\n  \t\tvar isChanged = false;\n  \t\twhile (lastIndex < this._inputLine.length) {\n  \t\t\tvar isMiddleVertexDeleted = false;\n  \t\t\tif (this.isDeletable(index, midIndex, lastIndex, this._distanceTol)) {\n  \t\t\t\tthis._isDeleted[midIndex] = BufferInputLineSimplifier.DELETE;\n  \t\t\t\tisMiddleVertexDeleted = true;\n  \t\t\t\tisChanged = true;\n  \t\t\t}\n  \t\t\tif (isMiddleVertexDeleted) index = lastIndex;else index = midIndex;\n  \t\t\tmidIndex = this.findNextNonDeletedIndex(index);\n  \t\t\tlastIndex = this.findNextNonDeletedIndex(midIndex);\n  \t\t}\n  \t\treturn isChanged;\n  \t},\n  \tisShallowConcavity: function isShallowConcavity(p0, p1, p2, distanceTol) {\n  \t\tvar orientation = CGAlgorithms.computeOrientation(p0, p1, p2);\n  \t\tvar isAngleToSimplify = orientation === this._angleOrientation;\n  \t\tif (!isAngleToSimplify) return false;\n  \t\tvar dist = CGAlgorithms.distancePointLine(p1, p0, p2);\n  \t\treturn dist < distanceTol;\n  \t},\n  \tisShallowSampled: function isShallowSampled(p0, p2, i0, i2, distanceTol) {\n  \t\tvar inc = Math.trunc((i2 - i0) / BufferInputLineSimplifier.NUM_PTS_TO_CHECK);\n  \t\tif (inc <= 0) inc = 1;\n  \t\tfor (var i = i0; i < i2; i += inc) {\n  \t\t\tif (!this.isShallow(p0, p2, this._inputLine[i], distanceTol)) return false;\n  \t\t}\n  \t\treturn true;\n  \t},\n  \tisConcave: function isConcave(p0, p1, p2) {\n  \t\tvar orientation = CGAlgorithms.computeOrientation(p0, p1, p2);\n  \t\tvar isConcave = orientation === this._angleOrientation;\n  \t\treturn isConcave;\n  \t},\n  \tsimplify: function simplify(distanceTol) {\n  \t\tthis._distanceTol = Math.abs(distanceTol);\n  \t\tif (distanceTol < 0) this._angleOrientation = CGAlgorithms.CLOCKWISE;\n  \t\tthis._isDeleted = new Array(this._inputLine.length).fill(null);\n  \t\tvar isChanged = false;\n  \t\tdo {\n  \t\t\tisChanged = this.deleteShallowConcavities();\n  \t\t} while (isChanged);\n  \t\treturn this.collapseLine();\n  \t},\n  \tfindNextNonDeletedIndex: function findNextNonDeletedIndex(index) {\n  \t\tvar next = index + 1;\n  \t\twhile (next < this._inputLine.length && this._isDeleted[next] === BufferInputLineSimplifier.DELETE) {\n  \t\t\tnext++;\n  \t\t}return next;\n  \t},\n  \tisShallow: function isShallow(p0, p1, p2, distanceTol) {\n  \t\tvar dist = CGAlgorithms.distancePointLine(p1, p0, p2);\n  \t\treturn dist < distanceTol;\n  \t},\n  \tcollapseLine: function collapseLine() {\n  \t\tvar coordList = new CoordinateList();\n  \t\tfor (var i = 0; i < this._inputLine.length; i++) {\n  \t\t\tif (this._isDeleted[i] !== BufferInputLineSimplifier.DELETE) coordList.add(this._inputLine[i]);\n  \t\t}\n  \t\treturn coordList.toCoordinateArray();\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn BufferInputLineSimplifier;\n  \t}\n  });\n  BufferInputLineSimplifier.simplify = function (inputLine, distanceTol) {\n  \tvar simp = new BufferInputLineSimplifier(inputLine);\n  \treturn simp.simplify(distanceTol);\n  };\n  BufferInputLineSimplifier.INIT = 0;\n  BufferInputLineSimplifier.DELETE = 1;\n  BufferInputLineSimplifier.KEEP = 1;\n  BufferInputLineSimplifier.NUM_PTS_TO_CHECK = 10;\n\n  function OffsetSegmentString() {\n  \tthis._ptList = null;\n  \tthis._precisionModel = null;\n  \tthis._minimimVertexDistance = 0.0;\n  \tthis._ptList = new ArrayList();\n  }\n  extend(OffsetSegmentString.prototype, {\n  \tgetCoordinates: function getCoordinates() {\n  \t\tvar coord = this._ptList.toArray(OffsetSegmentString.COORDINATE_ARRAY_TYPE);\n  \t\treturn coord;\n  \t},\n  \tsetPrecisionModel: function setPrecisionModel(precisionModel) {\n  \t\tthis._precisionModel = precisionModel;\n  \t},\n  \taddPt: function addPt(pt) {\n  \t\tvar bufPt = new Coordinate(pt);\n  \t\tthis._precisionModel.makePrecise(bufPt);\n  \t\tif (this.isRedundant(bufPt)) return null;\n  \t\tthis._ptList.add(bufPt);\n  \t},\n  \treverse: function reverse() {},\n  \taddPts: function addPts(pt, isForward) {\n  \t\tif (isForward) {\n  \t\t\tfor (var i = 0; i < pt.length; i++) {\n  \t\t\t\tthis.addPt(pt[i]);\n  \t\t\t}\n  \t\t} else {\n  \t\t\tfor (var i = pt.length - 1; i >= 0; i--) {\n  \t\t\t\tthis.addPt(pt[i]);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tisRedundant: function isRedundant(pt) {\n  \t\tif (this._ptList.size() < 1) return false;\n  \t\tvar lastPt = this._ptList.get(this._ptList.size() - 1);\n  \t\tvar ptDist = pt.distance(lastPt);\n  \t\tif (ptDist < this._minimimVertexDistance) return true;\n  \t\treturn false;\n  \t},\n  \ttoString: function toString() {\n  \t\tvar fact = new GeometryFactory();\n  \t\tvar line = fact.createLineString(this.getCoordinates());\n  \t\treturn line.toString();\n  \t},\n  \tcloseRing: function closeRing() {\n  \t\tif (this._ptList.size() < 1) return null;\n  \t\tvar startPt = new Coordinate(this._ptList.get(0));\n  \t\tvar lastPt = this._ptList.get(this._ptList.size() - 1);\n  \t\tvar last2Pt = null;\n  \t\tif (this._ptList.size() >= 2) last2Pt = this._ptList.get(this._ptList.size() - 2);\n  \t\tif (startPt.equals(lastPt)) return null;\n  \t\tthis._ptList.add(startPt);\n  \t},\n  \tsetMinimumVertexDistance: function setMinimumVertexDistance(minimimVertexDistance) {\n  \t\tthis._minimimVertexDistance = minimimVertexDistance;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn OffsetSegmentString;\n  \t}\n  });\n  OffsetSegmentString.COORDINATE_ARRAY_TYPE = new Array(0).fill(null);\n\n  function OffsetSegmentGenerator() {\n  \tthis._maxCurveSegmentError = 0.0;\n  \tthis._filletAngleQuantum = null;\n  \tthis._closingSegLengthFactor = 1;\n  \tthis._segList = null;\n  \tthis._distance = 0.0;\n  \tthis._precisionModel = null;\n  \tthis._bufParams = null;\n  \tthis._li = null;\n  \tthis._s0 = null;\n  \tthis._s1 = null;\n  \tthis._s2 = null;\n  \tthis._seg0 = new LineSegment();\n  \tthis._seg1 = new LineSegment();\n  \tthis._offset0 = new LineSegment();\n  \tthis._offset1 = new LineSegment();\n  \tthis._side = 0;\n  \tthis._hasNarrowConcaveAngle = false;\n  \tvar precisionModel = arguments[0],\n  \t    bufParams = arguments[1],\n  \t    distance = arguments[2];\n  \tthis._precisionModel = precisionModel;\n  \tthis._bufParams = bufParams;\n  \tthis._li = new RobustLineIntersector();\n  \tthis._filletAngleQuantum = Math.PI / 2.0 / bufParams.getQuadrantSegments();\n  \tif (bufParams.getQuadrantSegments() >= 8 && bufParams.getJoinStyle() === BufferParameters.JOIN_ROUND) this._closingSegLengthFactor = OffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR;\n  \tthis.init(distance);\n  }\n  extend(OffsetSegmentGenerator.prototype, {\n  \taddNextSegment: function addNextSegment(p, addStartPoint) {\n  \t\tthis._s0 = this._s1;\n  \t\tthis._s1 = this._s2;\n  \t\tthis._s2 = p;\n  \t\tthis._seg0.setCoordinates(this._s0, this._s1);\n  \t\tthis.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0);\n  \t\tthis._seg1.setCoordinates(this._s1, this._s2);\n  \t\tthis.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1);\n  \t\tif (this._s1.equals(this._s2)) return null;\n  \t\tvar orientation = CGAlgorithms.computeOrientation(this._s0, this._s1, this._s2);\n  \t\tvar outsideTurn = orientation === CGAlgorithms.CLOCKWISE && this._side === Position.LEFT || orientation === CGAlgorithms.COUNTERCLOCKWISE && this._side === Position.RIGHT;\n  \t\tif (orientation === 0) {\n  \t\t\tthis.addCollinear(addStartPoint);\n  \t\t} else if (outsideTurn) {\n  \t\t\tthis.addOutsideTurn(orientation, addStartPoint);\n  \t\t} else {\n  \t\t\tthis.addInsideTurn(orientation, addStartPoint);\n  \t\t}\n  \t},\n  \taddLineEndCap: function addLineEndCap(p0, p1) {\n  \t\tvar seg = new LineSegment(p0, p1);\n  \t\tvar offsetL = new LineSegment();\n  \t\tthis.computeOffsetSegment(seg, Position.LEFT, this._distance, offsetL);\n  \t\tvar offsetR = new LineSegment();\n  \t\tthis.computeOffsetSegment(seg, Position.RIGHT, this._distance, offsetR);\n  \t\tvar dx = p1.x - p0.x;\n  \t\tvar dy = p1.y - p0.y;\n  \t\tvar angle = Math.atan2(dy, dx);\n  \t\tswitch (this._bufParams.getEndCapStyle()) {\n  \t\t\tcase BufferParameters.CAP_ROUND:\n  \t\t\t\tthis._segList.addPt(offsetL.p1);\n  \t\t\t\tthis.addFilletArc(p1, angle + Math.PI / 2, angle - Math.PI / 2, CGAlgorithms.CLOCKWISE, this._distance);\n  \t\t\t\tthis._segList.addPt(offsetR.p1);\n  \t\t\t\tbreak;\n  \t\t\tcase BufferParameters.CAP_FLAT:\n  \t\t\t\tthis._segList.addPt(offsetL.p1);\n  \t\t\t\tthis._segList.addPt(offsetR.p1);\n  \t\t\t\tbreak;\n  \t\t\tcase BufferParameters.CAP_SQUARE:\n  \t\t\t\tvar squareCapSideOffset = new Coordinate();\n  \t\t\t\tsquareCapSideOffset.x = Math.abs(this._distance) * Math.cos(angle);\n  \t\t\t\tsquareCapSideOffset.y = Math.abs(this._distance) * Math.sin(angle);\n  \t\t\t\tvar squareCapLOffset = new Coordinate(offsetL.p1.x + squareCapSideOffset.x, offsetL.p1.y + squareCapSideOffset.y);\n  \t\t\t\tvar squareCapROffset = new Coordinate(offsetR.p1.x + squareCapSideOffset.x, offsetR.p1.y + squareCapSideOffset.y);\n  \t\t\t\tthis._segList.addPt(squareCapLOffset);\n  \t\t\t\tthis._segList.addPt(squareCapROffset);\n  \t\t\t\tbreak;\n  \t\t}\n  \t},\n  \tgetCoordinates: function getCoordinates() {\n  \t\tvar pts = this._segList.getCoordinates();\n  \t\treturn pts;\n  \t},\n  \taddMitreJoin: function addMitreJoin(p, offset0, offset1, distance) {\n  \t\tvar isMitreWithinLimit = true;\n  \t\tvar intPt = null;\n  \t\ttry {\n  \t\t\tintPt = HCoordinate.intersection(offset0.p0, offset0.p1, offset1.p0, offset1.p1);\n  \t\t\tvar mitreRatio = distance <= 0.0 ? 1.0 : intPt.distance(p) / Math.abs(distance);\n  \t\t\tif (mitreRatio > this._bufParams.getMitreLimit()) isMitreWithinLimit = false;\n  \t\t} catch (ex) {\n  \t\t\tif (ex instanceof NotRepresentableException) {\n  \t\t\t\tintPt = new Coordinate(0, 0);\n  \t\t\t\tisMitreWithinLimit = false;\n  \t\t\t} else throw ex;\n  \t\t} finally {}\n  \t\tif (isMitreWithinLimit) {\n  \t\t\tthis._segList.addPt(intPt);\n  \t\t} else {\n  \t\t\tthis.addLimitedMitreJoin(offset0, offset1, distance, this._bufParams.getMitreLimit());\n  \t\t}\n  \t},\n  \taddFilletCorner: function addFilletCorner(p, p0, p1, direction, radius) {\n  \t\tvar dx0 = p0.x - p.x;\n  \t\tvar dy0 = p0.y - p.y;\n  \t\tvar startAngle = Math.atan2(dy0, dx0);\n  \t\tvar dx1 = p1.x - p.x;\n  \t\tvar dy1 = p1.y - p.y;\n  \t\tvar endAngle = Math.atan2(dy1, dx1);\n  \t\tif (direction === CGAlgorithms.CLOCKWISE) {\n  \t\t\tif (startAngle <= endAngle) startAngle += 2.0 * Math.PI;\n  \t\t} else {\n  \t\t\tif (startAngle >= endAngle) startAngle -= 2.0 * Math.PI;\n  \t\t}\n  \t\tthis._segList.addPt(p0);\n  \t\tthis.addFilletArc(p, startAngle, endAngle, direction, radius);\n  \t\tthis._segList.addPt(p1);\n  \t},\n  \taddOutsideTurn: function addOutsideTurn(orientation, addStartPoint) {\n  \t\tif (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR) {\n  \t\t\tthis._segList.addPt(this._offset0.p1);\n  \t\t\treturn null;\n  \t\t}\n  \t\tif (this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {\n  \t\t\tthis.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance);\n  \t\t} else if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL) {\n  \t\t\tthis.addBevelJoin(this._offset0, this._offset1);\n  \t\t} else {\n  \t\t\tif (addStartPoint) this._segList.addPt(this._offset0.p1);\n  \t\t\tthis.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, orientation, this._distance);\n  \t\t\tthis._segList.addPt(this._offset1.p0);\n  \t\t}\n  \t},\n  \tcreateSquare: function createSquare(p) {\n  \t\tthis._segList.addPt(new Coordinate(p.x + this._distance, p.y + this._distance));\n  \t\tthis._segList.addPt(new Coordinate(p.x + this._distance, p.y - this._distance));\n  \t\tthis._segList.addPt(new Coordinate(p.x - this._distance, p.y - this._distance));\n  \t\tthis._segList.addPt(new Coordinate(p.x - this._distance, p.y + this._distance));\n  \t\tthis._segList.closeRing();\n  \t},\n  \taddSegments: function addSegments(pt, isForward) {\n  \t\tthis._segList.addPts(pt, isForward);\n  \t},\n  \taddFirstSegment: function addFirstSegment() {\n  \t\tthis._segList.addPt(this._offset1.p0);\n  \t},\n  \taddLastSegment: function addLastSegment() {\n  \t\tthis._segList.addPt(this._offset1.p1);\n  \t},\n  \tinitSideSegments: function initSideSegments(s1, s2, side) {\n  \t\tthis._s1 = s1;\n  \t\tthis._s2 = s2;\n  \t\tthis._side = side;\n  \t\tthis._seg1.setCoordinates(s1, s2);\n  \t\tthis.computeOffsetSegment(this._seg1, side, this._distance, this._offset1);\n  \t},\n  \taddLimitedMitreJoin: function addLimitedMitreJoin(offset0, offset1, distance, mitreLimit) {\n  \t\tvar basePt = this._seg0.p1;\n  \t\tvar ang0 = Angle.angle(basePt, this._seg0.p0);\n  \t\tvar ang1 = Angle.angle(basePt, this._seg1.p1);\n  \t\tvar angDiff = Angle.angleBetweenOriented(this._seg0.p0, basePt, this._seg1.p1);\n  \t\tvar angDiffHalf = angDiff / 2;\n  \t\tvar midAng = Angle.normalize(ang0 + angDiffHalf);\n  \t\tvar mitreMidAng = Angle.normalize(midAng + Math.PI);\n  \t\tvar mitreDist = mitreLimit * distance;\n  \t\tvar bevelDelta = mitreDist * Math.abs(Math.sin(angDiffHalf));\n  \t\tvar bevelHalfLen = distance - bevelDelta;\n  \t\tvar bevelMidX = basePt.x + mitreDist * Math.cos(mitreMidAng);\n  \t\tvar bevelMidY = basePt.y + mitreDist * Math.sin(mitreMidAng);\n  \t\tvar bevelMidPt = new Coordinate(bevelMidX, bevelMidY);\n  \t\tvar mitreMidLine = new LineSegment(basePt, bevelMidPt);\n  \t\tvar bevelEndLeft = mitreMidLine.pointAlongOffset(1.0, bevelHalfLen);\n  \t\tvar bevelEndRight = mitreMidLine.pointAlongOffset(1.0, -bevelHalfLen);\n  \t\tif (this._side === Position.LEFT) {\n  \t\t\tthis._segList.addPt(bevelEndLeft);\n  \t\t\tthis._segList.addPt(bevelEndRight);\n  \t\t} else {\n  \t\t\tthis._segList.addPt(bevelEndRight);\n  \t\t\tthis._segList.addPt(bevelEndLeft);\n  \t\t}\n  \t},\n  \tcomputeOffsetSegment: function computeOffsetSegment(seg, side, distance, offset) {\n  \t\tvar sideSign = side === Position.LEFT ? 1 : -1;\n  \t\tvar dx = seg.p1.x - seg.p0.x;\n  \t\tvar dy = seg.p1.y - seg.p0.y;\n  \t\tvar len = Math.sqrt(dx * dx + dy * dy);\n  \t\tvar ux = sideSign * distance * dx / len;\n  \t\tvar uy = sideSign * distance * dy / len;\n  \t\toffset.p0.x = seg.p0.x - uy;\n  \t\toffset.p0.y = seg.p0.y + ux;\n  \t\toffset.p1.x = seg.p1.x - uy;\n  \t\toffset.p1.y = seg.p1.y + ux;\n  \t},\n  \taddFilletArc: function addFilletArc(p, startAngle, endAngle, direction, radius) {\n  \t\tvar directionFactor = direction === CGAlgorithms.CLOCKWISE ? -1 : 1;\n  \t\tvar totalAngle = Math.abs(startAngle - endAngle);\n  \t\tvar nSegs = Math.trunc(totalAngle / this._filletAngleQuantum + 0.5);\n  \t\tif (nSegs < 1) return null;\n  \t\tvar initAngle = null,\n  \t\t    currAngleInc = null;\n  \t\tinitAngle = 0.0;\n  \t\tcurrAngleInc = totalAngle / nSegs;\n  \t\tvar currAngle = initAngle;\n  \t\tvar pt = new Coordinate();\n  \t\twhile (currAngle < totalAngle) {\n  \t\t\tvar angle = startAngle + directionFactor * currAngle;\n  \t\t\tpt.x = p.x + radius * Math.cos(angle);\n  \t\t\tpt.y = p.y + radius * Math.sin(angle);\n  \t\t\tthis._segList.addPt(pt);\n  \t\t\tcurrAngle += currAngleInc;\n  \t\t}\n  \t},\n  \taddInsideTurn: function addInsideTurn(orientation, addStartPoint) {\n  \t\tthis._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1);\n  \t\tif (this._li.hasIntersection()) {\n  \t\t\tthis._segList.addPt(this._li.getIntersection(0));\n  \t\t} else {\n  \t\t\tthis._hasNarrowConcaveAngle = true;\n  \t\t\tif (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) {\n  \t\t\t\tthis._segList.addPt(this._offset0.p1);\n  \t\t\t} else {\n  \t\t\t\tthis._segList.addPt(this._offset0.p1);\n  \t\t\t\tif (this._closingSegLengthFactor > 0) {\n  \t\t\t\t\tvar mid0 = new Coordinate((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));\n  \t\t\t\t\tthis._segList.addPt(mid0);\n  \t\t\t\t\tvar mid1 = new Coordinate((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));\n  \t\t\t\t\tthis._segList.addPt(mid1);\n  \t\t\t\t} else {\n  \t\t\t\t\tthis._segList.addPt(this._s1);\n  \t\t\t\t}\n  \t\t\t\tthis._segList.addPt(this._offset1.p0);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcreateCircle: function createCircle(p) {\n  \t\tvar pt = new Coordinate(p.x + this._distance, p.y);\n  \t\tthis._segList.addPt(pt);\n  \t\tthis.addFilletArc(p, 0.0, 2.0 * Math.PI, -1, this._distance);\n  \t\tthis._segList.closeRing();\n  \t},\n  \taddBevelJoin: function addBevelJoin(offset0, offset1) {\n  \t\tthis._segList.addPt(offset0.p1);\n  \t\tthis._segList.addPt(offset1.p0);\n  \t},\n  \tinit: function init(distance) {\n  \t\tthis._distance = distance;\n  \t\tthis._maxCurveSegmentError = distance * (1 - Math.cos(this._filletAngleQuantum / 2.0));\n  \t\tthis._segList = new OffsetSegmentString();\n  \t\tthis._segList.setPrecisionModel(this._precisionModel);\n  \t\tthis._segList.setMinimumVertexDistance(distance * OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);\n  \t},\n  \taddCollinear: function addCollinear(addStartPoint) {\n  \t\tthis._li.computeIntersection(this._s0, this._s1, this._s1, this._s2);\n  \t\tvar numInt = this._li.getIntersectionNum();\n  \t\tif (numInt >= 2) {\n  \t\t\tif (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL || this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {\n  \t\t\t\tif (addStartPoint) this._segList.addPt(this._offset0.p1);\n  \t\t\t\tthis._segList.addPt(this._offset1.p0);\n  \t\t\t} else {\n  \t\t\t\tthis.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, CGAlgorithms.CLOCKWISE, this._distance);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcloseRing: function closeRing() {\n  \t\tthis._segList.closeRing();\n  \t},\n  \thasNarrowConcaveAngle: function hasNarrowConcaveAngle() {\n  \t\treturn this._hasNarrowConcaveAngle;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn OffsetSegmentGenerator;\n  \t}\n  });\n  OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR = 1.0E-3;\n  OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = 1.0E-3;\n  OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1.0E-6;\n  OffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR = 80;\n\n  function OffsetCurveBuilder() {\n  \tthis._distance = 0.0;\n  \tthis._precisionModel = null;\n  \tthis._bufParams = null;\n  \tvar precisionModel = arguments[0],\n  \t    bufParams = arguments[1];\n  \tthis._precisionModel = precisionModel;\n  \tthis._bufParams = bufParams;\n  }\n  extend(OffsetCurveBuilder.prototype, {\n  \tgetOffsetCurve: function getOffsetCurve(inputPts, distance) {\n  \t\tthis._distance = distance;\n  \t\tif (distance === 0.0) return null;\n  \t\tvar isRightSide = distance < 0.0;\n  \t\tvar posDistance = Math.abs(distance);\n  \t\tvar segGen = this.getSegGen(posDistance);\n  \t\tif (inputPts.length <= 1) {\n  \t\t\tthis.computePointCurve(inputPts[0], segGen);\n  \t\t} else {\n  \t\t\tthis.computeOffsetCurve(inputPts, isRightSide, segGen);\n  \t\t}\n  \t\tvar curvePts = segGen.getCoordinates();\n  \t\tif (isRightSide) CoordinateArrays.reverse(curvePts);\n  \t\treturn curvePts;\n  \t},\n  \tcomputeSingleSidedBufferCurve: function computeSingleSidedBufferCurve(inputPts, isRightSide, segGen) {\n  \t\tvar distTol = this.simplifyTolerance(this._distance);\n  \t\tif (isRightSide) {\n  \t\t\tsegGen.addSegments(inputPts, true);\n  \t\t\tvar simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);\n  \t\t\tvar n2 = simp2.length - 1;\n  \t\t\tsegGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);\n  \t\t\tsegGen.addFirstSegment();\n  \t\t\tfor (var i = n2 - 2; i >= 0; i--) {\n  \t\t\t\tsegGen.addNextSegment(simp2[i], true);\n  \t\t\t}\n  \t\t} else {\n  \t\t\tsegGen.addSegments(inputPts, false);\n  \t\t\tvar simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);\n  \t\t\tvar n1 = simp1.length - 1;\n  \t\t\tsegGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);\n  \t\t\tsegGen.addFirstSegment();\n  \t\t\tfor (var i = 2; i <= n1; i++) {\n  \t\t\t\tsegGen.addNextSegment(simp1[i], true);\n  \t\t\t}\n  \t\t}\n  \t\tsegGen.addLastSegment();\n  \t\tsegGen.closeRing();\n  \t},\n  \tcomputeRingBufferCurve: function computeRingBufferCurve(inputPts, side, segGen) {\n  \t\tvar distTol = this.simplifyTolerance(this._distance);\n  \t\tif (side === Position.RIGHT) distTol = -distTol;\n  \t\tvar simp = BufferInputLineSimplifier.simplify(inputPts, distTol);\n  \t\tvar n = simp.length - 1;\n  \t\tsegGen.initSideSegments(simp[n - 1], simp[0], side);\n  \t\tfor (var i = 1; i <= n; i++) {\n  \t\t\tvar addStartPoint = i !== 1;\n  \t\t\tsegGen.addNextSegment(simp[i], addStartPoint);\n  \t\t}\n  \t\tsegGen.closeRing();\n  \t},\n  \tcomputeLineBufferCurve: function computeLineBufferCurve(inputPts, segGen) {\n  \t\tvar distTol = this.simplifyTolerance(this._distance);\n  \t\tvar simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);\n  \t\tvar n1 = simp1.length - 1;\n  \t\tsegGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);\n  \t\tfor (var i = 2; i <= n1; i++) {\n  \t\t\tsegGen.addNextSegment(simp1[i], true);\n  \t\t}\n  \t\tsegGen.addLastSegment();\n  \t\tsegGen.addLineEndCap(simp1[n1 - 1], simp1[n1]);\n  \t\tvar simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);\n  \t\tvar n2 = simp2.length - 1;\n  \t\tsegGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);\n  \t\tfor (var i = n2 - 2; i >= 0; i--) {\n  \t\t\tsegGen.addNextSegment(simp2[i], true);\n  \t\t}\n  \t\tsegGen.addLastSegment();\n  \t\tsegGen.addLineEndCap(simp2[1], simp2[0]);\n  \t\tsegGen.closeRing();\n  \t},\n  \tcomputePointCurve: function computePointCurve(pt, segGen) {\n  \t\tswitch (this._bufParams.getEndCapStyle()) {\n  \t\t\tcase BufferParameters.CAP_ROUND:\n  \t\t\t\tsegGen.createCircle(pt);\n  \t\t\t\tbreak;\n  \t\t\tcase BufferParameters.CAP_SQUARE:\n  \t\t\t\tsegGen.createSquare(pt);\n  \t\t\t\tbreak;\n  \t\t}\n  \t},\n  \tgetLineCurve: function getLineCurve(inputPts, distance) {\n  \t\tthis._distance = distance;\n  \t\tif (distance < 0.0 && !this._bufParams.isSingleSided()) return null;\n  \t\tif (distance === 0.0) return null;\n  \t\tvar posDistance = Math.abs(distance);\n  \t\tvar segGen = this.getSegGen(posDistance);\n  \t\tif (inputPts.length <= 1) {\n  \t\t\tthis.computePointCurve(inputPts[0], segGen);\n  \t\t} else {\n  \t\t\tif (this._bufParams.isSingleSided()) {\n  \t\t\t\tvar isRightSide = distance < 0.0;\n  \t\t\t\tthis.computeSingleSidedBufferCurve(inputPts, isRightSide, segGen);\n  \t\t\t} else this.computeLineBufferCurve(inputPts, segGen);\n  \t\t}\n  \t\tvar lineCoord = segGen.getCoordinates();\n  \t\treturn lineCoord;\n  \t},\n  \tgetBufferParameters: function getBufferParameters() {\n  \t\treturn this._bufParams;\n  \t},\n  \tsimplifyTolerance: function simplifyTolerance(bufDistance) {\n  \t\treturn bufDistance * this._bufParams.getSimplifyFactor();\n  \t},\n  \tgetRingCurve: function getRingCurve(inputPts, side, distance) {\n  \t\tthis._distance = distance;\n  \t\tif (inputPts.length <= 2) return this.getLineCurve(inputPts, distance);\n  \t\tif (distance === 0.0) {\n  \t\t\treturn OffsetCurveBuilder.copyCoordinates(inputPts);\n  \t\t}\n  \t\tvar segGen = this.getSegGen(distance);\n  \t\tthis.computeRingBufferCurve(inputPts, side, segGen);\n  \t\treturn segGen.getCoordinates();\n  \t},\n  \tcomputeOffsetCurve: function computeOffsetCurve(inputPts, isRightSide, segGen) {\n  \t\tvar distTol = this.simplifyTolerance(this._distance);\n  \t\tif (isRightSide) {\n  \t\t\tvar simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);\n  \t\t\tvar n2 = simp2.length - 1;\n  \t\t\tsegGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);\n  \t\t\tsegGen.addFirstSegment();\n  \t\t\tfor (var i = n2 - 2; i >= 0; i--) {\n  \t\t\t\tsegGen.addNextSegment(simp2[i], true);\n  \t\t\t}\n  \t\t} else {\n  \t\t\tvar simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);\n  \t\t\tvar n1 = simp1.length - 1;\n  \t\t\tsegGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);\n  \t\t\tsegGen.addFirstSegment();\n  \t\t\tfor (var i = 2; i <= n1; i++) {\n  \t\t\t\tsegGen.addNextSegment(simp1[i], true);\n  \t\t\t}\n  \t\t}\n  \t\tsegGen.addLastSegment();\n  \t},\n  \tgetSegGen: function getSegGen(distance) {\n  \t\treturn new OffsetSegmentGenerator(this._precisionModel, this._bufParams, distance);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn OffsetCurveBuilder;\n  \t}\n  });\n  OffsetCurveBuilder.copyCoordinates = function (pts) {\n  \tvar copy = new Array(pts.length).fill(null);\n  \tfor (var i = 0; i < copy.length; i++) {\n  \t\tcopy[i] = new Coordinate(pts[i]);\n  \t}\n  \treturn copy;\n  };\n\n  function SubgraphDepthLocater() {\n  \tthis._subgraphs = null;\n  \tthis._seg = new LineSegment();\n  \tthis._cga = new CGAlgorithms();\n  \tvar subgraphs = arguments[0];\n  \tthis._subgraphs = subgraphs;\n  }\n  extend(SubgraphDepthLocater.prototype, {\n  \tfindStabbedSegments: function findStabbedSegments() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar stabbingRayLeftPt = arguments[0];\n  \t\t\tvar stabbedSegments = new ArrayList();\n  \t\t\tfor (var i = this._subgraphs.iterator(); i.hasNext();) {\n  \t\t\t\tvar bsg = i.next();\n  \t\t\t\tvar env = bsg.getEnvelope();\n  \t\t\t\tif (stabbingRayLeftPt.y < env.getMinY() || stabbingRayLeftPt.y > env.getMaxY()) continue;\n  \t\t\t\tthis.findStabbedSegments(stabbingRayLeftPt, bsg.getDirectedEdges(), stabbedSegments);\n  \t\t\t}\n  \t\t\treturn stabbedSegments;\n  \t\t} else if (arguments.length === 3) {\n  \t\t\tif (hasInterface(arguments[2], List) && arguments[0] instanceof Coordinate && arguments[1] instanceof DirectedEdge) {\n  \t\t\t\tvar stabbingRayLeftPt = arguments[0],\n  \t\t\t\t    dirEdge = arguments[1],\n  \t\t\t\t    stabbedSegments = arguments[2];\n  \t\t\t\tvar pts = dirEdge.getEdge().getCoordinates();\n  \t\t\t\tfor (var i = 0; i < pts.length - 1; i++) {\n  \t\t\t\t\tthis._seg.p0 = pts[i];\n  \t\t\t\t\tthis._seg.p1 = pts[i + 1];\n  \t\t\t\t\tif (this._seg.p0.y > this._seg.p1.y) this._seg.reverse();\n  \t\t\t\t\tvar maxx = Math.max(this._seg.p0.x, this._seg.p1.x);\n  \t\t\t\t\tif (maxx < stabbingRayLeftPt.x) continue;\n  \t\t\t\t\tif (this._seg.isHorizontal()) continue;\n  \t\t\t\t\tif (stabbingRayLeftPt.y < this._seg.p0.y || stabbingRayLeftPt.y > this._seg.p1.y) continue;\n  \t\t\t\t\tif (CGAlgorithms.computeOrientation(this._seg.p0, this._seg.p1, stabbingRayLeftPt) === CGAlgorithms.RIGHT) continue;\n  \t\t\t\t\tvar depth = dirEdge.getDepth(Position.LEFT);\n  \t\t\t\t\tif (!this._seg.p0.equals(pts[i])) depth = dirEdge.getDepth(Position.RIGHT);\n  \t\t\t\t\tvar ds = new DepthSegment(this._seg, depth);\n  \t\t\t\t\tstabbedSegments.add(ds);\n  \t\t\t\t}\n  \t\t\t} else if (hasInterface(arguments[2], List) && arguments[0] instanceof Coordinate && hasInterface(arguments[1], List)) {\n  \t\t\t\tvar stabbingRayLeftPt = arguments[0],\n  \t\t\t\t    dirEdges = arguments[1],\n  \t\t\t\t    stabbedSegments = arguments[2];\n  \t\t\t\tfor (var i = dirEdges.iterator(); i.hasNext();) {\n  \t\t\t\t\tvar de = i.next();\n  \t\t\t\t\tif (!de.isForward()) continue;\n  \t\t\t\t\tthis.findStabbedSegments(stabbingRayLeftPt, de, stabbedSegments);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetDepth: function getDepth(p) {\n  \t\tvar stabbedSegments = this.findStabbedSegments(p);\n  \t\tif (stabbedSegments.size() === 0) return 0;\n  \t\tvar ds = Collections.min(stabbedSegments);\n  \t\treturn ds._leftDepth;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SubgraphDepthLocater;\n  \t}\n  });\n  function DepthSegment() {\n  \tthis._upwardSeg = null;\n  \tthis._leftDepth = null;\n  \tvar seg = arguments[0],\n  \t    depth = arguments[1];\n  \tthis._upwardSeg = new LineSegment(seg);\n  \tthis._leftDepth = depth;\n  }\n  extend(DepthSegment.prototype, {\n  \tcompareTo: function compareTo(obj) {\n  \t\tvar other = obj;\n  \t\tif (this._upwardSeg.minX() >= other._upwardSeg.maxX()) return 1;\n  \t\tif (this._upwardSeg.maxX() <= other._upwardSeg.minX()) return -1;\n  \t\tvar orientIndex = this._upwardSeg.orientationIndex(other._upwardSeg);\n  \t\tif (orientIndex !== 0) return orientIndex;\n  \t\torientIndex = -1 * other._upwardSeg.orientationIndex(this._upwardSeg);\n  \t\tif (orientIndex !== 0) return orientIndex;\n  \t\treturn this._upwardSeg.compareTo(other._upwardSeg);\n  \t},\n  \tcompareX: function compareX(seg0, seg1) {\n  \t\tvar compare0 = seg0.p0.compareTo(seg1.p0);\n  \t\tif (compare0 !== 0) return compare0;\n  \t\treturn seg0.p1.compareTo(seg1.p1);\n  \t},\n  \ttoString: function toString() {\n  \t\treturn this._upwardSeg.toString();\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn DepthSegment;\n  \t}\n  });\n  SubgraphDepthLocater.DepthSegment = DepthSegment;\n\n  function OffsetCurveSetBuilder() {\n  \tthis._inputGeom = null;\n  \tthis._distance = null;\n  \tthis._curveBuilder = null;\n  \tthis._curveList = new ArrayList();\n  \tvar inputGeom = arguments[0],\n  \t    distance = arguments[1],\n  \t    curveBuilder = arguments[2];\n  \tthis._inputGeom = inputGeom;\n  \tthis._distance = distance;\n  \tthis._curveBuilder = curveBuilder;\n  }\n  extend(OffsetCurveSetBuilder.prototype, {\n  \taddPoint: function addPoint(p) {\n  \t\tif (this._distance <= 0.0) return null;\n  \t\tvar coord = p.getCoordinates();\n  \t\tvar curve = this._curveBuilder.getLineCurve(coord, this._distance);\n  \t\tthis.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);\n  \t},\n  \taddPolygon: function addPolygon(p) {\n  \t\tvar offsetDistance = this._distance;\n  \t\tvar offsetSide = Position.LEFT;\n  \t\tif (this._distance < 0.0) {\n  \t\t\toffsetDistance = -this._distance;\n  \t\t\toffsetSide = Position.RIGHT;\n  \t\t}\n  \t\tvar shell = p.getExteriorRing();\n  \t\tvar shellCoord = CoordinateArrays.removeRepeatedPoints(shell.getCoordinates());\n  \t\tif (this._distance < 0.0 && this.isErodedCompletely(shell, this._distance)) return null;\n  \t\tif (this._distance <= 0.0 && shellCoord.length < 3) return null;\n  \t\tthis.addPolygonRing(shellCoord, offsetDistance, offsetSide, Location.EXTERIOR, Location.INTERIOR);\n  \t\tfor (var i = 0; i < p.getNumInteriorRing(); i++) {\n  \t\t\tvar hole = p.getInteriorRingN(i);\n  \t\t\tvar holeCoord = CoordinateArrays.removeRepeatedPoints(hole.getCoordinates());\n  \t\t\tif (this._distance > 0.0 && this.isErodedCompletely(hole, -this._distance)) continue;\n  \t\t\tthis.addPolygonRing(holeCoord, offsetDistance, Position.opposite(offsetSide), Location.INTERIOR, Location.EXTERIOR);\n  \t\t}\n  \t},\n  \tisTriangleErodedCompletely: function isTriangleErodedCompletely(triangleCoord, bufferDistance) {\n  \t\tvar tri = new Triangle$1(triangleCoord[0], triangleCoord[1], triangleCoord[2]);\n  \t\tvar inCentre = tri.inCentre();\n  \t\tvar distToCentre = CGAlgorithms.distancePointLine(inCentre, tri.p0, tri.p1);\n  \t\treturn distToCentre < Math.abs(bufferDistance);\n  \t},\n  \taddLineString: function addLineString(line) {\n  \t\tif (this._distance <= 0.0 && !this._curveBuilder.getBufferParameters().isSingleSided()) return null;\n  \t\tvar coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());\n  \t\tvar curve = this._curveBuilder.getLineCurve(coord, this._distance);\n  \t\tthis.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);\n  \t},\n  \taddCurve: function addCurve(coord, leftLoc, rightLoc) {\n  \t\tif (coord === null || coord.length < 2) return null;\n  \t\tvar e = new NodedSegmentString(coord, new Label(0, Location.BOUNDARY, leftLoc, rightLoc));\n  \t\tthis._curveList.add(e);\n  \t},\n  \tgetCurves: function getCurves() {\n  \t\tthis.add(this._inputGeom);\n  \t\treturn this._curveList;\n  \t},\n  \taddPolygonRing: function addPolygonRing(coord, offsetDistance, side, cwLeftLoc, cwRightLoc) {\n  \t\tif (offsetDistance === 0.0 && coord.length < LinearRing.MINIMUM_VALID_SIZE) return null;\n  \t\tvar leftLoc = cwLeftLoc;\n  \t\tvar rightLoc = cwRightLoc;\n  \t\tif (coord.length >= LinearRing.MINIMUM_VALID_SIZE && CGAlgorithms.isCCW(coord)) {\n  \t\t\tleftLoc = cwRightLoc;\n  \t\t\trightLoc = cwLeftLoc;\n  \t\t\tside = Position.opposite(side);\n  \t\t}\n  \t\tvar curve = this._curveBuilder.getRingCurve(coord, side, offsetDistance);\n  \t\tthis.addCurve(curve, leftLoc, rightLoc);\n  \t},\n  \tadd: function add(g) {\n  \t\tif (g.isEmpty()) return null;\n  \t\tif (g instanceof Polygon) this.addPolygon(g);else if (g instanceof LineString) this.addLineString(g);else if (g instanceof Point) this.addPoint(g);else if (g instanceof MultiPoint) this.addCollection(g);else if (g instanceof MultiLineString) this.addCollection(g);else if (g instanceof MultiPolygon) this.addCollection(g);else if (g instanceof GeometryCollection) this.addCollection(g);else throw new UnsupportedOperationException(g.getClass().getName());\n  \t},\n  \tisErodedCompletely: function isErodedCompletely(ring, bufferDistance) {\n  \t\tvar ringCoord = ring.getCoordinates();\n  \t\tif (ringCoord.length < 4) return bufferDistance < 0;\n  \t\tif (ringCoord.length === 4) return this.isTriangleErodedCompletely(ringCoord, bufferDistance);\n  \t\tvar env = ring.getEnvelopeInternal();\n  \t\tvar envMinDimension = Math.min(env.getHeight(), env.getWidth());\n  \t\tif (bufferDistance < 0.0 && 2 * Math.abs(bufferDistance) > envMinDimension) return true;\n  \t\treturn false;\n  \t},\n  \taddCollection: function addCollection(gc) {\n  \t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n  \t\t\tvar g = gc.getGeometryN(i);\n  \t\t\tthis.add(g);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn OffsetCurveSetBuilder;\n  \t}\n  });\n\n  function IntersectionAdder() {\n  \tthis._hasIntersection = false;\n  \tthis._hasProper = false;\n  \tthis._hasProperInterior = false;\n  \tthis._hasInterior = false;\n  \tthis._properIntersectionPoint = null;\n  \tthis._li = null;\n  \tthis._isSelfIntersection = null;\n  \tthis.numIntersections = 0;\n  \tthis.numInteriorIntersections = 0;\n  \tthis.numProperIntersections = 0;\n  \tthis.numTests = 0;\n  \tvar li = arguments[0];\n  \tthis._li = li;\n  }\n  extend(IntersectionAdder.prototype, {\n  \tisTrivialIntersection: function isTrivialIntersection(e0, segIndex0, e1, segIndex1) {\n  \t\tif (e0 === e1) {\n  \t\t\tif (this._li.getIntersectionNum() === 1) {\n  \t\t\t\tif (IntersectionAdder.isAdjacentSegments(segIndex0, segIndex1)) return true;\n  \t\t\t\tif (e0.isClosed()) {\n  \t\t\t\t\tvar maxSegIndex = e0.size() - 1;\n  \t\t\t\t\tif (segIndex0 === 0 && segIndex1 === maxSegIndex || segIndex1 === 0 && segIndex0 === maxSegIndex) {\n  \t\t\t\t\t\treturn true;\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tgetProperIntersectionPoint: function getProperIntersectionPoint() {\n  \t\treturn this._properIntersectionPoint;\n  \t},\n  \thasProperInteriorIntersection: function hasProperInteriorIntersection() {\n  \t\treturn this._hasProperInterior;\n  \t},\n  \tgetLineIntersector: function getLineIntersector() {\n  \t\treturn this._li;\n  \t},\n  \thasProperIntersection: function hasProperIntersection() {\n  \t\treturn this._hasProper;\n  \t},\n  \tprocessIntersections: function processIntersections(e0, segIndex0, e1, segIndex1) {\n  \t\tif (e0 === e1 && segIndex0 === segIndex1) return null;\n  \t\tthis.numTests++;\n  \t\tvar p00 = e0.getCoordinates()[segIndex0];\n  \t\tvar p01 = e0.getCoordinates()[segIndex0 + 1];\n  \t\tvar p10 = e1.getCoordinates()[segIndex1];\n  \t\tvar p11 = e1.getCoordinates()[segIndex1 + 1];\n  \t\tthis._li.computeIntersection(p00, p01, p10, p11);\n  \t\tif (this._li.hasIntersection()) {\n  \t\t\tthis.numIntersections++;\n  \t\t\tif (this._li.isInteriorIntersection()) {\n  \t\t\t\tthis.numInteriorIntersections++;\n  \t\t\t\tthis._hasInterior = true;\n  \t\t\t}\n  \t\t\tif (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {\n  \t\t\t\tthis._hasIntersection = true;\n  \t\t\t\te0.addIntersections(this._li, segIndex0, 0);\n  \t\t\t\te1.addIntersections(this._li, segIndex1, 1);\n  \t\t\t\tif (this._li.isProper()) {\n  \t\t\t\t\tthis.numProperIntersections++;\n  \t\t\t\t\tthis._hasProper = true;\n  \t\t\t\t\tthis._hasProperInterior = true;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \thasIntersection: function hasIntersection() {\n  \t\treturn this._hasIntersection;\n  \t},\n  \tisDone: function isDone() {\n  \t\treturn false;\n  \t},\n  \thasInteriorIntersection: function hasInteriorIntersection() {\n  \t\treturn this._hasInterior;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [SegmentIntersector];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn IntersectionAdder;\n  \t}\n  });\n  IntersectionAdder.isAdjacentSegments = function (i1, i2) {\n  \treturn Math.abs(i1 - i2) === 1;\n  };\n\n  function BufferBuilder() {\n  \tthis._bufParams = null;\n  \tthis._workingPrecisionModel = null;\n  \tthis._workingNoder = null;\n  \tthis._geomFact = null;\n  \tthis._graph = null;\n  \tthis._edgeList = new EdgeList();\n  \tvar bufParams = arguments[0];\n  \tthis._bufParams = bufParams;\n  }\n  extend(BufferBuilder.prototype, {\n  \tsetWorkingPrecisionModel: function setWorkingPrecisionModel(pm) {\n  \t\tthis._workingPrecisionModel = pm;\n  \t},\n  \tinsertUniqueEdge: function insertUniqueEdge(e) {\n  \t\tvar existingEdge = this._edgeList.findEqualEdge(e);\n  \t\tif (existingEdge !== null) {\n  \t\t\tvar existingLabel = existingEdge.getLabel();\n  \t\t\tvar labelToMerge = e.getLabel();\n  \t\t\tif (!existingEdge.isPointwiseEqual(e)) {\n  \t\t\t\tlabelToMerge = new Label(e.getLabel());\n  \t\t\t\tlabelToMerge.flip();\n  \t\t\t}\n  \t\t\texistingLabel.merge(labelToMerge);\n  \t\t\tvar mergeDelta = BufferBuilder.depthDelta(labelToMerge);\n  \t\t\tvar existingDelta = existingEdge.getDepthDelta();\n  \t\t\tvar newDelta = existingDelta + mergeDelta;\n  \t\t\texistingEdge.setDepthDelta(newDelta);\n  \t\t} else {\n  \t\t\tthis._edgeList.add(e);\n  \t\t\te.setDepthDelta(BufferBuilder.depthDelta(e.getLabel()));\n  \t\t}\n  \t},\n  \tbuildSubgraphs: function buildSubgraphs(subgraphList, polyBuilder) {\n  \t\tvar processedGraphs = new ArrayList();\n  \t\tfor (var i = subgraphList.iterator(); i.hasNext();) {\n  \t\t\tvar subgraph = i.next();\n  \t\t\tvar p = subgraph.getRightmostCoordinate();\n  \t\t\tvar locater = new SubgraphDepthLocater(processedGraphs);\n  \t\t\tvar outsideDepth = locater.getDepth(p);\n  \t\t\tsubgraph.computeDepth(outsideDepth);\n  \t\t\tsubgraph.findResultEdges();\n  \t\t\tprocessedGraphs.add(subgraph);\n  \t\t\tpolyBuilder.add(subgraph.getDirectedEdges(), subgraph.getNodes());\n  \t\t}\n  \t},\n  \tcreateSubgraphs: function createSubgraphs(graph) {\n  \t\tvar subgraphList = new ArrayList();\n  \t\tfor (var i = graph.getNodes().iterator(); i.hasNext();) {\n  \t\t\tvar node = i.next();\n  \t\t\tif (!node.isVisited()) {\n  \t\t\t\tvar subgraph = new BufferSubgraph();\n  \t\t\t\tsubgraph.create(node);\n  \t\t\t\tsubgraphList.add(subgraph);\n  \t\t\t}\n  \t\t}\n  \t\tCollections.sort(subgraphList, Collections.reverseOrder());\n  \t\treturn subgraphList;\n  \t},\n  \tcreateEmptyResultGeometry: function createEmptyResultGeometry() {\n  \t\tvar emptyGeom = this._geomFact.createPolygon();\n  \t\treturn emptyGeom;\n  \t},\n  \tgetNoder: function getNoder(precisionModel) {\n  \t\tif (this._workingNoder !== null) return this._workingNoder;\n  \t\tvar noder = new MCIndexNoder();\n  \t\tvar li = new RobustLineIntersector();\n  \t\tli.setPrecisionModel(precisionModel);\n  \t\tnoder.setSegmentIntersector(new IntersectionAdder(li));\n  \t\treturn noder;\n  \t},\n  \tbuffer: function buffer(g, distance) {\n  \t\tvar precisionModel = this._workingPrecisionModel;\n  \t\tif (precisionModel === null) precisionModel = g.getPrecisionModel();\n  \t\tthis._geomFact = g.getFactory();\n  \t\tvar curveBuilder = new OffsetCurveBuilder(precisionModel, this._bufParams);\n  \t\tvar curveSetBuilder = new OffsetCurveSetBuilder(g, distance, curveBuilder);\n  \t\tvar bufferSegStrList = curveSetBuilder.getCurves();\n  \t\tif (bufferSegStrList.size() <= 0) {\n  \t\t\treturn this.createEmptyResultGeometry();\n  \t\t}\n  \t\tthis.computeNodedEdges(bufferSegStrList, precisionModel);\n  \t\tthis._graph = new PlanarGraph(new OverlayNodeFactory());\n  \t\tthis._graph.addEdges(this._edgeList.getEdges());\n  \t\tvar subgraphList = this.createSubgraphs(this._graph);\n  \t\tvar polyBuilder = new PolygonBuilder(this._geomFact);\n  \t\tthis.buildSubgraphs(subgraphList, polyBuilder);\n  \t\tvar resultPolyList = polyBuilder.getPolygons();\n  \t\tif (resultPolyList.size() <= 0) {\n  \t\t\treturn this.createEmptyResultGeometry();\n  \t\t}\n  \t\tvar resultGeom = this._geomFact.buildGeometry(resultPolyList);\n  \t\treturn resultGeom;\n  \t},\n  \tcomputeNodedEdges: function computeNodedEdges(bufferSegStrList, precisionModel) {\n  \t\tvar noder = this.getNoder(precisionModel);\n  \t\tnoder.computeNodes(bufferSegStrList);\n  \t\tvar nodedSegStrings = noder.getNodedSubstrings();\n  \t\tfor (var i = nodedSegStrings.iterator(); i.hasNext();) {\n  \t\t\tvar segStr = i.next();\n  \t\t\tvar pts = segStr.getCoordinates();\n  \t\t\tif (pts.length === 2 && pts[0].equals2D(pts[1])) continue;\n  \t\t\tvar oldLabel = segStr.getData();\n  \t\t\tvar edge = new Edge(segStr.getCoordinates(), new Label(oldLabel));\n  \t\t\tthis.insertUniqueEdge(edge);\n  \t\t}\n  \t},\n  \tsetNoder: function setNoder(noder) {\n  \t\tthis._workingNoder = noder;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn BufferBuilder;\n  \t}\n  });\n  BufferBuilder.depthDelta = function (label) {\n  \tvar lLoc = label.getLocation(0, Position.LEFT);\n  \tvar rLoc = label.getLocation(0, Position.RIGHT);\n  \tif (lLoc === Location.INTERIOR && rLoc === Location.EXTERIOR) return 1;else if (lLoc === Location.EXTERIOR && rLoc === Location.INTERIOR) return -1;\n  \treturn 0;\n  };\n  BufferBuilder.convertSegStrings = function (it) {\n  \tvar fact = new GeometryFactory();\n  \tvar lines = new ArrayList();\n  \twhile (it.hasNext()) {\n  \t\tvar ss = it.next();\n  \t\tvar line = fact.createLineString(ss.getCoordinates());\n  \t\tlines.add(line);\n  \t}\n  \treturn fact.buildGeometry(lines);\n  };\n\n  function NodingValidator() {\n  \tthis._li = new RobustLineIntersector();\n  \tthis._segStrings = null;\n  \tvar segStrings = arguments[0];\n  \tthis._segStrings = segStrings;\n  }\n  extend(NodingValidator.prototype, {\n  \tcheckEndPtVertexIntersections: function checkEndPtVertexIntersections() {\n  \t\tif (arguments.length === 0) {\n  \t\t\tfor (var i = this._segStrings.iterator(); i.hasNext();) {\n  \t\t\t\tvar ss = i.next();\n  \t\t\t\tvar pts = ss.getCoordinates();\n  \t\t\t\tthis.checkEndPtVertexIntersections(pts[0], this._segStrings);\n  \t\t\t\tthis.checkEndPtVertexIntersections(pts[pts.length - 1], this._segStrings);\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar testPt = arguments[0],\n  \t\t\t    segStrings = arguments[1];\n  \t\t\tfor (var i = segStrings.iterator(); i.hasNext();) {\n  \t\t\t\tvar ss = i.next();\n  \t\t\t\tvar pts = ss.getCoordinates();\n  \t\t\t\tfor (var j = 1; j < pts.length - 1; j++) {\n  \t\t\t\t\tif (pts[j].equals(testPt)) throw new RuntimeException(\"found endpt/interior pt intersection at index \" + j + \" :pt \" + testPt);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcheckInteriorIntersections: function checkInteriorIntersections() {\n  \t\tif (arguments.length === 0) {\n  \t\t\tfor (var i = this._segStrings.iterator(); i.hasNext();) {\n  \t\t\t\tvar ss0 = i.next();\n  \t\t\t\tfor (var j = this._segStrings.iterator(); j.hasNext();) {\n  \t\t\t\t\tvar ss1 = j.next();\n  \t\t\t\t\tthis.checkInteriorIntersections(ss0, ss1);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar ss0 = arguments[0],\n  \t\t\t    ss1 = arguments[1];\n  \t\t\tvar pts0 = ss0.getCoordinates();\n  \t\t\tvar pts1 = ss1.getCoordinates();\n  \t\t\tfor (var i0 = 0; i0 < pts0.length - 1; i0++) {\n  \t\t\t\tfor (var i1 = 0; i1 < pts1.length - 1; i1++) {\n  \t\t\t\t\tthis.checkInteriorIntersections(ss0, i0, ss1, i1);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} else if (arguments.length === 4) {\n  \t\t\tvar e0 = arguments[0],\n  \t\t\t    segIndex0 = arguments[1],\n  \t\t\t    e1 = arguments[2],\n  \t\t\t    segIndex1 = arguments[3];\n  \t\t\tif (e0 === e1 && segIndex0 === segIndex1) return null;\n  \t\t\tvar p00 = e0.getCoordinates()[segIndex0];\n  \t\t\tvar p01 = e0.getCoordinates()[segIndex0 + 1];\n  \t\t\tvar p10 = e1.getCoordinates()[segIndex1];\n  \t\t\tvar p11 = e1.getCoordinates()[segIndex1 + 1];\n  \t\t\tthis._li.computeIntersection(p00, p01, p10, p11);\n  \t\t\tif (this._li.hasIntersection()) {\n  \t\t\t\tif (this._li.isProper() || this.hasInteriorIntersection(this._li, p00, p01) || this.hasInteriorIntersection(this._li, p10, p11)) {\n  \t\t\t\t\tthrow new RuntimeException(\"found non-noded intersection at \" + p00 + \"-\" + p01 + \" and \" + p10 + \"-\" + p11);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcheckValid: function checkValid() {\n  \t\tthis.checkEndPtVertexIntersections();\n  \t\tthis.checkInteriorIntersections();\n  \t\tthis.checkCollapses();\n  \t},\n  \tcheckCollapses: function checkCollapses() {\n  \t\tif (arguments.length === 0) {\n  \t\t\tfor (var i = this._segStrings.iterator(); i.hasNext();) {\n  \t\t\t\tvar ss = i.next();\n  \t\t\t\tthis.checkCollapses(ss);\n  \t\t\t}\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tvar ss = arguments[0];\n  \t\t\tvar pts = ss.getCoordinates();\n  \t\t\tfor (var i = 0; i < pts.length - 2; i++) {\n  \t\t\t\tthis.checkCollapse(pts[i], pts[i + 1], pts[i + 2]);\n  \t\t\t}\n  \t\t}\n  \t},\n  \thasInteriorIntersection: function hasInteriorIntersection(li, p0, p1) {\n  \t\tfor (var i = 0; i < li.getIntersectionNum(); i++) {\n  \t\t\tvar intPt = li.getIntersection(i);\n  \t\t\tif (!(intPt.equals(p0) || intPt.equals(p1))) return true;\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tcheckCollapse: function checkCollapse(p0, p1, p2) {\n  \t\tif (p0.equals(p2)) throw new RuntimeException(\"found non-noded collapse at \" + NodingValidator.fact.createLineString([p0, p1, p2]));\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn NodingValidator;\n  \t}\n  });\n  NodingValidator.fact = new GeometryFactory();\n\n  function HotPixel() {\n  \tthis._li = null;\n  \tthis._pt = null;\n  \tthis._originalPt = null;\n  \tthis._ptScaled = null;\n  \tthis._p0Scaled = null;\n  \tthis._p1Scaled = null;\n  \tthis._scaleFactor = null;\n  \tthis._minx = null;\n  \tthis._maxx = null;\n  \tthis._miny = null;\n  \tthis._maxy = null;\n  \tthis._corner = new Array(4).fill(null);\n  \tthis._safeEnv = null;\n  \tvar pt = arguments[0],\n  \t    scaleFactor = arguments[1],\n  \t    li = arguments[2];\n  \tthis._originalPt = pt;\n  \tthis._pt = pt;\n  \tthis._scaleFactor = scaleFactor;\n  \tthis._li = li;\n  \tif (scaleFactor <= 0) throw new IllegalArgumentException(\"Scale factor must be non-zero\");\n  \tif (scaleFactor !== 1.0) {\n  \t\tthis._pt = new Coordinate(this.scale(pt.x), this.scale(pt.y));\n  \t\tthis._p0Scaled = new Coordinate();\n  \t\tthis._p1Scaled = new Coordinate();\n  \t}\n  \tthis.initCorners(this._pt);\n  }\n  extend(HotPixel.prototype, {\n  \tintersectsScaled: function intersectsScaled(p0, p1) {\n  \t\tvar segMinx = Math.min(p0.x, p1.x);\n  \t\tvar segMaxx = Math.max(p0.x, p1.x);\n  \t\tvar segMiny = Math.min(p0.y, p1.y);\n  \t\tvar segMaxy = Math.max(p0.y, p1.y);\n  \t\tvar isOutsidePixelEnv = this._maxx < segMinx || this._minx > segMaxx || this._maxy < segMiny || this._miny > segMaxy;\n  \t\tif (isOutsidePixelEnv) return false;\n  \t\tvar intersects = this.intersectsToleranceSquare(p0, p1);\n  \t\tAssert.isTrue(!(isOutsidePixelEnv && intersects), \"Found bad envelope test\");\n  \t\treturn intersects;\n  \t},\n  \tinitCorners: function initCorners(pt) {\n  \t\tvar tolerance = 0.5;\n  \t\tthis._minx = pt.x - tolerance;\n  \t\tthis._maxx = pt.x + tolerance;\n  \t\tthis._miny = pt.y - tolerance;\n  \t\tthis._maxy = pt.y + tolerance;\n  \t\tthis._corner[0] = new Coordinate(this._maxx, this._maxy);\n  \t\tthis._corner[1] = new Coordinate(this._minx, this._maxy);\n  \t\tthis._corner[2] = new Coordinate(this._minx, this._miny);\n  \t\tthis._corner[3] = new Coordinate(this._maxx, this._miny);\n  \t},\n  \tintersects: function intersects(p0, p1) {\n  \t\tif (this._scaleFactor === 1.0) return this.intersectsScaled(p0, p1);\n  \t\tthis.copyScaled(p0, this._p0Scaled);\n  \t\tthis.copyScaled(p1, this._p1Scaled);\n  \t\treturn this.intersectsScaled(this._p0Scaled, this._p1Scaled);\n  \t},\n  \tscale: function scale(val) {\n  \t\treturn Math.round(val * this._scaleFactor);\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\treturn this._originalPt;\n  \t},\n  \tcopyScaled: function copyScaled(p, pScaled) {\n  \t\tpScaled.x = this.scale(p.x);\n  \t\tpScaled.y = this.scale(p.y);\n  \t},\n  \tgetSafeEnvelope: function getSafeEnvelope() {\n  \t\tif (this._safeEnv === null) {\n  \t\t\tvar safeTolerance = HotPixel.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;\n  \t\t\tthis._safeEnv = new Envelope(this._originalPt.x - safeTolerance, this._originalPt.x + safeTolerance, this._originalPt.y - safeTolerance, this._originalPt.y + safeTolerance);\n  \t\t}\n  \t\treturn this._safeEnv;\n  \t},\n  \tintersectsPixelClosure: function intersectsPixelClosure(p0, p1) {\n  \t\tthis._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);\n  \t\tif (this._li.hasIntersection()) return true;\n  \t\tthis._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);\n  \t\tif (this._li.hasIntersection()) return true;\n  \t\tthis._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);\n  \t\tif (this._li.hasIntersection()) return true;\n  \t\tthis._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);\n  \t\tif (this._li.hasIntersection()) return true;\n  \t\treturn false;\n  \t},\n  \tintersectsToleranceSquare: function intersectsToleranceSquare(p0, p1) {\n  \t\tvar intersectsLeft = false;\n  \t\tvar intersectsBottom = false;\n  \t\tthis._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);\n  \t\tif (this._li.isProper()) return true;\n  \t\tthis._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);\n  \t\tif (this._li.isProper()) return true;\n  \t\tif (this._li.hasIntersection()) intersectsLeft = true;\n  \t\tthis._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);\n  \t\tif (this._li.isProper()) return true;\n  \t\tif (this._li.hasIntersection()) intersectsBottom = true;\n  \t\tthis._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);\n  \t\tif (this._li.isProper()) return true;\n  \t\tif (intersectsLeft && intersectsBottom) return true;\n  \t\tif (p0.equals(this._pt)) return true;\n  \t\tif (p1.equals(this._pt)) return true;\n  \t\treturn false;\n  \t},\n  \taddSnappedNode: function addSnappedNode(segStr, segIndex) {\n  \t\tvar p0 = segStr.getCoordinate(segIndex);\n  \t\tvar p1 = segStr.getCoordinate(segIndex + 1);\n  \t\tif (this.intersects(p0, p1)) {\n  \t\t\tsegStr.addIntersection(this.getCoordinate(), segIndex);\n  \t\t\treturn true;\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn HotPixel;\n  \t}\n  });\n  HotPixel.SAFE_ENV_EXPANSION_FACTOR = 0.75;\n\n  function MCIndexPointSnapper() {\n  \tthis._index = null;\n  \tvar index = arguments[0];\n  \tthis._index = index;\n  }\n  extend(MCIndexPointSnapper.prototype, {\n  \tsnap: function snap() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar hotPixel = arguments[0];\n  \t\t\treturn this.snap(hotPixel, null, -1);\n  \t\t} else if (arguments.length === 3) {\n  \t\t\tvar hotPixel = arguments[0],\n  \t\t\t    parentEdge = arguments[1],\n  \t\t\t    hotPixelVertexIndex = arguments[2];\n  \t\t\tvar pixelEnv = hotPixel.getSafeEnvelope();\n  \t\t\tvar hotPixelSnapAction = new HotPixelSnapAction(hotPixel, parentEdge, hotPixelVertexIndex);\n  \t\t\tthis._index.query(pixelEnv, {\n  \t\t\t\tinterfaces_: function interfaces_() {\n  \t\t\t\t\treturn [ItemVisitor];\n  \t\t\t\t},\n  \t\t\t\tvisitItem: function visitItem(item) {\n  \t\t\t\t\tvar testChain = item;\n  \t\t\t\t\ttestChain.select(pixelEnv, hotPixelSnapAction);\n  \t\t\t\t}\n  \t\t\t});\n  \t\t\treturn hotPixelSnapAction.isNodeAdded();\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MCIndexPointSnapper;\n  \t}\n  });\n  function HotPixelSnapAction() {\n  \tMonotoneChainSelectAction.apply(this);\n  \tthis._hotPixel = null;\n  \tthis._parentEdge = null;\n  \tthis._hotPixelVertexIndex = null;\n  \tthis._isNodeAdded = false;\n  \tvar hotPixel = arguments[0],\n  \t    parentEdge = arguments[1],\n  \t    hotPixelVertexIndex = arguments[2];\n  \tthis._hotPixel = hotPixel;\n  \tthis._parentEdge = parentEdge;\n  \tthis._hotPixelVertexIndex = hotPixelVertexIndex;\n  }\n  inherits$1(HotPixelSnapAction, MonotoneChainSelectAction);\n  extend(HotPixelSnapAction.prototype, {\n  \tisNodeAdded: function isNodeAdded() {\n  \t\treturn this._isNodeAdded;\n  \t},\n  \tselect: function select() {\n  \t\tif (arguments.length === 2) {\n  \t\t\tvar mc = arguments[0],\n  \t\t\t    startIndex = arguments[1];\n  \t\t\tvar ss = mc.getContext();\n  \t\t\tif (this._parentEdge !== null) {\n  \t\t\t\tif (ss === this._parentEdge && startIndex === this._hotPixelVertexIndex) return null;\n  \t\t\t}\n  \t\t\tthis._isNodeAdded = this._hotPixel.addSnappedNode(ss, startIndex);\n  \t\t} else return MonotoneChainSelectAction.prototype.select.apply(this, arguments);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn HotPixelSnapAction;\n  \t}\n  });\n  MCIndexPointSnapper.HotPixelSnapAction = HotPixelSnapAction;\n\n  function InteriorIntersectionFinderAdder() {\n  \tthis._li = null;\n  \tthis._interiorIntersections = null;\n  \tvar li = arguments[0];\n  \tthis._li = li;\n  \tthis._interiorIntersections = new ArrayList();\n  }\n  extend(InteriorIntersectionFinderAdder.prototype, {\n  \tprocessIntersections: function processIntersections(e0, segIndex0, e1, segIndex1) {\n  \t\tif (e0 === e1 && segIndex0 === segIndex1) return null;\n  \t\tvar p00 = e0.getCoordinates()[segIndex0];\n  \t\tvar p01 = e0.getCoordinates()[segIndex0 + 1];\n  \t\tvar p10 = e1.getCoordinates()[segIndex1];\n  \t\tvar p11 = e1.getCoordinates()[segIndex1 + 1];\n  \t\tthis._li.computeIntersection(p00, p01, p10, p11);\n  \t\tif (this._li.hasIntersection()) {\n  \t\t\tif (this._li.isInteriorIntersection()) {\n  \t\t\t\tfor (var intIndex = 0; intIndex < this._li.getIntersectionNum(); intIndex++) {\n  \t\t\t\t\tthis._interiorIntersections.add(this._li.getIntersection(intIndex));\n  \t\t\t\t}\n  \t\t\t\te0.addIntersections(this._li, segIndex0, 0);\n  \t\t\t\te1.addIntersections(this._li, segIndex1, 1);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tisDone: function isDone() {\n  \t\treturn false;\n  \t},\n  \tgetInteriorIntersections: function getInteriorIntersections() {\n  \t\treturn this._interiorIntersections;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [SegmentIntersector];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn InteriorIntersectionFinderAdder;\n  \t}\n  });\n\n  function MCIndexSnapRounder() {\n  \tthis._pm = null;\n  \tthis._li = null;\n  \tthis._scaleFactor = null;\n  \tthis._noder = null;\n  \tthis._pointSnapper = null;\n  \tthis._nodedSegStrings = null;\n  \tvar pm = arguments[0];\n  \tthis._pm = pm;\n  \tthis._li = new RobustLineIntersector();\n  \tthis._li.setPrecisionModel(pm);\n  \tthis._scaleFactor = pm.getScale();\n  }\n  extend(MCIndexSnapRounder.prototype, {\n  \tcheckCorrectness: function checkCorrectness(inputSegmentStrings) {\n  \t\tvar resultSegStrings = NodedSegmentString.getNodedSubstrings(inputSegmentStrings);\n  \t\tvar nv = new NodingValidator(resultSegStrings);\n  \t\ttry {\n  \t\t\tnv.checkValid();\n  \t\t} catch (ex) {\n  \t\t\tif (ex instanceof Exception) {\n  \t\t\t\tex.printStackTrace();\n  \t\t\t} else throw ex;\n  \t\t} finally {}\n  \t},\n  \tgetNodedSubstrings: function getNodedSubstrings() {\n  \t\treturn NodedSegmentString.getNodedSubstrings(this._nodedSegStrings);\n  \t},\n  \tsnapRound: function snapRound(segStrings, li) {\n  \t\tvar intersections = this.findInteriorIntersections(segStrings, li);\n  \t\tthis.computeIntersectionSnaps(intersections);\n  \t\tthis.computeVertexSnaps(segStrings);\n  \t},\n  \tfindInteriorIntersections: function findInteriorIntersections(segStrings, li) {\n  \t\tvar intFinderAdder = new InteriorIntersectionFinderAdder(li);\n  \t\tthis._noder.setSegmentIntersector(intFinderAdder);\n  \t\tthis._noder.computeNodes(segStrings);\n  \t\treturn intFinderAdder.getInteriorIntersections();\n  \t},\n  \tcomputeVertexSnaps: function computeVertexSnaps() {\n  \t\tif (hasInterface(arguments[0], Collection)) {\n  \t\t\tvar edges = arguments[0];\n  \t\t\tfor (var i0 = edges.iterator(); i0.hasNext();) {\n  \t\t\t\tvar edge0 = i0.next();\n  \t\t\t\tthis.computeVertexSnaps(edge0);\n  \t\t\t}\n  \t\t} else if (arguments[0] instanceof NodedSegmentString) {\n  \t\t\tvar e = arguments[0];\n  \t\t\tvar pts0 = e.getCoordinates();\n  \t\t\tfor (var i = 0; i < pts0.length; i++) {\n  \t\t\t\tvar hotPixel = new HotPixel(pts0[i], this._scaleFactor, this._li);\n  \t\t\t\tvar isNodeAdded = this._pointSnapper.snap(hotPixel, e, i);\n  \t\t\t\tif (isNodeAdded) {\n  \t\t\t\t\te.addIntersection(pts0[i], i);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcomputeNodes: function computeNodes(inputSegmentStrings) {\n  \t\tthis._nodedSegStrings = inputSegmentStrings;\n  \t\tthis._noder = new MCIndexNoder();\n  \t\tthis._pointSnapper = new MCIndexPointSnapper(this._noder.getIndex());\n  \t\tthis.snapRound(inputSegmentStrings, this._li);\n  \t},\n  \tcomputeIntersectionSnaps: function computeIntersectionSnaps(snapPts) {\n  \t\tfor (var it = snapPts.iterator(); it.hasNext();) {\n  \t\t\tvar snapPt = it.next();\n  \t\t\tvar hotPixel = new HotPixel(snapPt, this._scaleFactor, this._li);\n  \t\t\tthis._pointSnapper.snap(hotPixel);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Noder];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MCIndexSnapRounder;\n  \t}\n  });\n\n  function BufferOp() {\n  \tthis._argGeom = null;\n  \tthis._distance = null;\n  \tthis._bufParams = new BufferParameters();\n  \tthis._resultGeometry = null;\n  \tthis._saveException = null;\n  \tif (arguments.length === 1) {\n  \t\tvar g = arguments[0];\n  \t\tthis._argGeom = g;\n  \t} else if (arguments.length === 2) {\n  \t\tvar g = arguments[0],\n  \t\t    bufParams = arguments[1];\n  \t\tthis._argGeom = g;\n  \t\tthis._bufParams = bufParams;\n  \t}\n  }\n  extend(BufferOp.prototype, {\n  \tbufferFixedPrecision: function bufferFixedPrecision(fixedPM) {\n  \t\tvar noder = new ScaledNoder(new MCIndexSnapRounder(new PrecisionModel(1.0)), fixedPM.getScale());\n  \t\tvar bufBuilder = new BufferBuilder(this._bufParams);\n  \t\tbufBuilder.setWorkingPrecisionModel(fixedPM);\n  \t\tbufBuilder.setNoder(noder);\n  \t\tthis._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);\n  \t},\n  \tbufferReducedPrecision: function bufferReducedPrecision() {\n  \t\tif (arguments.length === 0) {\n  \t\t\tfor (var precDigits = BufferOp.MAX_PRECISION_DIGITS; precDigits >= 0; precDigits--) {\n  \t\t\t\ttry {\n  \t\t\t\t\tthis.bufferReducedPrecision(precDigits);\n  \t\t\t\t} catch (ex) {\n  \t\t\t\t\tif (ex instanceof TopologyException) {\n  \t\t\t\t\t\tthis._saveException = ex;\n  \t\t\t\t\t} else throw ex;\n  \t\t\t\t} finally {}\n  \t\t\t\tif (this._resultGeometry !== null) return null;\n  \t\t\t}\n  \t\t\tthrow this._saveException;\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tvar precisionDigits = arguments[0];\n  \t\t\tvar sizeBasedScaleFactor = BufferOp.precisionScaleFactor(this._argGeom, this._distance, precisionDigits);\n  \t\t\tvar fixedPM = new PrecisionModel(sizeBasedScaleFactor);\n  \t\t\tthis.bufferFixedPrecision(fixedPM);\n  \t\t}\n  \t},\n  \tcomputeGeometry: function computeGeometry() {\n  \t\tthis.bufferOriginalPrecision();\n  \t\tif (this._resultGeometry !== null) return null;\n  \t\tvar argPM = this._argGeom.getFactory().getPrecisionModel();\n  \t\tif (argPM.getType() === PrecisionModel.FIXED) this.bufferFixedPrecision(argPM);else this.bufferReducedPrecision();\n  \t},\n  \tsetQuadrantSegments: function setQuadrantSegments(quadrantSegments) {\n  \t\tthis._bufParams.setQuadrantSegments(quadrantSegments);\n  \t},\n  \tbufferOriginalPrecision: function bufferOriginalPrecision() {\n  \t\ttry {\n  \t\t\tvar bufBuilder = new BufferBuilder(this._bufParams);\n  \t\t\tthis._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);\n  \t\t} catch (ex) {\n  \t\t\tif (ex instanceof RuntimeException) {\n  \t\t\t\tthis._saveException = ex;\n  \t\t\t} else throw ex;\n  \t\t} finally {}\n  \t},\n  \tgetResultGeometry: function getResultGeometry(distance) {\n  \t\tthis._distance = distance;\n  \t\tthis.computeGeometry();\n  \t\treturn this._resultGeometry;\n  \t},\n  \tsetEndCapStyle: function setEndCapStyle(endCapStyle) {\n  \t\tthis._bufParams.setEndCapStyle(endCapStyle);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn BufferOp;\n  \t}\n  });\n  BufferOp.bufferOp = function () {\n  \tif (arguments.length === 2) {\n  \t\tvar g = arguments[0],\n  \t\t    distance = arguments[1];\n  \t\tvar gBuf = new BufferOp(g);\n  \t\tvar geomBuf = gBuf.getResultGeometry(distance);\n  \t\treturn geomBuf;\n  \t} else if (arguments.length === 3) {\n  \t\tif (Number.isInteger(arguments[2]) && arguments[0] instanceof Geometry && typeof arguments[1] === \"number\") {\n  \t\t\tvar g = arguments[0],\n  \t\t\t    distance = arguments[1],\n  \t\t\t    quadrantSegments = arguments[2];\n  \t\t\tvar bufOp = new BufferOp(g);\n  \t\t\tbufOp.setQuadrantSegments(quadrantSegments);\n  \t\t\tvar geomBuf = bufOp.getResultGeometry(distance);\n  \t\t\treturn geomBuf;\n  \t\t} else if (arguments[2] instanceof BufferParameters && arguments[0] instanceof Geometry && typeof arguments[1] === \"number\") {\n  \t\t\tvar g = arguments[0],\n  \t\t\t    distance = arguments[1],\n  \t\t\t    params = arguments[2];\n  \t\t\tvar bufOp = new BufferOp(g, params);\n  \t\t\tvar geomBuf = bufOp.getResultGeometry(distance);\n  \t\t\treturn geomBuf;\n  \t\t}\n  \t} else if (arguments.length === 4) {\n  \t\tvar g = arguments[0],\n  \t\t    distance = arguments[1],\n  \t\t    quadrantSegments = arguments[2],\n  \t\t    endCapStyle = arguments[3];\n  \t\tvar bufOp = new BufferOp(g);\n  \t\tbufOp.setQuadrantSegments(quadrantSegments);\n  \t\tbufOp.setEndCapStyle(endCapStyle);\n  \t\tvar geomBuf = bufOp.getResultGeometry(distance);\n  \t\treturn geomBuf;\n  \t}\n  };\n  BufferOp.precisionScaleFactor = function (g, distance, maxPrecisionDigits) {\n  \tvar env = g.getEnvelopeInternal();\n  \tvar envMax = MathUtil.max(Math.abs(env.getMaxX()), Math.abs(env.getMaxY()), Math.abs(env.getMinX()), Math.abs(env.getMinY()));\n  \tvar expandByDistance = distance > 0.0 ? distance : 0.0;\n  \tvar bufEnvMax = envMax + 2 * expandByDistance;\n  \tvar bufEnvPrecisionDigits = Math.trunc(Math.log(bufEnvMax) / Math.log(10) + 1.0);\n  \tvar minUnitLog10 = maxPrecisionDigits - bufEnvPrecisionDigits;\n  \tvar scaleFactor = Math.pow(10.0, minUnitLog10);\n  \treturn scaleFactor;\n  };\n  BufferOp.CAP_ROUND = BufferParameters.CAP_ROUND;\n  BufferOp.CAP_BUTT = BufferParameters.CAP_FLAT;\n  BufferOp.CAP_FLAT = BufferParameters.CAP_FLAT;\n  BufferOp.CAP_SQUARE = BufferParameters.CAP_SQUARE;\n  BufferOp.MAX_PRECISION_DIGITS = 12;\n\n  function PolygonExtracter() {\n  \tthis._comps = null;\n  \tvar comps = arguments[0];\n  \tthis._comps = comps;\n  }\n  extend(PolygonExtracter.prototype, {\n  \tfilter: function filter(geom) {\n  \t\tif (geom instanceof Polygon) this._comps.add(geom);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [GeometryFilter];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn PolygonExtracter;\n  \t}\n  });\n  PolygonExtracter.getPolygons = function () {\n  \tif (arguments.length === 1) {\n  \t\tvar geom = arguments[0];\n  \t\treturn PolygonExtracter.getPolygons(geom, new ArrayList());\n  \t} else if (arguments.length === 2) {\n  \t\tvar geom = arguments[0],\n  \t\t    list = arguments[1];\n  \t\tif (geom instanceof Polygon) {\n  \t\t\tlist.add(geom);\n  \t\t} else if (geom instanceof GeometryCollection) {\n  \t\t\tgeom.apply(new PolygonExtracter(list));\n  \t\t}\n  \t\treturn list;\n  \t}\n  };\n\n  function GeometryLocation() {\n  \tthis._component = null;\n  \tthis._segIndex = null;\n  \tthis._pt = null;\n  \tif (arguments.length === 2) {\n  \t\tvar component = arguments[0],\n  \t\t    pt = arguments[1];\n  \t\tGeometryLocation.call(this, component, GeometryLocation.INSIDE_AREA, pt);\n  \t} else if (arguments.length === 3) {\n  \t\tvar component = arguments[0],\n  \t\t    segIndex = arguments[1],\n  \t\t    pt = arguments[2];\n  \t\tthis._component = component;\n  \t\tthis._segIndex = segIndex;\n  \t\tthis._pt = pt;\n  \t}\n  }\n  extend(GeometryLocation.prototype, {\n  \tisInsideArea: function isInsideArea() {\n  \t\treturn this._segIndex === GeometryLocation.INSIDE_AREA;\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\treturn this._pt;\n  \t},\n  \tgetGeometryComponent: function getGeometryComponent() {\n  \t\treturn this._component;\n  \t},\n  \tgetSegmentIndex: function getSegmentIndex() {\n  \t\treturn this._segIndex;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn GeometryLocation;\n  \t}\n  });\n  GeometryLocation.INSIDE_AREA = -1;\n\n  function PointExtracter() {\n  \tthis._pts = null;\n  \tvar pts = arguments[0];\n  \tthis._pts = pts;\n  }\n  extend(PointExtracter.prototype, {\n  \tfilter: function filter(geom) {\n  \t\tif (geom instanceof Point) this._pts.add(geom);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [GeometryFilter];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn PointExtracter;\n  \t}\n  });\n  PointExtracter.getPoints = function () {\n  \tif (arguments.length === 1) {\n  \t\tvar geom = arguments[0];\n  \t\tif (geom instanceof Point) {\n  \t\t\treturn Collections.singletonList(geom);\n  \t\t}\n  \t\treturn PointExtracter.getPoints(geom, new ArrayList());\n  \t} else if (arguments.length === 2) {\n  \t\tvar geom = arguments[0],\n  \t\t    list = arguments[1];\n  \t\tif (geom instanceof Point) {\n  \t\t\tlist.add(geom);\n  \t\t} else if (geom instanceof GeometryCollection) {\n  \t\t\tgeom.apply(new PointExtracter(list));\n  \t\t}\n  \t\treturn list;\n  \t}\n  };\n\n  function ConnectedElementLocationFilter() {\n  \tthis._locations = null;\n  \tvar locations = arguments[0];\n  \tthis._locations = locations;\n  }\n  extend(ConnectedElementLocationFilter.prototype, {\n  \tfilter: function filter(geom) {\n  \t\tif (geom instanceof Point || geom instanceof LineString || geom instanceof Polygon) this._locations.add(new GeometryLocation(geom, 0, geom.getCoordinate()));\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [GeometryFilter];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn ConnectedElementLocationFilter;\n  \t}\n  });\n  ConnectedElementLocationFilter.getLocations = function (geom) {\n  \tvar locations = new ArrayList();\n  \tgeom.apply(new ConnectedElementLocationFilter(locations));\n  \treturn locations;\n  };\n\n  function DistanceOp() {\n  \tthis._geom = null;\n  \tthis._terminateDistance = 0.0;\n  \tthis._ptLocator = new PointLocator();\n  \tthis._minDistanceLocation = null;\n  \tthis._minDistance = Double.MAX_VALUE;\n  \tif (arguments.length === 2) {\n  \t\tvar g0 = arguments[0],\n  \t\t    g1 = arguments[1];\n  \t\tDistanceOp.call(this, g0, g1, 0.0);\n  \t} else if (arguments.length === 3) {\n  \t\tvar g0 = arguments[0],\n  \t\t    g1 = arguments[1],\n  \t\t    terminateDistance = arguments[2];\n  \t\tthis._geom = new Array(2).fill(null);\n  \t\tthis._geom[0] = g0;\n  \t\tthis._geom[1] = g1;\n  \t\tthis._terminateDistance = terminateDistance;\n  \t}\n  }\n  extend(DistanceOp.prototype, {\n  \tcomputeContainmentDistance: function computeContainmentDistance() {\n  \t\tif (arguments.length === 0) {\n  \t\t\tvar locPtPoly = new Array(2).fill(null);\n  \t\t\tthis.computeContainmentDistance(0, locPtPoly);\n  \t\t\tif (this._minDistance <= this._terminateDistance) return null;\n  \t\t\tthis.computeContainmentDistance(1, locPtPoly);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar polyGeomIndex = arguments[0],\n  \t\t\t    locPtPoly = arguments[1];\n  \t\t\tvar locationsIndex = 1 - polyGeomIndex;\n  \t\t\tvar polys = PolygonExtracter.getPolygons(this._geom[polyGeomIndex]);\n  \t\t\tif (polys.size() > 0) {\n  \t\t\t\tvar insideLocs = ConnectedElementLocationFilter.getLocations(this._geom[locationsIndex]);\n  \t\t\t\tthis.computeContainmentDistance(insideLocs, polys, locPtPoly);\n  \t\t\t\tif (this._minDistance <= this._terminateDistance) {\n  \t\t\t\t\tthis._minDistanceLocation[locationsIndex] = locPtPoly[0];\n  \t\t\t\t\tthis._minDistanceLocation[polyGeomIndex] = locPtPoly[1];\n  \t\t\t\t\treturn null;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} else if (arguments.length === 3) {\n  \t\t\tif (arguments[2] instanceof Array && hasInterface(arguments[0], List) && hasInterface(arguments[1], List)) {\n  \t\t\t\tvar locs = arguments[0],\n  \t\t\t\t    polys = arguments[1],\n  \t\t\t\t    locPtPoly = arguments[2];\n  \t\t\t\tfor (var i = 0; i < locs.size(); i++) {\n  \t\t\t\t\tvar loc = locs.get(i);\n  \t\t\t\t\tfor (var j = 0; j < polys.size(); j++) {\n  \t\t\t\t\t\tthis.computeContainmentDistance(loc, polys.get(j), locPtPoly);\n  \t\t\t\t\t\tif (this._minDistance <= this._terminateDistance) return null;\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t} else if (arguments[2] instanceof Array && arguments[0] instanceof GeometryLocation && arguments[1] instanceof Polygon) {\n  \t\t\t\tvar ptLoc = arguments[0],\n  \t\t\t\t    poly = arguments[1],\n  \t\t\t\t    locPtPoly = arguments[2];\n  \t\t\t\tvar pt = ptLoc.getCoordinate();\n  \t\t\t\tif (Location.EXTERIOR !== this._ptLocator.locate(pt, poly)) {\n  \t\t\t\t\tthis._minDistance = 0.0;\n  \t\t\t\t\tlocPtPoly[0] = ptLoc;\n  \t\t\t\t\tlocPtPoly[1] = new GeometryLocation(poly, pt);\n  \t\t\t\t\treturn null;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcomputeMinDistanceLinesPoints: function computeMinDistanceLinesPoints(lines, points, locGeom) {\n  \t\tfor (var i = 0; i < lines.size(); i++) {\n  \t\t\tvar line = lines.get(i);\n  \t\t\tfor (var j = 0; j < points.size(); j++) {\n  \t\t\t\tvar pt = points.get(j);\n  \t\t\t\tthis.computeMinDistance(line, pt, locGeom);\n  \t\t\t\tif (this._minDistance <= this._terminateDistance) return null;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcomputeFacetDistance: function computeFacetDistance() {\n  \t\tvar locGeom = new Array(2).fill(null);\n  \t\tvar lines0 = LinearComponentExtracter.getLines(this._geom[0]);\n  \t\tvar lines1 = LinearComponentExtracter.getLines(this._geom[1]);\n  \t\tvar pts0 = PointExtracter.getPoints(this._geom[0]);\n  \t\tvar pts1 = PointExtracter.getPoints(this._geom[1]);\n  \t\tthis.computeMinDistanceLines(lines0, lines1, locGeom);\n  \t\tthis.updateMinDistance(locGeom, false);\n  \t\tif (this._minDistance <= this._terminateDistance) return null;\n  \t\tlocGeom[0] = null;\n  \t\tlocGeom[1] = null;\n  \t\tthis.computeMinDistanceLinesPoints(lines0, pts1, locGeom);\n  \t\tthis.updateMinDistance(locGeom, false);\n  \t\tif (this._minDistance <= this._terminateDistance) return null;\n  \t\tlocGeom[0] = null;\n  \t\tlocGeom[1] = null;\n  \t\tthis.computeMinDistanceLinesPoints(lines1, pts0, locGeom);\n  \t\tthis.updateMinDistance(locGeom, true);\n  \t\tif (this._minDistance <= this._terminateDistance) return null;\n  \t\tlocGeom[0] = null;\n  \t\tlocGeom[1] = null;\n  \t\tthis.computeMinDistancePoints(pts0, pts1, locGeom);\n  \t\tthis.updateMinDistance(locGeom, false);\n  \t},\n  \tnearestLocations: function nearestLocations() {\n  \t\tthis.computeMinDistance();\n  \t\treturn this._minDistanceLocation;\n  \t},\n  \tupdateMinDistance: function updateMinDistance(locGeom, flip) {\n  \t\tif (locGeom[0] === null) return null;\n  \t\tif (flip) {\n  \t\t\tthis._minDistanceLocation[0] = locGeom[1];\n  \t\t\tthis._minDistanceLocation[1] = locGeom[0];\n  \t\t} else {\n  \t\t\tthis._minDistanceLocation[0] = locGeom[0];\n  \t\t\tthis._minDistanceLocation[1] = locGeom[1];\n  \t\t}\n  \t},\n  \tnearestPoints: function nearestPoints() {\n  \t\tthis.computeMinDistance();\n  \t\tvar nearestPts = [this._minDistanceLocation[0].getCoordinate(), this._minDistanceLocation[1].getCoordinate()];\n  \t\treturn nearestPts;\n  \t},\n  \tcomputeMinDistance: function computeMinDistance() {\n  \t\tif (arguments.length === 0) {\n  \t\t\tif (this._minDistanceLocation !== null) return null;\n  \t\t\tthis._minDistanceLocation = new Array(2).fill(null);\n  \t\t\tthis.computeContainmentDistance();\n  \t\t\tif (this._minDistance <= this._terminateDistance) return null;\n  \t\t\tthis.computeFacetDistance();\n  \t\t} else if (arguments.length === 3) {\n  \t\t\tif (arguments[2] instanceof Array && arguments[0] instanceof LineString && arguments[1] instanceof Point) {\n  \t\t\t\tvar line = arguments[0],\n  \t\t\t\t    pt = arguments[1],\n  \t\t\t\t    locGeom = arguments[2];\n  \t\t\t\tif (line.getEnvelopeInternal().distance(pt.getEnvelopeInternal()) > this._minDistance) return null;\n  \t\t\t\tvar coord0 = line.getCoordinates();\n  \t\t\t\tvar coord = pt.getCoordinate();\n  \t\t\t\tfor (var i = 0; i < coord0.length - 1; i++) {\n  \t\t\t\t\tvar dist = CGAlgorithms.distancePointLine(coord, coord0[i], coord0[i + 1]);\n  \t\t\t\t\tif (dist < this._minDistance) {\n  \t\t\t\t\t\tthis._minDistance = dist;\n  \t\t\t\t\t\tvar seg = new LineSegment(coord0[i], coord0[i + 1]);\n  \t\t\t\t\t\tvar segClosestPoint = seg.closestPoint(coord);\n  \t\t\t\t\t\tlocGeom[0] = new GeometryLocation(line, i, segClosestPoint);\n  \t\t\t\t\t\tlocGeom[1] = new GeometryLocation(pt, 0, coord);\n  \t\t\t\t\t}\n  \t\t\t\t\tif (this._minDistance <= this._terminateDistance) return null;\n  \t\t\t\t}\n  \t\t\t} else if (arguments[2] instanceof Array && arguments[0] instanceof LineString && arguments[1] instanceof LineString) {\n  \t\t\t\tvar line0 = arguments[0],\n  \t\t\t\t    line1 = arguments[1],\n  \t\t\t\t    locGeom = arguments[2];\n  \t\t\t\tif (line0.getEnvelopeInternal().distance(line1.getEnvelopeInternal()) > this._minDistance) return null;\n  \t\t\t\tvar coord0 = line0.getCoordinates();\n  \t\t\t\tvar coord1 = line1.getCoordinates();\n  \t\t\t\tfor (var i = 0; i < coord0.length - 1; i++) {\n  \t\t\t\t\tfor (var j = 0; j < coord1.length - 1; j++) {\n  \t\t\t\t\t\tvar dist = CGAlgorithms.distanceLineLine(coord0[i], coord0[i + 1], coord1[j], coord1[j + 1]);\n  \t\t\t\t\t\tif (dist < this._minDistance) {\n  \t\t\t\t\t\t\tthis._minDistance = dist;\n  \t\t\t\t\t\t\tvar seg0 = new LineSegment(coord0[i], coord0[i + 1]);\n  \t\t\t\t\t\t\tvar seg1 = new LineSegment(coord1[j], coord1[j + 1]);\n  \t\t\t\t\t\t\tvar closestPt = seg0.closestPoints(seg1);\n  \t\t\t\t\t\t\tlocGeom[0] = new GeometryLocation(line0, i, closestPt[0]);\n  \t\t\t\t\t\t\tlocGeom[1] = new GeometryLocation(line1, j, closestPt[1]);\n  \t\t\t\t\t\t}\n  \t\t\t\t\t\tif (this._minDistance <= this._terminateDistance) return null;\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcomputeMinDistancePoints: function computeMinDistancePoints(points0, points1, locGeom) {\n  \t\tfor (var i = 0; i < points0.size(); i++) {\n  \t\t\tvar pt0 = points0.get(i);\n  \t\t\tfor (var j = 0; j < points1.size(); j++) {\n  \t\t\t\tvar pt1 = points1.get(j);\n  \t\t\t\tvar dist = pt0.getCoordinate().distance(pt1.getCoordinate());\n  \t\t\t\tif (dist < this._minDistance) {\n  \t\t\t\t\tthis._minDistance = dist;\n  \t\t\t\t\tlocGeom[0] = new GeometryLocation(pt0, 0, pt0.getCoordinate());\n  \t\t\t\t\tlocGeom[1] = new GeometryLocation(pt1, 0, pt1.getCoordinate());\n  \t\t\t\t}\n  \t\t\t\tif (this._minDistance <= this._terminateDistance) return null;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tdistance: function distance() {\n  \t\tif (this._geom[0] === null || this._geom[1] === null) throw new IllegalArgumentException(\"null geometries are not supported\");\n  \t\tif (this._geom[0].isEmpty() || this._geom[1].isEmpty()) return 0.0;\n  \t\tthis.computeMinDistance();\n  \t\treturn this._minDistance;\n  \t},\n  \tcomputeMinDistanceLines: function computeMinDistanceLines(lines0, lines1, locGeom) {\n  \t\tfor (var i = 0; i < lines0.size(); i++) {\n  \t\t\tvar line0 = lines0.get(i);\n  \t\t\tfor (var j = 0; j < lines1.size(); j++) {\n  \t\t\t\tvar line1 = lines1.get(j);\n  \t\t\t\tthis.computeMinDistance(line0, line1, locGeom);\n  \t\t\t\tif (this._minDistance <= this._terminateDistance) return null;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn DistanceOp;\n  \t}\n  });\n  DistanceOp.distance = function (g0, g1) {\n  \tvar distOp = new DistanceOp(g0, g1);\n  \treturn distOp.distance();\n  };\n  DistanceOp.isWithinDistance = function (g0, g1, distance) {\n  \tvar distOp = new DistanceOp(g0, g1, distance);\n  \treturn distOp.distance() <= distance;\n  };\n  DistanceOp.nearestPoints = function (g0, g1) {\n  \tvar distOp = new DistanceOp(g0, g1);\n  \treturn distOp.nearestPoints();\n  };\n\n  function EdgeString() {\n  \tthis._factory = null;\n  \tthis._directedEdges = new ArrayList();\n  \tthis._coordinates = null;\n  \tvar factory = arguments[0];\n  \tthis._factory = factory;\n  }\n  extend(EdgeString.prototype, {\n  \tgetCoordinates: function getCoordinates() {\n  \t\tif (this._coordinates === null) {\n  \t\t\tvar forwardDirectedEdges = 0;\n  \t\t\tvar reverseDirectedEdges = 0;\n  \t\t\tvar coordinateList = new CoordinateList();\n  \t\t\tfor (var i = this._directedEdges.iterator(); i.hasNext();) {\n  \t\t\t\tvar directedEdge = i.next();\n  \t\t\t\tif (directedEdge.getEdgeDirection()) {\n  \t\t\t\t\tforwardDirectedEdges++;\n  \t\t\t\t} else {\n  \t\t\t\t\treverseDirectedEdges++;\n  \t\t\t\t}\n  \t\t\t\tcoordinateList.add(directedEdge.getEdge().getLine().getCoordinates(), false, directedEdge.getEdgeDirection());\n  \t\t\t}\n  \t\t\tthis._coordinates = coordinateList.toCoordinateArray();\n  \t\t\tif (reverseDirectedEdges > forwardDirectedEdges) {\n  \t\t\t\tCoordinateArrays.reverse(this._coordinates);\n  \t\t\t}\n  \t\t}\n  \t\treturn this._coordinates;\n  \t},\n  \ttoLineString: function toLineString() {\n  \t\treturn this._factory.createLineString(this.getCoordinates());\n  \t},\n  \tadd: function add(directedEdge) {\n  \t\tthis._directedEdges.add(directedEdge);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn EdgeString;\n  \t}\n  });\n\n  function GraphComponent$1() {\n  \tthis._isMarked = false;\n  \tthis._isVisited = false;\n  \tthis._data = null;\n  }\n  extend(GraphComponent$1.prototype, {\n  \tsetVisited: function setVisited(isVisited) {\n  \t\tthis._isVisited = isVisited;\n  \t},\n  \tisMarked: function isMarked() {\n  \t\treturn this._isMarked;\n  \t},\n  \tsetData: function setData(data) {\n  \t\tthis._data = data;\n  \t},\n  \tgetData: function getData() {\n  \t\treturn this._data;\n  \t},\n  \tsetMarked: function setMarked(isMarked) {\n  \t\tthis._isMarked = isMarked;\n  \t},\n  \tgetContext: function getContext() {\n  \t\treturn this._data;\n  \t},\n  \tisVisited: function isVisited() {\n  \t\treturn this._isVisited;\n  \t},\n  \tsetContext: function setContext(data) {\n  \t\tthis._data = data;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn GraphComponent$1;\n  \t}\n  });\n  GraphComponent$1.getComponentWithVisitedState = function (i, visitedState) {\n  \twhile (i.hasNext()) {\n  \t\tvar comp = i.next();\n  \t\tif (comp.isVisited() === visitedState) return comp;\n  \t}\n  \treturn null;\n  };\n  GraphComponent$1.setVisited = function (i, visited) {\n  \twhile (i.hasNext()) {\n  \t\tvar comp = i.next();\n  \t\tcomp.setVisited(visited);\n  \t}\n  };\n  GraphComponent$1.setMarked = function (i, marked) {\n  \twhile (i.hasNext()) {\n  \t\tvar comp = i.next();\n  \t\tcomp.setMarked(marked);\n  \t}\n  };\n\n  function DirectedEdge$1() {\n  \tGraphComponent$1.apply(this);\n  \tthis._parentEdge = null;\n  \tthis._from = null;\n  \tthis._to = null;\n  \tthis._p0 = null;\n  \tthis._p1 = null;\n  \tthis._sym = null;\n  \tthis._edgeDirection = null;\n  \tthis._quadrant = null;\n  \tthis._angle = null;\n  \tvar from = arguments[0],\n  \t    to = arguments[1],\n  \t    directionPt = arguments[2],\n  \t    edgeDirection = arguments[3];\n  \tthis._from = from;\n  \tthis._to = to;\n  \tthis._edgeDirection = edgeDirection;\n  \tthis._p0 = from.getCoordinate();\n  \tthis._p1 = directionPt;\n  \tvar dx = this._p1.x - this._p0.x;\n  \tvar dy = this._p1.y - this._p0.y;\n  \tthis._quadrant = Quadrant.quadrant(dx, dy);\n  \tthis._angle = Math.atan2(dy, dx);\n  }\n  inherits$1(DirectedEdge$1, GraphComponent$1);\n  extend(DirectedEdge$1.prototype, {\n  \tisRemoved: function isRemoved() {\n  \t\treturn this._parentEdge === null;\n  \t},\n  \tcompareDirection: function compareDirection(e) {\n  \t\tif (this._quadrant > e._quadrant) return 1;\n  \t\tif (this._quadrant < e._quadrant) return -1;\n  \t\treturn CGAlgorithms.computeOrientation(e._p0, e._p1, this._p1);\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\treturn this._from.getCoordinate();\n  \t},\n  \tprint: function print(out) {\n  \t\tvar className = this.getClass().getName();\n  \t\tvar lastDotPos = className.lastIndexOf('.');\n  \t\tvar name = className.substring(lastDotPos + 1);\n  \t\tout.print(\"  \" + name + \": \" + this._p0 + \" - \" + this._p1 + \" \" + this._quadrant + \":\" + this._angle);\n  \t},\n  \tgetDirectionPt: function getDirectionPt() {\n  \t\treturn this._p1;\n  \t},\n  \tgetAngle: function getAngle() {\n  \t\treturn this._angle;\n  \t},\n  \tcompareTo: function compareTo(obj) {\n  \t\tvar de = obj;\n  \t\treturn this.compareDirection(de);\n  \t},\n  \tgetFromNode: function getFromNode() {\n  \t\treturn this._from;\n  \t},\n  \tgetSym: function getSym() {\n  \t\treturn this._sym;\n  \t},\n  \tsetEdge: function setEdge(parentEdge) {\n  \t\tthis._parentEdge = parentEdge;\n  \t},\n  \tremove: function remove() {\n  \t\tthis._sym = null;\n  \t\tthis._parentEdge = null;\n  \t},\n  \tgetEdge: function getEdge() {\n  \t\treturn this._parentEdge;\n  \t},\n  \tgetQuadrant: function getQuadrant() {\n  \t\treturn this._quadrant;\n  \t},\n  \tsetSym: function setSym(sym) {\n  \t\tthis._sym = sym;\n  \t},\n  \tgetToNode: function getToNode() {\n  \t\treturn this._to;\n  \t},\n  \tgetEdgeDirection: function getEdgeDirection() {\n  \t\treturn this._edgeDirection;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn DirectedEdge$1;\n  \t}\n  });\n  DirectedEdge$1.toEdges = function (dirEdges) {\n  \tvar edges = new ArrayList();\n  \tfor (var i = dirEdges.iterator(); i.hasNext();) {\n  \t\tedges.add(i.next()._parentEdge);\n  \t}\n  \treturn edges;\n  };\n\n  function LineMergeDirectedEdge() {\n  \tvar from = arguments[0],\n  \t    to = arguments[1],\n  \t    directionPt = arguments[2],\n  \t    edgeDirection = arguments[3];\n  \tDirectedEdge$1.call(this, from, to, directionPt, edgeDirection);\n  }\n  inherits$1(LineMergeDirectedEdge, DirectedEdge$1);\n  extend(LineMergeDirectedEdge.prototype, {\n  \tgetNext: function getNext() {\n  \t\tif (this.getToNode().getDegree() !== 2) {\n  \t\t\treturn null;\n  \t\t}\n  \t\tif (this.getToNode().getOutEdges().getEdges().get(0) === this.getSym()) {\n  \t\t\treturn this.getToNode().getOutEdges().getEdges().get(1);\n  \t\t}\n  \t\tAssert.isTrue(this.getToNode().getOutEdges().getEdges().get(1) === this.getSym());\n  \t\treturn this.getToNode().getOutEdges().getEdges().get(0);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LineMergeDirectedEdge;\n  \t}\n  });\n\n  function Edge$1() {\n  \tGraphComponent$1.apply(this);\n  \tthis._dirEdge = null;\n  \tif (arguments.length === 0) ; else if (arguments.length === 2) {\n  \t\tvar de0 = arguments[0],\n  \t\t    de1 = arguments[1];\n  \t\tthis.setDirectedEdges(de0, de1);\n  \t}\n  }\n  inherits$1(Edge$1, GraphComponent$1);\n  extend(Edge$1.prototype, {\n  \tisRemoved: function isRemoved() {\n  \t\treturn this._dirEdge === null;\n  \t},\n  \tsetDirectedEdges: function setDirectedEdges(de0, de1) {\n  \t\tthis._dirEdge = [de0, de1];\n  \t\tde0.setEdge(this);\n  \t\tde1.setEdge(this);\n  \t\tde0.setSym(de1);\n  \t\tde1.setSym(de0);\n  \t\tde0.getFromNode().addOutEdge(de0);\n  \t\tde1.getFromNode().addOutEdge(de1);\n  \t},\n  \tgetDirEdge: function getDirEdge() {\n  \t\tif (Number.isInteger(arguments[0])) {\n  \t\t\tvar i = arguments[0];\n  \t\t\treturn this._dirEdge[i];\n  \t\t} else if (arguments[0] instanceof Node$3) {\n  \t\t\tvar fromNode = arguments[0];\n  \t\t\tif (this._dirEdge[0].getFromNode() === fromNode) return this._dirEdge[0];\n  \t\t\tif (this._dirEdge[1].getFromNode() === fromNode) return this._dirEdge[1];\n  \t\t\treturn null;\n  \t\t}\n  \t},\n  \tremove: function remove() {\n  \t\tthis._dirEdge = null;\n  \t},\n  \tgetOppositeNode: function getOppositeNode(node) {\n  \t\tif (this._dirEdge[0].getFromNode() === node) return this._dirEdge[0].getToNode();\n  \t\tif (this._dirEdge[1].getFromNode() === node) return this._dirEdge[1].getToNode();\n  \t\treturn null;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Edge$1;\n  \t}\n  });\n\n  function DirectedEdgeStar$1() {\n  \tthis._outEdges = new ArrayList();\n  \tthis._sorted = false;\n  }\n  extend(DirectedEdgeStar$1.prototype, {\n  \tgetNextEdge: function getNextEdge(dirEdge) {\n  \t\tvar i = this.getIndex(dirEdge);\n  \t\treturn this._outEdges.get(this.getIndex(i + 1));\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\tvar it = this.iterator();\n  \t\tif (!it.hasNext()) return null;\n  \t\tvar e = it.next();\n  \t\treturn e.getCoordinate();\n  \t},\n  \titerator: function iterator() {\n  \t\tthis.sortEdges();\n  \t\treturn this._outEdges.iterator();\n  \t},\n  \tsortEdges: function sortEdges() {\n  \t\tif (!this._sorted) {\n  \t\t\tCollections.sort(this._outEdges);\n  \t\t\tthis._sorted = true;\n  \t\t}\n  \t},\n  \tremove: function remove(de) {\n  \t\tthis._outEdges.remove(de);\n  \t},\n  \tgetEdges: function getEdges() {\n  \t\tthis.sortEdges();\n  \t\treturn this._outEdges;\n  \t},\n  \tgetNextCWEdge: function getNextCWEdge(dirEdge) {\n  \t\tvar i = this.getIndex(dirEdge);\n  \t\treturn this._outEdges.get(this.getIndex(i - 1));\n  \t},\n  \tgetIndex: function getIndex() {\n  \t\tif (arguments[0] instanceof Edge$1) {\n  \t\t\tvar edge = arguments[0];\n  \t\t\tthis.sortEdges();\n  \t\t\tfor (var i = 0; i < this._outEdges.size(); i++) {\n  \t\t\t\tvar de = this._outEdges.get(i);\n  \t\t\t\tif (de.getEdge() === edge) return i;\n  \t\t\t}\n  \t\t\treturn -1;\n  \t\t} else if (arguments[0] instanceof DirectedEdge$1) {\n  \t\t\tvar dirEdge = arguments[0];\n  \t\t\tthis.sortEdges();\n  \t\t\tfor (var i = 0; i < this._outEdges.size(); i++) {\n  \t\t\t\tvar de = this._outEdges.get(i);\n  \t\t\t\tif (de === dirEdge) return i;\n  \t\t\t}\n  \t\t\treturn -1;\n  \t\t} else if (Number.isInteger(arguments[0])) {\n  \t\t\tvar i = arguments[0];\n  \t\t\tvar modi = i % this._outEdges.size();\n  \t\t\tif (modi < 0) modi += this._outEdges.size();\n  \t\t\treturn modi;\n  \t\t}\n  \t},\n  \tadd: function add(de) {\n  \t\tthis._outEdges.add(de);\n  \t\tthis._sorted = false;\n  \t},\n  \tgetDegree: function getDegree() {\n  \t\treturn this._outEdges.size();\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn DirectedEdgeStar$1;\n  \t}\n  });\n\n  function Node$3() {\n  \tGraphComponent$1.apply(this);\n  \tthis._pt = null;\n  \tthis._deStar = null;\n  \tif (arguments.length === 1) {\n  \t\tvar pt = arguments[0];\n  \t\tNode$3.call(this, pt, new DirectedEdgeStar$1());\n  \t} else if (arguments.length === 2) {\n  \t\tvar pt = arguments[0],\n  \t\t    deStar = arguments[1];\n  \t\tthis._pt = pt;\n  \t\tthis._deStar = deStar;\n  \t}\n  }\n  inherits$1(Node$3, GraphComponent$1);\n  extend(Node$3.prototype, {\n  \tisRemoved: function isRemoved() {\n  \t\treturn this._pt === null;\n  \t},\n  \taddOutEdge: function addOutEdge(de) {\n  \t\tthis._deStar.add(de);\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\treturn this._pt;\n  \t},\n  \tgetOutEdges: function getOutEdges() {\n  \t\treturn this._deStar;\n  \t},\n  \tremove: function remove() {\n  \t\tif (arguments.length === 0) {\n  \t\t\tthis._pt = null;\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tvar de = arguments[0];\n  \t\t\tthis._deStar.remove(de);\n  \t\t}\n  \t},\n  \tgetIndex: function getIndex(edge) {\n  \t\treturn this._deStar.getIndex(edge);\n  \t},\n  \tgetDegree: function getDegree() {\n  \t\treturn this._deStar.getDegree();\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Node$3;\n  \t}\n  });\n  Node$3.getEdgesBetween = function (node0, node1) {\n  \tvar edges0 = DirectedEdge$1.toEdges(node0.getOutEdges().getEdges());\n  \tvar commonEdges = new HashSet(edges0);\n  \tvar edges1 = DirectedEdge$1.toEdges(node1.getOutEdges().getEdges());\n  \tcommonEdges.retainAll(edges1);\n  \treturn commonEdges;\n  };\n\n  function LineMergeEdge() {\n  \tEdge$1.apply(this);\n  \tthis._line = null;\n  \tvar line = arguments[0];\n  \tthis._line = line;\n  }\n  inherits$1(LineMergeEdge, Edge$1);\n  extend(LineMergeEdge.prototype, {\n  \tgetLine: function getLine() {\n  \t\treturn this._line;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LineMergeEdge;\n  \t}\n  });\n\n  function NodeMap$1() {\n  \tthis._nodeMap = new TreeMap();\n  }\n  extend(NodeMap$1.prototype, {\n  \tfind: function find(coord) {\n  \t\treturn this._nodeMap.get(coord);\n  \t},\n  \titerator: function iterator() {\n  \t\treturn this._nodeMap.values().iterator();\n  \t},\n  \tremove: function remove(pt) {\n  \t\treturn this._nodeMap.remove(pt);\n  \t},\n  \tvalues: function values() {\n  \t\treturn this._nodeMap.values();\n  \t},\n  \tadd: function add(n) {\n  \t\tthis._nodeMap.put(n.getCoordinate(), n);\n  \t\treturn n;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn NodeMap$1;\n  \t}\n  });\n\n  function PlanarGraph$1() {\n  \tthis._edges = new HashSet();\n  \tthis._dirEdges = new HashSet();\n  \tthis._nodeMap = new NodeMap$1();\n  }\n  extend(PlanarGraph$1.prototype, {\n  \tfindNodesOfDegree: function findNodesOfDegree(degree) {\n  \t\tvar nodesFound = new ArrayList();\n  \t\tfor (var i = this.nodeIterator(); i.hasNext();) {\n  \t\t\tvar node = i.next();\n  \t\t\tif (node.getDegree() === degree) nodesFound.add(node);\n  \t\t}\n  \t\treturn nodesFound;\n  \t},\n  \tdirEdgeIterator: function dirEdgeIterator() {\n  \t\treturn this._dirEdges.iterator();\n  \t},\n  \tedgeIterator: function edgeIterator() {\n  \t\treturn this._edges.iterator();\n  \t},\n  \tremove: function remove() {\n  \t\tif (arguments[0] instanceof Edge$1) {\n  \t\t\tvar edge = arguments[0];\n  \t\t\tthis.remove(edge.getDirEdge(0));\n  \t\t\tthis.remove(edge.getDirEdge(1));\n  \t\t\tthis._edges.remove(edge);\n  \t\t\tedge.remove();\n  \t\t} else if (arguments[0] instanceof DirectedEdge$1) {\n  \t\t\tvar de = arguments[0];\n  \t\t\tvar sym = de.getSym();\n  \t\t\tif (sym !== null) sym.setSym(null);\n  \t\t\tde.getFromNode().remove(de);\n  \t\t\tde.remove();\n  \t\t\tthis._dirEdges.remove(de);\n  \t\t} else if (arguments[0] instanceof Node$3) {\n  \t\t\tvar node = arguments[0];\n  \t\t\tvar outEdges = node.getOutEdges().getEdges();\n  \t\t\tfor (var i = outEdges.iterator(); i.hasNext();) {\n  \t\t\t\tvar de = i.next();\n  \t\t\t\tvar sym = de.getSym();\n  \t\t\t\tif (sym !== null) this.remove(sym);\n  \t\t\t\tthis._dirEdges.remove(de);\n  \t\t\t\tvar edge = de.getEdge();\n  \t\t\t\tif (edge !== null) {\n  \t\t\t\t\tthis._edges.remove(edge);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\tthis._nodeMap.remove(node.getCoordinate());\n  \t\t\tnode.remove();\n  \t\t}\n  \t},\n  \tfindNode: function findNode(pt) {\n  \t\treturn this._nodeMap.find(pt);\n  \t},\n  \tgetEdges: function getEdges() {\n  \t\treturn this._edges;\n  \t},\n  \tnodeIterator: function nodeIterator() {\n  \t\treturn this._nodeMap.iterator();\n  \t},\n  \tcontains: function contains() {\n  \t\tif (arguments[0] instanceof Edge$1) {\n  \t\t\tvar e = arguments[0];\n  \t\t\treturn this._edges.contains(e);\n  \t\t} else if (arguments[0] instanceof DirectedEdge$1) {\n  \t\t\tvar de = arguments[0];\n  \t\t\treturn this._dirEdges.contains(de);\n  \t\t}\n  \t},\n  \tadd: function add() {\n  \t\tif (arguments[0] instanceof Node$3) {\n  \t\t\tvar node = arguments[0];\n  \t\t\tthis._nodeMap.add(node);\n  \t\t} else if (arguments[0] instanceof Edge$1) {\n  \t\t\tvar edge = arguments[0];\n  \t\t\tthis._edges.add(edge);\n  \t\t\tthis.add(edge.getDirEdge(0));\n  \t\t\tthis.add(edge.getDirEdge(1));\n  \t\t} else if (arguments[0] instanceof DirectedEdge$1) {\n  \t\t\tvar dirEdge = arguments[0];\n  \t\t\tthis._dirEdges.add(dirEdge);\n  \t\t}\n  \t},\n  \tgetNodes: function getNodes() {\n  \t\treturn this._nodeMap.values();\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn PlanarGraph$1;\n  \t}\n  });\n\n  function LineMergeGraph() {\n  \tPlanarGraph$1.apply(this);\n  }\n  inherits$1(LineMergeGraph, PlanarGraph$1);\n  extend(LineMergeGraph.prototype, {\n  \taddEdge: function addEdge(lineString) {\n  \t\tif (lineString.isEmpty()) {\n  \t\t\treturn null;\n  \t\t}\n  \t\tvar coordinates = CoordinateArrays.removeRepeatedPoints(lineString.getCoordinates());\n  \t\tif (coordinates.length <= 1) return null;\n  \t\tvar startCoordinate = coordinates[0];\n  \t\tvar endCoordinate = coordinates[coordinates.length - 1];\n  \t\tvar startNode = this.getNode(startCoordinate);\n  \t\tvar endNode = this.getNode(endCoordinate);\n  \t\tvar directedEdge0 = new LineMergeDirectedEdge(startNode, endNode, coordinates[1], true);\n  \t\tvar directedEdge1 = new LineMergeDirectedEdge(endNode, startNode, coordinates[coordinates.length - 2], false);\n  \t\tvar edge = new LineMergeEdge(lineString);\n  \t\tedge.setDirectedEdges(directedEdge0, directedEdge1);\n  \t\tthis.add(edge);\n  \t},\n  \tgetNode: function getNode(coordinate) {\n  \t\tvar node = this.findNode(coordinate);\n  \t\tif (node === null) {\n  \t\t\tnode = new Node$3(coordinate);\n  \t\t\tthis.add(node);\n  \t\t}\n  \t\treturn node;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LineMergeGraph;\n  \t}\n  });\n\n  function LineMerger() {\n  \tthis._graph = new LineMergeGraph();\n  \tthis._mergedLineStrings = null;\n  \tthis._factory = null;\n  \tthis._edgeStrings = null;\n  }\n  extend(LineMerger.prototype, {\n  \tbuildEdgeStringsForUnprocessedNodes: function buildEdgeStringsForUnprocessedNodes() {\n  \t\tfor (var i = this._graph.getNodes().iterator(); i.hasNext();) {\n  \t\t\tvar node = i.next();\n  \t\t\tif (!node.isMarked()) {\n  \t\t\t\tAssert.isTrue(node.getDegree() === 2);\n  \t\t\t\tthis.buildEdgeStringsStartingAt(node);\n  \t\t\t\tnode.setMarked(true);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tbuildEdgeStringsForNonDegree2Nodes: function buildEdgeStringsForNonDegree2Nodes() {\n  \t\tfor (var i = this._graph.getNodes().iterator(); i.hasNext();) {\n  \t\t\tvar node = i.next();\n  \t\t\tif (node.getDegree() !== 2) {\n  \t\t\t\tthis.buildEdgeStringsStartingAt(node);\n  \t\t\t\tnode.setMarked(true);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tbuildEdgeStringsForObviousStartNodes: function buildEdgeStringsForObviousStartNodes() {\n  \t\tthis.buildEdgeStringsForNonDegree2Nodes();\n  \t},\n  \tgetMergedLineStrings: function getMergedLineStrings() {\n  \t\tthis.merge();\n  \t\treturn this._mergedLineStrings;\n  \t},\n  \tbuildEdgeStringsStartingAt: function buildEdgeStringsStartingAt(node) {\n  \t\tfor (var i = node.getOutEdges().iterator(); i.hasNext();) {\n  \t\t\tvar directedEdge = i.next();\n  \t\t\tif (directedEdge.getEdge().isMarked()) {\n  \t\t\t\tcontinue;\n  \t\t\t}\n  \t\t\tthis._edgeStrings.add(this.buildEdgeStringStartingWith(directedEdge));\n  \t\t}\n  \t},\n  \tmerge: function merge() {\n  \t\tif (this._mergedLineStrings !== null) {\n  \t\t\treturn null;\n  \t\t}\n  \t\tGraphComponent$1.setMarked(this._graph.nodeIterator(), false);\n  \t\tGraphComponent$1.setMarked(this._graph.edgeIterator(), false);\n  \t\tthis._edgeStrings = new ArrayList();\n  \t\tthis.buildEdgeStringsForObviousStartNodes();\n  \t\tthis.buildEdgeStringsForIsolatedLoops();\n  \t\tthis._mergedLineStrings = new ArrayList();\n  \t\tfor (var i = this._edgeStrings.iterator(); i.hasNext();) {\n  \t\t\tvar edgeString = i.next();\n  \t\t\tthis._mergedLineStrings.add(edgeString.toLineString());\n  \t\t}\n  \t},\n  \tbuildEdgeStringStartingWith: function buildEdgeStringStartingWith(start) {\n  \t\tvar edgeString = new EdgeString(this._factory);\n  \t\tvar current = start;\n  \t\tdo {\n  \t\t\tedgeString.add(current);\n  \t\t\tcurrent.getEdge().setMarked(true);\n  \t\t\tcurrent = current.getNext();\n  \t\t} while (current !== null && current !== start);\n  \t\treturn edgeString;\n  \t},\n  \tadd: function add() {\n  \t\tif (arguments[0] instanceof Geometry) {\n  \t\t\tvar geometry = arguments[0];\n  \t\t\tgeometry.apply({\n  \t\t\t\tinterfaces_: function interfaces_() {\n  \t\t\t\t\treturn [GeometryComponentFilter];\n  \t\t\t\t},\n  \t\t\t\tfilter: function filter(component) {\n  \t\t\t\t\tif (component instanceof LineString) {\n  \t\t\t\t\t\tthis.add(component);\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t});\n  \t\t} else if (hasInterface(arguments[0], Collection)) {\n  \t\t\tvar geometries = arguments[0];\n  \t\t\tthis._mergedLineStrings = null;\n  \t\t\tfor (var i = geometries.iterator(); i.hasNext();) {\n  \t\t\t\tvar geometry = i.next();\n  \t\t\t\tthis.add(geometry);\n  \t\t\t}\n  \t\t} else if (arguments[0] instanceof LineString) {\n  \t\t\tvar lineString = arguments[0];\n  \t\t\tif (this._factory === null) {\n  \t\t\t\tthis._factory = lineString.getFactory();\n  \t\t\t}\n  \t\t\tthis._graph.addEdge(lineString);\n  \t\t}\n  \t},\n  \tbuildEdgeStringsForIsolatedLoops: function buildEdgeStringsForIsolatedLoops() {\n  \t\tthis.buildEdgeStringsForUnprocessedNodes();\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LineMerger;\n  \t}\n  });\n\n  function PolygonizeDirectedEdge() {\n  \tthis._edgeRing = null;\n  \tthis._next = null;\n  \tthis._label = -1;\n  \tvar from = arguments[0],\n  \t    to = arguments[1],\n  \t    directionPt = arguments[2],\n  \t    edgeDirection = arguments[3];\n  \tDirectedEdge$1.call(this, from, to, directionPt, edgeDirection);\n  }\n  inherits$1(PolygonizeDirectedEdge, DirectedEdge$1);\n  extend(PolygonizeDirectedEdge.prototype, {\n  \tgetNext: function getNext() {\n  \t\treturn this._next;\n  \t},\n  \tisInRing: function isInRing() {\n  \t\treturn this._edgeRing !== null;\n  \t},\n  \tsetRing: function setRing(edgeRing) {\n  \t\tthis._edgeRing = edgeRing;\n  \t},\n  \tsetLabel: function setLabel(label) {\n  \t\tthis._label = label;\n  \t},\n  \tgetLabel: function getLabel() {\n  \t\treturn this._label;\n  \t},\n  \tsetNext: function setNext(next) {\n  \t\tthis._next = next;\n  \t},\n  \tgetRing: function getRing() {\n  \t\treturn this._edgeRing;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn PolygonizeDirectedEdge;\n  \t}\n  });\n\n  function PolygonizeEdge() {\n  \tEdge$1.apply(this);\n  \tthis._line = null;\n  \tvar line = arguments[0];\n  \tthis._line = line;\n  }\n  inherits$1(PolygonizeEdge, Edge$1);\n  extend(PolygonizeEdge.prototype, {\n  \tgetLine: function getLine() {\n  \t\treturn this._line;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn PolygonizeEdge;\n  \t}\n  });\n\n  function ConnectedInteriorTester() {\n  \tthis._geometryFactory = new GeometryFactory();\n  \tthis._geomGraph = null;\n  \tthis._disconnectedRingcoord = null;\n  \tvar geomGraph = arguments[0];\n  \tthis._geomGraph = geomGraph;\n  }\n  extend(ConnectedInteriorTester.prototype, {\n  \tvisitInteriorRing: function visitInteriorRing(ring, graph) {\n  \t\tvar pts = ring.getCoordinates();\n  \t\tvar pt0 = pts[0];\n  \t\tvar pt1 = ConnectedInteriorTester.findDifferentPoint(pts, pt0);\n  \t\tvar e = graph.findEdgeInSameDirection(pt0, pt1);\n  \t\tvar de = graph.findEdgeEnd(e);\n  \t\tvar intDe = null;\n  \t\tif (de.getLabel().getLocation(0, Position.RIGHT) === Location.INTERIOR) {\n  \t\t\tintDe = de;\n  \t\t} else if (de.getSym().getLabel().getLocation(0, Position.RIGHT) === Location.INTERIOR) {\n  \t\t\tintDe = de.getSym();\n  \t\t}\n  \t\tAssert.isTrue(intDe !== null, \"unable to find dirEdge with Interior on RHS\");\n  \t\tthis.visitLinkedDirectedEdges(intDe);\n  \t},\n  \tvisitShellInteriors: function visitShellInteriors(g, graph) {\n  \t\tif (g instanceof Polygon) {\n  \t\t\tvar p = g;\n  \t\t\tthis.visitInteriorRing(p.getExteriorRing(), graph);\n  \t\t}\n  \t\tif (g instanceof MultiPolygon) {\n  \t\t\tvar mp = g;\n  \t\t\tfor (var i = 0; i < mp.getNumGeometries(); i++) {\n  \t\t\t\tvar p = mp.getGeometryN(i);\n  \t\t\t\tthis.visitInteriorRing(p.getExteriorRing(), graph);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\treturn this._disconnectedRingcoord;\n  \t},\n  \tsetInteriorEdgesInResult: function setInteriorEdgesInResult(graph) {\n  \t\tfor (var it = graph.getEdgeEnds().iterator(); it.hasNext();) {\n  \t\t\tvar de = it.next();\n  \t\t\tif (de.getLabel().getLocation(0, Position.RIGHT) === Location.INTERIOR) {\n  \t\t\t\tde.setInResult(true);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tvisitLinkedDirectedEdges: function visitLinkedDirectedEdges(start) {\n  \t\tvar startDe = start;\n  \t\tvar de = start;\n  \t\tdo {\n  \t\t\tAssert.isTrue(de !== null, \"found null Directed Edge\");\n  \t\t\tde.setVisited(true);\n  \t\t\tde = de.getNext();\n  \t\t} while (de !== startDe);\n  \t},\n  \tbuildEdgeRings: function buildEdgeRings(dirEdges) {\n  \t\tvar edgeRings = new ArrayList();\n  \t\tfor (var it = dirEdges.iterator(); it.hasNext();) {\n  \t\t\tvar de = it.next();\n  \t\t\tif (de.isInResult() && de.getEdgeRing() === null) {\n  \t\t\t\tvar er = new MaximalEdgeRing(de, this._geometryFactory);\n  \t\t\t\ter.linkDirectedEdgesForMinimalEdgeRings();\n  \t\t\t\tvar minEdgeRings = er.buildMinimalRings();\n  \t\t\t\tedgeRings.addAll(minEdgeRings);\n  \t\t\t}\n  \t\t}\n  \t\treturn edgeRings;\n  \t},\n  \thasUnvisitedShellEdge: function hasUnvisitedShellEdge(edgeRings) {\n  \t\tfor (var i = 0; i < edgeRings.size(); i++) {\n  \t\t\tvar er = edgeRings.get(i);\n  \t\t\tif (er.isHole()) continue;\n  \t\t\tvar edges = er.getEdges();\n  \t\t\tvar de = edges.get(0);\n  \t\t\tif (de.getLabel().getLocation(0, Position.RIGHT) !== Location.INTERIOR) continue;\n  \t\t\tfor (var j = 0; j < edges.size(); j++) {\n  \t\t\t\tde = edges.get(j);\n  \t\t\t\tif (!de.isVisited()) {\n  \t\t\t\t\tthis._disconnectedRingcoord = de.getCoordinate();\n  \t\t\t\t\treturn true;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tisInteriorsConnected: function isInteriorsConnected() {\n  \t\tvar splitEdges = new ArrayList();\n  \t\tthis._geomGraph.computeSplitEdges(splitEdges);\n  \t\tvar graph = new PlanarGraph(new OverlayNodeFactory());\n  \t\tgraph.addEdges(splitEdges);\n  \t\tthis.setInteriorEdgesInResult(graph);\n  \t\tgraph.linkResultDirectedEdges();\n  \t\tvar edgeRings = this.buildEdgeRings(graph.getEdgeEnds());\n  \t\tthis.visitShellInteriors(this._geomGraph.getGeometry(), graph);\n  \t\treturn !this.hasUnvisitedShellEdge(edgeRings);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn ConnectedInteriorTester;\n  \t}\n  });\n  ConnectedInteriorTester.findDifferentPoint = function (coord, pt) {\n  \tfor (var i = 0; i < coord.length; i++) {\n  \t\tif (!coord[i].equals(pt)) return coord[i];\n  \t}\n  \treturn null;\n  };\n\n  function EdgeEndBuilder() {}\n  extend(EdgeEndBuilder.prototype, {\n  \tcreateEdgeEndForNext: function createEdgeEndForNext(edge, l, eiCurr, eiNext) {\n  \t\tvar iNext = eiCurr.segmentIndex + 1;\n  \t\tif (iNext >= edge.getNumPoints() && eiNext === null) return null;\n  \t\tvar pNext = edge.getCoordinate(iNext);\n  \t\tif (eiNext !== null && eiNext.segmentIndex === eiCurr.segmentIndex) pNext = eiNext.coord;\n  \t\tvar e = new EdgeEnd(edge, eiCurr.coord, pNext, new Label(edge.getLabel()));\n  \t\tl.add(e);\n  \t},\n  \tcreateEdgeEndForPrev: function createEdgeEndForPrev(edge, l, eiCurr, eiPrev) {\n  \t\tvar iPrev = eiCurr.segmentIndex;\n  \t\tif (eiCurr.dist === 0.0) {\n  \t\t\tif (iPrev === 0) return null;\n  \t\t\tiPrev--;\n  \t\t}\n  \t\tvar pPrev = edge.getCoordinate(iPrev);\n  \t\tif (eiPrev !== null && eiPrev.segmentIndex >= iPrev) pPrev = eiPrev.coord;\n  \t\tvar label = new Label(edge.getLabel());\n  \t\tlabel.flip();\n  \t\tvar e = new EdgeEnd(edge, eiCurr.coord, pPrev, label);\n  \t\tl.add(e);\n  \t},\n  \tcomputeEdgeEnds: function computeEdgeEnds() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar edges = arguments[0];\n  \t\t\tvar l = new ArrayList();\n  \t\t\tfor (var i = edges; i.hasNext();) {\n  \t\t\t\tvar e = i.next();\n  \t\t\t\tthis.computeEdgeEnds(e, l);\n  \t\t\t}\n  \t\t\treturn l;\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar edge = arguments[0],\n  \t\t\t    l = arguments[1];\n  \t\t\tvar eiList = edge.getEdgeIntersectionList();\n  \t\t\teiList.addEndpoints();\n  \t\t\tvar it = eiList.iterator();\n  \t\t\tvar eiPrev = null;\n  \t\t\tvar eiCurr = null;\n  \t\t\tif (!it.hasNext()) return null;\n  \t\t\tvar eiNext = it.next();\n  \t\t\tdo {\n  \t\t\t\teiPrev = eiCurr;\n  \t\t\t\teiCurr = eiNext;\n  \t\t\t\teiNext = null;\n  \t\t\t\tif (it.hasNext()) eiNext = it.next();\n  \t\t\t\tif (eiCurr !== null) {\n  \t\t\t\t\tthis.createEdgeEndForPrev(edge, l, eiCurr, eiPrev);\n  \t\t\t\t\tthis.createEdgeEndForNext(edge, l, eiCurr, eiNext);\n  \t\t\t\t}\n  \t\t\t} while (eiCurr !== null);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn EdgeEndBuilder;\n  \t}\n  });\n\n  function EdgeEndBundle() {\n  \tthis._edgeEnds = new ArrayList();\n  \tif (arguments.length === 1) {\n  \t\tvar e = arguments[0];\n  \t\tEdgeEndBundle.call(this, null, e);\n  \t} else if (arguments.length === 2) {\n  \t\tvar e = arguments[1];\n  \t\tEdgeEnd.call(this, e.getEdge(), e.getCoordinate(), e.getDirectedCoordinate(), new Label(e.getLabel()));\n  \t\tthis.insert(e);\n  \t}\n  }\n  inherits$1(EdgeEndBundle, EdgeEnd);\n  extend(EdgeEndBundle.prototype, {\n  \tinsert: function insert(e) {\n  \t\tthis._edgeEnds.add(e);\n  \t},\n  \tprint: function print(out) {\n  \t\tout.println(\"EdgeEndBundle--> Label: \" + this._label);\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar ee = it.next();\n  \t\t\tee.print(out);\n  \t\t\tout.println();\n  \t\t}\n  \t},\n  \titerator: function iterator() {\n  \t\treturn this._edgeEnds.iterator();\n  \t},\n  \tgetEdgeEnds: function getEdgeEnds() {\n  \t\treturn this._edgeEnds;\n  \t},\n  \tcomputeLabelOn: function computeLabelOn(geomIndex, boundaryNodeRule) {\n  \t\tvar boundaryCount = 0;\n  \t\tvar foundInterior = false;\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar e = it.next();\n  \t\t\tvar loc = e.getLabel().getLocation(geomIndex);\n  \t\t\tif (loc === Location.BOUNDARY) boundaryCount++;\n  \t\t\tif (loc === Location.INTERIOR) foundInterior = true;\n  \t\t}\n  \t\tvar loc = Location.NONE;\n  \t\tif (foundInterior) loc = Location.INTERIOR;\n  \t\tif (boundaryCount > 0) {\n  \t\t\tloc = GeometryGraph.determineBoundary(boundaryNodeRule, boundaryCount);\n  \t\t}\n  \t\tthis._label.setLocation(geomIndex, loc);\n  \t},\n  \tcomputeLabelSide: function computeLabelSide(geomIndex, side) {\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar e = it.next();\n  \t\t\tif (e.getLabel().isArea()) {\n  \t\t\t\tvar loc = e.getLabel().getLocation(geomIndex, side);\n  \t\t\t\tif (loc === Location.INTERIOR) {\n  \t\t\t\t\tthis._label.setLocation(geomIndex, side, Location.INTERIOR);\n  \t\t\t\t\treturn null;\n  \t\t\t\t} else if (loc === Location.EXTERIOR) this._label.setLocation(geomIndex, side, Location.EXTERIOR);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetLabel: function getLabel() {\n  \t\treturn this._label;\n  \t},\n  \tcomputeLabelSides: function computeLabelSides(geomIndex) {\n  \t\tthis.computeLabelSide(geomIndex, Position.LEFT);\n  \t\tthis.computeLabelSide(geomIndex, Position.RIGHT);\n  \t},\n  \tupdateIM: function updateIM(im) {\n  \t\tEdge.updateIM(this._label, im);\n  \t},\n  \tcomputeLabel: function computeLabel(boundaryNodeRule) {\n  \t\tvar isArea = false;\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar e = it.next();\n  \t\t\tif (e.getLabel().isArea()) isArea = true;\n  \t\t}\n  \t\tif (isArea) this._label = new Label(Location.NONE, Location.NONE, Location.NONE);else this._label = new Label(Location.NONE);\n  \t\tfor (var i = 0; i < 2; i++) {\n  \t\t\tthis.computeLabelOn(i, boundaryNodeRule);\n  \t\t\tif (isArea) this.computeLabelSides(i);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn EdgeEndBundle;\n  \t}\n  });\n\n  function EdgeEndBundleStar() {\n  \tEdgeEndStar.apply(this);\n  }\n  inherits$1(EdgeEndBundleStar, EdgeEndStar);\n  extend(EdgeEndBundleStar.prototype, {\n  \tupdateIM: function updateIM(im) {\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar esb = it.next();\n  \t\t\tesb.updateIM(im);\n  \t\t}\n  \t},\n  \tinsert: function insert(e) {\n  \t\tvar eb = this._edgeMap.get(e);\n  \t\tif (eb === null) {\n  \t\t\teb = new EdgeEndBundle(e);\n  \t\t\tthis.insertEdgeEnd(e, eb);\n  \t\t} else {\n  \t\t\teb.insert(e);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn EdgeEndBundleStar;\n  \t}\n  });\n\n  function RelateNode() {\n  \tvar coord = arguments[0],\n  \t    edges = arguments[1];\n  \tNode.call(this, coord, edges);\n  }\n  inherits$1(RelateNode, Node);\n  extend(RelateNode.prototype, {\n  \tupdateIMFromEdges: function updateIMFromEdges(im) {\n  \t\tthis._edges.updateIM(im);\n  \t},\n  \tcomputeIM: function computeIM(im) {\n  \t\tim.setAtLeastIfValid(this._label.getLocation(0), this._label.getLocation(1), 0);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn RelateNode;\n  \t}\n  });\n\n  function RelateNodeFactory() {\n  \tNodeFactory.apply(this);\n  }\n  inherits$1(RelateNodeFactory, NodeFactory);\n  extend(RelateNodeFactory.prototype, {\n  \tcreateNode: function createNode(coord) {\n  \t\treturn new RelateNode(coord, new EdgeEndBundleStar());\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn RelateNodeFactory;\n  \t}\n  });\n\n  function RelateNodeGraph() {\n  \tthis._nodes = new NodeMap(new RelateNodeFactory());\n  }\n  extend(RelateNodeGraph.prototype, {\n  \tinsertEdgeEnds: function insertEdgeEnds(ee) {\n  \t\tfor (var i = ee.iterator(); i.hasNext();) {\n  \t\t\tvar e = i.next();\n  \t\t\tthis._nodes.add(e);\n  \t\t}\n  \t},\n  \tgetNodeIterator: function getNodeIterator() {\n  \t\treturn this._nodes.iterator();\n  \t},\n  \tcopyNodesAndLabels: function copyNodesAndLabels(geomGraph, argIndex) {\n  \t\tfor (var nodeIt = geomGraph.getNodeIterator(); nodeIt.hasNext();) {\n  \t\t\tvar graphNode = nodeIt.next();\n  \t\t\tvar newNode = this._nodes.addNode(graphNode.getCoordinate());\n  \t\t\tnewNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));\n  \t\t}\n  \t},\n  \tbuild: function build(geomGraph) {\n  \t\tthis.computeIntersectionNodes(geomGraph, 0);\n  \t\tthis.copyNodesAndLabels(geomGraph, 0);\n  \t\tvar eeBuilder = new EdgeEndBuilder();\n  \t\tvar eeList = eeBuilder.computeEdgeEnds(geomGraph.getEdgeIterator());\n  \t\tthis.insertEdgeEnds(eeList);\n  \t},\n  \tcomputeIntersectionNodes: function computeIntersectionNodes(geomGraph, argIndex) {\n  \t\tfor (var edgeIt = geomGraph.getEdgeIterator(); edgeIt.hasNext();) {\n  \t\t\tvar e = edgeIt.next();\n  \t\t\tvar eLoc = e.getLabel().getLocation(argIndex);\n  \t\t\tfor (var eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext();) {\n  \t\t\t\tvar ei = eiIt.next();\n  \t\t\t\tvar n = this._nodes.addNode(ei.coord);\n  \t\t\t\tif (eLoc === Location.BOUNDARY) n.setLabelBoundary(argIndex);else {\n  \t\t\t\t\tif (n.getLabel().isNull(argIndex)) n.setLabel(argIndex, Location.INTERIOR);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn RelateNodeGraph;\n  \t}\n  });\n\n  function ConsistentAreaTester() {\n  \tthis._li = new RobustLineIntersector();\n  \tthis._geomGraph = null;\n  \tthis._nodeGraph = new RelateNodeGraph();\n  \tthis._invalidPoint = null;\n  \tvar geomGraph = arguments[0];\n  \tthis._geomGraph = geomGraph;\n  }\n  extend(ConsistentAreaTester.prototype, {\n  \tisNodeEdgeAreaLabelsConsistent: function isNodeEdgeAreaLabelsConsistent() {\n  \t\tfor (var nodeIt = this._nodeGraph.getNodeIterator(); nodeIt.hasNext();) {\n  \t\t\tvar node = nodeIt.next();\n  \t\t\tif (!node.getEdges().isAreaLabelsConsistent(this._geomGraph)) {\n  \t\t\t\tthis._invalidPoint = node.getCoordinate().copy();\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t}\n  \t\treturn true;\n  \t},\n  \tgetInvalidPoint: function getInvalidPoint() {\n  \t\treturn this._invalidPoint;\n  \t},\n  \thasDuplicateRings: function hasDuplicateRings() {\n  \t\tfor (var nodeIt = this._nodeGraph.getNodeIterator(); nodeIt.hasNext();) {\n  \t\t\tvar node = nodeIt.next();\n  \t\t\tfor (var i = node.getEdges().iterator(); i.hasNext();) {\n  \t\t\t\tvar eeb = i.next();\n  \t\t\t\tif (eeb.getEdgeEnds().size() > 1) {\n  \t\t\t\t\tthis._invalidPoint = eeb.getEdge().getCoordinate(0);\n  \t\t\t\t\treturn true;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tisNodeConsistentArea: function isNodeConsistentArea() {\n  \t\tvar intersector = this._geomGraph.computeSelfNodes(this._li, true, true);\n  \t\tif (intersector.hasProperIntersection()) {\n  \t\t\tthis._invalidPoint = intersector.getProperIntersectionPoint();\n  \t\t\treturn false;\n  \t\t}\n  \t\tthis._nodeGraph.build(this._geomGraph);\n  \t\treturn this.isNodeEdgeAreaLabelsConsistent();\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn ConsistentAreaTester;\n  \t}\n  });\n\n  function IndexedNestedRingTester() {\n  \tthis._graph = null;\n  \tthis._rings = new ArrayList();\n  \tthis._totalEnv = new Envelope();\n  \tthis._index = null;\n  \tthis._nestedPt = null;\n  \tvar graph = arguments[0];\n  \tthis._graph = graph;\n  }\n  extend(IndexedNestedRingTester.prototype, {\n  \tbuildIndex: function buildIndex() {\n  \t\tthis._index = new STRtree();\n  \t\tfor (var i = 0; i < this._rings.size(); i++) {\n  \t\t\tvar ring = this._rings.get(i);\n  \t\t\tvar env = ring.getEnvelopeInternal();\n  \t\t\tthis._index.insert(env, ring);\n  \t\t}\n  \t},\n  \tgetNestedPoint: function getNestedPoint() {\n  \t\treturn this._nestedPt;\n  \t},\n  \tisNonNested: function isNonNested() {\n  \t\tthis.buildIndex();\n  \t\tfor (var i = 0; i < this._rings.size(); i++) {\n  \t\t\tvar innerRing = this._rings.get(i);\n  \t\t\tvar innerRingPts = innerRing.getCoordinates();\n  \t\t\tvar results = this._index.query(innerRing.getEnvelopeInternal());\n  \t\t\tfor (var j = 0; j < results.size(); j++) {\n  \t\t\t\tvar searchRing = results.get(j);\n  \t\t\t\tvar searchRingPts = searchRing.getCoordinates();\n  \t\t\t\tif (innerRing === searchRing) continue;\n  \t\t\t\tif (!innerRing.getEnvelopeInternal().intersects(searchRing.getEnvelopeInternal())) continue;\n  \t\t\t\tvar innerRingPt = IsValidOp.findPtNotNode(innerRingPts, searchRing, this._graph);\n  \t\t\t\tif (innerRingPt === null) continue;\n  \t\t\t\tvar isInside = CGAlgorithms.isPointInRing(innerRingPt, searchRingPts);\n  \t\t\t\tif (isInside) {\n  \t\t\t\t\tthis._nestedPt = innerRingPt;\n  \t\t\t\t\treturn false;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\treturn true;\n  \t},\n  \tadd: function add(ring) {\n  \t\tthis._rings.add(ring);\n  \t\tthis._totalEnv.expandToInclude(ring.getEnvelopeInternal());\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn IndexedNestedRingTester;\n  \t}\n  });\n\n  function TopologyValidationError() {\n  \tthis._errorType = null;\n  \tthis._pt = null;\n  \tif (arguments.length === 1) {\n  \t\tvar errorType = arguments[0];\n  \t\tTopologyValidationError.call(this, errorType, null);\n  \t} else if (arguments.length === 2) {\n  \t\tvar errorType = arguments[0],\n  \t\t    pt = arguments[1];\n  \t\tthis._errorType = errorType;\n  \t\tif (pt !== null) this._pt = pt.copy();\n  \t}\n  }\n  extend(TopologyValidationError.prototype, {\n  \tgetErrorType: function getErrorType() {\n  \t\treturn this._errorType;\n  \t},\n  \tgetMessage: function getMessage() {\n  \t\treturn TopologyValidationError.errMsg[this._errorType];\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\treturn this._pt;\n  \t},\n  \ttoString: function toString() {\n  \t\tvar locStr = \"\";\n  \t\tif (this._pt !== null) locStr = \" at or near point \" + this._pt;\n  \t\treturn this.getMessage() + locStr;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn TopologyValidationError;\n  \t}\n  });\n  TopologyValidationError.ERROR = 0;\n  TopologyValidationError.REPEATED_POINT = 1;\n  TopologyValidationError.HOLE_OUTSIDE_SHELL = 2;\n  TopologyValidationError.NESTED_HOLES = 3;\n  TopologyValidationError.DISCONNECTED_INTERIOR = 4;\n  TopologyValidationError.SELF_INTERSECTION = 5;\n  TopologyValidationError.RING_SELF_INTERSECTION = 6;\n  TopologyValidationError.NESTED_SHELLS = 7;\n  TopologyValidationError.DUPLICATE_RINGS = 8;\n  TopologyValidationError.TOO_FEW_POINTS = 9;\n  TopologyValidationError.INVALID_COORDINATE = 10;\n  TopologyValidationError.RING_NOT_CLOSED = 11;\n  TopologyValidationError.errMsg = [\"Topology Validation Error\", \"Repeated Point\", \"Hole lies outside shell\", \"Holes are nested\", \"Interior is disconnected\", \"Self-intersection\", \"Ring Self-intersection\", \"Nested shells\", \"Duplicate Rings\", \"Too few distinct points in geometry component\", \"Invalid Coordinate\", \"Ring is not closed\"];\n\n  function IsValidOp() {\n  \tthis._parentGeometry = null;\n  \tthis._isSelfTouchingRingFormingHoleValid = false;\n  \tthis._validErr = null;\n  \tvar parentGeometry = arguments[0];\n  \tthis._parentGeometry = parentGeometry;\n  }\n  extend(IsValidOp.prototype, {\n  \tcheckInvalidCoordinates: function checkInvalidCoordinates() {\n  \t\tif (arguments[0] instanceof Array) {\n  \t\t\tvar coords = arguments[0];\n  \t\t\tfor (var i = 0; i < coords.length; i++) {\n  \t\t\t\tif (!IsValidOp.isValid(coords[i])) {\n  \t\t\t\t\tthis._validErr = new TopologyValidationError(TopologyValidationError.INVALID_COORDINATE, coords[i]);\n  \t\t\t\t\treturn null;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} else if (arguments[0] instanceof Polygon) {\n  \t\t\tvar poly = arguments[0];\n  \t\t\tthis.checkInvalidCoordinates(poly.getExteriorRing().getCoordinates());\n  \t\t\tif (this._validErr !== null) return null;\n  \t\t\tfor (var i = 0; i < poly.getNumInteriorRing(); i++) {\n  \t\t\t\tthis.checkInvalidCoordinates(poly.getInteriorRingN(i).getCoordinates());\n  \t\t\t\tif (this._validErr !== null) return null;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcheckHolesNotNested: function checkHolesNotNested(p, graph) {\n  \t\tvar nestedTester = new IndexedNestedRingTester(graph);\n  \t\tfor (var i = 0; i < p.getNumInteriorRing(); i++) {\n  \t\t\tvar innerHole = p.getInteriorRingN(i);\n  \t\t\tnestedTester.add(innerHole);\n  \t\t}\n  \t\tvar isNonNested = nestedTester.isNonNested();\n  \t\tif (!isNonNested) {\n  \t\t\tthis._validErr = new TopologyValidationError(TopologyValidationError.NESTED_HOLES, nestedTester.getNestedPoint());\n  \t\t}\n  \t},\n  \tcheckConsistentArea: function checkConsistentArea(graph) {\n  \t\tvar cat = new ConsistentAreaTester(graph);\n  \t\tvar isValidArea = cat.isNodeConsistentArea();\n  \t\tif (!isValidArea) {\n  \t\t\tthis._validErr = new TopologyValidationError(TopologyValidationError.SELF_INTERSECTION, cat.getInvalidPoint());\n  \t\t\treturn null;\n  \t\t}\n  \t\tif (cat.hasDuplicateRings()) {\n  \t\t\tthis._validErr = new TopologyValidationError(TopologyValidationError.DUPLICATE_RINGS, cat.getInvalidPoint());\n  \t\t}\n  \t},\n  \tisValid: function isValid() {\n  \t\tthis.checkValid(this._parentGeometry);\n  \t\treturn this._validErr === null;\n  \t},\n  \tcheckShellInsideHole: function checkShellInsideHole(shell, hole, graph) {\n  \t\tvar shellPts = shell.getCoordinates();\n  \t\tvar holePts = hole.getCoordinates();\n  \t\tvar shellPt = IsValidOp.findPtNotNode(shellPts, hole, graph);\n  \t\tif (shellPt !== null) {\n  \t\t\tvar insideHole = CGAlgorithms.isPointInRing(shellPt, holePts);\n  \t\t\tif (!insideHole) {\n  \t\t\t\treturn shellPt;\n  \t\t\t}\n  \t\t}\n  \t\tvar holePt = IsValidOp.findPtNotNode(holePts, shell, graph);\n  \t\tif (holePt !== null) {\n  \t\t\tvar insideShell = CGAlgorithms.isPointInRing(holePt, shellPts);\n  \t\t\tif (insideShell) {\n  \t\t\t\treturn holePt;\n  \t\t\t}\n  \t\t\treturn null;\n  \t\t}\n  \t\tAssert.shouldNeverReachHere(\"points in shell and hole appear to be equal\");\n  \t\treturn null;\n  \t},\n  \tcheckNoSelfIntersectingRings: function checkNoSelfIntersectingRings(graph) {\n  \t\tfor (var i = graph.getEdgeIterator(); i.hasNext();) {\n  \t\t\tvar e = i.next();\n  \t\t\tthis.checkNoSelfIntersectingRing(e.getEdgeIntersectionList());\n  \t\t\tif (this._validErr !== null) return null;\n  \t\t}\n  \t},\n  \tcheckConnectedInteriors: function checkConnectedInteriors(graph) {\n  \t\tvar cit = new ConnectedInteriorTester(graph);\n  \t\tif (!cit.isInteriorsConnected()) this._validErr = new TopologyValidationError(TopologyValidationError.DISCONNECTED_INTERIOR, cit.getCoordinate());\n  \t},\n  \tcheckNoSelfIntersectingRing: function checkNoSelfIntersectingRing(eiList) {\n  \t\tvar nodeSet = new TreeSet();\n  \t\tvar isFirst = true;\n  \t\tfor (var i = eiList.iterator(); i.hasNext();) {\n  \t\t\tvar ei = i.next();\n  \t\t\tif (isFirst) {\n  \t\t\t\tisFirst = false;\n  \t\t\t\tcontinue;\n  \t\t\t}\n  \t\t\tif (nodeSet.contains(ei.coord)) {\n  \t\t\t\tthis._validErr = new TopologyValidationError(TopologyValidationError.RING_SELF_INTERSECTION, ei.coord);\n  \t\t\t\treturn null;\n  \t\t\t} else {\n  \t\t\t\tnodeSet.add(ei.coord);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcheckHolesInShell: function checkHolesInShell(p, graph) {\n  \t\tvar shell = p.getExteriorRing();\n  \t\tvar pir = new MCPointInRing(shell);\n  \t\tfor (var i = 0; i < p.getNumInteriorRing(); i++) {\n  \t\t\tvar hole = p.getInteriorRingN(i);\n  \t\t\tvar holePt = IsValidOp.findPtNotNode(hole.getCoordinates(), shell, graph);\n  \t\t\tif (holePt === null) return null;\n  \t\t\tvar outside = !pir.isInside(holePt);\n  \t\t\tif (outside) {\n  \t\t\t\tthis._validErr = new TopologyValidationError(TopologyValidationError.HOLE_OUTSIDE_SHELL, holePt);\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcheckTooFewPoints: function checkTooFewPoints(graph) {\n  \t\tif (graph.hasTooFewPoints()) {\n  \t\t\tthis._validErr = new TopologyValidationError(TopologyValidationError.TOO_FEW_POINTS, graph.getInvalidPoint());\n  \t\t\treturn null;\n  \t\t}\n  \t},\n  \tgetValidationError: function getValidationError() {\n  \t\tthis.checkValid(this._parentGeometry);\n  \t\treturn this._validErr;\n  \t},\n  \tcheckValid: function checkValid() {\n  \t\tif (arguments[0] instanceof Point) {\n  \t\t\tvar g = arguments[0];\n  \t\t\tthis.checkInvalidCoordinates(g.getCoordinates());\n  \t\t} else if (arguments[0] instanceof MultiPoint) {\n  \t\t\tvar g = arguments[0];\n  \t\t\tthis.checkInvalidCoordinates(g.getCoordinates());\n  \t\t} else if (arguments[0] instanceof LinearRing) {\n  \t\t\tvar g = arguments[0];\n  \t\t\tthis.checkInvalidCoordinates(g.getCoordinates());\n  \t\t\tif (this._validErr !== null) return null;\n  \t\t\tthis.checkClosedRing(g);\n  \t\t\tif (this._validErr !== null) return null;\n  \t\t\tvar graph = new GeometryGraph(0, g);\n  \t\t\tthis.checkTooFewPoints(graph);\n  \t\t\tif (this._validErr !== null) return null;\n  \t\t\tvar li = new RobustLineIntersector();\n  \t\t\tgraph.computeSelfNodes(li, true, true);\n  \t\t\tthis.checkNoSelfIntersectingRings(graph);\n  \t\t} else if (arguments[0] instanceof LineString) {\n  \t\t\tvar g = arguments[0];\n  \t\t\tthis.checkInvalidCoordinates(g.getCoordinates());\n  \t\t\tif (this._validErr !== null) return null;\n  \t\t\tvar graph = new GeometryGraph(0, g);\n  \t\t\tthis.checkTooFewPoints(graph);\n  \t\t} else if (arguments[0] instanceof Polygon) {\n  \t\t\tvar g = arguments[0];\n  \t\t\tthis.checkInvalidCoordinates(g);\n  \t\t\tif (this._validErr !== null) return null;\n  \t\t\tthis.checkClosedRings(g);\n  \t\t\tif (this._validErr !== null) return null;\n  \t\t\tvar graph = new GeometryGraph(0, g);\n  \t\t\tthis.checkTooFewPoints(graph);\n  \t\t\tif (this._validErr !== null) return null;\n  \t\t\tthis.checkConsistentArea(graph);\n  \t\t\tif (this._validErr !== null) return null;\n  \t\t\tif (!this._isSelfTouchingRingFormingHoleValid) {\n  \t\t\t\tthis.checkNoSelfIntersectingRings(graph);\n  \t\t\t\tif (this._validErr !== null) return null;\n  \t\t\t}\n  \t\t\tthis.checkHolesInShell(g, graph);\n  \t\t\tif (this._validErr !== null) return null;\n  \t\t\tthis.checkHolesNotNested(g, graph);\n  \t\t\tif (this._validErr !== null) return null;\n  \t\t\tthis.checkConnectedInteriors(graph);\n  \t\t} else if (arguments[0] instanceof MultiPolygon) {\n  \t\t\tvar g = arguments[0];\n  \t\t\tfor (var i = 0; i < g.getNumGeometries(); i++) {\n  \t\t\t\tvar p = g.getGeometryN(i);\n  \t\t\t\tthis.checkInvalidCoordinates(p);\n  \t\t\t\tif (this._validErr !== null) return null;\n  \t\t\t\tthis.checkClosedRings(p);\n  \t\t\t\tif (this._validErr !== null) return null;\n  \t\t\t}\n  \t\t\tvar graph = new GeometryGraph(0, g);\n  \t\t\tthis.checkTooFewPoints(graph);\n  \t\t\tif (this._validErr !== null) return null;\n  \t\t\tthis.checkConsistentArea(graph);\n  \t\t\tif (this._validErr !== null) return null;\n  \t\t\tif (!this._isSelfTouchingRingFormingHoleValid) {\n  \t\t\t\tthis.checkNoSelfIntersectingRings(graph);\n  \t\t\t\tif (this._validErr !== null) return null;\n  \t\t\t}\n  \t\t\tfor (var i = 0; i < g.getNumGeometries(); i++) {\n  \t\t\t\tvar p = g.getGeometryN(i);\n  \t\t\t\tthis.checkHolesInShell(p, graph);\n  \t\t\t\tif (this._validErr !== null) return null;\n  \t\t\t}\n  \t\t\tfor (var i = 0; i < g.getNumGeometries(); i++) {\n  \t\t\t\tvar p = g.getGeometryN(i);\n  \t\t\t\tthis.checkHolesNotNested(p, graph);\n  \t\t\t\tif (this._validErr !== null) return null;\n  \t\t\t}\n  \t\t\tthis.checkShellsNotNested(g, graph);\n  \t\t\tif (this._validErr !== null) return null;\n  \t\t\tthis.checkConnectedInteriors(graph);\n  \t\t} else if (arguments[0] instanceof GeometryCollection) {\n  \t\t\tvar gc = arguments[0];\n  \t\t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n  \t\t\t\tvar g = gc.getGeometryN(i);\n  \t\t\t\tthis.checkValid(g);\n  \t\t\t\tif (this._validErr !== null) return null;\n  \t\t\t}\n  \t\t} else if (arguments[0] instanceof Geometry) {\n  \t\t\tvar g = arguments[0];\n  \t\t\tthis._validErr = null;\n  \t\t\tif (g.isEmpty()) return null;\n  \t\t\tif (g instanceof Point) this.checkValid(g);else if (g instanceof MultiPoint) this.checkValid(g);else if (g instanceof LinearRing) this.checkValid(g);else if (g instanceof LineString) this.checkValid(g);else if (g instanceof Polygon) this.checkValid(g);else if (g instanceof MultiPolygon) this.checkValid(g);else if (g instanceof GeometryCollection) this.checkValid(g);else throw new UnsupportedOperationException(g.getClass().getName());\n  \t\t}\n  \t},\n  \tsetSelfTouchingRingFormingHoleValid: function setSelfTouchingRingFormingHoleValid(isValid) {\n  \t\tthis._isSelfTouchingRingFormingHoleValid = isValid;\n  \t},\n  \tcheckShellNotNested: function checkShellNotNested(shell, p, graph) {\n  \t\tvar shellPts = shell.getCoordinates();\n  \t\tvar polyShell = p.getExteriorRing();\n  \t\tvar polyPts = polyShell.getCoordinates();\n  \t\tvar shellPt = IsValidOp.findPtNotNode(shellPts, polyShell, graph);\n  \t\tif (shellPt === null) return null;\n  \t\tvar insidePolyShell = CGAlgorithms.isPointInRing(shellPt, polyPts);\n  \t\tif (!insidePolyShell) return null;\n  \t\tif (p.getNumInteriorRing() <= 0) {\n  \t\t\tthis._validErr = new TopologyValidationError(TopologyValidationError.NESTED_SHELLS, shellPt);\n  \t\t\treturn null;\n  \t\t}\n  \t\tvar badNestedPt = null;\n  \t\tfor (var i = 0; i < p.getNumInteriorRing(); i++) {\n  \t\t\tvar hole = p.getInteriorRingN(i);\n  \t\t\tbadNestedPt = this.checkShellInsideHole(shell, hole, graph);\n  \t\t\tif (badNestedPt === null) return null;\n  \t\t}\n  \t\tthis._validErr = new TopologyValidationError(TopologyValidationError.NESTED_SHELLS, badNestedPt);\n  \t},\n  \tcheckClosedRings: function checkClosedRings(poly) {\n  \t\tthis.checkClosedRing(poly.getExteriorRing());\n  \t\tif (this._validErr !== null) return null;\n  \t\tfor (var i = 0; i < poly.getNumInteriorRing(); i++) {\n  \t\t\tthis.checkClosedRing(poly.getInteriorRingN(i));\n  \t\t\tif (this._validErr !== null) return null;\n  \t\t}\n  \t},\n  \tcheckClosedRing: function checkClosedRing(ring) {\n  \t\tif (!ring.isClosed()) {\n  \t\t\tvar pt = null;\n  \t\t\tif (ring.getNumPoints() >= 1) pt = ring.getCoordinateN(0);\n  \t\t\tthis._validErr = new TopologyValidationError(TopologyValidationError.RING_NOT_CLOSED, pt);\n  \t\t}\n  \t},\n  \tcheckShellsNotNested: function checkShellsNotNested(mp, graph) {\n  \t\tfor (var i = 0; i < mp.getNumGeometries(); i++) {\n  \t\t\tvar p = mp.getGeometryN(i);\n  \t\t\tvar shell = p.getExteriorRing();\n  \t\t\tfor (var j = 0; j < mp.getNumGeometries(); j++) {\n  \t\t\t\tif (i === j) continue;\n  \t\t\t\tvar p2 = mp.getGeometryN(j);\n  \t\t\t\tthis.checkShellNotNested(shell, p2, graph);\n  \t\t\t\tif (this._validErr !== null) return null;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn IsValidOp;\n  \t}\n  });\n  IsValidOp.findPtNotNode = function (testCoords, searchRing, graph) {\n  \tvar searchEdge = graph.findEdge(searchRing);\n  \tvar eiList = searchEdge.getEdgeIntersectionList();\n  \tfor (var i = 0; i < testCoords.length; i++) {\n  \t\tvar pt = testCoords[i];\n  \t\tif (!eiList.isIntersection(pt)) return pt;\n  \t}\n  \treturn null;\n  };\n  IsValidOp.isValid = function () {\n  \tif (arguments[0] instanceof Geometry) {\n  \t\tvar geom = arguments[0];\n  \t\tvar isValidOp = new IsValidOp(geom);\n  \t\treturn isValidOp.isValid();\n  \t} else if (arguments[0] instanceof Coordinate) {\n  \t\tvar coord = arguments[0];\n  \t\tif (Double.isNaN(coord.x)) return false;\n  \t\tif (Double.isInfinite(coord.x)) return false;\n  \t\tif (Double.isNaN(coord.y)) return false;\n  \t\tif (Double.isInfinite(coord.y)) return false;\n  \t\treturn true;\n  \t}\n  };\n\n  function EdgeRing$1() {\n  \tthis._factory = null;\n  \tthis._deList = new ArrayList();\n  \tthis._lowestEdge = null;\n  \tthis._ring = null;\n  \tthis._ringPts = null;\n  \tthis._holes = null;\n  \tthis._shell = null;\n  \tthis._isHole = null;\n  \tthis._isProcessed = false;\n  \tthis._isIncludedSet = false;\n  \tthis._isIncluded = false;\n  \tvar factory = arguments[0];\n  \tthis._factory = factory;\n  }\n  extend(EdgeRing$1.prototype, {\n  \tisIncluded: function isIncluded() {\n  \t\treturn this._isIncluded;\n  \t},\n  \tgetCoordinates: function getCoordinates() {\n  \t\tif (this._ringPts === null) {\n  \t\t\tvar coordList = new CoordinateList();\n  \t\t\tfor (var i = this._deList.iterator(); i.hasNext();) {\n  \t\t\t\tvar de = i.next();\n  \t\t\t\tvar edge = de.getEdge();\n  \t\t\t\tEdgeRing$1.addEdge(edge.getLine().getCoordinates(), de.getEdgeDirection(), coordList);\n  \t\t\t}\n  \t\t\tthis._ringPts = coordList.toCoordinateArray();\n  \t\t}\n  \t\treturn this._ringPts;\n  \t},\n  \tisIncludedSet: function isIncludedSet() {\n  \t\treturn this._isIncludedSet;\n  \t},\n  \tisValid: function isValid() {\n  \t\tthis.getCoordinates();\n  \t\tif (this._ringPts.length <= 3) return false;\n  \t\tthis.getRing();\n  \t\treturn IsValidOp.isValid(this._ring);\n  \t},\n  \tbuild: function build(startDE) {\n  \t\tvar de = startDE;\n  \t\tdo {\n  \t\t\tthis.add(de);\n  \t\t\tde.setRing(this);\n  \t\t\tde = de.getNext();\n  \t\t\tAssert.isTrue(de !== null, \"found null DE in ring\");\n  \t\t\tAssert.isTrue(de === startDE || !de.isInRing(), \"found DE already in ring\");\n  \t\t} while (de !== startDE);\n  \t},\n  \tisOuterHole: function isOuterHole() {\n  \t\tif (!this._isHole) return false;\n  \t\treturn !this.hasShell();\n  \t},\n  \tgetPolygon: function getPolygon() {\n  \t\tvar holeLR = null;\n  \t\tif (this._holes !== null) {\n  \t\t\tholeLR = new Array(this._holes.size()).fill(null);\n  \t\t\tfor (var i = 0; i < this._holes.size(); i++) {\n  \t\t\t\tholeLR[i] = this._holes.get(i);\n  \t\t\t}\n  \t\t}\n  \t\tvar poly = this._factory.createPolygon(this._ring, holeLR);\n  \t\treturn poly;\n  \t},\n  \tisHole: function isHole() {\n  \t\treturn this._isHole;\n  \t},\n  \tisProcessed: function isProcessed() {\n  \t\treturn this._isProcessed;\n  \t},\n  \taddHole: function addHole() {\n  \t\tif (arguments[0] instanceof LinearRing) {\n  \t\t\tvar hole = arguments[0];\n  \t\t\tif (this._holes === null) this._holes = new ArrayList();\n  \t\t\tthis._holes.add(hole);\n  \t\t} else if (arguments[0] instanceof EdgeRing$1) {\n  \t\t\tvar holeER = arguments[0];\n  \t\t\tholeER.setShell(this);\n  \t\t\tvar hole = holeER.getRing();\n  \t\t\tif (this._holes === null) this._holes = new ArrayList();\n  \t\t\tthis._holes.add(hole);\n  \t\t}\n  \t},\n  \tsetIncluded: function setIncluded(isIncluded) {\n  \t\tthis._isIncluded = isIncluded;\n  \t\tthis._isIncludedSet = true;\n  \t},\n  \tgetOuterHole: function getOuterHole() {\n  \t\tif (this.isHole()) return null;\n  \t\tfor (var i = 0; i < this._deList.size(); i++) {\n  \t\t\tvar de = this._deList.get(i);\n  \t\t\tvar adjRing = de.getSym().getRing();\n  \t\t\tif (adjRing.isOuterHole()) return adjRing;\n  \t\t}\n  \t\treturn null;\n  \t},\n  \tcomputeHole: function computeHole() {\n  \t\tvar ring = this.getRing();\n  \t\tthis._isHole = CGAlgorithms.isCCW(ring.getCoordinates());\n  \t},\n  \thasShell: function hasShell() {\n  \t\treturn this._shell !== null;\n  \t},\n  \tisOuterShell: function isOuterShell() {\n  \t\treturn this.getOuterHole() !== null;\n  \t},\n  \tgetLineString: function getLineString() {\n  \t\tthis.getCoordinates();\n  \t\treturn this._factory.createLineString(this._ringPts);\n  \t},\n  \ttoString: function toString() {\n  \t\treturn WKTWriter.toLineString(new CoordinateArraySequence(this.getCoordinates()));\n  \t},\n  \tgetShell: function getShell() {\n  \t\tif (this.isHole()) return this._shell;\n  \t\treturn this;\n  \t},\n  \tadd: function add(de) {\n  \t\tthis._deList.add(de);\n  \t},\n  \tgetRing: function getRing() {\n  \t\tif (this._ring !== null) return this._ring;\n  \t\tthis.getCoordinates();\n  \t\tif (this._ringPts.length < 3) System.out.println(this._ringPts);\n  \t\ttry {\n  \t\t\tthis._ring = this._factory.createLinearRing(this._ringPts);\n  \t\t} catch (ex) {\n  \t\t\tif (ex instanceof Exception) {\n  \t\t\t\tSystem.out.println(this._ringPts);\n  \t\t\t} else throw ex;\n  \t\t} finally {}\n  \t\treturn this._ring;\n  \t},\n  \tupdateIncluded: function updateIncluded() {\n  \t\tif (this.isHole()) return null;\n  \t\tfor (var i = 0; i < this._deList.size(); i++) {\n  \t\t\tvar de = this._deList.get(i);\n  \t\t\tvar adjShell = de.getSym().getRing().getShell();\n  \t\t\tif (adjShell !== null && adjShell.isIncludedSet()) {\n  \t\t\t\tthis.setIncluded(!adjShell.isIncluded());\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tsetShell: function setShell(shell) {\n  \t\tthis._shell = shell;\n  \t},\n  \tsetProcessed: function setProcessed(isProcessed) {\n  \t\tthis._isProcessed = isProcessed;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn EdgeRing$1;\n  \t}\n  });\n  EdgeRing$1.findDirEdgesInRing = function (startDE) {\n  \tvar de = startDE;\n  \tvar edges = new ArrayList();\n  \tdo {\n  \t\tedges.add(de);\n  \t\tde = de.getNext();\n  \t\tAssert.isTrue(de !== null, \"found null DE in ring\");\n  \t\tAssert.isTrue(de === startDE || !de.isInRing(), \"found DE already in ring\");\n  \t} while (de !== startDE);\n  \treturn edges;\n  };\n  EdgeRing$1.addEdge = function (coords, isForward, coordList) {\n  \tif (isForward) {\n  \t\tfor (var i = 0; i < coords.length; i++) {\n  \t\t\tcoordList.add(coords[i], false);\n  \t\t}\n  \t} else {\n  \t\tfor (var i = coords.length - 1; i >= 0; i--) {\n  \t\t\tcoordList.add(coords[i], false);\n  \t\t}\n  \t}\n  };\n  EdgeRing$1.findEdgeRingContaining = function (testEr, shellList) {\n  \tvar testRing = testEr.getRing();\n  \tvar testEnv = testRing.getEnvelopeInternal();\n  \tvar testPt = testRing.getCoordinateN(0);\n  \tvar minShell = null;\n  \tvar minShellEnv = null;\n  \tfor (var it = shellList.iterator(); it.hasNext();) {\n  \t\tvar tryShell = it.next();\n  \t\tvar tryShellRing = tryShell.getRing();\n  \t\tvar tryShellEnv = tryShellRing.getEnvelopeInternal();\n  \t\tif (tryShellEnv.equals(testEnv)) continue;\n  \t\tif (!tryShellEnv.contains(testEnv)) continue;\n  \t\ttestPt = CoordinateArrays.ptNotInList(testRing.getCoordinates(), tryShellRing.getCoordinates());\n  \t\tvar isContained = false;\n  \t\tif (CGAlgorithms.isPointInRing(testPt, tryShellRing.getCoordinates())) isContained = true;\n  \t\tif (isContained) {\n  \t\t\tif (minShell === null || minShellEnv.contains(tryShellEnv)) {\n  \t\t\t\tminShell = tryShell;\n  \t\t\t\tminShellEnv = minShell.getRing().getEnvelopeInternal();\n  \t\t\t}\n  \t\t}\n  \t}\n  \treturn minShell;\n  };\n  function EnvelopeComparator() {}\n  extend(EnvelopeComparator.prototype, {\n  \tcompare: function compare(obj0, obj1) {\n  \t\tvar r0 = obj0;\n  \t\tvar r1 = obj1;\n  \t\treturn r0.getRing().getEnvelope().compareTo(r1.getRing().getEnvelope());\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparator];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn EnvelopeComparator;\n  \t}\n  });\n  EdgeRing$1.EnvelopeComparator = EnvelopeComparator;\n\n  function PolygonizeGraph() {\n  \tPlanarGraph$1.apply(this);\n  \tthis._factory = null;\n  \tvar factory = arguments[0];\n  \tthis._factory = factory;\n  }\n  inherits$1(PolygonizeGraph, PlanarGraph$1);\n  extend(PolygonizeGraph.prototype, {\n  \tfindEdgeRing: function findEdgeRing(startDE) {\n  \t\tvar er = new EdgeRing$1(this._factory);\n  \t\ter.build(startDE);\n  \t\treturn er;\n  \t},\n  \tcomputeDepthParity: function computeDepthParity() {\n  \t\tif (arguments.length === 0) {\n  \t\t\twhile (true) {\n  \t\t\t\tvar de = null;\n  \t\t\t\tif (de === null) return null;\n  \t\t\t\tthis.computeDepthParity(de);\n  \t\t\t}\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tvar de = arguments[0];\n  \t\t}\n  \t},\n  \tcomputeNextCWEdges: function computeNextCWEdges() {\n  \t\tfor (var iNode = this.nodeIterator(); iNode.hasNext();) {\n  \t\t\tvar node = iNode.next();\n  \t\t\tPolygonizeGraph.computeNextCWEdges(node);\n  \t\t}\n  \t},\n  \taddEdge: function addEdge(line) {\n  \t\tif (line.isEmpty()) {\n  \t\t\treturn null;\n  \t\t}\n  \t\tvar linePts = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());\n  \t\tif (linePts.length < 2) {\n  \t\t\treturn null;\n  \t\t}\n  \t\tvar startPt = linePts[0];\n  \t\tvar endPt = linePts[linePts.length - 1];\n  \t\tvar nStart = this.getNode(startPt);\n  \t\tvar nEnd = this.getNode(endPt);\n  \t\tvar de0 = new PolygonizeDirectedEdge(nStart, nEnd, linePts[1], true);\n  \t\tvar de1 = new PolygonizeDirectedEdge(nEnd, nStart, linePts[linePts.length - 2], false);\n  \t\tvar edge = new PolygonizeEdge(line);\n  \t\tedge.setDirectedEdges(de0, de1);\n  \t\tthis.add(edge);\n  \t},\n  \tdeleteCutEdges: function deleteCutEdges() {\n  \t\tthis.computeNextCWEdges();\n  \t\tPolygonizeGraph.findLabeledEdgeRings(this._dirEdges);\n  \t\tvar cutLines = new ArrayList();\n  \t\tfor (var i = this._dirEdges.iterator(); i.hasNext();) {\n  \t\t\tvar de = i.next();\n  \t\t\tif (de.isMarked()) continue;\n  \t\t\tvar sym = de.getSym();\n  \t\t\tif (de.getLabel() === sym.getLabel()) {\n  \t\t\t\tde.setMarked(true);\n  \t\t\t\tsym.setMarked(true);\n  \t\t\t\tvar e = de.getEdge();\n  \t\t\t\tcutLines.add(e.getLine());\n  \t\t\t}\n  \t\t}\n  \t\treturn cutLines;\n  \t},\n  \tgetEdgeRings: function getEdgeRings() {\n  \t\tthis.computeNextCWEdges();\n  \t\tPolygonizeGraph.label(this._dirEdges, -1);\n  \t\tvar maximalRings = PolygonizeGraph.findLabeledEdgeRings(this._dirEdges);\n  \t\tthis.convertMaximalToMinimalEdgeRings(maximalRings);\n  \t\tvar edgeRingList = new ArrayList();\n  \t\tfor (var i = this._dirEdges.iterator(); i.hasNext();) {\n  \t\t\tvar de = i.next();\n  \t\t\tif (de.isMarked()) continue;\n  \t\t\tif (de.isInRing()) continue;\n  \t\t\tvar er = this.findEdgeRing(de);\n  \t\t\tedgeRingList.add(er);\n  \t\t}\n  \t\treturn edgeRingList;\n  \t},\n  \tgetNode: function getNode(pt) {\n  \t\tvar node = this.findNode(pt);\n  \t\tif (node === null) {\n  \t\t\tnode = new Node$3(pt);\n  \t\t\tthis.add(node);\n  \t\t}\n  \t\treturn node;\n  \t},\n  \tconvertMaximalToMinimalEdgeRings: function convertMaximalToMinimalEdgeRings(ringEdges) {\n  \t\tfor (var i = ringEdges.iterator(); i.hasNext();) {\n  \t\t\tvar de = i.next();\n  \t\t\tvar label = de.getLabel();\n  \t\t\tvar intNodes = PolygonizeGraph.findIntersectionNodes(de, label);\n  \t\t\tif (intNodes === null) continue;\n  \t\t\tfor (var iNode = intNodes.iterator(); iNode.hasNext();) {\n  \t\t\t\tvar node = iNode.next();\n  \t\t\t\tPolygonizeGraph.computeNextCCWEdges(node, label);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tdeleteDangles: function deleteDangles() {\n  \t\tvar nodesToRemove = this.findNodesOfDegree(1);\n  \t\tvar dangleLines = new HashSet();\n  \t\tvar nodeStack = new Stack$1();\n  \t\tfor (var i = nodesToRemove.iterator(); i.hasNext();) {\n  \t\t\tnodeStack.push(i.next());\n  \t\t}\n  \t\twhile (!nodeStack.isEmpty()) {\n  \t\t\tvar node = nodeStack.pop();\n  \t\t\tPolygonizeGraph.deleteAllEdges(node);\n  \t\t\tvar nodeOutEdges = node.getOutEdges().getEdges();\n  \t\t\tfor (var i = nodeOutEdges.iterator(); i.hasNext();) {\n  \t\t\t\tvar de = i.next();\n  \t\t\t\tde.setMarked(true);\n  \t\t\t\tvar sym = de.getSym();\n  \t\t\t\tif (sym !== null) sym.setMarked(true);\n  \t\t\t\tvar e = de.getEdge();\n  \t\t\t\tdangleLines.add(e.getLine());\n  \t\t\t\tvar toNode = de.getToNode();\n  \t\t\t\tif (PolygonizeGraph.getDegreeNonDeleted(toNode) === 1) nodeStack.push(toNode);\n  \t\t\t}\n  \t\t}\n  \t\treturn dangleLines;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn PolygonizeGraph;\n  \t}\n  });\n  PolygonizeGraph.findLabeledEdgeRings = function (dirEdges) {\n  \tvar edgeRingStarts = new ArrayList();\n  \tvar currLabel = 1;\n  \tfor (var i = dirEdges.iterator(); i.hasNext();) {\n  \t\tvar de = i.next();\n  \t\tif (de.isMarked()) continue;\n  \t\tif (de.getLabel() >= 0) continue;\n  \t\tedgeRingStarts.add(de);\n  \t\tvar edges = EdgeRing$1.findDirEdgesInRing(de);\n  \t\tPolygonizeGraph.label(edges, currLabel);\n  \t\tcurrLabel++;\n  \t}\n  \treturn edgeRingStarts;\n  };\n  PolygonizeGraph.getDegreeNonDeleted = function (node) {\n  \tvar edges = node.getOutEdges().getEdges();\n  \tvar degree = 0;\n  \tfor (var i = edges.iterator(); i.hasNext();) {\n  \t\tvar de = i.next();\n  \t\tif (!de.isMarked()) degree++;\n  \t}\n  \treturn degree;\n  };\n  PolygonizeGraph.deleteAllEdges = function (node) {\n  \tvar edges = node.getOutEdges().getEdges();\n  \tfor (var i = edges.iterator(); i.hasNext();) {\n  \t\tvar de = i.next();\n  \t\tde.setMarked(true);\n  \t\tvar sym = de.getSym();\n  \t\tif (sym !== null) sym.setMarked(true);\n  \t}\n  };\n  PolygonizeGraph.label = function (dirEdges, label) {\n  \tfor (var i = dirEdges.iterator(); i.hasNext();) {\n  \t\tvar de = i.next();\n  \t\tde.setLabel(label);\n  \t}\n  };\n  PolygonizeGraph.computeNextCWEdges = function (node) {\n  \tvar deStar = node.getOutEdges();\n  \tvar startDE = null;\n  \tvar prevDE = null;\n  \tfor (var i = deStar.getEdges().iterator(); i.hasNext();) {\n  \t\tvar outDE = i.next();\n  \t\tif (outDE.isMarked()) continue;\n  \t\tif (startDE === null) startDE = outDE;\n  \t\tif (prevDE !== null) {\n  \t\t\tvar sym = prevDE.getSym();\n  \t\t\tsym.setNext(outDE);\n  \t\t}\n  \t\tprevDE = outDE;\n  \t}\n  \tif (prevDE !== null) {\n  \t\tvar sym = prevDE.getSym();\n  \t\tsym.setNext(startDE);\n  \t}\n  };\n  PolygonizeGraph.computeNextCCWEdges = function (node, label) {\n  \tvar deStar = node.getOutEdges();\n  \tvar firstOutDE = null;\n  \tvar prevInDE = null;\n  \tvar edges = deStar.getEdges();\n  \tfor (var i = edges.size() - 1; i >= 0; i--) {\n  \t\tvar de = edges.get(i);\n  \t\tvar sym = de.getSym();\n  \t\tvar outDE = null;\n  \t\tif (de.getLabel() === label) outDE = de;\n  \t\tvar inDE = null;\n  \t\tif (sym.getLabel() === label) inDE = sym;\n  \t\tif (outDE === null && inDE === null) continue;\n  \t\tif (inDE !== null) {\n  \t\t\tprevInDE = inDE;\n  \t\t}\n  \t\tif (outDE !== null) {\n  \t\t\tif (prevInDE !== null) {\n  \t\t\t\tprevInDE.setNext(outDE);\n  \t\t\t\tprevInDE = null;\n  \t\t\t}\n  \t\t\tif (firstOutDE === null) firstOutDE = outDE;\n  \t\t}\n  \t}\n  \tif (prevInDE !== null) {\n  \t\tAssert.isTrue(firstOutDE !== null);\n  \t\tprevInDE.setNext(firstOutDE);\n  \t}\n  };\n  PolygonizeGraph.getDegree = function (node, label) {\n  \tvar edges = node.getOutEdges().getEdges();\n  \tvar degree = 0;\n  \tfor (var i = edges.iterator(); i.hasNext();) {\n  \t\tvar de = i.next();\n  \t\tif (de.getLabel() === label) degree++;\n  \t}\n  \treturn degree;\n  };\n  PolygonizeGraph.findIntersectionNodes = function (startDE, label) {\n  \tvar de = startDE;\n  \tvar intNodes = null;\n  \tdo {\n  \t\tvar node = de.getFromNode();\n  \t\tif (PolygonizeGraph.getDegree(node, label) > 1) {\n  \t\t\tif (intNodes === null) intNodes = new ArrayList();\n  \t\t\tintNodes.add(node);\n  \t\t}\n  \t\tde = de.getNext();\n  \t\tAssert.isTrue(de !== null, \"found null DE in ring\");\n  \t\tAssert.isTrue(de === startDE || !de.isInRing(), \"found DE already in ring\");\n  \t} while (de !== startDE);\n  \treturn intNodes;\n  };\n\n  function Polygonizer() {\n  \tthis._lineStringAdder = new LineStringAdder(this);\n  \tthis._graph = null;\n  \tthis._dangles = new ArrayList();\n  \tthis._cutEdges = new ArrayList();\n  \tthis._invalidRingLines = new ArrayList();\n  \tthis._holeList = null;\n  \tthis._shellList = null;\n  \tthis._polyList = null;\n  \tthis._isCheckingRingsValid = true;\n  \tthis._extractOnlyPolygonal = null;\n  \tthis._geomFactory = null;\n  \tif (arguments.length === 0) {\n  \t\tPolygonizer.call(this, false);\n  \t} else if (arguments.length === 1) {\n  \t\tvar extractOnlyPolygonal = arguments[0];\n  \t\tthis._extractOnlyPolygonal = extractOnlyPolygonal;\n  \t}\n  }\n  extend(Polygonizer.prototype, {\n  \tgetGeometry: function getGeometry() {\n  \t\tif (this._geomFactory === null) this._geomFactory = new GeometryFactory();\n  \t\tthis.polygonize();\n  \t\tif (this._extractOnlyPolygonal) {\n  \t\t\treturn this._geomFactory.buildGeometry(this._polyList);\n  \t\t}\n  \t\treturn this._geomFactory.createGeometryCollection(GeometryFactory.toGeometryArray(this._polyList));\n  \t},\n  \tgetInvalidRingLines: function getInvalidRingLines() {\n  \t\tthis.polygonize();\n  \t\treturn this._invalidRingLines;\n  \t},\n  \tfindValidRings: function findValidRings(edgeRingList, validEdgeRingList, invalidRingList) {\n  \t\tfor (var i = edgeRingList.iterator(); i.hasNext();) {\n  \t\t\tvar er = i.next();\n  \t\t\tif (er.isValid()) validEdgeRingList.add(er);else invalidRingList.add(er.getLineString());\n  \t\t}\n  \t},\n  \tpolygonize: function polygonize() {\n  \t\tif (this._polyList !== null) return null;\n  \t\tthis._polyList = new ArrayList();\n  \t\tif (this._graph === null) return null;\n  \t\tthis._dangles = this._graph.deleteDangles();\n  \t\tthis._cutEdges = this._graph.deleteCutEdges();\n  \t\tvar edgeRingList = this._graph.getEdgeRings();\n  \t\tvar validEdgeRingList = new ArrayList();\n  \t\tthis._invalidRingLines = new ArrayList();\n  \t\tif (this._isCheckingRingsValid) {\n  \t\t\tthis.findValidRings(edgeRingList, validEdgeRingList, this._invalidRingLines);\n  \t\t} else {\n  \t\t\tvalidEdgeRingList = edgeRingList;\n  \t\t}\n  \t\tthis.findShellsAndHoles(validEdgeRingList);\n  \t\tPolygonizer.assignHolesToShells(this._holeList, this._shellList);\n  \t\tCollections.sort(this._shellList, new EdgeRing$1.EnvelopeComparator());\n  \t\tvar includeAll = true;\n  \t\tif (this._extractOnlyPolygonal) {\n  \t\t\tPolygonizer.findDisjointShells(this._shellList);\n  \t\t\tincludeAll = false;\n  \t\t}\n  \t\tthis._polyList = Polygonizer.extractPolygons(this._shellList, includeAll);\n  \t},\n  \tgetDangles: function getDangles() {\n  \t\tthis.polygonize();\n  \t\treturn this._dangles;\n  \t},\n  \tgetCutEdges: function getCutEdges() {\n  \t\tthis.polygonize();\n  \t\treturn this._cutEdges;\n  \t},\n  \tgetPolygons: function getPolygons() {\n  \t\tthis.polygonize();\n  \t\treturn this._polyList;\n  \t},\n  \tadd: function add() {\n  \t\tif (hasInterface(arguments[0], Collection)) {\n  \t\t\tvar geomList = arguments[0];\n  \t\t\tfor (var i = geomList.iterator(); i.hasNext();) {\n  \t\t\t\tvar geometry = i.next();\n  \t\t\t\tthis.add(geometry);\n  \t\t\t}\n  \t\t} else if (arguments[0] instanceof LineString) {\n  \t\t\tvar line = arguments[0];\n  \t\t\tthis._geomFactory = line.getFactory();\n  \t\t\tif (this._graph === null) this._graph = new PolygonizeGraph(this._geomFactory);\n  \t\t\tthis._graph.addEdge(line);\n  \t\t} else if (arguments[0] instanceof Geometry) {\n  \t\t\tvar g = arguments[0];\n  \t\t\tg.apply(this._lineStringAdder);\n  \t\t}\n  \t},\n  \tsetCheckRingsValid: function setCheckRingsValid(isCheckingRingsValid) {\n  \t\tthis._isCheckingRingsValid = isCheckingRingsValid;\n  \t},\n  \tfindShellsAndHoles: function findShellsAndHoles(edgeRingList) {\n  \t\tthis._holeList = new ArrayList();\n  \t\tthis._shellList = new ArrayList();\n  \t\tfor (var i = edgeRingList.iterator(); i.hasNext();) {\n  \t\t\tvar er = i.next();\n  \t\t\ter.computeHole();\n  \t\t\tif (er.isHole()) this._holeList.add(er);else this._shellList.add(er);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Polygonizer;\n  \t}\n  });\n  Polygonizer.findOuterShells = function (shellList) {\n  \tfor (var i = shellList.iterator(); i.hasNext();) {\n  \t\tvar er = i.next();\n  \t\tvar outerHoleER = er.getOuterHole();\n  \t\tif (outerHoleER !== null && !outerHoleER.isProcessed()) {\n  \t\t\ter.setIncluded(true);\n  \t\t\touterHoleER.setProcessed(true);\n  \t\t}\n  \t}\n  };\n  Polygonizer.extractPolygons = function (shellList, includeAll) {\n  \tvar polyList = new ArrayList();\n  \tfor (var i = shellList.iterator(); i.hasNext();) {\n  \t\tvar er = i.next();\n  \t\tif (includeAll || er.isIncluded()) {\n  \t\t\tpolyList.add(er.getPolygon());\n  \t\t}\n  \t}\n  \treturn polyList;\n  };\n  Polygonizer.assignHolesToShells = function (holeList, shellList) {\n  \tfor (var i = holeList.iterator(); i.hasNext();) {\n  \t\tvar holeER = i.next();\n  \t\tPolygonizer.assignHoleToShell(holeER, shellList);\n  \t}\n  };\n  Polygonizer.assignHoleToShell = function (holeER, shellList) {\n  \tvar shell = EdgeRing$1.findEdgeRingContaining(holeER, shellList);\n  \tif (shell !== null) {\n  \t\tshell.addHole(holeER);\n  \t}\n  };\n  Polygonizer.findDisjointShells = function (shellList) {\n  \tPolygonizer.findOuterShells(shellList);\n  \tvar isMoreToScan = null;\n  \tdo {\n  \t\tisMoreToScan = false;\n  \t\tfor (var i = shellList.iterator(); i.hasNext();) {\n  \t\t\tvar er = i.next();\n  \t\t\tif (er.isIncludedSet()) continue;\n  \t\t\ter.updateIncluded();\n  \t\t\tif (!er.isIncludedSet()) {\n  \t\t\t\tisMoreToScan = true;\n  \t\t\t}\n  \t\t}\n  \t} while (isMoreToScan);\n  };\n  function LineStringAdder() {\n  \tthis.p = null;\n  \tvar p = arguments[0];\n  \tthis.p = p;\n  }\n  extend(LineStringAdder.prototype, {\n  \tfilter: function filter(g) {\n  \t\tif (g instanceof LineString) this.p.add(g);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [GeometryComponentFilter];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LineStringAdder;\n  \t}\n  });\n  Polygonizer.LineStringAdder = LineStringAdder;\n\n  function RelateComputer() {\n  \tthis._li = new RobustLineIntersector();\n  \tthis._ptLocator = new PointLocator();\n  \tthis._arg = null;\n  \tthis._nodes = new NodeMap(new RelateNodeFactory());\n  \tthis._im = null;\n  \tthis._isolatedEdges = new ArrayList();\n  \tthis._invalidPoint = null;\n  \tvar arg = arguments[0];\n  \tthis._arg = arg;\n  }\n  extend(RelateComputer.prototype, {\n  \tinsertEdgeEnds: function insertEdgeEnds(ee) {\n  \t\tfor (var i = ee.iterator(); i.hasNext();) {\n  \t\t\tvar e = i.next();\n  \t\t\tthis._nodes.add(e);\n  \t\t}\n  \t},\n  \tcomputeProperIntersectionIM: function computeProperIntersectionIM(intersector, im) {\n  \t\tvar dimA = this._arg[0].getGeometry().getDimension();\n  \t\tvar dimB = this._arg[1].getGeometry().getDimension();\n  \t\tvar hasProper = intersector.hasProperIntersection();\n  \t\tvar hasProperInterior = intersector.hasProperInteriorIntersection();\n  \t\tif (dimA === 2 && dimB === 2) {\n  \t\t\tif (hasProper) im.setAtLeast(\"212101212\");\n  \t\t} else if (dimA === 2 && dimB === 1) {\n  \t\t\tif (hasProper) im.setAtLeast(\"FFF0FFFF2\");\n  \t\t\tif (hasProperInterior) im.setAtLeast(\"1FFFFF1FF\");\n  \t\t} else if (dimA === 1 && dimB === 2) {\n  \t\t\tif (hasProper) im.setAtLeast(\"F0FFFFFF2\");\n  \t\t\tif (hasProperInterior) im.setAtLeast(\"1F1FFFFFF\");\n  \t\t} else if (dimA === 1 && dimB === 1) {\n  \t\t\tif (hasProperInterior) im.setAtLeast(\"0FFFFFFFF\");\n  \t\t}\n  \t},\n  \tlabelIsolatedEdges: function labelIsolatedEdges(thisIndex, targetIndex) {\n  \t\tfor (var ei = this._arg[thisIndex].getEdgeIterator(); ei.hasNext();) {\n  \t\t\tvar e = ei.next();\n  \t\t\tif (e.isIsolated()) {\n  \t\t\t\tthis.labelIsolatedEdge(e, targetIndex, this._arg[targetIndex].getGeometry());\n  \t\t\t\tthis._isolatedEdges.add(e);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tlabelIsolatedEdge: function labelIsolatedEdge(e, targetIndex, target) {\n  \t\tif (target.getDimension() > 0) {\n  \t\t\tvar loc = this._ptLocator.locate(e.getCoordinate(), target);\n  \t\t\te.getLabel().setAllLocations(targetIndex, loc);\n  \t\t} else {\n  \t\t\te.getLabel().setAllLocations(targetIndex, Location.EXTERIOR);\n  \t\t}\n  \t},\n  \tcomputeIM: function computeIM() {\n  \t\tvar im = new IntersectionMatrix();\n  \t\tim.set(Location.EXTERIOR, Location.EXTERIOR, 2);\n  \t\tif (!this._arg[0].getGeometry().getEnvelopeInternal().intersects(this._arg[1].getGeometry().getEnvelopeInternal())) {\n  \t\t\tthis.computeDisjointIM(im);\n  \t\t\treturn im;\n  \t\t}\n  \t\tthis._arg[0].computeSelfNodes(this._li, false);\n  \t\tthis._arg[1].computeSelfNodes(this._li, false);\n  \t\tvar intersector = this._arg[0].computeEdgeIntersections(this._arg[1], this._li, false);\n  \t\tthis.computeIntersectionNodes(0);\n  \t\tthis.computeIntersectionNodes(1);\n  \t\tthis.copyNodesAndLabels(0);\n  \t\tthis.copyNodesAndLabels(1);\n  \t\tthis.labelIsolatedNodes();\n  \t\tthis.computeProperIntersectionIM(intersector, im);\n  \t\tvar eeBuilder = new EdgeEndBuilder();\n  \t\tvar ee0 = eeBuilder.computeEdgeEnds(this._arg[0].getEdgeIterator());\n  \t\tthis.insertEdgeEnds(ee0);\n  \t\tvar ee1 = eeBuilder.computeEdgeEnds(this._arg[1].getEdgeIterator());\n  \t\tthis.insertEdgeEnds(ee1);\n  \t\tthis.labelNodeEdges();\n  \t\tthis.labelIsolatedEdges(0, 1);\n  \t\tthis.labelIsolatedEdges(1, 0);\n  \t\tthis.updateIM(im);\n  \t\treturn im;\n  \t},\n  \tlabelNodeEdges: function labelNodeEdges() {\n  \t\tfor (var ni = this._nodes.iterator(); ni.hasNext();) {\n  \t\t\tvar node = ni.next();\n  \t\t\tnode.getEdges().computeLabelling(this._arg);\n  \t\t}\n  \t},\n  \tcopyNodesAndLabels: function copyNodesAndLabels(argIndex) {\n  \t\tfor (var i = this._arg[argIndex].getNodeIterator(); i.hasNext();) {\n  \t\t\tvar graphNode = i.next();\n  \t\t\tvar newNode = this._nodes.addNode(graphNode.getCoordinate());\n  \t\t\tnewNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));\n  \t\t}\n  \t},\n  \tlabelIntersectionNodes: function labelIntersectionNodes(argIndex) {\n  \t\tfor (var i = this._arg[argIndex].getEdgeIterator(); i.hasNext();) {\n  \t\t\tvar e = i.next();\n  \t\t\tvar eLoc = e.getLabel().getLocation(argIndex);\n  \t\t\tfor (var eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext();) {\n  \t\t\t\tvar ei = eiIt.next();\n  \t\t\t\tvar n = this._nodes.find(ei.coord);\n  \t\t\t\tif (n.getLabel().isNull(argIndex)) {\n  \t\t\t\t\tif (eLoc === Location.BOUNDARY) n.setLabelBoundary(argIndex);else n.setLabel(argIndex, Location.INTERIOR);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tlabelIsolatedNode: function labelIsolatedNode(n, targetIndex) {\n  \t\tvar loc = this._ptLocator.locate(n.getCoordinate(), this._arg[targetIndex].getGeometry());\n  \t\tn.getLabel().setAllLocations(targetIndex, loc);\n  \t},\n  \tcomputeIntersectionNodes: function computeIntersectionNodes(argIndex) {\n  \t\tfor (var i = this._arg[argIndex].getEdgeIterator(); i.hasNext();) {\n  \t\t\tvar e = i.next();\n  \t\t\tvar eLoc = e.getLabel().getLocation(argIndex);\n  \t\t\tfor (var eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext();) {\n  \t\t\t\tvar ei = eiIt.next();\n  \t\t\t\tvar n = this._nodes.addNode(ei.coord);\n  \t\t\t\tif (eLoc === Location.BOUNDARY) n.setLabelBoundary(argIndex);else {\n  \t\t\t\t\tif (n.getLabel().isNull(argIndex)) n.setLabel(argIndex, Location.INTERIOR);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tlabelIsolatedNodes: function labelIsolatedNodes() {\n  \t\tfor (var ni = this._nodes.iterator(); ni.hasNext();) {\n  \t\t\tvar n = ni.next();\n  \t\t\tvar label = n.getLabel();\n  \t\t\tAssert.isTrue(label.getGeometryCount() > 0, \"node with empty label found\");\n  \t\t\tif (n.isIsolated()) {\n  \t\t\t\tif (label.isNull(0)) this.labelIsolatedNode(n, 0);else this.labelIsolatedNode(n, 1);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tupdateIM: function updateIM(im) {\n  \t\tfor (var ei = this._isolatedEdges.iterator(); ei.hasNext();) {\n  \t\t\tvar e = ei.next();\n  \t\t\te.updateIM(im);\n  \t\t}\n  \t\tfor (var ni = this._nodes.iterator(); ni.hasNext();) {\n  \t\t\tvar node = ni.next();\n  \t\t\tnode.updateIM(im);\n  \t\t\tnode.updateIMFromEdges(im);\n  \t\t}\n  \t},\n  \tcomputeDisjointIM: function computeDisjointIM(im) {\n  \t\tvar ga = this._arg[0].getGeometry();\n  \t\tif (!ga.isEmpty()) {\n  \t\t\tim.set(Location.INTERIOR, Location.EXTERIOR, ga.getDimension());\n  \t\t\tim.set(Location.BOUNDARY, Location.EXTERIOR, ga.getBoundaryDimension());\n  \t\t}\n  \t\tvar gb = this._arg[1].getGeometry();\n  \t\tif (!gb.isEmpty()) {\n  \t\t\tim.set(Location.EXTERIOR, Location.INTERIOR, gb.getDimension());\n  \t\t\tim.set(Location.EXTERIOR, Location.BOUNDARY, gb.getBoundaryDimension());\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn RelateComputer;\n  \t}\n  });\n\n  function RectangleContains() {\n  \tthis._rectEnv = null;\n  \tvar rectangle = arguments[0];\n  \tthis._rectEnv = rectangle.getEnvelopeInternal();\n  }\n  extend(RectangleContains.prototype, {\n  \tisContainedInBoundary: function isContainedInBoundary(geom) {\n  \t\tif (geom instanceof Polygon) return false;\n  \t\tif (geom instanceof Point) return this.isPointContainedInBoundary(geom);\n  \t\tif (geom instanceof LineString) return this.isLineStringContainedInBoundary(geom);\n  \t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n  \t\t\tvar comp = geom.getGeometryN(i);\n  \t\t\tif (!this.isContainedInBoundary(comp)) return false;\n  \t\t}\n  \t\treturn true;\n  \t},\n  \tisLineSegmentContainedInBoundary: function isLineSegmentContainedInBoundary(p0, p1) {\n  \t\tif (p0.equals(p1)) return this.isPointContainedInBoundary(p0);\n  \t\tif (p0.x === p1.x) {\n  \t\t\tif (p0.x === this._rectEnv.getMinX() || p0.x === this._rectEnv.getMaxX()) return true;\n  \t\t} else if (p0.y === p1.y) {\n  \t\t\tif (p0.y === this._rectEnv.getMinY() || p0.y === this._rectEnv.getMaxY()) return true;\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tisLineStringContainedInBoundary: function isLineStringContainedInBoundary(line) {\n  \t\tvar seq = line.getCoordinateSequence();\n  \t\tvar p0 = new Coordinate();\n  \t\tvar p1 = new Coordinate();\n  \t\tfor (var i = 0; i < seq.size() - 1; i++) {\n  \t\t\tseq.getCoordinate(i, p0);\n  \t\t\tseq.getCoordinate(i + 1, p1);\n  \t\t\tif (!this.isLineSegmentContainedInBoundary(p0, p1)) return false;\n  \t\t}\n  \t\treturn true;\n  \t},\n  \tisPointContainedInBoundary: function isPointContainedInBoundary() {\n  \t\tif (arguments[0] instanceof Point) {\n  \t\t\tvar point = arguments[0];\n  \t\t\treturn this.isPointContainedInBoundary(point.getCoordinate());\n  \t\t} else if (arguments[0] instanceof Coordinate) {\n  \t\t\tvar pt = arguments[0];\n  \t\t\treturn pt.x === this._rectEnv.getMinX() || pt.x === this._rectEnv.getMaxX() || pt.y === this._rectEnv.getMinY() || pt.y === this._rectEnv.getMaxY();\n  \t\t}\n  \t},\n  \tcontains: function contains(geom) {\n  \t\tif (!this._rectEnv.contains(geom.getEnvelopeInternal())) return false;\n  \t\tif (this.isContainedInBoundary(geom)) return false;\n  \t\treturn true;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn RectangleContains;\n  \t}\n  });\n  RectangleContains.contains = function (rectangle, b) {\n  \tvar rc = new RectangleContains(rectangle);\n  \treturn rc.contains(b);\n  };\n\n  function RectangleLineIntersector() {\n  \tthis._li = new RobustLineIntersector();\n  \tthis._rectEnv = null;\n  \tthis._diagUp0 = null;\n  \tthis._diagUp1 = null;\n  \tthis._diagDown0 = null;\n  \tthis._diagDown1 = null;\n  \tvar rectEnv = arguments[0];\n  \tthis._rectEnv = rectEnv;\n  \tthis._diagUp0 = new Coordinate(rectEnv.getMinX(), rectEnv.getMinY());\n  \tthis._diagUp1 = new Coordinate(rectEnv.getMaxX(), rectEnv.getMaxY());\n  \tthis._diagDown0 = new Coordinate(rectEnv.getMinX(), rectEnv.getMaxY());\n  \tthis._diagDown1 = new Coordinate(rectEnv.getMaxX(), rectEnv.getMinY());\n  }\n  extend(RectangleLineIntersector.prototype, {\n  \tintersects: function intersects(p0, p1) {\n  \t\tvar segEnv = new Envelope(p0, p1);\n  \t\tif (!this._rectEnv.intersects(segEnv)) return false;\n  \t\tif (this._rectEnv.intersects(p0)) return true;\n  \t\tif (this._rectEnv.intersects(p1)) return true;\n  \t\tif (p0.compareTo(p1) > 0) {\n  \t\t\tvar tmp = p0;\n  \t\t\tp0 = p1;\n  \t\t\tp1 = tmp;\n  \t\t}\n  \t\tvar isSegUpwards = false;\n  \t\tif (p1.y > p0.y) isSegUpwards = true;\n  \t\tif (isSegUpwards) {\n  \t\t\tthis._li.computeIntersection(p0, p1, this._diagDown0, this._diagDown1);\n  \t\t} else {\n  \t\t\tthis._li.computeIntersection(p0, p1, this._diagUp0, this._diagUp1);\n  \t\t}\n  \t\tif (this._li.hasIntersection()) return true;\n  \t\treturn false;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn RectangleLineIntersector;\n  \t}\n  });\n\n  function ShortCircuitedGeometryVisitor() {\n  \tthis._isDone = false;\n  }\n  extend(ShortCircuitedGeometryVisitor.prototype, {\n  \tapplyTo: function applyTo(geom) {\n  \t\tfor (var i = 0; i < geom.getNumGeometries() && !this._isDone; i++) {\n  \t\t\tvar element = geom.getGeometryN(i);\n  \t\t\tif (!(element instanceof GeometryCollection)) {\n  \t\t\t\tthis.visit(element);\n  \t\t\t\tif (this.isDone()) {\n  \t\t\t\t\tthis._isDone = true;\n  \t\t\t\t\treturn null;\n  \t\t\t\t}\n  \t\t\t} else this.applyTo(element);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn ShortCircuitedGeometryVisitor;\n  \t}\n  });\n\n  function RectangleIntersects() {\n  \tthis._rectangle = null;\n  \tthis._rectEnv = null;\n  \tvar rectangle = arguments[0];\n  \tthis._rectangle = rectangle;\n  \tthis._rectEnv = rectangle.getEnvelopeInternal();\n  }\n  extend(RectangleIntersects.prototype, {\n  \tintersects: function intersects(geom) {\n  \t\tif (!this._rectEnv.intersects(geom.getEnvelopeInternal())) return false;\n  \t\tvar visitor = new EnvelopeIntersectsVisitor(this._rectEnv);\n  \t\tvisitor.applyTo(geom);\n  \t\tif (visitor.intersects()) return true;\n  \t\tvar ecpVisitor = new GeometryContainsPointVisitor(this._rectangle);\n  \t\tecpVisitor.applyTo(geom);\n  \t\tif (ecpVisitor.containsPoint()) return true;\n  \t\tvar riVisitor = new RectangleIntersectsSegmentVisitor(this._rectangle);\n  \t\triVisitor.applyTo(geom);\n  \t\tif (riVisitor.intersects()) return true;\n  \t\treturn false;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn RectangleIntersects;\n  \t}\n  });\n  RectangleIntersects.intersects = function (rectangle, b) {\n  \tvar rp = new RectangleIntersects(rectangle);\n  \treturn rp.intersects(b);\n  };\n  function EnvelopeIntersectsVisitor() {\n  \tShortCircuitedGeometryVisitor.apply(this);\n  \tthis._rectEnv = null;\n  \tthis._intersects = false;\n  \tvar rectEnv = arguments[0];\n  \tthis._rectEnv = rectEnv;\n  }\n  inherits$1(EnvelopeIntersectsVisitor, ShortCircuitedGeometryVisitor);\n  extend(EnvelopeIntersectsVisitor.prototype, {\n  \tisDone: function isDone() {\n  \t\treturn this._intersects === true;\n  \t},\n  \tvisit: function visit(element) {\n  \t\tvar elementEnv = element.getEnvelopeInternal();\n  \t\tif (!this._rectEnv.intersects(elementEnv)) {\n  \t\t\treturn null;\n  \t\t}\n  \t\tif (this._rectEnv.contains(elementEnv)) {\n  \t\t\tthis._intersects = true;\n  \t\t\treturn null;\n  \t\t}\n  \t\tif (elementEnv.getMinX() >= this._rectEnv.getMinX() && elementEnv.getMaxX() <= this._rectEnv.getMaxX()) {\n  \t\t\tthis._intersects = true;\n  \t\t\treturn null;\n  \t\t}\n  \t\tif (elementEnv.getMinY() >= this._rectEnv.getMinY() && elementEnv.getMaxY() <= this._rectEnv.getMaxY()) {\n  \t\t\tthis._intersects = true;\n  \t\t\treturn null;\n  \t\t}\n  \t},\n  \tintersects: function intersects() {\n  \t\treturn this._intersects;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn EnvelopeIntersectsVisitor;\n  \t}\n  });\n  function GeometryContainsPointVisitor() {\n  \tShortCircuitedGeometryVisitor.apply(this);\n  \tthis._rectSeq = null;\n  \tthis._rectEnv = null;\n  \tthis._containsPoint = false;\n  \tvar rectangle = arguments[0];\n  \tthis._rectSeq = rectangle.getExteriorRing().getCoordinateSequence();\n  \tthis._rectEnv = rectangle.getEnvelopeInternal();\n  }\n  inherits$1(GeometryContainsPointVisitor, ShortCircuitedGeometryVisitor);\n  extend(GeometryContainsPointVisitor.prototype, {\n  \tisDone: function isDone() {\n  \t\treturn this._containsPoint === true;\n  \t},\n  \tvisit: function visit(geom) {\n  \t\tif (!(geom instanceof Polygon)) return null;\n  \t\tvar elementEnv = geom.getEnvelopeInternal();\n  \t\tif (!this._rectEnv.intersects(elementEnv)) return null;\n  \t\tvar rectPt = new Coordinate();\n  \t\tfor (var i = 0; i < 4; i++) {\n  \t\t\tthis._rectSeq.getCoordinate(i, rectPt);\n  \t\t\tif (!elementEnv.contains(rectPt)) continue;\n  \t\t\tif (SimplePointInAreaLocator.containsPointInPolygon(rectPt, geom)) {\n  \t\t\t\tthis._containsPoint = true;\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcontainsPoint: function containsPoint() {\n  \t\treturn this._containsPoint;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn GeometryContainsPointVisitor;\n  \t}\n  });\n  function RectangleIntersectsSegmentVisitor() {\n  \tShortCircuitedGeometryVisitor.apply(this);\n  \tthis._rectEnv = null;\n  \tthis._rectIntersector = null;\n  \tthis._hasIntersection = false;\n  \tthis._p0 = new Coordinate();\n  \tthis._p1 = new Coordinate();\n  \tvar rectangle = arguments[0];\n  \tthis._rectEnv = rectangle.getEnvelopeInternal();\n  \tthis._rectIntersector = new RectangleLineIntersector(this._rectEnv);\n  }\n  inherits$1(RectangleIntersectsSegmentVisitor, ShortCircuitedGeometryVisitor);\n  extend(RectangleIntersectsSegmentVisitor.prototype, {\n  \tintersects: function intersects() {\n  \t\treturn this._hasIntersection;\n  \t},\n  \tisDone: function isDone() {\n  \t\treturn this._hasIntersection === true;\n  \t},\n  \tvisit: function visit(geom) {\n  \t\tvar elementEnv = geom.getEnvelopeInternal();\n  \t\tif (!this._rectEnv.intersects(elementEnv)) return null;\n  \t\tvar lines = LinearComponentExtracter.getLines(geom);\n  \t\tthis.checkIntersectionWithLineStrings(lines);\n  \t},\n  \tcheckIntersectionWithLineStrings: function checkIntersectionWithLineStrings(lines) {\n  \t\tfor (var i = lines.iterator(); i.hasNext();) {\n  \t\t\tvar testLine = i.next();\n  \t\t\tthis.checkIntersectionWithSegments(testLine);\n  \t\t\tif (this._hasIntersection) return null;\n  \t\t}\n  \t},\n  \tcheckIntersectionWithSegments: function checkIntersectionWithSegments(testLine) {\n  \t\tvar seq1 = testLine.getCoordinateSequence();\n  \t\tfor (var j = 1; j < seq1.size(); j++) {\n  \t\t\tseq1.getCoordinate(j - 1, this._p0);\n  \t\t\tseq1.getCoordinate(j, this._p1);\n  \t\t\tif (this._rectIntersector.intersects(this._p0, this._p1)) {\n  \t\t\t\tthis._hasIntersection = true;\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn RectangleIntersectsSegmentVisitor;\n  \t}\n  });\n\n  function RelateOp() {\n  \tthis._relate = null;\n  \tif (arguments.length === 2) {\n  \t\tvar g0 = arguments[0],\n  \t\t    g1 = arguments[1];\n  \t\tGeometryGraphOperation.call(this, g0, g1);\n  \t\tthis._relate = new RelateComputer(this._arg);\n  \t} else if (arguments.length === 3) {\n  \t\tvar g0 = arguments[0],\n  \t\t    g1 = arguments[1],\n  \t\t    boundaryNodeRule = arguments[2];\n  \t\tGeometryGraphOperation.call(this, g0, g1, boundaryNodeRule);\n  \t\tthis._relate = new RelateComputer(this._arg);\n  \t}\n  }\n  inherits$1(RelateOp, GeometryGraphOperation);\n  extend(RelateOp.prototype, {\n  \tgetIntersectionMatrix: function getIntersectionMatrix() {\n  \t\treturn this._relate.computeIM();\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn RelateOp;\n  \t}\n  });\n  RelateOp.covers = function (g1, g2) {\n  \tif (!g1.getEnvelopeInternal().covers(g2.getEnvelopeInternal())) return false;\n  \tif (g1.isRectangle()) {\n  \t\treturn true;\n  \t}\n  \treturn RelateOp.relate(g1, g2).isCovers();\n  };\n  RelateOp.intersects = function (g1, g2) {\n  \tif (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;\n  \tif (g1.isRectangle()) {\n  \t\treturn RectangleIntersects.intersects(g1, g2);\n  \t}\n  \tif (g2.isRectangle()) {\n  \t\treturn RectangleIntersects.intersects(g2, g1);\n  \t}\n  \treturn RelateOp.relate(g1, g2).isIntersects();\n  };\n  RelateOp.touches = function (g1, g2) {\n  \tif (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;\n  \treturn RelateOp.relate(g1, g2).isTouches(g1.getDimension(), g2.getDimension());\n  };\n  RelateOp.within = function (g1, g2) {\n  \treturn g2.contains(g1);\n  };\n  RelateOp.coveredBy = function (g1, g2) {\n  \treturn RelateOp.covers(g2, g1);\n  };\n  RelateOp.relate = function () {\n  \tif (arguments.length === 2) {\n  \t\tvar a = arguments[0],\n  \t\t    b = arguments[1];\n  \t\tvar relOp = new RelateOp(a, b);\n  \t\tvar im = relOp.getIntersectionMatrix();\n  \t\treturn im;\n  \t} else if (arguments.length === 3) {\n  \t\tif (typeof arguments[2] === \"string\" && arguments[0] instanceof Geometry && arguments[1] instanceof Geometry) {\n  \t\t\tvar g1 = arguments[0],\n  \t\t\t    g2 = arguments[1],\n  \t\t\t    intersectionPattern = arguments[2];\n  \t\t\treturn RelateOp.relateWithCheck(g1, g2).matches(intersectionPattern);\n  \t\t} else if (hasInterface(arguments[2], BoundaryNodeRule) && arguments[0] instanceof Geometry && arguments[1] instanceof Geometry) {\n  \t\t\tvar a = arguments[0],\n  \t\t\t    b = arguments[1],\n  \t\t\t    boundaryNodeRule = arguments[2];\n  \t\t\tvar relOp = new RelateOp(a, b, boundaryNodeRule);\n  \t\t\tvar im = relOp.getIntersectionMatrix();\n  \t\t\treturn im;\n  \t\t}\n  \t}\n  };\n  RelateOp.overlaps = function (g1, g2) {\n  \tif (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;\n  \treturn RelateOp.relate(g1, g2).isOverlaps(g1.getDimension(), g2.getDimension());\n  };\n  RelateOp.disjoint = function (g1, g2) {\n  \treturn !g1.intersects(g2);\n  };\n  RelateOp.relateWithCheck = function (g1, g2) {\n  \tg1.checkNotGeometryCollection(g1);\n  \tg1.checkNotGeometryCollection(g2);\n  \treturn RelateOp.relate(g1, g2);\n  };\n  RelateOp.crosses = function (g1, g2) {\n  \tif (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;\n  \treturn RelateOp.relate(g1, g2).isCrosses(g1.getDimension(), g2.getDimension());\n  };\n  RelateOp.contains = function (g1, g2) {\n  \tif (!g1.getEnvelopeInternal().contains(g2.getEnvelopeInternal())) return false;\n  \tif (g1.isRectangle()) {\n  \t\treturn RectangleContains.contains(g1, g2);\n  \t}\n  \treturn RelateOp.relate(g1, g2).isContains();\n  };\n\n  function GeometryCombiner() {\n  \tthis._geomFactory = null;\n  \tthis._skipEmpty = false;\n  \tthis._inputGeoms = null;\n  \tvar geoms = arguments[0];\n  \tthis._geomFactory = GeometryCombiner.extractFactory(geoms);\n  \tthis._inputGeoms = geoms;\n  }\n  extend(GeometryCombiner.prototype, {\n  \textractElements: function extractElements(geom, elems) {\n  \t\tif (geom === null) return null;\n  \t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n  \t\t\tvar elemGeom = geom.getGeometryN(i);\n  \t\t\tif (this._skipEmpty && elemGeom.isEmpty()) continue;\n  \t\t\telems.add(elemGeom);\n  \t\t}\n  \t},\n  \tcombine: function combine() {\n  \t\tvar elems = new ArrayList();\n  \t\tfor (var i = this._inputGeoms.iterator(); i.hasNext();) {\n  \t\t\tvar g = i.next();\n  \t\t\tthis.extractElements(g, elems);\n  \t\t}\n  \t\tif (elems.size() === 0) {\n  \t\t\tif (this._geomFactory !== null) {\n  \t\t\t\treturn this._geomFactory.createGeometryCollection(null);\n  \t\t\t}\n  \t\t\treturn null;\n  \t\t}\n  \t\treturn this._geomFactory.buildGeometry(elems);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn GeometryCombiner;\n  \t}\n  });\n  GeometryCombiner.combine = function () {\n  \tif (arguments.length === 1) {\n  \t\tvar geoms = arguments[0];\n  \t\tvar combiner = new GeometryCombiner(geoms);\n  \t\treturn combiner.combine();\n  \t} else if (arguments.length === 2) {\n  \t\tvar g0 = arguments[0],\n  \t\t    g1 = arguments[1];\n  \t\tvar combiner = new GeometryCombiner(GeometryCombiner.createList(g0, g1));\n  \t\treturn combiner.combine();\n  \t} else if (arguments.length === 3) {\n  \t\tvar g0 = arguments[0],\n  \t\t    g1 = arguments[1],\n  \t\t    g2 = arguments[2];\n  \t\tvar combiner = new GeometryCombiner(GeometryCombiner.createList(g0, g1, g2));\n  \t\treturn combiner.combine();\n  \t}\n  };\n  GeometryCombiner.extractFactory = function (geoms) {\n  \tif (geoms.isEmpty()) return null;\n  \treturn geoms.iterator().next().getFactory();\n  };\n  GeometryCombiner.createList = function () {\n  \tif (arguments.length === 2) {\n  \t\tvar obj0 = arguments[0],\n  \t\t    obj1 = arguments[1];\n  \t\tvar list = new ArrayList();\n  \t\tlist.add(obj0);\n  \t\tlist.add(obj1);\n  \t\treturn list;\n  \t} else if (arguments.length === 3) {\n  \t\tvar obj0 = arguments[0],\n  \t\t    obj1 = arguments[1],\n  \t\t    obj2 = arguments[2];\n  \t\tvar list = new ArrayList();\n  \t\tlist.add(obj0);\n  \t\tlist.add(obj1);\n  \t\tlist.add(obj2);\n  \t\treturn list;\n  \t}\n  };\n\n  function CascadedPolygonUnion() {\n  \tthis._inputPolys = null;\n  \tthis._geomFactory = null;\n  \tvar polys = arguments[0];\n  \tthis._inputPolys = polys;\n  \tif (this._inputPolys === null) this._inputPolys = new ArrayList();\n  }\n  extend(CascadedPolygonUnion.prototype, {\n  \treduceToGeometries: function reduceToGeometries(geomTree) {\n  \t\tvar geoms = new ArrayList();\n  \t\tfor (var i = geomTree.iterator(); i.hasNext();) {\n  \t\t\tvar o = i.next();\n  \t\t\tvar geom = null;\n  \t\t\tif (hasInterface(o, List)) {\n  \t\t\t\tgeom = this.unionTree(o);\n  \t\t\t} else if (o instanceof Geometry) {\n  \t\t\t\tgeom = o;\n  \t\t\t}\n  \t\t\tgeoms.add(geom);\n  \t\t}\n  \t\treturn geoms;\n  \t},\n  \textractByEnvelope: function extractByEnvelope(env, geom, disjointGeoms) {\n  \t\tvar intersectingGeoms = new ArrayList();\n  \t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n  \t\t\tvar elem = geom.getGeometryN(i);\n  \t\t\tif (elem.getEnvelopeInternal().intersects(env)) intersectingGeoms.add(elem);else disjointGeoms.add(elem);\n  \t\t}\n  \t\treturn this._geomFactory.buildGeometry(intersectingGeoms);\n  \t},\n  \tunionOptimized: function unionOptimized(g0, g1) {\n  \t\tvar g0Env = g0.getEnvelopeInternal();\n  \t\tvar g1Env = g1.getEnvelopeInternal();\n  \t\tif (!g0Env.intersects(g1Env)) {\n  \t\t\tvar combo = GeometryCombiner.combine(g0, g1);\n  \t\t\treturn combo;\n  \t\t}\n  \t\tif (g0.getNumGeometries() <= 1 && g1.getNumGeometries() <= 1) return this.unionActual(g0, g1);\n  \t\tvar commonEnv = g0Env.intersection(g1Env);\n  \t\treturn this.unionUsingEnvelopeIntersection(g0, g1, commonEnv);\n  \t},\n  \tunion: function union() {\n  \t\tif (this._inputPolys === null) throw new IllegalStateException(\"union() method cannot be called twice\");\n  \t\tif (this._inputPolys.isEmpty()) return null;\n  \t\tthis._geomFactory = this._inputPolys.iterator().next().getFactory();\n  \t\tvar index = new STRtree(CascadedPolygonUnion.STRTREE_NODE_CAPACITY);\n  \t\tfor (var i = this._inputPolys.iterator(); i.hasNext();) {\n  \t\t\tvar item = i.next();\n  \t\t\tindex.insert(item.getEnvelopeInternal(), item);\n  \t\t}\n  \t\tthis._inputPolys = null;\n  \t\tvar itemTree = index.itemsTree();\n  \t\tvar unionAll = this.unionTree(itemTree);\n  \t\treturn unionAll;\n  \t},\n  \tbinaryUnion: function binaryUnion() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar geoms = arguments[0];\n  \t\t\treturn this.binaryUnion(geoms, 0, geoms.size());\n  \t\t} else if (arguments.length === 3) {\n  \t\t\tvar geoms = arguments[0],\n  \t\t\t    start = arguments[1],\n  \t\t\t    end = arguments[2];\n  \t\t\tif (end - start <= 1) {\n  \t\t\t\tvar g0 = CascadedPolygonUnion.getGeometry(geoms, start);\n  \t\t\t\treturn this.unionSafe(g0, null);\n  \t\t\t} else if (end - start === 2) {\n  \t\t\t\treturn this.unionSafe(CascadedPolygonUnion.getGeometry(geoms, start), CascadedPolygonUnion.getGeometry(geoms, start + 1));\n  \t\t\t} else {\n  \t\t\t\tvar mid = Math.trunc((end + start) / 2);\n  \t\t\t\tvar g0 = this.binaryUnion(geoms, start, mid);\n  \t\t\t\tvar g1 = this.binaryUnion(geoms, mid, end);\n  \t\t\t\treturn this.unionSafe(g0, g1);\n  \t\t\t}\n  \t\t}\n  \t},\n  \trepeatedUnion: function repeatedUnion(geoms) {\n  \t\tvar union = null;\n  \t\tfor (var i = geoms.iterator(); i.hasNext();) {\n  \t\t\tvar g = i.next();\n  \t\t\tif (union === null) union = g.copy();else union = union.union(g);\n  \t\t}\n  \t\treturn union;\n  \t},\n  \tunionSafe: function unionSafe(g0, g1) {\n  \t\tif (g0 === null && g1 === null) return null;\n  \t\tif (g0 === null) return g1.copy();\n  \t\tif (g1 === null) return g0.copy();\n  \t\treturn this.unionOptimized(g0, g1);\n  \t},\n  \tunionActual: function unionActual(g0, g1) {\n  \t\treturn CascadedPolygonUnion.restrictToPolygons(g0.union(g1));\n  \t},\n  \tunionTree: function unionTree(geomTree) {\n  \t\tvar geoms = this.reduceToGeometries(geomTree);\n  \t\tvar union = this.binaryUnion(geoms);\n  \t\treturn union;\n  \t},\n  \tunionUsingEnvelopeIntersection: function unionUsingEnvelopeIntersection(g0, g1, common) {\n  \t\tvar disjointPolys = new ArrayList();\n  \t\tvar g0Int = this.extractByEnvelope(common, g0, disjointPolys);\n  \t\tvar g1Int = this.extractByEnvelope(common, g1, disjointPolys);\n  \t\tvar union = this.unionActual(g0Int, g1Int);\n  \t\tdisjointPolys.add(union);\n  \t\tvar overallUnion = GeometryCombiner.combine(disjointPolys);\n  \t\treturn overallUnion;\n  \t},\n  \tbufferUnion: function bufferUnion() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar geoms = arguments[0];\n  \t\t\tvar factory = geoms.get(0).getFactory();\n  \t\t\tvar gColl = factory.buildGeometry(geoms);\n  \t\t\tvar unionAll = gColl.buffer(0.0);\n  \t\t\treturn unionAll;\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar g0 = arguments[0],\n  \t\t\t    g1 = arguments[1];\n  \t\t\tvar factory = g0.getFactory();\n  \t\t\tvar gColl = factory.createGeometryCollection([g0, g1]);\n  \t\t\tvar unionAll = gColl.buffer(0.0);\n  \t\t\treturn unionAll;\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn CascadedPolygonUnion;\n  \t}\n  });\n  CascadedPolygonUnion.restrictToPolygons = function (g) {\n  \tif (hasInterface(g, Polygonal)) {\n  \t\treturn g;\n  \t}\n  \tvar polygons = PolygonExtracter.getPolygons(g);\n  \tif (polygons.size() === 1) return polygons.get(0);\n  \treturn g.getFactory().createMultiPolygon(GeometryFactory.toPolygonArray(polygons));\n  };\n  CascadedPolygonUnion.getGeometry = function (list, index) {\n  \tif (index >= list.size()) return null;\n  \treturn list.get(index);\n  };\n  CascadedPolygonUnion.union = function (polys) {\n  \tvar op = new CascadedPolygonUnion(polys);\n  \treturn op.union();\n  };\n  CascadedPolygonUnion.STRTREE_NODE_CAPACITY = 4;\n\n  function PointGeometryUnion() {\n  \tthis._pointGeom = null;\n  \tthis._otherGeom = null;\n  \tthis._geomFact = null;\n  \tvar pointGeom = arguments[0],\n  \t    otherGeom = arguments[1];\n  \tthis._pointGeom = pointGeom;\n  \tthis._otherGeom = otherGeom;\n  \tthis._geomFact = otherGeom.getFactory();\n  }\n  extend(PointGeometryUnion.prototype, {\n  \tunion: function union() {\n  \t\tvar locater = new PointLocator();\n  \t\tvar exteriorCoords = new TreeSet();\n  \t\tfor (var i = 0; i < this._pointGeom.getNumGeometries(); i++) {\n  \t\t\tvar point = this._pointGeom.getGeometryN(i);\n  \t\t\tvar coord = point.getCoordinate();\n  \t\t\tvar loc = locater.locate(coord, this._otherGeom);\n  \t\t\tif (loc === Location.EXTERIOR) exteriorCoords.add(coord);\n  \t\t}\n  \t\tif (exteriorCoords.size() === 0) return this._otherGeom;\n  \t\tvar ptComp = null;\n  \t\tvar coords = CoordinateArrays.toCoordinateArray(exteriorCoords);\n  \t\tif (coords.length === 1) {\n  \t\t\tptComp = this._geomFact.createPoint(coords[0]);\n  \t\t} else {\n  \t\t\tptComp = this._geomFact.createMultiPointFromCoords(coords);\n  \t\t}\n  \t\treturn GeometryCombiner.combine(ptComp, this._otherGeom);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn PointGeometryUnion;\n  \t}\n  });\n  PointGeometryUnion.union = function (pointGeom, otherGeom) {\n  \tvar unioner = new PointGeometryUnion(pointGeom, otherGeom);\n  \treturn unioner.union();\n  };\n\n  function GeometryExtracter() {\n  \tthis._sortIndex = -1;\n  \tthis._comps = null;\n  \tvar sortIndex = arguments[0],\n  \t    comps = arguments[1];\n  \tthis._sortIndex = sortIndex;\n  \tthis._comps = comps;\n  }\n  extend(GeometryExtracter.prototype, {\n  \tfilter: function filter(geom) {\n  \t\tif (this._sortIndex === -1 || geom.getSortIndex() === this._sortIndex) this._comps.add(geom);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [GeometryFilter];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn GeometryExtracter;\n  \t}\n  });\n  GeometryExtracter.extract = function () {\n  \tif (arguments.length === 2) {\n  \t\tvar geom = arguments[0],\n  \t\t    sortIndex = arguments[1];\n  \t\treturn GeometryExtracter.extract(geom, sortIndex, new ArrayList());\n  \t} else if (arguments.length === 3) {\n  \t\tvar geom = arguments[0],\n  \t\t    sortIndex = arguments[1],\n  \t\t    list = arguments[2];\n  \t\tif (geom.getSortIndex() === sortIndex) {\n  \t\t\tlist.add(geom);\n  \t\t} else if (geom instanceof GeometryCollection) {\n  \t\t\tgeom.apply(new GeometryExtracter(sortIndex, list));\n  \t\t}\n  \t\treturn list;\n  \t}\n  };\n\n  function UnaryUnionOp() {\n  \tthis._polygons = new ArrayList();\n  \tthis._lines = new ArrayList();\n  \tthis._points = new ArrayList();\n  \tthis._geomFact = null;\n  \tif (arguments.length === 1) {\n  \t\tif (hasInterface(arguments[0], Collection)) {\n  \t\t\tvar geoms = arguments[0];\n  \t\t\tthis.extract(geoms);\n  \t\t} else if (arguments[0] instanceof Geometry) {\n  \t\t\tvar geom = arguments[0];\n  \t\t\tthis.extract(geom);\n  \t\t}\n  \t} else if (arguments.length === 2) {\n  \t\tvar geoms = arguments[0],\n  \t\t    geomFact = arguments[1];\n  \t\tthis._geomFact = geomFact;\n  \t\tthis.extract(geoms);\n  \t}\n  }\n  extend(UnaryUnionOp.prototype, {\n  \tunionNoOpt: function unionNoOpt(g0) {\n  \t\tvar empty = this._geomFact.createPoint();\n  \t\treturn SnapIfNeededOverlayOp.overlayOp(g0, empty, OverlayOp.UNION);\n  \t},\n  \tunionWithNull: function unionWithNull(g0, g1) {\n  \t\tif (g0 === null && g1 === null) return null;\n  \t\tif (g1 === null) return g0;\n  \t\tif (g0 === null) return g1;\n  \t\treturn g0.union(g1);\n  \t},\n  \textract: function extract() {\n  \t\tif (hasInterface(arguments[0], Collection)) {\n  \t\t\tvar geoms = arguments[0];\n  \t\t\tfor (var i = geoms.iterator(); i.hasNext();) {\n  \t\t\t\tvar geom = i.next();\n  \t\t\t\tthis.extract(geom);\n  \t\t\t}\n  \t\t} else if (arguments[0] instanceof Geometry) {\n  \t\t\tvar geom = arguments[0];\n  \t\t\tif (this._geomFact === null) this._geomFact = geom.getFactory();\n  \t\t\tGeometryExtracter.extract(geom, Geometry.SORTINDEX_POLYGON, this._polygons);\n  \t\t\tGeometryExtracter.extract(geom, Geometry.SORTINDEX_LINESTRING, this._lines);\n  \t\t\tGeometryExtracter.extract(geom, Geometry.SORTINDEX_POINT, this._points);\n  \t\t}\n  \t},\n  \tunion: function union() {\n  \t\tif (this._geomFact === null) {\n  \t\t\treturn null;\n  \t\t}\n  \t\tvar unionPoints = null;\n  \t\tif (this._points.size() > 0) {\n  \t\t\tvar ptGeom = this._geomFact.buildGeometry(this._points);\n  \t\t\tunionPoints = this.unionNoOpt(ptGeom);\n  \t\t}\n  \t\tvar unionLines = null;\n  \t\tif (this._lines.size() > 0) {\n  \t\t\tvar lineGeom = this._geomFact.buildGeometry(this._lines);\n  \t\t\tunionLines = this.unionNoOpt(lineGeom);\n  \t\t}\n  \t\tvar unionPolygons = null;\n  \t\tif (this._polygons.size() > 0) {\n  \t\t\tunionPolygons = CascadedPolygonUnion.union(this._polygons);\n  \t\t}\n  \t\tvar unionLA = this.unionWithNull(unionLines, unionPolygons);\n  \t\tvar union = null;\n  \t\tif (unionPoints === null) union = unionLA;else if (unionLA === null) union = unionPoints;else union = PointGeometryUnion.union(unionPoints, unionLA);\n  \t\tif (union === null) return this._geomFact.createGeometryCollection();\n  \t\treturn union;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn UnaryUnionOp;\n  \t}\n  });\n  UnaryUnionOp.union = function () {\n  \tif (arguments.length === 1) {\n  \t\tif (hasInterface(arguments[0], Collection)) {\n  \t\t\tvar geoms = arguments[0];\n  \t\t\tvar op = new UnaryUnionOp(geoms);\n  \t\t\treturn op.union();\n  \t\t} else if (arguments[0] instanceof Geometry) {\n  \t\t\tvar geom = arguments[0];\n  \t\t\tvar op = new UnaryUnionOp(geom);\n  \t\t\treturn op.union();\n  \t\t}\n  \t} else if (arguments.length === 2) {\n  \t\tvar geoms = arguments[0],\n  \t\t    geomFact = arguments[1];\n  \t\tvar op = new UnaryUnionOp(geoms, geomFact);\n  \t\treturn op.union();\n  \t}\n  };\n\n  function UnionInteracting() {\n  \tthis._geomFactory = null;\n  \tthis._g0 = null;\n  \tthis._g1 = null;\n  \tthis._interacts0 = null;\n  \tthis._interacts1 = null;\n  \tvar g0 = arguments[0],\n  \t    g1 = arguments[1];\n  \tthis._g0 = g0;\n  \tthis._g1 = g1;\n  \tthis._geomFactory = g0.getFactory();\n  \tthis._interacts0 = new Array(g0.getNumGeometries()).fill(null);\n  \tthis._interacts1 = new Array(g1.getNumGeometries()).fill(null);\n  }\n  extend(UnionInteracting.prototype, {\n  \textractElements: function extractElements(geom, interacts, isInteracting) {\n  \t\tvar extractedGeoms = new ArrayList();\n  \t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n  \t\t\tvar elem = geom.getGeometryN(i);\n  \t\t\tif (interacts[i] === isInteracting) extractedGeoms.add(elem);\n  \t\t}\n  \t\treturn this._geomFactory.buildGeometry(extractedGeoms);\n  \t},\n  \tcomputeInteracting: function computeInteracting() {\n  \t\tif (arguments.length === 0) {\n  \t\t\tfor (var i = 0; i < this._g0.getNumGeometries(); i++) {\n  \t\t\t\tvar elem = this._g0.getGeometryN(i);\n  \t\t\t\tthis._interacts0[i] = this.computeInteracting(elem);\n  \t\t\t}\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tvar elem0 = arguments[0];\n  \t\t\tvar interactsWithAny = false;\n  \t\t\tfor (var i = 0; i < this._g1.getNumGeometries(); i++) {\n  \t\t\t\tvar elem1 = this._g1.getGeometryN(i);\n  \t\t\t\tvar interacts = elem1.getEnvelopeInternal().intersects(elem0.getEnvelopeInternal());\n  \t\t\t\tif (interacts) this._interacts1[i] = true;\n  \t\t\t\tif (interacts) interactsWithAny = true;\n  \t\t\t}\n  \t\t\treturn interactsWithAny;\n  \t\t}\n  \t},\n  \tunion: function union() {\n  \t\tthis.computeInteracting();\n  \t\tvar int0 = this.extractElements(this._g0, this._interacts0, true);\n  \t\tvar int1 = this.extractElements(this._g1, this._interacts1, true);\n  \t\tif (int0.isEmpty() || int1.isEmpty()) {\n  \t\t\tSystem.out.println(\"found empty!\");\n  \t\t}\n  \t\tvar union = int0.union(int1);\n  \t\tvar disjoint0 = this.extractElements(this._g0, this._interacts0, false);\n  \t\tvar disjoint1 = this.extractElements(this._g1, this._interacts1, false);\n  \t\tvar overallUnion = GeometryCombiner.combine(union, disjoint0, disjoint1);\n  \t\treturn overallUnion;\n  \t},\n  \tbufferUnion: function bufferUnion(g0, g1) {\n  \t\tvar factory = g0.getFactory();\n  \t\tvar gColl = factory.createGeometryCollection([g0, g1]);\n  \t\tvar unionAll = gColl.buffer(0.0);\n  \t\treturn unionAll;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn UnionInteracting;\n  \t}\n  });\n  UnionInteracting.union = function (g0, g1) {\n  \tvar uue = new UnionInteracting(g0, g1);\n  \treturn uue.union();\n  };\n\n  function UnionOp() {}\n  extend(UnionOp.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn UnionOp;\n  \t}\n  });\n  UnionOp.union = function (g, other) {\n  \tif (g.isEmpty() || other.isEmpty()) {\n  \t\tif (g.isEmpty() && other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.UNION, g, other, g.getFactory());\n  \t\tif (g.isEmpty()) return other.copy();\n  \t\tif (other.isEmpty()) return g.copy();\n  \t}\n  \tg.checkNotGeometryCollection(g);\n  \tg.checkNotGeometryCollection(other);\n  \treturn SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.UNION);\n  };\n\n  function PrecisionReducerCoordinateOperation() {\n  \tGeometryEditor.CoordinateOperation.apply(this);\n  \tthis._targetPM = null;\n  \tthis._removeCollapsed = true;\n  \tvar targetPM = arguments[0],\n  \t    removeCollapsed = arguments[1];\n  \tthis._targetPM = targetPM;\n  \tthis._removeCollapsed = removeCollapsed;\n  }\n  inherits$1(PrecisionReducerCoordinateOperation, GeometryEditor.CoordinateOperation);\n  extend(PrecisionReducerCoordinateOperation.prototype, {\n  \teditCoordinates: function editCoordinates(coordinates, geom) {\n  \t\tif (coordinates.length === 0) return null;\n  \t\tvar reducedCoords = new Array(coordinates.length).fill(null);\n  \t\tfor (var i = 0; i < coordinates.length; i++) {\n  \t\t\tvar coord = new Coordinate(coordinates[i]);\n  \t\t\tthis._targetPM.makePrecise(coord);\n  \t\t\treducedCoords[i] = coord;\n  \t\t}\n  \t\tvar noRepeatedCoordList = new CoordinateList(reducedCoords, false);\n  \t\tvar noRepeatedCoords = noRepeatedCoordList.toCoordinateArray();\n  \t\tvar minLength = 0;\n  \t\tif (geom instanceof LineString) minLength = 2;\n  \t\tif (geom instanceof LinearRing) minLength = 4;\n  \t\tvar collapsedCoords = reducedCoords;\n  \t\tif (this._removeCollapsed) collapsedCoords = null;\n  \t\tif (noRepeatedCoords.length < minLength) {\n  \t\t\treturn collapsedCoords;\n  \t\t}\n  \t\treturn noRepeatedCoords;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn PrecisionReducerCoordinateOperation;\n  \t}\n  });\n\n  function GeometryPrecisionReducer() {\n  \tthis._targetPM = null;\n  \tthis._removeCollapsed = true;\n  \tthis._changePrecisionModel = false;\n  \tthis._isPointwise = false;\n  \tvar pm = arguments[0];\n  \tthis._targetPM = pm;\n  }\n  extend(GeometryPrecisionReducer.prototype, {\n  \tfixPolygonalTopology: function fixPolygonalTopology(geom) {\n  \t\tvar geomToBuffer = geom;\n  \t\tif (!this._changePrecisionModel) {\n  \t\t\tgeomToBuffer = this.changePM(geom, this._targetPM);\n  \t\t}\n  \t\tvar bufGeom = geomToBuffer.buffer(0);\n  \t\tvar finalGeom = bufGeom;\n  \t\tif (!this._changePrecisionModel) {\n  \t\t\tfinalGeom = this.changePM(bufGeom, geom.getPrecisionModel());\n  \t\t}\n  \t\treturn finalGeom;\n  \t},\n  \treducePointwise: function reducePointwise(geom) {\n  \t\tvar geomEdit = null;\n  \t\tif (this._changePrecisionModel) {\n  \t\t\tvar newFactory = this.createFactory(geom.getFactory(), this._targetPM);\n  \t\t\tgeomEdit = new GeometryEditor(newFactory);\n  \t\t} else geomEdit = new GeometryEditor();\n  \t\tvar finalRemoveCollapsed = this._removeCollapsed;\n  \t\tif (geom.getDimension() >= 2) finalRemoveCollapsed = true;\n  \t\tvar reduceGeom = geomEdit.edit(geom, new PrecisionReducerCoordinateOperation(this._targetPM, finalRemoveCollapsed));\n  \t\treturn reduceGeom;\n  \t},\n  \tchangePM: function changePM(geom, newPM) {\n  \t\tvar geomEditor = this.createEditor(geom.getFactory(), newPM);\n  \t\treturn geomEditor.edit(geom, new GeometryEditor.NoOpGeometryOperation());\n  \t},\n  \tsetRemoveCollapsedComponents: function setRemoveCollapsedComponents(removeCollapsed) {\n  \t\tthis._removeCollapsed = removeCollapsed;\n  \t},\n  \tcreateFactory: function createFactory(inputFactory, pm) {\n  \t\tvar newFactory = new GeometryFactory(pm, inputFactory.getSRID(), inputFactory.getCoordinateSequenceFactory());\n  \t\treturn newFactory;\n  \t},\n  \tsetChangePrecisionModel: function setChangePrecisionModel(changePrecisionModel) {\n  \t\tthis._changePrecisionModel = changePrecisionModel;\n  \t},\n  \treduce: function reduce(geom) {\n  \t\tvar reducePW = this.reducePointwise(geom);\n  \t\tif (this._isPointwise) return reducePW;\n  \t\tif (!hasInterface(reducePW, Polygonal)) return reducePW;\n  \t\tif (reducePW.isValid()) return reducePW;\n  \t\treturn this.fixPolygonalTopology(reducePW);\n  \t},\n  \tsetPointwise: function setPointwise(isPointwise) {\n  \t\tthis._isPointwise = isPointwise;\n  \t},\n  \tcreateEditor: function createEditor(geomFactory, newPM) {\n  \t\tif (geomFactory.getPrecisionModel() === newPM) return new GeometryEditor();\n  \t\tvar newFactory = this.createFactory(geomFactory, newPM);\n  \t\tvar geomEdit = new GeometryEditor(newFactory);\n  \t\treturn geomEdit;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn GeometryPrecisionReducer;\n  \t}\n  });\n  GeometryPrecisionReducer.reduce = function (g, precModel) {\n  \tvar reducer = new GeometryPrecisionReducer(precModel);\n  \treturn reducer.reduce(g);\n  };\n  GeometryPrecisionReducer.reducePointwise = function (g, precModel) {\n  \tvar reducer = new GeometryPrecisionReducer(precModel);\n  \treducer.setPointwise(true);\n  \treturn reducer.reduce(g);\n  };\n\n  function DouglasPeuckerLineSimplifier() {\n  \tthis._pts = null;\n  \tthis._usePt = null;\n  \tthis._distanceTolerance = null;\n  \tthis._seg = new LineSegment();\n  \tvar pts = arguments[0];\n  \tthis._pts = pts;\n  }\n  extend(DouglasPeuckerLineSimplifier.prototype, {\n  \tsimplifySection: function simplifySection(i, j) {\n  \t\tif (i + 1 === j) {\n  \t\t\treturn null;\n  \t\t}\n  \t\tthis._seg.p0 = this._pts[i];\n  \t\tthis._seg.p1 = this._pts[j];\n  \t\tvar maxDistance = -1.0;\n  \t\tvar maxIndex = i;\n  \t\tfor (var k = i + 1; k < j; k++) {\n  \t\t\tvar distance = this._seg.distance(this._pts[k]);\n  \t\t\tif (distance > maxDistance) {\n  \t\t\t\tmaxDistance = distance;\n  \t\t\t\tmaxIndex = k;\n  \t\t\t}\n  \t\t}\n  \t\tif (maxDistance <= this._distanceTolerance) {\n  \t\t\tfor (var k = i + 1; k < j; k++) {\n  \t\t\t\tthis._usePt[k] = false;\n  \t\t\t}\n  \t\t} else {\n  \t\t\tthis.simplifySection(i, maxIndex);\n  \t\t\tthis.simplifySection(maxIndex, j);\n  \t\t}\n  \t},\n  \tsetDistanceTolerance: function setDistanceTolerance(distanceTolerance) {\n  \t\tthis._distanceTolerance = distanceTolerance;\n  \t},\n  \tsimplify: function simplify() {\n  \t\tthis._usePt = new Array(this._pts.length).fill(null);\n  \t\tfor (var i = 0; i < this._pts.length; i++) {\n  \t\t\tthis._usePt[i] = true;\n  \t\t}\n  \t\tthis.simplifySection(0, this._pts.length - 1);\n  \t\tvar coordList = new CoordinateList();\n  \t\tfor (var i = 0; i < this._pts.length; i++) {\n  \t\t\tif (this._usePt[i]) coordList.add(new Coordinate(this._pts[i]));\n  \t\t}\n  \t\treturn coordList.toCoordinateArray();\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn DouglasPeuckerLineSimplifier;\n  \t}\n  });\n  DouglasPeuckerLineSimplifier.simplify = function (pts, distanceTolerance) {\n  \tvar simp = new DouglasPeuckerLineSimplifier(pts);\n  \tsimp.setDistanceTolerance(distanceTolerance);\n  \treturn simp.simplify();\n  };\n\n  function DouglasPeuckerSimplifier() {\n  \tthis._inputGeom = null;\n  \tthis._distanceTolerance = null;\n  \tthis._isEnsureValidTopology = true;\n  \tvar inputGeom = arguments[0];\n  \tthis._inputGeom = inputGeom;\n  }\n  extend(DouglasPeuckerSimplifier.prototype, {\n  \tsetEnsureValid: function setEnsureValid(isEnsureValidTopology) {\n  \t\tthis._isEnsureValidTopology = isEnsureValidTopology;\n  \t},\n  \tgetResultGeometry: function getResultGeometry() {\n  \t\tif (this._inputGeom.isEmpty()) return this._inputGeom.copy();\n  \t\treturn new DPTransformer(this._isEnsureValidTopology, this._distanceTolerance).transform(this._inputGeom);\n  \t},\n  \tsetDistanceTolerance: function setDistanceTolerance(distanceTolerance) {\n  \t\tif (distanceTolerance < 0.0) throw new IllegalArgumentException(\"Tolerance must be non-negative\");\n  \t\tthis._distanceTolerance = distanceTolerance;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn DouglasPeuckerSimplifier;\n  \t}\n  });\n  DouglasPeuckerSimplifier.simplify = function (geom, distanceTolerance) {\n  \tvar tss = new DouglasPeuckerSimplifier(geom);\n  \ttss.setDistanceTolerance(distanceTolerance);\n  \treturn tss.getResultGeometry();\n  };\n  function DPTransformer() {\n  \tGeometryTransformer.apply(this);\n  \tthis._isEnsureValidTopology = true;\n  \tthis._distanceTolerance = null;\n  \tvar isEnsureValidTopology = arguments[0],\n  \t    distanceTolerance = arguments[1];\n  \tthis._isEnsureValidTopology = isEnsureValidTopology;\n  \tthis._distanceTolerance = distanceTolerance;\n  }\n  inherits$1(DPTransformer, GeometryTransformer);\n  extend(DPTransformer.prototype, {\n  \ttransformPolygon: function transformPolygon(geom, parent) {\n  \t\tif (geom.isEmpty()) return null;\n  \t\tvar rawGeom = GeometryTransformer.prototype.transformPolygon.call(this, geom, parent);\n  \t\tif (parent instanceof MultiPolygon) {\n  \t\t\treturn rawGeom;\n  \t\t}\n  \t\treturn this.createValidArea(rawGeom);\n  \t},\n  \tcreateValidArea: function createValidArea(rawAreaGeom) {\n  \t\tif (this._isEnsureValidTopology) return rawAreaGeom.buffer(0.0);\n  \t\treturn rawAreaGeom;\n  \t},\n  \ttransformCoordinates: function transformCoordinates(coords, parent) {\n  \t\tvar inputPts = coords.toCoordinateArray();\n  \t\tvar newPts = null;\n  \t\tif (inputPts.length === 0) {\n  \t\t\tnewPts = new Array(0).fill(null);\n  \t\t} else {\n  \t\t\tnewPts = DouglasPeuckerLineSimplifier.simplify(inputPts, this._distanceTolerance);\n  \t\t}\n  \t\treturn this._factory.getCoordinateSequenceFactory().create(newPts);\n  \t},\n  \ttransformMultiPolygon: function transformMultiPolygon(geom, parent) {\n  \t\tvar rawGeom = GeometryTransformer.prototype.transformMultiPolygon.call(this, geom, parent);\n  \t\treturn this.createValidArea(rawGeom);\n  \t},\n  \ttransformLinearRing: function transformLinearRing(geom, parent) {\n  \t\tvar removeDegenerateRings = parent instanceof Polygon;\n  \t\tvar simpResult = GeometryTransformer.prototype.transformLinearRing.call(this, geom, parent);\n  \t\tif (removeDegenerateRings && !(simpResult instanceof LinearRing)) return null;\n  \t\treturn simpResult;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn DPTransformer;\n  \t}\n  });\n  DouglasPeuckerSimplifier.DPTransformer = DPTransformer;\n\n  function TaggedLineSegment() {\n  \tthis._parent = null;\n  \tthis._index = null;\n  \tif (arguments.length === 2) {\n  \t\tvar p0 = arguments[0],\n  \t\t    p1 = arguments[1];\n  \t\tTaggedLineSegment.call(this, p0, p1, null, -1);\n  \t} else if (arguments.length === 4) {\n  \t\tvar p0 = arguments[0],\n  \t\t    p1 = arguments[1],\n  \t\t    parent = arguments[2],\n  \t\t    index = arguments[3];\n  \t\tLineSegment.call(this, p0, p1);\n  \t\tthis._parent = parent;\n  \t\tthis._index = index;\n  \t}\n  }\n  inherits$1(TaggedLineSegment, LineSegment);\n  extend(TaggedLineSegment.prototype, {\n  \tgetIndex: function getIndex() {\n  \t\treturn this._index;\n  \t},\n  \tgetParent: function getParent() {\n  \t\treturn this._parent;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn TaggedLineSegment;\n  \t}\n  });\n\n  function TaggedLineString() {\n  \tthis._parentLine = null;\n  \tthis._segs = null;\n  \tthis._resultSegs = new ArrayList();\n  \tthis._minimumSize = null;\n  \tif (arguments.length === 1) {\n  \t\tvar parentLine = arguments[0];\n  \t\tTaggedLineString.call(this, parentLine, 2);\n  \t} else if (arguments.length === 2) {\n  \t\tvar parentLine = arguments[0],\n  \t\t    minimumSize = arguments[1];\n  \t\tthis._parentLine = parentLine;\n  \t\tthis._minimumSize = minimumSize;\n  \t\tthis.init();\n  \t}\n  }\n  extend(TaggedLineString.prototype, {\n  \taddToResult: function addToResult(seg) {\n  \t\tthis._resultSegs.add(seg);\n  \t},\n  \tasLineString: function asLineString() {\n  \t\treturn this._parentLine.getFactory().createLineString(TaggedLineString.extractCoordinates(this._resultSegs));\n  \t},\n  \tgetResultSize: function getResultSize() {\n  \t\tvar resultSegsSize = this._resultSegs.size();\n  \t\treturn resultSegsSize === 0 ? 0 : resultSegsSize + 1;\n  \t},\n  \tgetParent: function getParent() {\n  \t\treturn this._parentLine;\n  \t},\n  \tgetSegment: function getSegment(i) {\n  \t\treturn this._segs[i];\n  \t},\n  \tgetParentCoordinates: function getParentCoordinates() {\n  \t\treturn this._parentLine.getCoordinates();\n  \t},\n  \tgetMinimumSize: function getMinimumSize() {\n  \t\treturn this._minimumSize;\n  \t},\n  \tasLinearRing: function asLinearRing() {\n  \t\treturn this._parentLine.getFactory().createLinearRing(TaggedLineString.extractCoordinates(this._resultSegs));\n  \t},\n  \tgetSegments: function getSegments() {\n  \t\treturn this._segs;\n  \t},\n  \tinit: function init() {\n  \t\tvar pts = this._parentLine.getCoordinates();\n  \t\tthis._segs = new Array(pts.length - 1).fill(null);\n  \t\tfor (var i = 0; i < pts.length - 1; i++) {\n  \t\t\tvar seg = new TaggedLineSegment(pts[i], pts[i + 1], this._parentLine, i);\n  \t\t\tthis._segs[i] = seg;\n  \t\t}\n  \t},\n  \tgetResultCoordinates: function getResultCoordinates() {\n  \t\treturn TaggedLineString.extractCoordinates(this._resultSegs);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn TaggedLineString;\n  \t}\n  });\n  TaggedLineString.extractCoordinates = function (segs) {\n  \tvar pts = new Array(segs.size() + 1).fill(null);\n  \tvar seg = null;\n  \tfor (var i = 0; i < segs.size(); i++) {\n  \t\tseg = segs.get(i);\n  \t\tpts[i] = seg.p0;\n  \t}\n  \tpts[pts.length - 1] = seg.p1;\n  \treturn pts;\n  };\n\n  function LineSegmentIndex() {\n  \tthis._index = new Quadtree();\n  }\n  extend(LineSegmentIndex.prototype, {\n  \tremove: function remove(seg) {\n  \t\tthis._index.remove(new Envelope(seg.p0, seg.p1), seg);\n  \t},\n  \tadd: function add() {\n  \t\tif (arguments[0] instanceof TaggedLineString) {\n  \t\t\tvar line = arguments[0];\n  \t\t\tvar segs = line.getSegments();\n  \t\t\tfor (var i = 0; i < segs.length; i++) {\n  \t\t\t\tvar seg = segs[i];\n  \t\t\t\tthis.add(seg);\n  \t\t\t}\n  \t\t} else if (arguments[0] instanceof LineSegment) {\n  \t\t\tvar seg = arguments[0];\n  \t\t\tthis._index.insert(new Envelope(seg.p0, seg.p1), seg);\n  \t\t}\n  \t},\n  \tquery: function query(querySeg) {\n  \t\tvar env = new Envelope(querySeg.p0, querySeg.p1);\n  \t\tvar visitor = new LineSegmentVisitor(querySeg);\n  \t\tthis._index.query(env, visitor);\n  \t\tvar itemsFound = visitor.getItems();\n  \t\treturn itemsFound;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LineSegmentIndex;\n  \t}\n  });\n  function LineSegmentVisitor() {\n  \tthis._querySeg = null;\n  \tthis._items = new ArrayList();\n  \tvar querySeg = arguments[0];\n  \tthis._querySeg = querySeg;\n  }\n  extend(LineSegmentVisitor.prototype, {\n  \tvisitItem: function visitItem(item) {\n  \t\tvar seg = item;\n  \t\tif (Envelope.intersects(seg.p0, seg.p1, this._querySeg.p0, this._querySeg.p1)) this._items.add(item);\n  \t},\n  \tgetItems: function getItems() {\n  \t\treturn this._items;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [ItemVisitor];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LineSegmentVisitor;\n  \t}\n  });\n\n  function TaggedLineStringSimplifier() {\n  \tthis._li = new RobustLineIntersector();\n  \tthis._inputIndex = new LineSegmentIndex();\n  \tthis._outputIndex = new LineSegmentIndex();\n  \tthis._line = null;\n  \tthis._linePts = null;\n  \tthis._distanceTolerance = 0.0;\n  \tvar inputIndex = arguments[0],\n  \t    outputIndex = arguments[1];\n  \tthis._inputIndex = inputIndex;\n  \tthis._outputIndex = outputIndex;\n  }\n  extend(TaggedLineStringSimplifier.prototype, {\n  \tflatten: function flatten(start, end) {\n  \t\tvar p0 = this._linePts[start];\n  \t\tvar p1 = this._linePts[end];\n  \t\tvar newSeg = new LineSegment(p0, p1);\n  \t\tthis.remove(this._line, start, end);\n  \t\tthis._outputIndex.add(newSeg);\n  \t\treturn newSeg;\n  \t},\n  \thasBadIntersection: function hasBadIntersection(parentLine, sectionIndex, candidateSeg) {\n  \t\tif (this.hasBadOutputIntersection(candidateSeg)) return true;\n  \t\tif (this.hasBadInputIntersection(parentLine, sectionIndex, candidateSeg)) return true;\n  \t\treturn false;\n  \t},\n  \tsetDistanceTolerance: function setDistanceTolerance(distanceTolerance) {\n  \t\tthis._distanceTolerance = distanceTolerance;\n  \t},\n  \tsimplifySection: function simplifySection(i, j, depth) {\n  \t\tdepth += 1;\n  \t\tvar sectionIndex = new Array(2).fill(null);\n  \t\tif (i + 1 === j) {\n  \t\t\tvar newSeg = this._line.getSegment(i);\n  \t\t\tthis._line.addToResult(newSeg);\n  \t\t\treturn null;\n  \t\t}\n  \t\tvar isValidToSimplify = true;\n  \t\tif (this._line.getResultSize() < this._line.getMinimumSize()) {\n  \t\t\tvar worstCaseSize = depth + 1;\n  \t\t\tif (worstCaseSize < this._line.getMinimumSize()) isValidToSimplify = false;\n  \t\t}\n  \t\tvar distance = new Array(1).fill(null);\n  \t\tvar furthestPtIndex = this.findFurthestPoint(this._linePts, i, j, distance);\n  \t\tif (distance[0] > this._distanceTolerance) isValidToSimplify = false;\n  \t\tvar candidateSeg = new LineSegment();\n  \t\tcandidateSeg.p0 = this._linePts[i];\n  \t\tcandidateSeg.p1 = this._linePts[j];\n  \t\tsectionIndex[0] = i;\n  \t\tsectionIndex[1] = j;\n  \t\tif (this.hasBadIntersection(this._line, sectionIndex, candidateSeg)) isValidToSimplify = false;\n  \t\tif (isValidToSimplify) {\n  \t\t\tvar newSeg = this.flatten(i, j);\n  \t\t\tthis._line.addToResult(newSeg);\n  \t\t\treturn null;\n  \t\t}\n  \t\tthis.simplifySection(i, furthestPtIndex, depth);\n  \t\tthis.simplifySection(furthestPtIndex, j, depth);\n  \t},\n  \thasBadOutputIntersection: function hasBadOutputIntersection(candidateSeg) {\n  \t\tvar querySegs = this._outputIndex.query(candidateSeg);\n  \t\tfor (var i = querySegs.iterator(); i.hasNext();) {\n  \t\t\tvar querySeg = i.next();\n  \t\t\tif (this.hasInteriorIntersection(querySeg, candidateSeg)) {\n  \t\t\t\treturn true;\n  \t\t\t}\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tfindFurthestPoint: function findFurthestPoint(pts, i, j, maxDistance) {\n  \t\tvar seg = new LineSegment();\n  \t\tseg.p0 = pts[i];\n  \t\tseg.p1 = pts[j];\n  \t\tvar maxDist = -1.0;\n  \t\tvar maxIndex = i;\n  \t\tfor (var k = i + 1; k < j; k++) {\n  \t\t\tvar midPt = pts[k];\n  \t\t\tvar distance = seg.distance(midPt);\n  \t\t\tif (distance > maxDist) {\n  \t\t\t\tmaxDist = distance;\n  \t\t\t\tmaxIndex = k;\n  \t\t\t}\n  \t\t}\n  \t\tmaxDistance[0] = maxDist;\n  \t\treturn maxIndex;\n  \t},\n  \tsimplify: function simplify(line) {\n  \t\tthis._line = line;\n  \t\tthis._linePts = line.getParentCoordinates();\n  \t\tthis.simplifySection(0, this._linePts.length - 1, 0);\n  \t},\n  \tremove: function remove(line, start, end) {\n  \t\tfor (var i = start; i < end; i++) {\n  \t\t\tvar seg = line.getSegment(i);\n  \t\t\tthis._inputIndex.remove(seg);\n  \t\t}\n  \t},\n  \thasInteriorIntersection: function hasInteriorIntersection(seg0, seg1) {\n  \t\tthis._li.computeIntersection(seg0.p0, seg0.p1, seg1.p0, seg1.p1);\n  \t\treturn this._li.isInteriorIntersection();\n  \t},\n  \thasBadInputIntersection: function hasBadInputIntersection(parentLine, sectionIndex, candidateSeg) {\n  \t\tvar querySegs = this._inputIndex.query(candidateSeg);\n  \t\tfor (var i = querySegs.iterator(); i.hasNext();) {\n  \t\t\tvar querySeg = i.next();\n  \t\t\tif (this.hasInteriorIntersection(querySeg, candidateSeg)) {\n  \t\t\t\tif (TaggedLineStringSimplifier.isInLineSection(parentLine, sectionIndex, querySeg)) continue;\n  \t\t\t\treturn true;\n  \t\t\t}\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn TaggedLineStringSimplifier;\n  \t}\n  });\n  TaggedLineStringSimplifier.isInLineSection = function (line, sectionIndex, seg) {\n  \tif (seg.getParent() !== line.getParent()) return false;\n  \tvar segIndex = seg.getIndex();\n  \tif (segIndex >= sectionIndex[0] && segIndex < sectionIndex[1]) return true;\n  \treturn false;\n  };\n\n  function TaggedLinesSimplifier() {\n  \tthis._inputIndex = new LineSegmentIndex();\n  \tthis._outputIndex = new LineSegmentIndex();\n  \tthis._distanceTolerance = 0.0;\n  }\n  extend(TaggedLinesSimplifier.prototype, {\n  \tsetDistanceTolerance: function setDistanceTolerance(distanceTolerance) {\n  \t\tthis._distanceTolerance = distanceTolerance;\n  \t},\n  \tsimplify: function simplify(taggedLines) {\n  \t\tfor (var i = taggedLines.iterator(); i.hasNext();) {\n  \t\t\tthis._inputIndex.add(i.next());\n  \t\t}\n  \t\tfor (var i = taggedLines.iterator(); i.hasNext();) {\n  \t\t\tvar tlss = new TaggedLineStringSimplifier(this._inputIndex, this._outputIndex);\n  \t\t\ttlss.setDistanceTolerance(this._distanceTolerance);\n  \t\t\ttlss.simplify(i.next());\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn TaggedLinesSimplifier;\n  \t}\n  });\n\n  function TopologyPreservingSimplifier() {\n  \tthis._inputGeom = null;\n  \tthis._lineSimplifier = new TaggedLinesSimplifier();\n  \tthis._linestringMap = null;\n  \tvar inputGeom = arguments[0];\n  \tthis._inputGeom = inputGeom;\n  }\n  extend(TopologyPreservingSimplifier.prototype, {\n  \tgetResultGeometry: function getResultGeometry() {\n  \t\tif (this._inputGeom.isEmpty()) return this._inputGeom.copy();\n  \t\tthis._linestringMap = new HashMap();\n  \t\tthis._inputGeom.apply(new LineStringMapBuilderFilter(this));\n  \t\tthis._lineSimplifier.simplify(this._linestringMap.values());\n  \t\tvar result = new LineStringTransformer(this._linestringMap).transform(this._inputGeom);\n  \t\treturn result;\n  \t},\n  \tsetDistanceTolerance: function setDistanceTolerance(distanceTolerance) {\n  \t\tif (distanceTolerance < 0.0) throw new IllegalArgumentException(\"Tolerance must be non-negative\");\n  \t\tthis._lineSimplifier.setDistanceTolerance(distanceTolerance);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn TopologyPreservingSimplifier;\n  \t}\n  });\n  TopologyPreservingSimplifier.simplify = function (geom, distanceTolerance) {\n  \tvar tss = new TopologyPreservingSimplifier(geom);\n  \ttss.setDistanceTolerance(distanceTolerance);\n  \treturn tss.getResultGeometry();\n  };\n  function LineStringTransformer() {\n  \tGeometryTransformer.apply(this);\n  \tthis._linestringMap = null;\n  \tvar linestringMap = arguments[0];\n  \tthis._linestringMap = linestringMap;\n  }\n  inherits$1(LineStringTransformer, GeometryTransformer);\n  extend(LineStringTransformer.prototype, {\n  \ttransformCoordinates: function transformCoordinates(coords, parent) {\n  \t\tif (coords.size() === 0) return null;\n  \t\tif (parent instanceof LineString) {\n  \t\t\tvar taggedLine = this._linestringMap.get(parent);\n  \t\t\treturn this.createCoordinateSequence(taggedLine.getResultCoordinates());\n  \t\t}\n  \t\treturn GeometryTransformer.prototype.transformCoordinates.call(this, coords, parent);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LineStringTransformer;\n  \t}\n  });\n  function LineStringMapBuilderFilter() {\n  \tthis.tps = null;\n  \tvar tps = arguments[0];\n  \tthis.tps = tps;\n  }\n  extend(LineStringMapBuilderFilter.prototype, {\n  \tfilter: function filter(geom) {\n  \t\tif (geom instanceof LineString) {\n  \t\t\tvar line = geom;\n  \t\t\tif (line.isEmpty()) return null;\n  \t\t\tvar minSize = line.isClosed() ? 4 : 2;\n  \t\t\tvar taggedLine = new TaggedLineString(line, minSize);\n  \t\t\tthis.tps._linestringMap.put(line, taggedLine);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [GeometryComponentFilter];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LineStringMapBuilderFilter;\n  \t}\n  });\n  TopologyPreservingSimplifier.LineStringTransformer = LineStringTransformer;\n  TopologyPreservingSimplifier.LineStringMapBuilderFilter = LineStringMapBuilderFilter;\n\n  function SplitSegment() {\n  \tthis._seg = null;\n  \tthis._segLen = null;\n  \tthis._splitPt = null;\n  \tthis._minimumLen = 0.0;\n  \tvar seg = arguments[0];\n  \tthis._seg = seg;\n  \tthis._segLen = seg.getLength();\n  }\n  extend(SplitSegment.prototype, {\n  \tsplitAt: function splitAt() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar pt = arguments[0];\n  \t\t\tvar minFrac = this._minimumLen / this._segLen;\n  \t\t\tif (pt.distance(this._seg.p0) < this._minimumLen) {\n  \t\t\t\tthis._splitPt = this._seg.pointAlong(minFrac);\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t\tif (pt.distance(this._seg.p1) < this._minimumLen) {\n  \t\t\t\tthis._splitPt = SplitSegment.pointAlongReverse(this._seg, minFrac);\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t\tthis._splitPt = pt;\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar length = arguments[0],\n  \t\t\t    endPt = arguments[1];\n  \t\t\tvar actualLen = this.getConstrainedLength(length);\n  \t\t\tvar frac = actualLen / this._segLen;\n  \t\t\tif (endPt.equals2D(this._seg.p0)) this._splitPt = this._seg.pointAlong(frac);else this._splitPt = SplitSegment.pointAlongReverse(this._seg, frac);\n  \t\t}\n  \t},\n  \tsetMinimumLength: function setMinimumLength(minLen) {\n  \t\tthis._minimumLen = minLen;\n  \t},\n  \tgetConstrainedLength: function getConstrainedLength(len) {\n  \t\tif (len < this._minimumLen) return this._minimumLen;\n  \t\treturn len;\n  \t},\n  \tgetSplitPoint: function getSplitPoint() {\n  \t\treturn this._splitPt;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SplitSegment;\n  \t}\n  });\n  SplitSegment.pointAlongReverse = function (seg, segmentLengthFraction) {\n  \tvar coord = new Coordinate();\n  \tcoord.x = seg.p1.x - segmentLengthFraction * (seg.p1.x - seg.p0.x);\n  \tcoord.y = seg.p1.y - segmentLengthFraction * (seg.p1.y - seg.p0.y);\n  \treturn coord;\n  };\n\n  function ConstraintSplitPointFinder() {}\n  extend(ConstraintSplitPointFinder.prototype, {\n  \tfindSplitPoint: function findSplitPoint(seg, encroachPt) {},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn ConstraintSplitPointFinder;\n  \t}\n  });\n\n  function NonEncroachingSplitPointFinder() {}\n  extend(NonEncroachingSplitPointFinder.prototype, {\n  \tfindSplitPoint: function findSplitPoint(seg, encroachPt) {\n  \t\tvar lineSeg = seg.getLineSegment();\n  \t\tvar segLen = lineSeg.getLength();\n  \t\tvar midPtLen = segLen / 2;\n  \t\tvar splitSeg = new SplitSegment(lineSeg);\n  \t\tvar projPt = NonEncroachingSplitPointFinder.projectedSplitPoint(seg, encroachPt);\n  \t\tvar nonEncroachDiam = projPt.distance(encroachPt) * 2 * 0.8;\n  \t\tvar maxSplitLen = nonEncroachDiam;\n  \t\tif (maxSplitLen > midPtLen) {\n  \t\t\tmaxSplitLen = midPtLen;\n  \t\t}\n  \t\tsplitSeg.setMinimumLength(maxSplitLen);\n  \t\tsplitSeg.splitAt(projPt);\n  \t\treturn splitSeg.getSplitPoint();\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [ConstraintSplitPointFinder];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn NonEncroachingSplitPointFinder;\n  \t}\n  });\n  NonEncroachingSplitPointFinder.projectedSplitPoint = function (seg, encroachPt) {\n  \tvar lineSeg = seg.getLineSegment();\n  \tvar projPt = lineSeg.project(encroachPt);\n  \treturn projPt;\n  };\n\n  function TrianglePredicate() {}\n  extend(TrianglePredicate.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn TrianglePredicate;\n  \t}\n  });\n  TrianglePredicate.triArea = function (a, b, c) {\n  \treturn (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n  };\n  TrianglePredicate.isInCircleDDNormalized = function (a, b, c, p) {\n  \tvar adx = DD.valueOf(a.x).selfSubtract(p.x);\n  \tvar ady = DD.valueOf(a.y).selfSubtract(p.y);\n  \tvar bdx = DD.valueOf(b.x).selfSubtract(p.x);\n  \tvar bdy = DD.valueOf(b.y).selfSubtract(p.y);\n  \tvar cdx = DD.valueOf(c.x).selfSubtract(p.x);\n  \tvar cdy = DD.valueOf(c.y).selfSubtract(p.y);\n  \tvar abdet = adx.multiply(bdy).selfSubtract(bdx.multiply(ady));\n  \tvar bcdet = bdx.multiply(cdy).selfSubtract(cdx.multiply(bdy));\n  \tvar cadet = cdx.multiply(ady).selfSubtract(adx.multiply(cdy));\n  \tvar alift = adx.multiply(adx).selfAdd(ady.multiply(ady));\n  \tvar blift = bdx.multiply(bdx).selfAdd(bdy.multiply(bdy));\n  \tvar clift = cdx.multiply(cdx).selfAdd(cdy.multiply(cdy));\n  \tvar sum = alift.selfMultiply(bcdet).selfAdd(blift.selfMultiply(cadet)).selfAdd(clift.selfMultiply(abdet));\n  \tvar isInCircle = sum.doubleValue() > 0;\n  \treturn isInCircle;\n  };\n  TrianglePredicate.checkRobustInCircle = function (a, b, c, p) {\n  \tvar nonRobustInCircle = TrianglePredicate.isInCircleNonRobust(a, b, c, p);\n  \tvar isInCircleDD = TrianglePredicate.isInCircleDDSlow(a, b, c, p);\n  \tvar isInCircleCC = TrianglePredicate.isInCircleCC(a, b, c, p);\n  \tvar circumCentre = Triangle$1.circumcentre(a, b, c);\n  \tSystem.out.println(\"p radius diff a = \" + Math.abs(p.distance(circumCentre) - a.distance(circumCentre)) / a.distance(circumCentre));\n  \tif (nonRobustInCircle !== isInCircleDD || nonRobustInCircle !== isInCircleCC) {\n  \t\tSystem.out.println(\"inCircle robustness failure (double result = \" + nonRobustInCircle + \", DD result = \" + isInCircleDD + \", CC result = \" + isInCircleCC + \")\");\n  \t\tSystem.out.println(WKTWriter.toLineString(new CoordinateArraySequence([a, b, c, p])));\n  \t\tSystem.out.println(\"Circumcentre = \" + WKTWriter.toPoint(circumCentre) + \" radius = \" + a.distance(circumCentre));\n  \t\tSystem.out.println(\"p radius diff a = \" + Math.abs(p.distance(circumCentre) / a.distance(circumCentre) - 1));\n  \t\tSystem.out.println(\"p radius diff b = \" + Math.abs(p.distance(circumCentre) / b.distance(circumCentre) - 1));\n  \t\tSystem.out.println(\"p radius diff c = \" + Math.abs(p.distance(circumCentre) / c.distance(circumCentre) - 1));\n  \t\tSystem.out.println();\n  \t}\n  };\n  TrianglePredicate.isInCircleDDFast = function (a, b, c, p) {\n  \tvar aTerm = DD.sqr(a.x).selfAdd(DD.sqr(a.y)).selfMultiply(TrianglePredicate.triAreaDDFast(b, c, p));\n  \tvar bTerm = DD.sqr(b.x).selfAdd(DD.sqr(b.y)).selfMultiply(TrianglePredicate.triAreaDDFast(a, c, p));\n  \tvar cTerm = DD.sqr(c.x).selfAdd(DD.sqr(c.y)).selfMultiply(TrianglePredicate.triAreaDDFast(a, b, p));\n  \tvar pTerm = DD.sqr(p.x).selfAdd(DD.sqr(p.y)).selfMultiply(TrianglePredicate.triAreaDDFast(a, b, c));\n  \tvar sum = aTerm.selfSubtract(bTerm).selfAdd(cTerm).selfSubtract(pTerm);\n  \tvar isInCircle = sum.doubleValue() > 0;\n  \treturn isInCircle;\n  };\n  TrianglePredicate.isInCircleCC = function (a, b, c, p) {\n  \tvar cc = Triangle$1.circumcentre(a, b, c);\n  \tvar ccRadius = a.distance(cc);\n  \tvar pRadiusDiff = p.distance(cc) - ccRadius;\n  \treturn pRadiusDiff <= 0;\n  };\n  TrianglePredicate.isInCircleNormalized = function (a, b, c, p) {\n  \tvar adx = a.x - p.x;\n  \tvar ady = a.y - p.y;\n  \tvar bdx = b.x - p.x;\n  \tvar bdy = b.y - p.y;\n  \tvar cdx = c.x - p.x;\n  \tvar cdy = c.y - p.y;\n  \tvar abdet = adx * bdy - bdx * ady;\n  \tvar bcdet = bdx * cdy - cdx * bdy;\n  \tvar cadet = cdx * ady - adx * cdy;\n  \tvar alift = adx * adx + ady * ady;\n  \tvar blift = bdx * bdx + bdy * bdy;\n  \tvar clift = cdx * cdx + cdy * cdy;\n  \tvar disc = alift * bcdet + blift * cadet + clift * abdet;\n  \treturn disc > 0;\n  };\n  TrianglePredicate.isInCircleDDSlow = function (a, b, c, p) {\n  \tvar px = DD.valueOf(p.x);\n  \tvar py = DD.valueOf(p.y);\n  \tvar ax = DD.valueOf(a.x);\n  \tvar ay = DD.valueOf(a.y);\n  \tvar bx = DD.valueOf(b.x);\n  \tvar by = DD.valueOf(b.y);\n  \tvar cx = DD.valueOf(c.x);\n  \tvar cy = DD.valueOf(c.y);\n  \tvar aTerm = ax.multiply(ax).add(ay.multiply(ay)).multiply(TrianglePredicate.triAreaDDSlow(bx, by, cx, cy, px, py));\n  \tvar bTerm = bx.multiply(bx).add(by.multiply(by)).multiply(TrianglePredicate.triAreaDDSlow(ax, ay, cx, cy, px, py));\n  \tvar cTerm = cx.multiply(cx).add(cy.multiply(cy)).multiply(TrianglePredicate.triAreaDDSlow(ax, ay, bx, by, px, py));\n  \tvar pTerm = px.multiply(px).add(py.multiply(py)).multiply(TrianglePredicate.triAreaDDSlow(ax, ay, bx, by, cx, cy));\n  \tvar sum = aTerm.subtract(bTerm).add(cTerm).subtract(pTerm);\n  \tvar isInCircle = sum.doubleValue() > 0;\n  \treturn isInCircle;\n  };\n  TrianglePredicate.isInCircleNonRobust = function (a, b, c, p) {\n  \tvar isInCircle = (a.x * a.x + a.y * a.y) * TrianglePredicate.triArea(b, c, p) - (b.x * b.x + b.y * b.y) * TrianglePredicate.triArea(a, c, p) + (c.x * c.x + c.y * c.y) * TrianglePredicate.triArea(a, b, p) - (p.x * p.x + p.y * p.y) * TrianglePredicate.triArea(a, b, c) > 0;\n  \treturn isInCircle;\n  };\n  TrianglePredicate.isInCircleRobust = function (a, b, c, p) {\n  \treturn TrianglePredicate.isInCircleNormalized(a, b, c, p);\n  };\n  TrianglePredicate.triAreaDDSlow = function (ax, ay, bx, by, cx, cy) {\n  \treturn bx.subtract(ax).multiply(cy.subtract(ay)).subtract(by.subtract(ay).multiply(cx.subtract(ax)));\n  };\n  TrianglePredicate.triAreaDDFast = function (a, b, c) {\n  \tvar t1 = DD.valueOf(b.x).selfSubtract(a.x).selfMultiply(DD.valueOf(c.y).selfSubtract(a.y));\n  \tvar t2 = DD.valueOf(b.y).selfSubtract(a.y).selfMultiply(DD.valueOf(c.x).selfSubtract(a.x));\n  \treturn t1.selfSubtract(t2);\n  };\n\n  function Vertex() {\n  \tthis._p = null;\n  \tif (arguments.length === 1) {\n  \t\tvar _p = arguments[0];\n  \t\tthis._p = new Coordinate(_p);\n  \t} else if (arguments.length === 2) {\n  \t\tvar _x = arguments[0],\n  \t\t    _y = arguments[1];\n  \t\tthis._p = new Coordinate(_x, _y);\n  \t} else if (arguments.length === 3) {\n  \t\tvar _x = arguments[0],\n  \t\t    _y = arguments[1],\n  \t\t    _z = arguments[2];\n  \t\tthis._p = new Coordinate(_x, _y, _z);\n  \t}\n  }\n  extend(Vertex.prototype, {\n  \tcircleCenter: function circleCenter(b, c) {\n  \t\tvar a = new Vertex(this.getX(), this.getY());\n  \t\tvar cab = this.bisector(a, b);\n  \t\tvar cbc = this.bisector(b, c);\n  \t\tvar hcc = new HCoordinate(cab, cbc);\n  \t\tvar cc = null;\n  \t\ttry {\n  \t\t\tcc = new Vertex(hcc.getX(), hcc.getY());\n  \t\t} catch (nre) {\n  \t\t\tif (nre instanceof NotRepresentableException) {\n  \t\t\t\tSystem.err.println(\"a: \" + a + \"  b: \" + b + \"  c: \" + c);\n  \t\t\t\tSystem.err.println(nre);\n  \t\t\t} else throw nre;\n  \t\t} finally {}\n  \t\treturn cc;\n  \t},\n  \tdot: function dot(v) {\n  \t\treturn this._p.x * v.getX() + this._p.y * v.getY();\n  \t},\n  \tmagn: function magn() {\n  \t\treturn Math.sqrt(this._p.x * this._p.x + this._p.y * this._p.y);\n  \t},\n  \tgetZ: function getZ() {\n  \t\treturn this._p.z;\n  \t},\n  \tbisector: function bisector(a, b) {\n  \t\tvar dx = b.getX() - a.getX();\n  \t\tvar dy = b.getY() - a.getY();\n  \t\tvar l1 = new HCoordinate(a.getX() + dx / 2.0, a.getY() + dy / 2.0, 1.0);\n  \t\tvar l2 = new HCoordinate(a.getX() - dy + dx / 2.0, a.getY() + dx + dy / 2.0, 1.0);\n  \t\treturn new HCoordinate(l1, l2);\n  \t},\n  \tequals: function equals() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar _x = arguments[0];\n  \t\t\tif (this._p.x === _x.getX() && this._p.y === _x.getY()) {\n  \t\t\t\treturn true;\n  \t\t\t} else {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar _x = arguments[0],\n  \t\t\t    tolerance = arguments[1];\n  \t\t\tif (this._p.distance(_x.getCoordinate()) < tolerance) {\n  \t\t\t\treturn true;\n  \t\t\t} else {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\treturn this._p;\n  \t},\n  \tisInCircle: function isInCircle(a, b, c) {\n  \t\treturn TrianglePredicate.isInCircleRobust(a._p, b._p, c._p, this._p);\n  \t},\n  \tinterpolateZValue: function interpolateZValue(v0, v1, v2) {\n  \t\tvar x0 = v0.getX();\n  \t\tvar y0 = v0.getY();\n  \t\tvar a = v1.getX() - x0;\n  \t\tvar b = v2.getX() - x0;\n  \t\tvar c = v1.getY() - y0;\n  \t\tvar d = v2.getY() - y0;\n  \t\tvar det = a * d - b * c;\n  \t\tvar dx = this.getX() - x0;\n  \t\tvar dy = this.getY() - y0;\n  \t\tvar t = (d * dx - b * dy) / det;\n  \t\tvar u = (-c * dx + a * dy) / det;\n  \t\tvar z = v0.getZ() + t * (v1.getZ() - v0.getZ()) + u * (v2.getZ() - v0.getZ());\n  \t\treturn z;\n  \t},\n  \tmidPoint: function midPoint(a) {\n  \t\tvar xm = (this._p.x + a.getX()) / 2.0;\n  \t\tvar ym = (this._p.y + a.getY()) / 2.0;\n  \t\tvar zm = (this._p.z + a.getZ()) / 2.0;\n  \t\treturn new Vertex(xm, ym, zm);\n  \t},\n  \trightOf: function rightOf(e) {\n  \t\treturn this.isCCW(e.dest(), e.orig());\n  \t},\n  \tisCCW: function isCCW(b, c) {\n  \t\treturn (b._p.x - this._p.x) * (c._p.y - this._p.y) - (b._p.y - this._p.y) * (c._p.x - this._p.x) > 0;\n  \t},\n  \tgetX: function getX() {\n  \t\treturn this._p.x;\n  \t},\n  \tcrossProduct: function crossProduct(v) {\n  \t\treturn this._p.x * v.getY() - this._p.y * v.getX();\n  \t},\n  \tsetZ: function setZ(_z) {\n  \t\tthis._p.z = _z;\n  \t},\n  \ttimes: function times(c) {\n  \t\treturn new Vertex(c * this._p.x, c * this._p.y);\n  \t},\n  \tcross: function cross() {\n  \t\treturn new Vertex(this._p.y, -this._p.x);\n  \t},\n  \tleftOf: function leftOf(e) {\n  \t\treturn this.isCCW(e.orig(), e.dest());\n  \t},\n  \ttoString: function toString() {\n  \t\treturn \"POINT (\" + this._p.x + \" \" + this._p.y + \")\";\n  \t},\n  \tsub: function sub(v) {\n  \t\treturn new Vertex(this._p.x - v.getX(), this._p.y - v.getY());\n  \t},\n  \tgetY: function getY() {\n  \t\treturn this._p.y;\n  \t},\n  \tclassify: function classify(p0, p1) {\n  \t\tvar p2 = this;\n  \t\tvar a = p1.sub(p0);\n  \t\tvar b = p2.sub(p0);\n  \t\tvar sa = a.crossProduct(b);\n  \t\tif (sa > 0.0) return Vertex.LEFT;\n  \t\tif (sa < 0.0) return Vertex.RIGHT;\n  \t\tif (a.getX() * b.getX() < 0.0 || a.getY() * b.getY() < 0.0) return Vertex.BEHIND;\n  \t\tif (a.magn() < b.magn()) return Vertex.BEYOND;\n  \t\tif (p0.equals(p2)) return Vertex.ORIGIN;\n  \t\tif (p1.equals(p2)) return Vertex.DESTINATION;\n  \t\treturn Vertex.BETWEEN;\n  \t},\n  \tsum: function sum(v) {\n  \t\treturn new Vertex(this._p.x + v.getX(), this._p.y + v.getY());\n  \t},\n  \tdistance: function distance(v1, v2) {\n  \t\treturn Math.sqrt(Math.pow(v2.getX() - v1.getX(), 2.0) + Math.pow(v2.getY() - v1.getY(), 2.0));\n  \t},\n  \tcircumRadiusRatio: function circumRadiusRatio(b, c) {\n  \t\tvar x = this.circleCenter(b, c);\n  \t\tvar radius = this.distance(x, b);\n  \t\tvar edgeLength = this.distance(this, b);\n  \t\tvar el = this.distance(b, c);\n  \t\tif (el < edgeLength) {\n  \t\t\tedgeLength = el;\n  \t\t}\n  \t\tel = this.distance(c, this);\n  \t\tif (el < edgeLength) {\n  \t\t\tedgeLength = el;\n  \t\t}\n  \t\treturn radius / edgeLength;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Vertex;\n  \t}\n  });\n  Vertex.interpolateZ = function () {\n  \tif (arguments.length === 3) {\n  \t\tvar p = arguments[0],\n  \t\t    p0 = arguments[1],\n  \t\t    p1 = arguments[2];\n  \t\tvar segLen = p0.distance(p1);\n  \t\tvar ptLen = p.distance(p0);\n  \t\tvar dz = p1.z - p0.z;\n  \t\tvar pz = p0.z + dz * (ptLen / segLen);\n  \t\treturn pz;\n  \t} else if (arguments.length === 4) {\n  \t\tvar p = arguments[0],\n  \t\t    v0 = arguments[1],\n  \t\t    v1 = arguments[2],\n  \t\t    v2 = arguments[3];\n  \t\tvar x0 = v0.x;\n  \t\tvar y0 = v0.y;\n  \t\tvar a = v1.x - x0;\n  \t\tvar b = v2.x - x0;\n  \t\tvar c = v1.y - y0;\n  \t\tvar d = v2.y - y0;\n  \t\tvar det = a * d - b * c;\n  \t\tvar dx = p.x - x0;\n  \t\tvar dy = p.y - y0;\n  \t\tvar t = (d * dx - b * dy) / det;\n  \t\tvar u = (-c * dx + a * dy) / det;\n  \t\tvar z = v0.z + t * (v1.z - v0.z) + u * (v2.z - v0.z);\n  \t\treturn z;\n  \t}\n  };\n  Vertex.LEFT = 0;\n  Vertex.RIGHT = 1;\n  Vertex.BEYOND = 2;\n  Vertex.BEHIND = 3;\n  Vertex.BETWEEN = 4;\n  Vertex.ORIGIN = 5;\n  Vertex.DESTINATION = 6;\n\n  function ConstraintVertex() {\n  \tthis._isOnConstraint = null;\n  \tthis._constraint = null;\n  \tvar p = arguments[0];\n  \tVertex.call(this, p);\n  }\n  inherits$1(ConstraintVertex, Vertex);\n  extend(ConstraintVertex.prototype, {\n  \tgetConstraint: function getConstraint() {\n  \t\treturn this._constraint;\n  \t},\n  \tsetOnConstraint: function setOnConstraint(isOnConstraint) {\n  \t\tthis._isOnConstraint = isOnConstraint;\n  \t},\n  \tmerge: function merge(other) {\n  \t\tif (other._isOnConstraint) {\n  \t\t\tthis._isOnConstraint = true;\n  \t\t\tthis._constraint = other._constraint;\n  \t\t}\n  \t},\n  \tisOnConstraint: function isOnConstraint() {\n  \t\treturn this._isOnConstraint;\n  \t},\n  \tsetConstraint: function setConstraint(constraint) {\n  \t\tthis._isOnConstraint = true;\n  \t\tthis._constraint = constraint;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn ConstraintVertex;\n  \t}\n  });\n\n  function QuadEdge() {\n  \tthis._rot = null;\n  \tthis._vertex = null;\n  \tthis._next = null;\n  \tthis._data = null;\n  }\n  extend(QuadEdge.prototype, {\n  \tequalsNonOriented: function equalsNonOriented(qe) {\n  \t\tif (this.equalsOriented(qe)) return true;\n  \t\tif (this.equalsOriented(qe.sym())) return true;\n  \t\treturn false;\n  \t},\n  \ttoLineSegment: function toLineSegment() {\n  \t\treturn new LineSegment(this._vertex.getCoordinate(), this.dest().getCoordinate());\n  \t},\n  \tdest: function dest() {\n  \t\treturn this.sym().orig();\n  \t},\n  \toNext: function oNext() {\n  \t\treturn this._next;\n  \t},\n  \tequalsOriented: function equalsOriented(qe) {\n  \t\tif (this.orig().getCoordinate().equals2D(qe.orig().getCoordinate()) && this.dest().getCoordinate().equals2D(qe.dest().getCoordinate())) return true;\n  \t\treturn false;\n  \t},\n  \tdNext: function dNext() {\n  \t\treturn this.sym().oNext().sym();\n  \t},\n  \tlPrev: function lPrev() {\n  \t\treturn this._next.sym();\n  \t},\n  \trPrev: function rPrev() {\n  \t\treturn this.sym().oNext();\n  \t},\n  \trot: function rot() {\n  \t\treturn this._rot;\n  \t},\n  \toPrev: function oPrev() {\n  \t\treturn this._rot._next._rot;\n  \t},\n  \tsym: function sym() {\n  \t\treturn this._rot._rot;\n  \t},\n  \tsetOrig: function setOrig(o) {\n  \t\tthis._vertex = o;\n  \t},\n  \tlNext: function lNext() {\n  \t\treturn this.invRot().oNext().rot();\n  \t},\n  \tgetLength: function getLength() {\n  \t\treturn this.orig().getCoordinate().distance(this.dest().getCoordinate());\n  \t},\n  \tinvRot: function invRot() {\n  \t\treturn this._rot.sym();\n  \t},\n  \tsetDest: function setDest(d) {\n  \t\tthis.sym().setOrig(d);\n  \t},\n  \tsetData: function setData(data) {\n  \t\tthis._data = data;\n  \t},\n  \tgetData: function getData() {\n  \t\treturn this._data;\n  \t},\n  \tdelete: function _delete() {\n  \t\tthis._rot = null;\n  \t},\n  \torig: function orig() {\n  \t\treturn this._vertex;\n  \t},\n  \trNext: function rNext() {\n  \t\treturn this._rot._next.invRot();\n  \t},\n  \ttoString: function toString() {\n  \t\tvar p0 = this._vertex.getCoordinate();\n  \t\tvar p1 = this.dest().getCoordinate();\n  \t\treturn WKTWriter.toLineString(p0, p1);\n  \t},\n  \tisLive: function isLive() {\n  \t\treturn this._rot !== null;\n  \t},\n  \tgetPrimary: function getPrimary() {\n  \t\tif (this.orig().getCoordinate().compareTo(this.dest().getCoordinate()) <= 0) return this;else return this.sym();\n  \t},\n  \tdPrev: function dPrev() {\n  \t\treturn this.invRot().oNext().invRot();\n  \t},\n  \tsetNext: function setNext(next) {\n  \t\tthis._next = next;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn QuadEdge;\n  \t}\n  });\n  QuadEdge.makeEdge = function (o, d) {\n  \tvar q0 = new QuadEdge();\n  \tvar q1 = new QuadEdge();\n  \tvar q2 = new QuadEdge();\n  \tvar q3 = new QuadEdge();\n  \tq0._rot = q1;\n  \tq1._rot = q2;\n  \tq2._rot = q3;\n  \tq3._rot = q0;\n  \tq0.setNext(q0);\n  \tq1.setNext(q3);\n  \tq2.setNext(q2);\n  \tq3.setNext(q1);\n  \tvar base = q0;\n  \tbase.setOrig(o);\n  \tbase.setDest(d);\n  \treturn base;\n  };\n  QuadEdge.swap = function (e) {\n  \tvar a = e.oPrev();\n  \tvar b = e.sym().oPrev();\n  \tQuadEdge.splice(e, a);\n  \tQuadEdge.splice(e.sym(), b);\n  \tQuadEdge.splice(e, a.lNext());\n  \tQuadEdge.splice(e.sym(), b.lNext());\n  \te.setOrig(a.dest());\n  \te.setDest(b.dest());\n  };\n  QuadEdge.splice = function (a, b) {\n  \tvar alpha = a.oNext().rot();\n  \tvar beta = b.oNext().rot();\n  \tvar t1 = b.oNext();\n  \tvar t2 = a.oNext();\n  \tvar t3 = beta.oNext();\n  \tvar t4 = alpha.oNext();\n  \ta.setNext(t1);\n  \tb.setNext(t2);\n  \talpha.setNext(t3);\n  \tbeta.setNext(t4);\n  };\n  QuadEdge.connect = function (a, b) {\n  \tvar e = QuadEdge.makeEdge(a.dest(), b.orig());\n  \tQuadEdge.splice(e, a.lNext());\n  \tQuadEdge.splice(e.sym(), b);\n  \treturn e;\n  };\n\n  function IncrementalDelaunayTriangulator() {\n  \tthis._subdiv = null;\n  \tthis._isUsingTolerance = false;\n  \tvar subdiv = arguments[0];\n  \tthis._subdiv = subdiv;\n  \tthis._isUsingTolerance = subdiv.getTolerance() > 0.0;\n  }\n  extend(IncrementalDelaunayTriangulator.prototype, {\n  \tinsertSite: function insertSite(v) {\n  \t\tvar e = this._subdiv.locate(v);\n  \t\tif (this._subdiv.isVertexOfEdge(e, v)) {\n  \t\t\treturn e;\n  \t\t} else if (this._subdiv.isOnEdge(e, v.getCoordinate())) {\n  \t\t\te = e.oPrev();\n  \t\t\tthis._subdiv.delete(e.oNext());\n  \t\t}\n  \t\tvar base = this._subdiv.makeEdge(e.orig(), v);\n  \t\tQuadEdge.splice(base, e);\n  \t\tvar startEdge = base;\n  \t\tdo {\n  \t\t\tbase = this._subdiv.connect(e, base.sym());\n  \t\t\te = base.oPrev();\n  \t\t} while (e.lNext() !== startEdge);\n  \t\tdo {\n  \t\t\tvar t = e.oPrev();\n  \t\t\tif (t.dest().rightOf(e) && v.isInCircle(e.orig(), t.dest(), e.dest())) {\n  \t\t\t\tQuadEdge.swap(e);\n  \t\t\t\te = e.oPrev();\n  \t\t\t} else if (e.oNext() === startEdge) {\n  \t\t\t\treturn base;\n  \t\t\t} else {\n  \t\t\t\te = e.oNext().lPrev();\n  \t\t\t}\n  \t\t} while (true);\n  \t},\n  \tinsertSites: function insertSites(vertices) {\n  \t\tfor (var i = vertices.iterator(); i.hasNext();) {\n  \t\t\tvar v = i.next();\n  \t\t\tthis.insertSite(v);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn IncrementalDelaunayTriangulator;\n  \t}\n  });\n\n  function QuadEdgeLocator() {}\n  extend(QuadEdgeLocator.prototype, {\n  \tlocate: function locate(v) {},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn QuadEdgeLocator;\n  \t}\n  });\n\n  function LastFoundQuadEdgeLocator() {\n  \tthis._subdiv = null;\n  \tthis._lastEdge = null;\n  \tvar subdiv = arguments[0];\n  \tthis._subdiv = subdiv;\n  \tthis.init();\n  }\n  extend(LastFoundQuadEdgeLocator.prototype, {\n  \tinit: function init() {\n  \t\tthis._lastEdge = this.findEdge();\n  \t},\n  \tlocate: function locate(v) {\n  \t\tif (!this._lastEdge.isLive()) {\n  \t\t\tthis.init();\n  \t\t}\n  \t\tvar e = this._subdiv.locateFromEdge(v, this._lastEdge);\n  \t\tthis._lastEdge = e;\n  \t\treturn e;\n  \t},\n  \tfindEdge: function findEdge() {\n  \t\tvar edges = this._subdiv.getEdges();\n  \t\treturn edges.iterator().next();\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [QuadEdgeLocator];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LastFoundQuadEdgeLocator;\n  \t}\n  });\n\n  function LocateFailureException() {\n  \tthis._seg = null;\n  \tif (arguments.length === 1) {\n  \t\tif (typeof arguments[0] === \"string\") {\n  \t\t\tvar msg = arguments[0];\n  \t\t\tRuntimeException.call(this, msg);\n  \t\t} else if (arguments[0] instanceof LineSegment) {\n  \t\t\tvar seg = arguments[0];\n  \t\t\tRuntimeException.call(this, \"Locate failed to converge (at edge: \" + seg + \").  Possible causes include invalid Subdivision topology or very close sites\");\n  \t\t\tthis._seg = new LineSegment(seg);\n  \t\t}\n  \t} else if (arguments.length === 2) {\n  \t\tvar msg = arguments[0],\n  \t\t    seg = arguments[1];\n  \t\tRuntimeException.call(this, LocateFailureException.msgWithSpatial(msg, seg));\n  \t\tthis._seg = new LineSegment(seg);\n  \t}\n  }\n  inherits$1(LocateFailureException, RuntimeException);\n  extend(LocateFailureException.prototype, {\n  \tgetSegment: function getSegment() {\n  \t\treturn this._seg;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LocateFailureException;\n  \t}\n  });\n  LocateFailureException.msgWithSpatial = function (msg, seg) {\n  \tif (seg !== null) return msg + \" [ \" + seg + \" ]\";\n  \treturn msg;\n  };\n\n  function TriangleVisitor() {}\n  extend(TriangleVisitor.prototype, {\n  \tvisit: function visit(triEdges) {},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn TriangleVisitor;\n  \t}\n  });\n\n  function QuadEdgeSubdivision() {\n  \tthis._visitedKey = 0;\n  \tthis._quadEdges = new ArrayList();\n  \tthis._startingEdge = null;\n  \tthis._tolerance = null;\n  \tthis._edgeCoincidenceTolerance = null;\n  \tthis._frameVertex = new Array(3).fill(null);\n  \tthis._frameEnv = null;\n  \tthis._locator = null;\n  \tthis._seg = new LineSegment();\n  \tthis._triEdges = new Array(3).fill(null);\n  \tvar env = arguments[0],\n  \t    tolerance = arguments[1];\n  \tthis._tolerance = tolerance;\n  \tthis._edgeCoincidenceTolerance = tolerance / QuadEdgeSubdivision.EDGE_COINCIDENCE_TOL_FACTOR;\n  \tthis.createFrame(env);\n  \tthis._startingEdge = this.initSubdiv();\n  \tthis._locator = new LastFoundQuadEdgeLocator(this);\n  }\n  extend(QuadEdgeSubdivision.prototype, {\n  \tgetTriangleVertices: function getTriangleVertices(includeFrame) {\n  \t\tvar visitor = new TriangleVertexListVisitor();\n  \t\tthis.visitTriangles(visitor, includeFrame);\n  \t\treturn visitor.getTriangleVertices();\n  \t},\n  \tisFrameVertex: function isFrameVertex(v) {\n  \t\tif (v.equals(this._frameVertex[0])) return true;\n  \t\tif (v.equals(this._frameVertex[1])) return true;\n  \t\tif (v.equals(this._frameVertex[2])) return true;\n  \t\treturn false;\n  \t},\n  \tisVertexOfEdge: function isVertexOfEdge(e, v) {\n  \t\tif (v.equals(e.orig(), this._tolerance) || v.equals(e.dest(), this._tolerance)) {\n  \t\t\treturn true;\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tconnect: function connect(a, b) {\n  \t\tvar q = QuadEdge.connect(a, b);\n  \t\tthis._quadEdges.add(q);\n  \t\treturn q;\n  \t},\n  \tgetVoronoiCellPolygon: function getVoronoiCellPolygon(qe, geomFact) {\n  \t\tvar cellPts = new ArrayList();\n  \t\tvar startQE = qe;\n  \t\tdo {\n  \t\t\tvar cc = qe.rot().orig().getCoordinate();\n  \t\t\tcellPts.add(cc);\n  \t\t\tqe = qe.oPrev();\n  \t\t} while (qe !== startQE);\n  \t\tvar coordList = new CoordinateList();\n  \t\tcoordList.addAll(cellPts, false);\n  \t\tcoordList.closeRing();\n  \t\tif (coordList.size() < 4) {\n  \t\t\tSystem.out.println(coordList);\n  \t\t\tcoordList.add(coordList.get(coordList.size() - 1), true);\n  \t\t}\n  \t\tvar pts = coordList.toCoordinateArray();\n  \t\tvar cellPoly = geomFact.createPolygon(geomFact.createLinearRing(pts), null);\n  \t\tvar v = startQE.orig();\n  \t\tcellPoly.setUserData(v.getCoordinate());\n  \t\treturn cellPoly;\n  \t},\n  \tsetLocator: function setLocator(locator) {\n  \t\tthis._locator = locator;\n  \t},\n  \tinitSubdiv: function initSubdiv() {\n  \t\tvar ea = this.makeEdge(this._frameVertex[0], this._frameVertex[1]);\n  \t\tvar eb = this.makeEdge(this._frameVertex[1], this._frameVertex[2]);\n  \t\tQuadEdge.splice(ea.sym(), eb);\n  \t\tvar ec = this.makeEdge(this._frameVertex[2], this._frameVertex[0]);\n  \t\tQuadEdge.splice(eb.sym(), ec);\n  \t\tQuadEdge.splice(ec.sym(), ea);\n  \t\treturn ea;\n  \t},\n  \tisFrameBorderEdge: function isFrameBorderEdge(e) {\n  \t\tvar leftTri = new Array(3).fill(null);\n  \t\tQuadEdgeSubdivision.getTriangleEdges(e, leftTri);\n  \t\tvar rightTri = new Array(3).fill(null);\n  \t\tQuadEdgeSubdivision.getTriangleEdges(e.sym(), rightTri);\n  \t\tvar vLeftTriOther = e.lNext().dest();\n  \t\tif (this.isFrameVertex(vLeftTriOther)) return true;\n  \t\tvar vRightTriOther = e.sym().lNext().dest();\n  \t\tif (this.isFrameVertex(vRightTriOther)) return true;\n  \t\treturn false;\n  \t},\n  \tmakeEdge: function makeEdge(o, d) {\n  \t\tvar q = QuadEdge.makeEdge(o, d);\n  \t\tthis._quadEdges.add(q);\n  \t\treturn q;\n  \t},\n  \tvisitTriangles: function visitTriangles(triVisitor, includeFrame) {\n  \t\tthis._visitedKey++;\n  \t\tvar edgeStack = new Stack$1();\n  \t\tedgeStack.push(this._startingEdge);\n  \t\tvar visitedEdges = new HashSet();\n  \t\twhile (!edgeStack.empty()) {\n  \t\t\tvar edge = edgeStack.pop();\n  \t\t\tif (!visitedEdges.contains(edge)) {\n  \t\t\t\tvar triEdges = this.fetchTriangleToVisit(edge, edgeStack, includeFrame, visitedEdges);\n  \t\t\t\tif (triEdges !== null) triVisitor.visit(triEdges);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tisFrameEdge: function isFrameEdge(e) {\n  \t\tif (this.isFrameVertex(e.orig()) || this.isFrameVertex(e.dest())) return true;\n  \t\treturn false;\n  \t},\n  \tisOnEdge: function isOnEdge(e, p) {\n  \t\tthis._seg.setCoordinates(e.orig().getCoordinate(), e.dest().getCoordinate());\n  \t\tvar dist = this._seg.distance(p);\n  \t\treturn dist < this._edgeCoincidenceTolerance;\n  \t},\n  \tgetEnvelope: function getEnvelope() {\n  \t\treturn new Envelope(this._frameEnv);\n  \t},\n  \tcreateFrame: function createFrame(env) {\n  \t\tvar deltaX = env.getWidth();\n  \t\tvar deltaY = env.getHeight();\n  \t\tvar offset = 0.0;\n  \t\tif (deltaX > deltaY) {\n  \t\t\toffset = deltaX * 10.0;\n  \t\t} else {\n  \t\t\toffset = deltaY * 10.0;\n  \t\t}\n  \t\tthis._frameVertex[0] = new Vertex((env.getMaxX() + env.getMinX()) / 2.0, env.getMaxY() + offset);\n  \t\tthis._frameVertex[1] = new Vertex(env.getMinX() - offset, env.getMinY() - offset);\n  \t\tthis._frameVertex[2] = new Vertex(env.getMaxX() + offset, env.getMinY() - offset);\n  \t\tthis._frameEnv = new Envelope(this._frameVertex[0].getCoordinate(), this._frameVertex[1].getCoordinate());\n  \t\tthis._frameEnv.expandToInclude(this._frameVertex[2].getCoordinate());\n  \t},\n  \tgetTriangleCoordinates: function getTriangleCoordinates(includeFrame) {\n  \t\tvar visitor = new TriangleCoordinatesVisitor();\n  \t\tthis.visitTriangles(visitor, includeFrame);\n  \t\treturn visitor.getTriangles();\n  \t},\n  \tgetVertices: function getVertices(includeFrame) {\n  \t\tvar vertices = new HashSet();\n  \t\tfor (var i = this._quadEdges.iterator(); i.hasNext();) {\n  \t\t\tvar qe = i.next();\n  \t\t\tvar v = qe.orig();\n  \t\t\tif (includeFrame || !this.isFrameVertex(v)) vertices.add(v);\n  \t\t\tvar vd = qe.dest();\n  \t\t\tif (includeFrame || !this.isFrameVertex(vd)) vertices.add(vd);\n  \t\t}\n  \t\treturn vertices;\n  \t},\n  \tfetchTriangleToVisit: function fetchTriangleToVisit(edge, edgeStack, includeFrame, visitedEdges) {\n  \t\tvar curr = edge;\n  \t\tvar edgeCount = 0;\n  \t\tvar isFrame = false;\n  \t\tdo {\n  \t\t\tthis._triEdges[edgeCount] = curr;\n  \t\t\tif (this.isFrameEdge(curr)) isFrame = true;\n  \t\t\tvar sym = curr.sym();\n  \t\t\tif (!visitedEdges.contains(sym)) edgeStack.push(sym);\n  \t\t\tvisitedEdges.add(curr);\n  \t\t\tedgeCount++;\n  \t\t\tcurr = curr.lNext();\n  \t\t} while (curr !== edge);\n  \t\tif (isFrame && !includeFrame) return null;\n  \t\treturn this._triEdges;\n  \t},\n  \tgetEdges: function getEdges() {\n  \t\tif (arguments.length === 0) {\n  \t\t\treturn this._quadEdges;\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tvar geomFact = arguments[0];\n  \t\t\tvar quadEdges = this.getPrimaryEdges(false);\n  \t\t\tvar edges = new Array(quadEdges.size()).fill(null);\n  \t\t\tvar i = 0;\n  \t\t\tfor (var it = quadEdges.iterator(); it.hasNext();) {\n  \t\t\t\tvar qe = it.next();\n  \t\t\t\tedges[i++] = geomFact.createLineString([qe.orig().getCoordinate(), qe.dest().getCoordinate()]);\n  \t\t\t}\n  \t\t\treturn geomFact.createMultiLineString(edges);\n  \t\t}\n  \t},\n  \tgetVertexUniqueEdges: function getVertexUniqueEdges(includeFrame) {\n  \t\tvar edges = new ArrayList();\n  \t\tvar visitedVertices = new HashSet();\n  \t\tfor (var i = this._quadEdges.iterator(); i.hasNext();) {\n  \t\t\tvar qe = i.next();\n  \t\t\tvar v = qe.orig();\n  \t\t\tif (!visitedVertices.contains(v)) {\n  \t\t\t\tvisitedVertices.add(v);\n  \t\t\t\tif (includeFrame || !this.isFrameVertex(v)) {\n  \t\t\t\t\tedges.add(qe);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\tvar qd = qe.sym();\n  \t\t\tvar vd = qd.orig();\n  \t\t\tif (!visitedVertices.contains(vd)) {\n  \t\t\t\tvisitedVertices.add(vd);\n  \t\t\t\tif (includeFrame || !this.isFrameVertex(vd)) {\n  \t\t\t\t\tedges.add(qd);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\treturn edges;\n  \t},\n  \tgetTriangleEdges: function getTriangleEdges(includeFrame) {\n  \t\tvar visitor = new TriangleEdgesListVisitor();\n  \t\tthis.visitTriangles(visitor, includeFrame);\n  \t\treturn visitor.getTriangleEdges();\n  \t},\n  \tgetPrimaryEdges: function getPrimaryEdges(includeFrame) {\n  \t\tthis._visitedKey++;\n  \t\tvar edges = new ArrayList();\n  \t\tvar edgeStack = new Stack$1();\n  \t\tedgeStack.push(this._startingEdge);\n  \t\tvar visitedEdges = new HashSet();\n  \t\twhile (!edgeStack.empty()) {\n  \t\t\tvar edge = edgeStack.pop();\n  \t\t\tif (!visitedEdges.contains(edge)) {\n  \t\t\t\tvar priQE = edge.getPrimary();\n  \t\t\t\tif (includeFrame || !this.isFrameEdge(priQE)) edges.add(priQE);\n  \t\t\t\tedgeStack.push(edge.oNext());\n  \t\t\t\tedgeStack.push(edge.sym().oNext());\n  \t\t\t\tvisitedEdges.add(edge);\n  \t\t\t\tvisitedEdges.add(edge.sym());\n  \t\t\t}\n  \t\t}\n  \t\treturn edges;\n  \t},\n  \tdelete: function _delete(e) {\n  \t\tQuadEdge.splice(e, e.oPrev());\n  \t\tQuadEdge.splice(e.sym(), e.sym().oPrev());\n  \t\tvar eSym = e.sym();\n  \t\tvar eRot = e.rot();\n  \t\tvar eRotSym = e.rot().sym();\n  \t\tthis._quadEdges.remove(e);\n  \t\tthis._quadEdges.remove(eSym);\n  \t\tthis._quadEdges.remove(eRot);\n  \t\tthis._quadEdges.remove(eRotSym);\n  \t\te.delete();\n  \t\teSym.delete();\n  \t\teRot.delete();\n  \t\teRotSym.delete();\n  \t},\n  \tlocateFromEdge: function locateFromEdge(v, startEdge) {\n  \t\tvar iter = 0;\n  \t\tvar maxIter = this._quadEdges.size();\n  \t\tvar e = startEdge;\n  \t\twhile (true) {\n  \t\t\titer++;\n  \t\t\tif (iter > maxIter) {\n  \t\t\t\tthrow new LocateFailureException(e.toLineSegment());\n  \t\t\t}\n  \t\t\tif (v.equals(e.orig()) || v.equals(e.dest())) {\n  \t\t\t\tbreak;\n  \t\t\t} else if (v.rightOf(e)) {\n  \t\t\t\te = e.sym();\n  \t\t\t} else if (!v.rightOf(e.oNext())) {\n  \t\t\t\te = e.oNext();\n  \t\t\t} else if (!v.rightOf(e.dPrev())) {\n  \t\t\t\te = e.dPrev();\n  \t\t\t} else {\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t}\n  \t\treturn e;\n  \t},\n  \tgetTolerance: function getTolerance() {\n  \t\treturn this._tolerance;\n  \t},\n  \tgetVoronoiCellPolygons: function getVoronoiCellPolygons(geomFact) {\n  \t\tthis.visitTriangles(new TriangleCircumcentreVisitor(), true);\n  \t\tvar cells = new ArrayList();\n  \t\tvar edges = this.getVertexUniqueEdges(false);\n  \t\tfor (var i = edges.iterator(); i.hasNext();) {\n  \t\t\tvar qe = i.next();\n  \t\t\tcells.add(this.getVoronoiCellPolygon(qe, geomFact));\n  \t\t}\n  \t\treturn cells;\n  \t},\n  \tgetVoronoiDiagram: function getVoronoiDiagram(geomFact) {\n  \t\tvar vorCells = this.getVoronoiCellPolygons(geomFact);\n  \t\treturn geomFact.createGeometryCollection(GeometryFactory.toGeometryArray(vorCells));\n  \t},\n  \tgetTriangles: function getTriangles(geomFact) {\n  \t\tvar triPtsList = this.getTriangleCoordinates(false);\n  \t\tvar tris = new Array(triPtsList.size()).fill(null);\n  \t\tvar i = 0;\n  \t\tfor (var it = triPtsList.iterator(); it.hasNext();) {\n  \t\t\tvar triPt = it.next();\n  \t\t\ttris[i++] = geomFact.createPolygon(geomFact.createLinearRing(triPt), null);\n  \t\t}\n  \t\treturn geomFact.createGeometryCollection(tris);\n  \t},\n  \tinsertSite: function insertSite(v) {\n  \t\tvar e = this.locate(v);\n  \t\tif (v.equals(e.orig(), this._tolerance) || v.equals(e.dest(), this._tolerance)) {\n  \t\t\treturn e;\n  \t\t}\n  \t\tvar base = this.makeEdge(e.orig(), v);\n  \t\tQuadEdge.splice(base, e);\n  \t\tvar startEdge = base;\n  \t\tdo {\n  \t\t\tbase = this.connect(e, base.sym());\n  \t\t\te = base.oPrev();\n  \t\t} while (e.lNext() !== startEdge);\n  \t\treturn startEdge;\n  \t},\n  \tlocate: function locate() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tif (arguments[0] instanceof Vertex) {\n  \t\t\t\tvar v = arguments[0];\n  \t\t\t\treturn this._locator.locate(v);\n  \t\t\t} else if (arguments[0] instanceof Coordinate) {\n  \t\t\t\tvar p = arguments[0];\n  \t\t\t\treturn this._locator.locate(new Vertex(p));\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar p0 = arguments[0],\n  \t\t\t    p1 = arguments[1];\n  \t\t\tvar e = this._locator.locate(new Vertex(p0));\n  \t\t\tif (e === null) return null;\n  \t\t\tvar base = e;\n  \t\t\tif (e.dest().getCoordinate().equals2D(p0)) base = e.sym();\n  \t\t\tvar locEdge = base;\n  \t\t\tdo {\n  \t\t\t\tif (locEdge.dest().getCoordinate().equals2D(p1)) return locEdge;\n  \t\t\t\tlocEdge = locEdge.oNext();\n  \t\t\t} while (locEdge !== base);\n  \t\t\treturn null;\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn QuadEdgeSubdivision;\n  \t}\n  });\n  QuadEdgeSubdivision.getTriangleEdges = function (startQE, triEdge) {\n  \ttriEdge[0] = startQE;\n  \ttriEdge[1] = triEdge[0].lNext();\n  \ttriEdge[2] = triEdge[1].lNext();\n  \tif (triEdge[2].lNext() !== triEdge[0]) throw new IllegalArgumentException(\"Edges do not form a triangle\");\n  };\n  function TriangleCircumcentreVisitor() {}\n  extend(TriangleCircumcentreVisitor.prototype, {\n  \tvisit: function visit(triEdges) {\n  \t\tvar a = triEdges[0].orig().getCoordinate();\n  \t\tvar b = triEdges[1].orig().getCoordinate();\n  \t\tvar c = triEdges[2].orig().getCoordinate();\n  \t\tvar cc = Triangle$1.circumcentre(a, b, c);\n  \t\tvar ccVertex = new Vertex(cc);\n  \t\tfor (var i = 0; i < 3; i++) {\n  \t\t\ttriEdges[i].rot().setOrig(ccVertex);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [TriangleVisitor];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn TriangleCircumcentreVisitor;\n  \t}\n  });\n  function TriangleEdgesListVisitor() {\n  \tthis._triList = new ArrayList();\n  }\n  extend(TriangleEdgesListVisitor.prototype, {\n  \tgetTriangleEdges: function getTriangleEdges() {\n  \t\treturn this._triList;\n  \t},\n  \tvisit: function visit(triEdges) {\n  \t\tthis._triList.add(triEdges.clone());\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [TriangleVisitor];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn TriangleEdgesListVisitor;\n  \t}\n  });\n  function TriangleVertexListVisitor() {\n  \tthis._triList = new ArrayList();\n  }\n  extend(TriangleVertexListVisitor.prototype, {\n  \tvisit: function visit(triEdges) {\n  \t\tthis._triList.add([triEdges[0].orig(), triEdges[1].orig(), triEdges[2].orig()]);\n  \t},\n  \tgetTriangleVertices: function getTriangleVertices() {\n  \t\treturn this._triList;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [TriangleVisitor];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn TriangleVertexListVisitor;\n  \t}\n  });\n  function TriangleCoordinatesVisitor() {\n  \tthis._coordList = new CoordinateList();\n  \tthis._triCoords = new ArrayList();\n  }\n  extend(TriangleCoordinatesVisitor.prototype, {\n  \tcheckTriangleSize: function checkTriangleSize(pts) {\n  \t\tvar loc = \"\";\n  \t\tif (pts.length >= 2) loc = WKTWriter.toLineString(pts[0], pts[1]);else {\n  \t\t\tif (pts.length >= 1) loc = WKTWriter.toPoint(pts[0]);\n  \t\t}\n  \t},\n  \tvisit: function visit(triEdges) {\n  \t\tthis._coordList.clear();\n  \t\tfor (var i = 0; i < 3; i++) {\n  \t\t\tvar v = triEdges[i].orig();\n  \t\t\tthis._coordList.add(v.getCoordinate());\n  \t\t}\n  \t\tif (this._coordList.size() > 0) {\n  \t\t\tthis._coordList.closeRing();\n  \t\t\tvar pts = this._coordList.toCoordinateArray();\n  \t\t\tif (pts.length !== 4) {\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t\tthis._triCoords.add(pts);\n  \t\t}\n  \t},\n  \tgetTriangles: function getTriangles() {\n  \t\treturn this._triCoords;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [TriangleVisitor];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn TriangleCoordinatesVisitor;\n  \t}\n  });\n  QuadEdgeSubdivision.TriangleCircumcentreVisitor = TriangleCircumcentreVisitor;\n  QuadEdgeSubdivision.TriangleEdgesListVisitor = TriangleEdgesListVisitor;\n  QuadEdgeSubdivision.TriangleVertexListVisitor = TriangleVertexListVisitor;\n  QuadEdgeSubdivision.TriangleCoordinatesVisitor = TriangleCoordinatesVisitor;\n  QuadEdgeSubdivision.EDGE_COINCIDENCE_TOL_FACTOR = 1000;\n\n  function Segment() {\n  \tthis._ls = null;\n  \tthis._data = null;\n  \tif (arguments.length === 2) {\n  \t\tvar p0 = arguments[0],\n  \t\t    p1 = arguments[1];\n  \t\tthis._ls = new LineSegment(p0, p1);\n  \t} else if (arguments.length === 3) {\n  \t\tvar p0 = arguments[0],\n  \t\t    p1 = arguments[1],\n  \t\t    data = arguments[2];\n  \t\tthis._ls = new LineSegment(p0, p1);\n  \t\tthis._data = data;\n  \t} else if (arguments.length === 6) {\n  \t\tvar x1 = arguments[0],\n  \t\t    y1 = arguments[1],\n  \t\t    z1 = arguments[2],\n  \t\t    x2 = arguments[3],\n  \t\t    y2 = arguments[4],\n  \t\t    z2 = arguments[5];\n  \t\tSegment.call(this, new Coordinate(x1, y1, z1), new Coordinate(x2, y2, z2));\n  \t} else if (arguments.length === 7) {\n  \t\tvar x1 = arguments[0],\n  \t\t    y1 = arguments[1],\n  \t\t    z1 = arguments[2],\n  \t\t    x2 = arguments[3],\n  \t\t    y2 = arguments[4],\n  \t\t    z2 = arguments[5],\n  \t\t    data = arguments[6];\n  \t\tSegment.call(this, new Coordinate(x1, y1, z1), new Coordinate(x2, y2, z2), data);\n  \t}\n  }\n  extend(Segment.prototype, {\n  \tgetLineSegment: function getLineSegment() {\n  \t\treturn this._ls;\n  \t},\n  \tgetEndZ: function getEndZ() {\n  \t\tvar p = this._ls.getCoordinate(1);\n  \t\treturn p.z;\n  \t},\n  \tgetStartZ: function getStartZ() {\n  \t\tvar p = this._ls.getCoordinate(0);\n  \t\treturn p.z;\n  \t},\n  \tintersection: function intersection(s) {\n  \t\treturn this._ls.intersection(s.getLineSegment());\n  \t},\n  \tgetStart: function getStart() {\n  \t\treturn this._ls.getCoordinate(0);\n  \t},\n  \tgetEnd: function getEnd() {\n  \t\treturn this._ls.getCoordinate(1);\n  \t},\n  \tgetEndY: function getEndY() {\n  \t\tvar p = this._ls.getCoordinate(1);\n  \t\treturn p.y;\n  \t},\n  \tgetStartX: function getStartX() {\n  \t\tvar p = this._ls.getCoordinate(0);\n  \t\treturn p.x;\n  \t},\n  \tequalsTopo: function equalsTopo(s) {\n  \t\treturn this._ls.equalsTopo(s.getLineSegment());\n  \t},\n  \tgetStartY: function getStartY() {\n  \t\tvar p = this._ls.getCoordinate(0);\n  \t\treturn p.y;\n  \t},\n  \tsetData: function setData(data) {\n  \t\tthis._data = data;\n  \t},\n  \tgetData: function getData() {\n  \t\treturn this._data;\n  \t},\n  \tgetEndX: function getEndX() {\n  \t\tvar p = this._ls.getCoordinate(1);\n  \t\treturn p.x;\n  \t},\n  \ttoString: function toString() {\n  \t\treturn this._ls.toString();\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Segment;\n  \t}\n  });\n\n  function KdNodeVisitor() {}\n  extend(KdNodeVisitor.prototype, {\n  \tvisit: function visit(node) {},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn KdNodeVisitor;\n  \t}\n  });\n\n  function KdNode() {\n  \tthis._p = null;\n  \tthis._data = null;\n  \tthis._left = null;\n  \tthis._right = null;\n  \tthis._count = null;\n  \tif (arguments.length === 2) {\n  \t\tvar p = arguments[0],\n  \t\t    data = arguments[1];\n  \t\tthis._p = new Coordinate(p);\n  \t\tthis._left = null;\n  \t\tthis._right = null;\n  \t\tthis._count = 1;\n  \t\tthis._data = data;\n  \t} else if (arguments.length === 3) {\n  \t\tvar _x = arguments[0],\n  \t\t    _y = arguments[1],\n  \t\t    data = arguments[2];\n  \t\tthis._p = new Coordinate(_x, _y);\n  \t\tthis._left = null;\n  \t\tthis._right = null;\n  \t\tthis._count = 1;\n  \t\tthis._data = data;\n  \t}\n  }\n  extend(KdNode.prototype, {\n  \tisRepeated: function isRepeated() {\n  \t\treturn this._count > 1;\n  \t},\n  \tgetRight: function getRight() {\n  \t\treturn this._right;\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\treturn this._p;\n  \t},\n  \tsetLeft: function setLeft(_left) {\n  \t\tthis._left = _left;\n  \t},\n  \tgetX: function getX() {\n  \t\treturn this._p.x;\n  \t},\n  \tgetData: function getData() {\n  \t\treturn this._data;\n  \t},\n  \tgetCount: function getCount() {\n  \t\treturn this._count;\n  \t},\n  \tgetLeft: function getLeft() {\n  \t\treturn this._left;\n  \t},\n  \tgetY: function getY() {\n  \t\treturn this._p.y;\n  \t},\n  \tincrement: function increment() {\n  \t\tthis._count = this._count + 1;\n  \t},\n  \tsetRight: function setRight(_right) {\n  \t\tthis._right = _right;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn KdNode;\n  \t}\n  });\n\n  function KdTree() {\n  \tthis._root = null;\n  \tthis._numberOfNodes = null;\n  \tthis._tolerance = null;\n  \tif (arguments.length === 0) {\n  \t\tKdTree.call(this, 0.0);\n  \t} else if (arguments.length === 1) {\n  \t\tvar tolerance = arguments[0];\n  \t\tthis._tolerance = tolerance;\n  \t}\n  }\n  extend(KdTree.prototype, {\n  \tinsert: function insert() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar p = arguments[0];\n  \t\t\treturn this.insert(p, null);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar p = arguments[0],\n  \t\t\t    data = arguments[1];\n  \t\t\tif (this._root === null) {\n  \t\t\t\tthis._root = new KdNode(p, data);\n  \t\t\t\treturn this._root;\n  \t\t\t}\n  \t\t\tif (this._tolerance > 0) {\n  \t\t\t\tvar matchNode = this.findBestMatchNode(p);\n  \t\t\t\tif (matchNode !== null) {\n  \t\t\t\t\tmatchNode.increment();\n  \t\t\t\t\treturn matchNode;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\treturn this.insertExact(p, data);\n  \t\t}\n  \t},\n  \tquery: function query() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar queryEnv = arguments[0];\n  \t\t\tvar result = new ArrayList();\n  \t\t\tthis.query(queryEnv, result);\n  \t\t\treturn result;\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tif (arguments[0] instanceof Envelope && hasInterface(arguments[1], List)) {\n  \t\t\t\tvar queryEnv = arguments[0],\n  \t\t\t\t    result = arguments[1];\n  \t\t\t\tthis.queryNode(this._root, queryEnv, true, {\n  \t\t\t\t\tinterfaces_: function interfaces_() {\n  \t\t\t\t\t\treturn [KdNodeVisitor];\n  \t\t\t\t\t},\n  \t\t\t\t\tvisit: function visit(node) {\n  \t\t\t\t\t\tresult.add(node);\n  \t\t\t\t\t}\n  \t\t\t\t});\n  \t\t\t} else if (arguments[0] instanceof Envelope && hasInterface(arguments[1], KdNodeVisitor)) {\n  \t\t\t\tvar queryEnv = arguments[0],\n  \t\t\t\t    visitor = arguments[1];\n  \t\t\t\tthis.queryNode(this._root, queryEnv, true, visitor);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tqueryNode: function queryNode(currentNode, queryEnv, odd, visitor) {\n  \t\tif (currentNode === null) return null;\n  \t\tvar min = null;\n  \t\tvar max = null;\n  \t\tvar discriminant = null;\n  \t\tif (odd) {\n  \t\t\tmin = queryEnv.getMinX();\n  \t\t\tmax = queryEnv.getMaxX();\n  \t\t\tdiscriminant = currentNode.getX();\n  \t\t} else {\n  \t\t\tmin = queryEnv.getMinY();\n  \t\t\tmax = queryEnv.getMaxY();\n  \t\t\tdiscriminant = currentNode.getY();\n  \t\t}\n  \t\tvar searchLeft = min < discriminant;\n  \t\tvar searchRight = discriminant <= max;\n  \t\tif (searchLeft) {\n  \t\t\tthis.queryNode(currentNode.getLeft(), queryEnv, !odd, visitor);\n  \t\t}\n  \t\tif (queryEnv.contains(currentNode.getCoordinate())) {\n  \t\t\tvisitor.visit(currentNode);\n  \t\t}\n  \t\tif (searchRight) {\n  \t\t\tthis.queryNode(currentNode.getRight(), queryEnv, !odd, visitor);\n  \t\t}\n  \t},\n  \tfindBestMatchNode: function findBestMatchNode(p) {\n  \t\tvar visitor = new BestMatchVisitor(p, this._tolerance);\n  \t\tthis.query(visitor.queryEnvelope(), visitor);\n  \t\treturn visitor.getNode();\n  \t},\n  \tisEmpty: function isEmpty() {\n  \t\tif (this._root === null) return true;\n  \t\treturn false;\n  \t},\n  \tinsertExact: function insertExact(p, data) {\n  \t\tvar currentNode = this._root;\n  \t\tvar leafNode = this._root;\n  \t\tvar isOddLevel = true;\n  \t\tvar isLessThan = true;\n  \t\twhile (currentNode !== null) {\n  \t\t\tif (currentNode !== null) {\n  \t\t\t\tvar isInTolerance = p.distance(currentNode.getCoordinate()) <= this._tolerance;\n  \t\t\t\tif (isInTolerance) {\n  \t\t\t\t\tcurrentNode.increment();\n  \t\t\t\t\treturn currentNode;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\tif (isOddLevel) {\n  \t\t\t\tisLessThan = p.x < currentNode.getX();\n  \t\t\t} else {\n  \t\t\t\tisLessThan = p.y < currentNode.getY();\n  \t\t\t}\n  \t\t\tleafNode = currentNode;\n  \t\t\tif (isLessThan) {\n  \t\t\t\tcurrentNode = currentNode.getLeft();\n  \t\t\t} else {\n  \t\t\t\tcurrentNode = currentNode.getRight();\n  \t\t\t}\n  \t\t\tisOddLevel = !isOddLevel;\n  \t\t}\n  \t\tthis._numberOfNodes = this._numberOfNodes + 1;\n  \t\tvar node = new KdNode(p, data);\n  \t\tif (isLessThan) {\n  \t\t\tleafNode.setLeft(node);\n  \t\t} else {\n  \t\t\tleafNode.setRight(node);\n  \t\t}\n  \t\treturn node;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn KdTree;\n  \t}\n  });\n  KdTree.toCoordinates = function () {\n  \tif (arguments.length === 1) {\n  \t\tvar kdnodes = arguments[0];\n  \t\treturn KdTree.toCoordinates(kdnodes, false);\n  \t} else if (arguments.length === 2) {\n  \t\tvar kdnodes = arguments[0],\n  \t\t    includeRepeated = arguments[1];\n  \t\tvar coord = new CoordinateList();\n  \t\tfor (var it = kdnodes.iterator(); it.hasNext();) {\n  \t\t\tvar node = it.next();\n  \t\t\tvar count = includeRepeated ? node.getCount() : 1;\n  \t\t\tfor (var i = 0; i < count; i++) {\n  \t\t\t\tcoord.add(node.getCoordinate(), true);\n  \t\t\t}\n  \t\t}\n  \t\treturn coord.toCoordinateArray();\n  \t}\n  };\n  function BestMatchVisitor() {\n  \tthis._tolerance = null;\n  \tthis._matchNode = null;\n  \tthis._matchDist = 0.0;\n  \tthis._p = null;\n  \tvar p = arguments[0],\n  \t    tolerance = arguments[1];\n  \tthis._p = p;\n  \tthis._tolerance = tolerance;\n  }\n  extend(BestMatchVisitor.prototype, {\n  \tvisit: function visit(node) {\n  \t\tvar dist = this._p.distance(node.getCoordinate());\n  \t\tvar isInTolerance = dist <= this._tolerance;\n  \t\tif (!isInTolerance) return null;\n  \t\tvar update = false;\n  \t\tif (this._matchNode === null || dist < this._matchDist || this._matchNode !== null && dist === this._matchDist && node.getCoordinate().compareTo(this._matchNode.getCoordinate()) < 1) update = true;\n  \t\tif (update) {\n  \t\t\tthis._matchNode = node;\n  \t\t\tthis._matchDist = dist;\n  \t\t}\n  \t},\n  \tqueryEnvelope: function queryEnvelope() {\n  \t\tvar queryEnv = new Envelope(this._p);\n  \t\tqueryEnv.expandBy(this._tolerance);\n  \t\treturn queryEnv;\n  \t},\n  \tgetNode: function getNode() {\n  \t\treturn this._matchNode;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [KdNodeVisitor];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn BestMatchVisitor;\n  \t}\n  });\n  KdTree.BestMatchVisitor = BestMatchVisitor;\n\n  function ConformingDelaunayTriangulator() {\n  \tthis._initialVertices = null;\n  \tthis._segVertices = null;\n  \tthis._segments = new ArrayList();\n  \tthis._subdiv = null;\n  \tthis._incDel = null;\n  \tthis._convexHull = null;\n  \tthis._splitFinder = new NonEncroachingSplitPointFinder();\n  \tthis._kdt = null;\n  \tthis._vertexFactory = null;\n  \tthis._computeAreaEnv = null;\n  \tthis._splitPt = null;\n  \tthis._tolerance = null;\n  \tvar initialVertices = arguments[0],\n  \t    tolerance = arguments[1];\n  \tthis._initialVertices = new ArrayList(initialVertices);\n  \tthis._tolerance = tolerance;\n  \tthis._kdt = new KdTree(tolerance);\n  }\n  extend(ConformingDelaunayTriangulator.prototype, {\n  \tgetInitialVertices: function getInitialVertices() {\n  \t\treturn this._initialVertices;\n  \t},\n  \tgetKDT: function getKDT() {\n  \t\treturn this._kdt;\n  \t},\n  \tenforceConstraints: function enforceConstraints() {\n  \t\tthis.addConstraintVertices();\n  \t\tvar count = 0;\n  \t\tvar splits = 0;\n  \t\tdo {\n  \t\t\tsplits = this.enforceGabriel(this._segments);\n  \t\t\tcount++;\n  \t\t} while (splits > 0 && count < ConformingDelaunayTriangulator.MAX_SPLIT_ITER);\n  \t},\n  \tinsertSites: function insertSites(vertices) {\n  \t\tfor (var i = vertices.iterator(); i.hasNext();) {\n  \t\t\tvar v = i.next();\n  \t\t\tthis.insertSite(v);\n  \t\t}\n  \t},\n  \tgetVertexFactory: function getVertexFactory() {\n  \t\treturn this._vertexFactory;\n  \t},\n  \tgetPointArray: function getPointArray() {\n  \t\tvar pts = new Array(this._initialVertices.size() + this._segVertices.size()).fill(null);\n  \t\tvar index = 0;\n  \t\tfor (var i = this._initialVertices.iterator(); i.hasNext();) {\n  \t\t\tvar v = i.next();\n  \t\t\tpts[index++] = v.getCoordinate();\n  \t\t}\n  \t\tfor (var i2 = this._segVertices.iterator(); i2.hasNext();) {\n  \t\t\tvar v = i2.next();\n  \t\t\tpts[index++] = v.getCoordinate();\n  \t\t}\n  \t\treturn pts;\n  \t},\n  \tsetConstraints: function setConstraints(segments, segVertices) {\n  \t\tthis._segments = segments;\n  \t\tthis._segVertices = segVertices;\n  \t},\n  \tcomputeConvexHull: function computeConvexHull() {\n  \t\tvar fact = new GeometryFactory();\n  \t\tvar coords = this.getPointArray();\n  \t\tvar hull = new ConvexHull(coords, fact);\n  \t\tthis._convexHull = hull.getConvexHull();\n  \t},\n  \taddConstraintVertices: function addConstraintVertices() {\n  \t\tthis.computeConvexHull();\n  \t\tthis.insertSites(this._segVertices);\n  \t},\n  \tfindNonGabrielPoint: function findNonGabrielPoint(seg) {\n  \t\tvar p = seg.getStart();\n  \t\tvar q = seg.getEnd();\n  \t\tvar midPt = new Coordinate((p.x + q.x) / 2.0, (p.y + q.y) / 2.0);\n  \t\tvar segRadius = p.distance(midPt);\n  \t\tvar env = new Envelope(midPt);\n  \t\tenv.expandBy(segRadius);\n  \t\tvar result = this._kdt.query(env);\n  \t\tvar closestNonGabriel = null;\n  \t\tvar minDist = Double.MAX_VALUE;\n  \t\tfor (var i = result.iterator(); i.hasNext();) {\n  \t\t\tvar nextNode = i.next();\n  \t\t\tvar testPt = nextNode.getCoordinate();\n  \t\t\tif (testPt.equals2D(p) || testPt.equals2D(q)) continue;\n  \t\t\tvar testRadius = midPt.distance(testPt);\n  \t\t\tif (testRadius < segRadius) {\n  \t\t\t\tvar testDist = testRadius;\n  \t\t\t\tif (closestNonGabriel === null || testDist < minDist) {\n  \t\t\t\t\tclosestNonGabriel = testPt;\n  \t\t\t\t\tminDist = testDist;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\treturn closestNonGabriel;\n  \t},\n  \tgetConstraintSegments: function getConstraintSegments() {\n  \t\treturn this._segments;\n  \t},\n  \tsetSplitPointFinder: function setSplitPointFinder(splitFinder) {\n  \t\tthis._splitFinder = splitFinder;\n  \t},\n  \tgetConvexHull: function getConvexHull() {\n  \t\treturn this._convexHull;\n  \t},\n  \tgetTolerance: function getTolerance() {\n  \t\treturn this._tolerance;\n  \t},\n  \tenforceGabriel: function enforceGabriel(segsToInsert) {\n  \t\tvar newSegments = new ArrayList();\n  \t\tvar splits = 0;\n  \t\tvar segsToRemove = new ArrayList();\n  \t\tfor (var i = segsToInsert.iterator(); i.hasNext();) {\n  \t\t\tvar seg = i.next();\n  \t\t\tvar encroachPt = this.findNonGabrielPoint(seg);\n  \t\t\tif (encroachPt === null) continue;\n  \t\t\tthis._splitPt = this._splitFinder.findSplitPoint(seg, encroachPt);\n  \t\t\tvar splitVertex = this.createVertex(this._splitPt, seg);\n  \t\t\tvar insertedVertex = this.insertSite(splitVertex);\n  \t\t\tvar s1 = new Segment(seg.getStartX(), seg.getStartY(), seg.getStartZ(), splitVertex.getX(), splitVertex.getY(), splitVertex.getZ(), seg.getData());\n  \t\t\tvar s2 = new Segment(splitVertex.getX(), splitVertex.getY(), splitVertex.getZ(), seg.getEndX(), seg.getEndY(), seg.getEndZ(), seg.getData());\n  \t\t\tnewSegments.add(s1);\n  \t\t\tnewSegments.add(s2);\n  \t\t\tsegsToRemove.add(seg);\n  \t\t\tsplits = splits + 1;\n  \t\t}\n  \t\tsegsToInsert.removeAll(segsToRemove);\n  \t\tsegsToInsert.addAll(newSegments);\n  \t\treturn splits;\n  \t},\n  \tcreateVertex: function createVertex() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar p = arguments[0];\n  \t\t\tvar v = null;\n  \t\t\tif (this._vertexFactory !== null) v = this._vertexFactory.createVertex(p, null);else v = new ConstraintVertex(p);\n  \t\t\treturn v;\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar p = arguments[0],\n  \t\t\t    seg = arguments[1];\n  \t\t\tvar v = null;\n  \t\t\tif (this._vertexFactory !== null) v = this._vertexFactory.createVertex(p, seg);else v = new ConstraintVertex(p);\n  \t\t\tv.setOnConstraint(true);\n  \t\t\treturn v;\n  \t\t}\n  \t},\n  \tgetSubdivision: function getSubdivision() {\n  \t\treturn this._subdiv;\n  \t},\n  \tcomputeBoundingBox: function computeBoundingBox() {\n  \t\tvar vertexEnv = ConformingDelaunayTriangulator.computeVertexEnvelope(this._initialVertices);\n  \t\tvar segEnv = ConformingDelaunayTriangulator.computeVertexEnvelope(this._segVertices);\n  \t\tvar allPointsEnv = new Envelope(vertexEnv);\n  \t\tallPointsEnv.expandToInclude(segEnv);\n  \t\tvar deltaX = allPointsEnv.getWidth() * 0.2;\n  \t\tvar deltaY = allPointsEnv.getHeight() * 0.2;\n  \t\tvar delta = Math.max(deltaX, deltaY);\n  \t\tthis._computeAreaEnv = new Envelope(allPointsEnv);\n  \t\tthis._computeAreaEnv.expandBy(delta);\n  \t},\n  \tsetVertexFactory: function setVertexFactory(vertexFactory) {\n  \t\tthis._vertexFactory = vertexFactory;\n  \t},\n  \tformInitialDelaunay: function formInitialDelaunay() {\n  \t\tthis.computeBoundingBox();\n  \t\tthis._subdiv = new QuadEdgeSubdivision(this._computeAreaEnv, this._tolerance);\n  \t\tthis._subdiv.setLocator(new LastFoundQuadEdgeLocator(this._subdiv));\n  \t\tthis._incDel = new IncrementalDelaunayTriangulator(this._subdiv);\n  \t\tthis.insertSites(this._initialVertices);\n  \t},\n  \tinsertSite: function insertSite() {\n  \t\tif (arguments[0] instanceof ConstraintVertex) {\n  \t\t\tvar v = arguments[0];\n  \t\t\tvar kdnode = this._kdt.insert(v.getCoordinate(), v);\n  \t\t\tif (!kdnode.isRepeated()) {\n  \t\t\t\tthis._incDel.insertSite(v);\n  \t\t\t} else {\n  \t\t\t\tvar snappedV = kdnode.getData();\n  \t\t\t\tsnappedV.merge(v);\n  \t\t\t\treturn snappedV;\n  \t\t\t}\n  \t\t\treturn v;\n  \t\t} else if (arguments[0] instanceof Coordinate) {\n  \t\t\tvar p = arguments[0];\n  \t\t\tthis.insertSite(this.createVertex(p));\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn ConformingDelaunayTriangulator;\n  \t}\n  });\n  ConformingDelaunayTriangulator.computeVertexEnvelope = function (vertices) {\n  \tvar env = new Envelope();\n  \tfor (var i = vertices.iterator(); i.hasNext();) {\n  \t\tvar v = i.next();\n  \t\tenv.expandToInclude(v.getCoordinate());\n  \t}\n  \treturn env;\n  };\n  ConformingDelaunayTriangulator.MAX_SPLIT_ITER = 99;\n\n  function DelaunayTriangulationBuilder() {\n  \tthis._siteCoords = null;\n  \tthis._tolerance = 0.0;\n  \tthis._subdiv = null;\n  }\n  extend(DelaunayTriangulationBuilder.prototype, {\n  \tcreate: function create() {\n  \t\tif (this._subdiv !== null) return null;\n  \t\tvar siteEnv = DelaunayTriangulationBuilder.envelope(this._siteCoords);\n  \t\tvar vertices = DelaunayTriangulationBuilder.toVertices(this._siteCoords);\n  \t\tthis._subdiv = new QuadEdgeSubdivision(siteEnv, this._tolerance);\n  \t\tvar triangulator = new IncrementalDelaunayTriangulator(this._subdiv);\n  \t\ttriangulator.insertSites(vertices);\n  \t},\n  \tsetTolerance: function setTolerance(tolerance) {\n  \t\tthis._tolerance = tolerance;\n  \t},\n  \tsetSites: function setSites() {\n  \t\tif (arguments[0] instanceof Geometry) {\n  \t\t\tvar geom = arguments[0];\n  \t\t\tthis._siteCoords = DelaunayTriangulationBuilder.extractUniqueCoordinates(geom);\n  \t\t} else if (hasInterface(arguments[0], Collection)) {\n  \t\t\tvar coords = arguments[0];\n  \t\t\tthis._siteCoords = DelaunayTriangulationBuilder.unique(CoordinateArrays.toCoordinateArray(coords));\n  \t\t}\n  \t},\n  \tgetEdges: function getEdges(geomFact) {\n  \t\tthis.create();\n  \t\treturn this._subdiv.getEdges(geomFact);\n  \t},\n  \tgetSubdivision: function getSubdivision() {\n  \t\tthis.create();\n  \t\treturn this._subdiv;\n  \t},\n  \tgetTriangles: function getTriangles(geomFact) {\n  \t\tthis.create();\n  \t\treturn this._subdiv.getTriangles(geomFact);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn DelaunayTriangulationBuilder;\n  \t}\n  });\n  DelaunayTriangulationBuilder.extractUniqueCoordinates = function (geom) {\n  \tif (geom === null) return new CoordinateList();\n  \tvar coords = geom.getCoordinates();\n  \treturn DelaunayTriangulationBuilder.unique(coords);\n  };\n  DelaunayTriangulationBuilder.envelope = function (coords) {\n  \tvar env = new Envelope();\n  \tfor (var i = coords.iterator(); i.hasNext();) {\n  \t\tvar coord = i.next();\n  \t\tenv.expandToInclude(coord);\n  \t}\n  \treturn env;\n  };\n  DelaunayTriangulationBuilder.unique = function (coords) {\n  \tvar coordsCopy = CoordinateArrays.copyDeep(coords);\n  \tArrays.sort(coordsCopy);\n  \tvar coordList = new CoordinateList(coordsCopy, false);\n  \treturn coordList;\n  };\n  DelaunayTriangulationBuilder.toVertices = function (coords) {\n  \tvar verts = new ArrayList();\n  \tfor (var i = coords.iterator(); i.hasNext();) {\n  \t\tvar coord = i.next();\n  \t\tverts.add(new Vertex(coord));\n  \t}\n  \treturn verts;\n  };\n\n  function ConformingDelaunayTriangulationBuilder() {\n  \tthis._siteCoords = null;\n  \tthis._constraintLines = null;\n  \tthis._tolerance = 0.0;\n  \tthis._subdiv = null;\n  \tthis._constraintVertexMap = new TreeMap();\n  }\n  extend(ConformingDelaunayTriangulationBuilder.prototype, {\n  \tcreateSiteVertices: function createSiteVertices(coords) {\n  \t\tvar verts = new ArrayList();\n  \t\tfor (var i = coords.iterator(); i.hasNext();) {\n  \t\t\tvar coord = i.next();\n  \t\t\tif (this._constraintVertexMap.containsKey(coord)) continue;\n  \t\t\tverts.add(new ConstraintVertex(coord));\n  \t\t}\n  \t\treturn verts;\n  \t},\n  \tcreate: function create() {\n  \t\tif (this._subdiv !== null) return null;\n  \t\tvar siteEnv = DelaunayTriangulationBuilder.envelope(this._siteCoords);\n  \t\tvar segments = new ArrayList();\n  \t\tif (this._constraintLines !== null) {\n  \t\t\tsiteEnv.expandToInclude(this._constraintLines.getEnvelopeInternal());\n  \t\t\tthis.createVertices(this._constraintLines);\n  \t\t\tsegments = ConformingDelaunayTriangulationBuilder.createConstraintSegments(this._constraintLines);\n  \t\t}\n  \t\tvar sites = this.createSiteVertices(this._siteCoords);\n  \t\tvar cdt = new ConformingDelaunayTriangulator(sites, this._tolerance);\n  \t\tcdt.setConstraints(segments, new ArrayList(this._constraintVertexMap.values()));\n  \t\tcdt.formInitialDelaunay();\n  \t\tcdt.enforceConstraints();\n  \t\tthis._subdiv = cdt.getSubdivision();\n  \t},\n  \tsetTolerance: function setTolerance(tolerance) {\n  \t\tthis._tolerance = tolerance;\n  \t},\n  \tsetConstraints: function setConstraints(constraintLines) {\n  \t\tthis._constraintLines = constraintLines;\n  \t},\n  \tsetSites: function setSites(geom) {\n  \t\tthis._siteCoords = DelaunayTriangulationBuilder.extractUniqueCoordinates(geom);\n  \t},\n  \tgetEdges: function getEdges(geomFact) {\n  \t\tthis.create();\n  \t\treturn this._subdiv.getEdges(geomFact);\n  \t},\n  \tgetSubdivision: function getSubdivision() {\n  \t\tthis.create();\n  \t\treturn this._subdiv;\n  \t},\n  \tgetTriangles: function getTriangles(geomFact) {\n  \t\tthis.create();\n  \t\treturn this._subdiv.getTriangles(geomFact);\n  \t},\n  \tcreateVertices: function createVertices(geom) {\n  \t\tvar coords = geom.getCoordinates();\n  \t\tfor (var i = 0; i < coords.length; i++) {\n  \t\t\tvar v = new ConstraintVertex(coords[i]);\n  \t\t\tthis._constraintVertexMap.put(coords[i], v);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn ConformingDelaunayTriangulationBuilder;\n  \t}\n  });\n  ConformingDelaunayTriangulationBuilder.createConstraintSegments = function () {\n  \tif (arguments.length === 1) {\n  \t\tvar geom = arguments[0];\n  \t\tvar lines = LinearComponentExtracter.getLines(geom);\n  \t\tvar constraintSegs = new ArrayList();\n  \t\tfor (var i = lines.iterator(); i.hasNext();) {\n  \t\t\tvar line = i.next();\n  \t\t\tConformingDelaunayTriangulationBuilder.createConstraintSegments(line, constraintSegs);\n  \t\t}\n  \t\treturn constraintSegs;\n  \t} else if (arguments.length === 2) {\n  \t\tvar line = arguments[0],\n  \t\t    constraintSegs = arguments[1];\n  \t\tvar coords = line.getCoordinates();\n  \t\tfor (var i = 1; i < coords.length; i++) {\n  \t\t\tconstraintSegs.add(new Segment(coords[i - 1], coords[i]));\n  \t\t}\n  \t}\n  };\n\n  function VoronoiDiagramBuilder() {\n  \tthis._siteCoords = null;\n  \tthis._tolerance = 0.0;\n  \tthis._subdiv = null;\n  \tthis._clipEnv = null;\n  \tthis._diagramEnv = null;\n  }\n  extend(VoronoiDiagramBuilder.prototype, {\n  \tcreate: function create() {\n  \t\tif (this._subdiv !== null) return null;\n  \t\tvar siteEnv = DelaunayTriangulationBuilder.envelope(this._siteCoords);\n  \t\tthis._diagramEnv = siteEnv;\n  \t\tvar expandBy = Math.max(this._diagramEnv.getWidth(), this._diagramEnv.getHeight());\n  \t\tthis._diagramEnv.expandBy(expandBy);\n  \t\tif (this._clipEnv !== null) this._diagramEnv.expandToInclude(this._clipEnv);\n  \t\tvar vertices = DelaunayTriangulationBuilder.toVertices(this._siteCoords);\n  \t\tthis._subdiv = new QuadEdgeSubdivision(siteEnv, this._tolerance);\n  \t\tvar triangulator = new IncrementalDelaunayTriangulator(this._subdiv);\n  \t\ttriangulator.insertSites(vertices);\n  \t},\n  \tgetDiagram: function getDiagram(geomFact) {\n  \t\tthis.create();\n  \t\tvar polys = this._subdiv.getVoronoiDiagram(geomFact);\n  \t\treturn VoronoiDiagramBuilder.clipGeometryCollection(polys, this._diagramEnv);\n  \t},\n  \tsetTolerance: function setTolerance(tolerance) {\n  \t\tthis._tolerance = tolerance;\n  \t},\n  \tsetSites: function setSites() {\n  \t\tif (arguments[0] instanceof Geometry) {\n  \t\t\tvar geom = arguments[0];\n  \t\t\tthis._siteCoords = DelaunayTriangulationBuilder.extractUniqueCoordinates(geom);\n  \t\t} else if (hasInterface(arguments[0], Collection)) {\n  \t\t\tvar coords = arguments[0];\n  \t\t\tthis._siteCoords = DelaunayTriangulationBuilder.unique(CoordinateArrays.toCoordinateArray(coords));\n  \t\t}\n  \t},\n  \tsetClipEnvelope: function setClipEnvelope(clipEnv) {\n  \t\tthis._clipEnv = clipEnv;\n  \t},\n  \tgetSubdivision: function getSubdivision() {\n  \t\tthis.create();\n  \t\treturn this._subdiv;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn VoronoiDiagramBuilder;\n  \t}\n  });\n  VoronoiDiagramBuilder.clipGeometryCollection = function (geom, clipEnv) {\n  \tvar clipPoly = geom.getFactory().toGeometry(clipEnv);\n  \tvar clipped = new ArrayList();\n  \tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n  \t\tvar g = geom.getGeometryN(i);\n  \t\tvar result = null;\n  \t\tif (clipEnv.contains(g.getEnvelopeInternal())) result = g;else if (clipEnv.intersects(g.getEnvelopeInternal())) {\n  \t\t\tresult = clipPoly.intersection(g);\n  \t\t\tresult.setUserData(g.getUserData());\n  \t\t}\n  \t\tif (result !== null && !result.isEmpty()) {\n  \t\t\tclipped.add(result);\n  \t\t}\n  \t}\n  \treturn geom.getFactory().createGeometryCollection(GeometryFactory.toGeometryArray(clipped));\n  };\n\n  function LinearLocation() {\n  \tthis._componentIndex = 0;\n  \tthis._segmentIndex = 0;\n  \tthis._segmentFraction = 0.0;\n  \tif (arguments.length === 0) ; else if (arguments.length === 1) {\n  \t\tvar loc = arguments[0];\n  \t\tthis._componentIndex = loc._componentIndex;\n  \t\tthis._segmentIndex = loc._segmentIndex;\n  \t\tthis._segmentFraction = loc._segmentFraction;\n  \t} else if (arguments.length === 2) {\n  \t\tvar segmentIndex = arguments[0],\n  \t\t    segmentFraction = arguments[1];\n  \t\tLinearLocation.call(this, 0, segmentIndex, segmentFraction);\n  \t} else if (arguments.length === 3) {\n  \t\tvar componentIndex = arguments[0],\n  \t\t    segmentIndex = arguments[1],\n  \t\t    segmentFraction = arguments[2];\n  \t\tthis._componentIndex = componentIndex;\n  \t\tthis._segmentIndex = segmentIndex;\n  \t\tthis._segmentFraction = segmentFraction;\n  \t\tthis.normalize();\n  \t} else if (arguments.length === 4) {\n  \t\tvar componentIndex = arguments[0],\n  \t\t    segmentIndex = arguments[1],\n  \t\t    segmentFraction = arguments[2],\n  \t\t    doNormalize = arguments[3];\n  \t\tthis._componentIndex = componentIndex;\n  \t\tthis._segmentIndex = segmentIndex;\n  \t\tthis._segmentFraction = segmentFraction;\n  \t\tif (doNormalize) this.normalize();\n  \t}\n  }\n  extend(LinearLocation.prototype, {\n  \tgetSegmentIndex: function getSegmentIndex() {\n  \t\treturn this._segmentIndex;\n  \t},\n  \tgetComponentIndex: function getComponentIndex() {\n  \t\treturn this._componentIndex;\n  \t},\n  \tisEndpoint: function isEndpoint(linearGeom) {\n  \t\tvar lineComp = linearGeom.getGeometryN(this._componentIndex);\n  \t\tvar nseg = lineComp.getNumPoints() - 1;\n  \t\treturn this._segmentIndex >= nseg || this._segmentIndex === nseg && this._segmentFraction >= 1.0;\n  \t},\n  \tisValid: function isValid(linearGeom) {\n  \t\tif (this._componentIndex < 0 || this._componentIndex >= linearGeom.getNumGeometries()) return false;\n  \t\tvar lineComp = linearGeom.getGeometryN(this._componentIndex);\n  \t\tif (this._segmentIndex < 0 || this._segmentIndex > lineComp.getNumPoints()) return false;\n  \t\tif (this._segmentIndex === lineComp.getNumPoints() && this._segmentFraction !== 0.0) return false;\n  \t\tif (this._segmentFraction < 0.0 || this._segmentFraction > 1.0) return false;\n  \t\treturn true;\n  \t},\n  \tnormalize: function normalize() {\n  \t\tif (this._segmentFraction < 0.0) {\n  \t\t\tthis._segmentFraction = 0.0;\n  \t\t}\n  \t\tif (this._segmentFraction > 1.0) {\n  \t\t\tthis._segmentFraction = 1.0;\n  \t\t}\n  \t\tif (this._componentIndex < 0) {\n  \t\t\tthis._componentIndex = 0;\n  \t\t\tthis._segmentIndex = 0;\n  \t\t\tthis._segmentFraction = 0.0;\n  \t\t}\n  \t\tif (this._segmentIndex < 0) {\n  \t\t\tthis._segmentIndex = 0;\n  \t\t\tthis._segmentFraction = 0.0;\n  \t\t}\n  \t\tif (this._segmentFraction === 1.0) {\n  \t\t\tthis._segmentFraction = 0.0;\n  \t\t\tthis._segmentIndex += 1;\n  \t\t}\n  \t},\n  \ttoLowest: function toLowest(linearGeom) {\n  \t\tvar lineComp = linearGeom.getGeometryN(this._componentIndex);\n  \t\tvar nseg = lineComp.getNumPoints() - 1;\n  \t\tif (this._segmentIndex < nseg) return this;\n  \t\treturn new LinearLocation(this._componentIndex, nseg, 1.0, false);\n  \t},\n  \tgetCoordinate: function getCoordinate(linearGeom) {\n  \t\tvar lineComp = linearGeom.getGeometryN(this._componentIndex);\n  \t\tvar p0 = lineComp.getCoordinateN(this._segmentIndex);\n  \t\tif (this._segmentIndex >= lineComp.getNumPoints() - 1) return p0;\n  \t\tvar p1 = lineComp.getCoordinateN(this._segmentIndex + 1);\n  \t\treturn LinearLocation.pointAlongSegmentByFraction(p0, p1, this._segmentFraction);\n  \t},\n  \tgetSegmentFraction: function getSegmentFraction() {\n  \t\treturn this._segmentFraction;\n  \t},\n  \tgetSegment: function getSegment(linearGeom) {\n  \t\tvar lineComp = linearGeom.getGeometryN(this._componentIndex);\n  \t\tvar p0 = lineComp.getCoordinateN(this._segmentIndex);\n  \t\tif (this._segmentIndex >= lineComp.getNumPoints() - 1) {\n  \t\t\tvar prev = lineComp.getCoordinateN(lineComp.getNumPoints() - 2);\n  \t\t\treturn new LineSegment(prev, p0);\n  \t\t}\n  \t\tvar p1 = lineComp.getCoordinateN(this._segmentIndex + 1);\n  \t\treturn new LineSegment(p0, p1);\n  \t},\n  \tclamp: function clamp(linear) {\n  \t\tif (this._componentIndex >= linear.getNumGeometries()) {\n  \t\t\tthis.setToEnd(linear);\n  \t\t\treturn null;\n  \t\t}\n  \t\tif (this._segmentIndex >= linear.getNumPoints()) {\n  \t\t\tvar line = linear.getGeometryN(this._componentIndex);\n  \t\t\tthis._segmentIndex = line.getNumPoints() - 1;\n  \t\t\tthis._segmentFraction = 1.0;\n  \t\t}\n  \t},\n  \tsetToEnd: function setToEnd(linear) {\n  \t\tthis._componentIndex = linear.getNumGeometries() - 1;\n  \t\tvar lastLine = linear.getGeometryN(this._componentIndex);\n  \t\tthis._segmentIndex = lastLine.getNumPoints() - 1;\n  \t\tthis._segmentFraction = 1.0;\n  \t},\n  \tcompareTo: function compareTo(o) {\n  \t\tvar other = o;\n  \t\tif (this._componentIndex < other._componentIndex) return -1;\n  \t\tif (this._componentIndex > other._componentIndex) return 1;\n  \t\tif (this._segmentIndex < other._segmentIndex) return -1;\n  \t\tif (this._segmentIndex > other._segmentIndex) return 1;\n  \t\tif (this._segmentFraction < other._segmentFraction) return -1;\n  \t\tif (this._segmentFraction > other._segmentFraction) return 1;\n  \t\treturn 0;\n  \t},\n  \tclone: function clone() {\n  \t\treturn new LinearLocation(this._componentIndex, this._segmentIndex, this._segmentFraction);\n  \t},\n  \ttoString: function toString() {\n  \t\treturn \"LinearLoc[\" + this._componentIndex + \", \" + this._segmentIndex + \", \" + this._segmentFraction + \"]\";\n  \t},\n  \tisOnSameSegment: function isOnSameSegment(loc) {\n  \t\tif (this._componentIndex !== loc._componentIndex) return false;\n  \t\tif (this._segmentIndex === loc._segmentIndex) return true;\n  \t\tif (loc._segmentIndex - this._segmentIndex === 1 && loc._segmentFraction === 0.0) return true;\n  \t\tif (this._segmentIndex - loc._segmentIndex === 1 && this._segmentFraction === 0.0) return true;\n  \t\treturn false;\n  \t},\n  \tsnapToVertex: function snapToVertex(linearGeom, minDistance) {\n  \t\tif (this._segmentFraction <= 0.0 || this._segmentFraction >= 1.0) return null;\n  \t\tvar segLen = this.getSegmentLength(linearGeom);\n  \t\tvar lenToStart = this._segmentFraction * segLen;\n  \t\tvar lenToEnd = segLen - lenToStart;\n  \t\tif (lenToStart <= lenToEnd && lenToStart < minDistance) {\n  \t\t\tthis._segmentFraction = 0.0;\n  \t\t} else if (lenToEnd <= lenToStart && lenToEnd < minDistance) {\n  \t\t\tthis._segmentFraction = 1.0;\n  \t\t}\n  \t},\n  \tcompareLocationValues: function compareLocationValues(componentIndex1, segmentIndex1, segmentFraction1) {\n  \t\tif (this._componentIndex < componentIndex1) return -1;\n  \t\tif (this._componentIndex > componentIndex1) return 1;\n  \t\tif (this._segmentIndex < segmentIndex1) return -1;\n  \t\tif (this._segmentIndex > segmentIndex1) return 1;\n  \t\tif (this._segmentFraction < segmentFraction1) return -1;\n  \t\tif (this._segmentFraction > segmentFraction1) return 1;\n  \t\treturn 0;\n  \t},\n  \tgetSegmentLength: function getSegmentLength(linearGeom) {\n  \t\tvar lineComp = linearGeom.getGeometryN(this._componentIndex);\n  \t\tvar segIndex = this._segmentIndex;\n  \t\tif (this._segmentIndex >= lineComp.getNumPoints() - 1) segIndex = lineComp.getNumPoints() - 2;\n  \t\tvar p0 = lineComp.getCoordinateN(segIndex);\n  \t\tvar p1 = lineComp.getCoordinateN(segIndex + 1);\n  \t\treturn p0.distance(p1);\n  \t},\n  \tisVertex: function isVertex() {\n  \t\treturn this._segmentFraction <= 0.0 || this._segmentFraction >= 1.0;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LinearLocation;\n  \t}\n  });\n  LinearLocation.getEndLocation = function (linear) {\n  \tvar loc = new LinearLocation();\n  \tloc.setToEnd(linear);\n  \treturn loc;\n  };\n  LinearLocation.pointAlongSegmentByFraction = function (p0, p1, frac) {\n  \tif (frac <= 0.0) return p0;\n  \tif (frac >= 1.0) return p1;\n  \tvar x = (p1.x - p0.x) * frac + p0.x;\n  \tvar y = (p1.y - p0.y) * frac + p0.y;\n  \tvar z = (p1.z - p0.z) * frac + p0.z;\n  \treturn new Coordinate(x, y, z);\n  };\n  LinearLocation.compareLocationValues = function (componentIndex0, segmentIndex0, segmentFraction0, componentIndex1, segmentIndex1, segmentFraction1) {\n  \tif (componentIndex0 < componentIndex1) return -1;\n  \tif (componentIndex0 > componentIndex1) return 1;\n  \tif (segmentIndex0 < segmentIndex1) return -1;\n  \tif (segmentIndex0 > segmentIndex1) return 1;\n  \tif (segmentFraction0 < segmentFraction1) return -1;\n  \tif (segmentFraction0 > segmentFraction1) return 1;\n  \treturn 0;\n  };\n\n  function LinearIterator() {\n  \tthis._linearGeom = null;\n  \tthis._numLines = null;\n  \tthis._currentLine = null;\n  \tthis._componentIndex = 0;\n  \tthis._vertexIndex = 0;\n  \tif (arguments.length === 1) {\n  \t\tvar linear = arguments[0];\n  \t\tLinearIterator.call(this, linear, 0, 0);\n  \t} else if (arguments.length === 2) {\n  \t\tvar linear = arguments[0],\n  \t\t    start = arguments[1];\n  \t\tLinearIterator.call(this, linear, start.getComponentIndex(), LinearIterator.segmentEndVertexIndex(start));\n  \t} else if (arguments.length === 3) {\n  \t\tvar linearGeom = arguments[0],\n  \t\t    componentIndex = arguments[1],\n  \t\t    vertexIndex = arguments[2];\n  \t\tif (!hasInterface(linearGeom, Lineal)) throw new IllegalArgumentException(\"Lineal geometry is required\");\n  \t\tthis._linearGeom = linearGeom;\n  \t\tthis._numLines = linearGeom.getNumGeometries();\n  \t\tthis._componentIndex = componentIndex;\n  \t\tthis._vertexIndex = vertexIndex;\n  \t\tthis.loadCurrentLine();\n  \t}\n  }\n  extend(LinearIterator.prototype, {\n  \tgetComponentIndex: function getComponentIndex() {\n  \t\treturn this._componentIndex;\n  \t},\n  \tgetLine: function getLine() {\n  \t\treturn this._currentLine;\n  \t},\n  \tgetVertexIndex: function getVertexIndex() {\n  \t\treturn this._vertexIndex;\n  \t},\n  \tgetSegmentEnd: function getSegmentEnd() {\n  \t\tif (this._vertexIndex < this.getLine().getNumPoints() - 1) return this._currentLine.getCoordinateN(this._vertexIndex + 1);\n  \t\treturn null;\n  \t},\n  \tnext: function next() {\n  \t\tif (!this.hasNext()) return null;\n  \t\tthis._vertexIndex++;\n  \t\tif (this._vertexIndex >= this._currentLine.getNumPoints()) {\n  \t\t\tthis._componentIndex++;\n  \t\t\tthis.loadCurrentLine();\n  \t\t\tthis._vertexIndex = 0;\n  \t\t}\n  \t},\n  \tloadCurrentLine: function loadCurrentLine() {\n  \t\tif (this._componentIndex >= this._numLines) {\n  \t\t\tthis._currentLine = null;\n  \t\t\treturn null;\n  \t\t}\n  \t\tthis._currentLine = this._linearGeom.getGeometryN(this._componentIndex);\n  \t},\n  \tgetSegmentStart: function getSegmentStart() {\n  \t\treturn this._currentLine.getCoordinateN(this._vertexIndex);\n  \t},\n  \tisEndOfLine: function isEndOfLine() {\n  \t\tif (this._componentIndex >= this._numLines) return false;\n  \t\tif (this._vertexIndex < this._currentLine.getNumPoints() - 1) return false;\n  \t\treturn true;\n  \t},\n  \thasNext: function hasNext() {\n  \t\tif (this._componentIndex >= this._numLines) return false;\n  \t\tif (this._componentIndex === this._numLines - 1 && this._vertexIndex >= this._currentLine.getNumPoints()) return false;\n  \t\treturn true;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LinearIterator;\n  \t}\n  });\n  LinearIterator.segmentEndVertexIndex = function (loc) {\n  \tif (loc.getSegmentFraction() > 0.0) return loc.getSegmentIndex() + 1;\n  \treturn loc.getSegmentIndex();\n  };\n\n  function LocationIndexOfPoint() {\n  \tthis._linearGeom = null;\n  \tvar linearGeom = arguments[0];\n  \tthis._linearGeom = linearGeom;\n  }\n  extend(LocationIndexOfPoint.prototype, {\n  \tindexOf: function indexOf(inputPt) {\n  \t\treturn this.indexOfFromStart(inputPt, null);\n  \t},\n  \tindexOfFromStart: function indexOfFromStart(inputPt, minIndex) {\n  \t\tvar minDistance = Double.MAX_VALUE;\n  \t\tvar minComponentIndex = 0;\n  \t\tvar minSegmentIndex = 0;\n  \t\tvar minFrac = -1.0;\n  \t\tvar seg = new LineSegment();\n  \t\tfor (var it = new LinearIterator(this._linearGeom); it.hasNext(); it.next()) {\n  \t\t\tif (!it.isEndOfLine()) {\n  \t\t\t\tseg.p0 = it.getSegmentStart();\n  \t\t\t\tseg.p1 = it.getSegmentEnd();\n  \t\t\t\tvar segDistance = seg.distance(inputPt);\n  \t\t\t\tvar segFrac = seg.segmentFraction(inputPt);\n  \t\t\t\tvar candidateComponentIndex = it.getComponentIndex();\n  \t\t\t\tvar candidateSegmentIndex = it.getVertexIndex();\n  \t\t\t\tif (segDistance < minDistance) {\n  \t\t\t\t\tif (minIndex === null || minIndex.compareLocationValues(candidateComponentIndex, candidateSegmentIndex, segFrac) < 0) {\n  \t\t\t\t\t\tminComponentIndex = candidateComponentIndex;\n  \t\t\t\t\t\tminSegmentIndex = candidateSegmentIndex;\n  \t\t\t\t\t\tminFrac = segFrac;\n  \t\t\t\t\t\tminDistance = segDistance;\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\tif (minDistance === Double.MAX_VALUE) {\n  \t\t\treturn new LinearLocation(minIndex);\n  \t\t}\n  \t\tvar loc = new LinearLocation(minComponentIndex, minSegmentIndex, minFrac);\n  \t\treturn loc;\n  \t},\n  \tindexOfAfter: function indexOfAfter(inputPt, minIndex) {\n  \t\tif (minIndex === null) return this.indexOf(inputPt);\n  \t\tvar endLoc = LinearLocation.getEndLocation(this._linearGeom);\n  \t\tif (endLoc.compareTo(minIndex) <= 0) return endLoc;\n  \t\tvar closestAfter = this.indexOfFromStart(inputPt, minIndex);\n  \t\tAssert.isTrue(closestAfter.compareTo(minIndex) >= 0, \"computed location is before specified minimum location\");\n  \t\treturn closestAfter;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LocationIndexOfPoint;\n  \t}\n  });\n  LocationIndexOfPoint.indexOf = function (linearGeom, inputPt) {\n  \tvar locater = new LocationIndexOfPoint(linearGeom);\n  \treturn locater.indexOf(inputPt);\n  };\n  LocationIndexOfPoint.indexOfAfter = function (linearGeom, inputPt, minIndex) {\n  \tvar locater = new LocationIndexOfPoint(linearGeom);\n  \treturn locater.indexOfAfter(inputPt, minIndex);\n  };\n\n  function LocationIndexOfLine() {\n  \tthis._linearGeom = null;\n  \tvar linearGeom = arguments[0];\n  \tthis._linearGeom = linearGeom;\n  }\n  extend(LocationIndexOfLine.prototype, {\n  \tindicesOf: function indicesOf(subLine) {\n  \t\tvar startPt = subLine.getGeometryN(0).getCoordinateN(0);\n  \t\tvar lastLine = subLine.getGeometryN(subLine.getNumGeometries() - 1);\n  \t\tvar endPt = lastLine.getCoordinateN(lastLine.getNumPoints() - 1);\n  \t\tvar locPt = new LocationIndexOfPoint(this._linearGeom);\n  \t\tvar subLineLoc = new Array(2).fill(null);\n  \t\tsubLineLoc[0] = locPt.indexOf(startPt);\n  \t\tif (subLine.getLength() === 0.0) {\n  \t\t\tsubLineLoc[1] = subLineLoc[0].clone();\n  \t\t} else {\n  \t\t\tsubLineLoc[1] = locPt.indexOfAfter(endPt, subLineLoc[0]);\n  \t\t}\n  \t\treturn subLineLoc;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LocationIndexOfLine;\n  \t}\n  });\n  LocationIndexOfLine.indicesOf = function (linearGeom, subLine) {\n  \tvar locater = new LocationIndexOfLine(linearGeom);\n  \treturn locater.indicesOf(subLine);\n  };\n\n  function LinearGeometryBuilder() {\n  \tthis._geomFact = null;\n  \tthis._lines = new ArrayList();\n  \tthis._coordList = null;\n  \tthis._ignoreInvalidLines = false;\n  \tthis._fixInvalidLines = false;\n  \tthis._lastPt = null;\n  \tvar geomFact = arguments[0];\n  \tthis._geomFact = geomFact;\n  }\n  extend(LinearGeometryBuilder.prototype, {\n  \tgetGeometry: function getGeometry() {\n  \t\tthis.endLine();\n  \t\treturn this._geomFact.buildGeometry(this._lines);\n  \t},\n  \tgetLastCoordinate: function getLastCoordinate() {\n  \t\treturn this._lastPt;\n  \t},\n  \tendLine: function endLine() {\n  \t\tif (this._coordList === null) {\n  \t\t\treturn null;\n  \t\t}\n  \t\tif (this._ignoreInvalidLines && this._coordList.size() < 2) {\n  \t\t\tthis._coordList = null;\n  \t\t\treturn null;\n  \t\t}\n  \t\tvar rawPts = this._coordList.toCoordinateArray();\n  \t\tvar pts = rawPts;\n  \t\tif (this._fixInvalidLines) pts = this.validCoordinateSequence(rawPts);\n  \t\tthis._coordList = null;\n  \t\tvar line = null;\n  \t\ttry {\n  \t\t\tline = this._geomFact.createLineString(pts);\n  \t\t} catch (ex) {\n  \t\t\tif (ex instanceof IllegalArgumentException) {\n  \t\t\t\tif (!this._ignoreInvalidLines) throw ex;\n  \t\t\t} else throw ex;\n  \t\t} finally {}\n  \t\tif (line !== null) this._lines.add(line);\n  \t},\n  \tsetFixInvalidLines: function setFixInvalidLines(fixInvalidLines) {\n  \t\tthis._fixInvalidLines = fixInvalidLines;\n  \t},\n  \tadd: function add() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar pt = arguments[0];\n  \t\t\tthis.add(pt, true);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar pt = arguments[0],\n  \t\t\t    allowRepeatedPoints = arguments[1];\n  \t\t\tif (this._coordList === null) this._coordList = new CoordinateList();\n  \t\t\tthis._coordList.add(pt, allowRepeatedPoints);\n  \t\t\tthis._lastPt = pt;\n  \t\t}\n  \t},\n  \tsetIgnoreInvalidLines: function setIgnoreInvalidLines(ignoreInvalidLines) {\n  \t\tthis._ignoreInvalidLines = ignoreInvalidLines;\n  \t},\n  \tvalidCoordinateSequence: function validCoordinateSequence(pts) {\n  \t\tif (pts.length >= 2) return pts;\n  \t\tvar validPts = [pts[0], pts[0]];\n  \t\treturn validPts;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LinearGeometryBuilder;\n  \t}\n  });\n\n  function ExtractLineByLocation() {\n  \tthis._line = null;\n  \tvar line = arguments[0];\n  \tthis._line = line;\n  }\n  extend(ExtractLineByLocation.prototype, {\n  \tcomputeLinear: function computeLinear(start, end) {\n  \t\tvar builder = new LinearGeometryBuilder(this._line.getFactory());\n  \t\tbuilder.setFixInvalidLines(true);\n  \t\tif (!start.isVertex()) builder.add(start.getCoordinate(this._line));\n  \t\tfor (var it = new LinearIterator(this._line, start); it.hasNext(); it.next()) {\n  \t\t\tif (end.compareLocationValues(it.getComponentIndex(), it.getVertexIndex(), 0.0) < 0) break;\n  \t\t\tvar pt = it.getSegmentStart();\n  \t\t\tbuilder.add(pt);\n  \t\t\tif (it.isEndOfLine()) builder.endLine();\n  \t\t}\n  \t\tif (!end.isVertex()) builder.add(end.getCoordinate(this._line));\n  \t\treturn builder.getGeometry();\n  \t},\n  \tcomputeLine: function computeLine(start, end) {\n  \t\tvar coordinates = this._line.getCoordinates();\n  \t\tvar newCoordinates = new CoordinateList();\n  \t\tvar startSegmentIndex = start.getSegmentIndex();\n  \t\tif (start.getSegmentFraction() > 0.0) startSegmentIndex += 1;\n  \t\tvar lastSegmentIndex = end.getSegmentIndex();\n  \t\tif (end.getSegmentFraction() === 1.0) lastSegmentIndex += 1;\n  \t\tif (lastSegmentIndex >= coordinates.length) lastSegmentIndex = coordinates.length - 1;\n  \t\tif (!start.isVertex()) newCoordinates.add(start.getCoordinate(this._line));\n  \t\tfor (var i = startSegmentIndex; i <= lastSegmentIndex; i++) {\n  \t\t\tnewCoordinates.add(coordinates[i]);\n  \t\t}\n  \t\tif (!end.isVertex()) newCoordinates.add(end.getCoordinate(this._line));\n  \t\tif (newCoordinates.size() <= 0) newCoordinates.add(start.getCoordinate(this._line));\n  \t\tvar newCoordinateArray = newCoordinates.toCoordinateArray();\n  \t\tif (newCoordinateArray.length <= 1) {\n  \t\t\tnewCoordinateArray = [newCoordinateArray[0], newCoordinateArray[0]];\n  \t\t}\n  \t\treturn this._line.getFactory().createLineString(newCoordinateArray);\n  \t},\n  \textract: function extract(start, end) {\n  \t\tif (end.compareTo(start) < 0) {\n  \t\t\treturn this.reverse(this.computeLinear(end, start));\n  \t\t}\n  \t\treturn this.computeLinear(start, end);\n  \t},\n  \treverse: function reverse(linear) {\n  \t\tif (linear instanceof LineString) return linear.reverse();\n  \t\tif (linear instanceof MultiLineString) return linear.reverse();\n  \t\tAssert.shouldNeverReachHere(\"non-linear geometry encountered\");\n  \t\treturn null;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn ExtractLineByLocation;\n  \t}\n  });\n  ExtractLineByLocation.extract = function (line, start, end) {\n  \tvar ls = new ExtractLineByLocation(line);\n  \treturn ls.extract(start, end);\n  };\n\n  function LocationIndexedLine() {\n  \tthis._linearGeom = null;\n  \tvar linearGeom = arguments[0];\n  \tthis._linearGeom = linearGeom;\n  \tthis.checkGeometryType();\n  }\n  extend(LocationIndexedLine.prototype, {\n  \tclampIndex: function clampIndex(index) {\n  \t\tvar loc = index.clone();\n  \t\tloc.clamp(this._linearGeom);\n  \t\treturn loc;\n  \t},\n  \tproject: function project(pt) {\n  \t\treturn LocationIndexOfPoint.indexOf(this._linearGeom, pt);\n  \t},\n  \tcheckGeometryType: function checkGeometryType() {\n  \t\tif (!(this._linearGeom instanceof LineString || this._linearGeom instanceof MultiLineString)) throw new IllegalArgumentException(\"Input geometry must be linear\");\n  \t},\n  \textractPoint: function extractPoint() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar index = arguments[0];\n  \t\t\treturn index.getCoordinate(this._linearGeom);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar index = arguments[0],\n  \t\t\t    offsetDistance = arguments[1];\n  \t\t\tvar indexLow = index.toLowest(this._linearGeom);\n  \t\t\treturn indexLow.getSegment(this._linearGeom).pointAlongOffset(indexLow.getSegmentFraction(), offsetDistance);\n  \t\t}\n  \t},\n  \tisValidIndex: function isValidIndex(index) {\n  \t\treturn index.isValid(this._linearGeom);\n  \t},\n  \tgetEndIndex: function getEndIndex() {\n  \t\treturn LinearLocation.getEndLocation(this._linearGeom);\n  \t},\n  \tgetStartIndex: function getStartIndex() {\n  \t\treturn new LinearLocation();\n  \t},\n  \tindexOfAfter: function indexOfAfter(pt, minIndex) {\n  \t\treturn LocationIndexOfPoint.indexOfAfter(this._linearGeom, pt, minIndex);\n  \t},\n  \textractLine: function extractLine(startIndex, endIndex) {\n  \t\treturn ExtractLineByLocation.extract(this._linearGeom, startIndex, endIndex);\n  \t},\n  \tindexOf: function indexOf(pt) {\n  \t\treturn LocationIndexOfPoint.indexOf(this._linearGeom, pt);\n  \t},\n  \tindicesOf: function indicesOf(subLine) {\n  \t\treturn LocationIndexOfLine.indicesOf(this._linearGeom, subLine);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LocationIndexedLine;\n  \t}\n  });\n\n  function LengthIndexOfPoint() {\n  \tthis._linearGeom = null;\n  \tvar linearGeom = arguments[0];\n  \tthis._linearGeom = linearGeom;\n  }\n  extend(LengthIndexOfPoint.prototype, {\n  \tindexOf: function indexOf(inputPt) {\n  \t\treturn this.indexOfFromStart(inputPt, -1.0);\n  \t},\n  \tindexOfFromStart: function indexOfFromStart(inputPt, minIndex) {\n  \t\tvar minDistance = Double.MAX_VALUE;\n  \t\tvar ptMeasure = minIndex;\n  \t\tvar segmentStartMeasure = 0.0;\n  \t\tvar seg = new LineSegment();\n  \t\tvar it = new LinearIterator(this._linearGeom);\n  \t\twhile (it.hasNext()) {\n  \t\t\tif (!it.isEndOfLine()) {\n  \t\t\t\tseg.p0 = it.getSegmentStart();\n  \t\t\t\tseg.p1 = it.getSegmentEnd();\n  \t\t\t\tvar segDistance = seg.distance(inputPt);\n  \t\t\t\tvar segMeasureToPt = this.segmentNearestMeasure(seg, inputPt, segmentStartMeasure);\n  \t\t\t\tif (segDistance < minDistance && segMeasureToPt > minIndex) {\n  \t\t\t\t\tptMeasure = segMeasureToPt;\n  \t\t\t\t\tminDistance = segDistance;\n  \t\t\t\t}\n  \t\t\t\tsegmentStartMeasure += seg.getLength();\n  \t\t\t}\n  \t\t\tit.next();\n  \t\t}\n  \t\treturn ptMeasure;\n  \t},\n  \tindexOfAfter: function indexOfAfter(inputPt, minIndex) {\n  \t\tif (minIndex < 0.0) return this.indexOf(inputPt);\n  \t\tvar endIndex = this._linearGeom.getLength();\n  \t\tif (endIndex < minIndex) return endIndex;\n  \t\tvar closestAfter = this.indexOfFromStart(inputPt, minIndex);\n  \t\tAssert.isTrue(closestAfter >= minIndex, \"computed index is before specified minimum index\");\n  \t\treturn closestAfter;\n  \t},\n  \tsegmentNearestMeasure: function segmentNearestMeasure(seg, inputPt, segmentStartMeasure) {\n  \t\tvar projFactor = seg.projectionFactor(inputPt);\n  \t\tif (projFactor <= 0.0) return segmentStartMeasure;\n  \t\tif (projFactor <= 1.0) return segmentStartMeasure + projFactor * seg.getLength();\n  \t\treturn segmentStartMeasure + seg.getLength();\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LengthIndexOfPoint;\n  \t}\n  });\n  LengthIndexOfPoint.indexOf = function (linearGeom, inputPt) {\n  \tvar locater = new LengthIndexOfPoint(linearGeom);\n  \treturn locater.indexOf(inputPt);\n  };\n  LengthIndexOfPoint.indexOfAfter = function (linearGeom, inputPt, minIndex) {\n  \tvar locater = new LengthIndexOfPoint(linearGeom);\n  \treturn locater.indexOfAfter(inputPt, minIndex);\n  };\n\n  function LengthLocationMap() {\n  \tthis._linearGeom = null;\n  \tvar linearGeom = arguments[0];\n  \tthis._linearGeom = linearGeom;\n  }\n  extend(LengthLocationMap.prototype, {\n  \tgetLength: function getLength(loc) {\n  \t\tvar totalLength = 0.0;\n  \t\tvar it = new LinearIterator(this._linearGeom);\n  \t\twhile (it.hasNext()) {\n  \t\t\tif (!it.isEndOfLine()) {\n  \t\t\t\tvar p0 = it.getSegmentStart();\n  \t\t\t\tvar p1 = it.getSegmentEnd();\n  \t\t\t\tvar segLen = p1.distance(p0);\n  \t\t\t\tif (loc.getComponentIndex() === it.getComponentIndex() && loc.getSegmentIndex() === it.getVertexIndex()) {\n  \t\t\t\t\treturn totalLength + segLen * loc.getSegmentFraction();\n  \t\t\t\t}\n  \t\t\t\ttotalLength += segLen;\n  \t\t\t}\n  \t\t\tit.next();\n  \t\t}\n  \t\treturn totalLength;\n  \t},\n  \tresolveHigher: function resolveHigher(loc) {\n  \t\tif (!loc.isEndpoint(this._linearGeom)) return loc;\n  \t\tvar compIndex = loc.getComponentIndex();\n  \t\tif (compIndex >= this._linearGeom.getNumGeometries() - 1) return loc;\n  \t\tdo {\n  \t\t\tcompIndex++;\n  \t\t} while (compIndex < this._linearGeom.getNumGeometries() - 1 && this._linearGeom.getGeometryN(compIndex).getLength() === 0);\n  \t\treturn new LinearLocation(compIndex, 0, 0.0);\n  \t},\n  \tgetLocation: function getLocation() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar length = arguments[0];\n  \t\t\treturn this.getLocation(length, true);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar length = arguments[0],\n  \t\t\t    resolveLower = arguments[1];\n  \t\t\tvar forwardLength = length;\n  \t\t\tif (length < 0.0) {\n  \t\t\t\tvar lineLen = this._linearGeom.getLength();\n  \t\t\t\tforwardLength = lineLen + length;\n  \t\t\t}\n  \t\t\tvar loc = this.getLocationForward(forwardLength);\n  \t\t\tif (resolveLower) {\n  \t\t\t\treturn loc;\n  \t\t\t}\n  \t\t\treturn this.resolveHigher(loc);\n  \t\t}\n  \t},\n  \tgetLocationForward: function getLocationForward(length) {\n  \t\tif (length <= 0.0) return new LinearLocation();\n  \t\tvar totalLength = 0.0;\n  \t\tvar it = new LinearIterator(this._linearGeom);\n  \t\twhile (it.hasNext()) {\n  \t\t\tif (it.isEndOfLine()) {\n  \t\t\t\tif (totalLength === length) {\n  \t\t\t\t\tvar compIndex = it.getComponentIndex();\n  \t\t\t\t\tvar segIndex = it.getVertexIndex();\n  \t\t\t\t\treturn new LinearLocation(compIndex, segIndex, 0.0);\n  \t\t\t\t}\n  \t\t\t} else {\n  \t\t\t\tvar p0 = it.getSegmentStart();\n  \t\t\t\tvar p1 = it.getSegmentEnd();\n  \t\t\t\tvar segLen = p1.distance(p0);\n  \t\t\t\tif (totalLength + segLen > length) {\n  \t\t\t\t\tvar frac = (length - totalLength) / segLen;\n  \t\t\t\t\tvar compIndex = it.getComponentIndex();\n  \t\t\t\t\tvar segIndex = it.getVertexIndex();\n  \t\t\t\t\treturn new LinearLocation(compIndex, segIndex, frac);\n  \t\t\t\t}\n  \t\t\t\ttotalLength += segLen;\n  \t\t\t}\n  \t\t\tit.next();\n  \t\t}\n  \t\treturn LinearLocation.getEndLocation(this._linearGeom);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LengthLocationMap;\n  \t}\n  });\n  LengthLocationMap.getLength = function (linearGeom, loc) {\n  \tvar locater = new LengthLocationMap(linearGeom);\n  \treturn locater.getLength(loc);\n  };\n  LengthLocationMap.getLocation = function () {\n  \tif (arguments.length === 2) {\n  \t\tvar linearGeom = arguments[0],\n  \t\t    length = arguments[1];\n  \t\tvar locater = new LengthLocationMap(linearGeom);\n  \t\treturn locater.getLocation(length);\n  \t} else if (arguments.length === 3) {\n  \t\tvar linearGeom = arguments[0],\n  \t\t    length = arguments[1],\n  \t\t    resolveLower = arguments[2];\n  \t\tvar locater = new LengthLocationMap(linearGeom);\n  \t\treturn locater.getLocation(length, resolveLower);\n  \t}\n  };\n\n  function LengthIndexedLine() {\n  \tthis._linearGeom = null;\n  \tvar linearGeom = arguments[0];\n  \tthis._linearGeom = linearGeom;\n  }\n  extend(LengthIndexedLine.prototype, {\n  \tclampIndex: function clampIndex(index) {\n  \t\tvar posIndex = this.positiveIndex(index);\n  \t\tvar startIndex = this.getStartIndex();\n  \t\tif (posIndex < startIndex) return startIndex;\n  \t\tvar endIndex = this.getEndIndex();\n  \t\tif (posIndex > endIndex) return endIndex;\n  \t\treturn posIndex;\n  \t},\n  \tlocationOf: function locationOf() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar index = arguments[0];\n  \t\t\treturn LengthLocationMap.getLocation(this._linearGeom, index);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar index = arguments[0],\n  \t\t\t    resolveLower = arguments[1];\n  \t\t\treturn LengthLocationMap.getLocation(this._linearGeom, index, resolveLower);\n  \t\t}\n  \t},\n  \tproject: function project(pt) {\n  \t\treturn LengthIndexOfPoint.indexOf(this._linearGeom, pt);\n  \t},\n  \tpositiveIndex: function positiveIndex(index) {\n  \t\tif (index >= 0.0) return index;\n  \t\treturn this._linearGeom.getLength() + index;\n  \t},\n  \textractPoint: function extractPoint() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar index = arguments[0];\n  \t\t\tvar loc = LengthLocationMap.getLocation(this._linearGeom, index);\n  \t\t\treturn loc.getCoordinate(this._linearGeom);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar index = arguments[0],\n  \t\t\t    offsetDistance = arguments[1];\n  \t\t\tvar loc = LengthLocationMap.getLocation(this._linearGeom, index);\n  \t\t\tvar locLow = loc.toLowest(this._linearGeom);\n  \t\t\treturn locLow.getSegment(this._linearGeom).pointAlongOffset(locLow.getSegmentFraction(), offsetDistance);\n  \t\t}\n  \t},\n  \tisValidIndex: function isValidIndex(index) {\n  \t\treturn index >= this.getStartIndex() && index <= this.getEndIndex();\n  \t},\n  \tgetEndIndex: function getEndIndex() {\n  \t\treturn this._linearGeom.getLength();\n  \t},\n  \tgetStartIndex: function getStartIndex() {\n  \t\treturn 0.0;\n  \t},\n  \tindexOfAfter: function indexOfAfter(pt, minIndex) {\n  \t\treturn LengthIndexOfPoint.indexOfAfter(this._linearGeom, pt, minIndex);\n  \t},\n  \textractLine: function extractLine(startIndex, endIndex) {\n  \t\tvar lil = new LocationIndexedLine(this._linearGeom);\n  \t\tvar startIndex2 = this.clampIndex(startIndex);\n  \t\tvar endIndex2 = this.clampIndex(endIndex);\n  \t\tvar resolveStartLower = startIndex2 === endIndex2;\n  \t\tvar startLoc = this.locationOf(startIndex2, resolveStartLower);\n  \t\tvar endLoc = this.locationOf(endIndex2);\n  \t\treturn ExtractLineByLocation.extract(this._linearGeom, startLoc, endLoc);\n  \t},\n  \tindexOf: function indexOf(pt) {\n  \t\treturn LengthIndexOfPoint.indexOf(this._linearGeom, pt);\n  \t},\n  \tindicesOf: function indicesOf(subLine) {\n  \t\tvar locIndex = LocationIndexOfLine.indicesOf(this._linearGeom, subLine);\n  \t\tvar index = [LengthLocationMap.getLength(this._linearGeom, locIndex[0]), LengthLocationMap.getLength(this._linearGeom, locIndex[1])];\n  \t\treturn index;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LengthIndexedLine;\n  \t}\n  });\n\n  function union() {\n      var reader = new GeoJSONReader();\n      var result = reader.read(JSON.stringify(arguments[0].geometry));\n      for (var i = 1; i < arguments.length; i++) {\n          result = UnionOp.union(result, reader.read(JSON.stringify(arguments[i].geometry)));\n      }\n      var writer = new GeoJSONWriter();\n      result = writer.write(result);\n      return {\n          type: 'Feature',\n          geometry: result,\n          properties: arguments[0].properties\n      };\n  }\n\n  function union$1(poly1, poly2) {\n    var featurePolygon1 = polygonToFeaturePolygon(poly1),\n        featurePolygon2 = polygonToFeaturePolygon(poly2),\n        FeatureUnion = union(featurePolygon1, featurePolygon2);\n    return FeatureUnion;\n  }\n\n  function bbox$1(geojson) {\n      var BBox = [Infinity, Infinity, -Infinity, -Infinity];\n      coordEach(geojson, function (coord) {\n          if (BBox[0] > coord[0]) BBox[0] = coord[0];\n          if (BBox[1] > coord[1]) BBox[1] = coord[1];\n          if (BBox[2] < coord[0]) BBox[2] = coord[0];\n          if (BBox[3] < coord[1]) BBox[3] = coord[1];\n      });\n      return BBox;\n  }\n\n  function center(geojson, properties) {\n    var ext = bbox$1(geojson);\n    var x = (ext[0] + ext[2]) / 2;\n    var y = (ext[1] + ext[3]) / 2;\n    return point([x, y], properties);\n  }\n\n  function toMercator(geojson, options) {\n      return convert(geojson, 'mercator', options);\n  }\n  function toWgs84(geojson, options) {\n      return convert(geojson, 'wgs84', options);\n  }\n  function convert(geojson, projection, options) {\n      options = options || {};\n      if (!isObject$1(options)) throw new Error('options is invalid');\n      var mutate = options.mutate;\n      if (!geojson) throw new Error('geojson is required');\n      if (Array.isArray(geojson) && isNumber(geojson[0])) geojson = projection === 'mercator' ? convertToMercator(geojson) : convertToWgs84(geojson);\n      else {\n              if (mutate !== true) geojson = clone(geojson);\n              coordEach(geojson, function (coord) {\n                  var newCoord = projection === 'mercator' ? convertToMercator(coord) : convertToWgs84(coord);\n                  coord[0] = newCoord[0];\n                  coord[1] = newCoord[1];\n              });\n          }\n      return geojson;\n  }\n  function convertToMercator(lonLat) {\n      var D2R = Math.PI / 180,\n      A = 6378137.0,\n          MAXEXTENT = 20037508.342789244;\n      var adjusted = Math.abs(lonLat[0]) <= 180 ? lonLat[0] : lonLat[0] - sign(lonLat[0]) * 360;\n      var xy = [A * adjusted * D2R, A * Math.log(Math.tan(Math.PI * 0.25 + 0.5 * lonLat[1] * D2R))];\n      if (xy[0] > MAXEXTENT) xy[0] = MAXEXTENT;\n      if (xy[0] < -MAXEXTENT) xy[0] = -MAXEXTENT;\n      if (xy[1] > MAXEXTENT) xy[1] = MAXEXTENT;\n      if (xy[1] < -MAXEXTENT) xy[1] = -MAXEXTENT;\n      return xy;\n  }\n  function convertToWgs84(xy) {\n      var R2D = 180 / Math.PI;\n      var A = 6378137.0;\n      return [xy[0] * R2D / A, (Math.PI * 0.5 - 2.0 * Math.atan(Math.exp(-xy[1] / A))) * R2D];\n  }\n  function sign(x) {\n      return x < 0 ? -1 : x > 0 ? 1 : 0;\n  }\n\n  function adder () {\n    return new Adder();\n  }\n  function Adder() {\n    this.reset();\n  }\n  Adder.prototype = {\n    constructor: Adder,\n    reset: function reset() {\n      this.s =\n      this.t = 0;\n    },\n    add: function add(y) {\n      _add(temp, y, this.t);\n      _add(this, temp.s, this.s);\n      if (this.s) this.t += temp.t;else this.s = temp.t;\n    },\n    valueOf: function valueOf() {\n      return this.s;\n    }\n  };\n  var temp = new Adder();\n  function _add(adder, a, b) {\n    var x = adder.s = a + b,\n        bv = x - a,\n        av = x - bv;\n    adder.t = a - av + (b - bv);\n  }\n\n  var epsilon = 1e-6;\n  var pi = Math.PI;\n  var halfPi = pi / 2;\n  var quarterPi = pi / 4;\n  var tau = pi * 2;\n  var degrees = 180 / pi;\n  var radians = pi / 180;\n  var abs = Math.abs;\n  var atan = Math.atan;\n  var atan2 = Math.atan2;\n  var cos = Math.cos;\n  var exp = Math.exp;\n  var log = Math.log;\n  var sin = Math.sin;\n  var sqrt = Math.sqrt;\n  var tan = Math.tan;\n  function acos(x) {\n    return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);\n  }\n  function asin(x) {\n    return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);\n  }\n\n  function noop() {}\n\n  function streamGeometry(geometry, stream) {\n    if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {\n      streamGeometryType[geometry.type](geometry, stream);\n    }\n  }\n  var streamObjectType = {\n    Feature: function Feature(object, stream) {\n      streamGeometry(object.geometry, stream);\n    },\n    FeatureCollection: function FeatureCollection(object, stream) {\n      var features = object.features,\n          i = -1,\n          n = features.length;\n      while (++i < n) {\n        streamGeometry(features[i].geometry, stream);\n      }\n    }\n  };\n  var streamGeometryType = {\n    Sphere: function Sphere(object, stream) {\n      stream.sphere();\n    },\n    Point: function Point(object, stream) {\n      object = object.coordinates;\n      stream.point(object[0], object[1], object[2]);\n    },\n    MultiPoint: function MultiPoint(object, stream) {\n      var coordinates = object.coordinates,\n          i = -1,\n          n = coordinates.length;\n      while (++i < n) {\n        object = coordinates[i], stream.point(object[0], object[1], object[2]);\n      }\n    },\n    LineString: function LineString(object, stream) {\n      streamLine(object.coordinates, stream, 0);\n    },\n    MultiLineString: function MultiLineString(object, stream) {\n      var coordinates = object.coordinates,\n          i = -1,\n          n = coordinates.length;\n      while (++i < n) {\n        streamLine(coordinates[i], stream, 0);\n      }\n    },\n    Polygon: function Polygon(object, stream) {\n      streamPolygon(object.coordinates, stream);\n    },\n    MultiPolygon: function MultiPolygon(object, stream) {\n      var coordinates = object.coordinates,\n          i = -1,\n          n = coordinates.length;\n      while (++i < n) {\n        streamPolygon(coordinates[i], stream);\n      }\n    },\n    GeometryCollection: function GeometryCollection(object, stream) {\n      var geometries = object.geometries,\n          i = -1,\n          n = geometries.length;\n      while (++i < n) {\n        streamGeometry(geometries[i], stream);\n      }\n    }\n  };\n  function streamLine(coordinates, stream, closed) {\n    var i = -1,\n        n = coordinates.length - closed,\n        coordinate;\n    stream.lineStart();\n    while (++i < n) {\n      coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);\n    }stream.lineEnd();\n  }\n  function streamPolygon(coordinates, stream) {\n    var i = -1,\n        n = coordinates.length;\n    stream.polygonStart();\n    while (++i < n) {\n      streamLine(coordinates[i], stream, 1);\n    }stream.polygonEnd();\n  }\n  function geoStream (object, stream) {\n    if (object && streamObjectType.hasOwnProperty(object.type)) {\n      streamObjectType[object.type](object, stream);\n    } else {\n      streamGeometry(object, stream);\n    }\n  }\n\n  var areaRingSum = adder();\n  var areaSum = adder();\n\n  function spherical(cartesian) {\n    return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];\n  }\n  function cartesian(spherical) {\n    var lambda = spherical[0],\n        phi = spherical[1],\n        cosPhi = cos(phi);\n    return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];\n  }\n  function cartesianDot(a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n  }\n  function cartesianCross(a, b) {\n    return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];\n  }\n  function cartesianAddInPlace(a, b) {\n    a[0] += b[0], a[1] += b[1], a[2] += b[2];\n  }\n  function cartesianScale(vector, k) {\n    return [vector[0] * k, vector[1] * k, vector[2] * k];\n  }\n  function cartesianNormalizeInPlace(d) {\n    var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);\n    d[0] /= l, d[1] /= l, d[2] /= l;\n  }\n\n  var deltaSum = adder();\n\n  function compose (a, b) {\n    function compose(x, y) {\n      return x = a(x, y), b(x[0], x[1]);\n    }\n    if (a.invert && b.invert) compose.invert = function (x, y) {\n      return x = b.invert(x, y), x && a.invert(x[0], x[1]);\n    };\n    return compose;\n  }\n\n  function rotationIdentity(lambda, phi) {\n    return [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];\n  }\n  rotationIdentity.invert = rotationIdentity;\n  function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {\n    return (deltaLambda %= tau) ? deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;\n  }\n  function forwardRotationLambda(deltaLambda) {\n    return function (lambda, phi) {\n      return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];\n    };\n  }\n  function rotationLambda(deltaLambda) {\n    var rotation = forwardRotationLambda(deltaLambda);\n    rotation.invert = forwardRotationLambda(-deltaLambda);\n    return rotation;\n  }\n  function rotationPhiGamma(deltaPhi, deltaGamma) {\n    var cosDeltaPhi = cos(deltaPhi),\n        sinDeltaPhi = sin(deltaPhi),\n        cosDeltaGamma = cos(deltaGamma),\n        sinDeltaGamma = sin(deltaGamma);\n    function rotation(lambda, phi) {\n      var cosPhi = cos(phi),\n          x = cos(lambda) * cosPhi,\n          y = sin(lambda) * cosPhi,\n          z = sin(phi),\n          k = z * cosDeltaPhi + x * sinDeltaPhi;\n      return [atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi), asin(k * cosDeltaGamma + y * sinDeltaGamma)];\n    }\n    rotation.invert = function (lambda, phi) {\n      var cosPhi = cos(phi),\n          x = cos(lambda) * cosPhi,\n          y = sin(lambda) * cosPhi,\n          z = sin(phi),\n          k = z * cosDeltaGamma - y * sinDeltaGamma;\n      return [atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi), asin(k * cosDeltaPhi - x * sinDeltaPhi)];\n    };\n    return rotation;\n  }\n  function rotation (rotate) {\n    rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);\n    function forward(coordinates) {\n      coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);\n      return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;\n    }\n    forward.invert = function (coordinates) {\n      coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);\n      return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;\n    };\n    return forward;\n  }\n\n  function circleStream(stream, radius, delta, direction, t0, t1) {\n    if (!delta) return;\n    var cosRadius = cos(radius),\n        sinRadius = sin(radius),\n        step = direction * delta;\n    if (t0 == null) {\n      t0 = radius + direction * tau;\n      t1 = radius - step / 2;\n    } else {\n      t0 = circleRadius(cosRadius, t0);\n      t1 = circleRadius(cosRadius, t1);\n      if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau;\n    }\n    for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {\n      point = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);\n      stream.point(point[0], point[1]);\n    }\n  }\n  function circleRadius(cosRadius, point) {\n    point = cartesian(point), point[0] -= cosRadius;\n    cartesianNormalizeInPlace(point);\n    var radius = acos(-point[1]);\n    return ((-point[2] < 0 ? -radius : radius) + tau - epsilon) % tau;\n  }\n\n  function clipBuffer () {\n    var lines = [],\n        line;\n    return {\n      point: function point(x, y) {\n        line.push([x, y]);\n      },\n      lineStart: function lineStart() {\n        lines.push(line = []);\n      },\n      lineEnd: noop,\n      rejoin: function rejoin() {\n        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));\n      },\n      result: function result() {\n        var result = lines;\n        lines = [];\n        line = null;\n        return result;\n      }\n    };\n  }\n\n  function clipLine (a, b, x0, y0, x1, y1) {\n    var ax = a[0],\n        ay = a[1],\n        bx = b[0],\n        by = b[1],\n        t0 = 0,\n        t1 = 1,\n        dx = bx - ax,\n        dy = by - ay,\n        r;\n    r = x0 - ax;\n    if (!dx && r > 0) return;\n    r /= dx;\n    if (dx < 0) {\n      if (r < t0) return;\n      if (r < t1) t1 = r;\n    } else if (dx > 0) {\n      if (r > t1) return;\n      if (r > t0) t0 = r;\n    }\n    r = x1 - ax;\n    if (!dx && r < 0) return;\n    r /= dx;\n    if (dx < 0) {\n      if (r > t1) return;\n      if (r > t0) t0 = r;\n    } else if (dx > 0) {\n      if (r < t0) return;\n      if (r < t1) t1 = r;\n    }\n    r = y0 - ay;\n    if (!dy && r > 0) return;\n    r /= dy;\n    if (dy < 0) {\n      if (r < t0) return;\n      if (r < t1) t1 = r;\n    } else if (dy > 0) {\n      if (r > t1) return;\n      if (r > t0) t0 = r;\n    }\n    r = y1 - ay;\n    if (!dy && r < 0) return;\n    r /= dy;\n    if (dy < 0) {\n      if (r > t1) return;\n      if (r > t0) t0 = r;\n    } else if (dy > 0) {\n      if (r < t0) return;\n      if (r < t1) t1 = r;\n    }\n    if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;\n    if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;\n    return true;\n  }\n\n  function pointEqual (a, b) {\n    return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;\n  }\n\n  function Intersection(point, points, other, entry) {\n    this.x = point;\n    this.z = points;\n    this.o = other;\n    this.e = entry;\n    this.v = false;\n    this.n = this.p = null;\n  }\n  function clipPolygon (segments, compareIntersection, startInside, interpolate, stream) {\n    var subject = [],\n        clip = [],\n        i,\n        n;\n    segments.forEach(function (segment) {\n      if ((n = segment.length - 1) <= 0) return;\n      var n,\n          p0 = segment[0],\n          p1 = segment[n],\n          x;\n      if (pointEqual(p0, p1)) {\n        stream.lineStart();\n        for (i = 0; i < n; ++i) {\n          stream.point((p0 = segment[i])[0], p0[1]);\n        }stream.lineEnd();\n        return;\n      }\n      subject.push(x = new Intersection(p0, segment, null, true));\n      clip.push(x.o = new Intersection(p0, null, x, false));\n      subject.push(x = new Intersection(p1, segment, null, false));\n      clip.push(x.o = new Intersection(p1, null, x, true));\n    });\n    if (!subject.length) return;\n    clip.sort(compareIntersection);\n    link(subject);\n    link(clip);\n    for (i = 0, n = clip.length; i < n; ++i) {\n      clip[i].e = startInside = !startInside;\n    }\n    var start = subject[0],\n        points,\n        point;\n    while (1) {\n      var current = start,\n          isSubject = true;\n      while (current.v) {\n        if ((current = current.n) === start) return;\n      }points = current.z;\n      stream.lineStart();\n      do {\n        current.v = current.o.v = true;\n        if (current.e) {\n          if (isSubject) {\n            for (i = 0, n = points.length; i < n; ++i) {\n              stream.point((point = points[i])[0], point[1]);\n            }\n          } else {\n            interpolate(current.x, current.n.x, 1, stream);\n          }\n          current = current.n;\n        } else {\n          if (isSubject) {\n            points = current.p.z;\n            for (i = points.length - 1; i >= 0; --i) {\n              stream.point((point = points[i])[0], point[1]);\n            }\n          } else {\n            interpolate(current.x, current.p.x, -1, stream);\n          }\n          current = current.p;\n        }\n        current = current.o;\n        points = current.z;\n        isSubject = !isSubject;\n      } while (!current.v);\n      stream.lineEnd();\n    }\n  }\n  function link(array) {\n    if (!(n = array.length)) return;\n    var n,\n        i = 0,\n        a = array[0],\n        b;\n    while (++i < n) {\n      a.n = b = array[i];\n      b.p = a;\n      a = b;\n    }\n    a.n = b = array[0];\n    b.p = a;\n  }\n\n  function ascending (a, b) {\n    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n  }\n\n  function bisector (compare) {\n    if (compare.length === 1) compare = ascendingComparator(compare);\n    return {\n      left: function left(a, x, lo, hi) {\n        if (lo == null) lo = 0;\n        if (hi == null) hi = a.length;\n        while (lo < hi) {\n          var mid = lo + hi >>> 1;\n          if (compare(a[mid], x) < 0) lo = mid + 1;else hi = mid;\n        }\n        return lo;\n      },\n      right: function right(a, x, lo, hi) {\n        if (lo == null) lo = 0;\n        if (hi == null) hi = a.length;\n        while (lo < hi) {\n          var mid = lo + hi >>> 1;\n          if (compare(a[mid], x) > 0) hi = mid;else lo = mid + 1;\n        }\n        return lo;\n      }\n    };\n  }\n  function ascendingComparator(f) {\n    return function (d, x) {\n      return ascending(f(d), x);\n    };\n  }\n\n  var ascendingBisect = bisector(ascending);\n\n  function merge$1 (arrays) {\n    var n = arrays.length,\n        m,\n        i = -1,\n        j = 0,\n        merged,\n        array;\n    while (++i < n) {\n      j += arrays[i].length;\n    }merged = new Array(j);\n    while (--n >= 0) {\n      array = arrays[n];\n      m = array.length;\n      while (--m >= 0) {\n        merged[--j] = array[m];\n      }\n    }\n    return merged;\n  }\n\n  var clipMax = 1e9,\n      clipMin = -clipMax;\n  function clipExtent(x0, y0, x1, y1) {\n    function visible(x, y) {\n      return x0 <= x && x <= x1 && y0 <= y && y <= y1;\n    }\n    function interpolate(from, to, direction, stream) {\n      var a = 0,\n          a1 = 0;\n      if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {\n        do {\n          stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);\n        } while ((a = (a + direction + 4) % 4) !== a1);\n      } else {\n        stream.point(to[0], to[1]);\n      }\n    }\n    function corner(p, direction) {\n      return abs(p[0] - x0) < epsilon ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < epsilon ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < epsilon ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;\n    }\n    function compareIntersection(a, b) {\n      return comparePoint(a.x, b.x);\n    }\n    function comparePoint(a, b) {\n      var ca = corner(a, 1),\n          cb = corner(b, 1);\n      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];\n    }\n    return function (stream) {\n      var activeStream = stream,\n          bufferStream = clipBuffer(),\n          segments,\n          polygon,\n          ring,\n          x__,\n          y__,\n          v__,\n      x_,\n          y_,\n          v_,\n      first,\n          clean;\n      var clipStream = {\n        point: point,\n        lineStart: lineStart,\n        lineEnd: lineEnd,\n        polygonStart: polygonStart,\n        polygonEnd: polygonEnd\n      };\n      function point(x, y) {\n        if (visible(x, y)) activeStream.point(x, y);\n      }\n      function polygonInside() {\n        var winding = 0;\n        for (var i = 0, n = polygon.length; i < n; ++i) {\n          for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {\n            a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];\n            if (a1 <= y1) {\n              if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding;\n            } else {\n              if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding;\n            }\n          }\n        }\n        return winding;\n      }\n      function polygonStart() {\n        activeStream = bufferStream, segments = [], polygon = [], clean = true;\n      }\n      function polygonEnd() {\n        var startInside = polygonInside(),\n            cleanInside = clean && startInside,\n            visible = (segments = merge$1(segments)).length;\n        if (cleanInside || visible) {\n          stream.polygonStart();\n          if (cleanInside) {\n            stream.lineStart();\n            interpolate(null, null, 1, stream);\n            stream.lineEnd();\n          }\n          if (visible) {\n            clipPolygon(segments, compareIntersection, startInside, interpolate, stream);\n          }\n          stream.polygonEnd();\n        }\n        activeStream = stream, segments = polygon = ring = null;\n      }\n      function lineStart() {\n        clipStream.point = linePoint;\n        if (polygon) polygon.push(ring = []);\n        first = true;\n        v_ = false;\n        x_ = y_ = NaN;\n      }\n      function lineEnd() {\n        if (segments) {\n          linePoint(x__, y__);\n          if (v__ && v_) bufferStream.rejoin();\n          segments.push(bufferStream.result());\n        }\n        clipStream.point = point;\n        if (v_) activeStream.lineEnd();\n      }\n      function linePoint(x, y) {\n        var v = visible(x, y);\n        if (polygon) ring.push([x, y]);\n        if (first) {\n          x__ = x, y__ = y, v__ = v;\n          first = false;\n          if (v) {\n            activeStream.lineStart();\n            activeStream.point(x, y);\n          }\n        } else {\n          if (v && v_) activeStream.point(x, y);else {\n            var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],\n                b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];\n            if (clipLine(a, b, x0, y0, x1, y1)) {\n              if (!v_) {\n                activeStream.lineStart();\n                activeStream.point(a[0], a[1]);\n              }\n              activeStream.point(b[0], b[1]);\n              if (!v) activeStream.lineEnd();\n              clean = false;\n            } else if (v) {\n              activeStream.lineStart();\n              activeStream.point(x, y);\n              clean = false;\n            }\n          }\n        }\n        x_ = x, y_ = y, v_ = v;\n      }\n      return clipStream;\n    };\n  }\n\n  var sum$1 = adder();\n  function polygonContains (polygon, point) {\n    var lambda = point[0],\n        phi = point[1],\n        normal = [sin(lambda), -cos(lambda), 0],\n        angle = 0,\n        winding = 0;\n    sum$1.reset();\n    for (var i = 0, n = polygon.length; i < n; ++i) {\n      if (!(m = (ring = polygon[i]).length)) continue;\n      var ring,\n          m,\n          point0 = ring[m - 1],\n          lambda0 = point0[0],\n          phi0 = point0[1] / 2 + quarterPi,\n          sinPhi0 = sin(phi0),\n          cosPhi0 = cos(phi0);\n      for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {\n        var point1 = ring[j],\n            lambda1 = point1[0],\n            phi1 = point1[1] / 2 + quarterPi,\n            sinPhi1 = sin(phi1),\n            cosPhi1 = cos(phi1),\n            delta = lambda1 - lambda0,\n            sign = delta >= 0 ? 1 : -1,\n            absDelta = sign * delta,\n            antimeridian = absDelta > pi,\n            k = sinPhi0 * sinPhi1;\n        sum$1.add(atan2(k * sign * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta)));\n        angle += antimeridian ? delta + sign * tau : delta;\n        if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {\n          var arc = cartesianCross(cartesian(point0), cartesian(point1));\n          cartesianNormalizeInPlace(arc);\n          var intersection = cartesianCross(normal, arc);\n          cartesianNormalizeInPlace(intersection);\n          var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);\n          if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {\n            winding += antimeridian ^ delta >= 0 ? 1 : -1;\n          }\n        }\n      }\n    }\n    return (angle < -epsilon || angle < epsilon && sum$1 < -epsilon) ^ winding & 1;\n  }\n\n  var lengthSum = adder();\n\n  function identity$3 (x) {\n    return x;\n  }\n\n  var areaSum$1 = adder(),\n      areaRingSum$1 = adder();\n\n  var x0$2 = Infinity,\n      y0$2 = x0$2,\n      x1 = -x0$2,\n      y1 = x1;\n  var boundsStream$1 = {\n    point: boundsPoint$1,\n    lineStart: noop,\n    lineEnd: noop,\n    polygonStart: noop,\n    polygonEnd: noop,\n    result: function result() {\n      var bounds = [[x0$2, y0$2], [x1, y1]];\n      x1 = y1 = -(y0$2 = x0$2 = Infinity);\n      return bounds;\n    }\n  };\n  function boundsPoint$1(x, y) {\n    if (x < x0$2) x0$2 = x;\n    if (x > x1) x1 = x;\n    if (y < y0$2) y0$2 = y;\n    if (y > y1) y1 = y;\n  }\n\n  var lengthSum$1 = adder();\n\n  function clip (pointVisible, clipLine, interpolate, start) {\n    return function (rotate, sink) {\n      var line = clipLine(sink),\n          rotatedStart = rotate.invert(start[0], start[1]),\n          ringBuffer = clipBuffer(),\n          ringSink = clipLine(ringBuffer),\n          polygonStarted = false,\n          polygon,\n          segments,\n          ring;\n      var clip = {\n        point: point,\n        lineStart: lineStart,\n        lineEnd: lineEnd,\n        polygonStart: function polygonStart() {\n          clip.point = pointRing;\n          clip.lineStart = ringStart;\n          clip.lineEnd = ringEnd;\n          segments = [];\n          polygon = [];\n        },\n        polygonEnd: function polygonEnd() {\n          clip.point = point;\n          clip.lineStart = lineStart;\n          clip.lineEnd = lineEnd;\n          segments = merge$1(segments);\n          var startInside = polygonContains(polygon, rotatedStart);\n          if (segments.length) {\n            if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n            clipPolygon(segments, compareIntersection, startInside, interpolate, sink);\n          } else if (startInside) {\n            if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n            sink.lineStart();\n            interpolate(null, null, 1, sink);\n            sink.lineEnd();\n          }\n          if (polygonStarted) sink.polygonEnd(), polygonStarted = false;\n          segments = polygon = null;\n        },\n        sphere: function sphere() {\n          sink.polygonStart();\n          sink.lineStart();\n          interpolate(null, null, 1, sink);\n          sink.lineEnd();\n          sink.polygonEnd();\n        }\n      };\n      function point(lambda, phi) {\n        var point = rotate(lambda, phi);\n        if (pointVisible(lambda = point[0], phi = point[1])) sink.point(lambda, phi);\n      }\n      function pointLine(lambda, phi) {\n        var point = rotate(lambda, phi);\n        line.point(point[0], point[1]);\n      }\n      function lineStart() {\n        clip.point = pointLine;\n        line.lineStart();\n      }\n      function lineEnd() {\n        clip.point = point;\n        line.lineEnd();\n      }\n      function pointRing(lambda, phi) {\n        ring.push([lambda, phi]);\n        var point = rotate(lambda, phi);\n        ringSink.point(point[0], point[1]);\n      }\n      function ringStart() {\n        ringSink.lineStart();\n        ring = [];\n      }\n      function ringEnd() {\n        pointRing(ring[0][0], ring[0][1]);\n        ringSink.lineEnd();\n        var clean = ringSink.clean(),\n            ringSegments = ringBuffer.result(),\n            i,\n            n = ringSegments.length,\n            m,\n            segment,\n            point;\n        ring.pop();\n        polygon.push(ring);\n        ring = null;\n        if (!n) return;\n        if (clean & 1) {\n          segment = ringSegments[0];\n          if ((m = segment.length - 1) > 0) {\n            if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n            sink.lineStart();\n            for (i = 0; i < m; ++i) {\n              sink.point((point = segment[i])[0], point[1]);\n            }sink.lineEnd();\n          }\n          return;\n        }\n        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n        segments.push(ringSegments.filter(validSegment));\n      }\n      return clip;\n    };\n  }\n  function validSegment(segment) {\n    return segment.length > 1;\n  }\n  function compareIntersection(a, b) {\n    return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);\n  }\n\n  var clipAntimeridian = clip(function () {\n    return true;\n  }, clipAntimeridianLine, clipAntimeridianInterpolate, [-pi, -halfPi]);\n  function clipAntimeridianLine(stream) {\n    var lambda0 = NaN,\n        phi0 = NaN,\n        sign0 = NaN,\n        _clean;\n    return {\n      lineStart: function lineStart() {\n        stream.lineStart();\n        _clean = 1;\n      },\n      point: function point(lambda1, phi1) {\n        var sign1 = lambda1 > 0 ? pi : -pi,\n            delta = abs(lambda1 - lambda0);\n        if (abs(delta - pi) < epsilon) {\n          stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);\n          stream.point(sign0, phi0);\n          stream.lineEnd();\n          stream.lineStart();\n          stream.point(sign1, phi0);\n          stream.point(lambda1, phi0);\n          _clean = 0;\n        } else if (sign0 !== sign1 && delta >= pi) {\n          if (abs(lambda0 - sign0) < epsilon) lambda0 -= sign0 * epsilon;\n          if (abs(lambda1 - sign1) < epsilon) lambda1 -= sign1 * epsilon;\n          phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);\n          stream.point(sign0, phi0);\n          stream.lineEnd();\n          stream.lineStart();\n          stream.point(sign1, phi0);\n          _clean = 0;\n        }\n        stream.point(lambda0 = lambda1, phi0 = phi1);\n        sign0 = sign1;\n      },\n      lineEnd: function lineEnd() {\n        stream.lineEnd();\n        lambda0 = phi0 = NaN;\n      },\n      clean: function clean() {\n        return 2 - _clean;\n      }\n    };\n  }\n  function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {\n    var cosPhi0,\n        cosPhi1,\n        sinLambda0Lambda1 = sin(lambda0 - lambda1);\n    return abs(sinLambda0Lambda1) > epsilon ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1) - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;\n  }\n  function clipAntimeridianInterpolate(from, to, direction, stream) {\n    var phi;\n    if (from == null) {\n      phi = direction * halfPi;\n      stream.point(-pi, phi);\n      stream.point(0, phi);\n      stream.point(pi, phi);\n      stream.point(pi, 0);\n      stream.point(pi, -phi);\n      stream.point(0, -phi);\n      stream.point(-pi, -phi);\n      stream.point(-pi, 0);\n      stream.point(-pi, phi);\n    } else if (abs(from[0] - to[0]) > epsilon) {\n      var lambda = from[0] < to[0] ? pi : -pi;\n      phi = direction * lambda / 2;\n      stream.point(-lambda, phi);\n      stream.point(0, phi);\n      stream.point(lambda, phi);\n    } else {\n      stream.point(to[0], to[1]);\n    }\n  }\n\n  function clipCircle (radius, delta) {\n    var cr = cos(radius),\n        smallRadius = cr > 0,\n        notHemisphere = abs(cr) > epsilon;\n    function interpolate(from, to, direction, stream) {\n      circleStream(stream, radius, delta, direction, from, to);\n    }\n    function visible(lambda, phi) {\n      return cos(lambda) * cos(phi) > cr;\n    }\n    function clipLine(stream) {\n      var point0,\n      c0,\n      v0,\n      v00,\n      _clean;\n      return {\n        lineStart: function lineStart() {\n          v00 = v0 = false;\n          _clean = 1;\n        },\n        point: function point(lambda, phi) {\n          var point1 = [lambda, phi],\n              point2,\n              v = visible(lambda, phi),\n              c = smallRadius ? v ? 0 : code(lambda, phi) : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;\n          if (!point0 && (v00 = v0 = v)) stream.lineStart();\n          if (v !== v0) {\n            point2 = intersect(point0, point1);\n            if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {\n              point1[0] += epsilon;\n              point1[1] += epsilon;\n              v = visible(point1[0], point1[1]);\n            }\n          }\n          if (v !== v0) {\n            _clean = 0;\n            if (v) {\n              stream.lineStart();\n              point2 = intersect(point1, point0);\n              stream.point(point2[0], point2[1]);\n            } else {\n              point2 = intersect(point0, point1);\n              stream.point(point2[0], point2[1]);\n              stream.lineEnd();\n            }\n            point0 = point2;\n          } else if (notHemisphere && point0 && smallRadius ^ v) {\n            var t;\n            if (!(c & c0) && (t = intersect(point1, point0, true))) {\n              _clean = 0;\n              if (smallRadius) {\n                stream.lineStart();\n                stream.point(t[0][0], t[0][1]);\n                stream.point(t[1][0], t[1][1]);\n                stream.lineEnd();\n              } else {\n                stream.point(t[1][0], t[1][1]);\n                stream.lineEnd();\n                stream.lineStart();\n                stream.point(t[0][0], t[0][1]);\n              }\n            }\n          }\n          if (v && (!point0 || !pointEqual(point0, point1))) {\n            stream.point(point1[0], point1[1]);\n          }\n          point0 = point1, v0 = v, c0 = c;\n        },\n        lineEnd: function lineEnd() {\n          if (v0) stream.lineEnd();\n          point0 = null;\n        },\n        clean: function clean() {\n          return _clean | (v00 && v0) << 1;\n        }\n      };\n    }\n    function intersect(a, b, two) {\n      var pa = cartesian(a),\n          pb = cartesian(b);\n      var n1 = [1, 0, 0],\n      n2 = cartesianCross(pa, pb),\n          n2n2 = cartesianDot(n2, n2),\n          n1n2 = n2[0],\n      determinant = n2n2 - n1n2 * n1n2;\n      if (!determinant) return !two && a;\n      var c1 = cr * n2n2 / determinant,\n          c2 = -cr * n1n2 / determinant,\n          n1xn2 = cartesianCross(n1, n2),\n          A = cartesianScale(n1, c1),\n          B = cartesianScale(n2, c2);\n      cartesianAddInPlace(A, B);\n      var u = n1xn2,\n          w = cartesianDot(A, u),\n          uu = cartesianDot(u, u),\n          t2 = w * w - uu * (cartesianDot(A, A) - 1);\n      if (t2 < 0) return;\n      var t = sqrt(t2),\n          q = cartesianScale(u, (-w - t) / uu);\n      cartesianAddInPlace(q, A);\n      q = spherical(q);\n      if (!two) return q;\n      var lambda0 = a[0],\n          lambda1 = b[0],\n          phi0 = a[1],\n          phi1 = b[1],\n          z;\n      if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;\n      var delta = lambda1 - lambda0,\n          polar = abs(delta - pi) < epsilon,\n          meridian = polar || delta < epsilon;\n      if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;\n      if (meridian ? polar ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {\n        var q1 = cartesianScale(u, (-w + t) / uu);\n        cartesianAddInPlace(q1, A);\n        return [q, spherical(q1)];\n      }\n    }\n    function code(lambda, phi) {\n      var r = smallRadius ? radius : pi - radius,\n          code = 0;\n      if (lambda < -r) code |= 1;\n      else if (lambda > r) code |= 2;\n      if (phi < -r) code |= 4;\n      else if (phi > r) code |= 8;\n      return code;\n    }\n    return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);\n  }\n\n  function transformer(methods) {\n    return function (stream) {\n      var s = new TransformStream();\n      for (var key in methods) {\n        s[key] = methods[key];\n      }s.stream = stream;\n      return s;\n    };\n  }\n  function TransformStream() {}\n  TransformStream.prototype = {\n    constructor: TransformStream,\n    point: function point(x, y) {\n      this.stream.point(x, y);\n    },\n    sphere: function sphere() {\n      this.stream.sphere();\n    },\n    lineStart: function lineStart() {\n      this.stream.lineStart();\n    },\n    lineEnd: function lineEnd() {\n      this.stream.lineEnd();\n    },\n    polygonStart: function polygonStart() {\n      this.stream.polygonStart();\n    },\n    polygonEnd: function polygonEnd() {\n      this.stream.polygonEnd();\n    }\n  };\n\n  function fitExtent(projection, extent, object) {\n      var w = extent[1][0] - extent[0][0],\n          h = extent[1][1] - extent[0][1],\n          clip = projection.clipExtent && projection.clipExtent();\n      projection.scale(150).translate([0, 0]);\n      if (clip != null) projection.clipExtent(null);\n      geoStream(object, projection.stream(boundsStream$1));\n      var b = boundsStream$1.result(),\n          k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),\n          x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,\n          y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;\n      if (clip != null) projection.clipExtent(clip);\n      return projection.scale(k * 150).translate([x, y]);\n  }\n  function fitSize(projection, size, object) {\n      return fitExtent(projection, [[0, 0], size], object);\n  }\n\n  var maxDepth = 16,\n  cosMinDistance = cos(30 * radians);\n  function resample (project, delta2) {\n    return +delta2 ? resample$1(project, delta2) : resampleNone(project);\n  }\n  function resampleNone(project) {\n    return transformer({\n      point: function point(x, y) {\n        x = project(x, y);\n        this.stream.point(x[0], x[1]);\n      }\n    });\n  }\n  function resample$1(project, delta2) {\n    function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {\n      var dx = x1 - x0,\n          dy = y1 - y0,\n          d2 = dx * dx + dy * dy;\n      if (d2 > 4 * delta2 && depth--) {\n        var a = a0 + a1,\n            b = b0 + b1,\n            c = c0 + c1,\n            m = sqrt(a * a + b * b + c * c),\n            phi2 = asin(c /= m),\n            lambda2 = abs(abs(c) - 1) < epsilon || abs(lambda0 - lambda1) < epsilon ? (lambda0 + lambda1) / 2 : atan2(b, a),\n            p = project(lambda2, phi2),\n            x2 = p[0],\n            y2 = p[1],\n            dx2 = x2 - x0,\n            dy2 = y2 - y0,\n            dz = dy * dx2 - dx * dy2;\n        if (dz * dz / d2 > delta2\n        || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3\n        || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {\n          resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);\n          stream.point(x2, y2);\n          resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);\n        }\n      }\n    }\n    return function (stream) {\n      var lambda00, x00, y00, a00, b00, c00,\n      lambda0, x0, y0, a0, b0, c0;\n      var resampleStream = {\n        point: point,\n        lineStart: lineStart,\n        lineEnd: lineEnd,\n        polygonStart: function polygonStart() {\n          stream.polygonStart();resampleStream.lineStart = ringStart;\n        },\n        polygonEnd: function polygonEnd() {\n          stream.polygonEnd();resampleStream.lineStart = lineStart;\n        }\n      };\n      function point(x, y) {\n        x = project(x, y);\n        stream.point(x[0], x[1]);\n      }\n      function lineStart() {\n        x0 = NaN;\n        resampleStream.point = linePoint;\n        stream.lineStart();\n      }\n      function linePoint(lambda, phi) {\n        var c = cartesian([lambda, phi]),\n            p = project(lambda, phi);\n        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);\n        stream.point(x0, y0);\n      }\n      function lineEnd() {\n        resampleStream.point = point;\n        stream.lineEnd();\n      }\n      function ringStart() {\n        lineStart();\n        resampleStream.point = ringPoint;\n        resampleStream.lineEnd = ringEnd;\n      }\n      function ringPoint(lambda, phi) {\n        linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;\n        resampleStream.point = linePoint;\n      }\n      function ringEnd() {\n        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);\n        resampleStream.lineEnd = lineEnd;\n        lineEnd();\n      }\n      return resampleStream;\n    };\n  }\n\n  var transformRadians = transformer({\n    point: function point(x, y) {\n      this.stream.point(x * radians, y * radians);\n    }\n  });\n  function projection(project) {\n    return projectionMutator(function () {\n      return project;\n    })();\n  }\n  function projectionMutator(projectAt) {\n    var project,\n        k = 150,\n    x = 480,\n        y = 250,\n    dx,\n        dy,\n        lambda = 0,\n        phi = 0,\n    deltaLambda = 0,\n        deltaPhi = 0,\n        deltaGamma = 0,\n        rotate,\n        projectRotate,\n    theta = null,\n        preclip = clipAntimeridian,\n    x0 = null,\n        y0,\n        x1,\n        y1,\n        postclip = identity$3,\n    delta2 = 0.5,\n        projectResample = resample(projectTransform, delta2),\n    cache,\n        cacheStream;\n    function projection(point) {\n      point = projectRotate(point[0] * radians, point[1] * radians);\n      return [point[0] * k + dx, dy - point[1] * k];\n    }\n    function invert(point) {\n      point = projectRotate.invert((point[0] - dx) / k, (dy - point[1]) / k);\n      return point && [point[0] * degrees, point[1] * degrees];\n    }\n    function projectTransform(x, y) {\n      return x = project(x, y), [x[0] * k + dx, dy - x[1] * k];\n    }\n    projection.stream = function (stream) {\n      return cache && cacheStream === stream ? cache : cache = transformRadians(preclip(rotate, projectResample(postclip(cacheStream = stream))));\n    };\n    projection.clipAngle = function (_) {\n      return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians, 6 * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;\n    };\n    projection.clipExtent = function (_) {\n      return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$3) : clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n    };\n    projection.scale = function (_) {\n      return arguments.length ? (k = +_, recenter()) : k;\n    };\n    projection.translate = function (_) {\n      return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];\n    };\n    projection.center = function (_) {\n      return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];\n    };\n    projection.rotate = function (_) {\n      return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];\n    };\n    projection.precision = function (_) {\n      return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);\n    };\n    projection.fitExtent = function (extent, object) {\n      return fitExtent(projection, extent, object);\n    };\n    projection.fitSize = function (size, object) {\n      return fitSize(projection, size, object);\n    };\n    function recenter() {\n      projectRotate = compose(rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma), project);\n      var center = project(lambda, phi);\n      dx = x - center[0] * k;\n      dy = y + center[1] * k;\n      return reset();\n    }\n    function reset() {\n      cache = cacheStream = null;\n      return projection;\n    }\n    return function () {\n      project = projectAt.apply(this, arguments);\n      projection.invert = project.invert && invert;\n      return recenter();\n    };\n  }\n\n  function mercatorRaw(lambda, phi) {\n    return [lambda, log(tan((halfPi + phi) / 2))];\n  }\n  mercatorRaw.invert = function (x, y) {\n    return [x, 2 * atan(exp(y)) - halfPi];\n  };\n  function mercatorProjection(project) {\n    var m = projection(project),\n        center = m.center,\n        scale = m.scale,\n        translate = m.translate,\n        clipExtent = m.clipExtent,\n        x0 = null,\n        y0,\n        x1,\n        y1;\n    m.scale = function (_) {\n      return arguments.length ? (scale(_), reclip()) : scale();\n    };\n    m.translate = function (_) {\n      return arguments.length ? (translate(_), reclip()) : translate();\n    };\n    m.center = function (_) {\n      return arguments.length ? (center(_), reclip()) : center();\n    };\n    m.clipExtent = function (_) {\n      return arguments.length ? (_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n    };\n    function reclip() {\n      var k = pi * scale(),\n          t = m(rotation(m.rotate()).invert([0, 0]));\n      return clipExtent(x0 == null ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]] : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);\n    }\n    return reclip();\n  }\n\n  function transverseMercatorRaw(lambda, phi) {\n    return [log(tan((halfPi + phi) / 2)), -lambda];\n  }\n  transverseMercatorRaw.invert = function (x, y) {\n    return [-y, 2 * atan(exp(x)) - halfPi];\n  };\n  function geoTransverseMercator () {\n    var m = mercatorProjection(transverseMercatorRaw),\n        center = m.center,\n        rotate = m.rotate;\n    m.center = function (_) {\n      return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);\n    };\n    m.rotate = function (_) {\n      return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);\n    };\n    return rotate([0, 0, 90]).scale(159.155);\n  }\n\n  function buffer$1(geojson, radius, options) {\n      options = options || {};\n      var units = options.units;\n      var steps = options.steps || 64;\n      if (!geojson) throw new Error('geojson is required');\n      if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object') throw new Error('options must be an object');\n      if (typeof steps !== 'number') throw new Error('steps must be an number');\n      if (radius === undefined) throw new Error('radius is required');\n      if (steps <= 0) throw new Error('steps must be greater than 0');\n      steps = steps || 64;\n      units = units || 'kilometers';\n      var results = [];\n      switch (geojson.type) {\n          case 'GeometryCollection':\n              geomEach(geojson, function (geometry$$1) {\n                  var buffered = bufferFeature(geometry$$1, radius, units, steps);\n                  if (buffered) results.push(buffered);\n              });\n              return featureCollection(results);\n          case 'FeatureCollection':\n              featureEach(geojson, function (feature$$1) {\n                  var multiBuffered = bufferFeature(feature$$1, radius, units, steps);\n                  if (multiBuffered) {\n                      featureEach(multiBuffered, function (buffered) {\n                          if (buffered) results.push(buffered);\n                      });\n                  }\n              });\n              return featureCollection(results);\n      }\n      return bufferFeature(geojson, radius, units, steps);\n  }\n  function bufferFeature(geojson, radius, units, steps) {\n      var properties = geojson.properties || {};\n      var geometry$$1 = geojson.type === 'Feature' ? geojson.geometry : geojson;\n      if (geometry$$1.type === 'GeometryCollection') {\n          var results = [];\n          geomEach(geojson, function (geometry$$1) {\n              var buffered = bufferFeature(geometry$$1, radius, units, steps);\n              if (buffered) results.push(buffered);\n          });\n          return featureCollection(results);\n      }\n      var projected;\n      var bbox = bbox$1(geojson);\n      var needsTransverseMercator = bbox[1] > 50 && bbox[3] > 50;\n      if (needsTransverseMercator) {\n          projected = {\n              type: geometry$$1.type,\n              coordinates: projectCoords(geometry$$1.coordinates, defineProjection(geometry$$1))\n          };\n      } else {\n          projected = toMercator(geometry$$1);\n      }\n      var reader = new GeoJSONReader();\n      var geom = reader.read(projected);\n      var distance = radiansToLength(lengthToRadians(radius, units), 'meters');\n      var buffered = BufferOp.bufferOp(geom, distance);\n      var writer = new GeoJSONWriter();\n      buffered = writer.write(buffered);\n      if (coordsIsNaN(buffered.coordinates)) return undefined;\n      var result;\n      if (needsTransverseMercator) {\n          result = {\n              type: buffered.type,\n              coordinates: unprojectCoords(buffered.coordinates, defineProjection(geometry$$1))\n          };\n      } else {\n          result = toWgs84(buffered);\n      }\n      return result.geometry ? result : feature(result, properties);\n  }\n  function coordsIsNaN(coords) {\n      if (Array.isArray(coords[0])) return coordsIsNaN(coords[0]);\n      return isNaN(coords[0]);\n  }\n  function projectCoords(coords, proj) {\n      if (_typeof(coords[0]) !== 'object') return proj(coords);\n      return coords.map(function (coord) {\n          return projectCoords(coord, proj);\n      });\n  }\n  function unprojectCoords(coords, proj) {\n      if (_typeof(coords[0]) !== 'object') return proj.invert(coords);\n      return coords.map(function (coord) {\n          return unprojectCoords(coord, proj);\n      });\n  }\n  function defineProjection(geojson) {\n      var coords = center(geojson).geometry.coordinates.reverse();\n      var rotate = coords.map(function (coord) {\n          return -coord;\n      });\n      return geoTransverseMercator().center(coords).rotate(rotate).scale(earthRadius);\n  }\n\n  function createbuffer(object, output, distance, units, comment, steps) {\n      units = units || 'meters';\n      output = (output || 'feature').toLowerCase();\n      var Feature;\n      if (object instanceof google.maps.Polyline || object instanceof google.maps.Polygon || object instanceof google.maps.Marker || object instanceof google.maps.LatLng) {\n          var geometry = Wicket$1().fromObject(object).toJson();\n          Feature = {\n              type: \"Feature\",\n              properties: {},\n              geometry: geometry\n          };\n      } else if (object.type && object.type === 'Feature' && object.geometry) {\n          Feature = object;\n      } else {\n          Feature = polygonToFeaturePolygon(object);\n      }\n      var buffered = buffer$1(Feature, distance, {\n          units: units,\n          steps: steps\n      });\n      if (buffered.type === 'FeatureCollection') {\n          buffered = buffered.features[0];\n      }\n      if (output === 'geometry') {\n          return buffered.geometry;\n      } else if (output === 'object') {\n          return Wicket$1().fromJson(buffered.geometry).toObject();\n      } else {\n          return buffered;\n      }\n  }\n\n  function booleanPointInPolygon(point, polygon, options) {\n      options = options || {};\n      if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object') throw new Error('options is invalid');\n      var ignoreBoundary = options.ignoreBoundary;\n      if (!point) throw new Error('point is required');\n      if (!polygon) throw new Error('polygon is required');\n      var pt = getCoord(point);\n      var polys = getCoords(polygon);\n      var type = polygon.geometry ? polygon.geometry.type : polygon.type;\n      var bbox = polygon.bbox;\n      if (bbox && inBBox(pt, bbox) === false) return false;\n      if (type === 'Polygon') polys = [polys];\n      for (var i = 0, insidePoly = false; i < polys.length && !insidePoly; i++) {\n          if (inRing(pt, polys[i][0], ignoreBoundary)) {\n              var inHole = false;\n              var k = 1;\n              while (k < polys[i].length && !inHole) {\n                  if (inRing(pt, polys[i][k], !ignoreBoundary)) {\n                      inHole = true;\n                  }\n                  k++;\n              }\n              if (!inHole) insidePoly = true;\n          }\n      }\n      return insidePoly;\n  }\n  function inRing(pt, ring, ignoreBoundary) {\n      var isInside = false;\n      if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) ring = ring.slice(0, ring.length - 1);\n      for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n          var xi = ring[i][0],\n              yi = ring[i][1];\n          var xj = ring[j][0],\n              yj = ring[j][1];\n          var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 && (xi - pt[0]) * (xj - pt[0]) <= 0 && (yi - pt[1]) * (yj - pt[1]) <= 0;\n          if (onBoundary) return !ignoreBoundary;\n          var intersect = yi > pt[1] !== yj > pt[1] && pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi;\n          if (intersect) isInside = !isInside;\n      }\n      return isInside;\n  }\n  function inBBox(pt, bbox) {\n      return bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1];\n  }\n\n  function pointInPolygon(sourceArray, geojsonPolygon) {\n  \tvar pointsInside = [];\n  \tvar pointsOutside = [];\n  \tif (geojsonPolygon.type !== 'Feature') {\n  \t\tgeojsonPolygon = {\n  \t\t\t\"type\": \"Feature\",\n  \t\t\t\"properties\": {},\n  \t\t\t\"geometry\": geojsonPolygon\n  \t\t};\n  \t}\n  \tif (geojsonPolygon.geometry.type === 'Polygon' || geojsonPolygon.geometry.type === 'Multipolygon') {\n  \t\tforEach(sourceArray, function (item) {\n  \t\t\tvar Point = markerToFeaturePoint(item);\n  \t\t\tif (booleanPointInPolygon(Point, geojsonPolygon)) {\n  \t\t\t\tpointsInside.push(item);\n  \t\t\t} else {\n  \t\t\t\tpointsOutside.push(item);\n  \t\t\t}\n  \t\t});\n  \t}\n  \treturn {\n  \t\tpointsInside: pointsInside,\n  \t\tpointsOutside: pointsOutside\n  \t};\n  }\n\n  function kinks(featureIn) {\n      var coordinates;\n      var feature$$1;\n      var results = {\n          type: 'FeatureCollection',\n          features: []\n      };\n      if (featureIn.type === 'Feature') {\n          feature$$1 = featureIn.geometry;\n      } else {\n          feature$$1 = featureIn;\n      }\n      if (feature$$1.type === 'LineString') {\n          coordinates = [feature$$1.coordinates];\n      } else if (feature$$1.type === 'MultiLineString') {\n          coordinates = feature$$1.coordinates;\n      } else if (feature$$1.type === 'MultiPolygon') {\n          coordinates = [].concat.apply([], feature$$1.coordinates);\n      } else if (feature$$1.type === 'Polygon') {\n          coordinates = feature$$1.coordinates;\n      } else {\n          throw new Error('Input must be a LineString, MultiLineString, ' + 'Polygon, or MultiPolygon Feature or Geometry');\n      }\n      coordinates.forEach(function (line1) {\n          coordinates.forEach(function (line2) {\n              for (var i = 0; i < line1.length - 1; i++) {\n                  for (var k = i; k < line2.length - 1; k++) {\n                      if (line1 === line2) {\n                          if (Math.abs(i - k) === 1) {\n                              continue;\n                          }\n                          if (\n                          i === 0 && k === line1.length - 2 &&\n                          line1[i][0] === line1[line1.length - 1][0] && line1[i][1] === line1[line1.length - 1][1]) {\n                              continue;\n                          }\n                      }\n                      var intersection = lineIntersects(line1[i][0], line1[i][1], line1[i + 1][0], line1[i + 1][1], line2[k][0], line2[k][1], line2[k + 1][0], line2[k + 1][1]);\n                      if (intersection) {\n                          results.features.push(point([intersection[0], intersection[1]]));\n                      }\n                  }\n              }\n          });\n      });\n      return results;\n  }\n  function lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {\n      var denominator,\n          a,\n          b,\n          numerator1,\n          numerator2,\n          result = {\n          x: null,\n          y: null,\n          onLine1: false,\n          onLine2: false\n      };\n      denominator = (line2EndY - line2StartY) * (line1EndX - line1StartX) - (line2EndX - line2StartX) * (line1EndY - line1StartY);\n      if (denominator === 0) {\n          if (result.x !== null && result.y !== null) {\n              return result;\n          } else {\n              return false;\n          }\n      }\n      a = line1StartY - line2StartY;\n      b = line1StartX - line2StartX;\n      numerator1 = (line2EndX - line2StartX) * a - (line2EndY - line2StartY) * b;\n      numerator2 = (line1EndX - line1StartX) * a - (line1EndY - line1StartY) * b;\n      a = numerator1 / denominator;\n      b = numerator2 / denominator;\n      result.x = line1StartX + a * (line1EndX - line1StartX);\n      result.y = line1StartY + a * (line1EndY - line1StartY);\n      if (a >= 0 && a <= 1) {\n          result.onLine1 = true;\n      }\n      if (b >= 0 && b <= 1) {\n          result.onLine2 = true;\n      }\n      if (result.onLine1 && result.onLine2) {\n          return [result.x, result.y];\n      } else {\n          return false;\n      }\n  }\n\n  function kinks$1(object) {\n    var Feature;\n    if (object instanceof google.maps.Polyline || object instanceof google.maps.Polygon) {\n      var geometry = Wicket().fromObject(object).toJson();\n      Feature = {\n        type: \"Feature\",\n        properties: {},\n        geometry: geometry\n      };\n    } else if (object.type && object.type === 'Feature' && object.geometry) {\n      Feature = object;\n    } else {\n      Feature = polygonToFeaturePolygon(object);\n    }\n    return kinks(Feature);\n  }\n\n  function feature$5(geometry, properties, options) {\n      options = options || {};\n      if (!isObject$4(options)) throw new Error('options is invalid');\n      var bbox = options.bbox;\n      var id = options.id;\n      if (geometry === undefined) throw new Error('geometry is required');\n      if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n      if (bbox) validateBBox$2(bbox);\n      if (id) validateId$2(id);\n      var feat = { type: 'Feature' };\n      if (id) feat.id = id;\n      if (bbox) feat.bbox = bbox;\n      feat.properties = properties || {};\n      feat.geometry = geometry;\n      return feat;\n  }\n  function polygon$3(coordinates, properties, options) {\n      if (!coordinates) throw new Error('coordinates is required');\n      for (var i = 0; i < coordinates.length; i++) {\n          var ring = coordinates[i];\n          if (ring.length < 4) {\n              throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n          }\n          for (var j = 0; j < ring[ring.length - 1].length; j++) {\n              if (i === 0 && j === 0 && !isNumber$3(ring[0][0]) || !isNumber$3(ring[0][1])) throw new Error('coordinates must contain numbers');\n              if (ring[ring.length - 1][j] !== ring[0][j]) {\n                  throw new Error('First and last Position are not equivalent.');\n              }\n          }\n      }\n      return feature$5({\n          type: 'Polygon',\n          coordinates: coordinates\n      }, properties, options);\n  }\n  function featureCollection$3(features, options) {\n      options = options || {};\n      if (!isObject$4(options)) throw new Error('options is invalid');\n      var bbox = options.bbox;\n      var id = options.id;\n      if (!features) throw new Error('No features passed');\n      if (!Array.isArray(features)) throw new Error('features must be an Array');\n      if (bbox) validateBBox$2(bbox);\n      if (id) validateId$2(id);\n      var fc = { type: 'FeatureCollection' };\n      if (id) fc.id = id;\n      if (bbox) fc.bbox = bbox;\n      fc.features = features;\n      return fc;\n  }\n  function isNumber$3(num) {\n      return !isNaN(num) && num !== null && !Array.isArray(num);\n  }\n  function isObject$4(input) {\n      return !!input && input.constructor === Object;\n  }\n  function validateBBox$2(bbox) {\n      if (!bbox) throw new Error('bbox is required');\n      if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n      if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n      bbox.forEach(function (num) {\n          if (!isNumber$3(num)) throw new Error('bbox must only contain numbers');\n      });\n  }\n  function validateId$2(id) {\n      if (!id) throw new Error('id is required');\n      if (['string', 'number'].indexOf(typeof id === 'undefined' ? 'undefined' : _typeof(id)) === -1) throw new Error('id must be a number or a string');\n  }\n\n  function featureEach$2(geojson, callback) {\n      if (geojson.type === 'Feature') {\n          callback(geojson, 0);\n      } else if (geojson.type === 'FeatureCollection') {\n          for (var i = 0; i < geojson.features.length; i++) {\n              if (callback(geojson.features[i], i) === false) break;\n          }\n      }\n  }\n  function geomEach$2(geojson, callback) {\n      var i,\n          j,\n          g,\n          geometry,\n          stopG,\n          geometryMaybeCollection,\n          isGeometryCollection,\n          featureProperties,\n          featureBBox,\n          featureId,\n          featureIndex = 0,\n          isFeatureCollection = geojson.type === 'FeatureCollection',\n          isFeature = geojson.type === 'Feature',\n          stop = isFeatureCollection ? geojson.features.length : 1;\n      for (i = 0; i < stop; i++) {\n          geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;\n          featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};\n          featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : undefined;\n          featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : undefined;\n          isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n          stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n          for (g = 0; g < stopG; g++) {\n              geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n              if (geometry === null) {\n                  if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                  continue;\n              }\n              switch (geometry.type) {\n                  case 'Point':\n                  case 'LineString':\n                  case 'MultiPoint':\n                  case 'Polygon':\n                  case 'MultiLineString':\n                  case 'MultiPolygon':\n                      {\n                          if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                          break;\n                      }\n                  case 'GeometryCollection':\n                      {\n                          for (j = 0; j < geometry.geometries.length; j++) {\n                              if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                          }\n                          break;\n                      }\n                  default:\n                      throw new Error('Unknown Geometry Type');\n              }\n          }\n          featureIndex++;\n      }\n  }\n  function flattenEach$2(geojson, callback) {\n      geomEach$2(geojson, function (geometry, featureIndex, properties, bbox, id) {\n          var type = geometry === null ? null : geometry.type;\n          switch (type) {\n              case null:\n              case 'Point':\n              case 'LineString':\n              case 'Polygon':\n                  if (callback(feature$5(geometry, properties, { bbox: bbox, id: id }), featureIndex, 0) === false) return false;\n                  return;\n          }\n          var geomType;\n          switch (type) {\n              case 'MultiPoint':\n                  geomType = 'Point';\n                  break;\n              case 'MultiLineString':\n                  geomType = 'LineString';\n                  break;\n              case 'MultiPolygon':\n                  geomType = 'Polygon';\n                  break;\n          }\n          for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n              var coordinate = geometry.coordinates[multiFeatureIndex];\n              var geom = {\n                  type: geomType,\n                  coordinates: coordinate\n              };\n              if (callback(feature$5(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n          }\n      });\n  }\n\n  var quickselect = partialSort;\n  function partialSort(arr, k, left, right, compare) {\n      left = left || 0;\n      right = right || arr.length - 1;\n      compare = compare || defaultCompare;\n      while (right > left) {\n          if (right - left > 600) {\n              var n = right - left + 1;\n              var m = k - left + 1;\n              var z = Math.log(n);\n              var s = 0.5 * Math.exp(2 * z / 3);\n              var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n              var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n              var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n              partialSort(arr, k, newLeft, newRight, compare);\n          }\n          var t = arr[k];\n          var i = left;\n          var j = right;\n          swap(arr, left, k);\n          if (compare(arr[right], t) > 0) swap(arr, left, right);\n          while (i < j) {\n              swap(arr, i, j);\n              i++;\n              j--;\n              while (compare(arr[i], t) < 0) {\n                  i++;\n              }while (compare(arr[j], t) > 0) {\n                  j--;\n              }\n          }\n          if (compare(arr[left], t) === 0) swap(arr, left, j);else {\n              j++;\n              swap(arr, j, right);\n          }\n          if (j <= k) left = j + 1;\n          if (k <= j) right = j - 1;\n      }\n  }\n  function swap(arr, i, j) {\n      var tmp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = tmp;\n  }\n  function defaultCompare(a, b) {\n      return a < b ? -1 : a > b ? 1 : 0;\n  }\n\n  var quickselect$1 = /*#__PURE__*/Object.freeze({\n    default: quickselect,\n    __moduleExports: quickselect\n  });\n\n  var quickselect$2 = ( quickselect$1 && quickselect ) || quickselect$1;\n\n  var rbush_1 = rbush;\n  function rbush(maxEntries, format) {\n      if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n      this._maxEntries = Math.max(4, maxEntries || 9);\n      this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n      if (format) {\n          this._initFormat(format);\n      }\n      this.clear();\n  }\n  rbush.prototype = {\n      all: function all() {\n          return this._all(this.data, []);\n      },\n      search: function search(bbox) {\n          var node = this.data,\n              result = [],\n              toBBox = this.toBBox;\n          if (!intersects(bbox, node)) return result;\n          var nodesToSearch = [],\n              i,\n              len,\n              child,\n              childBBox;\n          while (node) {\n              for (i = 0, len = node.children.length; i < len; i++) {\n                  child = node.children[i];\n                  childBBox = node.leaf ? toBBox(child) : child;\n                  if (intersects(bbox, childBBox)) {\n                      if (node.leaf) result.push(child);else if (contains$1(bbox, childBBox)) this._all(child, result);else nodesToSearch.push(child);\n                  }\n              }\n              node = nodesToSearch.pop();\n          }\n          return result;\n      },\n      collides: function collides(bbox) {\n          var node = this.data,\n              toBBox = this.toBBox;\n          if (!intersects(bbox, node)) return false;\n          var nodesToSearch = [],\n              i,\n              len,\n              child,\n              childBBox;\n          while (node) {\n              for (i = 0, len = node.children.length; i < len; i++) {\n                  child = node.children[i];\n                  childBBox = node.leaf ? toBBox(child) : child;\n                  if (intersects(bbox, childBBox)) {\n                      if (node.leaf || contains$1(bbox, childBBox)) return true;\n                      nodesToSearch.push(child);\n                  }\n              }\n              node = nodesToSearch.pop();\n          }\n          return false;\n      },\n      load: function load(data) {\n          if (!(data && data.length)) return this;\n          if (data.length < this._minEntries) {\n              for (var i = 0, len = data.length; i < len; i++) {\n                  this.insert(data[i]);\n              }\n              return this;\n          }\n          var node = this._build(data.slice(), 0, data.length - 1, 0);\n          if (!this.data.children.length) {\n              this.data = node;\n          } else if (this.data.height === node.height) {\n              this._splitRoot(this.data, node);\n          } else {\n              if (this.data.height < node.height) {\n                  var tmpNode = this.data;\n                  this.data = node;\n                  node = tmpNode;\n              }\n              this._insert(node, this.data.height - node.height - 1, true);\n          }\n          return this;\n      },\n      insert: function insert(item) {\n          if (item) this._insert(item, this.data.height - 1);\n          return this;\n      },\n      clear: function clear() {\n          this.data = createNode([]);\n          return this;\n      },\n      remove: function remove(item, equalsFn) {\n          if (!item) return this;\n          var node = this.data,\n              bbox = this.toBBox(item),\n              path = [],\n              indexes = [],\n              i,\n              parent,\n              index,\n              goingUp;\n          while (node || path.length) {\n              if (!node) {\n                  node = path.pop();\n                  parent = path[path.length - 1];\n                  i = indexes.pop();\n                  goingUp = true;\n              }\n              if (node.leaf) {\n                  index = findItem(item, node.children, equalsFn);\n                  if (index !== -1) {\n                      node.children.splice(index, 1);\n                      path.push(node);\n                      this._condense(path);\n                      return this;\n                  }\n              }\n              if (!goingUp && !node.leaf && contains$1(node, bbox)) {\n                  path.push(node);\n                  indexes.push(i);\n                  i = 0;\n                  parent = node;\n                  node = node.children[0];\n              } else if (parent) {\n                  i++;\n                  node = parent.children[i];\n                  goingUp = false;\n              } else node = null;\n          }\n          return this;\n      },\n      toBBox: function toBBox(item) {\n          return item;\n      },\n      compareMinX: compareNodeMinX,\n      compareMinY: compareNodeMinY,\n      toJSON: function toJSON() {\n          return this.data;\n      },\n      fromJSON: function fromJSON(data) {\n          this.data = data;\n          return this;\n      },\n      _all: function _all(node, result) {\n          var nodesToSearch = [];\n          while (node) {\n              if (node.leaf) result.push.apply(result, node.children);else nodesToSearch.push.apply(nodesToSearch, node.children);\n              node = nodesToSearch.pop();\n          }\n          return result;\n      },\n      _build: function _build(items, left, right, height) {\n          var N = right - left + 1,\n              M = this._maxEntries,\n              node;\n          if (N <= M) {\n              node = createNode(items.slice(left, right + 1));\n              calcBBox(node, this.toBBox);\n              return node;\n          }\n          if (!height) {\n              height = Math.ceil(Math.log(N) / Math.log(M));\n              M = Math.ceil(N / Math.pow(M, height - 1));\n          }\n          node = createNode([]);\n          node.leaf = false;\n          node.height = height;\n          var N2 = Math.ceil(N / M),\n              N1 = N2 * Math.ceil(Math.sqrt(M)),\n              i,\n              j,\n              right2,\n              right3;\n          multiSelect(items, left, right, N1, this.compareMinX);\n          for (i = left; i <= right; i += N1) {\n              right2 = Math.min(i + N1 - 1, right);\n              multiSelect(items, i, right2, N2, this.compareMinY);\n              for (j = i; j <= right2; j += N2) {\n                  right3 = Math.min(j + N2 - 1, right2);\n                  node.children.push(this._build(items, j, right3, height - 1));\n              }\n          }\n          calcBBox(node, this.toBBox);\n          return node;\n      },\n      _chooseSubtree: function _chooseSubtree(bbox, node, level, path) {\n          var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n          while (true) {\n              path.push(node);\n              if (node.leaf || path.length - 1 === level) break;\n              minArea = minEnlargement = Infinity;\n              for (i = 0, len = node.children.length; i < len; i++) {\n                  child = node.children[i];\n                  area = bboxArea(child);\n                  enlargement = enlargedArea(bbox, child) - area;\n                  if (enlargement < minEnlargement) {\n                      minEnlargement = enlargement;\n                      minArea = area < minArea ? area : minArea;\n                      targetNode = child;\n                  } else if (enlargement === minEnlargement) {\n                      if (area < minArea) {\n                          minArea = area;\n                          targetNode = child;\n                      }\n                  }\n              }\n              node = targetNode || node.children[0];\n          }\n          return node;\n      },\n      _insert: function _insert(item, level, isNode) {\n          var toBBox = this.toBBox,\n              bbox = isNode ? item : toBBox(item),\n              insertPath = [];\n          var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n          node.children.push(item);\n          extend$1(node, bbox);\n          while (level >= 0) {\n              if (insertPath[level].children.length > this._maxEntries) {\n                  this._split(insertPath, level);\n                  level--;\n              } else break;\n          }\n          this._adjustParentBBoxes(bbox, insertPath, level);\n      },\n      _split: function _split(insertPath, level) {\n          var node = insertPath[level],\n              M = node.children.length,\n              m = this._minEntries;\n          this._chooseSplitAxis(node, m, M);\n          var splitIndex = this._chooseSplitIndex(node, m, M);\n          var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n          newNode.height = node.height;\n          newNode.leaf = node.leaf;\n          calcBBox(node, this.toBBox);\n          calcBBox(newNode, this.toBBox);\n          if (level) insertPath[level - 1].children.push(newNode);else this._splitRoot(node, newNode);\n      },\n      _splitRoot: function _splitRoot(node, newNode) {\n          this.data = createNode([node, newNode]);\n          this.data.height = node.height + 1;\n          this.data.leaf = false;\n          calcBBox(this.data, this.toBBox);\n      },\n      _chooseSplitIndex: function _chooseSplitIndex(node, m, M) {\n          var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n          minOverlap = minArea = Infinity;\n          for (i = m; i <= M - m; i++) {\n              bbox1 = distBBox(node, 0, i, this.toBBox);\n              bbox2 = distBBox(node, i, M, this.toBBox);\n              overlap = intersectionArea(bbox1, bbox2);\n              area = bboxArea(bbox1) + bboxArea(bbox2);\n              if (overlap < minOverlap) {\n                  minOverlap = overlap;\n                  index = i;\n                  minArea = area < minArea ? area : minArea;\n              } else if (overlap === minOverlap) {\n                  if (area < minArea) {\n                      minArea = area;\n                      index = i;\n                  }\n              }\n          }\n          return index;\n      },\n      _chooseSplitAxis: function _chooseSplitAxis(node, m, M) {\n          var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n              compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n              xMargin = this._allDistMargin(node, m, M, compareMinX),\n              yMargin = this._allDistMargin(node, m, M, compareMinY);\n          if (xMargin < yMargin) node.children.sort(compareMinX);\n      },\n      _allDistMargin: function _allDistMargin(node, m, M, compare) {\n          node.children.sort(compare);\n          var toBBox = this.toBBox,\n              leftBBox = distBBox(node, 0, m, toBBox),\n              rightBBox = distBBox(node, M - m, M, toBBox),\n              margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n              i,\n              child;\n          for (i = m; i < M - m; i++) {\n              child = node.children[i];\n              extend$1(leftBBox, node.leaf ? toBBox(child) : child);\n              margin += bboxMargin(leftBBox);\n          }\n          for (i = M - m - 1; i >= m; i--) {\n              child = node.children[i];\n              extend$1(rightBBox, node.leaf ? toBBox(child) : child);\n              margin += bboxMargin(rightBBox);\n          }\n          return margin;\n      },\n      _adjustParentBBoxes: function _adjustParentBBoxes(bbox, path, level) {\n          for (var i = level; i >= 0; i--) {\n              extend$1(path[i], bbox);\n          }\n      },\n      _condense: function _condense(path) {\n          for (var i = path.length - 1, siblings; i >= 0; i--) {\n              if (path[i].children.length === 0) {\n                  if (i > 0) {\n                      siblings = path[i - 1].children;\n                      siblings.splice(siblings.indexOf(path[i]), 1);\n                  } else this.clear();\n              } else calcBBox(path[i], this.toBBox);\n          }\n      },\n      _initFormat: function _initFormat(format) {\n          var compareArr = ['return a', ' - b', ';'];\n          this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n          this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n          this.toBBox = new Function('a', 'return {minX: a' + format[0] + ', minY: a' + format[1] + ', maxX: a' + format[2] + ', maxY: a' + format[3] + '};');\n      }\n  };\n  function findItem(item, items, equalsFn) {\n      if (!equalsFn) return items.indexOf(item);\n      for (var i = 0; i < items.length; i++) {\n          if (equalsFn(item, items[i])) return i;\n      }\n      return -1;\n  }\n  function calcBBox(node, toBBox) {\n      distBBox(node, 0, node.children.length, toBBox, node);\n  }\n  function distBBox(node, k, p, toBBox, destNode) {\n      if (!destNode) destNode = createNode(null);\n      destNode.minX = Infinity;\n      destNode.minY = Infinity;\n      destNode.maxX = -Infinity;\n      destNode.maxY = -Infinity;\n      for (var i = k, child; i < p; i++) {\n          child = node.children[i];\n          extend$1(destNode, node.leaf ? toBBox(child) : child);\n      }\n      return destNode;\n  }\n  function extend$1(a, b) {\n      a.minX = Math.min(a.minX, b.minX);\n      a.minY = Math.min(a.minY, b.minY);\n      a.maxX = Math.max(a.maxX, b.maxX);\n      a.maxY = Math.max(a.maxY, b.maxY);\n      return a;\n  }\n  function compareNodeMinX(a, b) {\n      return a.minX - b.minX;\n  }\n  function compareNodeMinY(a, b) {\n      return a.minY - b.minY;\n  }\n  function bboxArea(a) {\n      return (a.maxX - a.minX) * (a.maxY - a.minY);\n  }\n  function bboxMargin(a) {\n      return a.maxX - a.minX + (a.maxY - a.minY);\n  }\n  function enlargedArea(a, b) {\n      return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n  }\n  function intersectionArea(a, b) {\n      var minX = Math.max(a.minX, b.minX),\n          minY = Math.max(a.minY, b.minY),\n          maxX = Math.min(a.maxX, b.maxX),\n          maxY = Math.min(a.maxY, b.maxY);\n      return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);\n  }\n  function contains$1(a, b) {\n      return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;\n  }\n  function intersects(a, b) {\n      return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;\n  }\n  function createNode(children) {\n      return {\n          children: children,\n          height: 1,\n          leaf: true,\n          minX: Infinity,\n          minY: Infinity,\n          maxX: -Infinity,\n          maxY: -Infinity\n      };\n  }\n  function multiSelect(arr, left, right, n, compare) {\n      var stack = [left, right],\n          mid;\n      while (stack.length) {\n          right = stack.pop();\n          left = stack.pop();\n          if (right - left <= n) continue;\n          mid = left + Math.ceil((right - left) / n / 2) * n;\n          quickselect$2(arr, mid, left, right, compare);\n          stack.push(left, mid, mid, right);\n      }\n  }\n\n  function geomEach$3(geojson, callback) {\n      var i,\n          j,\n          g,\n          geometry,\n          stopG,\n          geometryMaybeCollection,\n          isGeometryCollection,\n          featureProperties,\n          featureBBox,\n          featureId,\n          featureIndex = 0,\n          isFeatureCollection = geojson.type === 'FeatureCollection',\n          isFeature = geojson.type === 'Feature',\n          stop = isFeatureCollection ? geojson.features.length : 1;\n      for (i = 0; i < stop; i++) {\n          geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;\n          featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};\n          featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : undefined;\n          featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : undefined;\n          isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n          stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n          for (g = 0; g < stopG; g++) {\n              geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n              if (geometry === null) {\n                  if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                  continue;\n              }\n              switch (geometry.type) {\n                  case 'Point':\n                  case 'LineString':\n                  case 'MultiPoint':\n                  case 'Polygon':\n                  case 'MultiLineString':\n                  case 'MultiPolygon':\n                      {\n                          if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                          break;\n                      }\n                  case 'GeometryCollection':\n                      {\n                          for (j = 0; j < geometry.geometries.length; j++) {\n                              if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                          }\n                          break;\n                      }\n                  default:\n                      throw new Error('Unknown Geometry Type');\n              }\n          }\n          featureIndex++;\n      }\n  }\n  function geomReduce$3(geojson, callback, initialValue) {\n      var previousValue = initialValue;\n      geomEach$3(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n          if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n      });\n      return previousValue;\n  }\n\n  function area$1(geojson) {\n      return geomReduce$3(geojson, function (value, geom) {\n          return value + calculateArea(geom);\n      }, 0);\n  }\n  var RADIUS = 6378137;\n  function calculateArea(geojson) {\n      var area = 0,\n          i;\n      switch (geojson.type) {\n          case 'Polygon':\n              return polygonArea(geojson.coordinates);\n          case 'MultiPolygon':\n              for (i = 0; i < geojson.coordinates.length; i++) {\n                  area += polygonArea(geojson.coordinates[i]);\n              }\n              return area;\n          case 'Point':\n          case 'MultiPoint':\n          case 'LineString':\n          case 'MultiLineString':\n              return 0;\n          case 'GeometryCollection':\n              for (i = 0; i < geojson.geometries.length; i++) {\n                  area += calculateArea(geojson.geometries[i]);\n              }\n              return area;\n      }\n  }\n  function polygonArea(coords) {\n      var area = 0;\n      if (coords && coords.length > 0) {\n          area += Math.abs(ringArea(coords[0]));\n          for (var i = 1; i < coords.length; i++) {\n              area -= Math.abs(ringArea(coords[i]));\n          }\n      }\n      return area;\n  }\n  function ringArea(coords) {\n      var p1;\n      var p2;\n      var p3;\n      var lowerIndex;\n      var middleIndex;\n      var upperIndex;\n      var i;\n      var area = 0;\n      var coordsLength = coords.length;\n      if (coordsLength > 2) {\n          for (i = 0; i < coordsLength; i++) {\n              if (i === coordsLength - 2) {\n                  lowerIndex = coordsLength - 2;\n                  middleIndex = coordsLength - 1;\n                  upperIndex = 0;\n              } else if (i === coordsLength - 1) {\n                  lowerIndex = coordsLength - 1;\n                  middleIndex = 0;\n                  upperIndex = 1;\n              } else {\n                  lowerIndex = i;\n                  middleIndex = i + 1;\n                  upperIndex = i + 2;\n              }\n              p1 = coords[lowerIndex];\n              p2 = coords[middleIndex];\n              p3 = coords[upperIndex];\n              area += (rad(p3[0]) - rad(p1[0])) * Math.sin(rad(p2[1]));\n          }\n          area = area * RADIUS * RADIUS / 2;\n      }\n      return area;\n  }\n  function rad(_) {\n      return _ * Math.PI / 180;\n  }\n\n  function getCoord$2(coord) {\n      if (!coord) throw new Error('coord is required');\n      if (coord.type === 'Feature' && coord.geometry !== null && coord.geometry.type === 'Point') return coord.geometry.coordinates;\n      if (coord.type === 'Point') return coord.coordinates;\n      if (Array.isArray(coord) && coord.length >= 2 && coord[0].length === undefined && coord[1].length === undefined) return coord;\n      throw new Error('coord must be GeoJSON Point or an Array of numbers');\n  }\n  function getCoords$2(coords) {\n      if (!coords) throw new Error('coords is required');\n      if (coords.type === 'Feature' && coords.geometry !== null) return coords.geometry.coordinates;\n      if (coords.coordinates) return coords.coordinates;\n      if (Array.isArray(coords)) return coords;\n      throw new Error('coords must be GeoJSON Feature, Geometry Object or an Array');\n  }\n\n  function booleanPointInPolygon$1(point, polygon, options) {\n      options = options || {};\n      if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object') throw new Error('options is invalid');\n      var ignoreBoundary = options.ignoreBoundary;\n      if (!point) throw new Error('point is required');\n      if (!polygon) throw new Error('polygon is required');\n      var pt = getCoord$2(point);\n      var polys = getCoords$2(polygon);\n      var type = polygon.geometry ? polygon.geometry.type : polygon.type;\n      var bbox = polygon.bbox;\n      if (bbox && inBBox$1(pt, bbox) === false) return false;\n      if (type === 'Polygon') polys = [polys];\n      for (var i = 0, insidePoly = false; i < polys.length && !insidePoly; i++) {\n          if (inRing$1(pt, polys[i][0], ignoreBoundary)) {\n              var inHole = false;\n              var k = 1;\n              while (k < polys[i].length && !inHole) {\n                  if (inRing$1(pt, polys[i][k], !ignoreBoundary)) {\n                      inHole = true;\n                  }\n                  k++;\n              }\n              if (!inHole) insidePoly = true;\n          }\n      }\n      return insidePoly;\n  }\n  function inRing$1(pt, ring, ignoreBoundary) {\n      var isInside = false;\n      if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) ring = ring.slice(0, ring.length - 1);\n      for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n          var xi = ring[i][0],\n              yi = ring[i][1];\n          var xj = ring[j][0],\n              yj = ring[j][1];\n          var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 && (xi - pt[0]) * (xj - pt[0]) <= 0 && (yi - pt[1]) * (yj - pt[1]) <= 0;\n          if (onBoundary) return !ignoreBoundary;\n          var intersect = yi > pt[1] !== yj > pt[1] && pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi;\n          if (intersect) isInside = !isInside;\n      }\n      return isInside;\n  }\n  function inBBox$1(pt, bbox) {\n      return bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1];\n  }\n\n  var isects = function isects(feature, filterFn, useSpatialIndex) {\n      if (feature.geometry.type !== 'Polygon') throw new Error('The input feature must be a Polygon');\n      if (useSpatialIndex === undefined) useSpatialIndex = 1;\n      var coord = feature.geometry.coordinates;\n      var output = [];\n      var seen = {};\n      if (useSpatialIndex) {\n          var allEdgesAsRbushTreeItems = [];\n          for (var ring0 = 0; ring0 < coord.length; ring0++) {\n              for (var edge0 = 0; edge0 < coord[ring0].length - 1; edge0++) {\n                  allEdgesAsRbushTreeItems.push(rbushTreeItem(ring0, edge0));\n              }\n          }\n          var tree = rbush_1();\n          tree.load(allEdgesAsRbushTreeItems);\n      }\n      for (var ringA = 0; ringA < coord.length; ringA++) {\n          for (var edgeA = 0; edgeA < coord[ringA].length - 1; edgeA++) {\n              if (useSpatialIndex) {\n                  var bboxOverlaps = tree.search(rbushTreeItem(ringA, edgeA));\n                  bboxOverlaps.forEach(function (bboxIsect) {\n                      var ring1 = bboxIsect.ring;\n                      var edge1 = bboxIsect.edge;\n                      ifIsectAddToOutput(ringA, edgeA, ring1, edge1);\n                  });\n              } else {\n                  for (var ring1 = 0; ring1 < coord.length; ring1++) {\n                      for (var edge1 = 0; edge1 < coord[ring1].length - 1; edge1++) {\n                          ifIsectAddToOutput(ringA, edgeA, ring1, edge1);\n                      }\n                  }\n              }\n          }\n      }\n      if (!filterFn) output = { type: 'Feature', geometry: { type: 'MultiPoint', coordinates: output } };\n      return output;\n      function ifIsectAddToOutput(ring0, edge0, ring1, edge1) {\n          var start0 = coord[ring0][edge0];\n          var end0 = coord[ring0][edge0 + 1];\n          var start1 = coord[ring1][edge1];\n          var end1 = coord[ring1][edge1 + 1];\n          var isect = intersect(start0, end0, start1, end1);\n          if (isect === null) return;\n          var frac0;\n          var frac1;\n          if (end0[0] !== start0[0]) {\n              frac0 = (isect[0] - start0[0]) / (end0[0] - start0[0]);\n          } else {\n              frac0 = (isect[1] - start0[1]) / (end0[1] - start0[1]);\n          }\n          if (end1[0] !== start1[0]) {\n              frac1 = (isect[0] - start1[0]) / (end1[0] - start1[0]);\n          } else {\n              frac1 = (isect[1] - start1[1]) / (end1[1] - start1[1]);\n          }\n          if (frac0 >= 1 || frac0 <= 0 || frac1 >= 1 || frac1 <= 0) return;\n          var key = isect;\n          var unique = !seen[key];\n          if (unique) {\n              seen[key] = true;\n          }\n          if (filterFn) {\n              output.push(filterFn(isect, ring0, edge0, start0, end0, frac0, ring1, edge1, start1, end1, frac1, unique));\n          } else {\n              output.push(isect);\n          }\n      }\n      function rbushTreeItem(ring, edge) {\n          var start = coord[ring][edge];\n          var end = coord[ring][edge + 1];\n          var minX;\n          var maxX;\n          var minY;\n          var maxY;\n          if (start[0] < end[0]) {\n              minX = start[0];\n              maxX = end[0];\n          } else {\n              minX = end[0];\n              maxX = start[0];\n          }\n          if (start[1] < end[1]) {\n              minY = start[1];\n              maxY = end[1];\n          } else {\n              minY = end[1];\n              maxY = start[1];\n          }\n          return { minX: minX, minY: minY, maxX: maxX, maxY: maxY, ring: ring, edge: edge };\n      }\n  };\n  function intersect(start0, end0, start1, end1) {\n      if (equalArrays$1(start0, start1) || equalArrays$1(start0, end1) || equalArrays$1(end0, start1) || equalArrays$1(end1, start1)) return null;\n      var x0 = start0[0],\n          y0 = start0[1],\n          x1 = end0[0],\n          y1 = end0[1],\n          x2 = start1[0],\n          y2 = start1[1],\n          x3 = end1[0],\n          y3 = end1[1];\n      var denom = (x0 - x1) * (y2 - y3) - (y0 - y1) * (x2 - x3);\n      if (denom === 0) return null;\n      var x4 = ((x0 * y1 - y0 * x1) * (x2 - x3) - (x0 - x1) * (x2 * y3 - y2 * x3)) / denom;\n      var y4 = ((x0 * y1 - y0 * x1) * (y2 - y3) - (y0 - y1) * (x2 * y3 - y2 * x3)) / denom;\n      return [x4, y4];\n  }\n  function equalArrays$1(array1, array2) {\n      if (!array1 || !array2) return false;\n      if (array1.length !== array2.length) return false;\n      for (var i = 0, l = array1.length; i < l; i++) {\n          if (array1[i] instanceof Array && array2[i] instanceof Array) {\n              if (!equalArrays$1(array1[i], array2[i])) return false;\n          } else if (array1[i] !== array2[i]) {\n              return false;\n          }\n      }\n      return true;\n  }\n  var simplepolygon = function simplepolygon(feature) {\n      if (feature.type != 'Feature') throw new Error('The input must a geojson object of type Feature');\n      if (feature.geometry === undefined || feature.geometry == null) throw new Error('The input must a geojson object with a non-empty geometry');\n      if (feature.geometry.type != 'Polygon') throw new Error('The input must be a geojson Polygon');\n      var numRings = feature.geometry.coordinates.length;\n      var vertices = [];\n      for (var i = 0; i < numRings; i++) {\n          var ring = feature.geometry.coordinates[i];\n          if (!equalArrays$2(ring[0], ring[ring.length - 1])) {\n              ring.push(ring[0]);\n          }\n          vertices.push.apply(vertices, ring.slice(0, ring.length - 1));\n      }\n      if (!isUnique(vertices)) throw new Error('The input polygon may not have duplicate vertices (except for the first and last vertex of each ring)');\n      var numvertices = vertices.length;\n      var selfIsectsData = isects(feature, function filterFn(isect, ring0, edge0, start0, end0, frac0, ring1, edge1, start1, end1, frac1, unique) {\n          return [isect, ring0, edge0, start0, end0, frac0, ring1, edge1, start1, end1, frac1, unique];\n      });\n      var numSelfIsect = selfIsectsData.length;\n      if (numSelfIsect == 0) {\n          var outputFeatureArray = [];\n          for (var i = 0; i < numRings; i++) {\n              outputFeatureArray.push(polygon$3([feature.geometry.coordinates[i]], { parent: -1, winding: windingOfRing(feature.geometry.coordinates[i]) }));\n          }\n          var output = featureCollection$3(outputFeatureArray);\n          determineParents();\n          setNetWinding();\n          return output;\n      }\n      var pseudoVtxListByRingAndEdge = [];\n      var isectList = [];\n      for (var i = 0; i < numRings; i++) {\n          pseudoVtxListByRingAndEdge.push([]);\n          for (var j = 0; j < feature.geometry.coordinates[i].length - 1; j++) {\n              pseudoVtxListByRingAndEdge[i].push([new PseudoVtx(feature.geometry.coordinates[i][(j + 1).modulo(feature.geometry.coordinates[i].length - 1)], 1, [i, j], [i, (j + 1).modulo(feature.geometry.coordinates[i].length - 1)], undefined)]);\n              isectList.push(new Isect(feature.geometry.coordinates[i][j], [i, (j - 1).modulo(feature.geometry.coordinates[i].length - 1)], [i, j], undefined, undefined, false, true));\n          }\n      }\n      for (var i = 0; i < numSelfIsect; i++) {\n          pseudoVtxListByRingAndEdge[selfIsectsData[i][1]][selfIsectsData[i][2]].push(new PseudoVtx(selfIsectsData[i][0], selfIsectsData[i][5], [selfIsectsData[i][1], selfIsectsData[i][2]], [selfIsectsData[i][6], selfIsectsData[i][7]], undefined));\n          if (selfIsectsData[i][11]) isectList.push(new Isect(selfIsectsData[i][0], [selfIsectsData[i][1], selfIsectsData[i][2]], [selfIsectsData[i][6], selfIsectsData[i][7]], undefined, undefined, true, true));\n      }\n      var numIsect = isectList.length;\n      for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {\n          for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {\n              pseudoVtxListByRingAndEdge[i][j].sort(function (a, b) {\n                  return a.param < b.param ? -1 : 1;\n              });\n          }\n      }\n      var allIsectsAsIsectRbushTreeItem = [];\n      for (var i = 0; i < numIsect; i++) {\n          allIsectsAsIsectRbushTreeItem.push({ minX: isectList[i].coord[0], minY: isectList[i].coord[1], maxX: isectList[i].coord[0], maxY: isectList[i].coord[1], index: i });\n      }\n      var isectRbushTree = rbush_1();\n      isectRbushTree.load(allIsectsAsIsectRbushTreeItem);\n      for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {\n          for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {\n              for (var k = 0; k < pseudoVtxListByRingAndEdge[i][j].length; k++) {\n                  var coordToFind;\n                  if (k == pseudoVtxListByRingAndEdge[i][j].length - 1) {\n                      coordToFind = pseudoVtxListByRingAndEdge[i][(j + 1).modulo(feature.geometry.coordinates[i].length - 1)][0].coord;\n                  } else {\n                      coordToFind = pseudoVtxListByRingAndEdge[i][j][k + 1].coord;\n                  }\n                  var IsectRbushTreeItemFound = isectRbushTree.search({ minX: coordToFind[0], minY: coordToFind[1], maxX: coordToFind[0], maxY: coordToFind[1] })[0];\n                  pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn = IsectRbushTreeItemFound.index;\n              }\n          }\n      }\n      for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {\n          for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {\n              for (var k = 0; k < pseudoVtxListByRingAndEdge[i][j].length; k++) {\n                  var coordToFind = pseudoVtxListByRingAndEdge[i][j][k].coord;\n                  var IsectRbushTreeItemFound = isectRbushTree.search({ minX: coordToFind[0], minY: coordToFind[1], maxX: coordToFind[0], maxY: coordToFind[1] })[0];\n                  var l = IsectRbushTreeItemFound.index;\n                  if (l < numvertices) {\n                      isectList[l].nxtIsectAlongRingAndEdge2 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;\n                  } else {\n                      if (equalArrays$2(isectList[l].ringAndEdge1, pseudoVtxListByRingAndEdge[i][j][k].ringAndEdgeIn)) {\n                          isectList[l].nxtIsectAlongRingAndEdge1 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;\n                      } else {\n                          isectList[l].nxtIsectAlongRingAndEdge2 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;\n                      }\n                  }\n              }\n          }\n      }\n      var queue = [];\n      var i = 0;\n      for (var j = 0; j < numRings; j++) {\n          var leftIsect = i;\n          for (var k = 0; k < feature.geometry.coordinates[j].length - 1; k++) {\n              if (isectList[i].coord[0] < isectList[leftIsect].coord[0]) {\n                  leftIsect = i;\n              }\n              i++;\n          }\n          var isectAfterLeftIsect = isectList[leftIsect].nxtIsectAlongRingAndEdge2;\n          for (var k = 0; k < isectList.length; k++) {\n              if (isectList[k].nxtIsectAlongRingAndEdge1 == leftIsect || isectList[k].nxtIsectAlongRingAndEdge2 == leftIsect) {\n                  var isectBeforeLeftIsect = k;\n                  break;\n              }\n          }\n          var windingAtIsect = isConvex([isectList[isectBeforeLeftIsect].coord, isectList[leftIsect].coord, isectList[isectAfterLeftIsect].coord], true) ? 1 : -1;\n          queue.push({ isect: leftIsect, parent: -1, winding: windingAtIsect });\n      }\n      queue.sort(function (a, b) {\n          return isectList[a.isect].coord > isectList[b.isect].coord ? -1 : 1;\n      });\n      var outputFeatureArray = [];\n      while (queue.length > 0) {\n          var popped = queue.pop();\n          var startIsect = popped.isect;\n          var currentOutputRingParent = popped.parent;\n          var currentOutputRingWinding = popped.winding;\n          var currentOutputRing = outputFeatureArray.length;\n          var currentOutputRingCoords = [isectList[startIsect].coord];\n          var currentIsect = startIsect;\n          if (isectList[startIsect].ringAndEdge1Walkable) {\n              var walkingRingAndEdge = isectList[startIsect].ringAndEdge1;\n              var nxtIsect = isectList[startIsect].nxtIsectAlongRingAndEdge1;\n          } else {\n              var walkingRingAndEdge = isectList[startIsect].ringAndEdge2;\n              var nxtIsect = isectList[startIsect].nxtIsectAlongRingAndEdge2;\n          }\n          while (!equalArrays$2(isectList[startIsect].coord, isectList[nxtIsect].coord)) {\n              currentOutputRingCoords.push(isectList[nxtIsect].coord);\n              var nxtIsectInQueue = undefined;\n              for (var i = 0; i < queue.length; i++) {\n                  if (queue[i].isect == nxtIsect) {\n                      nxtIsectInQueue = i;break;\n                  }\n              }\n              if (nxtIsectInQueue != undefined) {\n                  queue.splice(nxtIsectInQueue, 1);\n              }\n              if (equalArrays$2(walkingRingAndEdge, isectList[nxtIsect].ringAndEdge1)) {\n                  walkingRingAndEdge = isectList[nxtIsect].ringAndEdge2;\n                  isectList[nxtIsect].ringAndEdge2Walkable = false;\n                  if (isectList[nxtIsect].ringAndEdge1Walkable) {\n                      var pushing = { isect: nxtIsect };\n                      if (isConvex([isectList[currentIsect].coord, isectList[nxtIsect].coord, isectList[isectList[nxtIsect].nxtIsectAlongRingAndEdge2].coord], currentOutputRingWinding == 1)) {\n                          pushing.parent = currentOutputRingParent;\n                          pushing.winding = -currentOutputRingWinding;\n                      } else {\n                          pushing.parent = currentOutputRing;\n                          pushing.winding = currentOutputRingWinding;\n                      }\n                      queue.push(pushing);\n                  }\n                  currentIsect = nxtIsect;\n                  nxtIsect = isectList[nxtIsect].nxtIsectAlongRingAndEdge2;\n              } else {\n                  walkingRingAndEdge = isectList[nxtIsect].ringAndEdge1;\n                  isectList[nxtIsect].ringAndEdge1Walkable = false;\n                  if (isectList[nxtIsect].ringAndEdge2Walkable) {\n                      var pushing = { isect: nxtIsect };\n                      if (isConvex([isectList[currentIsect].coord, isectList[nxtIsect].coord, isectList[isectList[nxtIsect].nxtIsectAlongRingAndEdge1].coord], currentOutputRingWinding == 1)) {\n                          pushing.parent = currentOutputRingParent;\n                          pushing.winding = -currentOutputRingWinding;\n                      } else {\n                          pushing.parent = currentOutputRing;\n                          pushing.winding = currentOutputRingWinding;\n                      }\n                      queue.push(pushing);\n                  }\n                  currentIsect = nxtIsect;\n                  nxtIsect = isectList[nxtIsect].nxtIsectAlongRingAndEdge1;\n              }\n          }\n          currentOutputRingCoords.push(isectList[nxtIsect].coord);\n          outputFeatureArray.push(polygon$3([currentOutputRingCoords], { index: currentOutputRing, parent: currentOutputRingParent, winding: currentOutputRingWinding, netWinding: undefined }));\n      }\n      var output = featureCollection$3(outputFeatureArray);\n      determineParents();\n      setNetWinding();\n      function determineParents() {\n          var featuresWithoutParent = [];\n          for (var i = 0; i < output.features.length; i++) {\n              if (output.features[i].properties.parent == -1) featuresWithoutParent.push(i);\n          }\n          if (featuresWithoutParent.length > 1) {\n              for (var i = 0; i < featuresWithoutParent.length; i++) {\n                  var parent = -1;\n                  var parentArea = Infinity;\n                  for (var j = 0; j < output.features.length; j++) {\n                      if (featuresWithoutParent[i] == j) continue;\n                      if (booleanPointInPolygon$1(output.features[featuresWithoutParent[i]].geometry.coordinates[0][0], output.features[j], { ignoreBoundary: true })) {\n                          if (area$1(output.features[j]) < parentArea) {\n                              parent = j;\n                          }\n                      }\n                  }\n                  output.features[featuresWithoutParent[i]].properties.parent = parent;\n              }\n          }\n      }\n      function setNetWinding() {\n          for (var i = 0; i < output.features.length; i++) {\n              if (output.features[i].properties.parent == -1) {\n                  var netWinding = output.features[i].properties.winding;\n                  output.features[i].properties.netWinding = netWinding;\n                  setNetWindingOfChildren(i, netWinding);\n              }\n          }\n      }\n      function setNetWindingOfChildren(parent, ParentNetWinding) {\n          for (var i = 0; i < output.features.length; i++) {\n              if (output.features[i].properties.parent == parent) {\n                  var netWinding = ParentNetWinding + output.features[i].properties.winding;\n                  output.features[i].properties.netWinding = netWinding;\n                  setNetWindingOfChildren(i, netWinding);\n              }\n          }\n      }\n      return output;\n  };\n  var PseudoVtx = function PseudoVtx(coord, param, ringAndEdgeIn, ringAndEdgeOut, nxtIsectAlongEdgeIn) {\n      this.coord = coord;\n      this.param = param;\n      this.ringAndEdgeIn = ringAndEdgeIn;\n      this.ringAndEdgeOut = ringAndEdgeOut;\n      this.nxtIsectAlongEdgeIn = nxtIsectAlongEdgeIn;\n  };\n  var Isect = function Isect(coord, ringAndEdge1, ringAndEdge2, nxtIsectAlongRingAndEdge1, nxtIsectAlongRingAndEdge2, ringAndEdge1Walkable, ringAndEdge2Walkable) {\n      this.coord = coord;\n      this.ringAndEdge1 = ringAndEdge1;\n      this.ringAndEdge2 = ringAndEdge2;\n      this.nxtIsectAlongRingAndEdge1 = nxtIsectAlongRingAndEdge1;\n      this.nxtIsectAlongRingAndEdge2 = nxtIsectAlongRingAndEdge2;\n      this.ringAndEdge1Walkable = ringAndEdge1Walkable;\n      this.ringAndEdge2Walkable = ringAndEdge2Walkable;\n  };\n  function isConvex(pts, righthanded) {\n      if (typeof righthanded === 'undefined') righthanded = true;\n      if (pts.length != 3) throw new Error('This function requires an array of three points [x,y]');\n      var d = (pts[1][0] - pts[0][0]) * (pts[2][1] - pts[0][1]) - (pts[1][1] - pts[0][1]) * (pts[2][0] - pts[0][0]);\n      return d >= 0 == righthanded;\n  }\n  function windingOfRing(ring) {\n      var leftVtx = 0;\n      for (var i = 0; i < ring.length - 1; i++) {\n          if (ring[i][0] < ring[leftVtx][0]) leftVtx = i;\n      }\n      if (isConvex([ring[(leftVtx - 1).modulo(ring.length - 1)], ring[leftVtx], ring[(leftVtx + 1).modulo(ring.length - 1)]], true)) {\n          var winding = 1;\n      } else {\n          var winding = -1;\n      }\n      return winding;\n  }\n  function equalArrays$2(array1, array2) {\n      if (!array1 || !array2) return false;\n      if (array1.length != array2.length) return false;\n      for (var i = 0, l = array1.length; i < l; i++) {\n          if (array1[i] instanceof Array && array2[i] instanceof Array) {\n              if (!equalArrays$2(array1[i], array2[i])) return false;\n          } else if (array1[i] != array2[i]) {\n              return false;\n          }\n      }\n      return true;\n  }\n  Number.prototype.modulo = function (n) {\n      return (this % n + n) % n;\n  };\n  function isUnique(array) {\n      var u = {};\n      var isUnique = 1;\n      for (var i = 0, l = array.length; i < l; ++i) {\n          if (u.hasOwnProperty(array[i])) {\n              isUnique = 0;\n              break;\n          }\n          u[array[i]] = 1;\n      }\n      return isUnique;\n  }\n  function unkinkPolygon(geojson) {\n      var features = [];\n      flattenEach$2(geojson, function (feature) {\n          if (feature.geometry.type !== 'Polygon') return;\n          featureEach$2(simplepolygon(feature), function (poly) {\n              features.push(polygon$3(poly.geometry.coordinates, feature.properties));\n          });\n      });\n      return featureCollection$3(features);\n  }\n\n  function unkink(object) {\n    var polygonFeature = polygonToFeaturePolygon(object);\n    return unkinkPolygon(polygonFeature);\n  }\n\n  function baseFilter(collection, predicate) {\n    var result = [];\n    baseEach(collection, function (value, index, collection) {\n      if (predicate(value, index, collection)) {\n        result.push(value);\n      }\n    });\n    return result;\n  }\n\n  function filter(collection, predicate) {\n    var func = isArray(collection) ? arrayFilter : baseFilter;\n    return func(collection, baseIteratee(predicate, 3));\n  }\n\n  function baseExtremum(array, iteratee, comparator) {\n    var index = -1,\n        length = array.length;\n    while (++index < length) {\n      var value = array[index],\n          current = iteratee(value);\n      if (current != null && (computed === undefined ? current === current && !isSymbol(current) : comparator(current, computed))) {\n        var computed = current,\n            result = value;\n      }\n    }\n    return result;\n  }\n\n  function baseGt(value, other) {\n    return value > other;\n  }\n\n  function max$1(array) {\n    return array && array.length ? baseExtremum(array, identity, baseGt) : undefined;\n  }\n\n  function baseLt(value, other) {\n    return value < other;\n  }\n\n  function min$1(array) {\n    return array && array.length ? baseExtremum(array, identity, baseLt) : undefined;\n  }\n\n  function quickselect$3(arr, k, left, right, compare) {\n      quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare$1);\n  }\n  function quickselectStep(arr, k, left, right, compare) {\n      while (right > left) {\n          if (right - left > 600) {\n              var n = right - left + 1;\n              var m = k - left + 1;\n              var z = Math.log(n);\n              var s = 0.5 * Math.exp(2 * z / 3);\n              var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n              var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n              var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n              quickselectStep(arr, k, newLeft, newRight, compare);\n          }\n          var t = arr[k];\n          var i = left;\n          var j = right;\n          swap$1(arr, left, k);\n          if (compare(arr[right], t) > 0) swap$1(arr, left, right);\n          while (i < j) {\n              swap$1(arr, i, j);\n              i++;\n              j--;\n              while (compare(arr[i], t) < 0) {\n                  i++;\n              }while (compare(arr[j], t) > 0) {\n                  j--;\n              }\n          }\n          if (compare(arr[left], t) === 0) swap$1(arr, left, j);else {\n              j++;\n              swap$1(arr, j, right);\n          }\n          if (j <= k) left = j + 1;\n          if (k <= j) right = j - 1;\n      }\n  }\n  function swap$1(arr, i, j) {\n      var tmp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = tmp;\n  }\n  function defaultCompare$1(a, b) {\n      return a < b ? -1 : a > b ? 1 : 0;\n  }\n\n  function rbush$1(maxEntries, format) {\n      if (!(this instanceof rbush$1)) return new rbush$1(maxEntries, format);\n      this._maxEntries = Math.max(4, maxEntries || 9);\n      this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n      if (format) {\n          this._initFormat(format);\n      }\n      this.clear();\n  }\n  rbush$1.prototype = {\n      all: function all() {\n          return this._all(this.data, []);\n      },\n      search: function search(bbox) {\n          var node = this.data,\n              result = [],\n              toBBox = this.toBBox;\n          if (!intersects$1(bbox, node)) return result;\n          var nodesToSearch = [],\n              i,\n              len,\n              child,\n              childBBox;\n          while (node) {\n              for (i = 0, len = node.children.length; i < len; i++) {\n                  child = node.children[i];\n                  childBBox = node.leaf ? toBBox(child) : child;\n                  if (intersects$1(bbox, childBBox)) {\n                      if (node.leaf) result.push(child);else if (contains$2(bbox, childBBox)) this._all(child, result);else nodesToSearch.push(child);\n                  }\n              }\n              node = nodesToSearch.pop();\n          }\n          return result;\n      },\n      collides: function collides(bbox) {\n          var node = this.data,\n              toBBox = this.toBBox;\n          if (!intersects$1(bbox, node)) return false;\n          var nodesToSearch = [],\n              i,\n              len,\n              child,\n              childBBox;\n          while (node) {\n              for (i = 0, len = node.children.length; i < len; i++) {\n                  child = node.children[i];\n                  childBBox = node.leaf ? toBBox(child) : child;\n                  if (intersects$1(bbox, childBBox)) {\n                      if (node.leaf || contains$2(bbox, childBBox)) return true;\n                      nodesToSearch.push(child);\n                  }\n              }\n              node = nodesToSearch.pop();\n          }\n          return false;\n      },\n      load: function load(data) {\n          if (!(data && data.length)) return this;\n          if (data.length < this._minEntries) {\n              for (var i = 0, len = data.length; i < len; i++) {\n                  this.insert(data[i]);\n              }\n              return this;\n          }\n          var node = this._build(data.slice(), 0, data.length - 1, 0);\n          if (!this.data.children.length) {\n              this.data = node;\n          } else if (this.data.height === node.height) {\n              this._splitRoot(this.data, node);\n          } else {\n              if (this.data.height < node.height) {\n                  var tmpNode = this.data;\n                  this.data = node;\n                  node = tmpNode;\n              }\n              this._insert(node, this.data.height - node.height - 1, true);\n          }\n          return this;\n      },\n      insert: function insert(item) {\n          if (item) this._insert(item, this.data.height - 1);\n          return this;\n      },\n      clear: function clear() {\n          this.data = createNode$1([]);\n          return this;\n      },\n      remove: function remove(item, equalsFn) {\n          if (!item) return this;\n          var node = this.data,\n              bbox = this.toBBox(item),\n              path = [],\n              indexes = [],\n              i,\n              parent,\n              index,\n              goingUp;\n          while (node || path.length) {\n              if (!node) {\n                  node = path.pop();\n                  parent = path[path.length - 1];\n                  i = indexes.pop();\n                  goingUp = true;\n              }\n              if (node.leaf) {\n                  index = findItem$1(item, node.children, equalsFn);\n                  if (index !== -1) {\n                      node.children.splice(index, 1);\n                      path.push(node);\n                      this._condense(path);\n                      return this;\n                  }\n              }\n              if (!goingUp && !node.leaf && contains$2(node, bbox)) {\n                  path.push(node);\n                  indexes.push(i);\n                  i = 0;\n                  parent = node;\n                  node = node.children[0];\n              } else if (parent) {\n                  i++;\n                  node = parent.children[i];\n                  goingUp = false;\n              } else node = null;\n          }\n          return this;\n      },\n      toBBox: function toBBox(item) {\n          return item;\n      },\n      compareMinX: compareNodeMinX$1,\n      compareMinY: compareNodeMinY$1,\n      toJSON: function toJSON() {\n          return this.data;\n      },\n      fromJSON: function fromJSON(data) {\n          this.data = data;\n          return this;\n      },\n      _all: function _all(node, result) {\n          var nodesToSearch = [];\n          while (node) {\n              if (node.leaf) result.push.apply(result, node.children);else nodesToSearch.push.apply(nodesToSearch, node.children);\n              node = nodesToSearch.pop();\n          }\n          return result;\n      },\n      _build: function _build(items, left, right, height) {\n          var N = right - left + 1,\n              M = this._maxEntries,\n              node;\n          if (N <= M) {\n              node = createNode$1(items.slice(left, right + 1));\n              calcBBox$1(node, this.toBBox);\n              return node;\n          }\n          if (!height) {\n              height = Math.ceil(Math.log(N) / Math.log(M));\n              M = Math.ceil(N / Math.pow(M, height - 1));\n          }\n          node = createNode$1([]);\n          node.leaf = false;\n          node.height = height;\n          var N2 = Math.ceil(N / M),\n              N1 = N2 * Math.ceil(Math.sqrt(M)),\n              i,\n              j,\n              right2,\n              right3;\n          multiSelect$1(items, left, right, N1, this.compareMinX);\n          for (i = left; i <= right; i += N1) {\n              right2 = Math.min(i + N1 - 1, right);\n              multiSelect$1(items, i, right2, N2, this.compareMinY);\n              for (j = i; j <= right2; j += N2) {\n                  right3 = Math.min(j + N2 - 1, right2);\n                  node.children.push(this._build(items, j, right3, height - 1));\n              }\n          }\n          calcBBox$1(node, this.toBBox);\n          return node;\n      },\n      _chooseSubtree: function _chooseSubtree(bbox, node, level, path) {\n          var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n          while (true) {\n              path.push(node);\n              if (node.leaf || path.length - 1 === level) break;\n              minArea = minEnlargement = Infinity;\n              for (i = 0, len = node.children.length; i < len; i++) {\n                  child = node.children[i];\n                  area = bboxArea$1(child);\n                  enlargement = enlargedArea$1(bbox, child) - area;\n                  if (enlargement < minEnlargement) {\n                      minEnlargement = enlargement;\n                      minArea = area < minArea ? area : minArea;\n                      targetNode = child;\n                  } else if (enlargement === minEnlargement) {\n                      if (area < minArea) {\n                          minArea = area;\n                          targetNode = child;\n                      }\n                  }\n              }\n              node = targetNode || node.children[0];\n          }\n          return node;\n      },\n      _insert: function _insert(item, level, isNode) {\n          var toBBox = this.toBBox,\n              bbox = isNode ? item : toBBox(item),\n              insertPath = [];\n          var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n          node.children.push(item);\n          extend$2(node, bbox);\n          while (level >= 0) {\n              if (insertPath[level].children.length > this._maxEntries) {\n                  this._split(insertPath, level);\n                  level--;\n              } else break;\n          }\n          this._adjustParentBBoxes(bbox, insertPath, level);\n      },\n      _split: function _split(insertPath, level) {\n          var node = insertPath[level],\n              M = node.children.length,\n              m = this._minEntries;\n          this._chooseSplitAxis(node, m, M);\n          var splitIndex = this._chooseSplitIndex(node, m, M);\n          var newNode = createNode$1(node.children.splice(splitIndex, node.children.length - splitIndex));\n          newNode.height = node.height;\n          newNode.leaf = node.leaf;\n          calcBBox$1(node, this.toBBox);\n          calcBBox$1(newNode, this.toBBox);\n          if (level) insertPath[level - 1].children.push(newNode);else this._splitRoot(node, newNode);\n      },\n      _splitRoot: function _splitRoot(node, newNode) {\n          this.data = createNode$1([node, newNode]);\n          this.data.height = node.height + 1;\n          this.data.leaf = false;\n          calcBBox$1(this.data, this.toBBox);\n      },\n      _chooseSplitIndex: function _chooseSplitIndex(node, m, M) {\n          var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n          minOverlap = minArea = Infinity;\n          for (i = m; i <= M - m; i++) {\n              bbox1 = distBBox$1(node, 0, i, this.toBBox);\n              bbox2 = distBBox$1(node, i, M, this.toBBox);\n              overlap = intersectionArea$1(bbox1, bbox2);\n              area = bboxArea$1(bbox1) + bboxArea$1(bbox2);\n              if (overlap < minOverlap) {\n                  minOverlap = overlap;\n                  index = i;\n                  minArea = area < minArea ? area : minArea;\n              } else if (overlap === minOverlap) {\n                  if (area < minArea) {\n                      minArea = area;\n                      index = i;\n                  }\n              }\n          }\n          return index;\n      },\n      _chooseSplitAxis: function _chooseSplitAxis(node, m, M) {\n          var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX$1,\n              compareMinY = node.leaf ? this.compareMinY : compareNodeMinY$1,\n              xMargin = this._allDistMargin(node, m, M, compareMinX),\n              yMargin = this._allDistMargin(node, m, M, compareMinY);\n          if (xMargin < yMargin) node.children.sort(compareMinX);\n      },\n      _allDistMargin: function _allDistMargin(node, m, M, compare) {\n          node.children.sort(compare);\n          var toBBox = this.toBBox,\n              leftBBox = distBBox$1(node, 0, m, toBBox),\n              rightBBox = distBBox$1(node, M - m, M, toBBox),\n              margin = bboxMargin$1(leftBBox) + bboxMargin$1(rightBBox),\n              i,\n              child;\n          for (i = m; i < M - m; i++) {\n              child = node.children[i];\n              extend$2(leftBBox, node.leaf ? toBBox(child) : child);\n              margin += bboxMargin$1(leftBBox);\n          }\n          for (i = M - m - 1; i >= m; i--) {\n              child = node.children[i];\n              extend$2(rightBBox, node.leaf ? toBBox(child) : child);\n              margin += bboxMargin$1(rightBBox);\n          }\n          return margin;\n      },\n      _adjustParentBBoxes: function _adjustParentBBoxes(bbox, path, level) {\n          for (var i = level; i >= 0; i--) {\n              extend$2(path[i], bbox);\n          }\n      },\n      _condense: function _condense(path) {\n          for (var i = path.length - 1, siblings; i >= 0; i--) {\n              if (path[i].children.length === 0) {\n                  if (i > 0) {\n                      siblings = path[i - 1].children;\n                      siblings.splice(siblings.indexOf(path[i]), 1);\n                  } else this.clear();\n              } else calcBBox$1(path[i], this.toBBox);\n          }\n      },\n      _initFormat: function _initFormat(format) {\n          var compareArr = ['return a', ' - b', ';'];\n          this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n          this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n          this.toBBox = new Function('a', 'return {minX: a' + format[0] + ', minY: a' + format[1] + ', maxX: a' + format[2] + ', maxY: a' + format[3] + '};');\n      }\n  };\n  function findItem$1(item, items, equalsFn) {\n      if (!equalsFn) return items.indexOf(item);\n      for (var i = 0; i < items.length; i++) {\n          if (equalsFn(item, items[i])) return i;\n      }\n      return -1;\n  }\n  function calcBBox$1(node, toBBox) {\n      distBBox$1(node, 0, node.children.length, toBBox, node);\n  }\n  function distBBox$1(node, k, p, toBBox, destNode) {\n      if (!destNode) destNode = createNode$1(null);\n      destNode.minX = Infinity;\n      destNode.minY = Infinity;\n      destNode.maxX = -Infinity;\n      destNode.maxY = -Infinity;\n      for (var i = k, child; i < p; i++) {\n          child = node.children[i];\n          extend$2(destNode, node.leaf ? toBBox(child) : child);\n      }\n      return destNode;\n  }\n  function extend$2(a, b) {\n      a.minX = Math.min(a.minX, b.minX);\n      a.minY = Math.min(a.minY, b.minY);\n      a.maxX = Math.max(a.maxX, b.maxX);\n      a.maxY = Math.max(a.maxY, b.maxY);\n      return a;\n  }\n  function compareNodeMinX$1(a, b) {\n      return a.minX - b.minX;\n  }\n  function compareNodeMinY$1(a, b) {\n      return a.minY - b.minY;\n  }\n  function bboxArea$1(a) {\n      return (a.maxX - a.minX) * (a.maxY - a.minY);\n  }\n  function bboxMargin$1(a) {\n      return a.maxX - a.minX + (a.maxY - a.minY);\n  }\n  function enlargedArea$1(a, b) {\n      return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n  }\n  function intersectionArea$1(a, b) {\n      var minX = Math.max(a.minX, b.minX),\n          minY = Math.max(a.minY, b.minY),\n          maxX = Math.min(a.maxX, b.maxX),\n          maxY = Math.min(a.maxY, b.maxY);\n      return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);\n  }\n  function contains$2(a, b) {\n      return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;\n  }\n  function intersects$1(a, b) {\n      return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;\n  }\n  function createNode$1(children) {\n      return {\n          children: children,\n          height: 1,\n          leaf: true,\n          minX: Infinity,\n          minY: Infinity,\n          maxX: -Infinity,\n          maxY: -Infinity\n      };\n  }\n  function multiSelect$1(arr, left, right, n, compare) {\n      var stack = [left, right],\n          mid;\n      while (stack.length) {\n          right = stack.pop();\n          left = stack.pop();\n          if (right - left <= n) continue;\n          mid = left + Math.ceil((right - left) / n / 2) * n;\n          quickselect$3(arr, mid, left, right, compare);\n          stack.push(left, mid, mid, right);\n      }\n  }\n\n  function geojsonRbush(maxEntries) {\n      var tree = rbush$1(maxEntries);\n      tree.insert = function (feature) {\n          if (Array.isArray(feature)) {\n              var bbox = feature;\n              feature = bboxPolygon(bbox);\n              feature.bbox = bbox;\n          } else {\n              feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n          }\n          return rbush$1.prototype.insert.call(this, feature);\n      };\n      tree.load = function (features) {\n          var load = [];\n          if (Array.isArray(features)) {\n              features.forEach(function (bbox) {\n                  var feature = bboxPolygon(bbox);\n                  feature.bbox = bbox;\n                  load.push(feature);\n              });\n          } else {\n              featureEach(features, function (feature) {\n                  feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n                  load.push(feature);\n              });\n          }\n          return rbush$1.prototype.load.call(this, load);\n      };\n      tree.remove = function (feature) {\n          if (Array.isArray(feature)) {\n              var bbox = feature;\n              feature = bboxPolygon(bbox);\n              feature.bbox = bbox;\n          }\n          return rbush$1.prototype.remove.call(this, feature);\n      };\n      tree.clear = function () {\n          return rbush$1.prototype.clear.call(this);\n      };\n      tree.search = function (geojson) {\n          var features = rbush$1.prototype.search.call(this, this.toBBox(geojson));\n          return {\n              type: 'FeatureCollection',\n              features: features\n          };\n      };\n      tree.collides = function (geojson) {\n          return rbush$1.prototype.collides.call(this, this.toBBox(geojson));\n      };\n      tree.all = function () {\n          var features = rbush$1.prototype.all.call(this);\n          return {\n              type: 'FeatureCollection',\n              features: features\n          };\n      };\n      tree.toJSON = function () {\n          return rbush$1.prototype.toJSON.call(this);\n      };\n      tree.fromJSON = function (json) {\n          return rbush$1.prototype.fromJSON.call(this, json);\n      };\n      tree.toBBox = function (geojson) {\n          var bbox;\n          if (geojson.bbox) bbox = geojson.bbox;else if (Array.isArray(geojson) && geojson.length === 4) bbox = geojson;else bbox = turfBBox(geojson);\n          return {\n              minX: bbox[0],\n              minY: bbox[1],\n              maxX: bbox[2],\n              maxY: bbox[3]\n          };\n      };\n      return tree;\n  }\n  function bboxPolygon(bbox) {\n      var lowLeft = [bbox[0], bbox[1]];\n      var topLeft = [bbox[0], bbox[3]];\n      var topRight = [bbox[2], bbox[3]];\n      var lowRight = [bbox[2], bbox[1]];\n      var coordinates = [[lowLeft, lowRight, topRight, topLeft, lowLeft]];\n      return {\n          type: 'Feature',\n          bbox: bbox,\n          properties: {},\n          geometry: {\n              type: 'Polygon',\n              coordinates: coordinates\n          }\n      };\n  }\n  function turfBBox(geojson) {\n      var bbox = [Infinity, Infinity, -Infinity, -Infinity];\n      coordEach(geojson, function (coord) {\n          if (bbox[0] > coord[0]) bbox[0] = coord[0];\n          if (bbox[1] > coord[1]) bbox[1] = coord[1];\n          if (bbox[2] < coord[0]) bbox[2] = coord[0];\n          if (bbox[3] < coord[1]) bbox[3] = coord[1];\n      });\n      return bbox;\n  }\n\n  function feature$7(geometry, properties, options) {\n      options = options || {};\n      if (!isObject$6(options)) throw new Error('options is invalid');\n      var bbox = options.bbox;\n      var id = options.id;\n      if (geometry === undefined) throw new Error('geometry is required');\n      if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n      if (bbox) validateBBox$4(bbox);\n      if (id) validateId$4(id);\n      var feat = { type: 'Feature' };\n      if (id) feat.id = id;\n      if (bbox) feat.bbox = bbox;\n      feat.properties = properties || {};\n      feat.geometry = geometry;\n      return feat;\n  }\n  function lineString$5(coordinates, properties, options) {\n      if (!coordinates) throw new Error('coordinates is required');\n      if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions');\n      if (!isNumber$5(coordinates[0][1]) || !isNumber$5(coordinates[0][1])) throw new Error('coordinates must contain numbers');\n      return feature$7({\n          type: 'LineString',\n          coordinates: coordinates\n      }, properties, options);\n  }\n  function featureCollection$5(features, options) {\n      options = options || {};\n      if (!isObject$6(options)) throw new Error('options is invalid');\n      var bbox = options.bbox;\n      var id = options.id;\n      if (!features) throw new Error('No features passed');\n      if (!Array.isArray(features)) throw new Error('features must be an Array');\n      if (bbox) validateBBox$4(bbox);\n      if (id) validateId$4(id);\n      var fc = { type: 'FeatureCollection' };\n      if (id) fc.id = id;\n      if (bbox) fc.bbox = bbox;\n      fc.features = features;\n      return fc;\n  }\n  function isNumber$5(num) {\n      return !isNaN(num) && num !== null && !Array.isArray(num);\n  }\n  function isObject$6(input) {\n      return !!input && input.constructor === Object;\n  }\n  function validateBBox$4(bbox) {\n      if (!bbox) throw new Error('bbox is required');\n      if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n      if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n      bbox.forEach(function (num) {\n          if (!isNumber$5(num)) throw new Error('bbox must only contain numbers');\n      });\n  }\n  function validateId$4(id) {\n      if (!id) throw new Error('id is required');\n      if (['string', 'number'].indexOf(typeof id === 'undefined' ? 'undefined' : _typeof(id)) === -1) throw new Error('id must be a number or a string');\n  }\n\n  function getCoords$3(coords) {\n      if (!coords) throw new Error('coords is required');\n      if (coords.type === 'Feature' && coords.geometry !== null) return coords.geometry.coordinates;\n      if (coords.coordinates) return coords.coordinates;\n      if (Array.isArray(coords)) return coords;\n      throw new Error('coords must be GeoJSON Feature, Geometry Object or an Array');\n  }\n\n  function geomEach$4(geojson, callback) {\n      var i,\n          j,\n          g,\n          geometry,\n          stopG,\n          geometryMaybeCollection,\n          isGeometryCollection,\n          featureProperties,\n          featureBBox,\n          featureId,\n          featureIndex = 0,\n          isFeatureCollection = geojson.type === 'FeatureCollection',\n          isFeature = geojson.type === 'Feature',\n          stop = isFeatureCollection ? geojson.features.length : 1;\n      for (i = 0; i < stop; i++) {\n          geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;\n          featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};\n          featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : undefined;\n          featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : undefined;\n          isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n          stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n          for (g = 0; g < stopG; g++) {\n              geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n              if (geometry === null) {\n                  if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                  continue;\n              }\n              switch (geometry.type) {\n                  case 'Point':\n                  case 'LineString':\n                  case 'MultiPoint':\n                  case 'Polygon':\n                  case 'MultiLineString':\n                  case 'MultiPolygon':\n                      {\n                          if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                          break;\n                      }\n                  case 'GeometryCollection':\n                      {\n                          for (j = 0; j < geometry.geometries.length; j++) {\n                              if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                          }\n                          break;\n                      }\n                  default:\n                      throw new Error('Unknown Geometry Type');\n              }\n          }\n          featureIndex++;\n      }\n  }\n  function flattenEach$4(geojson, callback) {\n      geomEach$4(geojson, function (geometry, featureIndex, properties, bbox, id) {\n          var type = geometry === null ? null : geometry.type;\n          switch (type) {\n              case null:\n              case 'Point':\n              case 'LineString':\n              case 'Polygon':\n                  if (callback(feature$7(geometry, properties, { bbox: bbox, id: id }), featureIndex, 0) === false) return false;\n                  return;\n          }\n          var geomType;\n          switch (type) {\n              case 'MultiPoint':\n                  geomType = 'Point';\n                  break;\n              case 'MultiLineString':\n                  geomType = 'LineString';\n                  break;\n              case 'MultiPolygon':\n                  geomType = 'Polygon';\n                  break;\n          }\n          for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n              var coordinate = geometry.coordinates[multiFeatureIndex];\n              var geom = {\n                  type: geomType,\n                  coordinates: coordinate\n              };\n              if (callback(feature$7(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n          }\n      });\n  }\n\n  function lineSegment(geojson) {\n      if (!geojson) throw new Error('geojson is required');\n      var results = [];\n      flattenEach$4(geojson, function (feature) {\n          lineSegmentFeature(feature, results);\n      });\n      return featureCollection$5(results);\n  }\n  function lineSegmentFeature(geojson, results) {\n      var coords = [];\n      var geometry = geojson.geometry;\n      switch (geometry.type) {\n          case 'Polygon':\n              coords = getCoords$3(geometry);\n              break;\n          case 'LineString':\n              coords = [getCoords$3(geometry)];\n      }\n      coords.forEach(function (coord) {\n          var segments = createSegments(coord, geojson.properties);\n          segments.forEach(function (segment) {\n              segment.id = results.length;\n              results.push(segment);\n          });\n      });\n  }\n  function createSegments(coords, properties) {\n      var segments = [];\n      coords.reduce(function (previousCoords, currentCoords) {\n          var segment = lineString$5([previousCoords, currentCoords], properties);\n          segment.bbox = bbox$2(previousCoords, currentCoords);\n          segments.push(segment);\n          return currentCoords;\n      });\n      return segments;\n  }\n  function bbox$2(coords1, coords2) {\n      var x1 = coords1[0];\n      var y1 = coords1[1];\n      var x2 = coords2[0];\n      var y2 = coords2[1];\n      var west = x1 < x2 ? x1 : x2;\n      var south = y1 < y2 ? y1 : y2;\n      var east = x1 > x2 ? x1 : x2;\n      var north = y1 > y2 ? y1 : y2;\n      return [west, south, east, north];\n  }\n\n  function feature$8(geometry, properties, options) {\n      options = options || {};\n      if (!isObject$7(options)) throw new Error('options is invalid');\n      var bbox = options.bbox;\n      var id = options.id;\n      if (geometry === undefined) throw new Error('geometry is required');\n      if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n      if (bbox) validateBBox$5(bbox);\n      if (id) validateId$5(id);\n      var feat = { type: 'Feature' };\n      if (id) feat.id = id;\n      if (bbox) feat.bbox = bbox;\n      feat.properties = properties || {};\n      feat.geometry = geometry;\n      return feat;\n  }\n  function point$6(coordinates, properties, options) {\n      if (!coordinates) throw new Error('coordinates is required');\n      if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n      if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');\n      if (!isNumber$6(coordinates[0]) || !isNumber$6(coordinates[1])) throw new Error('coordinates must contain numbers');\n      return feature$8({\n          type: 'Point',\n          coordinates: coordinates\n      }, properties, options);\n  }\n  function featureCollection$6(features, options) {\n      options = options || {};\n      if (!isObject$7(options)) throw new Error('options is invalid');\n      var bbox = options.bbox;\n      var id = options.id;\n      if (!features) throw new Error('No features passed');\n      if (!Array.isArray(features)) throw new Error('features must be an Array');\n      if (bbox) validateBBox$5(bbox);\n      if (id) validateId$5(id);\n      var fc = { type: 'FeatureCollection' };\n      if (id) fc.id = id;\n      if (bbox) fc.bbox = bbox;\n      fc.features = features;\n      return fc;\n  }\n  function isNumber$6(num) {\n      return !isNaN(num) && num !== null && !Array.isArray(num);\n  }\n  function isObject$7(input) {\n      return !!input && input.constructor === Object;\n  }\n  function validateBBox$5(bbox) {\n      if (!bbox) throw new Error('bbox is required');\n      if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n      if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n      bbox.forEach(function (num) {\n          if (!isNumber$6(num)) throw new Error('bbox must only contain numbers');\n      });\n  }\n  function validateId$5(id) {\n      if (!id) throw new Error('id is required');\n      if (['string', 'number'].indexOf(typeof id === 'undefined' ? 'undefined' : _typeof(id)) === -1) throw new Error('id must be a number or a string');\n  }\n\n  function getCoords$4(coords) {\n      if (!coords) throw new Error('coords is required');\n      if (coords.type === 'Feature' && coords.geometry !== null) return coords.geometry.coordinates;\n      if (coords.coordinates) return coords.coordinates;\n      if (Array.isArray(coords)) return coords;\n      throw new Error('coords must be GeoJSON Feature, Geometry Object or an Array');\n  }\n\n  function featureEach$5(geojson, callback) {\n      if (geojson.type === 'Feature') {\n          callback(geojson, 0);\n      } else if (geojson.type === 'FeatureCollection') {\n          for (var i = 0; i < geojson.features.length; i++) {\n              if (callback(geojson.features[i], i) === false) break;\n          }\n      }\n  }\n\n  function lineIntersect(line1, line2) {\n      var unique = {};\n      var results = [];\n      if (line1.type === 'LineString') line1 = feature$8(line1);\n      if (line2.type === 'LineString') line2 = feature$8(line2);\n      if (line1.type === 'Feature' && line2.type === 'Feature' && line1.geometry.type === 'LineString' && line2.geometry.type === 'LineString' && line1.geometry.coordinates.length === 2 && line2.geometry.coordinates.length === 2) {\n          var intersect = intersects$2(line1, line2);\n          if (intersect) results.push(intersect);\n          return featureCollection$6(results);\n      }\n      var tree = geojsonRbush();\n      tree.load(lineSegment(line2));\n      featureEach$5(lineSegment(line1), function (segment) {\n          featureEach$5(tree.search(segment), function (match) {\n              var intersect = intersects$2(segment, match);\n              if (intersect) {\n                  var key = getCoords$4(intersect).join(',');\n                  if (!unique[key]) {\n                      unique[key] = true;\n                      results.push(intersect);\n                  }\n              }\n          });\n      });\n      return featureCollection$6(results);\n  }\n  function intersects$2(line1, line2) {\n      var coords1 = getCoords$4(line1);\n      var coords2 = getCoords$4(line2);\n      if (coords1.length !== 2) {\n          throw new Error('<intersects> line1 must only contain 2 coordinates');\n      }\n      if (coords2.length !== 2) {\n          throw new Error('<intersects> line2 must only contain 2 coordinates');\n      }\n      var x1 = coords1[0][0];\n      var y1 = coords1[0][1];\n      var x2 = coords1[1][0];\n      var y2 = coords1[1][1];\n      var x3 = coords2[0][0];\n      var y3 = coords2[0][1];\n      var x4 = coords2[1][0];\n      var y4 = coords2[1][1];\n      var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n      var numeA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n      var numeB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n      if (denom === 0) {\n          if (numeA === 0 && numeB === 0) {\n              return null;\n          }\n          return null;\n      }\n      var uA = numeA / denom;\n      var uB = numeB / denom;\n      if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\n          var x = x1 + uA * (x2 - x1);\n          var y = y1 + uA * (y2 - y1);\n          return point$6([x, y]);\n      }\n      return null;\n  }\n\n  function nearestPointOnLine(lines, pt, options) {\n      options = options || {};\n      if (!isObject$1(options)) throw new Error('options is invalid');\n      var type = lines.geometry ? lines.geometry.type : lines.type;\n      if (type !== 'LineString' && type !== 'MultiLineString') {\n          throw new Error('lines must be LineString or MultiLineString');\n      }\n      var closestPt = point([Infinity, Infinity], {\n          dist: Infinity\n      });\n      var length = 0.0;\n      flattenEach(lines, function (line) {\n          var coords = getCoords(line);\n          for (var i = 0; i < coords.length - 1; i++) {\n              var start = point(coords[i]);\n              start.properties.dist = distance(pt, start, options);\n              var stop = point(coords[i + 1]);\n              stop.properties.dist = distance(pt, stop, options);\n              var sectionLength = distance(start, stop, options);\n              var heightDistance = Math.max(start.properties.dist, stop.properties.dist);\n              var direction = bearing(start, stop);\n              var perpendicularPt1 = destination(pt, heightDistance, direction + 90, options);\n              var perpendicularPt2 = destination(pt, heightDistance, direction - 90, options);\n              var intersect = lineIntersect(lineString([perpendicularPt1.geometry.coordinates, perpendicularPt2.geometry.coordinates]), lineString([start.geometry.coordinates, stop.geometry.coordinates]));\n              var intersectPt = null;\n              if (intersect.features.length > 0) {\n                  intersectPt = intersect.features[0];\n                  intersectPt.properties.dist = distance(pt, intersectPt, options);\n                  intersectPt.properties.location = length + distance(start, intersectPt, options);\n              }\n              if (start.properties.dist < closestPt.properties.dist) {\n                  closestPt = start;\n                  closestPt.properties.index = i;\n                  closestPt.properties.location = length;\n              }\n              if (stop.properties.dist < closestPt.properties.dist) {\n                  closestPt = stop;\n                  closestPt.properties.index = i + 1;\n                  closestPt.properties.location = length + sectionLength;\n              }\n              if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {\n                  closestPt = intersectPt;\n                  closestPt.properties.index = i;\n              }\n              length += sectionLength;\n          }\n      });\n      return closestPt;\n  }\n\n  function lineSlice(startPt, stopPt, line) {\n      var coords;\n      if (line.type === 'Feature') {\n          coords = line.geometry.coordinates;\n      } else if (line.type === 'LineString') {\n          coords = line.coordinates;\n      } else {\n          throw new Error('input must be a LineString Feature or Geometry');\n      }\n      var startVertex = nearestPointOnLine(line, startPt);\n      var stopVertex = nearestPointOnLine(line, stopPt);\n      var ends;\n      if (startVertex.properties.index <= stopVertex.properties.index) {\n          ends = [startVertex, stopVertex];\n      } else {\n          ends = [stopVertex, startVertex];\n      }\n      var clipCoords = [ends[0].geometry.coordinates];\n      for (var i = ends[0].properties.index + 1; i < ends[1].properties.index + 1; i++) {\n          clipCoords.push(coords[i]);\n      }\n      clipCoords.push(ends[1].geometry.coordinates);\n      return lineString(clipCoords, line.properties);\n  }\n\n  function isEqual(value, other) {\n    return baseIsEqual(value, other);\n  }\n\n  function diffCoords(coord1, coord2) {\n  \tvar vector = [Math.abs(coord1[0] - coord2[0]), Math.abs(coord1[1] - coord2[1])];\n  \treturn Math.sqrt(Math.pow(vector[0], 2) + Math.pow(vector[1], 2));\n  }\n  function findLineIntersection(line1Start, line1End, line2Start, line2End) {\n  \tvar line1 = lineString([line1Start, line1End]),\n  \t    line2 = lineString([line2Start, line2End]),\n  \t    intersectionFC = lineIntersect(line1, line2);\n  \tif (intersectionFC.features.length) {\n  \t\tvar intersection = intersectionFC.features[0].geometry.coordinates;\n  \t\tintersection[0] = Math.round(intersection[0] * 100000000) / 100000000;\n  \t\tintersection[1] = Math.round(intersection[1] * 100000000) / 100000000;\n  \t\treturn intersection;\n  \t} else {\n  \t\treturn false;\n  \t}\n  }\n  function traverseRings(ring1, ring2) {\n  \tvar intersections = featureCollection([]);\n  \tvar samering = false;\n  \tif (isEqual(ring1, ring2)) {\n  \t\tsamering = true;\n  \t}\n  \tfor (var i = 0; i < ring1.length - 1; i++) {\n  \t\tvar startK = samering ? i : 0;\n  \t\tfor (var k = startK; k < ring2.length - 1; k++) {\n  \t\t\tif (ring1 === ring2 && (Math.abs(i - k) === 1 || Math.abs(i - k) === ring1.length - 2)) {\n  \t\t\t\tcontinue;\n  \t\t\t}\n  \t\t\tvar intersection = findLineIntersection(ring1[i], ring1[i + 1], ring2[k], ring2[k + 1]);\n  \t\t\tif (!intersection) {\n  \t\t\t\tcontinue;\n  \t\t\t}\n  \t\t\tif ((diffCoords(intersection, ring1[0]) < 0.000005 || diffCoords(intersection, ring1[ring1.length - 1]) < 0.000005) && (diffCoords(intersection, ring2[0]) < 0.000005 || diffCoords(intersection, ring2[ring2.length - 1]) < 0.000005)) {\n  \t\t\t\tcontinue;\n  \t\t\t}\n  \t\t\tvar FeatureIntersection = point([intersection[0], intersection[1]]);\n  \t\t\tFeatureIntersection.properties = {\n  \t\t\t\tposition1: i,\n  \t\t\t\tposition2: k\n  \t\t\t};\n  \t\t\tintersections.features.push(FeatureIntersection);\n  \t\t}\n  \t}\n  \treturn intersections;\n  }function trimPaths(arrayLatLng1, arrayLatLng2) {\n  \tvar ring1 = toCoords(arrayLatLng1);\n  \tvar ring2 = toCoords(arrayLatLng2);\n  \tvar intersections = traverseRings(ring1, ring2);\n  \tif (intersections.features.length > 0) {\n  \t\tvar line1 = lineString(ring1);\n  \t\tvar line2 = lineString(ring2);\n  \t\tvar line1Start = point(ring1[0]);\n  \t\tvar line2End = point(ring2.slice(-1)[0]);\n  \t\tvar sliced1, sliced2;\n  \t\tvar first_segment_with_kinks = min$1(intersections.features, function (kink) {\n  \t\t\treturn kink.properties.position1;\n  \t\t});\n  \t\tvar kinks_in_first_segment = filter(intersections.features, function (kink) {\n  \t\t\treturn kink.properties.position1 === first_segment_with_kinks.properties.position1;\n  \t\t});\n  \t\tvar chosenIntersection = max$1(kinks_in_first_segment, function (kink) {\n  \t\t\treturn kink.properties.position2;\n  \t\t});\n  \t\tvar intersectLatLng = toLatLngs([chosenIntersection.geometry.coordinates])[0];\n  \t\tif (chosenIntersection.properties.position1 === 0) {\n  \t\t\tsliced1 = line1;\n  \t\t} else {\n  \t\t\tsliced1 = lineSlice(line1Start, chosenIntersection, line1);\n  \t\t}\n  \t\tif (chosenIntersection.properties.position2 >= ring2.length - 1) {\n  \t\t\tsliced2 = line2;\n  \t\t} else {\n  \t\t\tsliced2 = lineSlice(chosenIntersection, line2End, line2);\n  \t\t}\n  \t\treturn [toLatLngs(sliced1.geometry.coordinates), toLatLngs(sliced2.geometry.coordinates), intersectLatLng];\n  \t}\n  \treturn [];\n  }\n\n  var ig_turfhelper = {\n      along: along$1,\n      arrayToFeaturePoints: arrayToFeaturePoints,\n      createbuffer: createbuffer,\n      pointInPolygon: pointInPolygon,\n      polygonToFeaturePolygon: polygonToFeaturePolygon,\n      polylineToFeatureLinestring: polylineToFeatureLinestring,\n      simplifyFeature: simplifyFeature,\n      simplifyPointArray: simplifyPointArray,\n      toLatLngs: toLatLngs,\n      toCoords: toCoords,\n      trimPaths: trimPaths,\n      union: union$1,\n      kinks: kinks$1,\n      unkink: unkink,\n      concave: concave$1\n  };\n\n  exports.along = along$1;\n  exports.arrayToFeaturePoints = arrayToFeaturePoints;\n  exports.createbuffer = createbuffer;\n  exports.pointInPolygon = pointInPolygon;\n  exports.polygonToFeaturePolygon = polygonToFeaturePolygon;\n  exports.polylineToFeatureLinestring = polylineToFeatureLinestring;\n  exports.simplifyFeature = simplifyFeature;\n  exports.simplifyPointArray = simplifyPointArray;\n  exports.toLatLngs = toLatLngs;\n  exports.toCoords = toCoords;\n  exports.trimPaths = trimPaths;\n  exports.kinks = kinks$1;\n  exports.unkink = unkink;\n  exports.union = union$1;\n  exports.concave = concave$1;\n  exports.default = ig_turfhelper;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"],"names":["global","factory","exports","module","define","amd","turfHelper","this","Wicket$1","Wkt","arrayMap","array","iteratee","index","length","result","Array","eq","value","other","assocIndexOf","key","ListCache","entries","clear","entry","set","baseGetTag","undefined","undefinedTag","nullTag","symToStringTag$1","Object","isOwn","hasOwnProperty","call","symToStringTag","tag","unmasked","e","nativeObjectToString","getRawTag","nativeObjectToString$1","objectToString","isObject","type","_typeof","isFunction","funcTag","genTag","asyncTag","proxyTag","toSource","func","funcToString","baseIsNative","maskSrcKey","isMasked","reIsNative","reIsHostCtor","test","getNative","object","getValue","Hash","getMapData","map","data","__data__","isKeyable","MapCache","Stack","size","SetCache","values","add","arraySome","predicate","cacheHas","cache","has","equalArrays","bitmask","customizer","equalFunc","stack","isPartial","COMPARE_PARTIAL_FLAG","arrLength","othLength","stacked","get","seen","COMPARE_UNORDERED_FLAG","arrValue","othValue","compared","othIndex","push","mapToArray","forEach","setToArray","arrayFilter","resIndex","isObjectLike","baseIsArguments","argsTag","isIndex","MAX_SAFE_INTEGER","reIsUint","isLength","MAX_SAFE_INTEGER$1","arrayLikeKeys","inherited","isArr","isArray","isArg","isArguments","isBuff","isBuffer","isType","isTypedArray","skipIndexes","n","baseTimes","String","hasOwnProperty$5","baseKeys","Ctor","constructor","prototype","objectProto$8","isPrototype","nativeKeys","hasOwnProperty$6","isArrayLike","keys","getAllKeys","keysFunc","symbolsFunc","offset","arrayPush","baseGetAllKeys","getSymbols","baseIsEqualDeep","objIsArr","othIsArr","objTag","arrayTag$1","getTag$1","othTag","objIsObj","argsTag$2","objectTag$2","othIsObj","isSameTag","dataViewTag","byteLength","byteOffset","buffer","arrayBufferTag","Uint8Array","boolTag","dateTag","numberTag","errorTag","name","message","regexpTag","stringTag","mapTag","convert","setTag","COMPARE_PARTIAL_FLAG$1","COMPARE_UNORDERED_FLAG$1","symbolTag","symbolValueOf","equalByTag","COMPARE_PARTIAL_FLAG$3","objIsWrapped","hasOwnProperty$8","othIsWrapped","objUnwrapped","othUnwrapped","COMPARE_PARTIAL_FLAG$2","objProps","objLength","hasOwnProperty$7","skipCtor","objValue","objCtor","othCtor","equalObjects","baseIsEqual","isStrictComparable","matchesStrictComparable","srcValue","baseMatches","source","matchData","getMatchData","noCustomizer","COMPARE_PARTIAL_FLAG$4","COMPARE_UNORDERED_FLAG$2","baseIsMatch","isSymbol","symbolTag$1","isKey","reIsPlainProp","reIsDeepProp","memoize","resolver","TypeError","FUNC_ERROR_TEXT","memoized","args","arguments","apply","Cache","baseToString","symbolToString","INFINITY","castPath","stringToPath","toString","toKey","INFINITY$1","baseGet","path","baseHasIn","hasIn","hasFunc","hasPath","baseMatchesProperty","defaultValue","get$1","COMPARE_PARTIAL_FLAG$5","COMPARE_UNORDERED_FLAG$3","identity","property","baseProperty","basePropertyDeep","baseIteratee","collection","baseEach","castFunction","toLatLng","position","google","maps","LatLng","lat","lng","toLatLngs","coordinates","toCoord$1","Error","toCoords","arrayLatLng","closeRing","ring","last_coord","pop","feature","geometry","properties","bbox","id","indexOf","feat","point","isNumber","lineString","featureCollection","features","fc","radiansToLength","radians","units","factor","factors","lengthToRadians","distance","radiansToDegrees","Math","PI","degreesToRadians","degrees","num","isNaN","isObject$1","input","arrayToFeaturePolygon","LatLngArray","polylineToFeatureLinestring","objeto","vertices","Polyline","getPath","getArray","polygonToFeaturePolygon","polygonFeature","Polygon","arrayToFeaturePoints","latLngArray","FeatureCollection","latLng","Feature","tin","points","z","isPointZ","sort","byX","a","b","c","A","B","G","i","xmin","x","xmax","ymin","y","ymax","j","dx","dy","dmax","xmid","ymid","open","Triangle","__sentinel","closed","edges","r","splice","dedup","abs","triangulate","p","point$$1","triangle","polygon","C","D","E","F","m","outer","clone","geojson","cloneFeature","cloned","cloneFeatureCollection","cloneGeometry","cloneProperties","item","geom","geometries","deepSlice","coords","slice","coord","getCoord","obj","getCoords","containsNumber","getType","coordEach","callback","excludeWrapCoord","featureIndex","geometryIndex","k","l","geometry$$1","stopG","geometryMaybeCollection","isGeometryCollection","wrapShrink","coordIndex","isFeatureCollection","isFeature","stop","featureSubIndex","geomType","featureEach","geomEach","g","featureProperties","featureBBox","featureId","flattenEach","coordinate","lineReduce","initialValue","previousValue","feature$$1","lineIndex","lineEach","currentLine","lineDissolve","options","mutate","lastLine","previousLine","merged","coords1","coords2","s1","coordId","e1","s2","e2","concat","reverse","mergeLineStrings","multiLineString","line","identity$1","topology","o","arc","arcs","transformPoint","t","transform","x0","y0","kx","scale","ky","translate","output","stitch","flush","fragmentByEnd","fragmentByStart","f","start","end","stitchedArcs","fragments","emptyIndex","p1","p0","dp","ends","fg","unshift","gf","merge","objects","extract","polygonsByArc","polygons","area","planarRingArea","groups","_","group","neighbors","ki","hashmap","hash","equal","keyType","keyEmpty","valueType","keystore","max","ceil","log","LN2","valstore","mask","matchKey","collisions","maybeSet","missingValue","equalPoint","pointA","pointB","hashPoint","floats","uints","join","sequence","previousIndex","currentIndex","nextIndex","visitedByIndex","leftIndex","leftByIndex","rightIndex","rightByIndex","junctionCount","junctionByIndex","hashIndex","equalIndex","lines","rings","indexes","indexByPoint","Int32Array","Int8Array","lineStart","lineEnd","ringStart","ringEnd","junctionByPoint","empty","store","match","hashset","cut","next","junctions","lineMid","0","1","ringMid","ringFixed","reverse$1","rotateArray","mid","dedup$1","dedupLine","startPoint","endPoint","startArcs","startArc","endArcs","endArc","arcsByEnd","arcA","arcB","ia","ib","ja","jb","equalLine","reverseEqualLine","equalRing","ka","findMinimumOffset","kb","reverseEqualRing","minimum","minimumPoint","arcCount","dedupRing","geometry$1","inputs","outputs","geomifyFeature","geomifyGeometry","geomifyObject","quantization","indexGeometry","indexGeometryType","indexArcs","indexByArc","indexMultiArcs","boundGeometry","boundGeometryType","boundPoint","x1","y1","boundLine","boundMultiLine","Infinity","GeometryCollection","Point","MultiPoint","LineString","MultiLineString","MultiPolygon","bounds","quantizePoint","round","quantizePoints","pi","px","py","quantizeLine","quantizeRing","quantizePolygon","quantizeGeometry","quantizeGeometryType","prequantize","extractGeometry","extractGeometryType","extractLine","extractRing","extractMultiRing","hashArc","equalArc","delta","polygonDissolve","geoms","topo","geometryCollection","dissolve","types","getHomogenousType","from","to","coordinates1","coordinates2","dLat","dLon","lat1","lat2","pow","sin","cos","atan2","sqrt","concave","maxEdge","tinPolys","cleaned","existing","pt","removeDuplicates","filter","pt1","pt2","pt3","dist1","dist2","dist3","dissolved","concave$1","feature$3","isObject$2","isNumber$1","validateBBox","validateId","getCoords$1","cleanCoords","getType$1","newCoords","cleanLine","polygons$$1","polyPoints","points$$1","equals","prevPoint","nextPoint","newPoints","secondToLast","startX","startY","endX","endY","dxl","dyl","isPointOnLineSegment","clone$1","cloneFeature$1","cloneFeatureCollection$1","cloneGeometry$1","cloneProperties$1","deepSlice$1","getSqDist","p2","getSqSegDist","simplifyDPStep","first","last","sqTolerance","simplified","maxSqDist","sqDist","simplify$2","tolerance","highestQuality","len","simplifyRadialDist","simplifyDouglasPeucker","simplify","isObject$3","highQuality","geomEach$1","simplifyLine","simplifyPolygon","simplifyGeom","pts","simpleRing","checkValidity","simplifyPointArray","coordArray","simplifyFeature","toLowerCase","fromObject","toJson","simplifiedgeom","warn","fromJson","toObject","bearing","final","bear","calculateFinalBearing","lon1","lon2","destination","origin","longitude1","latitude1","bearing_rad","latitude2","asin","along","distance$$1","travelled","overshot","direction","along$1","extend","target","NumberUtil","IllegalArgumentException","Double","Comparable","Clonable","Comparator","Serializable","RuntimeException","inherits$1","create","AssertionFailedException","Assert","Coordinate","NULL_ORDINATE","DimensionalComparator","_dimensionsToTest","dimensionsToTest","Iterator","Collection","IndexOutOfBoundsException$1","List","NoSuchElementException","OperationNotSupported","ArrayList","array_","addAll","CoordinateList","ensureCapacity","allowRepeated","Envelope","_minx","_maxx","_miny","_maxy","init","env","x2","y2","Exception","NotRepresentableException","Location","hasInterface","interfaces_","MathUtil","StringBuffer","str","Integer","Character","DD","_hi","_lo","dd","parse","hi","lo","CGAlgorithmsDD","CoordinateSequence","System","HCoordinate","w","_x","_y","_w","q1","q2","pw","qx","qy","qw","CoordinateSequenceFactory","GeometryComponentFilter","Geometry","_envelope","_factory","_SRID","_userData","getSRID","CoordinateFilter","BoundaryNodeRule","Mod2BoundaryNodeRule","EndPointBoundaryNodeRule","MultiValentEndPointBoundaryNodeRule","MonoValentEndPointBoundaryNodeRule","CoordinateArrays","ForwardComparator","BidirectionalComparator","Map$2","SortedMap","Set$1","HashSet","colorOf","BLACK","color","parentOf","parent","setColor","leftOf","left","rightOf","right","TreeMap","root_","size_","Lineal","SortedSet","TreeSet","Arrays","Dimension","GeometryFilter","CoordinateSequenceFilter","_geometries","hasNullElements","lineStrings","BoundaryOp","_geom","_geomFact","_bnRule","_endpointMap","MOD2_BOUNDARY_RULE","bnRule","getFactory","Counter","count","IOException","StringUtil","CoordinateSequences","_points","Puntal","_coordinates","Polygonal","_shell","_holes","shell","holes","createLinearRing","isEmpty","hasNonEmptyElements","LinearRing","GeometryFactory","getCoordinateSequenceFactory","validateConstruction","GeometryEditor","_isUserDataCopied","GeometryEditorOperation","NoOpGeometryOperation","CoordinateOperation","CoordinateSequenceOperation","CoordinateArraySequence","_dimension","Number","isInteger","fill","coordSeq","getDimension","getCoordinateCopy","dimension","CoordinateArraySequenceFactory","is","sharedIterator","itp","array2","done","v","sharedSize","_values","HashMap","map_","MapImpl","PrecisionModel","_modelType","_scale","FLOATING","Type","modelType","FIXED","setScale","pm","_name","nameToTypeMap","put","_precisionModel","_coordinateSequenceFactory","coordinateSequenceFactory","precisionModel","getDefaultCoordinateSequenceFactory","SRID","WKTParser","geometryFactory","WKTWriter","parser","LineIntersector","_result","_inputLines","_intPt","_intLineIndex","_isProper","_pa","_pb","RobustLineIntersector","RobustDeterminant","RayCrossingCounter","_p","_crossingCount","_isPointOnSegment","CGAlgorithms","LineSegment","ls","IntersectionMatrix","_matrix","setAll","FALSE","elements","INTERIOR","BOUNDARY","EXTERIOR","Centroid","_areaBasePt","_triangleCent3","_areasum2","_cg3","_lineCentSum","_totalLength","_ptCount","_ptCentSum","EmptyStackException","Stack$1","UniqueCoordinateArrayFilter","treeSet","list","ConvexHull","_geomFactory","_inputPts","extractCoordinates","geomFactory","filterCoordinates","RadialComparator","_origin","GeometryTransformer","_inputGeom","_pruneEmptyGeometry","_preserveGeometryCollectionType","_preserveCollections","_preserveType","LineStringSnapper","_snapTolerance","_srcPts","_seg","_allowSnappingToSourceVertices","_isClosed","srcLine","snapTolerance","getCoordinates","srcPts","isClosed","GeometrySnapper","_srcGeom","srcGeom","SnapTransformer","_snapPts","_isSelfSnap","snapPts","isSelfSnap","CommonBits","_isFirst","_commonMantissaBitsCount","_commonBits","_commonSignExp","CommonBitsRemover","_commonCoord","_ccFilter","CommonCoordinateFilter","_commonBitsX","_commonBitsY","Translater","trans","GeometryCollectionIterator","_parent","_atStart","_max","_index","_subcollectionIterator","getNumGeometries","PointLocator","_boundaryRule","OGC_SFS_BOUNDARY_RULE","_isIn","_numBoundaries","boundaryRule","Octant","SegmentString","BasicSegmentString","_pts","_data","Boundable","ItemBoundable","_bounds","_item","PriorityQueue","_size","_items","ItemVisitor","SpatialIndex","AbstractNode","_childBoundables","_level","level","BoundablePair","_boundable1","_boundable2","_distance","_itemDistance","boundable1","boundable2","itemDistance","AbstractSTRtree","_root","_built","_itemBoundables","_nodeCapacity","DEFAULT_NODE_CAPACITY","nodeCapacity","isTrue","ItemDistance","STRtree","STRtreeNode","SegmentPointComparator","SegmentNode","_segString","segmentIndex","_segmentOctant","_isInterior","segString","segmentOctant","equals2D","getCoordinate","SegmentNodeList","_nodeMap","_edge","edge","NodeVertexIterator","_nodeList","_nodeIt","_currNode","_nextNode","_currSegIndex","nodeList","getEdge","iterator","readNextNode","NodableSegmentString","NodedSegmentString","MonotoneChainOverlapAction","tempEnv1","tempEnv2","_overlapSeg1","_overlapSeg2","MonotoneChain","_start","_end","_env","_context","_id","context","Quadrant","MonotoneChainBuilder","Noder","SinglePassNoder","_segInt","segInt","setSegmentIntersector","MCIndexNoder","_monoChains","_idCounter","_nodedSegStrings","_nOverlaps","si","SegmentOverlapAction","_si","TopologyException","msg","msgWithCoord","SegmentIntersector","InteriorIntersectionFinder","_findAllIntersections","_isCheckEndSegmentsOnly","_li","_interiorIntersection","_intSegments","_intersections","_intersectionCount","_keepIntersections","li","FastNodingValidator","_segStrings","_isValid","segStrings","EdgeNodingValidator","_nv","toSegmentStrings","GeometryCollectionMapper","_mapOp","mapOp","Position","TopologyLocation","location","on","ON","gl","LEFT","RIGHT","Label","elt","onLoc","lbl","geomIndex","NONE","setLocation","leftLoc","rightLoc","setLocations","EdgeRing","_startDe","_maxNodeDegree","_edges","_label","_ring","_isHole","_geometryFactory","computePoints","computeRing","MinimalEdgeRing","MaximalEdgeRing","GraphComponent","_isInResult","_isCovered","_isCoveredSet","_isVisited","label","Node","_coord","NodeMap","nodeMap","nodeFact","EdgeEnd","_node","_p0","_p1","_dx","_dy","_quadrant","DirectedEdge","_isForward","_sym","_next","_nextMin","_edgeRing","_minEdgeRing","_depth","isForward","getNumPoints","computeDirectedLabel","NodeFactory","PlanarGraph","_nodes","_edgeEndList","PolygonBuilder","_shellList","LineBuilder","_op","_ptLocator","_lineEdgesList","_resultLineList","op","ptLocator","PointBuilder","_resultPointList","PointOnGeometryLocator","SimplePointInAreaLocator","EdgeEndStar","_edgeMap","_edgeList","_ptInAreaLocation","DirectedEdgeStar","_resultAreaEdgeList","_SCANNING_FOR_INCOMING","_LINKING_TO_OUTGOING","OverlayNodeFactory","MonotoneChain$1","mce","chainIndex","SweepLineEvent","_xValue","_eventType","_insertEvent","_deleteEventIndex","_obj","insertEvent","DELETE","INSERT","EdgeSetIntersector","SegmentIntersector$1","_hasIntersection","_hasProper","_hasProperInterior","_properIntersectionPoint","_includeProper","_recordIsolated","_isSelfIntersection","_numIntersections","numTests","_bdyNodes","_isDone","_isDoneWhenProperInt","includeProper","recordIsolated","SimpleMCSweepLineIntersector","events","nOverlaps","IntervalRTreeNode$1","_min","POSITIVE_INFINITY","NEGATIVE_INFINITY","NodeComparator","IntervalRTreeLeafNode","min","IntervalRTreeBranchNode","_node1","_node2","n1","n2","buildExtent","SortedPackedIntervalRTree","_leaves","LinearComponentExtracter","_lines","_isForcedToLineString","isForcedToLineString","ArrayListVisitor","IndexedPointInAreaLocator","IntervalIndexedGeometry","SegmentVisitor","_counter","counter","EdgeIntersection","dist","EdgeIntersectionList","MonotoneChainIndexer","MonotoneChainEdge","startIndex","env1","env2","mcb","getChainStartIndices","Depth","NULL_VALUE","Edge","eiList","_mce","_isIsolated","_depthDelta","GeometryGraph","_parentGeom","_lineEdgeMap","_boundaryNodeRule","_useBoundaryDeterminationRule","_argIndex","_boundaryNodes","_hasTooFewPoints","_invalidPoint","_areaPtLocator","argIndex","parentGeom","boundaryNodeRule","GeometryGraphOperation","_resultPrecisionModel","_arg","g0","setComputationPrecision","getPrecisionModel","g1","compareTo","OrientedCoordinateArray","_orientation","orientation","EdgeList","_ocaMap","OverlayOp","_resultGeom","_graph","_resultPolyList","SnapOverlayOp","_cbr","g2","computeSnapTolerance","SnapIfNeededOverlayOp","InteriorPointArea","_interiorPoint","_maxWidth","SafeBisectorFinder","_poly","_centreY","_hiY","MAX_VALUE","_loY","poly","getEnvelopeInternal","getMaxY","getMinY","avg","InteriorPointLine","_centroid","_minDistance","getCentroid","addInterior","addEndpoints","InteriorPointPoint","MonotoneChainSelectAction","selectedSegment","NodeBase","_subnode","Interval","interval","DoubleBits","Key","_pt","_interval","computeKey","Node$1","_centre","getMin","getMax","IntervalSize","Root","Bintree","_minExtent","PointInRing","MCPointInRing","_tree","_crossings","buildIndex","MCSelecter","mcp","Angle","Triangle$1","MinimumBoundingCircle","_input","_extremalPts","_radius","MinimumDiameter","_isConvex","_convexHullPts","_minBaseSeg","_minWidthPt","_minPtIndex","_minWidth","inputGeom","isConvex","Densifier","_distanceTolerance","DensifyTransformer","distanceTolerance","HalfEdge","_orig","orig","MarkHalfEdge","_isMarked","EdgeGraph","_vertexMap","DissolveHalfEdge","_isStart","DissolveEdgeGraph","LineDissolver","_nodeEdgeStack","_ringStartEdge","NodeBase$1","Key$1","itemEnv","Node$2","_centrex","_centrey","getMinX","getMaxX","Root$1","Quadtree","GeoJSONParser","GeoJSONReader","GeoJSONWriter","p2c","ScaledNoder","_noder","_scaleFactor","_offsetX","_offsetY","_isScaled","noder","scaleFactor","isIntegerPrecision","IsSimpleOp","_isClosedEndpointsInInterior","_nonSimpleLocation","isInBoundary","EndpointInfo","degree","BufferParameters","_quadrantSegments","DEFAULT_QUADRANT_SEGMENTS","_endCapStyle","CAP_ROUND","_joinStyle","JOIN_ROUND","_mitreLimit","DEFAULT_MITRE_LIMIT","_isSingleSided","_simplifyFactor","DEFAULT_SIMPLIFY_FACTOR","quadrantSegments","setQuadrantSegments","endCapStyle","setEndCapStyle","joinStyle","mitreLimit","setJoinStyle","setMitreLimit","RightmostEdgeFinder","_minIndex","_minCoord","_minDe","_orientedDe","LinkedList","BufferSubgraph","_finder","_dirEdgeList","_rightMostCoord","BufferInputLineSimplifier","_inputLine","_distanceTol","_isDeleted","_angleOrientation","COUNTERCLOCKWISE","inputLine","OffsetSegmentString","_ptList","_minimimVertexDistance","OffsetSegmentGenerator","_maxCurveSegmentError","_filletAngleQuantum","_closingSegLengthFactor","_segList","_bufParams","_s0","_s1","_s2","_seg0","_seg1","_offset0","_offset1","_side","_hasNarrowConcaveAngle","bufParams","getQuadrantSegments","getJoinStyle","MAX_CLOSING_SEG_LEN_FACTOR","OffsetCurveBuilder","SubgraphDepthLocater","_subgraphs","_cga","subgraphs","DepthSegment","_upwardSeg","_leftDepth","seg","depth","OffsetCurveSetBuilder","_curveBuilder","_curveList","curveBuilder","IntersectionAdder","_hasInterior","numIntersections","numInteriorIntersections","numProperIntersections","BufferBuilder","_workingPrecisionModel","_workingNoder","NodingValidator","HotPixel","_originalPt","_ptScaled","_p0Scaled","_p1Scaled","_corner","_safeEnv","initCorners","MCIndexPointSnapper","HotPixelSnapAction","_hotPixel","_parentEdge","_hotPixelVertexIndex","_isNodeAdded","hotPixel","parentEdge","hotPixelVertexIndex","InteriorIntersectionFinderAdder","_interiorIntersections","MCIndexSnapRounder","_pm","_pointSnapper","setPrecisionModel","getScale","BufferOp","_argGeom","_resultGeometry","_saveException","PolygonExtracter","_comps","comps","GeometryLocation","_component","_segIndex","component","INSIDE_AREA","segIndex","PointExtracter","ConnectedElementLocationFilter","_locations","locations","DistanceOp","_terminateDistance","_minDistanceLocation","terminateDistance","EdgeString","_directedEdges","GraphComponent$1","DirectedEdge$1","_from","_to","_edgeDirection","_angle","directionPt","edgeDirection","quadrant","LineMergeDirectedEdge","Edge$1","_dirEdge","de0","de1","setDirectedEdges","DirectedEdgeStar$1","_outEdges","_sorted","Node$3","_deStar","deStar","LineMergeEdge","_line","NodeMap$1","PlanarGraph$1","_dirEdges","LineMergeGraph","LineMerger","_mergedLineStrings","_edgeStrings","PolygonizeDirectedEdge","PolygonizeEdge","ConnectedInteriorTester","_geomGraph","_disconnectedRingcoord","geomGraph","EdgeEndBuilder","EdgeEndBundle","_edgeEnds","getDirectedCoordinate","getLabel","insert","EdgeEndBundleStar","RelateNode","RelateNodeFactory","RelateNodeGraph","ConsistentAreaTester","_nodeGraph","IndexedNestedRingTester","_rings","_totalEnv","_nestedPt","graph","TopologyValidationError","_errorType","errorType","copy","IsValidOp","_parentGeometry","_isSelfTouchingRingFormingHoleValid","_validErr","parentGeometry","EdgeRing$1","_deList","_lowestEdge","_ringPts","_isProcessed","_isIncludedSet","_isIncluded","EnvelopeComparator","PolygonizeGraph","Polygonizer","_lineStringAdder","LineStringAdder","_dangles","_cutEdges","_invalidRingLines","_holeList","_polyList","_isCheckingRingsValid","_extractOnlyPolygonal","extractOnlyPolygonal","RelateComputer","_im","_isolatedEdges","arg","RectangleContains","_rectEnv","rectangle","RectangleLineIntersector","_diagUp0","_diagUp1","_diagDown0","_diagDown1","rectEnv","ShortCircuitedGeometryVisitor","RectangleIntersects","_rectangle","EnvelopeIntersectsVisitor","_intersects","GeometryContainsPointVisitor","_rectSeq","_containsPoint","getExteriorRing","getCoordinateSequence","RectangleIntersectsSegmentVisitor","_rectIntersector","RelateOp","_relate","GeometryCombiner","_skipEmpty","_inputGeoms","extractFactory","CascadedPolygonUnion","_inputPolys","polys","PointGeometryUnion","_pointGeom","_otherGeom","pointGeom","otherGeom","GeometryExtracter","_sortIndex","sortIndex","UnaryUnionOp","_polygons","geomFact","UnionInteracting","_g0","_g1","_interacts0","_interacts1","UnionOp","PrecisionReducerCoordinateOperation","_targetPM","_removeCollapsed","targetPM","removeCollapsed","GeometryPrecisionReducer","_changePrecisionModel","_isPointwise","DouglasPeuckerLineSimplifier","_usePt","DouglasPeuckerSimplifier","_isEnsureValidTopology","DPTransformer","isEnsureValidTopology","TaggedLineSegment","TaggedLineString","_parentLine","_segs","_resultSegs","_minimumSize","parentLine","minimumSize","LineSegmentIndex","LineSegmentVisitor","_querySeg","querySeg","TaggedLineStringSimplifier","_inputIndex","_outputIndex","_linePts","inputIndex","outputIndex","TaggedLinesSimplifier","TopologyPreservingSimplifier","_lineSimplifier","_linestringMap","LineStringTransformer","linestringMap","LineStringMapBuilderFilter","tps","SplitSegment","_segLen","_splitPt","_minimumLen","getLength","ConstraintSplitPointFinder","NonEncroachingSplitPointFinder","TrianglePredicate","Vertex","_z","ConstraintVertex","_isOnConstraint","_constraint","QuadEdge","_rot","_vertex","IncrementalDelaunayTriangulator","_subdiv","_isUsingTolerance","subdiv","getTolerance","QuadEdgeLocator","LastFoundQuadEdgeLocator","_lastEdge","LocateFailureException","msgWithSpatial","TriangleVisitor","QuadEdgeSubdivision","_visitedKey","_quadEdges","_startingEdge","_tolerance","_edgeCoincidenceTolerance","_frameVertex","_frameEnv","_locator","_triEdges","EDGE_COINCIDENCE_TOL_FACTOR","createFrame","initSubdiv","TriangleCircumcentreVisitor","TriangleEdgesListVisitor","_triList","TriangleVertexListVisitor","TriangleCoordinatesVisitor","_coordList","_triCoords","Segment","_ls","z1","z2","KdNodeVisitor","KdNode","_left","_right","_count","KdTree","_numberOfNodes","BestMatchVisitor","_matchNode","_matchDist","ConformingDelaunayTriangulator","_initialVertices","_segVertices","_segments","_incDel","_convexHull","_splitFinder","_kdt","_vertexFactory","_computeAreaEnv","initialVertices","DelaunayTriangulationBuilder","_siteCoords","ConformingDelaunayTriangulationBuilder","_constraintLines","_constraintVertexMap","VoronoiDiagramBuilder","_clipEnv","_diagramEnv","LinearLocation","_componentIndex","_segmentIndex","_segmentFraction","loc","segmentFraction","componentIndex","normalize","doNormalize","LinearIterator","_linearGeom","_numLines","_currentLine","_vertexIndex","linear","getComponentIndex","segmentEndVertexIndex","linearGeom","vertexIndex","loadCurrentLine","LocationIndexOfPoint","LocationIndexOfLine","LinearGeometryBuilder","_ignoreInvalidLines","_fixInvalidLines","_lastPt","ExtractLineByLocation","LocationIndexedLine","checkGeometryType","LengthIndexOfPoint","LengthLocationMap","LengthIndexedLine","union$1","poly1","poly2","reader","read","JSON","stringify","union","write","bbox$1","BBox","projection","convertToMercator","convertToWgs84","newCoord","lonLat","D2R","MAXEXTENT","xy","sign","tan","R2D","atan","exp","adder","Adder","reset","_add","s","bv","av","halfPi","noop","streamGeometry","stream","streamGeometryType","streamLine","streamPolygon","polygonStart","polygonEnd","spherical","cartesian","lambda","phi","cosPhi","cartesianDot","cartesianCross","cartesianAddInPlace","cartesianScale","vector","cartesianNormalizeInPlace","d","compose","invert","rotationIdentity","tau","rotateRadians","deltaLambda","deltaPhi","deltaGamma","rotationLambda","rotationPhiGamma","forwardRotationLambda","rotation","cosDeltaPhi","sinDeltaPhi","cosDeltaGamma","sinDeltaGamma","circleRadius","cosRadius","radius","acos","epsilon","clipBuffer","rejoin","shift","pointEqual","Intersection","clipPolygon","segments","compareIntersection","startInside","interpolate","subject","clip","segment","link","current","isSubject","ascending","NaN","merge$1","arrays","clipExtent","visible","a1","corner","comparePoint","ca","cb","activeStream","linePoint","x__","y__","v__","v_","x_","clipMin","clipMax","y_","ax","ay","t0","t1","clipLine","clean","bufferStream","clipStream","winding","a0","b0","b1","polygonInside","cleanInside","identity$3","pointVisible","rotate","sink","pointLine","pointRing","ringSink","ringSegments","ringBuffer","polygonStarted","validSegment","rotatedStart","normal","angle","sum$1","point0","lambda0","phi0","quarterPi","sinPhi0","cosPhi0","lambda1","sinPhi1","cosPhi1","point1","phi1","absDelta","antimeridian","intersection","phiArc","polygonContains","sphere","clipCircle","cr","intersect","two","n2n2","n1n2","determinant","c1","c2","n1xn2","u","uu","t2","q","polar","code","smallRadius","notHemisphere","c0","v0","v00","_clean","point2","sinRadius","step","circleStream","transformer","methods","TransformStream","fitExtent","extent","h","streamObjectType","geoStream","boundsStream$1","resample","project","delta2","resampleLineTo","d2","phi2","lambda2","dx2","dy2","dz","cosMinDistance","resampleStream","maxDepth","ringPoint","lambda00","x00","y00","a00","b00","c00","resample$1","resampleNone","projectAt","projectRotate","projectTransform","recenter","center","cacheStream","theta","preclip","clipAntimeridian","postclip","projectResample","transformRadians","clipAngle","precision","fitSize","projectionMutator","mercatorRaw","mercatorProjection","reclip","forward","transverseMercatorRaw","bufferFeature","steps","results","buffered","projected","needsTransverseMercator","projectCoords","defineProjection","toMercator","bufferOp","coordsIsNaN","unprojectCoords","toWgs84","proj","ext","geoTransverseMercator","earthRadius","createbuffer","comment","Marker","multiBuffered","buffer$1","inRing","ignoreBoundary","isInside","xi","yi","xj","yj","pointInPolygon","sourceArray","geojsonPolygon","pointsInside","pointsOutside","inBBox","insidePoly","inHole","booleanPointInPolygon","marker","getPosition","markerToFeaturePoint","kinks$1","Wicket","featureIn","line1","line2","line1StartX","line1StartY","line1EndX","line1EndY","line2StartX","line2StartY","line2EndX","line2EndY","denominator","numerator1","numerator2","onLine1","onLine2","lineIntersects","kinks","feature$5","isObject$4","validateBBox$2","validateId$2","polygon$3","isNumber$3","featureCollection$3","flattenEach$2","geomEach$2","multiFeatureIndex","partialSort","arr","compare","sd","floor","swap","tmp","rbush","maxEntries","format","_maxEntries","_minEntries","_initFormat","calcBBox","node","toBBox","distBBox","children","destNode","createNode","minX","minY","maxX","maxY","child","extend$1","leaf","compareNodeMinX","compareNodeMinY","bboxArea","bboxMargin","contains$1","intersects","height","multiSelect","quickselect$2","geomReduce$3","geomEach$3","currentGeometry","area$1","calculateArea","polygonArea","ringArea","lowerIndex","middleIndex","upperIndex","coordsLength","rad","RADIUS","booleanPointInPolygon$1","getCoord$2","getCoords$2","inBBox$1","inRing$1","equalArrays$1","array1","righthanded","equalArrays$2","unkink","featureEach$2","simplepolygon","unkinkPolygon","baseExtremum","comparator","computed","baseGt","baseLt","quickselect$3","quickselectStep","swap$1","rbush$1","calcBBox$1","distBBox$1","createNode$1","extend$2","compareNodeMinX$1","compareNodeMinY$1","bboxArea$1","bboxMargin$1","contains$2","intersects$1","multiSelect$1","bboxPolygon","lowLeft","topLeft","topRight","turfBBox","feature$7","isObject$6","validateBBox$4","validateId$4","isNumber$5","getCoords$3","flattenEach$4","geomEach$4","lineSegment","reduce","previousCoords","currentCoords","lineString$5","bbox$2","createSegments","lineSegmentFeature","featureCollection$5","feature$8","isObject$7","validateBBox$5","validateId$5","featureCollection$6","isNumber$6","getCoords$4","featureEach$5","lineIntersect","unique","intersects$2","tree","load","remove","search","collides","all","toJSON","fromJSON","json","geojsonRbush","x3","y3","x4","y4","denom","numeA","numeB","uA","uB","point$6","nearestPointOnLine","closestPt","sectionLength","heightDistance","perpendicularPt1","perpendicularPt2","intersectPt","lineSlice","startPt","stopPt","startVertex","stopVertex","clipCoords","diffCoords","coord1","coord2","findLineIntersection","line1Start","line1End","line2Start","line2End","intersectionFC","traverseRings","ring1","ring2","intersections","samering","isEqual","FeatureIntersection","position1","position2","trimPaths","arrayLatLng1","arrayLatLng2","sliced1","sliced2","first_segment_with_kinks","min$1","chosenIntersection","max$1","kink","intersectLatLng","beginsWith","endsWith","Symbol","_wrapped","sub","substring","delimiter","trim","initializer","wrapVertices","regExes","typeStr","spaces","numeric","comma","parenComma","doubleParenComma","trimParens","ogcTypes","crudeJson","components","isCollection","sameCoords","deconstruct","isRectangle","config","construct","iring","oring","cs","exec","toUpperCase","wkt","prefix","matches","base","ingest","console","pieces","_point","multipoint","_multipoint","parts","linestring","_linestring","multilinestring","_multilinestring","_polygon","multipolygon","_multipolygon","box","_box","geometrycollection","split","parseFloat","multipoints","replace","subcomponents","x_cord","y_cord","optimized","editable","LatLngBounds","Rectangle","verts","paths","reverseInnerPolygons","multiFlag","response","vertex","linestrings","computeSignedArea","getAt","areas","getPaths","lastIndexOf","Circle","getCenter","getRadius","d2r","rlat","rlng","getSouthWest","getNorthEast","getBounds","Data","getGeometry","freeGlobal","freeSelf","self","root","Function","_Symbol","objectProto","toStringTag","coreJsData","uid","IE_PROTO","funcProto$1","objectProto$2","funcToString$1","hasOwnProperty$1","RegExp","Map$1","nativeCreate","HASH_UNDEFINED","hasOwnProperty$2","hasOwnProperty$3","HASH_UNDEFINED$1","string","LARGE_ARRAY_SIZE","pairs","HASH_UNDEFINED$2","symbolProto","valueOf","propertyIsEnumerable","nativeGetSymbols","getOwnPropertySymbols","symbol","objectProto$6","hasOwnProperty$4","propertyIsEnumerable$1","freeExports","nodeType","freeModule","Buffer","typedArrayTags","freeExports$1","freeModule$1","freeProcess","process","nodeUtil","binding","nodeIsTypedArray","baseUnary","overArg","DataView","Promise$1","Set","WeakMap","dataViewCtorString","mapCtorString","promiseCtorString","setCtorString","weakMapCtorString","getTag","ArrayBuffer","resolve","ctorString","MAX_MEMOIZE_SIZE","reLeadingDot","rePropName","reEscapeChar","memoizeCapped","number","quote","symbolProto$1","baseFor","fromRight","iterable","props","createBaseFor","eachFunc","createBaseEach","meters","metres","millimeters","millimetres","centimeters","centimetres","kilometers","kilometres","miles","nauticalmiles","inches","yards","feet","debug","bind","Float64Array","Uint32Array","getClass","equalsWithTolerance","doubleToLongBits","longBitsToDouble","isInfinite","isFinite","shouldNeverReachHere","assertion","expectedValue","actualValue","setOrdinate","ordinateIndex","X","Y","Z","getOrdinate","equals3D","equalInZ","CloneNotSupportedException","distance3D","hashCode","setCoordinate","trunc","o1","o2","compX","compY","serialVersionUID","hasNext","toArray","element","oldElement","Iterator_","found","arrayList","arrayList_","position_","coll","isChanged","toCoordinateArray","coordArrayType","inc","getArea","getWidth","getHeight","otherEnvelope","isNull","intMinX","intMinY","covers","expandToInclude","minExtent","transX","transY","setToNull","maxExtent","expandBy","deltaX","deltaY","contains","centre","minq","maxq","minp","maxp","toLocationSymbol","locationValue","log10","ln","LOG_10","v1","v2","v3","v4","clamp","wrap","average","append","setCharAt","substr","intValue","isWhitespace","le","extractSignificantDigits","insertDecimalPoint","magnitude","mag","TEN","divide","gt","lt","ONE","multiply","decimalPointPos","buf","numDigits","MAX_PRINT_DIGITS","digit","rebiasBy10","digitChar","subtract","selfAdd","continueExtractingDigits","remMag","sqr","doubleValue","negate","isZero","selfSubtract","getSpecialNumberString","selfDivide","yhi","ylo","hc","tc","hy","ty","U","SPLIT","dump","createNaN","ge","selfMultiply","reciprocal","fhi","flo","rint","setValue","isNegative","axdd","H","S","T","zhi","zlo","hx","tx","selfSqr","ex","toStandardNotation","toSciNotation","specialStr","sigDigits","charAt","stringOfChar","numZeroes","SCI_NOT_ZERO","digits","expStr","SCI_NOT_EXPONENT_CHAR","IllegalStateException","trailingDigits","digitsWithDecimal","isPositive","signum","strlen","signCh","val","numBeforeDec","ch","isDigit","parseInt","NumberFormatException","val2","numDecPlaces","xAbs","xLog10","xMag","TWO_PI","PI_2","EPS","orientationIndex","orientationIndexFilter","dx1","dy1","signOfDet2x2","denom1","denom2","numx1","numx2","fracP","numy1","numy2","fracQ","pa","pb","pc","detsum","detleft","detright","det","errbound","DP_SAFE_EPSILON","getX","expandEnvelope","getY","M","arraycopy","src","srcPos","dest","destPos","getProperty","line.separator","xInt","yInt","getSortIndex","SORTINDEX_GEOMETRYCOLLECTION","getGeometryN","equalsTopo","equalsExact","geometryChanged","geometryChangedFilter","geometryChangedAction","equalsNorm","norm","compareToSameClass","comp","getUserData","getEnvelope","toGeometry","checkNotGeometryCollection","computeEnvelopeInternal","setSRID","setUserData","userData","aElement","bElement","comparison","isGeometryCollectionOrDerived","SORTINDEX_MULTIPOINT","SORTINDEX_MULTILINESTRING","SORTINDEX_MULTIPOLYGON","SORTINDEX_POINT","SORTINDEX_LINESTRING","SORTINDEX_LINEARRING","SORTINDEX_POLYGON","boundaryCount","ENDPOINT_BOUNDARY_RULE","MULTIVALENT_ENDPOINT_BOUNDARY_RULE","MONOVALENT_ENDPOINT_BOUNDARY_RULE","isRing","ptNotInList","testPts","testPt","scroll","firstCoordinate","newCoordinates","coordinateComparator","coordList","hasRepeatedPoints","removeRepeatedPoints","removeNull","nonNull","copyDeep","srcStart","destStart","isEqualReversed","pts1","pts2","envelope","atLeastNCoordinatesOrNothing","increasingDirection","minCoordinate","minCoord","npts","extractPts","iPts","forwardComp","OLDcompare","dir1","dir2","i1","i2","comparePt","entrySet","javascript","util","Iterator_$1","hashSet","hashSet_","cmp","getKey","oldValue","fixAfterInsertion","rotateLeft","rotateRight","getFirstEntry","successor","Iterator_$2","treeSet_","asList","toDimensionSymbol","dimensionValue","SYM_FALSE","TRUE","SYM_TRUE","DONTCARE","SYM_DONTCARE","P","SYM_P","L","SYM_L","SYM_A","toDimensionValue","dimensionSymbol","seq","isDone","isGeometryChanged","childCoordinates","isEquivalentClass","otherCollection","getBoundaryDimension","sum","numPoints","revGeoms","createGeometryCollection","theseElements","otherElements","gc","thisGeom","holeComp","getBoundary","getGeometryType","nLines","revLines","createMultiLineString","boundaryMultiLineString","mLine","getEmptyMultiPoint","bdyPts","computeBoundaryCoordinates","createPoint","createMultiPointFromCoords","boundaryLineString","getStartPoint","createMultiPoint","getEndPoint","addEndpoint","getCoordinateN","it","valence","bop","chars","getStackTrace","os","ps","printStackTrace","stackTrace","lineNumberReader","readLine","NEWLINE","separator","separatorlen","tokenList","tmpString","pos","token","res","SIMPLE_ORDINATE_FORMAT","copyCoord","minDim","dim","cs1","cs2","cs1Size","fact","newseq","ensureValidRing","createClosedRing","isSimple","otherLineString","getPointN","computeLength","createLineString","isCoordinate","shellCoordinates","signedArea","getNumInteriorRing","prevX","prevY","otherPolygon","thisShell","otherPolygonShell","clockwise","uniqueCoordinates","isCCW","convexHull","otherShell","shellComp","nHole1","nHole2","thisHole","getInteriorRingN","otherHole","isValid","MINIMUM_VALID_SIZE","createMultiPolygon","allRings","allRingsArray","setCopyUserData","isUserDataCopied","edit","operation","editInternal","editGeometryCollection","editPolygon","getName","collectionForType","newPolygon","createPolygon","hole","editCoordinates","cloneCoordinates","strBuf","readResolve","instance","instanceObject","defineProperty$1","defineProperty","MapPolyfill","proto","objectOnly","_keys","_itp","createCollection","delete","Map","otherPrecisionModel","getMaximumSignificantDigits","otherSigDigits","isFloating","FLOATING_SINGLE","description","makePrecise","maxSigDigits","mostPrecise","pm1","pm2","maximumPreciseValue","buildGeometry","geomList","geomClass","isHeterogeneous","hasGeometryCollection","partClass","toGeometryArray","geom0","toPolygonArray","toLineStringArray","toPointArray","createGeometry","ptSeq","toMultiPolygonArray","multiPolygons","multiPolygonArray","geometryArray","toMultiLineStringArray","multiLineStrings","multiLineStringArray","lineStringArray","toMultiPointArray","multiPoints","multiPointArray","toLinearRingArray","linearRings","linearRingArray","pointArray","polygonArray","createPointFromInternalCoord","exemplar","emptyTypeStr","extract$1","wktType","_coordinate","linearring","_linearring","wktArray","toLineString","getIndexAlongSegment","intIndex","computeIntLineIndex","getTopologySummary","catBuf","isEndPoint","isCollinear","computeIntersection","p3","p4","computeIntersect","getIntersectionNum","getEdgeDistance","isProper","hasIntersection","isInteriorIntersection","inputLineIndex","getIntersection","NO_INTERSECTION","computeEdgeDistance","COLLINEAR_INTERSECTION","getEndpoint","ptIndex","isIntersection","getIntersectionAlongSegment","pdx","pdy","nonRobustComputeEdgeDistance","DONT_INTERSECT","DO_INTERSECT","COLLINEAR","POINT_INTERSECTION","isInSegmentEnvelopes","intPt","env0","normalizeToMinimum","n3","n4","normPt","smallestInAbsValue","safeHCoordinateIntersection","nearestEndpoint","intersectionWithNormalization","xabs","checkDD","intPtDD","isIn","out","println","normalizeToEnvCentre","computeCollinearIntersection","p1q1p2","p1q2p2","q1p1q2","q1p2q2","n00","n01","n10","n11","minX0","minY0","maxX0","maxY0","minX1","minY1","maxX1","maxY1","intMidX","intMidY","Pq1","Pq2","Qp1","Qp2","nearestPt","minDist","distancePointLine","countSegment","minx","maxx","xIntSign","isPointInPolygon","getLocation","isOnSegment","locatePointInRing","distanceLineLine","noIntersection","r_num","isPointInRing","nPts","hiPt","hiIndex","iPrev","iNext","prev","disc","computeOrientation","distancePointLinePerpendicular","len2","minDistance","isOnLine","lineIntersector","CLOCKWISE","STRAIGHT","orient0","orient1","isVertical","projectionFactor","pf0","pf1","newp0","newp1","distancePerpendicular","midPoint","closestPoints","close00","closestPoint","close01","close10","close11","comp0","temp","lineIntersection","pointAlongOffset","segmentLengthFraction","offsetDistance","segx","segy","ux","uy","setCoordinates","inputPt","segFrac","isHorizontal","pointAlong","bits0","java","lang","hash0","bits1","isIntersects","isDisjoint","isCovers","isCoveredBy","dimensionSymbols","row","col","column","isContains","setAtLeast","minimumDimensionSymbols","minimumDimensionValue","setAtLeastIfValid","isWithin","isTouches","dimensionOfGeometryA","dimensionOfGeometryB","isOverlaps","isEquals","ai","bi","transpose","requiredDimensionSymbols","im","isCrosses","actualDimensionValue","requiredDimensionSymbol","actualDimensionSymbols","addPoint","setBasePoint","basePt","addLineSegments","lineLen","segmentLen","midx","midy","addHole","isPositiveArea","addTriangle","cent","addShell","centroid3","area2","IndexOutOfBoundsException","peek","preSort","computeOctRing","inputPts","octPts","computeOctPts","lineOrPolygon","cleanRing","linearRing","original","cleanedRing","previousDistinctCoordinate","currentCoordinate","nextCoordinate","isBetween","cleanedRingCoordinates","c3","polyPts","reducedSet","reducedPts","padArray3","getConvexHull","sortedPts","cHS","grahamScan","cH","pad","polarCompare","dxp","dyp","dxq","dyq","orient","oq","transformCoordinates","transformPolygon","isAllValidLinearRings","transformLinearRing","createCoordinateSequence","getInputGeometry","transformMultiLineString","transGeomList","transformGeom","transformLineString","transformMultiPoint","transformMultiPolygon","transformGeometryCollection","seqSize","snapVertices","srcCoords","srcPt","snapVert","findSnapForVertex","snapTo","snapSegments","distinctPtCount","snapPt","findSegmentIndexToSnap","snapIndex","setAllowSnappingToSourceVertices","allowSnappingToSourceVertices","snapGeom","extractTargetCoordinates","snapToSelf","cleanResult","snappedGeom","ringPts","computeMinimumSegmentLength","ptSet","minSegLen","segLen","snap","snapper0","snapper1","computeOverlaySnapTolerance","computeSizeBasedSnapTolerance","fixedSnapTol","SNAP_PRECISION_FACTOR","snapLine","snapper","newPts","getCommon","numBits","signExpBits","numCommonMostSigMantissaBits","zeroLowerBits","bits","padStr","Long","toBinaryString","bitStr","getBit","nBits","num1","num2","addCommonBits","removeCommonBits","invCoord","getCommonCoordinate","xp","yp","isAtomic","UnsupportedOperationException","locateInternal","shellLoc","locateInPolygonRing","holeLoc","locate","updateLocationInfo","computeLocation","ml","mpoly","geomi","octant","adx","ady","setData","getData","getSegmentOctant","getItem","poll","minItem","reorder","visitItem","query","getLevel","getChildBoundables","addChildBoundable","childBoundable","computeBounds","Collections","reverseOrder","alen","singletonList","expandToQueue","priQ","isComp1","isComposite","isComp2","expand","isLeaves","nd","bndComposite","bndOther","bp","getDistance","getBoundable","getNodeCapacity","lastNode","nodes","build","removeItem","childToRemove","itemsTree","valuesTree","valuesTreeForNode","valuesTreeForChild","boundablesAtLevel","boundables","top","boundable","searchBounds","getIntersectsOp","visitor","childBoundables","createHigherLevels","getRoot","childToPrune","boundablesOfALevel","parentBoundables","createParentBoundables","maxChildDepth","childDepth","newLevel","sortedChildBoundables","getComparator","compareDoubles","IntersectsOp","item1","item2","createParentBoundablesFromVerticalSlices","verticalSlices","createParentBoundablesFromVerticalSlice","intersectsOp","sliceCount","sliceCapacity","slices","boundablesAddedToSlice","searchEnv","yComparator","minLeafCount","xComparator","nearestNeighbour","itemDist","initBndPair","distanceLowerBound","minPair","bndPair","currentDistance","bnd","centreX","centreY","aBounds","bBounds","relativeSign","xSign","ySign","compareValue","compareSign0","compareSign1","print","maxSegmentIndex","isInterior","getSplitCoordinates","eiPrev","ei","addEdgeCoordinates","addCollapsedNodes","collapsedVertexIndexes","findCollapsesFromInsertedNodes","findCollapsesFromExistingVertices","ei0","ei1","lastSegStartPt","useIntPt1","addSplitEdges","edgeList","newEdge","createSplitEdge","findCollapseIndex","collapsedVertexIndex","numVerticesBetween","maxSegIndex","ipt","eiNew","checkSplitEdgesCorrectness","splitEdges","edgePts","pt0","splitnPts","ptn","addIntersection","safeOctant","addIntersectionNode","getNodeList","normalizedSegmentIndex","nextSegIndex","nextPt","addIntersections","getNodedSubstrings","resultEdgelist","overlap","mc1","start1","mc2","start2","getLineSegment","computeSelect","start0","end0","mcs","select","computeOverlaps","mc","mco","computeOverlapsInternal","setId","getEndIndex","getStartIndex","getContext","getId","end1","p00","p01","p10","p11","mid0","mid1","isNorthern","quad","NE","NW","isOpposite","quad1","quad2","commonHalfPlane","isInHalfPlane","halfPlane","SE","SW","startIndexList","findChainEnd","toIntArray","safeStart","chainQuad","getChains","mcList","computeNodes","getMonotoneChains","getIndex","segStr","inputSegStrings","intersectChains","overlapAction","queryChain","testChain","ss1","ss2","processIntersections","e0","segIndex0","segIndex1","getInteriorIntersection","setCheckEndSegmentsOnly","isCheckEndSegmentsOnly","getIntersectionSegments","getIntersections","setFindAllIntersections","findAllIntersections","setKeepIntersections","keepIntersections","isEndSegment","createAllIntersectionsFinder","finder","createAnyIntersectionFinder","createIntersectionCounter","execute","checkInteriorIntersections","checkValid","getErrorMessage","intSegs","computeIntersections","nv","mapped","opposite","setAllLocations","locValue","setAllLocationsIfNull","isLine","newLoc","getLocations","flip","posIndex","isArea","isAnyNull","locIndex","isEqualOnSide","allPositionsEqual","getGeometryCount","side","toLine","toLineLabel","lineLabel","isIsolated","de","isFirstEdge","getEdgeRing","mergeLabel","addPoints","setEdgeRing","getNext","getLinearRing","computeMaxNodeDegree","getNode","getEdges","getOutgoingDegree","isHole","setInResult","containsPoint","isShell","getMaxNodeDegree","getShell","deLabel","setShell","toPolygon","holeLR","er","setMinEdgeRing","getNextMin","buildMinimalRings","minEdgeRings","getMinEdgeRing","minEr","linkDirectedEdgesForMinimalEdgeRings","linkMinimalDirectedEdges","setVisited","isVisited","isInResult","isCovered","isCoveredSet","setLabel","setCovered","updateIM","computeIM","isIncidentEdgeInResult","computeMergedLocation","label2","eltIndex","nLoc","onLocation","setNode","setLabelBoundary","find","addNode","getBoundaryNodes","bdyNodes","compareDirection","getDy","className","lastDotPos","getDx","getQuadrant","computeLabel","getDepth","setDepth","depthVal","isInteriorAreaEdge","setNextMin","nextMin","getDepthDelta","minEdgeRing","isLineEdge","isExteriorIfArea0","isExteriorIfArea1","edgeRing","depthDelta","getSym","printEdge","printReverse","setSym","setVisitedEdge","setEdgeDepths","directionFactor","oppositePos","oppositeDepth","setNext","depthFactor","currLocation","nextLocation","printEdges","getNodeIterator","linkResultDirectedEdges","nodeit","debugPrintln","isBoundaryNode","linkAllDirectedEdges","matchInSameDirection","ep0","ep1","getEdgeEnds","debugPrint","getEdgeIterator","findEdgeInSameDirection","eCoord","insertEdge","findEdgeEnd","ee","addEdges","edgesToAdd","de2","getNodes","findEdge","sortShellsAndHoles","edgeRings","shellList","freeHoleList","computePolygons","resultPolyList","placeFreeHoles","findEdgeRingContaining","buildMinimalEdgeRings","maxEdgeRings","findShell","placePolygonHoles","buildMaximalEdgeRings","dirEdges","getPolygons","testEr","testRing","testEnv","minShell","minEnv","tryShell","tryRing","tryEnv","isContained","shellCount","collectLines","opCode","getGraph","collectLineEdge","collectBoundaryTouchEdge","labelIsolatedLine","targetIndex","getArgGeometry","findCoveredLineEdges","buildLines","isResultOfOp","isCoveredByA","labelIsolatedLines","edgesList","INTERSECTION","filterCoveredNodeToPoint","isCoveredByLA","extractNonCoveredResultNodes","getDegree","containsPointInPolygon","getNextCW","iNextCW","propagateSideLabels","startLoc","currLoc","isAreaLabelsConsistent","computeEdgeEndLabels","getBoundaryNodeRule","checkAreaLabelsConsistent","lastEdgeIndex","findIndex","eSearch","computeLabelling","hasDimensionalCollapseEdge","insertEdgeEnd","getResultAreaEdges","firstOut","incoming","state","nextOut","nextIn","getRightmostEdge","deLast","quad0","updateLabelling","nodeLabel","prevOut","firstIn","computeDepths","edgeIndex","startDepth","targetLastDepth","nextDepth","endIndex","currDepth","nextDe","mergeSymLabels","eLabel","eLoc","computeIntersectsForChain","isDelete","setDeleteEventIndex","deleteEventIndex","getObject","pe","getInsertEvent","isInsert","isSameLabel","ev","getDeleteEventIndex","isTrivialIntersection","isAdjacentSegments","getProperIntersectionPoint","setIsDoneIfProperInt","isDoneWhenProperInt","hasProperInteriorIntersection","isBoundaryPointInternal","hasProperIntersection","isBoundaryPoint","setBoundaryNodes","bdyNodes0","bdyNodes1","setIsolated","prepareEvents","processOverlaps","edges0","edges1","addEdge","edgeSet","getMonotoneChainEdge","getStartIndexes","ev0","mc0","ev1","queryMin","queryMax","mid2","buildTree","IntervalRTreeNode","buildLevel","buildRoot","printNode","setForceToLineString","getLines","forceToLineString","getItems","rcc","addLine","getSegmentIndex","chainIndex0","chainIndex1","computeIntersects","depthValue","minDepth","newValue","getDelta","depthAtLocation","getCollapsedEdge","setName","isEqualForward","isEqualReverse","iRev","isCollapsed","getMaximumSegmentIndex","isPointwiseEqual","setDepthDelta","getEdgeIntersectionList","insertBoundaryPoint","determineBoundary","computeSelfNodes","computeRingSelfNodes","isDoneIfProperInt","esi","createEdgeSetIntersector","isRings","computeAllSegments","addSelfIntersectionNodes","computeSplitEdges","edgelist","computeEdgeIntersections","hasTooFewPoints","insertPoint","addPolygon","addPolygonRing","addLineString","getInvalidPoint","getBoundaryPoints","addSelfIntersectionNode","lr","cwLeft","cwRight","eiIt","addCollection","oca","compareOriented","orientation1","orientation2","limit1","limit2","compPt","done1","done2","edgeColl","findEdgeIndex","findEqualEdge","insertUniqueEdge","existingEdge","existingLabel","labelToMerge","cancelDuplicateResultEdges","sym","computeGeometry","resultPointList","resultLineList","opcode","createEmptyResult","replaceCollapsedEdges","newEdges","updateNodeLabelling","getResultGeometry","overlayOpCode","computeOverlay","insertUniqueEdges","copyPoints","baseSplitEdges","computeLabelsFromDepths","labelIncompleteNodes","findResultAreaEdges","polyBuilder","lineBuilder","pointBuilder","labelIncompleteNode","graphNode","ni","overlayOp","geom1","MapOp","symDifference","SYMDIFFERENCE","resultDimension","dim0","dim1","UNION","DIFFERENCE","difference","loc0","loc1","selfSnap","remGeom","prepareResult","prepGeom","isSuccess","savedException","width","bisector","horizontalBisector","widestIntersection","widestGeometry","getInteriorPoint","bisectY","getBisectorY","updateInterval","hasChildren","isPrunable","hasItems","addAllItems","items","subSize","addAllItemsFromOverlapping","resultItems","isSearchMatch","itemInterval","maxSubDepth","sqd","nodeSize","getSubnodeIndex","subnodeIndex","overlaps","exponent","NumW","Qty","Sign","Expo","Mant","Bin","ExW","32","64","CVTFWD","powerOf2","getInterval","computeLevel","computeInterval","getPoint","searchInterval","childNode","createSubnode","getSubnode","createExpanded","addInterval","expandInt","largerNode","isZeroWidth","maxAbs","MIN_BINARY_EXPONENT","insertContained","collectStats","insertInterval","ensureExtent","foundItems","del","testLineSegment","mcEnv","testMonotoneChain","rayEnv","mcSelecter","segs","toDegrees","PI_TIMES_2","isAcute","dx0","dy0","isObtuse","interiorAngle","anglePrev","angleNext","normalizePositive","angleBetween","tip1","tail","tip2","a2","diff","ang1","ang2","delAngle","toRadians","angleDegrees","getTurn","crossproduct","angleBetweenOriented","angDel","PI_OVER_2","PI_OVER_4","interpolateZ","longestSideLength","circumcentre","area3D","centroid","inCentre","m00","m01","m10","m11","lenAB","lenBC","lenCA","maxLen","cx","cy","bx","by","perpendicularBisector","angleBisector","len0","frac","uz","vx","vy","vz","crossx","crossy","crossz","absSq","len1","circum","compute","getDiameter","getExtremalPoints","computeCirclePoints","hullPts","lowestPoint","Q","pointWitMinAngleWithX","R","pointWithMinAngleWithSegment","computeCentre","getFarthestPoints","getCircle","centrePoint","getCentre","minSin","minAngPt","minAng","ang","getWidthCoordinate","computeMinimumDiameter","getSupportingSegment","computeWidthConvex","convexGeom","computeConvexRingMinDiameter","currMaxIndex","findMaxPerpDistance","maxPerpDistance","nextPerpDistance","maxIndex","getMinimumRectangle","minPara","maxPara","minPerp","maxPerp","paraC","computeC","perpC","maxPerpLine","computeSegmentForLine","minPerpLine","maxParaLine","minParaLine","getMinimumDiameter","setDistanceTolerance","densifyPoints","precModel","densifiedSegCount","densifiedSegLen","segFract","densify","densifier","roughGeom","createValidArea","roughAreaGeom","oNext","insertAfter","ecmp","ePrev","save","compareAngularDirection","quadrant2","prevNode","mark","setMark","isMarked","setMarkBoth","markBoth","eAdj","eAdjDest","createEdge","isValidEdge","eSame","getVertexEdges","setStart","isStart","updateRingStartEdge","getResult","computeResult","eNode","stackEdges","buildRing","eStartRing","eNext","buildLine","eStart","doneStart","getNodeCount","visitItems","visit","centrex","centrey","computeQuadLevel","quadSize","miny","maxy","insertNode","addEnv","expandEnv","isZeroX","isZeroY","insertEnv","queryAll","posEnv","delX","delY","geometryTypes","parse$1","extract$2","geoJson","shellGeoJson","holeGeoJson","reducePrecision","olReference","ol","convertFromPoint","convertFromLineString","convertFromLinearRing","convertFromPolygon","convertFromMultiPoint","convertFromMultiLineString","convertFromMultiPolygon","convertFromCollection","getLinearRings","multiPoint","getPoints","getLineStrings","multiPolygon","getGeometries","convertToPoint","convertToLineString","convertToLinearRing","convertToPolygon","convertToMultiPoint","convertToMultiLineString","convertToMultiPolygon","convertToCollection","rescale","ss","nodedSegmentStrings","roundPts","splitSS","intSegStrings","isSimpleMultiPoint","mp","isSimplePolygonal","isSimpleLinearGeometry","hasClosedEndpointIntersection","endPoints","eiInfo","getNonSimpleLocation","hasNonEndpointIntersection","computeSimple","isSimpleGeometryCollection","getEndCapStyle","isSingleSided","quadSegs","JOIN_BEVEL","JOIN_MITRE","setSimplifyFactor","simplifyFactor","getSimplifyFactor","getMitreLimit","setSingleSided","bufferDistanceError","alpha","CAP_FLAT","CAP_SQUARE","getRightmostSide","getRightmostSideOfSegment","checkForRightmostCoordinate","findRightmostEdgeAtVertex","pPrev","pNext","usePrev","findRightmostEdgeAtNode","star","dirEdgeList","addLast","removeFirst","clearVisitedEdges","getRightmostCoordinate","computeNodeDepth","startEdge","copySymDepths","computeDepth","outsideDepth","addReachable","findResultEdges","nodesVisited","nodeQueue","startNode","adjNode","edgeEnv","nodeStack","symNode","getDirectedEdges","isDeletable","i0","distanceTol","isConcave","isShallow","isShallowSampled","deleteShallowConcavities","midIndex","findNextNonDeletedIndex","lastIndex","isMiddleVertexDeleted","isShallowConcavity","NUM_PTS_TO_CHECK","collapseLine","INIT","KEEP","COORDINATE_ARRAY_TYPE","addPt","bufPt","isRedundant","addPts","lastPt","setMinimumVertexDistance","minimimVertexDistance","addNextSegment","addStartPoint","computeOffsetSegment","outsideTurn","addCollinear","addOutsideTurn","addInsideTurn","addLineEndCap","offsetL","offsetR","addFilletArc","squareCapSideOffset","squareCapLOffset","squareCapROffset","addMitreJoin","offset0","offset1","isMitreWithinLimit","addLimitedMitreJoin","addFilletCorner","startAngle","endAngle","OFFSET_SEGMENT_SEPARATION_FACTOR","addBevelJoin","createSquare","addSegments","addFirstSegment","addLastSegment","initSideSegments","ang0","angDiffHalf","midAng","mitreMidAng","mitreDist","bevelHalfLen","mitreMidLine","bevelEndLeft","bevelEndRight","sideSign","totalAngle","nSegs","currAngleInc","currAngle","INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR","createCircle","CURVE_VERTEX_SNAP_DISTANCE_FACTOR","hasNarrowConcaveAngle","getOffsetCurve","isRightSide","posDistance","segGen","getSegGen","computePointCurve","computeOffsetCurve","curvePts","computeSingleSidedBufferCurve","distTol","simplifyTolerance","simp2","simp1","computeRingBufferCurve","simp","computeLineBufferCurve","getLineCurve","getBufferParameters","bufDistance","getRingCurve","copyCoordinates","findStabbedSegments","stabbingRayLeftPt","stabbedSegments","bsg","dirEdge","ds","orientIndex","compareX","seg0","seg1","compare0","curve","addCurve","offsetSide","shellCoord","isErodedCompletely","holeCoord","isTriangleErodedCompletely","triangleCoord","bufferDistance","tri","getCurves","cwLeftLoc","cwRightLoc","ringCoord","envMinDimension","getLineIntersector","hasInteriorIntersection","setWorkingPrecisionModel","mergeDelta","newDelta","buildSubgraphs","subgraphList","processedGraphs","subgraph","createSubgraphs","createEmptyResultGeometry","getNoder","bufferSegStrList","computeNodedEdges","oldLabel","setNoder","lLoc","rLoc","convertSegStrings","checkEndPtVertexIntersections","ss0","pts0","checkCollapses","checkCollapse","intersectsScaled","segMinx","segMaxx","segMiny","segMaxy","isOutsidePixelEnv","intersectsToleranceSquare","copyScaled","pScaled","getSafeEnvelope","safeTolerance","SAFE_ENV_EXPANSION_FACTOR","intersectsPixelClosure","intersectsLeft","intersectsBottom","addSnappedNode","pixelEnv","hotPixelSnapAction","isNodeAdded","getInteriorIntersections","checkCorrectness","inputSegmentStrings","snapRound","findInteriorIntersections","computeIntersectionSnaps","computeVertexSnaps","intFinderAdder","edge0","bufferFixedPrecision","fixedPM","bufBuilder","bufferReducedPrecision","precDigits","MAX_PRECISION_DIGITS","precisionDigits","precisionScaleFactor","bufferOriginalPrecision","argPM","geomBuf","bufOp","maxPrecisionDigits","bufEnvMax","minUnitLog10","CAP_BUTT","isInsideArea","getGeometryComponent","computeContainmentDistance","locPtPoly","polyGeomIndex","locationsIndex","insideLocs","locs","ptLoc","computeMinDistanceLinesPoints","locGeom","computeMinDistance","computeFacetDistance","lines0","lines1","computeMinDistanceLines","updateMinDistance","computeMinDistancePoints","nearestLocations","nearestPoints","coord0","segClosestPoint","line0","points0","points1","isWithinDistance","forwardDirectedEdges","reverseDirectedEdges","coordinateList","directedEdge","getEdgeDirection","getLine","setMarked","setContext","getComponentWithVisitedState","visitedState","visited","marked","isRemoved","getDirectionPt","getAngle","getFromNode","setEdge","getToNode","toEdges","getOutEdges","addOutEdge","getDirEdge","fromNode","getOppositeNode","getNextEdge","sortEdges","getNextCWEdge","modi","getEdgesBetween","node0","node1","commonEdges","retainAll","findNodesOfDegree","nodesFound","nodeIterator","dirEdgeIterator","edgeIterator","findNode","startCoordinate","endCoordinate","endNode","directedEdge0","directedEdge1","buildEdgeStringsForUnprocessedNodes","buildEdgeStringsStartingAt","buildEdgeStringsForNonDegree2Nodes","buildEdgeStringsForObviousStartNodes","getMergedLineStrings","buildEdgeStringStartingWith","buildEdgeStringsForIsolatedLoops","edgeString","isInRing","setRing","getRing","visitInteriorRing","findDifferentPoint","intDe","visitLinkedDirectedEdges","visitShellInteriors","setInteriorEdgesInResult","startDe","buildEdgeRings","hasUnvisitedShellEdge","isInteriorsConnected","createEdgeEndForNext","eiCurr","eiNext","createEdgeEndForPrev","computeEdgeEnds","computeLabelOn","foundInterior","computeLabelSide","computeLabelSides","eb","updateIMFromEdges","insertEdgeEnds","copyNodesAndLabels","nodeIt","computeIntersectionNodes","eeList","edgeIt","isNodeEdgeAreaLabelsConsistent","hasDuplicateRings","eeb","isNodeConsistentArea","intersector","getNestedPoint","isNonNested","innerRing","innerRingPts","searchRing","searchRingPts","innerRingPt","findPtNotNode","getErrorType","getMessage","errMsg","locStr","ERROR","REPEATED_POINT","HOLE_OUTSIDE_SHELL","NESTED_HOLES","DISCONNECTED_INTERIOR","SELF_INTERSECTION","RING_SELF_INTERSECTION","NESTED_SHELLS","DUPLICATE_RINGS","TOO_FEW_POINTS","INVALID_COORDINATE","RING_NOT_CLOSED","checkInvalidCoordinates","checkHolesNotNested","nestedTester","innerHole","checkConsistentArea","cat","checkShellInsideHole","shellPts","holePts","shellPt","holePt","checkNoSelfIntersectingRings","checkNoSelfIntersectingRing","checkConnectedInteriors","cit","nodeSet","isFirst","checkHolesInShell","pir","checkTooFewPoints","getValidationError","checkClosedRing","checkClosedRings","checkShellsNotNested","setSelfTouchingRingFormingHoleValid","checkShellNotNested","polyShell","badNestedPt","testCoords","isIncluded","isIncludedSet","startDE","isOuterHole","hasShell","getPolygon","isProcessed","holeER","setIncluded","getOuterHole","adjRing","computeHole","isOuterShell","getLineString","updateIncluded","adjShell","setProcessed","findDirEdgesInRing","minShellEnv","tryShellRing","tryShellEnv","obj0","obj1","r1","findEdgeRing","computeDepthParity","computeNextCWEdges","iNode","linePts","endPt","nStart","nEnd","deleteCutEdges","findLabeledEdgeRings","cutLines","getEdgeRings","maximalRings","convertMaximalToMinimalEdgeRings","edgeRingList","ringEdges","intNodes","findIntersectionNodes","computeNextCCWEdges","deleteDangles","nodesToRemove","dangleLines","deleteAllEdges","toNode","getDegreeNonDeleted","edgeRingStarts","currLabel","prevDE","outDE","firstOutDE","prevInDE","inDE","polygonize","getInvalidRingLines","findValidRings","validEdgeRingList","invalidRingList","findShellsAndHoles","assignHolesToShells","includeAll","findDisjointShells","extractPolygons","getDangles","getCutEdges","setCheckRingsValid","isCheckingRingsValid","findOuterShells","outerHoleER","polyList","holeList","assignHoleToShell","isMoreToScan","computeProperIntersectionIM","dimA","dimB","hasProper","hasProperInterior","labelIsolatedEdges","thisIndex","labelIsolatedEdge","computeDisjointIM","labelIsolatedNodes","eeBuilder","ee0","ee1","labelNodeEdges","labelIntersectionNodes","labelIsolatedNode","ga","gb","isContainedInBoundary","isPointContainedInBoundary","isLineStringContainedInBoundary","isLineSegmentContainedInBoundary","segEnv","isSegUpwards","applyTo","ecpVisitor","riVisitor","elementEnv","rectPt","checkIntersectionWithLineStrings","testLine","checkIntersectionWithSegments","seq1","getIntersectionMatrix","relate","touches","within","coveredBy","relOp","intersectionPattern","relateWithCheck","disjoint","crosses","extractElements","elems","elemGeom","combine","combiner","createList","obj2","reduceToGeometries","geomTree","unionTree","extractByEnvelope","disjointGeoms","intersectingGeoms","elem","unionOptimized","g0Env","g1Env","unionActual","commonEnv","unionUsingEnvelopeIntersection","STRTREE_NODE_CAPACITY","itemTree","binaryUnion","unionSafe","repeatedUnion","restrictToPolygons","common","disjointPolys","g0Int","g1Int","bufferUnion","unionAll","gColl","locater","exteriorCoords","ptComp","unionNoOpt","unionWithNull","unionPoints","ptGeom","unionLines","lineGeom","unionPolygons","unionLA","interacts","isInteracting","extractedGeoms","computeInteracting","elem0","interactsWithAny","int0","int1","disjoint0","disjoint1","reducedCoords","noRepeatedCoords","minLength","collapsedCoords","fixPolygonalTopology","geomToBuffer","changePM","bufGeom","finalGeom","reducePointwise","geomEdit","createFactory","finalRemoveCollapsed","newPM","createEditor","setRemoveCollapsedComponents","inputFactory","setChangePrecisionModel","changePrecisionModel","reducePW","setPointwise","isPointwise","reducer","simplifySection","maxDistance","setEnsureValid","tss","rawGeom","rawAreaGeom","removeDegenerateRings","simpResult","getParent","addToResult","asLineString","getResultSize","resultSegsSize","getSegment","getParentCoordinates","getMinimumSize","asLinearRing","getSegments","getResultCoordinates","flatten","newSeg","hasBadIntersection","sectionIndex","candidateSeg","hasBadOutputIntersection","hasBadInputIntersection","isValidToSimplify","furthestPtIndex","findFurthestPoint","maxDist","midPt","isInLineSection","taggedLines","tlss","taggedLine","splitAt","minFrac","pointAlongReverse","getConstrainedLength","setMinimumLength","minLen","getSplitPoint","findSplitPoint","encroachPt","lineSeg","midPtLen","splitSeg","projPt","projectedSplitPoint","maxSplitLen","triArea","isInCircleDDNormalized","bdx","bdy","cdx","cdy","abdet","bcdet","cadet","alift","blift","clift","checkRobustInCircle","nonRobustInCircle","isInCircleNonRobust","isInCircleDD","isInCircleDDSlow","isInCircleCC","circumCentre","toPoint","isInCircleDDFast","aTerm","triAreaDDFast","bTerm","cTerm","pTerm","cc","ccRadius","isInCircleNormalized","triAreaDDSlow","isInCircleRobust","circleCenter","hcc","nre","err","dot","magn","getZ","isInCircle","interpolateZValue","crossProduct","setZ","times","cross","classify","sa","BEHIND","BEYOND","ORIGIN","DESTINATION","BETWEEN","circumRadiusRatio","edgeLength","el","ptLen","getConstraint","setOnConstraint","isOnConstraint","setConstraint","constraint","equalsNonOriented","qe","equalsOriented","toLineSegment","dNext","lPrev","rPrev","rot","oPrev","setOrig","lNext","invRot","setDest","rNext","isLive","getPrimary","dPrev","makeEdge","q0","q3","beta","t3","t4","connect","insertSite","isVertexOfEdge","isOnEdge","insertSites","locateFromEdge","triEdges","getTriangleVertices","includeFrame","visitTriangles","isFrameVertex","getVoronoiCellPolygon","cellPts","startQE","cellPoly","setLocator","locator","ea","ec","isFrameBorderEdge","leftTri","getTriangleEdges","rightTri","vLeftTriOther","vRightTriOther","triVisitor","edgeStack","visitedEdges","fetchTriangleToVisit","isFrameEdge","getTriangleCoordinates","getTriangles","getVertices","vd","curr","edgeCount","isFrame","quadEdges","getPrimaryEdges","getVertexUniqueEdges","visitedVertices","qd","priQE","eSym","eRot","eRotSym","iter","maxIter","getVoronoiCellPolygons","cells","getVoronoiDiagram","vorCells","triPtsList","tris","triPt","locEdge","triEdge","ccVertex","checkTriangleSize","getEndZ","getStartZ","getStart","getEnd","getEndY","getStartX","getStartY","getEndX","isRepeated","getRight","setLeft","getCount","getLeft","increment","setRight","matchNode","findBestMatchNode","insertExact","queryEnv","queryNode","currentNode","odd","discriminant","searchRight","queryEnvelope","leafNode","isOddLevel","isLessThan","toCoordinates","kdnodes","includeRepeated","update","getInitialVertices","getKDT","enforceConstraints","addConstraintVertices","splits","enforceGabriel","MAX_SPLIT_ITER","getVertexFactory","getPointArray","setConstraints","segVertices","computeConvexHull","hull","findNonGabrielPoint","segRadius","closestNonGabriel","testRadius","getConstraintSegments","setSplitPointFinder","splitFinder","segsToInsert","newSegments","segsToRemove","splitVertex","createVertex","removeAll","getSubdivision","computeBoundingBox","vertexEnv","computeVertexEnvelope","allPointsEnv","setVertexFactory","vertexFactory","formInitialDelaunay","kdnode","snappedV","siteEnv","toVertices","setTolerance","setSites","extractUniqueCoordinates","coordsCopy","createSiteVertices","containsKey","createVertices","createConstraintSegments","cdt","constraintLines","constraintSegs","getDiagram","clipGeometryCollection","setClipEnvelope","clipEnv","clipPoly","clipped","isEndpoint","nseg","lineComp","toLowest","pointAlongSegmentByFraction","getSegmentFraction","setToEnd","isOnSameSegment","snapToVertex","getSegmentLength","lenToStart","lenToEnd","compareLocationValues","componentIndex1","segmentIndex1","segmentFraction1","isVertex","getEndLocation","componentIndex0","segmentIndex0","segmentFraction0","getVertexIndex","getSegmentEnd","getSegmentStart","isEndOfLine","indexOfFromStart","minIndex","minComponentIndex","minSegmentIndex","segDistance","candidateComponentIndex","candidateSegmentIndex","indexOfAfter","endLoc","closestAfter","indicesOf","subLine","locPt","subLineLoc","endLine","getLastCoordinate","rawPts","validCoordinateSequence","setFixInvalidLines","fixInvalidLines","allowRepeatedPoints","setIgnoreInvalidLines","ignoreInvalidLines","computeLinear","builder","computeLine","startSegmentIndex","lastSegmentIndex","newCoordinateArray","clampIndex","extractPoint","indexLow","isValidIndex","ptMeasure","segmentStartMeasure","segMeasureToPt","segmentNearestMeasure","projFactor","totalLength","resolveHigher","compIndex","resolveLower","forwardLength","getLocationForward","positiveIndex","locationOf","locLow","startIndex2","endIndex2","resolveStartLower","Sphere","ascendingComparator","x0$2","y0$2","sign0","sign1","sinLambda0Lambda1","clipAntimeridianIntersect","quickselect","quickselect$1","freeze","default","__moduleExports","rbush_1","_all","childBBox","nodesToSearch","_build","_splitRoot","tmpNode","_insert","equalsFn","goingUp","findItem","_condense","compareMinX","compareMinY","N","right2","right3","N2","N1","_chooseSubtree","targetNode","enlargement","minArea","minEnlargement","enlargedArea","isNode","insertPath","_split","_adjustParentBBoxes","_chooseSplitAxis","splitIndex","_chooseSplitIndex","newNode","bbox1","bbox2","minOverlap","intersectionArea","_allDistMargin","leftBBox","rightBBox","margin","siblings","compareArr","isects","filterFn","useSpatialIndex","ifIsectAddToOutput","ring0","edge1","isect","frac0","frac1","rbushTreeItem","allEdgesAsRbushTreeItems","ringA","edgeA","bboxIsect","determineParents","featuresWithoutParent","setNetWinding","netWinding","setNetWindingOfChildren","ParentNetWinding","numRings","isUnique","numvertices","selfIsectsData","numSelfIsect","outputFeatureArray","leftVtx","modulo","windingOfRing","pseudoVtxListByRingAndEdge","isectList","PseudoVtx","Isect","numIsect","param","allIsectsAsIsectRbushTreeItem","isectRbushTree","coordToFind","IsectRbushTreeItemFound","nxtIsectAlongEdgeIn","nxtIsectAlongRingAndEdge2","ringAndEdge1","ringAndEdgeIn","nxtIsectAlongRingAndEdge1","queue","leftIsect","isectAfterLeftIsect","isectBeforeLeftIsect","windingAtIsect","popped","startIsect","currentOutputRingParent","currentOutputRingWinding","currentOutputRing","currentOutputRingCoords","currentIsect","ringAndEdge1Walkable","walkingRingAndEdge","nxtIsect","ringAndEdge2","nxtIsectInQueue","ringAndEdge2Walkable","pushing","ringAndEdgeOut","findItem$1","enlargedArea$1","intersectionArea$1","ig_turfhelper"],"mappings":"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"}