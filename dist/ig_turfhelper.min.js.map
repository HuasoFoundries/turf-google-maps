{"version":3,"file":"ig_turfhelper.min.js","sources":["ig_turfhelper.js"],"sourcesContent":["(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.turfHelper = global.turfHelper || {})));\n}(this, (function (exports) { 'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n/** @license\n *\n *  Copyright (C) 2012 K. Arthur Endsley (kaendsle@mtu.edu)\n *  Michigan Tech Research Institute (MTRI)\n *  3600 Green Court, Suite 100, Ann Arbor, MI, 48105\n *\n *  This program is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\nvar beginsWith;\nvar endsWith;\n\n/**\n * @desc The Wkt namespace.\n * @property    {String}    delimiter   - The default delimiter for separating components of atomic geometry (coordinates)\n * @namespace\n * @global\n */\nvar Wkt = function Wkt(obj) {\n    if (obj instanceof Wkt) return obj;\n    if (!(this instanceof Wkt)) return new Wkt(obj);\n    this._wrapped = obj;\n};\n\n/**\n * Returns true if the substring is found at the beginning of the string.\n * @param   str {String}    The String to search\n * @param   sub {String}    The substring of interest\n * @return      {Boolean}\n * @private\n */\nbeginsWith = function beginsWith(str, sub) {\n    return str.substring(0, sub.length) === sub;\n};\n\n/**\n * Returns true if the substring is found at the end of the string.\n * @param   str {String}    The String to search\n * @param   sub {String}    The substring of interest\n * @return      {Boolean}\n * @private\n */\nendsWith = function endsWith(str, sub) {\n    return str.substring(str.length - sub.length) === sub;\n};\n\n/**\n * The default delimiter for separating components of atomic geometry (coordinates)\n * @ignore\n */\nWkt.delimiter = ' ';\n\n/**\n * Determines whether or not the passed Object is an Array.\n * @param   obj {Object}    The Object in question\n * @return      {Boolean}\n * @member Wkt.isArray\n * @method\n */\nWkt.isArray = function (obj) {\n    return !!(obj && obj.constructor === Array);\n};\n\n/**\n * Removes given character String(s) from a String.\n * @param   str {String}    The String to search\n * @param   sub {String}    The String character(s) to trim\n * @return      {String}    The trimmed string\n * @member Wkt.trim\n * @method\n */\nWkt.trim = function (str, sub) {\n    sub = sub || ' '; // Defaults to trimming spaces\n    // Trim beginning spaces\n    while (beginsWith(str, sub)) {\n        str = str.substring(1);\n    }\n    // Trim ending spaces\n    while (endsWith(str, sub)) {\n        str = str.substring(0, str.length - 1);\n    }\n    return str;\n};\n\n/**\n * An object for reading WKT strings and writing geographic features\n * @constructor Wkt.Wkt\n * @param   initializer {String}    An optional WKT string for immediate read\n * @property            {Array}     components      - Holder for atomic geometry objects (internal representation of geometric components)\n * @property            {String}    delimiter       - The default delimiter for separating components of atomic geometry (coordinates)\n * @property            {Object}    regExes         - Some regular expressions copied from OpenLayers.Format.WKT.js\n * @property            {String}    type            - The Well-Known Text name (e.g. 'point') of the geometry\n * @property            {Boolean}   wrapVerticies   - True to wrap vertices in MULTIPOINT geometries; If true: MULTIPOINT((30 10),(10 30),(40 40)); If false: MULTIPOINT(30 10,10 30,40 40)\n * @return              {Wkt.Wkt}\n * @memberof Wkt\n */\nWkt.Wkt = function (initializer) {\n\n    /**\n     * The default delimiter between X and Y coordinates.\n     * @ignore\n     */\n    this.delimiter = Wkt.delimiter || ' ';\n\n    /**\n     * Configuration parameter for controlling how Wicket seralizes\n     * MULTIPOINT strings. Examples; both are valid WKT:\n     * If true: MULTIPOINT((30 10),(10 30),(40 40))\n     * If false: MULTIPOINT(30 10,10 30,40 40)\n     * @ignore\n     */\n    this.wrapVertices = true;\n\n    /**\n     * Some regular expressions copied from OpenLayers.Format.WKT.js\n     * @ignore\n     */\n    this.regExes = {\n        'typeStr': /^\\s*(\\w+)\\s*\\(\\s*(.*)\\s*\\)\\s*$/,\n        'spaces': /\\s+|\\+/, // Matches the '+' or the empty space\n        'numeric': /-*\\d+(\\.*\\d+)?/,\n        'comma': /\\s*,\\s*/,\n        'parenComma': /\\)\\s*,\\s*\\(/,\n        'coord': /-*\\d+\\.*\\d+ -*\\d+\\.*\\d+/, // e.g. \"24 -14\"\n        'doubleParenComma': /\\)\\s*\\)\\s*,\\s*\\(\\s*\\(/,\n        'trimParens': /^\\s*\\(?(.*?)\\)?\\s*$/,\n        'ogcTypes': /^(multi)?(point|line|polygon|box)?(string)?$/i, // Captures e.g. \"Multi\",\"Line\",\"String\"\n        'crudeJson': /^{.*\"(type|coordinates|geometries|features)\":.*}$/ // Attempts to recognize JSON strings\n    };\n\n    /**\n     * The internal representation of geometry--the \"components\" of geometry.\n     * @ignore\n     */\n    this.components = undefined;\n\n    // An initial WKT string may be provided\n    if (initializer && typeof initializer === 'string') {\n        this.read(initializer);\n    } else if (initializer && (typeof initializer === 'undefined' ? 'undefined' : _typeof(initializer)) !== undefined) {\n        this.fromObject(initializer);\n    }\n};\n\n/**\n * Returns true if the internal geometry is a collection of geometries.\n * @return  {Boolean}   Returns true when it is a collection\n * @memberof Wkt.Wkt\n * @method\n */\nWkt.Wkt.prototype.isCollection = function () {\n    switch (this.type.slice(0, 5)) {\n        case 'multi':\n            // Trivial; any multi-geometry is a collection\n            return true;\n        case 'polyg':\n            // Polygons with holes are \"collections\" of rings\n            return true;\n        default:\n            // Any other geometry is not a collection\n            return false;\n    }\n};\n\n/**\n * Compares two x,y coordinates for equality.\n * @param   a   {Object}    An object with x and y properties\n * @param   b   {Object}    An object with x and y properties\n * @return      {Boolean}\n * @memberof Wkt.Wkt\n * @method\n */\nWkt.Wkt.prototype.sameCoords = function (a, b) {\n    return a.x === b.x && a.y === b.y;\n};\n\n/**\n * Sets internal geometry (components) from framework geometry (e.g.\n * Google Polygon objects or google.maps.Polygon).\n * @param   obj {Object}    The framework-dependent geometry representation\n * @return      {Wkt.Wkt}   The object itself\n * @memberof Wkt.Wkt\n * @method\n */\nWkt.Wkt.prototype.fromObject = function (obj) {\n    var result;\n\n    if (obj.hasOwnProperty('type') && obj.hasOwnProperty('coordinates')) {\n        result = this.fromJson(obj);\n    } else {\n        result = this.deconstruct.call(this, obj);\n    }\n\n    this.components = result.components;\n    this.isRectangle = result.isRectangle || false;\n    this.type = result.type;\n    return this;\n};\n\n/**\n * Creates external geometry objects based on a plug-in framework's\n * construction methods and available geometry classes.\n * @param   config  {Object}    An optional framework-dependent properties specification\n * @return          {Object}    The framework-dependent geometry representation\n * @memberof Wkt.Wkt\n * @method\n */\nWkt.Wkt.prototype.toObject = function (config) {\n    var obj = this.construct[this.type].call(this, config);\n    // Don't assign the \"properties\" property to an Array\n    if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && !Wkt.isArray(obj)) {\n        obj.properties = this.properties;\n    }\n    return obj;\n};\n\n/**\n * Returns the WKT string representation; the same as the write() method.\n * @memberof Wkt.Wkt\n * @method\n */\nWkt.Wkt.prototype.toString = function (config) {\n    return this.write();\n};\n\n/**\n * Parses a JSON representation as an Object.\n * @param   obj {Object}    An Object with the GeoJSON schema\n * @return  {Wkt.Wkt}  The object itself\n * @memberof Wkt.Wkt\n * @method\n */\nWkt.Wkt.prototype.fromJson = function (obj) {\n    var i, j, k, coords, iring, oring;\n\n    this.type = obj.type.toLowerCase();\n    this.components = [];\n    if (obj.hasOwnProperty('geometry')) {\n        //Feature\n        this.fromJson(obj.geometry);\n        this.properties = obj.properties;\n        return this;\n    }\n    coords = obj.coordinates;\n\n    if (!Wkt.isArray(coords[0])) {\n        // Point\n        this.components.push({\n            x: coords[0],\n            y: coords[1]\n        });\n    } else {\n\n        for (i in coords) {\n            if (coords.hasOwnProperty(i)) {\n\n                if (!Wkt.isArray(coords[i][0])) {\n                    // LineString\n\n                    if (this.type === 'multipoint') {\n                        // MultiPoint\n                        this.components.push([{\n                            x: coords[i][0],\n                            y: coords[i][1]\n                        }]);\n                    } else {\n                        this.components.push({\n                            x: coords[i][0],\n                            y: coords[i][1]\n                        });\n                    }\n                } else {\n\n                    oring = [];\n                    for (j in coords[i]) {\n                        if (coords[i].hasOwnProperty(j)) {\n\n                            if (!Wkt.isArray(coords[i][j][0])) {\n                                oring.push({\n                                    x: coords[i][j][0],\n                                    y: coords[i][j][1]\n                                });\n                            } else {\n\n                                iring = [];\n                                for (k in coords[i][j]) {\n                                    if (coords[i][j].hasOwnProperty(k)) {\n\n                                        iring.push({\n                                            x: coords[i][j][k][0],\n                                            y: coords[i][j][k][1]\n                                        });\n                                    }\n                                }\n\n                                oring.push(iring);\n                            }\n                        }\n                    }\n\n                    this.components.push(oring);\n                }\n            }\n        }\n    }\n\n    return this;\n};\n\n/**\n * Creates a JSON representation, with the GeoJSON schema, of the geometry.\n * @return    {Object}    The corresponding GeoJSON representation\n * @memberof Wkt.Wkt\n * @method\n */\nWkt.Wkt.prototype.toJson = function () {\n    var cs, json, i, j, k, ring, rings;\n\n    cs = this.components;\n    json = {\n        coordinates: [],\n        type: function () {\n            var i, type, s;\n\n            type = this.regExes.ogcTypes.exec(this.type).slice(1);\n            s = [];\n\n            for (i in type) {\n                if (type.hasOwnProperty(i)) {\n                    if (type[i] !== undefined) {\n                        s.push(type[i].toLowerCase().slice(0, 1).toUpperCase() + type[i].toLowerCase().slice(1));\n                    }\n                }\n            }\n\n            return s;\n        }.call(this).join('')\n\n        // Wkt BOX type gets a special bbox property in GeoJSON\n    };if (this.type.toLowerCase() === 'box') {\n        json.type = 'Polygon';\n        json.bbox = [];\n\n        for (i in cs) {\n            if (cs.hasOwnProperty(i)) {\n                json.bbox = json.bbox.concat([cs[i].x, cs[i].y]);\n            }\n        }\n\n        json.coordinates = [[[cs[0].x, cs[0].y], [cs[0].x, cs[1].y], [cs[1].x, cs[1].y], [cs[1].x, cs[0].y], [cs[0].x, cs[0].y]]];\n\n        return json;\n    }\n\n    // For the coordinates of most simple features\n    for (i in cs) {\n        if (cs.hasOwnProperty(i)) {\n\n            // For those nested structures\n            if (Wkt.isArray(cs[i])) {\n                rings = [];\n\n                for (j in cs[i]) {\n                    if (cs[i].hasOwnProperty(j)) {\n\n                        if (Wkt.isArray(cs[i][j])) {\n                            // MULTIPOLYGONS\n                            ring = [];\n\n                            for (k in cs[i][j]) {\n                                if (cs[i][j].hasOwnProperty(k)) {\n                                    ring.push([cs[i][j][k].x, cs[i][j][k].y]);\n                                }\n                            }\n\n                            rings.push(ring);\n                        } else {\n                            // POLYGONS and MULTILINESTRINGS\n\n                            if (cs[i].length > 1) {\n                                rings.push([cs[i][j].x, cs[i][j].y]);\n                            } else {\n                                // MULTIPOINTS\n                                rings = rings.concat([cs[i][j].x, cs[i][j].y]);\n                            }\n                        }\n                    }\n                }\n\n                json.coordinates.push(rings);\n            } else {\n                if (cs.length > 1) {\n                    // For LINESTRING type\n                    json.coordinates.push([cs[i].x, cs[i].y]);\n                } else {\n                    // For POINT type\n                    json.coordinates = json.coordinates.concat([cs[i].x, cs[i].y]);\n                }\n            }\n        }\n    }\n\n    return json;\n};\n\n/**\n * Absorbs the geometry of another Wkt.Wkt instance, merging it with its own,\n * creating a collection (MULTI-geometry) based on their types, which must agree.\n * For example, creates a MULTIPOLYGON from a POLYGON type merged with another\n * POLYGON type, or adds a POLYGON instance to a MULTIPOLYGON instance.\n * @param   wkt {String}    A Wkt.Wkt object\n * @return  {Wkt.Wkt}  The object itself\n * @memberof Wkt.Wkt\n * @method\n */\nWkt.Wkt.prototype.merge = function (wkt) {\n    var prefix = this.type.slice(0, 5);\n\n    if (this.type !== wkt.type) {\n        if (this.type.slice(5, this.type.length) !== wkt.type) {\n            throw TypeError('The input geometry types must agree or the calling Wkt.Wkt instance must be a multigeometry of the other');\n        }\n    }\n\n    switch (prefix) {\n\n        case 'point':\n            this.components = [this.components.concat(wkt.components)];\n            break;\n\n        case 'multi':\n            this.components = this.components.concat(wkt.type.slice(0, 5) === 'multi' ? wkt.components : [wkt.components]);\n            break;\n\n        default:\n            this.components = [this.components, wkt.components];\n            break;\n\n    }\n\n    if (prefix !== 'multi') {\n        this.type = 'multi' + this.type;\n    }\n    return this;\n};\n\n/**\n * Reads a WKT string, validating and incorporating it.\n * @param   str {String}    A WKT or GeoJSON string\n * @return  {Wkt.Wkt}  The object itself\n * @memberof Wkt.Wkt\n * @method\n */\nWkt.Wkt.prototype.read = function (str) {\n    var matches;\n    matches = this.regExes.typeStr.exec(str);\n    if (matches) {\n        this.type = matches[1].toLowerCase();\n        this.base = matches[2];\n        if (this.ingest[this.type]) {\n            this.components = this.ingest[this.type].apply(this, [this.base]);\n        }\n    } else {\n        if (this.regExes.crudeJson.test(str)) {\n            if ((typeof JSON === 'undefined' ? 'undefined' : _typeof(JSON)) === 'object' && typeof JSON.parse === 'function') {\n                this.fromJson(JSON.parse(str));\n            } else {\n                console.log('JSON.parse() is not available; cannot parse GeoJSON strings');\n                throw {\n                    name: 'JSONError',\n                    message: 'JSON.parse() is not available; cannot parse GeoJSON strings'\n                };\n            }\n        } else {\n            console.log('Invalid WKT string provided to read() ', str);\n            throw {\n                name: 'WKTError',\n                message: 'Invalid WKT string provided to read()'\n            };\n        }\n    }\n\n    return this;\n}; // eo readWkt\n\n/**\n * Writes a WKT string.\n * @param   components  {Array}     An Array of internal geometry objects\n * @return              {String}    The corresponding WKT representation\n * @memberof Wkt.Wkt\n * @method\n */\nWkt.Wkt.prototype.write = function (components) {\n    var i, pieces, data;\n\n    components = components || this.components;\n\n    pieces = [];\n\n    pieces.push(this.type.toUpperCase() + '(');\n\n    for (i = 0; i < components.length; i += 1) {\n        if (this.isCollection() && i > 0) {\n            pieces.push(',');\n        }\n\n        // There should be an extract function for the named type\n        if (!this.extract[this.type]) {\n            return null;\n        }\n\n        data = this.extract[this.type].apply(this, [components[i]]);\n        if (this.isCollection() && this.type !== 'multipoint') {\n            pieces.push('(' + data + ')');\n        } else {\n            pieces.push(data);\n\n            // If not at the end of the components, add a comma\n            if (i !== components.length - 1 && this.type !== 'multipoint') {\n                pieces.push(',');\n            }\n        }\n    }\n\n    pieces.push(')');\n\n    return pieces.join('');\n};\n\n/**\n * This object contains functions as property names that extract WKT\n * strings from the internal representation.\n * @memberof Wkt.Wkt\n * @namespace Wkt.Wkt.extract\n * @instance\n */\nWkt.Wkt.prototype.extract = {\n    /**\n     * Return a WKT string representing atomic (point) geometry\n     * @param   point   {Object}    An object with x and y properties\n     * @return          {String}    The WKT representation\n     * @memberof Wkt.Wkt.extract\n     * @instance\n     */\n    point: function point(_point) {\n        return String(_point.x) + this.delimiter + String(_point.y);\n    },\n\n    /**\n     * Return a WKT string representing multiple atoms (points)\n     * @param   multipoint  {Array}     Multiple x-and-y objects\n     * @return              {String}    The WKT representation\n     * @memberof Wkt.Wkt.extract\n     * @instance\n     */\n    multipoint: function multipoint(_multipoint) {\n        var i,\n            parts = [],\n            s;\n\n        for (i = 0; i < _multipoint.length; i += 1) {\n            s = this.extract.point.apply(this, [_multipoint[i]]);\n\n            if (this.wrapVertices) {\n                s = '(' + s + ')';\n            }\n\n            parts.push(s);\n        }\n\n        return parts.join(',');\n    },\n\n    /**\n     * Return a WKT string representing a chain (linestring) of atoms\n     * @param   linestring  {Array}     Multiple x-and-y objects\n     * @return              {String}    The WKT representation\n     * @memberof Wkt.Wkt.extract\n     * @instance\n     */\n    linestring: function linestring(_linestring) {\n        // Extraction of linestrings is the same as for points\n        return this.extract.point.apply(this, [_linestring]);\n    },\n\n    /**\n     * Return a WKT string representing multiple chains (multilinestring) of atoms\n     * @param   multilinestring {Array}     Multiple of multiple x-and-y objects\n     * @return                  {String}    The WKT representation\n     * @memberof Wkt.Wkt.extract\n     * @instance\n     */\n    multilinestring: function multilinestring(_multilinestring) {\n        var i,\n            parts = [];\n\n        if (_multilinestring.length) {\n            for (i = 0; i < _multilinestring.length; i += 1) {\n                parts.push(this.extract.linestring.apply(this, [_multilinestring[i]]));\n            }\n        } else {\n            parts.push(this.extract.point.apply(this, [_multilinestring]));\n        }\n\n        return parts.join(',');\n    },\n\n    /**\n     * Return a WKT string representing multiple atoms in closed series (polygon)\n     * @param   polygon {Array}     Collection of ordered x-and-y objects\n     * @return          {String}    The WKT representation\n     * @memberof Wkt.Wkt.extract\n     * @instance\n     */\n    polygon: function polygon(_polygon) {\n        // Extraction of polygons is the same as for multilinestrings\n        return this.extract.multilinestring.apply(this, [_polygon]);\n    },\n\n    /**\n     * Return a WKT string representing multiple closed series (multipolygons) of multiple atoms\n     * @param   multipolygon    {Array}     Collection of ordered x-and-y objects\n     * @return                  {String}    The WKT representation\n     * @memberof Wkt.Wkt.extract\n     * @instance\n     */\n    multipolygon: function multipolygon(_multipolygon) {\n        var i,\n            parts = [];\n        for (i = 0; i < _multipolygon.length; i += 1) {\n            parts.push('(' + this.extract.polygon.apply(this, [_multipolygon[i]]) + ')');\n        }\n        return parts.join(',');\n    },\n\n    /**\n     * Return a WKT string representing a 2DBox\n     * @param   multipolygon    {Array}     Collection of ordered x-and-y objects\n     * @return                  {String}    The WKT representation\n     * @memberof Wkt.Wkt.extract\n     * @instance\n     */\n    box: function box(_box) {\n        return this.extract.linestring.apply(this, [_box]);\n    },\n\n    geometrycollection: function geometrycollection(str) {\n        console.log('The geometrycollection WKT type is not yet supported.');\n    }\n};\n\n/**\n * This object contains functions as property names that ingest WKT\n * strings into the internal representation.\n * @memberof Wkt.Wkt\n * @namespace Wkt.Wkt.ingest\n * @instance\n */\nWkt.Wkt.prototype.ingest = {\n\n    /**\n     * Return point feature given a point WKT fragment.\n     * @param   str {String}    A WKT fragment representing the point\n     * @memberof Wkt.Wkt.ingest\n     * @instance\n     */\n    point: function point(str) {\n        var coords = Wkt.trim(str).split(this.regExes.spaces);\n        // In case a parenthetical group of coordinates is passed...\n        return [{ // ...Search for numeric substrings\n            x: parseFloat(this.regExes.numeric.exec(coords[0])[0]),\n            y: parseFloat(this.regExes.numeric.exec(coords[1])[0])\n        }];\n    },\n\n    /**\n     * Return a multipoint feature given a multipoint WKT fragment.\n     * @param   str {String}    A WKT fragment representing the multipoint\n     * @memberof Wkt.Wkt.ingest\n     * @instance\n     */\n    multipoint: function multipoint(str) {\n        var i, components, points;\n        components = [];\n        points = Wkt.trim(str).split(this.regExes.comma);\n        for (i = 0; i < points.length; i += 1) {\n            components.push(this.ingest.point.apply(this, [points[i]]));\n        }\n        return components;\n    },\n\n    /**\n     * Return a linestring feature given a linestring WKT fragment.\n     * @param   str {String}    A WKT fragment representing the linestring\n     * @memberof Wkt.Wkt.ingest\n     * @instance\n     */\n    linestring: function linestring(str) {\n        var i, multipoints, components;\n\n        // In our x-and-y representation of components, parsing\n        //  multipoints is the same as parsing linestrings\n        multipoints = this.ingest.multipoint.apply(this, [str]);\n\n        // However, the points need to be joined\n        components = [];\n        for (i = 0; i < multipoints.length; i += 1) {\n            components = components.concat(multipoints[i]);\n        }\n        return components;\n    },\n\n    /**\n     * Return a multilinestring feature given a multilinestring WKT fragment.\n     * @param   str {String}    A WKT fragment representing the multilinestring\n     * @memberof Wkt.Wkt.ingest\n     * @instance\n     */\n    multilinestring: function multilinestring(str) {\n        var i, components, line, lines;\n        components = [];\n\n        lines = Wkt.trim(str).split(this.regExes.doubleParenComma);\n        if (lines.length === 1) {\n            // If that didn't work...\n            lines = Wkt.trim(str).split(this.regExes.parenComma);\n        }\n\n        for (i = 0; i < lines.length; i += 1) {\n            line = lines[i].replace(this.regExes.trimParens, '$1');\n            components.push(this.ingest.linestring.apply(this, [line]));\n        }\n\n        return components;\n    },\n\n    /**\n     * Return a polygon feature given a polygon WKT fragment.\n     * @param   str {String}    A WKT fragment representing the polygon\n     * @memberof Wkt.Wkt.ingest\n     * @instance\n     */\n    polygon: function polygon(str) {\n        var i, j, components, subcomponents, ring, rings;\n        rings = Wkt.trim(str).split(this.regExes.parenComma);\n        components = []; // Holds one or more rings\n        for (i = 0; i < rings.length; i += 1) {\n            ring = rings[i].replace(this.regExes.trimParens, '$1').split(this.regExes.comma);\n            subcomponents = []; // Holds the outer ring and any inner rings (holes)\n            for (j = 0; j < ring.length; j += 1) {\n                // Split on the empty space or '+' character (between coordinates)\n                var split = ring[j].split(this.regExes.spaces);\n                if (split.length > 2) {\n                    //remove the elements which are blanks\n                    split = split.filter(function (n) {\n                        return n != \"\";\n                    });\n                }\n                if (split.length === 2) {\n                    var x_cord = split[0];\n                    var y_cord = split[1];\n\n                    //now push\n                    subcomponents.push({\n                        x: parseFloat(x_cord),\n                        y: parseFloat(y_cord)\n                    });\n                }\n            }\n            components.push(subcomponents);\n        }\n        return components;\n    },\n\n    /**\n     * Return box vertices (which would become the Rectangle bounds) given a Box WKT fragment.\n     * @param   str {String}    A WKT fragment representing the box\n     * @memberof Wkt.Wkt.ingest\n     * @instance\n     */\n    box: function box(str) {\n        var i, multipoints, components;\n\n        // In our x-and-y representation of components, parsing\n        //  multipoints is the same as parsing linestrings\n        multipoints = this.ingest.multipoint.apply(this, [str]);\n\n        // However, the points need to be joined\n        components = [];\n        for (i = 0; i < multipoints.length; i += 1) {\n            components = components.concat(multipoints[i]);\n        }\n\n        return components;\n    },\n\n    /**\n     * Return a multipolygon feature given a multipolygon WKT fragment.\n     * @param   str {String}    A WKT fragment representing the multipolygon\n     * @memberof Wkt.Wkt.ingest\n     * @instance\n     */\n    multipolygon: function multipolygon(str) {\n        var i, components, polygon, polygons;\n        components = [];\n        polygons = Wkt.trim(str).split(this.regExes.doubleParenComma);\n        for (i = 0; i < polygons.length; i += 1) {\n            polygon = polygons[i].replace(this.regExes.trimParens, '$1');\n            components.push(this.ingest.polygon.apply(this, [polygon]));\n        }\n        return components;\n    },\n\n    /**\n     * Return an array of features given a geometrycollection WKT fragment.\n     * @param   str {String}    A WKT fragment representing the geometry collection\n     * @memberof Wkt.Wkt.ingest\n     * @instance\n     */\n    geometrycollection: function geometrycollection(str) {\n        console.log('The geometrycollection WKT type is not yet supported.');\n    }\n\n}; // eo ingest\n\n/**\n * @augments Wkt.Wkt\n * A framework-dependent flag, set for each Wkt.Wkt() instance, that indicates\n * whether or not a closed polygon geometry should be interpreted as a rectangle.\n */\nWkt.Wkt.prototype.isRectangle = false;\n\n/**\n * @augments Wkt.Wkt\n * An object of framework-dependent construction methods used to generate\n * objects belonging to the various geometry classes of the framework.\n */\nWkt.Wkt.prototype.construct = {\n    /**\n     * Creates the framework's equivalent point geometry object.\n     * @param   config      {Object}    An optional properties hash the object should use\n     * @param   component   {Object}    An optional component to build from\n     * @return              {google.maps.Marker}\n     */\n    point: function point(config, component) {\n        var c = component || this.components;\n\n        config = config || {\n            optimized: true\n        };\n\n        config.position = new google.maps.LatLng(c[0].y, c[0].x);\n\n        return new google.maps.Marker(config);\n    },\n\n    /**\n     * Creates the framework's equivalent multipoint geometry object.\n     * @param   config  {Object}    An optional properties hash the object should use\n     * @return          {Array}     Array containing multiple google.maps.Marker\n     */\n    multipoint: function multipoint(config) {\n        var i, c, arr;\n\n        c = this.components;\n\n        config = config || {};\n\n        arr = [];\n\n        for (i = 0; i < c.length; i += 1) {\n            arr.push(this.construct.point(config, c[i]));\n        }\n\n        return arr;\n    },\n\n    /**\n     * Creates the framework's equivalent linestring geometry object.\n     * @param   config      {Object}    An optional properties hash the object should use\n     * @param   component   {Object}    An optional component to build from\n     * @return              {google.maps.Polyline}\n     */\n    linestring: function linestring(config, component) {\n        var i, c;\n\n        c = component || this.components;\n\n        config = config || {\n            editable: false\n        };\n\n        config.path = [];\n\n        for (i = 0; i < c.length; i += 1) {\n            config.path.push(new google.maps.LatLng(c[i].y, c[i].x));\n        }\n\n        return new google.maps.Polyline(config);\n    },\n\n    /**\n     * Creates the framework's equivalent multilinestring geometry object.\n     * @param   config  {Object}    An optional properties hash the object should use\n     * @return          {Array}     Array containing multiple google.maps.Polyline instances\n     */\n    multilinestring: function multilinestring(config) {\n        var i, c, arr;\n\n        c = this.components;\n\n        config = config || {\n            editable: false\n        };\n\n        config.path = [];\n\n        arr = [];\n\n        for (i = 0; i < c.length; i += 1) {\n            arr.push(this.construct.linestring(config, c[i]));\n        }\n\n        return arr;\n    },\n\n    /**\n     * Creates the framework's equivalent Box or Rectangle geometry object.\n     * @param   config      {Object}    An optional properties hash the object should use\n     * @param   component   {Object}    An optional component to build from\n     * @return              {google.maps.Rectangle}\n     */\n    box: function box(config, component) {\n        var c = component || this.components;\n\n        config = config || {};\n\n        config.bounds = new google.maps.LatLngBounds(new google.maps.LatLng(c[0].y, c[0].x), new google.maps.LatLng(c[1].y, c[1].x));\n\n        return new google.maps.Rectangle(config);\n    },\n\n    /**\n     * Creates the framework's equivalent polygon geometry object.\n     * @param   config      {Object}    An optional properties hash the object should use\n     * @param   component   {Object}    An optional component to build from\n     * @return              {google.maps.Polygon}\n     */\n    polygon: function polygon(config, component) {\n        var j, k, c, rings, verts;\n\n        c = component || this.components;\n\n        config = config || {\n            editable: false // Editable geometry off by default\n        };\n\n        config.paths = [];\n\n        rings = [];\n        for (j = 0; j < c.length; j += 1) {\n            // For each ring...\n\n            verts = [];\n            // NOTE: We iterate to one (1) less than the Array length to skip the last vertex\n            for (k = 0; k < c[j].length - 1; k += 1) {\n                // For each vertex...\n                verts.push(new google.maps.LatLng(c[j][k].y, c[j][k].x));\n            } // eo for each vertex\n\n            if (j !== 0) {\n                // Reverse the order of coordinates in inner rings\n                if (config.reverseInnerPolygons === null || config.reverseInnerPolygons) {\n                    verts.reverse();\n                }\n            }\n\n            rings.push(verts);\n        } // eo for each ring\n\n        config.paths = config.paths.concat(rings);\n\n        if (this.isRectangle) {\n            return function () {\n                var bounds, v;\n\n                bounds = new google.maps.LatLngBounds();\n\n                for (v in rings[0]) {\n                    // Ought to be only 1 ring in a Rectangle\n                    if (rings[0].hasOwnProperty(v)) {\n                        bounds.extend(rings[0][v]);\n                    }\n                }\n\n                return new google.maps.Rectangle({\n                    bounds: bounds\n                });\n            }();\n        } else {\n            return new google.maps.Polygon(config);\n        }\n    },\n\n    /**\n     * Creates the framework's equivalent multipolygon geometry object.\n     * @param   config  {Object}    An optional properties hash the object should use\n     * @return          {Array}     Array containing multiple google.maps.Polygon\n     */\n    multipolygon: function multipolygon(config) {\n        var i, c, arr;\n\n        c = this.components;\n\n        config = config || {\n            editable: false\n        };\n\n        config.path = [];\n\n        arr = [];\n\n        for (i = 0; i < c.length; i += 1) {\n            arr.push(this.construct.polygon(config, c[i]));\n        }\n\n        return arr;\n    }\n\n};\n\n/**\n * @augments Wkt.Wkt\n * A framework-dependent deconstruction method used to generate internal\n * geometric representations from instances of framework geometry. This method\n * uses object detection to attempt to classify members of framework geometry\n * classes into the standard WKT types.\n * @param obj       {Object}    An instance of one of the framework's geometry classes\n * @param multiFlag {Boolean} If true, then the deconstructor will be forced to return a MultiGeometry (multipoint, multilinestring or multipolygon)\n * @return          {Object}    A hash of the 'type' and 'components' thus derived, plus the WKT string of the feature.\n */\nWkt.Wkt.prototype.deconstruct = function (obj, multiFlag) {\n    var features, i, j, verts, rings, sign, tmp, response, lat, lng, vertex, ring;\n    var polygons, polygon, k, linestring, linestrings;\n    // Shortcut to signed area function (determines clockwise vs counter-clock)\n    if (google.maps.geometry) {\n        sign = google.maps.geometry.spherical.computeSignedArea;\n    }\n\n    // google.maps.LatLng //////////////////////////////////////////////////////\n    if (obj.constructor === google.maps.LatLng) {\n\n        response = {\n            type: 'point',\n            components: [{\n                x: obj.lng(),\n                y: obj.lat()\n            }]\n        };\n        return response;\n    }\n\n    // google.maps.Point //////////////////////////////////////////////////////\n    if (obj.constructor === google.maps.Point) {\n        response = {\n            type: 'point',\n            components: [{\n                x: obj.x,\n                y: obj.y\n            }]\n        };\n        return response;\n    }\n\n    // google.maps.Marker //////////////////////////////////////////////////////\n    if (obj.constructor === google.maps.Marker) {\n        response = {\n            type: 'point',\n            components: [{\n                x: obj.getPosition().lng(),\n                y: obj.getPosition().lat()\n            }]\n        };\n        return response;\n    }\n\n    // google.maps.Polyline ////////////////////////////////////////////////////\n    if (obj.constructor === google.maps.Polyline) {\n\n        verts = [];\n        for (i = 0; i < obj.getPath().length; i += 1) {\n            tmp = obj.getPath().getAt(i);\n            verts.push({\n                x: tmp.lng(),\n                y: tmp.lat()\n            });\n        }\n        response = {\n            type: 'linestring',\n            components: verts\n        };\n        return response;\n    }\n\n    // google.maps.Polygon /////////////////////////////////////////////////////\n    if (obj.constructor === google.maps.Polygon) {\n\n        rings = [];\n\n        if (multiFlag === undefined) {\n            multiFlag = function () {\n                var areas, l;\n\n                l = obj.getPaths().length;\n                if (l <= 1) {\n                    // Trivial; this is a single polygon\n                    return false;\n                }\n\n                if (l === 2) {\n                    // If clockwise*clockwise or counter*counter, i.e.\n                    //  (-1)*(-1) or (1)*(1), then result would be positive\n                    if (sign(obj.getPaths().getAt(0)) * sign(obj.getPaths().getAt(1)) < 0) {\n                        return false; // Most likely single polygon with 1 hole\n                    }\n\n                    return true;\n                }\n\n                // Must be longer than 3 polygons at this point...\n                areas = obj.getPaths().getArray().map(function (k) {\n                    return sign(k) / Math.abs(sign(k)); // Unit normalization (outputs 1 or -1)\n                });\n\n                // If two clockwise or two counter-clockwise rings are found\n                //  (at different indices)...\n                if (areas.indexOf(areas[0]) !== areas.lastIndexOf(areas[0])) {\n                    multiFlag = true; // Flag for holes in one or more polygons\n                    return true;\n                }\n\n                return false;\n            }();\n        }\n\n        for (i = 0; i < obj.getPaths().length; i += 1) {\n            // For each polygon (ring)...\n            tmp = obj.getPaths().getAt(i);\n            verts = [];\n            for (j = 0; j < obj.getPaths().getAt(i).length; j += 1) {\n                // For each vertex...\n                verts.push({\n                    x: tmp.getAt(j).lng(),\n                    y: tmp.getAt(j).lat()\n                });\n            }\n\n            if (!tmp.getAt(tmp.length - 1).equals(tmp.getAt(0))) {\n                if (i % 2 !== 0) {\n                    // In inner rings, coordinates are reversed...\n                    verts.unshift({ // Add the first coordinate again for closure\n                        x: tmp.getAt(tmp.length - 1).lng(),\n                        y: tmp.getAt(tmp.length - 1).lat()\n                    });\n                } else {\n                    verts.push({ // Add the first coordinate again for closure\n                        x: tmp.getAt(0).lng(),\n                        y: tmp.getAt(0).lat()\n                    });\n                }\n            }\n\n            if (obj.getPaths().length > 1 && i > 0) {\n                // If this and the last ring have the same signs...\n                if (sign(obj.getPaths().getAt(i)) > 0 && sign(obj.getPaths().getAt(i - 1)) > 0 || sign(obj.getPaths().getAt(i)) < 0 && sign(obj.getPaths().getAt(i - 1)) < 0 && !multiFlag) {\n                    // ...They must both be inner rings (or both be outer rings, in a multipolygon)\n                    verts = [verts]; // Wrap multipolygons once more (collection)\n                }\n            }\n\n            //TODO This makes mistakes when a second polygon has holes; it sees them all as individual polygons\n            if (i % 2 !== 0) {\n                // In inner rings, coordinates are reversed...\n                verts.reverse();\n            }\n            rings.push(verts);\n        }\n\n        response = {\n            type: multiFlag ? 'multipolygon' : 'polygon',\n            components: rings\n        };\n        return response;\n    }\n\n    // google.maps.Circle //////////////////////////////////////////////////////\n    if (obj.constructor === google.maps.Circle) {\n        var point = obj.getCenter();\n        var radius = obj.getRadius();\n        verts = [];\n        var d2r = Math.PI / 180; // degrees to radians\n        var r2d = 180 / Math.PI; // radians to degrees\n        radius = radius / 1609; // meters to miles\n        var earthsradius = 3963; // 3963 is the radius of the earth in miles\n        var num_seg = 32; // number of segments used to approximate a circle\n        var rlat = radius / earthsradius * r2d;\n        var rlng = rlat / Math.cos(point.lat() * d2r);\n\n        for (var n = 0; n <= num_seg; n++) {\n            var theta = Math.PI * (n / (num_seg / 2));\n            lng = point.lng() + rlng * Math.cos(theta); // center a + radius x * cos(theta)\n            lat = point.lat() + rlat * Math.sin(theta); // center b + radius y * sin(theta)\n            verts.push({\n                x: lng,\n                y: lat\n            });\n        }\n\n        response = {\n            type: 'polygon',\n            components: [verts]\n        };\n\n        return response;\n    }\n\n    // google.maps.LatLngBounds ///////////////////////////////////////////////////\n    if (obj.constructor === google.maps.LatLngBounds) {\n\n        tmp = obj;\n        verts = [];\n        verts.push({ // NW corner\n            x: tmp.getSouthWest().lng(),\n            y: tmp.getNorthEast().lat()\n        });\n\n        verts.push({ // NE corner\n            x: tmp.getNorthEast().lng(),\n            y: tmp.getNorthEast().lat()\n        });\n\n        verts.push({ // SE corner\n            x: tmp.getNorthEast().lng(),\n            y: tmp.getSouthWest().lat()\n        });\n\n        verts.push({ // SW corner\n            x: tmp.getSouthWest().lng(),\n            y: tmp.getSouthWest().lat()\n        });\n\n        verts.push({ // NW corner (again, for closure)\n            x: tmp.getSouthWest().lng(),\n            y: tmp.getNorthEast().lat()\n        });\n\n        response = {\n            type: 'polygon',\n            isRectangle: true,\n            components: [verts]\n        };\n\n        return response;\n    }\n\n    // google.maps.Rectangle ///////////////////////////////////////////////////\n    if (obj.constructor === google.maps.Rectangle) {\n\n        tmp = obj.getBounds();\n        verts = [];\n        verts.push({ // NW corner\n            x: tmp.getSouthWest().lng(),\n            y: tmp.getNorthEast().lat()\n        });\n\n        verts.push({ // NE corner\n            x: tmp.getNorthEast().lng(),\n            y: tmp.getNorthEast().lat()\n        });\n\n        verts.push({ // SE corner\n            x: tmp.getNorthEast().lng(),\n            y: tmp.getSouthWest().lat()\n        });\n\n        verts.push({ // SW corner\n            x: tmp.getSouthWest().lng(),\n            y: tmp.getSouthWest().lat()\n        });\n\n        verts.push({ // NW corner (again, for closure)\n            x: tmp.getSouthWest().lng(),\n            y: tmp.getNorthEast().lat()\n        });\n\n        response = {\n            type: 'polygon',\n            isRectangle: true,\n            components: [verts]\n        };\n\n        return response;\n    }\n\n    // google.maps.Data Geometry Types /////////////////////////////////////////////////////\n\n    // google.maps.Data.Feature /////////////////////////////////////////////////////\n    if (obj.constructor === google.maps.Data.Feature) {\n        return this.deconstruct.call(this, obj.getGeometry());\n    }\n\n    // google.maps.Data.Point /////////////////////////////////////////////////////\n    if (obj.constructor === google.maps.Data.Point) {\n        //console.zlog('It is a google.maps.Data.Point');\n        response = {\n            type: 'point',\n            components: [{\n                x: obj.get().lng(),\n                y: obj.get().lat()\n            }]\n        };\n        return response;\n    }\n\n    // google.maps.Data.LineString /////////////////////////////////////////////////////\n    if (obj.constructor === google.maps.Data.LineString) {\n        verts = [];\n        //console.zlog('It is a google.maps.Data.LineString');\n        for (i = 0; i < obj.getLength(); i += 1) {\n            vertex = obj.getAt(i);\n            verts.push({\n                x: vertex.lng(),\n                y: vertex.lat()\n            });\n        }\n        response = {\n            type: 'linestring',\n            components: verts\n        };\n        return response;\n    }\n\n    // google.maps.Data.Polygon /////////////////////////////////////////////////////\n    if (obj.constructor === google.maps.Data.Polygon) {\n        rings = [];\n        //console.zlog('It is a google.maps.Data.Polygon');\n        for (i = 0; i < obj.getLength(); i += 1) {\n            // For each ring...\n            ring = obj.getAt(i);\n            verts = [];\n            for (j = 0; j < ring.getLength(); j += 1) {\n                // For each vertex...\n                vertex = ring.getAt(j);\n                verts.push({\n                    x: vertex.lng(),\n                    y: vertex.lat()\n                });\n            }\n            verts.push({\n                x: ring.getAt(0).lng(),\n                y: ring.getAt(0).lat()\n            });\n\n            rings.push(verts);\n        }\n        response = {\n            type: 'polygon',\n            components: rings\n        };\n\n        return response;\n    }\n\n    // google.maps.Data.MultiPoint /////////////////////////////////////////////////////\n    if (obj.constructor === google.maps.Data.MultiPoint) {\n        verts = [];\n        for (i = 0; i < obj.getLength(); i += 1) {\n            vertex = obj.getAt(i);\n            verts.push([{\n                x: vertex.lng(),\n                y: vertex.lat()\n            }]);\n        }\n        response = {\n            type: 'multipoint',\n            components: verts\n        };\n        return response;\n    }\n\n    // google.maps.Data.MultiLineString /////////////////////////////////////////////////////\n    if (obj.constructor === google.maps.Data.MultiLineString) {\n        linestrings = [];\n        for (i = 0; i < obj.getLength(); i += 1) {\n            verts = [];\n            linestring = obj.getAt(i);\n            for (j = 0; j < linestring.getLength(); j += 1) {\n                vertex = linestring.getAt(j);\n                verts.push({\n                    x: vertex.lng(),\n                    y: vertex.lat()\n                });\n            }\n            linestrings.push(verts);\n        }\n        response = {\n            type: 'multilinestring',\n            components: linestrings\n        };\n        return response;\n    }\n\n    // google.maps.Data.MultiPolygon /////////////////////////////////////////////////////\n    if (obj.constructor === google.maps.Data.MultiPolygon) {\n\n        polygons = [];\n\n        //console.zlog('It is a google.maps.Data.MultiPolygon');\n        for (k = 0; k < obj.getLength(); k += 1) {\n            // For each multipolygon\n            polygon = obj.getAt(k);\n            rings = [];\n            for (i = 0; i < polygon.getLength(); i += 1) {\n                // For each ring...\n                ring = polygon.getAt(i);\n                verts = [];\n                for (j = 0; j < ring.getLength(); j += 1) {\n                    // For each vertex...\n                    vertex = ring.getAt(j);\n                    verts.push({\n                        x: vertex.lng(),\n                        y: vertex.lat()\n                    });\n                }\n                verts.push({\n                    x: ring.getAt(0).lng(),\n                    y: ring.getAt(0).lat()\n                });\n\n                rings.push(verts);\n            }\n            polygons.push(rings);\n        }\n\n        response = {\n            type: 'multipolygon',\n            components: polygons\n        };\n        return response;\n    }\n\n    // google.maps.Data.GeometryCollection /////////////////////////////////////////////////////\n    if (obj.constructor === google.maps.Data.GeometryCollection) {\n\n        var objects = [];\n        for (k = 0; k < obj.getLength(); k += 1) {\n            // For each multipolygon\n            var object = obj.getAt(k);\n            objects.push(this.deconstruct.call(this, object));\n        }\n        //console.zlog('It is a google.maps.Data.GeometryCollection', objects);\n        response = {\n            type: 'geometrycollection',\n            components: objects\n        };\n        return response;\n    }\n\n    // Array ///////////////////////////////////////////////////////////////////\n    if (Wkt.isArray(obj)) {\n        features = [];\n\n        for (i = 0; i < obj.length; i += 1) {\n            features.push(this.deconstruct.call(this, obj[i], true));\n        }\n\n        response = {\n\n            type: function () {\n                var k,\n                    type = obj[0].constructor;\n\n                for (k = 0; k < obj.length; k += 1) {\n                    // Check that all items have the same constructor as the first item\n                    if (obj[k].constructor !== type) {\n                        // If they don't, type is heterogeneous geometry collection\n                        return 'geometrycollection';\n                    }\n                }\n\n                switch (type) {\n                    case google.maps.Marker:\n                        return 'multipoint';\n                    case google.maps.Polyline:\n                        return 'multilinestring';\n                    case google.maps.Polygon:\n                        return 'multipolygon';\n                    default:\n                        return 'geometrycollection';\n                }\n            }(),\n            components: function () {\n                // Pluck the components from each Wkt\n                var i, comps;\n\n                comps = [];\n                for (i = 0; i < features.length; i += 1) {\n                    if (features[i].components) {\n                        comps.push(features[i].components);\n                    }\n                }\n\n                return {\n                    comps: comps\n                };\n            }()\n\n        };\n        response.components = response.components.comps;\n        return response;\n    }\n\n    console.warn('The passed object does not have any recognizable properties.');\n};\n\nfunction Wicket$1() {\n    return new Wkt.Wkt();\n}\n\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || value !== value && other !== other;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache();\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Built-in value references. */\nvar _Symbol = root.Symbol;\n\n/** Used for built-in method references. */\nvar objectProto$1 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$1 = objectProto$1.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto$1.toString;\n\n/** Built-in value references. */\nvar symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty$1.call(value, symToStringTag$1),\n      tag = value[symToStringTag$1];\n\n  try {\n    value[symToStringTag$1] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag$1] = tag;\n    } else {\n      delete value[symToStringTag$1];\n    }\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar objectProto$2 = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString$1 = objectProto$2.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString$1.call(value);\n}\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]';\nvar undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]';\nvar funcTag = '[object Function]';\nvar genTag = '[object GeneratorFunction]';\nvar proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = function () {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? 'Symbol(src)_1.' + uid : '';\n}();\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && maskSrcKey in func;\n}\n\n/** Used for built-in method references. */\nvar funcProto$1 = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString$1 = funcProto$1.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString$1.call(func);\n    } catch (e) {}\n    try {\n      return func + '';\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype;\nvar objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&').replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$');\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/* Built-in method references that are verified to be native. */\nvar Map$1 = getNative(root, 'Map');\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto$3 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$2 = objectProto$3.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty$2.call(data, key) ? data[key] : undefined;\n}\n\n/** Used for built-in method references. */\nvar objectProto$4 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$3 = objectProto$4.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty$3.call(data, key);\n}\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED$1 = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED$1 : value;\n  return this;\n}\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash(),\n    'map': new (Map$1 || ListCache)(),\n    'string': new Hash()\n  };\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);\n  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED$2 = '__lodash_hash_undefined__';\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED$2);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache();\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG$2 = 1;\nvar COMPARE_UNORDERED_FLAG$1 = 2;\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = bitmask & COMPARE_UNORDERED_FLAG$1 ? new SetCache() : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function (othValue, othIndex) {\n        if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n          return seen.push(othIndex);\n        }\n      })) {\n        result = false;\n        break;\n      }\n    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/** Built-in value references. */\nvar Uint8Array$1 = root.Uint8Array;\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function (value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function (value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG$3 = 1;\nvar COMPARE_UNORDERED_FLAG$2 = 2;\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]';\nvar dateTag = '[object Date]';\nvar errorTag = '[object Error]';\nvar mapTag = '[object Map]';\nvar numberTag = '[object Number]';\nvar regexpTag = '[object RegExp]';\nvar setTag = '[object Set]';\nvar stringTag = '[object String]';\nvar symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]';\nvar dataViewTag = '[object DataView]';\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = _Symbol ? _Symbol.prototype : undefined;\nvar symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == other + '';\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG$2;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/** Used for built-in method references. */\nvar objectProto$7 = Object.prototype;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto$7.propertyIsEnumerable;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function (object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function (symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object';\n}\n\n/** `Object#toString` result references. */\nvar argsTag$1 = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag$1;\n}\n\n/** Used for built-in method references. */\nvar objectProto$9 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$7 = objectProto$9.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function () {\n  return arguments;\n}()) ? baseIsArguments : function (value) {\n  return isObjectLike(value) && hasOwnProperty$7.call(value, 'callee') && !propertyIsEnumerable$1.call(value, 'callee');\n};\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\n/** Detect free variable `exports`. */\nvar freeExports = (typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && (typeof module === 'undefined' ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;\n}\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER$1 = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;\n}\n\n/** `Object#toString` result references. */\nvar argsTag$2 = '[object Arguments]';\nvar arrayTag$1 = '[object Array]';\nvar boolTag$1 = '[object Boolean]';\nvar dateTag$1 = '[object Date]';\nvar errorTag$1 = '[object Error]';\nvar funcTag$1 = '[object Function]';\nvar mapTag$1 = '[object Map]';\nvar numberTag$1 = '[object Number]';\nvar objectTag$1 = '[object Object]';\nvar regexpTag$1 = '[object RegExp]';\nvar setTag$1 = '[object Set]';\nvar stringTag$1 = '[object String]';\nvar weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag$1 = '[object ArrayBuffer]';\nvar dataViewTag$1 = '[object DataView]';\nvar float32Tag = '[object Float32Array]';\nvar float64Tag = '[object Float64Array]';\nvar int8Tag = '[object Int8Array]';\nvar int16Tag = '[object Int16Array]';\nvar int32Tag = '[object Int32Array]';\nvar uint8Tag = '[object Uint8Array]';\nvar uint8ClampedTag = '[object Uint8ClampedArray]';\nvar uint16Tag = '[object Uint16Array]';\nvar uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag$2] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$1] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$1] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$1] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$1] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function (value) {\n    return func(value);\n  };\n}\n\n/** Detect free variable `exports`. */\nvar freeExports$1 = (typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule$1 = freeExports$1 && (typeof module === 'undefined' ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports$1 && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = function () {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}();\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/** Used for built-in method references. */\nvar objectProto$8 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$6 = objectProto$8.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty$6.call(value, key)) && !(skipIndexes && (\n    // Safari 9 has enumerable `arguments.length` in strict mode.\n    key == 'length' ||\n    // Node.js 0.10 has enumerable non-index properties on buffers.\n    isBuff && (key == 'offset' || key == 'parent') ||\n    // PhantomJS 2 has enumerable non-index properties on typed arrays.\n    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') ||\n    // Skip index properties.\n    isIndex(key, length)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar objectProto$11 = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$11;\n\n  return value === proto;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function (arg) {\n    return func(transform(arg));\n  };\n}\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\n/** Used for built-in method references. */\nvar objectProto$10 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$8 = objectProto$10.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty$8.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG$4 = 1;\n\n/** Used for built-in method references. */\nvar objectProto$6 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$5 = objectProto$6.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty$5.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView');\n\n/* Built-in method references that are verified to be native. */\nvar Promise$1 = getNative(root, 'Promise');\n\n/* Built-in method references that are verified to be native. */\nvar Set = getNative(root, 'Set');\n\n/* Built-in method references that are verified to be native. */\nvar WeakMap = getNative(root, 'WeakMap');\n\n/** `Object#toString` result references. */\nvar mapTag$2 = '[object Map]';\nvar objectTag$2 = '[object Object]';\nvar promiseTag = '[object Promise]';\nvar setTag$2 = '[object Set]';\nvar weakMapTag$1 = '[object WeakMap]';\n\nvar dataViewTag$2 = '[object DataView]';\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView);\nvar mapCtorString = toSource(Map$1);\nvar promiseCtorString = toSource(Promise$1);\nvar setCtorString = toSource(Set);\nvar weakMapCtorString = toSource(WeakMap);\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$2 || Map$1 && getTag(new Map$1()) != mapTag$2 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set && getTag(new Set()) != setTag$2 || WeakMap && getTag(new WeakMap()) != weakMapTag$1) {\n    getTag = function getTag(value) {\n        var result = baseGetTag(value),\n            Ctor = result == objectTag$2 ? value.constructor : undefined,\n            ctorString = Ctor ? toSource(Ctor) : '';\n\n        if (ctorString) {\n            switch (ctorString) {\n                case dataViewCtorString:\n                    return dataViewTag$2;\n                case mapCtorString:\n                    return mapTag$2;\n                case promiseCtorString:\n                    return promiseTag;\n                case setCtorString:\n                    return setTag$2;\n                case weakMapCtorString:\n                    return weakMapTag$1;\n            }\n        }\n        return result;\n    };\n}\n\nvar getTag$1 = getTag;\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG$1 = 1;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\nvar arrayTag = '[object Array]';\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar objectProto$5 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$4 = objectProto$5.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag$1(object),\n      othTag = othIsArr ? arrayTag : getTag$1(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack());\n    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG$1)) {\n    var objIsWrapped = objIsObj && hasOwnProperty$4.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty$4.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack());\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack());\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\nvar COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack();\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\n/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function (object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue && (srcValue !== undefined || key in Object(object));\n  };\n}\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function (object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\n/** `Object#toString` result references. */\nvar symbolTag$1 = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag$1;\n}\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\nvar reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);\n  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);\n}\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function memoized() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache)();\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function (key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\n/** Used to match property names within property paths. */\nvar reLeadingDot = /^\\./;\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function (string) {\n  var result = [];\n  if (reLeadingDot.test(string)) {\n    result.push('');\n  }\n  string.replace(rePropName, function (match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);\n  });\n  return result;\n});\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto$1 = _Symbol ? _Symbol.prototype : undefined;\nvar symbolToString = symbolProto$1 ? symbolProto$1.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = value + '';\n  return result == '0' && 1 / value == -INFINITY ? '-0' : result;\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\n/** Used as references for various `Number` constants. */\nvar INFINITY$1 = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = value + '';\n  return result == '0' && 1 / value == -INFINITY$1 ? '-0' : result;\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return index && index == length ? object : undefined;\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get$1(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\n/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      result = false;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));\n}\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG$5 = 1;\nvar COMPARE_UNORDERED_FLAG$3 = 2;\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function (object) {\n    var objValue = get$1(object, path);\n    return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$5 | COMPARE_UNORDERED_FLAG$3);\n  };\n}\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function (object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function (object) {\n    return baseGet(object, path);\n  };\n}\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object') {\n    return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);\n  }\n  return property(value);\n}\n\n/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function (object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function (collection, iteratee) {\n    if (collection == null) {\n      return collection;\n    }\n    if (!isArrayLike(collection)) {\n      return eachFunc(collection, iteratee);\n    }\n    var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection);\n\n    while (fromRight ? index-- : ++index < length) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\n/**\n * The base implementation of `_.map` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction baseMap(collection, iteratee) {\n  var index = -1,\n      result = isArrayLike(collection) ? Array(collection.length) : [];\n\n  baseEach(collection, function (value, key, collection) {\n    result[++index] = iteratee(value, key, collection);\n  });\n  return result;\n}\n\n/**\n * Creates an array of values by running each element in `collection` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n *\n * The guarded methods are:\n * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n * @example\n *\n * function square(n) {\n *   return n * n;\n * }\n *\n * _.map([4, 8], square);\n * // => [16, 64]\n *\n * _.map({ 'a': 4, 'b': 8 }, square);\n * // => [16, 64] (iteration order is not guaranteed)\n *\n * var users = [\n *   { 'user': 'barney' },\n *   { 'user': 'fred' }\n * ];\n *\n * // The `_.property` iteratee shorthand.\n * _.map(users, 'user');\n * // => ['barney', 'fred']\n */\nfunction map(collection, iteratee) {\n  var func = isArray(collection) ? arrayMap : baseMap;\n  return func(collection, baseIteratee(iteratee, 3));\n}\n\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\n/**\n * Casts `value` to `identity` if it's not a function.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Function} Returns cast function.\n */\nfunction castFunction(value) {\n  return typeof value == 'function' ? value : identity;\n}\n\n/**\n * Iterates over elements of `collection` and invokes `iteratee` for each element.\n * The iteratee is invoked with three arguments: (value, index|key, collection).\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n * property are iterated like arrays. To avoid this behavior use `_.forIn`\n * or `_.forOwn` for object iteration.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @alias each\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n * @see _.forEachRight\n * @example\n *\n * _.forEach([1, 2], function(value) {\n *   console.log(value);\n * });\n * // => Logs `1` then `2`.\n *\n * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n *   console.log(key);\n * });\n * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n */\nfunction forEach(collection, iteratee) {\n  var func = isArray(collection) ? arrayEach : baseEach;\n  return func(collection, castFunction(iteratee));\n}\n\n/**\n * Converts a coordinate pair into a {@link google.maps.LatLngLiteral}\n * @param  {Position|google.maps.LatLngLiteral|google.maps.LatLng} position a coordinate pair \n * @return {google.maps.LatLngLiteral}     a {@link google.maps.LatLngLiteral}\n * @private\n */\nfunction toLatLng(position) {\n\tif (position instanceof google.maps.LatLng) {\n\t\treturn {\n\t\t\tlat: position.lat(),\n\t\t\tlng: position.lng()\n\t\t};\n\t} else if (position.lat && position.lng) {\n\t\treturn position;\n\t} else {\n\t\treturn {\n\t\t\tlat: position[1],\n\t\t\tlng: position[0]\n\t\t};\n\t}\n}\n\n/**\n * Transforma un array de LatLng en un array de coordenadas [lng,lat]\n * @param {Array.<Position>} arrayLatLng [description]\n * @return {Array.<google.maps.LatLngLiteral>} array of {@link google.maps.LatLngLiteral}\n */\nfunction toLatLngs(coordinates) {\n\treturn map(coordinates, toLatLng);\n}\n\n/**\n * Transforms a {@link google.maps.LatLng} or {@link google.maps.LatLngLiteral}\n * @param  {google.maps.LatLng|google.maps.LatLngLiteral|Position} LatLng a coordinate to transform\n * @return {Position}   a coordinate pair\n * @private\n */\nfunction toCoord$1(LatLng) {\n\tif (google.maps && google.maps.LatLng && LatLng instanceof google.maps.LatLng) {\n\t\treturn [LatLng.lng(), LatLng.lat()];\n\t} else if (LatLng.lat && LatLng.lng) {\n\t\treturn [LatLng.lng, LatLng.lat];\n\t} else if (LatLng.length && LatLng.length >= 2) {\n\t\treturn LatLng;\n\t} else {\n\t\tthrow new Error('google.maps is not present in the global scope');\n\t}\n}\n\n/**\n * Transforms an array of coordinates to an array of [Lng, Lat]\n * @param {Array.<google.maps.LatLng>|Array.<google.maps.LatLngLiteral>} arrayLatLng Array of {@link google.maps.LatLng} or {@link google.maps.LatLngLiteral}\n * @param {bool} [closeRing=false] optionally, ensure the passed coordinate array forms a closed ring\n * @return {Array.<Position>} an array of {@link Position}\n */\nfunction toCoords(arrayLatLng, closeRing) {\n\n\tvar ring = map(arrayLatLng, toCoord$1);\n\n\tif (closeRing === true) {\n\t\tvar last_coord = ring.pop();\n\t\tif (last_coord[0] === ring[0][0] && last_coord[1] === ring[0][1]) {\n\t\t\tring.push(ring[0]);\n\t\t} else {\n\t\t\tring.push(last_coord);\n\t\t\tring.push(ring[0]);\n\t\t}\n\t}\n\treturn ring;\n}\n\n/** Used to compose unicode character classes. */\n\n/** Used to compose unicode character classes. */\nvar rsAstralRange$1 = '\\\\ud800-\\\\udfff';\nvar rsComboMarksRange$1 = '\\\\u0300-\\\\u036f';\nvar reComboHalfMarksRange$1 = '\\\\ufe20-\\\\ufe2f';\nvar rsComboSymbolsRange$1 = '\\\\u20d0-\\\\u20ff';\nvar rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;\nvar rsVarRange$1 = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsAstral = '[' + rsAstralRange$1 + ']';\nvar rsCombo = '[' + rsComboRange$1 + ']';\nvar rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]';\nvar rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')';\nvar rsNonAstral = '[^' + rsAstralRange$1 + ']';\nvar rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}';\nvar rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]';\nvar rsZWJ$1 = '\\\\u200d';\n\n/** Used to compose unicode regexes. */\nvar reOptMod = rsModifier + '?';\nvar rsOptVar = '[' + rsVarRange$1 + ']?';\nvar rsOptJoin = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*';\nvar rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\n\n/**\n * The base implementation of `_.reduce` and `_.reduceRight`, without support\n * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} accumulator The initial value.\n * @param {boolean} initAccum Specify using the first or last element of\n *  `collection` as the initial value.\n * @param {Function} eachFunc The function to iterate over `collection`.\n * @returns {*} Returns the accumulated value.\n */\n\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nvar earthRadius = 6371008.8;\n\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n */\nvar factors = {\n    meters: earthRadius,\n    metres: earthRadius,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    miles: earthRadius / 1609.344,\n    nauticalmiles: earthRadius / 1852,\n    inches: earthRadius * 39.370,\n    yards: earthRadius / 1.0936,\n    feet: earthRadius * 3.28084,\n    radians: 1,\n    degrees: earthRadius / 111325\n};\n\n/**\n * Units of measurement factors based on 1 meter.\n */\n\n\n/**\n * Area of measurement factors based on 1 square meter.\n */\n\n\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geometry, properties, bbox, id) {\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox) {\n        if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n        if (bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');\n    }\n    if (id && ['string', 'number'].indexOf(typeof id === 'undefined' ? 'undefined' : _typeof(id)) === -1) throw new Error('id must be a number or a string');\n\n    var feat = { type: 'Feature' };\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\n\n\n/**\n * Takes coordinates and properties (optional) and returns a new {@link Point} feature.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n    if (!Array.isArray(coordinates)) throw new Error('Coordinates must be an Array');\n    if (coordinates.length < 2) throw new Error('Coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('Coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Takes an array of LinearRings and optionally an {@link Object} with properties and returns a {@link Polygon} feature.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<Polygon>} a Polygon feature\n * @throws {Error} throw an error if a LinearRing of the polygon has too few positions\n * or if a LinearRing of the Polygon does not have matching Positions at the beginning & end.\n * @example\n * var polygon = turf.polygon([[\n *   [-2.275543, 53.464547],\n *   [-2.275543, 53.489271],\n *   [-2.215118, 53.489271],\n *   [-2.215118, 53.464547],\n *   [-2.275543, 53.464547]\n * ]], { name: 'poly1', population: 400});\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('Coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Creates a {@link LineString} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<LineString>} a LineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var linestring1 = turf.lineString([\n *   [-21.964416, 64.148203],\n *   [-21.956176, 64.141316],\n *   [-21.93901, 64.135924],\n *   [-21.927337, 64.136673]\n * ]);\n * var linestring2 = turf.lineString([\n *   [-21.929054, 64.127985],\n *   [-21.912918, 64.134726],\n *   [-21.916007, 64.141016],\n *   [-21.930084, 64.14446]\n * ], {name: 'line 1', distance: 145});\n *\n * //=linestring1\n *\n * //=linestring2\n */\nfunction lineString(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n    if (coordinates.length < 2) throw new Error('Coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('Coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {FeatureCollection} a FeatureCollection of input features\n * @example\n * var features = [\n *  turf.point([-75.343, 39.984], {name: 'Location A'}),\n *  turf.point([-75.833, 39.284], {name: 'Location B'}),\n *  turf.point([-75.534, 39.123], {name: 'Location C'})\n * ];\n *\n * var collection = turf.featureCollection(features);\n *\n * //=collection\n */\nfunction featureCollection(features, bbox, id) {\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');\n    if (id && ['string', 'number'].indexOf(typeof id === 'undefined' ? 'undefined' : _typeof(id)) === -1) throw new Error('id must be a number or a string');\n\n    var fc = { type: 'FeatureCollection' };\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\n\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\n\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nfunction geometryCollection(geometries, properties, bbox, id) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, bbox, id);\n}\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\n\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\n\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\n\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToradians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {string} originalUnit of the length\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted length\n */\n\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeter, acre, mile, yard, foot, inch\n * @param {number} area to be converted\n * @param {string} [originalUnit='meters'] of the distance\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted distance\n */\n\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject$2(input) {\n    return !!input && input.constructor === Object;\n}\n\n// Deprecated methods\n\nvar debug = console.debug.bind(console, '%c turfHelper' + ':', \"color:#00CC00;font-weight:bold;\");\nvar warn = console.debug.bind(console, '%c turfHelper' + ':', \"color:orange;font-weight:bold;\");\n\n/**\n * Transforma un array de gmaps.LatLng en un Feature.Polygon\n * @param  {Array.<google.maps.LatLng>} LatLngArray [description]\n * @return {Feature.<Polygon>}             [description]\n */\nfunction arrayToFeaturePolygon(LatLngArray) {\n\n    var vertices = toCoords(LatLngArray, true);\n\n    return {\n        type: \"Feature\",\n        properties: {},\n        geometry: {\n            type: \"Polygon\",\n\n            coordinates: [vertices]\n        }\n    };\n}\n\n/**\n * Transforms a {@link google.maps.Marker} to a {@link Feature<Point>}\n * @param  {google.maps.Marker} marker  - marker object to transform\n * @return {Feature<Point>}    output Feature\n */\nfunction markerToFeaturePoint(marker) {\n    if (!marker.getPosition || typeof marker.getPosition !== 'function') {\n        throw new Error('input object does not have a getPosition method');\n    }\n    var position = marker.getPosition(),\n        Feature = {\n        type: \"Feature\",\n        properties: {},\n        geometry: {\n            type: \"Point\",\n            coordinates: [position.lng(), position.lat()]\n        }\n    };\n\n    return Feature;\n}\n\n/**\n * [polylineToFeatureLinestring description]\n * @param  {Array.<google.maps.LatLng>|google.maps.Polyline} objeto array of positions or a google.maps.Polyline\n * @return {Feature.<LineString>}          [description]\n */\nfunction polylineToFeatureLinestring(objeto) {\n    var vertices;\n    if (objeto instanceof google.maps.Polyline) {\n        vertices = toCoords(objeto.getPath().getArray());\n    } else {\n        vertices = toCoords(objeto);\n    }\n\n    return lineString(vertices);\n}\n\n/**\n * Receives an object and returns a GeoJson Feature of type Polygon\n * @param  {google.maps.Polygon|Array.<google.maps.LatLng>|Feature.Polygon|Geometry} object object to transform into a Feature.Polygon\n * @return {Feature.Polygon}        [description]\n */\nfunction polygonToFeaturePolygon(object) {\n    var ring, polygonFeature;\n\n    if (object.type === 'Feature') {\n        polygonFeature = object;\n    } else if (object instanceof google.maps.Polygon) {\n\n        object = object.getPath().getArray();\n        ring = toCoords(object, true);\n        polygonFeature = arrayToFeaturePolygon(ring);\n    } else if (!!(object && object.constructor === Array)) {\n\n        ring = toCoords(object, true);\n        polygonFeature = arrayToFeaturePolygon(ring);\n    } else if (object.geometry) {\n\n        polygonFeature = {\n            type: \"Feature\",\n            properties: {},\n            geometry: object.geometry\n        };\n    } else {\n        throw new Error('object is not a Feature, google.maps.Polygon nor an array of google.maps.LatLng');\n    }\n\n    polygonFeature.properties = {};\n\n    return polygonFeature;\n}\n\n/**\n * Transforma un array de gmaps.LatLng en un featurecollection geoJson\n * donde cada Feature es un punto del array de entrada\n * @param  {Array<google.maps.LatLng>|google.maps.MVCArray} latLngArray array de posiciones {@link google.maps.LatLng}\n * @return {FeatureCollection}             geojson FeatureCollection\n */\nfunction arrayToFeaturePoints(latLngArray) {\n\n    var FeatureCollection = {\n        \"type\": \"FeatureCollection\",\n        \"features\": []\n    };\n    latLngArray.forEach(function (latLng) {\n        var Feature = {\n            type: \"Feature\",\n            geometry: {\n                type: \"Point\",\n                coordinates: toCoords([latLng])[0]\n            }\n        };\n        FeatureCollection.features.push(Feature);\n    });\n\n    return FeatureCollection;\n}\n\n//http://en.wikipedia.org/wiki/Delaunay_triangulation\n//https://github.com/ironwallaby/delaunay\n/**\n * Takes a set of {@link Point|points} and creates a\n * [Triangulated Irregular Network](http://en.wikipedia.org/wiki/Triangulated_irregular_network),\n * or a TIN for short, returned as a collection of Polygons. These are often used\n * for developing elevation contour maps or stepped heat visualizations.\n *\n * If an optional z-value property is provided then it is added as properties called `a`, `b`,\n * and `c` representing its value at each of the points that represent the corners of the\n * triangle.\n *\n * @name tin\n * @param {FeatureCollection<Point>} points input points\n * @param {String} [z] name of the property from which to pull z values\n * This is optional: if not given, then there will be no extra data added to the derived triangles.\n * @returns {FeatureCollection<Polygon>} TIN output\n * @example\n * // generate some random point data\n * var points = turf.randomPoint(30, {bbox: [50, 30, 70, 50]});\n *\n * // add a random property to each point between 0 and 9\n * for (var i = 0; i < points.features.length; i++) {\n *   points.features[i].properties.z = ~~(Math.random() * 9);\n * }\n * var tin = turf.tin(points, 'z');\n *\n * //addToMap\n * var addToMap = [tin, points]\n * for (var i = 0; i < tin.features.length; i++) {\n *   var properties  = tin.features[i].properties;\n *   properties.fill = '#' + properties.a + properties.b + properties.c;\n * }\n */\nfunction tin(points, z) {\n    if (points.type !== 'FeatureCollection') throw new Error('points must be a FeatureCollection');\n    //break down points\n    var isPointZ = false;\n    return featureCollection(triangulate(points.features.map(function (p) {\n        var point$$1 = {\n            x: p.geometry.coordinates[0],\n            y: p.geometry.coordinates[1]\n        };\n        if (z) {\n            point$$1.z = p.properties[z];\n        } else if (p.geometry.coordinates.length === 3) {\n            isPointZ = true;\n            point$$1.z = p.geometry.coordinates[2];\n        }\n        return point$$1;\n    })).map(function (triangle) {\n\n        var a = [triangle.a.x, triangle.a.y];\n        var b = [triangle.b.x, triangle.b.y];\n        var c = [triangle.c.x, triangle.c.y];\n        var properties = {};\n\n        // Add z coordinates to triangle points if user passed\n        // them in that way otherwise add it as a property.\n        if (isPointZ) {\n            a.push(triangle.a.z);\n            b.push(triangle.b.z);\n            c.push(triangle.c.z);\n        } else {\n            properties = {\n                a: triangle.a.z,\n                b: triangle.b.z,\n                c: triangle.c.z\n            };\n        }\n\n        return polygon([[a, b, c, a]], properties);\n    }));\n}\n\nfunction Triangle(a, b, c) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n\n    var A = b.x - a.x,\n        B = b.y - a.y,\n        C = c.x - a.x,\n        D = c.y - a.y,\n        E = A * (a.x + b.x) + B * (a.y + b.y),\n        F = C * (a.x + c.x) + D * (a.y + c.y),\n        G = 2 * (A * (c.y - b.y) - B * (c.x - b.x)),\n        dx,\n        dy;\n\n    // If the points of the triangle are collinear, then just find the\n    // extremes and use the midpoint as the center of the circumcircle.\n    this.x = (D * E - B * F) / G;\n    this.y = (A * F - C * E) / G;\n    dx = this.x - a.x;\n    dy = this.y - a.y;\n    this.r = dx * dx + dy * dy;\n}\n\nfunction byX(a, b) {\n    return b.x - a.x;\n}\n\nfunction dedup(edges) {\n    var j = edges.length,\n        a,\n        b,\n        i,\n        m,\n        n;\n\n    outer: while (j) {\n        b = edges[--j];\n        a = edges[--j];\n        i = j;\n        while (i) {\n            n = edges[--i];\n            m = edges[--i];\n            if (a === m && b === n || a === n && b === m) {\n                edges.splice(j, 2);\n                edges.splice(i, 2);\n                j -= 2;\n                continue outer;\n            }\n        }\n    }\n}\n\nfunction triangulate(vertices) {\n    // Bail if there aren't enough vertices to form any triangles.\n    if (vertices.length < 3) return [];\n\n    // Ensure the vertex array is in order of descending X coordinate\n    // (which is needed to ensure a subquadratic runtime), and then find\n    // the bounding box around the points.\n    vertices.sort(byX);\n\n    var i = vertices.length - 1,\n        xmin = vertices[i].x,\n        xmax = vertices[0].x,\n        ymin = vertices[i].y,\n        ymax = ymin,\n        epsilon = 1e-12;\n\n    var a, b, c, A, B, G;\n\n    while (i--) {\n        if (vertices[i].y < ymin) ymin = vertices[i].y;\n        if (vertices[i].y > ymax) ymax = vertices[i].y;\n    }\n\n    //Find a supertriangle, which is a triangle that surrounds all the\n    //vertices. This is used like something of a sentinel value to remove\n    //cases in the main algorithm, and is removed before we return any\n    // results.\n\n    // Once found, put it in the \"open\" list. (The \"open\" list is for\n    // triangles who may still need to be considered; the \"closed\" list is\n    // for triangles which do not.)\n    var dx = xmax - xmin,\n        dy = ymax - ymin,\n        dmax = dx > dy ? dx : dy,\n        xmid = (xmax + xmin) * 0.5,\n        ymid = (ymax + ymin) * 0.5,\n        open = [new Triangle({\n        x: xmid - 20 * dmax,\n        y: ymid - dmax,\n        __sentinel: true\n    }, {\n        x: xmid,\n        y: ymid + 20 * dmax,\n        __sentinel: true\n    }, {\n        x: xmid + 20 * dmax,\n        y: ymid - dmax,\n        __sentinel: true\n    })],\n        closed = [],\n        edges = [],\n        j;\n\n    // Incrementally add each vertex to the mesh.\n    i = vertices.length;\n    while (i--) {\n        // For each open triangle, check to see if the current point is\n        // inside it's circumcircle. If it is, remove the triangle and add\n        // it's edges to an edge list.\n        edges.length = 0;\n        j = open.length;\n        while (j--) {\n            // If this point is to the right of this triangle's circumcircle,\n            // then this triangle should never get checked again. Remove it\n            // from the open list, add it to the closed list, and skip.\n            dx = vertices[i].x - open[j].x;\n            if (dx > 0 && dx * dx > open[j].r) {\n                closed.push(open[j]);\n                open.splice(j, 1);\n                continue;\n            }\n\n            // If not, skip this triangle.\n            dy = vertices[i].y - open[j].y;\n            if (dx * dx + dy * dy > open[j].r) continue;\n\n            // Remove the triangle and add it's edges to the edge list.\n            edges.push(open[j].a, open[j].b, open[j].b, open[j].c, open[j].c, open[j].a);\n            open.splice(j, 1);\n        }\n\n        // Remove any doubled edges.\n        dedup(edges);\n\n        // Add a new triangle for each edge.\n        j = edges.length;\n        while (j) {\n            b = edges[--j];\n            a = edges[--j];\n            c = vertices[i];\n            // Avoid adding colinear triangles (which have error-prone\n            // circumcircles)\n            A = b.x - a.x;\n            B = b.y - a.y;\n            G = 2 * (A * (c.y - b.y) - B * (c.x - b.x));\n            if (Math.abs(G) > epsilon) {\n                open.push(new Triangle(a, b, c));\n            }\n        }\n    }\n\n    // Copy any remaining open triangles to the closed list, and then\n    // remove any triangles that share a vertex with the supertriangle.\n    Array.prototype.push.apply(closed, open);\n\n    i = closed.length;\n    while (i--) {\n        if (closed[i].a.__sentinel || closed[i].b.__sentinel || closed[i].c.__sentinel) closed.splice(i, 1);\n    }return closed;\n}\n\n/**\n * Returns a cloned copy of the passed GeoJSON Object, including possible 'Foreign Members'.\n * ~3-5x faster than the common JSON.parse + JSON.stringify combo method.\n *\n * @name clone\n * @param {GeoJSON} geojson GeoJSON Object\n * @returns {GeoJSON} cloned GeoJSON Object\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]], {color: 'red'});\n *\n * var lineCloned = turf.clone(line);\n */\nfunction clone(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n\n    switch (geojson.type) {\n        case 'Feature':\n            return cloneFeature(geojson);\n        case 'FeatureCollection':\n            return cloneFeatureCollection(geojson);\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n        case 'MultiPoint':\n        case 'MultiLineString':\n        case 'MultiPolygon':\n        case 'GeometryCollection':\n            return cloneGeometry(geojson);\n        default:\n            throw new Error('unknown GeoJSON type');\n    }\n}\n\n/**\n * Clone Feature\n *\n * @private\n * @param {Feature<any>} geojson GeoJSON Feature\n * @returns {Feature<any>} cloned Feature\n */\nfunction cloneFeature(geojson) {\n    var cloned = { type: 'Feature' };\n    // Preserve Foreign Members\n    Object.keys(geojson).forEach(function (key) {\n        switch (key) {\n            case 'type':\n            case 'properties':\n            case 'geometry':\n                return;\n            default:\n                cloned[key] = geojson[key];\n        }\n    });\n    // Add properties & geometry last\n    cloned.properties = cloneProperties(geojson.properties);\n    cloned.geometry = cloneGeometry(geojson.geometry);\n    return cloned;\n}\n\n/**\n * Clone Properties\n *\n * @private\n * @param {Object} properties GeoJSON Properties\n * @returns {Object} cloned Properties\n */\nfunction cloneProperties(properties) {\n    var cloned = {};\n    if (!properties) return cloned;\n    Object.keys(properties).forEach(function (key) {\n        var value = properties[key];\n        if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\n            // handle Array\n            if (value.length) cloned[key] = value.map(function (item) {\n                return item;\n            });\n            // handle Object\n            cloned[key] = cloneProperties(value);\n        } else cloned[key] = value;\n    });\n    return cloned;\n}\n\n/**\n * Clone Feature Collection\n *\n * @private\n * @param {FeatureCollection<any>} geojson GeoJSON Feature Collection\n * @returns {FeatureCollection<any>} cloned Feature Collection\n */\nfunction cloneFeatureCollection(geojson) {\n    var cloned = { type: 'FeatureCollection' };\n\n    // Preserve Foreign Members\n    Object.keys(geojson).forEach(function (key) {\n        switch (key) {\n            case 'type':\n            case 'features':\n                return;\n            default:\n                cloned[key] = geojson[key];\n        }\n    });\n    // Add features\n    cloned.features = geojson.features.map(function (feature) {\n        return cloneFeature(feature);\n    });\n    return cloned;\n}\n\n/**\n * Clone Geometry\n *\n * @private\n * @param {Geometry<any>} geometry GeoJSON Geometry\n * @returns {Geometry<any>} cloned Geometry\n */\nfunction cloneGeometry(geometry) {\n    var geom = { type: geometry.type };\n    if (geometry.bbox) geom.bbox = geometry.bbox;\n\n    if (geometry.type === 'GeometryCollection') {\n        geom.geometries = geometry.geometries.map(function (geom) {\n            return cloneGeometry(geom);\n        });\n        return geom;\n    }\n    geom.coordinates = deepSlice(geometry.coordinates);\n    return geom;\n}\n\n/**\n * Deep Slice coordinates\n *\n * @private\n * @param {Coordinates} coords Coordinates\n * @returns {Coordinates} all coordinates sliced\n */\nfunction deepSlice(coords) {\n    if (_typeof(coords[0]) !== 'object') {\n        return coords.slice();\n    }\n    return coords.map(function (coord) {\n        return deepSlice(coord);\n    });\n}\n\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nfunction getCoord(obj) {\n    if (!obj) throw new Error('obj is required');\n\n    var coordinates = getCoords(obj);\n\n    // getCoord() must contain at least two numbers (Point)\n    if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\n        return coordinates;\n    } else {\n        throw new Error('Coordinate is not a valid Point');\n    }\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array of numbers\n *\n * @name getCoords\n * @param {Array<number>|Geometry|Feature} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coord = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nfunction getCoords(obj) {\n    if (!obj) throw new Error('obj is required');\n    var coordinates;\n\n    // Array of numbers\n    if (obj.length) {\n        coordinates = obj;\n\n        // Geometry Object\n    } else if (obj.coordinates) {\n        coordinates = obj.coordinates;\n\n        // Feature\n    } else if (obj.geometry && obj.geometry.coordinates) {\n        coordinates = obj.geometry.coordinates;\n    }\n    // Checks if coordinates contains a number\n    if (coordinates) {\n        containsNumber(coordinates);\n        return coordinates;\n    }\n    throw new Error('No valid coordinates');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nfunction containsNumber(coordinates) {\n    if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\n\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\n\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\n\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\n\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @throws {Error} **DEPRECATED** in v5.0.0 in favor of getType\n */\n\n\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name] name of the variable to display in error message\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nfunction getType(geojson, name) {\n    if (!geojson) throw new Error((name || 'geojson') + ' is required');\n    // GeoJSON Feature & GeometryCollection\n    if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n    // GeoJSON Geometry & FeatureCollection\n    if (geojson.type) return geojson.type;\n    throw new Error((name || 'geojson') + ' is invalid');\n}\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0.\n * @param {number} featureIndex The current index of the feature being processed.\n * @param {number} featureSubIndex The current subIndex of the feature being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, featureSubIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, featureSubIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=featureSubIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var featureIndex,\n        geometryIndex,\n        j,\n        k,\n        l,\n        geometry$$1,\n        stopG,\n        coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;\n        isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (geometryIndex = 0; geometryIndex < stopG; geometryIndex++) {\n            var featureSubIndex = 0;\n            geometry$$1 = isGeometryCollection ? geometryMaybeCollection.geometries[geometryIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry$$1 === null) continue;\n            coords = geometry$$1.coordinates;\n            var geomType = geometry$$1.type;\n\n            wrapShrink = excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon') ? 1 : 0;\n\n            switch (geomType) {\n                case null:\n                    break;\n                case 'Point':\n                    callback(coords, coordIndex, featureIndex, featureSubIndex);\n                    coordIndex++;\n                    featureSubIndex++;\n                    break;\n                case 'LineString':\n                case 'MultiPoint':\n                    for (j = 0; j < coords.length; j++) {\n                        callback(coords[j], coordIndex, featureIndex, featureSubIndex);\n                        coordIndex++;\n                        if (geomType === 'MultiPoint') featureSubIndex++;\n                    }\n                    if (geomType === 'LineString') featureSubIndex++;\n                    break;\n                case 'Polygon':\n                case 'MultiLineString':\n                    for (j = 0; j < coords.length; j++) {\n                        for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                            callback(coords[j][k], coordIndex, featureIndex, featureSubIndex);\n                            coordIndex++;\n                        }\n                        if (geomType === 'MultiLineString') featureSubIndex++;\n                    }\n                    if (geomType === 'Polygon') featureSubIndex++;\n                    break;\n                case 'MultiPolygon':\n                    for (j = 0; j < coords.length; j++) {\n                        for (k = 0; k < coords[j].length; k++) {\n                            for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                                callback(coords[j][k][l], coordIndex, featureIndex, featureSubIndex);\n                                coordIndex++;\n                            }\n                        }featureSubIndex++;\n                    }\n                    break;\n                case 'GeometryCollection':\n                    for (j = 0; j < geometry$$1.geometries.length; j++) {\n                        coordEach(geometry$$1.geometries[j], callback, excludeWrapCoord);\n                    }break;\n                default:\n                    throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the feature being processed.\n * @param {number} featureSubIndex The current subIndex of the feature being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, featureSubIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=featureSubIndex\n *   return currentCoord;\n * });\n */\n\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current properties being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {(FeatureCollection|Feature)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current properties being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {(FeatureCollection|Feature)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\n\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current feature being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            callback(geojson.features[i], i);\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\n\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\n\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current geometry being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {Object} featureProperties The current feature properties being processed.\n * @param {Array<number>} featureBBox The current feature BBox being processed.\n * @param {number|string} featureId The current feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, currentProperties)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, currentProperties) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=currentProperties\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i,\n        j,\n        g,\n        geometry$$1,\n        stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;\n        featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};\n        featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : undefined;\n        featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : undefined;\n        isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry$$1 = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry$$1 === null) {\n                callback(null, featureIndex, featureProperties, featureBBox, featureId);\n                continue;\n            }\n            switch (geometry$$1.type) {\n                case 'Point':\n                case 'LineString':\n                case 'MultiPoint':\n                case 'Polygon':\n                case 'MultiLineString':\n                case 'MultiPolygon':\n                    {\n                        callback(geometry$$1, featureIndex, featureProperties, featureBBox, featureId);\n                        break;\n                    }\n                case 'GeometryCollection':\n                    {\n                        for (j = 0; j < geometry$$1.geometries.length; j++) {\n                            callback(geometry$$1.geometries[j], featureIndex, featureProperties, featureBBox, featureId);\n                        }\n                        break;\n                    }\n                default:\n                    throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Feature being processed.\n * @param {number} currentIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {Object} currentProperties The current feature properties being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, currentProperties)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, currentProperties) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=currentProperties\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, currentIndex, currentProperties) {\n        if (currentIndex === 0 && initialValue === undefined) previousValue = currentGeometry;else previousValue = callback(previousValue, currentGeometry, currentIndex, currentProperties);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureSubIndex The subindex of the current element being processed in the\n * array. Starts at index 0 and increases if the flattened feature was a multi-geometry.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, featureSubIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, featureSubIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=featureSubIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry$$1, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = geometry$$1 === null ? null : geometry$$1.type;\n        switch (type) {\n            case null:\n            case 'Point':\n            case 'LineString':\n            case 'Polygon':\n                callback(feature(geometry$$1, properties, bbox, id), featureIndex, 0);\n                return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n            case 'MultiPoint':\n                geomType = 'Point';\n                break;\n            case 'MultiLineString':\n                geomType = 'LineString';\n                break;\n            case 'MultiPolygon':\n                geomType = 'Polygon';\n                break;\n        }\n\n        geometry$$1.coordinates.forEach(function (coordinate, featureSubIndex) {\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            callback(feature(geom, properties), featureIndex, featureSubIndex);\n        });\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureSubIndex The subindex of the current element being processed in the\n * array. Starts at index 0 and increases if the flattened feature was a multi-geometry.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, featureSubIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, featureSubIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=featureSubIndex\n *   return currentFeature\n * });\n */\n\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current segment being processed.\n * @param {number} featureIndex The featureIndex currently being processed, starts at index 0.\n * @param {number} featureSubIndex The featureSubIndex currently being processed, starts at index 0.\n * @param {number} segmentIndex The segmentIndex currently being processed, starts at index 0.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, featureSubIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, featureSubIndex, segmentIndex) {\n *   //= currentSegment\n *   //= featureIndex\n *   //= featureSubIndex\n *   //= segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\n\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} [previousValue] The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} [currentSegment] The current segment being processed.\n * @param {number} featureIndex The featureIndex currently being processed, starts at index 0.\n * @param {number} featureSubIndex The featureSubIndex currently being processed, starts at index 0.\n * @param {number} segmentIndex The segmentIndex currently being processed, starts at index 0.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, featureSubIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= featureSubIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\n\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The feature index of the current element being processed in the array, starts at index 0.\n * @param {number} featureSubIndex The feature sub-index of the current line being processed at index 0\n * @param {number} lineIndex The current line being processed at index 0\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, featureSubIndex, lineIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, featureSubIndex, lineIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=featureSubIndex\n *   //=lineIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature$$1, featureIndex, featureSubIndex) {\n        if (feature$$1.geometry === null) return;\n        var type = feature$$1.geometry.type;\n        var coords = feature$$1.geometry.coordinates;\n        switch (type) {\n            case 'LineString':\n                callback(feature$$1, featureIndex, featureSubIndex, 0);\n                break;\n            case 'Polygon':\n                for (var lineIndex = 0; lineIndex < coords.length; lineIndex++) {\n                    callback(lineString(coords[lineIndex], feature$$1.properties), featureIndex, featureSubIndex, lineIndex);\n                }\n                break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The feature index of the current element being processed in the array, starts at index 0.\n * @param {number} featureSubIndex The feature sub-index of the current line being processed at index 0\n * @param {number} lineIndex The current line being processed at index 0\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var mtp = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(mtp, function (previousValue, currentLine, featureIndex, featureSubIndex, lineIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=featureSubIndex\n *   //=lineIndex\n *   return currentLine\n * }, 2);\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, featureSubIndex, lineIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;else previousValue = callback(previousValue, currentLine, featureIndex, featureSubIndex, lineIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Merges all connected (non-forking, non-junctioning) line strings into single lineStrings.\n * [LineString] -> LineString|MultiLineString\n *\n * @param {FeatureCollection<LineString|MultiLineString>} geojson Lines to dissolve\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.mutate=false] Prevent input mutation\n * @returns {Feature<LineString|MultiLineString>} Dissolved lines\n */\nfunction lineDissolve(geojson, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject$2(options)) throw new Error('options is invalid');\n    var mutate = options.mutate;\n\n    // Validation\n    if (getType(geojson) !== 'FeatureCollection') throw new Error('geojson must be a FeatureCollection');\n    if (!geojson.features.length) throw new Error('geojson is empty');\n\n    // Clone geojson to avoid side effects\n    if (mutate === false || mutate === undefined) geojson = clone(geojson);\n\n    var result = [];\n    var lastLine = lineReduce(geojson, function (previousLine, currentLine) {\n        // Attempt to merge this LineString with the other LineStrings, updating\n        // the reference as it is merged with others and grows.\n        var merged = mergeLineStrings(previousLine, currentLine);\n\n        // Accumulate the merged LineString\n        if (merged) return merged;\n\n        // Put the unmerged LineString back into the list\n        else {\n                result.push(previousLine);\n                return currentLine;\n            }\n    });\n    // Append the last line\n    if (lastLine) result.push(lastLine);\n\n    // Return null if no lines were dissolved\n    if (!result.length) return null;\n    // Return LineString if only 1 line was dissolved\n    else if (result.length === 1) return result[0];\n        // Return MultiLineString if multiple lines were dissolved with gaps\n        else return multiLineString(result.map(function (line) {\n                return line.coordinates;\n            }));\n}\n\n// [Number, Number] -> String\nfunction coordId(coord) {\n    return coord[0].toString() + ',' + coord[1].toString();\n}\n\n/**\n * LineString, LineString -> LineString\n *\n * @private\n * @param {Feature<LineString>} a line1\n * @param {Feature<LineString>} b line2\n * @returns {Feature<LineString>|null} Merged LineString\n */\nfunction mergeLineStrings(a, b) {\n    var coords1 = a.geometry.coordinates;\n    var coords2 = b.geometry.coordinates;\n\n    var s1 = coordId(coords1[0]);\n    var e1 = coordId(coords1[coords1.length - 1]);\n    var s2 = coordId(coords2[0]);\n    var e2 = coordId(coords2[coords2.length - 1]);\n\n    // TODO: handle case where more than one of these is true!\n    var coords;\n    if (s1 === e2) coords = coords2.concat(coords1.slice(1));else if (s2 === e1) coords = coords1.concat(coords2.slice(1));else if (s1 === s2) coords = coords1.slice(1).reverse().concat(coords2);else if (e1 === e2) coords = coords1.concat(coords2.reverse().slice(1));else return null;\n\n    return lineString(coords);\n}\n\nvar identity$2 = function (x) {\n  return x;\n};\n\nvar transform = function (transform) {\n  if (transform == null) return identity$2;\n  var x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n  return function (input, i) {\n    if (!i) x0 = y0 = 0;\n    var j = 2,\n        n = input.length,\n        output = new Array(n);\n    output[0] = (x0 += input[0]) * kx + dx;\n    output[1] = (y0 += input[1]) * ky + dy;\n    while (j < n) {\n      output[j] = input[j], ++j;\n    }return output;\n  };\n};\n\nvar reverse = function (array, n) {\n  var t,\n      j = array.length,\n      i = j - n;\n  while (i < --j) {\n    t = array[i], array[i++] = array[j], array[j] = t;\n  }\n};\n\nfunction object(topology, o) {\n  var transformPoint = transform(topology.transform),\n      arcs = topology.arcs;\n\n  function arc(i, points) {\n    if (points.length) points.pop();\n    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {\n      points.push(transformPoint(a[k], k));\n    }\n    if (i < 0) reverse(points, n);\n  }\n\n  function point(p) {\n    return transformPoint(p);\n  }\n\n  function line(arcs) {\n    var points = [];\n    for (var i = 0, n = arcs.length; i < n; ++i) {\n      arc(arcs[i], points);\n    }if (points.length < 2) points.push(points[0]); // This should never happen per the specification.\n    return points;\n  }\n\n  function ring(arcs) {\n    var points = line(arcs);\n    while (points.length < 4) {\n      points.push(points[0]);\n    } // This may happen if an arc has only two points.\n    return points;\n  }\n\n  function polygon(arcs) {\n    return arcs.map(ring);\n  }\n\n  function geometry(o) {\n    var type = o.type,\n        coordinates;\n    switch (type) {\n      case \"GeometryCollection\":\n        return { type: type, geometries: o.geometries.map(geometry) };\n      case \"Point\":\n        coordinates = point(o.coordinates);break;\n      case \"MultiPoint\":\n        coordinates = o.coordinates.map(point);break;\n      case \"LineString\":\n        coordinates = line(o.arcs);break;\n      case \"MultiLineString\":\n        coordinates = o.arcs.map(line);break;\n      case \"Polygon\":\n        coordinates = polygon(o.arcs);break;\n      case \"MultiPolygon\":\n        coordinates = o.arcs.map(polygon);break;\n      default:\n        return null;\n    }\n    return { type: type, coordinates: coordinates };\n  }\n\n  return geometry(o);\n}\n\nvar stitch = function (topology, arcs) {\n  var stitchedArcs = {},\n      fragmentByStart = {},\n      fragmentByEnd = {},\n      fragments = [],\n      emptyIndex = -1;\n\n  // Stitch empty arcs first, since they may be subsumed by other arcs.\n  arcs.forEach(function (i, j) {\n    var arc = topology.arcs[i < 0 ? ~i : i],\n        t;\n    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {\n      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;\n    }\n  });\n\n  arcs.forEach(function (i) {\n    var e = ends(i),\n        start = e[0],\n        end = e[1],\n        f,\n        g;\n\n    if (f = fragmentByEnd[start]) {\n      delete fragmentByEnd[f.end];\n      f.push(i);\n      f.end = end;\n      if (g = fragmentByStart[end]) {\n        delete fragmentByStart[g.start];\n        var fg = g === f ? f : f.concat(g);\n        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else if (f = fragmentByStart[end]) {\n      delete fragmentByStart[f.start];\n      f.unshift(i);\n      f.start = start;\n      if (g = fragmentByEnd[start]) {\n        delete fragmentByEnd[g.end];\n        var gf = g === f ? f : g.concat(f);\n        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else {\n      f = [i];\n      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;\n    }\n  });\n\n  function ends(i) {\n    var arc = topology.arcs[i < 0 ? ~i : i],\n        p0 = arc[0],\n        p1;\n    if (topology.transform) p1 = [0, 0], arc.forEach(function (dp) {\n      p1[0] += dp[0], p1[1] += dp[1];\n    });else p1 = arc[arc.length - 1];\n    return i < 0 ? [p1, p0] : [p0, p1];\n  }\n\n  function flush(fragmentByEnd, fragmentByStart) {\n    for (var k in fragmentByEnd) {\n      var f = fragmentByEnd[k];\n      delete fragmentByStart[f.start];\n      delete f.start;\n      delete f.end;\n      f.forEach(function (i) {\n        stitchedArcs[i < 0 ? ~i : i] = 1;\n      });\n      fragments.push(f);\n    }\n  }\n\n  flush(fragmentByEnd, fragmentByStart);\n  flush(fragmentByStart, fragmentByEnd);\n  arcs.forEach(function (i) {\n    if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]);\n  });\n\n  return fragments;\n};\n\nfunction planarRingArea(ring) {\n  var i = -1,\n      n = ring.length,\n      a,\n      b = ring[n - 1],\n      area = 0;\n  while (++i < n) {\n    a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];\n  }return Math.abs(area); // Note: doubled area!\n}\n\nvar merge = function (topology) {\n  return object(topology, mergeArcs.apply(this, arguments));\n};\n\nfunction mergeArcs(topology, objects) {\n  var polygonsByArc = {},\n      polygons = [],\n      groups = [];\n\n  objects.forEach(geometry);\n\n  function geometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\":\n        o.geometries.forEach(geometry);break;\n      case \"Polygon\":\n        extract(o.arcs);break;\n      case \"MultiPolygon\":\n        o.arcs.forEach(extract);break;\n    }\n  }\n\n  function extract(polygon) {\n    polygon.forEach(function (ring) {\n      ring.forEach(function (arc) {\n        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);\n      });\n    });\n    polygons.push(polygon);\n  }\n\n  function area(ring) {\n    return planarRingArea(object(topology, { type: \"Polygon\", arcs: [ring] }).coordinates[0]);\n  }\n\n  polygons.forEach(function (polygon) {\n    if (!polygon._) {\n      var group = [],\n          neighbors = [polygon];\n      polygon._ = 1;\n      groups.push(group);\n      while (polygon = neighbors.pop()) {\n        group.push(polygon);\n        polygon.forEach(function (ring) {\n          ring.forEach(function (arc) {\n            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function (polygon) {\n              if (!polygon._) {\n                polygon._ = 1;\n                neighbors.push(polygon);\n              }\n            });\n          });\n        });\n      }\n    }\n  });\n\n  polygons.forEach(function (polygon) {\n    delete polygon._;\n  });\n\n  return {\n    type: \"MultiPolygon\",\n    arcs: groups.map(function (polygons) {\n      var arcs = [],\n          n;\n\n      // Extract the exterior (unique) arcs.\n      polygons.forEach(function (polygon) {\n        polygon.forEach(function (ring) {\n          ring.forEach(function (arc) {\n            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {\n              arcs.push(arc);\n            }\n          });\n        });\n      });\n\n      // Stitch the arcs into one or more rings.\n      arcs = stitch(topology, arcs);\n\n      // If more than one ring is returned,\n      // at most one of these rings can be the exterior;\n      // choose the one with the greatest absolute area.\n      if ((n = arcs.length) > 1) {\n        for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {\n          if ((ki = area(arcs[i])) > k) {\n            t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;\n          }\n        }\n      }\n\n      return arcs;\n    })\n  };\n}\n\n// Computes the bounding box of the specified hash of GeoJSON objects.\nvar bounds = function (objects) {\n  var x0 = Infinity,\n      y0 = Infinity,\n      x1 = -Infinity,\n      y1 = -Infinity;\n\n  function boundGeometry(geometry) {\n    if (geometry != null && boundGeometryType.hasOwnProperty(geometry.type)) boundGeometryType[geometry.type](geometry);\n  }\n\n  var boundGeometryType = {\n    GeometryCollection: function GeometryCollection(o) {\n      o.geometries.forEach(boundGeometry);\n    },\n    Point: function Point(o) {\n      boundPoint(o.coordinates);\n    },\n    MultiPoint: function MultiPoint(o) {\n      o.coordinates.forEach(boundPoint);\n    },\n    LineString: function LineString(o) {\n      boundLine(o.arcs);\n    },\n    MultiLineString: function MultiLineString(o) {\n      o.arcs.forEach(boundLine);\n    },\n    Polygon: function Polygon(o) {\n      o.arcs.forEach(boundLine);\n    },\n    MultiPolygon: function MultiPolygon(o) {\n      o.arcs.forEach(boundMultiLine);\n    }\n  };\n\n  function boundPoint(coordinates) {\n    var x = coordinates[0],\n        y = coordinates[1];\n    if (x < x0) x0 = x;\n    if (x > x1) x1 = x;\n    if (y < y0) y0 = y;\n    if (y > y1) y1 = y;\n  }\n\n  function boundLine(coordinates) {\n    coordinates.forEach(boundPoint);\n  }\n\n  function boundMultiLine(coordinates) {\n    coordinates.forEach(boundLine);\n  }\n\n  for (var key in objects) {\n    boundGeometry(objects[key]);\n  }\n\n  return x1 >= x0 && y1 >= y0 ? [x0, y0, x1, y1] : undefined;\n};\n\nvar hashset = function (size, hash, equal, type, empty) {\n  if (arguments.length === 3) {\n    type = Array;\n    empty = null;\n  }\n\n  var store = new type(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))),\n      mask = size - 1;\n\n  for (var i = 0; i < size; ++i) {\n    store[i] = empty;\n  }\n\n  function add(value) {\n    var index = hash(value) & mask,\n        match = store[index],\n        collisions = 0;\n    while (match != empty) {\n      if (equal(match, value)) return true;\n      if (++collisions >= size) throw new Error(\"full hashset\");\n      match = store[index = index + 1 & mask];\n    }\n    store[index] = value;\n    return true;\n  }\n\n  function has(value) {\n    var index = hash(value) & mask,\n        match = store[index],\n        collisions = 0;\n    while (match != empty) {\n      if (equal(match, value)) return true;\n      if (++collisions >= size) break;\n      match = store[index = index + 1 & mask];\n    }\n    return false;\n  }\n\n  function values() {\n    var values = [];\n    for (var i = 0, n = store.length; i < n; ++i) {\n      var match = store[i];\n      if (match != empty) values.push(match);\n    }\n    return values;\n  }\n\n  return {\n    add: add,\n    has: has,\n    values: values\n  };\n};\n\nvar hashmap = function (size, hash, equal, keyType, keyEmpty, valueType) {\n  if (arguments.length === 3) {\n    keyType = valueType = Array;\n    keyEmpty = null;\n  }\n\n  var keystore = new keyType(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))),\n      valstore = new valueType(size),\n      mask = size - 1;\n\n  for (var i = 0; i < size; ++i) {\n    keystore[i] = keyEmpty;\n  }\n\n  function set(key, value) {\n    var index = hash(key) & mask,\n        matchKey = keystore[index],\n        collisions = 0;\n    while (matchKey != keyEmpty) {\n      if (equal(matchKey, key)) return valstore[index] = value;\n      if (++collisions >= size) throw new Error(\"full hashmap\");\n      matchKey = keystore[index = index + 1 & mask];\n    }\n    keystore[index] = key;\n    valstore[index] = value;\n    return value;\n  }\n\n  function maybeSet(key, value) {\n    var index = hash(key) & mask,\n        matchKey = keystore[index],\n        collisions = 0;\n    while (matchKey != keyEmpty) {\n      if (equal(matchKey, key)) return valstore[index];\n      if (++collisions >= size) throw new Error(\"full hashmap\");\n      matchKey = keystore[index = index + 1 & mask];\n    }\n    keystore[index] = key;\n    valstore[index] = value;\n    return value;\n  }\n\n  function get(key, missingValue) {\n    var index = hash(key) & mask,\n        matchKey = keystore[index],\n        collisions = 0;\n    while (matchKey != keyEmpty) {\n      if (equal(matchKey, key)) return valstore[index];\n      if (++collisions >= size) break;\n      matchKey = keystore[index = index + 1 & mask];\n    }\n    return missingValue;\n  }\n\n  function keys() {\n    var keys = [];\n    for (var i = 0, n = keystore.length; i < n; ++i) {\n      var matchKey = keystore[i];\n      if (matchKey != keyEmpty) keys.push(matchKey);\n    }\n    return keys;\n  }\n\n  return {\n    set: set,\n    maybeSet: maybeSet, // set if unset\n    get: get,\n    keys: keys\n  };\n};\n\nvar equalPoint = function (pointA, pointB) {\n  return pointA[0] === pointB[0] && pointA[1] === pointB[1];\n};\n\n// TODO if quantized, use simpler Int32 hashing?\n\nvar buffer = new ArrayBuffer(16);\nvar floats = new Float64Array(buffer);\nvar uints = new Uint32Array(buffer);\n\nvar hashPoint = function (point) {\n  floats[0] = point[0];\n  floats[1] = point[1];\n  var hash = uints[0] ^ uints[1];\n  hash = hash << 5 ^ hash >> 7 ^ uints[2] ^ uints[3];\n  return hash & 0x7fffffff;\n};\n\n// Given an extracted (pre-)topology, identifies all of the junctions. These are\n// the points at which arcs (lines or rings) will need to be cut so that each\n// arc is represented uniquely.\n//\n// A junction is a point where at least one arc deviates from another arc going\n// through the same point. For example, consider the point B. If there is a arc\n// through ABC and another arc through CBA, then B is not a junction because in\n// both cases the adjacent point pairs are {A,C}. However, if there is an\n// additional arc ABD, then {A,D} != {A,C}, and thus B becomes a junction.\n//\n// For a closed ring ABCA, the first point A’s adjacent points are the second\n// and last point {B,C}. For a line, the first and last point are always\n// considered junctions, even if the line is closed; this ensures that a closed\n// line is never rotated.\nvar join = function (topology) {\n  var coordinates = topology.coordinates,\n      lines = topology.lines,\n      rings = topology.rings,\n      indexes = index(),\n      visitedByIndex = new Int32Array(coordinates.length),\n      leftByIndex = new Int32Array(coordinates.length),\n      rightByIndex = new Int32Array(coordinates.length),\n      junctionByIndex = new Int8Array(coordinates.length),\n      junctionCount = 0,\n      // upper bound on number of junctions\n  i,\n      n,\n      previousIndex,\n      currentIndex,\n      nextIndex;\n\n  for (i = 0, n = coordinates.length; i < n; ++i) {\n    visitedByIndex[i] = leftByIndex[i] = rightByIndex[i] = -1;\n  }\n\n  for (i = 0, n = lines.length; i < n; ++i) {\n    var line = lines[i],\n        lineStart = line[0],\n        lineEnd = line[1];\n    currentIndex = indexes[lineStart];\n    nextIndex = indexes[++lineStart];\n    ++junctionCount, junctionByIndex[currentIndex] = 1; // start\n    while (++lineStart <= lineEnd) {\n      sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[lineStart]);\n    }\n    ++junctionCount, junctionByIndex[nextIndex] = 1; // end\n  }\n\n  for (i = 0, n = coordinates.length; i < n; ++i) {\n    visitedByIndex[i] = -1;\n  }\n\n  for (i = 0, n = rings.length; i < n; ++i) {\n    var ring = rings[i],\n        ringStart = ring[0] + 1,\n        ringEnd = ring[1];\n    previousIndex = indexes[ringEnd - 1];\n    currentIndex = indexes[ringStart - 1];\n    nextIndex = indexes[ringStart];\n    sequence(i, previousIndex, currentIndex, nextIndex);\n    while (++ringStart <= ringEnd) {\n      sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[ringStart]);\n    }\n  }\n\n  function sequence(i, previousIndex, currentIndex, nextIndex) {\n    if (visitedByIndex[currentIndex] === i) return; // ignore self-intersection\n    visitedByIndex[currentIndex] = i;\n    var leftIndex = leftByIndex[currentIndex];\n    if (leftIndex >= 0) {\n      var rightIndex = rightByIndex[currentIndex];\n      if ((leftIndex !== previousIndex || rightIndex !== nextIndex) && (leftIndex !== nextIndex || rightIndex !== previousIndex)) {\n        ++junctionCount, junctionByIndex[currentIndex] = 1;\n      }\n    } else {\n      leftByIndex[currentIndex] = previousIndex;\n      rightByIndex[currentIndex] = nextIndex;\n    }\n  }\n\n  function index() {\n    var indexByPoint = hashmap(coordinates.length * 1.4, hashIndex, equalIndex, Int32Array, -1, Int32Array),\n        indexes = new Int32Array(coordinates.length);\n\n    for (var i = 0, n = coordinates.length; i < n; ++i) {\n      indexes[i] = indexByPoint.maybeSet(i, i);\n    }\n\n    return indexes;\n  }\n\n  function hashIndex(i) {\n    return hashPoint(coordinates[i]);\n  }\n\n  function equalIndex(i, j) {\n    return equalPoint(coordinates[i], coordinates[j]);\n  }\n\n  visitedByIndex = leftByIndex = rightByIndex = null;\n\n  var junctionByPoint = hashset(junctionCount * 1.4, hashPoint, equalPoint),\n      j;\n\n  // Convert back to a standard hashset by point for caller convenience.\n  for (i = 0, n = coordinates.length; i < n; ++i) {\n    if (junctionByIndex[j = indexes[i]]) {\n      junctionByPoint.add(coordinates[j]);\n    }\n  }\n\n  return junctionByPoint;\n};\n\n// Given an extracted (pre-)topology, cuts (or rotates) arcs so that all shared\n// point sequences are identified. The topology can then be subsequently deduped\n// to remove exact duplicate arcs.\nvar cut = function (topology) {\n  var junctions = join(topology),\n      coordinates = topology.coordinates,\n      lines = topology.lines,\n      rings = topology.rings,\n      next,\n      i,\n      n;\n\n  for (i = 0, n = lines.length; i < n; ++i) {\n    var line = lines[i],\n        lineMid = line[0],\n        lineEnd = line[1];\n    while (++lineMid < lineEnd) {\n      if (junctions.has(coordinates[lineMid])) {\n        next = { 0: lineMid, 1: line[1] };\n        line[1] = lineMid;\n        line = line.next = next;\n      }\n    }\n  }\n\n  for (i = 0, n = rings.length; i < n; ++i) {\n    var ring = rings[i],\n        ringStart = ring[0],\n        ringMid = ringStart,\n        ringEnd = ring[1],\n        ringFixed = junctions.has(coordinates[ringStart]);\n    while (++ringMid < ringEnd) {\n      if (junctions.has(coordinates[ringMid])) {\n        if (ringFixed) {\n          next = { 0: ringMid, 1: ring[1] };\n          ring[1] = ringMid;\n          ring = ring.next = next;\n        } else {\n          // For the first junction, we can rotate rather than cut.\n          rotateArray(coordinates, ringStart, ringEnd, ringEnd - ringMid);\n          coordinates[ringEnd] = coordinates[ringStart];\n          ringFixed = true;\n          ringMid = ringStart; // restart; we may have skipped junctions\n        }\n      }\n    }\n  }\n\n  return topology;\n};\n\nfunction rotateArray(array, start, end, offset) {\n  reverse$1(array, start, end);\n  reverse$1(array, start, start + offset);\n  reverse$1(array, start + offset, end);\n}\n\nfunction reverse$1(array, start, end) {\n  for (var mid = start + (end-- - start >> 1), t; start < mid; ++start, --end) {\n    t = array[start], array[start] = array[end], array[end] = t;\n  }\n}\n\n// Given a cut topology, combines duplicate arcs.\nvar dedup$1 = function (topology) {\n  var coordinates = topology.coordinates,\n      lines = topology.lines,\n      line,\n      rings = topology.rings,\n      ring,\n      arcCount = lines.length + rings.length,\n      i,\n      n;\n\n  delete topology.lines;\n  delete topology.rings;\n\n  // Count the number of (non-unique) arcs to initialize the hashmap safely.\n  for (i = 0, n = lines.length; i < n; ++i) {\n    line = lines[i];while (line = line.next) {\n      ++arcCount;\n    }\n  }\n  for (i = 0, n = rings.length; i < n; ++i) {\n    ring = rings[i];while (ring = ring.next) {\n      ++arcCount;\n    }\n  }\n\n  var arcsByEnd = hashmap(arcCount * 2 * 1.4, hashPoint, equalPoint),\n      arcs = topology.arcs = [];\n\n  for (i = 0, n = lines.length; i < n; ++i) {\n    line = lines[i];\n    do {\n      dedupLine(line);\n    } while (line = line.next);\n  }\n\n  for (i = 0, n = rings.length; i < n; ++i) {\n    ring = rings[i];\n    if (ring.next) {\n      // arc is no longer closed\n      do {\n        dedupLine(ring);\n      } while (ring = ring.next);\n    } else {\n      dedupRing(ring);\n    }\n  }\n\n  function dedupLine(arc) {\n    var startPoint, endPoint, startArcs, startArc, endArcs, endArc, i, n;\n\n    // Does this arc match an existing arc in order?\n    if (startArcs = arcsByEnd.get(startPoint = coordinates[arc[0]])) {\n      for (i = 0, n = startArcs.length; i < n; ++i) {\n        startArc = startArcs[i];\n        if (equalLine(startArc, arc)) {\n          arc[0] = startArc[0];\n          arc[1] = startArc[1];\n          return;\n        }\n      }\n    }\n\n    // Does this arc match an existing arc in reverse order?\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[1]])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n        if (reverseEqualLine(endArc, arc)) {\n          arc[1] = endArc[0];\n          arc[0] = endArc[1];\n          return;\n        }\n      }\n    }\n\n    if (startArcs) startArcs.push(arc);else arcsByEnd.set(startPoint, [arc]);\n    if (endArcs) endArcs.push(arc);else arcsByEnd.set(endPoint, [arc]);\n    arcs.push(arc);\n  }\n\n  function dedupRing(arc) {\n    var endPoint, endArcs, endArc, i, n;\n\n    // Does this arc match an existing line in order, or reverse order?\n    // Rings are closed, so their start point and end point is the same.\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0]])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n        if (equalRing(endArc, arc)) {\n          arc[0] = endArc[0];\n          arc[1] = endArc[1];\n          return;\n        }\n        if (reverseEqualRing(endArc, arc)) {\n          arc[0] = endArc[1];\n          arc[1] = endArc[0];\n          return;\n        }\n      }\n    }\n\n    // Otherwise, does this arc match an existing ring in order, or reverse order?\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0] + findMinimumOffset(arc)])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n        if (equalRing(endArc, arc)) {\n          arc[0] = endArc[0];\n          arc[1] = endArc[1];\n          return;\n        }\n        if (reverseEqualRing(endArc, arc)) {\n          arc[0] = endArc[1];\n          arc[1] = endArc[0];\n          return;\n        }\n      }\n    }\n\n    if (endArcs) endArcs.push(arc);else arcsByEnd.set(endPoint, [arc]);\n    arcs.push(arc);\n  }\n\n  function equalLine(arcA, arcB) {\n    var ia = arcA[0],\n        ib = arcB[0],\n        ja = arcA[1],\n        jb = arcB[1];\n    if (ia - ja !== ib - jb) return false;\n    for (; ia <= ja; ++ia, ++ib) {\n      if (!equalPoint(coordinates[ia], coordinates[ib])) return false;\n    }return true;\n  }\n\n  function reverseEqualLine(arcA, arcB) {\n    var ia = arcA[0],\n        ib = arcB[0],\n        ja = arcA[1],\n        jb = arcB[1];\n    if (ia - ja !== ib - jb) return false;\n    for (; ia <= ja; ++ia, --jb) {\n      if (!equalPoint(coordinates[ia], coordinates[jb])) return false;\n    }return true;\n  }\n\n  function equalRing(arcA, arcB) {\n    var ia = arcA[0],\n        ib = arcB[0],\n        ja = arcA[1],\n        jb = arcB[1],\n        n = ja - ia;\n    if (n !== jb - ib) return false;\n    var ka = findMinimumOffset(arcA),\n        kb = findMinimumOffset(arcB);\n    for (var i = 0; i < n; ++i) {\n      if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[ib + (i + kb) % n])) return false;\n    }\n    return true;\n  }\n\n  function reverseEqualRing(arcA, arcB) {\n    var ia = arcA[0],\n        ib = arcB[0],\n        ja = arcA[1],\n        jb = arcB[1],\n        n = ja - ia;\n    if (n !== jb - ib) return false;\n    var ka = findMinimumOffset(arcA),\n        kb = n - findMinimumOffset(arcB);\n    for (var i = 0; i < n; ++i) {\n      if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[jb - (i + kb) % n])) return false;\n    }\n    return true;\n  }\n\n  // Rings are rotated to a consistent, but arbitrary, start point.\n  // This is necessary to detect when a ring and a rotated copy are dupes.\n  function findMinimumOffset(arc) {\n    var start = arc[0],\n        end = arc[1],\n        mid = start,\n        minimum = mid,\n        minimumPoint = coordinates[mid];\n    while (++mid < end) {\n      var point = coordinates[mid];\n      if (point[0] < minimumPoint[0] || point[0] === minimumPoint[0] && point[1] < minimumPoint[1]) {\n        minimum = mid;\n        minimumPoint = point;\n      }\n    }\n    return minimum - start;\n  }\n\n  return topology;\n};\n\n// Given an array of arcs in absolute (but already quantized!) coordinates,\n// converts to fixed-point delta encoding.\n// This is a destructive operation that modifies the given arcs!\nvar delta = function (arcs) {\n  var i = -1,\n      n = arcs.length;\n\n  while (++i < n) {\n    var arc = arcs[i],\n        j = 0,\n        k = 1,\n        m = arc.length,\n        point = arc[0],\n        x0 = point[0],\n        y0 = point[1],\n        x1,\n        y1;\n\n    while (++j < m) {\n      point = arc[j], x1 = point[0], y1 = point[1];\n      if (x1 !== x0 || y1 !== y0) arc[k++] = [x1 - x0, y1 - y0], x0 = x1, y0 = y1;\n    }\n\n    if (k === 1) arc[k++] = [0, 0]; // Each arc must be an array of two or more positions.\n\n    arc.length = k;\n  }\n\n  return arcs;\n};\n\n// Extracts the lines and rings from the specified hash of geometry objects.\n//\n// Returns an object with three properties:\n//\n// * coordinates - shared buffer of [x, y] coordinates\n// * lines - lines extracted from the hash, of the form [start, end]\n// * rings - rings extracted from the hash, of the form [start, end]\n//\n// For each ring or line, start and end represent inclusive indexes into the\n// coordinates buffer. For rings (and closed lines), coordinates[start] equals\n// coordinates[end].\n//\n// For each line or polygon geometry in the input hash, including nested\n// geometries as in geometry collections, the `coordinates` array is replaced\n// with an equivalent `arcs` array that, for each line (for line string\n// geometries) or ring (for polygon geometries), points to one of the above\n// lines or rings.\nvar extract = function (objects) {\n  var index = -1,\n      lines = [],\n      rings = [],\n      coordinates = [];\n\n  function extractGeometry(geometry) {\n    if (geometry && extractGeometryType.hasOwnProperty(geometry.type)) extractGeometryType[geometry.type](geometry);\n  }\n\n  var extractGeometryType = {\n    GeometryCollection: function GeometryCollection(o) {\n      o.geometries.forEach(extractGeometry);\n    },\n    LineString: function LineString(o) {\n      o.arcs = extractLine(o.arcs);\n    },\n    MultiLineString: function MultiLineString(o) {\n      o.arcs = o.arcs.map(extractLine);\n    },\n    Polygon: function Polygon(o) {\n      o.arcs = o.arcs.map(extractRing);\n    },\n    MultiPolygon: function MultiPolygon(o) {\n      o.arcs = o.arcs.map(extractMultiRing);\n    }\n  };\n\n  function extractLine(line) {\n    for (var i = 0, n = line.length; i < n; ++i) {\n      coordinates[++index] = line[i];\n    }var arc = { 0: index - n + 1, 1: index };\n    lines.push(arc);\n    return arc;\n  }\n\n  function extractRing(ring) {\n    for (var i = 0, n = ring.length; i < n; ++i) {\n      coordinates[++index] = ring[i];\n    }var arc = { 0: index - n + 1, 1: index };\n    rings.push(arc);\n    return arc;\n  }\n\n  function extractMultiRing(rings) {\n    return rings.map(extractRing);\n  }\n\n  for (var key in objects) {\n    extractGeometry(objects[key]);\n  }\n\n  return {\n    type: \"Topology\",\n    coordinates: coordinates,\n    lines: lines,\n    rings: rings,\n    objects: objects\n  };\n};\n\n// Given a hash of GeoJSON objects, returns a hash of GeoJSON geometry objects.\n// Any null input geometry objects are represented as {type: null} in the output.\n// Any feature.{id,properties,bbox} are transferred to the output geometry object.\n// Each output geometry object is a shallow copy of the input (e.g., properties, coordinates)!\nvar geometry$1 = function (inputs) {\n  var outputs = {},\n      key;\n  for (key in inputs) {\n    outputs[key] = geomifyObject(inputs[key]);\n  }return outputs;\n};\n\nfunction geomifyObject(input) {\n  return input == null ? { type: null } : (input.type === \"FeatureCollection\" ? geomifyFeatureCollection : input.type === \"Feature\" ? geomifyFeature : geomifyGeometry)(input);\n}\n\nfunction geomifyFeatureCollection(input) {\n  var output = { type: \"GeometryCollection\", geometries: input.features.map(geomifyFeature) };\n  if (input.bbox != null) output.bbox = input.bbox;\n  return output;\n}\n\nfunction geomifyFeature(input) {\n  var output = geomifyGeometry(input.geometry),\n      key; // eslint-disable-line no-unused-vars\n  if (input.id != null) output.id = input.id;\n  if (input.bbox != null) output.bbox = input.bbox;\n  for (key in input.properties) {\n    output.properties = input.properties;break;\n  }\n  return output;\n}\n\nfunction geomifyGeometry(input) {\n  if (input == null) return { type: null };\n  var output = input.type === \"GeometryCollection\" ? { type: \"GeometryCollection\", geometries: input.geometries.map(geomifyGeometry) } : input.type === \"Point\" || input.type === \"MultiPoint\" ? { type: input.type, coordinates: input.coordinates } : { type: input.type, arcs: input.coordinates }; // TODO Check for unknown types?\n  if (input.bbox != null) output.bbox = input.bbox;\n  return output;\n}\n\nvar prequantize = function (objects, bbox, n) {\n  var x0 = bbox[0],\n      y0 = bbox[1],\n      x1 = bbox[2],\n      y1 = bbox[3],\n      kx = x1 - x0 ? (n - 1) / (x1 - x0) : 1,\n      ky = y1 - y0 ? (n - 1) / (y1 - y0) : 1;\n\n  function quantizePoint(input) {\n    return [Math.round((input[0] - x0) * kx), Math.round((input[1] - y0) * ky)];\n  }\n\n  function quantizePoints(input, m) {\n    var i = -1,\n        j = 0,\n        n = input.length,\n        output = new Array(n),\n        // pessimistic\n    pi,\n        px,\n        py,\n        x,\n        y;\n\n    while (++i < n) {\n      pi = input[i];\n      x = Math.round((pi[0] - x0) * kx);\n      y = Math.round((pi[1] - y0) * ky);\n      if (x !== px || y !== py) output[j++] = [px = x, py = y]; // non-coincident points\n    }\n\n    output.length = j;\n    while (j < m) {\n      j = output.push([output[0][0], output[0][1]]);\n    }return output;\n  }\n\n  function quantizeLine(input) {\n    return quantizePoints(input, 2);\n  }\n\n  function quantizeRing(input) {\n    return quantizePoints(input, 4);\n  }\n\n  function quantizePolygon(input) {\n    return input.map(quantizeRing);\n  }\n\n  function quantizeGeometry(o) {\n    if (o != null && quantizeGeometryType.hasOwnProperty(o.type)) quantizeGeometryType[o.type](o);\n  }\n\n  var quantizeGeometryType = {\n    GeometryCollection: function GeometryCollection(o) {\n      o.geometries.forEach(quantizeGeometry);\n    },\n    Point: function Point(o) {\n      o.coordinates = quantizePoint(o.coordinates);\n    },\n    MultiPoint: function MultiPoint(o) {\n      o.coordinates = o.coordinates.map(quantizePoint);\n    },\n    LineString: function LineString(o) {\n      o.arcs = quantizeLine(o.arcs);\n    },\n    MultiLineString: function MultiLineString(o) {\n      o.arcs = o.arcs.map(quantizeLine);\n    },\n    Polygon: function Polygon(o) {\n      o.arcs = quantizePolygon(o.arcs);\n    },\n    MultiPolygon: function MultiPolygon(o) {\n      o.arcs = o.arcs.map(quantizePolygon);\n    }\n  };\n\n  for (var key in objects) {\n    quantizeGeometry(objects[key]);\n  }\n\n  return {\n    scale: [1 / kx, 1 / ky],\n    translate: [x0, y0]\n  };\n};\n\n// Constructs the TopoJSON Topology for the specified hash of features.\n// Each object in the specified hash must be a GeoJSON object,\n// meaning FeatureCollection, a Feature or a geometry object.\nvar topology = function (objects, quantization) {\n  var bbox = bounds(objects = geometry$1(objects)),\n      transform = quantization > 0 && bbox && prequantize(objects, bbox, quantization),\n      topology = dedup$1(cut(extract(objects))),\n      coordinates = topology.coordinates,\n      indexByArc = hashmap(topology.arcs.length * 1.4, hashArc, equalArc);\n\n  objects = topology.objects; // for garbage collection\n  topology.bbox = bbox;\n  topology.arcs = topology.arcs.map(function (arc, i) {\n    indexByArc.set(arc, i);\n    return coordinates.slice(arc[0], arc[1] + 1);\n  });\n\n  delete topology.coordinates;\n  coordinates = null;\n\n  function indexGeometry(geometry) {\n    if (geometry && indexGeometryType.hasOwnProperty(geometry.type)) indexGeometryType[geometry.type](geometry);\n  }\n\n  var indexGeometryType = {\n    GeometryCollection: function GeometryCollection(o) {\n      o.geometries.forEach(indexGeometry);\n    },\n    LineString: function LineString(o) {\n      o.arcs = indexArcs(o.arcs);\n    },\n    MultiLineString: function MultiLineString(o) {\n      o.arcs = o.arcs.map(indexArcs);\n    },\n    Polygon: function Polygon(o) {\n      o.arcs = o.arcs.map(indexArcs);\n    },\n    MultiPolygon: function MultiPolygon(o) {\n      o.arcs = o.arcs.map(indexMultiArcs);\n    }\n  };\n\n  function indexArcs(arc) {\n    var indexes = [];\n    do {\n      var index = indexByArc.get(arc);\n      indexes.push(arc[0] < arc[1] ? index : ~index);\n    } while (arc = arc.next);\n    return indexes;\n  }\n\n  function indexMultiArcs(arcs) {\n    return arcs.map(indexArcs);\n  }\n\n  for (var key in objects) {\n    indexGeometry(objects[key]);\n  }\n\n  if (transform) {\n    topology.transform = transform;\n    topology.arcs = delta(topology.arcs);\n  }\n\n  return topology;\n};\n\nfunction hashArc(arc) {\n  var i = arc[0],\n      j = arc[1],\n      t;\n  if (j < i) t = i, i = j, j = t;\n  return i + 31 * j;\n}\n\nfunction equalArc(arcA, arcB) {\n  var ia = arcA[0],\n      ja = arcA[1],\n      ib = arcB[0],\n      jb = arcB[1],\n      t;\n  if (ja < ia) t = ia, ia = ja, ja = t;\n  if (jb < ib) t = ib, ib = jb, jb = t;\n  return ia === ib && ja === jb;\n}\n\n/**\n * Dissolves all overlapping (Multi)Polygon\n *\n * @param {FeatureCollection<Polygon|MultiPolygon>} geojson Polygons to dissolve\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.mutate=false] Prevent input mutation\n * @returns {Feature<Polygon|MultiPolygon>} Dissolved Polygons\n */\nfunction polygonDissolve(geojson, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject$2(options)) throw new Error('options is invalid');\n    var mutate = options.mutate;\n\n    // Validation\n    if (getType(geojson) !== 'FeatureCollection') throw new Error('geojson must be a FeatureCollection');\n    if (!geojson.features.length) throw new Error('geojson is empty');\n\n    // Clone geojson to avoid side effects\n    // Topojson modifies in place, so we need to deep clone first\n    if (mutate === false || mutate === undefined) geojson = clone(geojson);\n\n    var geoms = [];\n    flattenEach(geojson, function (feature$$1) {\n        geoms.push(feature$$1.geometry);\n    });\n    var topo = topology({ geoms: geometryCollection(geoms).geometry });\n    return merge(topo, topo.objects.geoms.geometries);\n}\n\n/**\n * Transform function: attempts to dissolve geojson objects where possible\n * [GeoJSON] -> GeoJSON geometry\n *\n * @private\n * @param {FeatureCollection<LineString|MultiLineString|Polygon|MultiPolygon>} geojson Features to dissolved\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.mutate=false] Prevent input mutation\n * @returns {Feature<MultiLineString|MultiPolygon>} Dissolved Features\n */\nfunction dissolve(geojson, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject$2(options)) throw new Error('options is invalid');\n    var mutate = options.mutate;\n\n    // Validation\n    if (getType(geojson) !== 'FeatureCollection') throw new Error('geojson must be a FeatureCollection');\n    if (!geojson.features.length) throw new Error('geojson is empty');\n\n    // Clone geojson to avoid side effects\n    // Topojson modifies in place, so we need to deep clone first\n    if (mutate === false || mutate === undefined) geojson = clone(geojson);\n\n    // Assert homogenity\n    var type = getHomogenousType(geojson);\n    if (!type) throw new Error('geojson must be homogenous');\n\n    switch (type) {\n        case 'LineString':\n            return lineDissolve(geojson, options);\n        case 'Polygon':\n            return polygonDissolve(geojson, options);\n        default:\n            throw new Error(type + ' is not supported');\n    }\n}\n\n/**\n * Checks if GeoJSON is Homogenous\n *\n * @private\n * @param {GeoJSON} geojson GeoJSON\n * @returns {string|null} Homogenous type or null if multiple types\n */\nfunction getHomogenousType(geojson) {\n    var types = {};\n    flattenEach(geojson, function (feature$$1) {\n        types[feature$$1.geometry.type] = true;\n    });\n    var keys = Object.keys(types);\n    if (keys.length === 1) return keys[0];\n    return null;\n}\n\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n\n/**\n * Calculates the distance between two {@link Point|points} in degrees, radians,\n * miles, or kilometers. This uses the\n * [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula)\n * to account for global curvature.\n *\n * @name distance\n * @param {Coord} from origin point\n * @param {Coord} to destination point\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {number} distance between the two points\n * @example\n * var from = turf.point([-75.343, 39.984]);\n * var to = turf.point([-75.534, 39.123]);\n * var options = {units: 'miles'};\n *\n * var distance = turf.distance(from, to, options);\n *\n * //addToMap\n * var addToMap = [from, to];\n * from.properties.distance = distance;\n * to.properties.distance = distance;\n */\nfunction distance(from, to, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject$2(options)) throw new Error('options is invalid');\n  var units = options.units;\n\n  var coordinates1 = getCoord(from);\n  var coordinates2 = getCoord(to);\n  var dLat = degreesToRadians(coordinates2[1] - coordinates1[1]);\n  var dLon = degreesToRadians(coordinates2[0] - coordinates1[0]);\n  var lat1 = degreesToRadians(coordinates1[1]);\n  var lat2 = degreesToRadians(coordinates2[1]);\n\n  var a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n\n  return radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), units);\n}\n\n/**\n * Takes a set of {@link Point|points} and returns a concave hull Polygon or MultiPolygon.\n * Internally, this uses [turf-tin](https://github.com/Turfjs/turf-tin) to generate geometries.\n *\n * @name concave\n * @param {FeatureCollection<Point>} points input points\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.maxEdge=Infinity] the length (in 'units') of an edge necessary for part of the hull to become concave.\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {Feature<(Polygon|MultiPolygon)>|null} a concave hull (null value is returned if unable to compute hull)\n * @example\n * var points = turf.featureCollection([\n *   turf.point([-63.601226, 44.642643]),\n *   turf.point([-63.591442, 44.651436]),\n *   turf.point([-63.580799, 44.648749]),\n *   turf.point([-63.573589, 44.641788]),\n *   turf.point([-63.587665, 44.64533]),\n *   turf.point([-63.595218, 44.64765])\n * ]);\n * var options = {units: 'miles', maxEdge: 1};\n *\n * var hull = turf.concave(points, options);\n *\n * //addToMap\n * var addToMap = [points, hull]\n */\nfunction concave$1(points, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject$2(options)) throw new Error('options is invalid');\n\n    // validation\n    if (!points) throw new Error('points is required');\n    var maxEdge = options.maxEdge || Infinity;\n    if (!isNumber(maxEdge)) throw new Error('maxEdge is invalid');\n\n    var cleaned = removeDuplicates(points);\n\n    var tinPolys = tin(cleaned);\n    // calculate length of all edges and area of all triangles\n    // and remove triangles that fail the max length test\n    tinPolys.features = tinPolys.features.filter(function (triangle) {\n        var pt1 = triangle.geometry.coordinates[0][0];\n        var pt2 = triangle.geometry.coordinates[0][1];\n        var pt3 = triangle.geometry.coordinates[0][2];\n        var dist1 = distance(pt1, pt2, options);\n        var dist2 = distance(pt2, pt3, options);\n        var dist3 = distance(pt1, pt3, options);\n        return dist1 <= maxEdge && dist2 <= maxEdge && dist3 <= maxEdge;\n    });\n\n    if (tinPolys.features.length < 1) return null;\n\n    // merge the adjacent triangles\n    var dissolved = dissolve(tinPolys, options);\n\n    // geojson-dissolve always returns a MultiPolygon\n    if (dissolved.coordinates.length === 1) {\n        dissolved.coordinates = dissolved.coordinates[0];\n        dissolved.type = 'Polygon';\n    }\n    return feature(dissolved);\n}\n\n/**\n * Removes duplicated points in a collection returning a new collection\n *\n * @private\n * @param {FeatureCollection<Point>} points to be cleaned\n * @returns {FeatureCollection<Point>} cleaned set of points\n */\nfunction removeDuplicates(points) {\n    var cleaned = [];\n    var existing = {};\n\n    featureEach(points, function (pt) {\n        if (!pt.geometry) return;\n        var key = pt.geometry.coordinates.join('-');\n        if (!existing.hasOwnProperty(key)) {\n            cleaned.push(pt);\n            existing[key] = true;\n        }\n    });\n    return featureCollection(cleaned);\n}\n\n/**\n * Takes a set of points and returns a concave hull polygon. Internally, this uses turf-tin to generate geometries.\n * @param  {Array<google.maps.LatLng>|Array<google.maps.LatLngLiteral>|google.maps.MVCArray} latLngArray array of google positions\n * @param  {number} maxEdge the size of an edge necessary for part of the hull to become concave (in miles)\n * @param  {string} units degrees, radians, miles, or kilometers\n * @return {Feature.<Polygon>}  a concave hull\n */\nfunction concave(latLngArray, maxEdge, units) {\n\n  var FeatureCollection = arrayToFeaturePoints(latLngArray);\n  return concave$1(FeatureCollection, {\n    maxEdge: maxEdge,\n    units: units\n  });\n}\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar simplify$1 = createCommonjsModule(function (module) {\n    /*\n     (c) 2013, Vladimir Agafonkin\n     Simplify.js, a high-performance JS polyline simplification library\n     mourner.github.io/simplify-js\n    */\n\n    (function () {\n        function getSqDist(p1, p2) {\n\n            var dx = p1.x - p2.x,\n                dy = p1.y - p2.y;\n\n            return dx * dx + dy * dy;\n        }\n\n        // square distance from a point to a segment\n        function getSqSegDist(p, p1, p2) {\n\n            var x = p1.x,\n                y = p1.y,\n                dx = p2.x - x,\n                dy = p2.y - y;\n\n            if (dx !== 0 || dy !== 0) {\n\n                var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);\n\n                if (t > 1) {\n                    x = p2.x;\n                    y = p2.y;\n                } else if (t > 0) {\n                    x += dx * t;\n                    y += dy * t;\n                }\n            }\n\n            dx = p.x - x;\n            dy = p.y - y;\n\n            return dx * dx + dy * dy;\n        }\n        // rest of the code doesn't care about point format\n\n        // basic distance-based simplification\n        function simplifyRadialDist(points, sqTolerance) {\n\n            var prevPoint = points[0],\n                newPoints = [prevPoint],\n                point;\n\n            for (var i = 1, len = points.length; i < len; i++) {\n                point = points[i];\n\n                if (getSqDist(point, prevPoint) > sqTolerance) {\n                    newPoints.push(point);\n                    prevPoint = point;\n                }\n            }\n\n            if (prevPoint !== point) newPoints.push(point);\n\n            return newPoints;\n        }\n\n        // simplification using optimized Douglas-Peucker algorithm with recursion elimination\n        function simplifyDouglasPeucker(points, sqTolerance) {\n\n            var len = points.length,\n                MarkerArray = typeof Uint8Array !== 'undefined' ? Uint8Array : Array,\n                markers = new MarkerArray(len),\n                first = 0,\n                last = len - 1,\n                stack = [],\n                newPoints = [],\n                i,\n                maxSqDist,\n                sqDist,\n                index;\n\n            markers[first] = markers[last] = 1;\n\n            while (last) {\n\n                maxSqDist = 0;\n\n                for (i = first + 1; i < last; i++) {\n                    sqDist = getSqSegDist(points[i], points[first], points[last]);\n\n                    if (sqDist > maxSqDist) {\n                        index = i;\n                        maxSqDist = sqDist;\n                    }\n                }\n\n                if (maxSqDist > sqTolerance) {\n                    markers[index] = 1;\n                    stack.push(first, index, index, last);\n                }\n\n                last = stack.pop();\n                first = stack.pop();\n            }\n\n            for (i = 0; i < len; i++) {\n                if (markers[i]) newPoints.push(points[i]);\n            }\n\n            return newPoints;\n        }\n\n        // both algorithms combined for awesome performance\n        function simplify(points, tolerance, highestQuality) {\n\n            var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;\n\n            points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);\n            points = simplifyDouglasPeucker(points, sqTolerance);\n\n            return points;\n        }\n\n        // export as AMD module / Node module / browser or worker variable\n        if (typeof undefined === 'function' && undefined.amd) undefined(function () {\n            return simplify;\n        });else module.exports = simplify;\n    })();\n});\n\n/**\n * Removes redundant coordinates from any GeoJSON Geometry.\n *\n * @name cleanCoords\n * @param {Geometry|Feature} geojson Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated\n * @returns {Geometry|Feature} the cleaned input Feature/Geometry\n * @example\n * var line = turf.lineString([[0, 0], [0, 2], [0, 5], [0, 8], [0, 8], [0, 10]]);\n * var multiPoint = turf.multiPoint([[0, 0], [0, 0], [2, 2]]);\n *\n * turf.cleanCoords(line).geometry.coordinates;\n * //= [[0, 0], [0, 10]]\n *\n * turf.cleanCoords(multiPoint).geometry.coordinates;\n * //= [[0, 0], [2, 2]]\n */\nfunction cleanCoords(geojson, options) {\n    // Backwards compatible with v4.0\n    var mutate = (typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object' ? options.mutate : options;\n    if (!geojson) throw new Error('geojson is required');\n    var type = getType(geojson);\n\n    // Store new \"clean\" points in this Array\n    var newCoords = [];\n\n    switch (type) {\n        case 'LineString':\n            newCoords = cleanLine(geojson);\n            break;\n        case 'MultiLineString':\n        case 'Polygon':\n            getCoords(geojson).forEach(function (line) {\n                newCoords.push(cleanLine(line));\n            });\n            break;\n        case 'MultiPolygon':\n            getCoords(geojson).forEach(function (polygons) {\n                var polyPoints = [];\n                polygons.forEach(function (ring) {\n                    polyPoints.push(cleanLine(ring));\n                });\n                newCoords.push(polyPoints);\n            });\n            break;\n        case 'Point':\n            return geojson;\n        case 'MultiPoint':\n            var existing = {};\n            getCoords(geojson).forEach(function (coord) {\n                var key = coord.join('-');\n                if (!existing.hasOwnProperty(key)) {\n                    newCoords.push(coord);\n                    existing[key] = true;\n                }\n            });\n            break;\n        default:\n            throw new Error(type + ' geometry not supported');\n    }\n\n    // Support input mutation\n    if (geojson.coordinates) {\n        if (mutate === true) {\n            geojson.coordinates = newCoords;\n            return geojson;\n        }\n        return { type: type, coordinates: newCoords };\n    } else {\n        if (mutate === true) {\n            geojson.geometry.coordinates = newCoords;\n            return geojson;\n        }\n        return feature({ type: type, coordinates: newCoords }, geojson.properties, geojson.bbox, geojson.id);\n    }\n}\n\n/**\n * Clean Coords\n *\n * @private\n * @param {Array<number>|LineString} line Line\n * @returns {Array<number>} Cleaned coordinates\n */\nfunction cleanLine(line) {\n    var points = getCoords(line);\n    // handle \"clean\" segment\n    if (points.length === 2 && !equals(points[0], points[1])) return points;\n\n    var prevPoint, point$$1, nextPoint;\n    var newPoints = [];\n    var secondToLast = points.length - 1;\n\n    newPoints.push(points[0]);\n    for (var i = 1; i < secondToLast; i++) {\n        prevPoint = points[i - 1];\n        point$$1 = points[i];\n        nextPoint = points[i + 1];\n\n        if (!isPointOnLineSegment(prevPoint, nextPoint, point$$1)) {\n            newPoints.push(point$$1);\n        }\n    }\n    newPoints.push(nextPoint);\n    return newPoints;\n}\n\n/**\n * Compares two points and returns if they are equals\n *\n * @private\n * @param {Array<number>} pt1 point\n * @param {Array<number>} pt2 point\n * @returns {boolean} true if they are equals\n */\nfunction equals(pt1, pt2) {\n    return pt1[0] === pt2[0] && pt1[1] === pt2[1];\n}\n\n/**\n * Returns if `point` is on the segment between `start` and `end`.\n * Borrowed from `@turf/boolean-point-on-line` to speed up the evaluation (instead of using the module as dependency)\n *\n * @private\n * @param {Array<number>} start coord pair of start of line\n * @param {Array<number>} end coord pair of end of line\n * @param {Array<number>} point coord pair of point to check\n * @returns {boolean} true/false\n */\nfunction isPointOnLineSegment(start, end, point$$1) {\n    var x = point$$1[0],\n        y = point$$1[1];\n    var startX = start[0],\n        startY = start[1];\n    var endX = end[0],\n        endY = end[1];\n\n    var dxc = x - startX;\n    var dyc = y - startY;\n    var dxl = endX - startX;\n    var dyl = endY - startY;\n    var cross = dxc * dyl - dyc * dxl;\n\n    if (cross !== 0) return false;else if (Math.abs(dxl) >= Math.abs(dyl)) return dxl > 0 ? startX <= x && x <= endX : endX <= x && x <= startX;else return dyl > 0 ? startY <= y && y <= endY : endY <= y && y <= startY;\n}\n\n/**\n * Takes a {@link GeoJSON} object and returns a simplified version. Internally uses\n * [simplify-js](http://mourner.github.io/simplify-js/) to perform simplification.\n *\n * @name simplify\n * @param {GeoJSON} geojson object to be simplified\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.tolerance=1] simplification tolerance\n * @param {boolean} [options.highQuality=false] whether or not to spend more time to create a higher-quality simplification with a different algorithm\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {GeoJSON} a simplified GeoJSON\n * @example\n * var geojson = turf.polygon([[\n *   [-70.603637, -33.399918],\n *   [-70.614624, -33.395332],\n *   [-70.639343, -33.392466],\n *   [-70.659942, -33.394759],\n *   [-70.683975, -33.404504],\n *   [-70.697021, -33.419406],\n *   [-70.701141, -33.434306],\n *   [-70.700454, -33.446339],\n *   [-70.694274, -33.458369],\n *   [-70.682601, -33.465816],\n *   [-70.668869, -33.472117],\n *   [-70.646209, -33.473835],\n *   [-70.624923, -33.472117],\n *   [-70.609817, -33.468107],\n *   [-70.595397, -33.458369],\n *   [-70.587158, -33.442901],\n *   [-70.587158, -33.426283],\n *   [-70.590591, -33.414248],\n *   [-70.594711, -33.406224],\n *   [-70.603637, -33.399918]\n * ]]);\n * var options = {tolerance: 0.01, highQuality: false};\n * var simplified = turf.simplify(geojson, options);\n *\n * //addToMap\n * var addToMap = [geojson, simplified]\n */\nfunction simplify(geojson, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject$2(options)) throw new Error('options is invalid');\n    var tolerance = options.tolerance;\n    var highQuality = options.highQuality;\n    var mutate = options.mutate;\n\n    if (!geojson) throw new Error('geojson is required');\n    if (tolerance && tolerance < 0) throw new Error('invalid tolerance');\n\n    // Clone geojson to avoid side effects\n    if (mutate !== true) geojson = clone(geojson);\n\n    geomEach(geojson, function (geom) {\n        simplifyGeom(geom, tolerance, highQuality);\n    });\n    return geojson;\n}\n\n/**\n * Simplifies a feature's coordinates\n *\n * @private\n * @param {Geometry} geometry to be simplified\n * @param {number} [tolerance=1] simplification tolerance\n * @param {boolean} [highQuality=false] whether or not to spend more time to create a higher-quality simplification with a different algorithm\n * @returns {Geometry} output\n */\nfunction simplifyGeom(geometry$$1, tolerance, highQuality) {\n    var type = geometry$$1.type;\n\n    // \"unsimplyfiable\" geometry types\n    if (type === 'Point' || type === 'MultiPoint') return geometry$$1;\n\n    // Remove any extra coordinates\n    cleanCoords(geometry$$1, true);\n\n    var coordinates = geometry$$1.coordinates;\n    switch (type) {\n        case 'LineString':\n            geometry$$1['coordinates'] = simplifyLine(coordinates, tolerance, highQuality);\n            break;\n        case 'MultiLineString':\n            geometry$$1['coordinates'] = coordinates.map(function (lines) {\n                return simplifyLine(lines, tolerance, highQuality);\n            });\n            break;\n        case 'Polygon':\n            geometry$$1['coordinates'] = simplifyPolygon(coordinates, tolerance, highQuality);\n            break;\n        case 'MultiPolygon':\n            geometry$$1['coordinates'] = coordinates.map(function (rings) {\n                return simplifyPolygon(rings, tolerance, highQuality);\n            });\n    }\n    return geometry$$1;\n}\n\n/**\n * Simplifies the coordinates of a LineString with simplify-js\n *\n * @private\n * @param {Array<number>} coordinates to be processed\n * @param {number} tolerance simplification tolerance\n * @param {boolean} highQuality whether or not to spend more time to create a higher-quality\n * @returns {Array<Array<number>>} simplified coords\n */\nfunction simplifyLine(coordinates, tolerance, highQuality) {\n    return simplify$1(coordinates.map(function (coord) {\n        return {\n            x: coord[0],\n            y: coord[1],\n            z: coord[2]\n        };\n    }), tolerance, highQuality).map(function (coords) {\n        return coords.z ? [coords.x, coords.y, coords.z] : [coords.x, coords.y];\n    });\n}\n\n/**\n * Simplifies the coordinates of a Polygon with simplify-js\n *\n * @private\n * @param {Array<number>} coordinates to be processed\n * @param {number} tolerance simplification tolerance\n * @param {boolean} highQuality whether or not to spend more time to create a higher-quality\n * @returns {Array<Array<Array<number>>>} simplified coords\n */\nfunction simplifyPolygon(coordinates, tolerance, highQuality) {\n    return coordinates.map(function (ring) {\n        var pts = ring.map(function (coord) {\n            return {\n                x: coord[0],\n                y: coord[1]\n            };\n        });\n        if (pts.length < 4) {\n            throw new Error('invalid polygon');\n        }\n        var simpleRing = simplify$1(pts, tolerance, highQuality).map(function (coords) {\n            return [coords.x, coords.y];\n        });\n        //remove 1 percent of tolerance until enough points to make a triangle\n        while (!checkValidity(simpleRing)) {\n            tolerance -= tolerance * 0.01;\n            simpleRing = simplify$1(pts, tolerance, highQuality).map(function (coords) {\n                return [coords.x, coords.y];\n            });\n        }\n        if (simpleRing[simpleRing.length - 1][0] !== simpleRing[0][0] || simpleRing[simpleRing.length - 1][1] !== simpleRing[0][1]) {\n            simpleRing.push(simpleRing[0]);\n        }\n        return simpleRing;\n    });\n}\n\n/**\n * Returns true if ring has at least 3 coordinates and its first coordinate is the same as its last\n *\n * @private\n * @param {Array<number>} ring coordinates to be checked\n * @returns {boolean} true if valid\n */\nfunction checkValidity(ring) {\n    if (ring.length < 3) return false;\n    //if the last point is the same as the first, it's not a triangle\n    return !(ring.length === 3 && ring[2][0] === ring[0][0] && ring[2][1] === ring[0][1]);\n}\n\n/**\n * Simplifies an array of coordinates\n * @param  {Array.<google.maps.LatLng>|Array.<google.maps.LatLngLiteral>} coordArray Array of coordinates\n * @param  {number} tolerance   [description]\n * @param  {boolean} highQuality [description]\n * @return {Array.<Number>}  Array de coordenadas [lng,lat]\n */\nfunction simplifyPointArray(coordArray, tolerance, highQuality) {\n\ttolerance = tolerance || 0.00001;\n\thighQuality = highQuality || false;\n\tvar Feature = lineString(toCoords(coordArray));\n\n\tvar simplifiedgeom = simplify(Feature, tolerance, highQuality);\n\n\t//debug('simplifyPointArray', 'geometry is', Feature.geometry, 'simplifiedgeom is', simplifiedgeom);\n\n\treturn simplifiedgeom.geometry.coordinates;\n}\n\n/**\n * Simplified a Feature, google.maps.Polygon or google.maps.Polyline\n * @param  {google.maps.Polygon|google.maps.Polyline|Array.<google.maps.LatLng>|Feature.<Polygon>|Feature.<LineString>} object feature to be simplified\n * @param  {string} output either 'feature', 'geometry' or 'object' (google maps). Case insensitive. Defaults to feature\n * @param  {mumber} tolerance   simplification tolerance\n * @param  {boolean} highQuality [description]\n * @return {Feature|Geometry} whether or not to spend more time to create a higher-quality simplification with a different algorithm\n */\nfunction simplifyFeature(object, output, tolerance, highQuality) {\n\n\toutput = (output || 'feature').toLowerCase();\n\n\tvar Feature;\n\tif (object instanceof google.maps.Polyline || object instanceof google.maps.Polygon) {\n\t\tvar geometry$$1 = Wicket$1().fromObject(object).toJson();\n\t\tFeature = {\n\t\t\ttype: \"Feature\",\n\t\t\tproperties: {},\n\t\t\tgeometry: geometry$$1\n\t\t};\n\t} else if (object.type && object.type === 'Feature' && object.geometry) {\n\t\tFeature = object;\n\t} else {\n\t\tFeature = polygonToFeaturePolygon(object);\n\t}\n\n\tif (Feature.geometry.type === 'MultiPolygon') {\n\t\tFeature.geometry.type = 'Polygon';\n\t\tFeature.geometry.coordinates = Feature.geometry.coordinates[0];\n\t}\n\tvar simplifiedgeom = simplify(Feature, tolerance, highQuality);\n\n\tif (simplifiedgeom && simplifiedgeom.geometry) {\n\t\t//debug('Simplified Feature', Feature, 'simplifiedgeom', simplifiedgeom);\n\t\tFeature = simplifiedgeom;\n\t} else {\n\t\twarn('Cannot simplify  Feature', Feature);\n\t}\n\tif (output === 'geometry') {\n\t\treturn Feature.geometry;\n\t} else if (output === 'object') {\n\t\treturn Wicket$1().fromJson(Feature.geometry).toObject();\n\t} else {\n\t\treturn Feature;\n\t}\n}\n\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n\n/**\n * Takes two {@link Point|points} and finds the geographic bearing between them,\n * i.e. the angle measured in degrees from the north line (0 degrees)\n *\n * @name bearing\n * @param {Geometry|Feature<Point>|Array<number>} start starting Point\n * @param {Geometry|Feature<Point>|Array<number>} end ending Point\n * @param {Object} [options] Optional parameters\n * @param {boolean} [options.final=false] calculates the final bearing if true\n * @returns {number} bearing in decimal degrees, between -180 and 180 degrees (positive clockwise)\n * @example\n * var point1 = turf.point([-75.343, 39.984]);\n * var point2 = turf.point([-75.534, 39.123]);\n *\n * var bearing = turf.bearing(point1, point2);\n *\n * //addToMap\n * var addToMap = [point1, point2]\n * point1.properties['marker-color'] = '#f00'\n * point2.properties['marker-color'] = '#0f0'\n * point1.properties.bearing = bearing\n */\nfunction bearing(start, end, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject$2(options)) throw new Error('options is invalid');\n    var final = options.final;\n\n    // Reverse calculation\n    if (final === true) return calculateFinalBearing(start, end);\n\n    var coordinates1 = getCoord(start);\n    var coordinates2 = getCoord(end);\n\n    var lon1 = degreesToRadians(coordinates1[0]);\n    var lon2 = degreesToRadians(coordinates2[0]);\n    var lat1 = degreesToRadians(coordinates1[1]);\n    var lat2 = degreesToRadians(coordinates2[1]);\n    var a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n    var b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n\n    return radiansToDegrees(Math.atan2(a, b));\n}\n\n/**\n * Calculates Final Bearing\n * @private\n * @param {Feature<Point>} start starting Point\n * @param {Feature<Point>} end ending Point\n * @returns {number} bearing\n */\nfunction calculateFinalBearing(start, end) {\n    // Swap start & end\n    var bear = bearing(end, start);\n    bear = (bear + 180) % 360;\n    return bear;\n}\n\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Takes a {@link Point} and calculates the location of a destination point given a distance in degrees, radians, miles, or kilometers; and bearing in degrees. This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name destination\n * @param {Geometry|Feature<Point>|Array<number>} origin starting point\n * @param {number} distance distance from the origin point\n * @param {number} bearing ranging from -180 to 180\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\n * @returns {Feature<Point>} destination point\n * @example\n * var point = turf.point([-75.343, 39.984]);\n * var distance = 50;\n * var bearing = 90;\n * var options = {units: 'miles'};\n *\n * var destination = turf.destination(point, distance, bearing, options);\n *\n * //addToMap\n * var addToMap = [point, destination]\n * destination.properties['marker-color'] = '#f00';\n * point.properties['marker-color'] = '#0f0';\n */\nfunction destination(origin, distance, bearing, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject$2(options)) throw new Error('options is invalid');\n    var units = options.units;\n\n    // Handle input\n    var coordinates1 = getCoord(origin);\n    var longitude1 = degreesToRadians(coordinates1[0]);\n    var latitude1 = degreesToRadians(coordinates1[1]);\n    var bearing_rad = degreesToRadians(bearing);\n    var radians = lengthToRadians(distance, units);\n\n    // Main\n    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) + Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearing_rad));\n    var longitude2 = longitude1 + Math.atan2(Math.sin(bearing_rad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));\n\n    return point([radiansToDegrees(longitude2), radiansToDegrees(latitude2)]);\n}\n\n/**\n * Takes a {@link LineString|line} and returns a {@link Point|point} at a specified distance along the line.\n *\n * @name along\n * @param {Feature<LineString>} line input line\n * @param {number} distance distance along the line\n * @param {Object} [options] Optional parameters\n * @param {string} [options.units=\"kilometers\"] can be degrees, radians, miles, or kilometers\n * @returns {Feature<Point>} Point `distance` `units` along the line\n * @example\n * var line = turf.lineString([[-83, 30], [-84, 36], [-78, 41]]);\n * var options = {units: 'miles'};\n *\n * var along = turf.along(line, 200, options);\n *\n * //addToMap\n * var addToMap = [along, line]\n */\nfunction along$1(line, distance$$1, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject$2(options)) throw new Error('options is invalid');\n\n    // Validation\n    var coords;\n    if (line.type === 'Feature') coords = line.geometry.coordinates;else if (line.type === 'LineString') coords = line.coordinates;else throw new Error('input must be a LineString Feature or Geometry');\n    if (!isNumber(distance$$1)) throw new Error('distance must be a number');\n\n    var travelled = 0;\n    for (var i = 0; i < coords.length; i++) {\n        if (distance$$1 >= travelled && i === coords.length - 1) break;else if (travelled >= distance$$1) {\n            var overshot = distance$$1 - travelled;\n            if (!overshot) return point(coords[i]);else {\n                var direction = bearing(coords[i], coords[i - 1]) - 180;\n                var interpolated = destination(coords[i], overshot, direction, options);\n                return interpolated;\n            }\n        } else {\n            travelled += distance(coords[i], coords[i + 1], options);\n        }\n    }\n    return point(coords[coords.length - 1]);\n}\n\n/**\n * Takes a linestring and returns a {@link Point|point} at a specified distance along the line.\n * @param  {google.maps.Polyline|Array.<google.maps.LatLng>|Array.<google.maps.LatLngLiteral>|Feature<LineString>} object input object\n * @param  {Number} distance    [description]\n * @param  {string} units can be degrees, radians, miles, or kilometers. Defaults to kilometers\n * @return {Feature.<Point>} Point distance units along the line\n */\nfunction along(object, distance, units) {\n\tvar Feature;\n\n\tif (object instanceof google.maps.Polyline) {\n\t\tvar geometry$$1 = Wicket$1().fromObject(object).toJson();\n\t\tFeature = {\n\t\t\ttype: \"Feature\",\n\t\t\tproperties: {},\n\t\t\tgeometry: geometry$$1\n\t\t};\n\t} else if (object.type && object.type === 'Feature' && object.geometry) {\n\t\tFeature = object;\n\t} else {\n\t\tvar arrayCoords = toCoords(object);\n\t\tFeature = lineString(arrayCoords);\n\t}\n\n\treturn along$1(Feature, distance, units);\n}\n\nvar extend = function (target, source) {\n  for (var key in source) {\n    if (source.hasOwnProperty(key)) target[key] = source[key];\n  }\n};\n\nfunction NumberUtil() {}\nextend(NumberUtil.prototype, {\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn NumberUtil;\n\t}\n});\nNumberUtil.equalsWithTolerance = function (x1, x2, tolerance) {\n\treturn Math.abs(x1 - x2) <= tolerance;\n};\n\nfunction IllegalArgumentException() {}\n\nfunction Double() {}\nDouble.isNaN = function (n) {\n  return Number.isNaN(n);\n};\nDouble.doubleToLongBits = function (n) {\n  return n;\n};\nDouble.longBitsToDouble = function (n) {\n  return n;\n};\nDouble.isInfinite = function (n) {\n  return !Number.isFinite(n);\n};\nDouble.MAX_VALUE = Number.MAX_VALUE;\n\nfunction Comparable() {}\n\nfunction Clonable() {}\n\nfunction Comparator() {}\n\nfunction Serializable() {}\n\nfunction RuntimeException(message) {\n  this.name = 'RuntimeException';\n  this.message = message;\n  this.stack = new Error().stack;\n  Error.call(this, message);\n}\n\nRuntimeException.prototype = Object.create(Error.prototype);\nRuntimeException.prototype.constructor = Error;\n\nvar inherits$1 = function (c, p) {\n  c.prototype = Object.create(p.prototype);\n  c.prototype.constructor = c;\n};\n\nfunction AssertionFailedException() {\n\tif (arguments.length === 0) {\n\t\tRuntimeException.call(this);\n\t} else if (arguments.length === 1) {\n\t\tvar message = arguments[0];\n\t\tRuntimeException.call(this, message);\n\t}\n}\ninherits$1(AssertionFailedException, RuntimeException);\nextend(AssertionFailedException.prototype, {\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn AssertionFailedException;\n\t}\n});\n\nfunction Assert() {}\nextend(Assert.prototype, {\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Assert;\n\t}\n});\nAssert.shouldNeverReachHere = function () {\n\tif (arguments.length === 0) {\n\t\tAssert.shouldNeverReachHere(null);\n\t} else if (arguments.length === 1) {\n\t\tvar message = arguments[0];\n\t\tthrow new AssertionFailedException(\"Should never reach here\" + (message !== null ? \": \" + message : \"\"));\n\t}\n};\nAssert.isTrue = function () {\n\tif (arguments.length === 1) {\n\t\tvar assertion = arguments[0];\n\t\tAssert.isTrue(assertion, null);\n\t} else if (arguments.length === 2) {\n\t\tvar assertion = arguments[0],\n\t\t    message = arguments[1];\n\t\tif (!assertion) {\n\t\t\tif (message === null) {\n\t\t\t\tthrow new AssertionFailedException();\n\t\t\t} else {\n\t\t\t\tthrow new AssertionFailedException(message);\n\t\t\t}\n\t\t}\n\t}\n};\nAssert.equals = function () {\n\tif (arguments.length === 2) {\n\t\tvar expectedValue = arguments[0],\n\t\t    actualValue = arguments[1];\n\t\tAssert.equals(expectedValue, actualValue, null);\n\t} else if (arguments.length === 3) {\n\t\tvar expectedValue = arguments[0],\n\t\t    actualValue = arguments[1],\n\t\t    message = arguments[2];\n\t\tif (!actualValue.equals(expectedValue)) {\n\t\t\tthrow new AssertionFailedException(\"Expected \" + expectedValue + \" but encountered \" + actualValue + (message !== null ? \": \" + message : \"\"));\n\t\t}\n\t}\n};\n\nfunction Coordinate() {\n\tthis.x = null;\n\tthis.y = null;\n\tthis.z = null;\n\tif (arguments.length === 0) {\n\t\tCoordinate.call(this, 0.0, 0.0);\n\t} else if (arguments.length === 1) {\n\t\tvar c = arguments[0];\n\t\tCoordinate.call(this, c.x, c.y, c.z);\n\t} else if (arguments.length === 2) {\n\t\tvar x = arguments[0],\n\t\t    y = arguments[1];\n\t\tCoordinate.call(this, x, y, Coordinate.NULL_ORDINATE);\n\t} else if (arguments.length === 3) {\n\t\tvar x = arguments[0],\n\t\t    y = arguments[1],\n\t\t    z = arguments[2];\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t}\n}\nextend(Coordinate.prototype, {\n\tsetOrdinate: function setOrdinate(ordinateIndex, value) {\n\t\tswitch (ordinateIndex) {\n\t\t\tcase Coordinate.X:\n\t\t\t\tthis.x = value;\n\t\t\t\tbreak;\n\t\t\tcase Coordinate.Y:\n\t\t\t\tthis.y = value;\n\t\t\t\tbreak;\n\t\t\tcase Coordinate.Z:\n\t\t\t\tthis.z = value;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid ordinate index: \" + ordinateIndex);\n\t\t}\n\t},\n\tequals2D: function equals2D() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar other = arguments[0];\n\t\t\tif (this.x !== other.x) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (this.y !== other.y) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar c = arguments[0],\n\t\t\t    tolerance = arguments[1];\n\t\t\tif (!NumberUtil.equalsWithTolerance(this.x, c.x, tolerance)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!NumberUtil.equalsWithTolerance(this.y, c.y, tolerance)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t},\n\tgetOrdinate: function getOrdinate(ordinateIndex) {\n\t\tswitch (ordinateIndex) {\n\t\t\tcase Coordinate.X:\n\t\t\t\treturn this.x;\n\t\t\tcase Coordinate.Y:\n\t\t\t\treturn this.y;\n\t\t\tcase Coordinate.Z:\n\t\t\t\treturn this.z;\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Invalid ordinate index: \" + ordinateIndex);\n\t},\n\tequals3D: function equals3D(other) {\n\t\treturn this.x === other.x && this.y === other.y && (this.z === other.z || Double.isNaN(this.z) && Double.isNaN(other.z));\n\t},\n\tequals: function equals(other) {\n\t\tif (!(other instanceof Coordinate)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.equals2D(other);\n\t},\n\tequalInZ: function equalInZ(c, tolerance) {\n\t\treturn NumberUtil.equalsWithTolerance(this.z, c.z, tolerance);\n\t},\n\tcompareTo: function compareTo(o) {\n\t\tvar other = o;\n\t\tif (this.x < other.x) return -1;\n\t\tif (this.x > other.x) return 1;\n\t\tif (this.y < other.y) return -1;\n\t\tif (this.y > other.y) return 1;\n\t\treturn 0;\n\t},\n\tclone: function clone() {\n\t\ttry {\n\t\t\tvar coord = null;\n\t\t\treturn coord;\n\t\t} catch (e) {\n\t\t\tif (e instanceof CloneNotSupportedException) {\n\t\t\t\tAssert.shouldNeverReachHere(\"this shouldn't happen because this class is Cloneable\");\n\t\t\t\treturn null;\n\t\t\t} else throw e;\n\t\t} finally {}\n\t},\n\tcopy: function copy() {\n\t\treturn new Coordinate(this);\n\t},\n\ttoString: function toString() {\n\t\treturn \"(\" + this.x + \", \" + this.y + \", \" + this.z + \")\";\n\t},\n\tdistance3D: function distance3D(c) {\n\t\tvar dx = this.x - c.x;\n\t\tvar dy = this.y - c.y;\n\t\tvar dz = this.z - c.z;\n\t\treturn Math.sqrt(dx * dx + dy * dy + dz * dz);\n\t},\n\tdistance: function distance(c) {\n\t\tvar dx = this.x - c.x;\n\t\tvar dy = this.y - c.y;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t},\n\thashCode: function hashCode() {\n\t\tvar result = 17;\n\t\tresult = 37 * result + Coordinate.hashCode(this.x);\n\t\tresult = 37 * result + Coordinate.hashCode(this.y);\n\t\treturn result;\n\t},\n\tsetCoordinate: function setCoordinate(other) {\n\t\tthis.x = other.x;\n\t\tthis.y = other.y;\n\t\tthis.z = other.z;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Comparable, Clonable, Serializable];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Coordinate;\n\t}\n});\nCoordinate.hashCode = function () {\n\tif (arguments.length === 1) {\n\t\tvar x = arguments[0];\n\t\tvar f = Double.doubleToLongBits(x);\n\t\treturn Math.trunc(f ^ f >>> 32);\n\t}\n};\nfunction DimensionalComparator() {\n\tthis._dimensionsToTest = 2;\n\tif (arguments.length === 0) {\n\t\tDimensionalComparator.call(this, 2);\n\t} else if (arguments.length === 1) {\n\t\tvar dimensionsToTest = arguments[0];\n\t\tif (dimensionsToTest !== 2 && dimensionsToTest !== 3) throw new IllegalArgumentException(\"only 2 or 3 dimensions may be specified\");\n\t\tthis._dimensionsToTest = dimensionsToTest;\n\t}\n}\nextend(DimensionalComparator.prototype, {\n\tcompare: function compare(o1, o2) {\n\t\tvar c1 = o1;\n\t\tvar c2 = o2;\n\t\tvar compX = DimensionalComparator.compare(c1.x, c2.x);\n\t\tif (compX !== 0) return compX;\n\t\tvar compY = DimensionalComparator.compare(c1.y, c2.y);\n\t\tif (compY !== 0) return compY;\n\t\tif (this._dimensionsToTest <= 2) return 0;\n\t\tvar compZ = DimensionalComparator.compare(c1.z, c2.z);\n\t\treturn compZ;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Comparator];\n\t},\n\tgetClass: function getClass() {\n\t\treturn DimensionalComparator;\n\t}\n});\nDimensionalComparator.compare = function (a, b) {\n\tif (a < b) return -1;\n\tif (a > b) return 1;\n\tif (Double.isNaN(a)) {\n\t\tif (Double.isNaN(b)) return 0;\n\t\treturn -1;\n\t}\n\tif (Double.isNaN(b)) return 1;\n\treturn 0;\n};\nCoordinate.DimensionalComparator = DimensionalComparator;\nCoordinate.serialVersionUID = 6683108902428366910;\nCoordinate.NULL_ORDINATE = Double.NaN;\nCoordinate.X = 0;\nCoordinate.Y = 1;\nCoordinate.Z = 2;\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Iterator.html\n * @constructor\n * @private\n */\nfunction Iterator() {}\n\n/**\n * Returns true if the iteration has more elements.\n * @return {boolean}\n */\nIterator.prototype.hasNext = function () {};\n\n/**\n * Returns the next element in the iteration.\n * @return {Object}\n */\nIterator.prototype.next = function () {};\n\n/**\n * Removes from the underlying collection the last element returned by the\n * iterator (optional operation).\n */\nIterator.prototype.remove = function () {};\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Collection.html\n *\n * @constructor\n * @private\n */\nfunction Collection() {}\n\n/**\n * Ensures that this collection contains the specified element (optional\n * operation).\n * @param {Object} e\n * @return {boolean}\n */\nCollection.prototype.add = function () {};\n\n/**\n * Appends all of the elements in the specified collection to the end of this\n * list, in the order that they are returned by the specified collection's\n * iterator (optional operation).\n * @param {javascript.util.Collection} c\n * @return {boolean}\n */\nCollection.prototype.addAll = function () {};\n\n/**\n * Returns true if this collection contains no elements.\n * @return {boolean}\n */\nCollection.prototype.isEmpty = function () {};\n\n/**\n * Returns an iterator over the elements in this collection.\n * @return {javascript.util.Iterator}\n */\nCollection.prototype.iterator = function () {};\n\n/**\n * Returns an iterator over the elements in this collection.\n * @return {number}\n */\nCollection.prototype.size = function () {};\n\n/**\n * Returns an array containing all of the elements in this collection.\n * @return {Array}\n */\nCollection.prototype.toArray = function () {};\n\n/**\n * Removes a single instance of the specified element from this collection if it\n * is present. (optional)\n * @param {Object} e\n * @return {boolean}\n */\nCollection.prototype.remove = function () {};\n\n/**\n * @param {string=} message Optional message\n * @extends {Error}\n * @constructor\n * @private\n */\nfunction IndexOutOfBoundsException$1(message) {\n  this.message = message || '';\n}\nIndexOutOfBoundsException$1.prototype = new Error();\n\n/**\n * @type {string}\n */\nIndexOutOfBoundsException$1.prototype.name = 'IndexOutOfBoundsException';\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/List.html\n *\n * @extends {javascript.util.Collection}\n * @constructor\n * @private\n */\nfunction List() {}\nList.prototype = Object.create(Collection.prototype);\nList.prototype.constructor = List;\n\n/**\n * Returns the element at the specified position in this list.\n * @param {number} index\n * @return {Object}\n */\nList.prototype.get = function () {};\n\n/**\n * Replaces the element at the specified position in this list with the\n * specified element (optional operation).\n * @param {number} index\n * @param {Object} e\n * @return {Object}\n */\nList.prototype.set = function () {};\n\n/**\n * Returns true if this collection contains no elements.\n * @return {boolean}\n */\nList.prototype.isEmpty = function () {};\n\n/**\n * @param {string=} message Optional message\n * @extends {Error}\n * @constructor\n * @private\n */\nfunction NoSuchElementException(message) {\n  this.message = message || '';\n}\nNoSuchElementException.prototype = new Error();\n\n/**\n * @type {string}\n */\nNoSuchElementException.prototype.name = 'NoSuchElementException';\n\n/**\n * @param {string=} message Optional message\n * @extends {Error}\n * @constructor\n * @private\n */\nfunction OperationNotSupported(message) {\n  this.message = message || '';\n}\nOperationNotSupported.prototype = new Error();\n\n/**\n * @type {string}\n */\nOperationNotSupported.prototype.name = 'OperationNotSupported';\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/ArrayList.html\n *\n * @extends List\n * @private\n */\nfunction ArrayList() {\n  /**\n   * @type {Array}\n   * @private\n  */\n  this.array_ = [];\n\n  if (arguments[0] instanceof Collection) {\n    this.addAll(arguments[0]);\n  }\n}\nArrayList.prototype = Object.create(List.prototype);\nArrayList.prototype.constructor = ArrayList;\n\nArrayList.prototype.ensureCapacity = function () {};\nArrayList.prototype.interfaces_ = function () {\n  return [List, Collection];\n};\n\n/**\n * @override\n */\nArrayList.prototype.add = function (e) {\n  if (arguments.length === 1) {\n    this.array_.push(e);\n  } else {\n    this.array_.splice(arguments[0], arguments[1]);\n  }\n  return true;\n};\n\nArrayList.prototype.clear = function () {\n  this.array_ = [];\n};\n\n/**\n * @override\n */\nArrayList.prototype.addAll = function (c) {\n  for (var i = c.iterator(); i.hasNext();) {\n    this.add(i.next());\n  }\n  return true;\n};\n\n/**\n * @override\n */\nArrayList.prototype.set = function (index, element) {\n  var oldElement = this.array_[index];\n  this.array_[index] = element;\n  return oldElement;\n};\n\n/**\n * @override\n */\nArrayList.prototype.iterator = function () {\n  return new Iterator_(this);\n};\n\n/**\n * @override\n */\nArrayList.prototype.get = function (index) {\n  if (index < 0 || index >= this.size()) {\n    throw new IndexOutOfBoundsException$1();\n  }\n\n  return this.array_[index];\n};\n\n/**\n * @override\n */\nArrayList.prototype.isEmpty = function () {\n  return this.array_.length === 0;\n};\n\n/**\n * @override\n */\nArrayList.prototype.size = function () {\n  return this.array_.length;\n};\n\n/**\n * @override\n */\nArrayList.prototype.toArray = function () {\n  var array = [];\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    array.push(this.array_[i]);\n  }\n\n  return array;\n};\n\n/**\n * @override\n */\nArrayList.prototype.remove = function (o) {\n  var found = false;\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    if (this.array_[i] === o) {\n      this.array_.splice(i, 1);\n      found = true;\n      break;\n    }\n  }\n\n  return found;\n};\n\n/**\n * @extends {Iterator}\n * @param {ArrayList} arrayList\n * @constructor\n * @private\n */\nvar Iterator_ = function Iterator_(arrayList) {\n  /**\n   * @type {ArrayList}\n   * @private\n  */\n  this.arrayList_ = arrayList;\n  /**\n   * @type {number}\n   * @private\n  */\n  this.position_ = 0;\n};\n\n/**\n * @override\n */\nIterator_.prototype.next = function () {\n  if (this.position_ === this.arrayList_.size()) {\n    throw new NoSuchElementException();\n  }\n  return this.arrayList_.get(this.position_++);\n};\n\n/**\n * @override\n */\nIterator_.prototype.hasNext = function () {\n  if (this.position_ < this.arrayList_.size()) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\n/**\n * TODO: should be in ListIterator\n * @override\n */\nIterator_.prototype.set = function (element) {\n  return this.arrayList_.set(this.position_ - 1, element);\n};\n\n/**\n * @override\n */\nIterator_.prototype.remove = function () {\n  this.arrayList_.remove(this.arrayList_.get(this.position_));\n};\n\nfunction CoordinateList() {\n\tArrayList.apply(this);\n\tif (arguments.length === 0) {} else if (arguments.length === 1) {\n\t\tvar coord = arguments[0];\n\t\tthis.ensureCapacity(coord.length);\n\t\tthis.add(coord, true);\n\t} else if (arguments.length === 2) {\n\t\tvar coord = arguments[0],\n\t\t    allowRepeated = arguments[1];\n\t\tthis.ensureCapacity(coord.length);\n\t\tthis.add(coord, allowRepeated);\n\t}\n}\ninherits$1(CoordinateList, ArrayList);\nextend(CoordinateList.prototype, {\n\tgetCoordinate: function getCoordinate(i) {\n\t\treturn this.get(i);\n\t},\n\taddAll: function addAll() {\n\t\tif (arguments.length === 2) {\n\t\t\tvar coll = arguments[0],\n\t\t\t    allowRepeated = arguments[1];\n\t\t\tvar isChanged = false;\n\t\t\tfor (var i = coll.iterator(); i.hasNext();) {\n\t\t\t\tthis.add(i.next(), allowRepeated);\n\t\t\t\tisChanged = true;\n\t\t\t}\n\t\t\treturn isChanged;\n\t\t} else return ArrayList.prototype.addAll.apply(this, arguments);\n\t},\n\tclone: function clone() {\n\t\tvar clone = ArrayList.prototype.clone.call(this);\n\t\tfor (var i = 0; i < this.size(); i++) {\n\t\t\tclone.add(i, this.get(i).copy());\n\t\t}\n\t\treturn clone;\n\t},\n\ttoCoordinateArray: function toCoordinateArray() {\n\t\treturn this.toArray(CoordinateList.coordArrayType);\n\t},\n\tadd: function add() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar coord = arguments[0];\n\t\t\tArrayList.prototype.add.call(this, coord);\n\t\t} else if (arguments.length === 2) {\n\t\t\tif (arguments[0] instanceof Array && typeof arguments[1] === \"boolean\") {\n\t\t\t\tvar coord = arguments[0],\n\t\t\t\t    allowRepeated = arguments[1];\n\t\t\t\tthis.add(coord, allowRepeated, true);\n\t\t\t\treturn true;\n\t\t\t} else if (arguments[0] instanceof Coordinate && typeof arguments[1] === \"boolean\") {\n\t\t\t\tvar coord = arguments[0],\n\t\t\t\t    allowRepeated = arguments[1];\n\t\t\t\tif (!allowRepeated) {\n\t\t\t\t\tif (this.size() >= 1) {\n\t\t\t\t\t\tvar last = this.get(this.size() - 1);\n\t\t\t\t\t\tif (last.equals2D(coord)) return null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tArrayList.prototype.add.call(this, coord);\n\t\t\t} else if (arguments[0] instanceof Object && typeof arguments[1] === \"boolean\") {\n\t\t\t\tvar obj = arguments[0],\n\t\t\t\t    allowRepeated = arguments[1];\n\t\t\t\tthis.add(obj, allowRepeated);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tif (typeof arguments[2] === \"boolean\" && arguments[0] instanceof Array && typeof arguments[1] === \"boolean\") {\n\t\t\t\tvar coord = arguments[0],\n\t\t\t\t    allowRepeated = arguments[1],\n\t\t\t\t    direction = arguments[2];\n\t\t\t\tif (direction) {\n\t\t\t\t\tfor (var i = 0; i < coord.length; i++) {\n\t\t\t\t\t\tthis.add(coord[i], allowRepeated);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (var i = coord.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tthis.add(coord[i], allowRepeated);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else if (typeof arguments[2] === \"boolean\" && Number.isInteger(arguments[0]) && arguments[1] instanceof Coordinate) {\n\t\t\t\tvar i = arguments[0],\n\t\t\t\t    coord = arguments[1],\n\t\t\t\t    allowRepeated = arguments[2];\n\t\t\t\tif (!allowRepeated) {\n\t\t\t\t\tvar size = this.size();\n\t\t\t\t\tif (size > 0) {\n\t\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\t\tvar prev = this.get(i - 1);\n\t\t\t\t\t\t\tif (prev.equals2D(coord)) return null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (i < size) {\n\t\t\t\t\t\t\tvar next = this.get(i);\n\t\t\t\t\t\t\tif (next.equals2D(coord)) return null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tArrayList.prototype.add.call(this, i, coord);\n\t\t\t}\n\t\t} else if (arguments.length === 4) {\n\t\t\tvar coord = arguments[0],\n\t\t\t    allowRepeated = arguments[1],\n\t\t\t    start = arguments[2],\n\t\t\t    end = arguments[3];\n\t\t\tvar inc = 1;\n\t\t\tif (start > end) inc = -1;\n\t\t\tfor (var i = start; i !== end; i += inc) {\n\t\t\t\tthis.add(coord[i], allowRepeated);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t},\n\tcloseRing: function closeRing() {\n\t\tif (this.size() > 0) this.add(new Coordinate(this.get(0)), false);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn CoordinateList;\n\t}\n});\nCoordinateList.coordArrayType = new Array(0).fill(null);\n\nfunction Envelope() {\n\tthis._minx = null;\n\tthis._maxx = null;\n\tthis._miny = null;\n\tthis._maxy = null;\n\tif (arguments.length === 0) {\n\t\tthis.init();\n\t} else if (arguments.length === 1) {\n\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\tvar p = arguments[0];\n\t\t\tthis.init(p.x, p.x, p.y, p.y);\n\t\t} else if (arguments[0] instanceof Envelope) {\n\t\t\tvar env = arguments[0];\n\t\t\tthis.init(env);\n\t\t}\n\t} else if (arguments.length === 2) {\n\t\tvar p1 = arguments[0],\n\t\t    p2 = arguments[1];\n\t\tthis.init(p1.x, p2.x, p1.y, p2.y);\n\t} else if (arguments.length === 4) {\n\t\tvar x1 = arguments[0],\n\t\t    x2 = arguments[1],\n\t\t    y1 = arguments[2],\n\t\t    y2 = arguments[3];\n\t\tthis.init(x1, x2, y1, y2);\n\t}\n}\nextend(Envelope.prototype, {\n\tgetArea: function getArea() {\n\t\treturn this.getWidth() * this.getHeight();\n\t},\n\tequals: function equals(other) {\n\t\tif (!(other instanceof Envelope)) {\n\t\t\treturn false;\n\t\t}\n\t\tvar otherEnvelope = other;\n\t\tif (this.isNull()) {\n\t\t\treturn otherEnvelope.isNull();\n\t\t}\n\t\treturn this._maxx === otherEnvelope.getMaxX() && this._maxy === otherEnvelope.getMaxY() && this._minx === otherEnvelope.getMinX() && this._miny === otherEnvelope.getMinY();\n\t},\n\tintersection: function intersection(env) {\n\t\tif (this.isNull() || env.isNull() || !this.intersects(env)) return new Envelope();\n\t\tvar intMinX = this._minx > env._minx ? this._minx : env._minx;\n\t\tvar intMinY = this._miny > env._miny ? this._miny : env._miny;\n\t\tvar intMaxX = this._maxx < env._maxx ? this._maxx : env._maxx;\n\t\tvar intMaxY = this._maxy < env._maxy ? this._maxy : env._maxy;\n\t\treturn new Envelope(intMinX, intMaxX, intMinY, intMaxY);\n\t},\n\tisNull: function isNull() {\n\t\treturn this._maxx < this._minx;\n\t},\n\tgetMaxX: function getMaxX() {\n\t\treturn this._maxx;\n\t},\n\tcovers: function covers() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\t\tvar p = arguments[0];\n\t\t\t\treturn this.covers(p.x, p.y);\n\t\t\t} else if (arguments[0] instanceof Envelope) {\n\t\t\t\tvar other = arguments[0];\n\t\t\t\tif (this.isNull() || other.isNull()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn other.getMinX() >= this._minx && other.getMaxX() <= this._maxx && other.getMinY() >= this._miny && other.getMaxY() <= this._maxy;\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar x = arguments[0],\n\t\t\t    y = arguments[1];\n\t\t\tif (this.isNull()) return false;\n\t\t\treturn x >= this._minx && x <= this._maxx && y >= this._miny && y <= this._maxy;\n\t\t}\n\t},\n\tintersects: function intersects() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Envelope) {\n\t\t\t\tvar other = arguments[0];\n\t\t\t\tif (this.isNull() || other.isNull()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn !(other._minx > this._maxx || other._maxx < this._minx || other._miny > this._maxy || other._maxy < this._miny);\n\t\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\t\tvar p = arguments[0];\n\t\t\t\treturn this.intersects(p.x, p.y);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar x = arguments[0],\n\t\t\t    y = arguments[1];\n\t\t\tif (this.isNull()) return false;\n\t\t\treturn !(x > this._maxx || x < this._minx || y > this._maxy || y < this._miny);\n\t\t}\n\t},\n\tgetMinY: function getMinY() {\n\t\treturn this._miny;\n\t},\n\tgetMinX: function getMinX() {\n\t\treturn this._minx;\n\t},\n\texpandToInclude: function expandToInclude() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\t\tvar p = arguments[0];\n\t\t\t\tthis.expandToInclude(p.x, p.y);\n\t\t\t} else if (arguments[0] instanceof Envelope) {\n\t\t\t\tvar other = arguments[0];\n\t\t\t\tif (other.isNull()) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (this.isNull()) {\n\t\t\t\t\tthis._minx = other.getMinX();\n\t\t\t\t\tthis._maxx = other.getMaxX();\n\t\t\t\t\tthis._miny = other.getMinY();\n\t\t\t\t\tthis._maxy = other.getMaxY();\n\t\t\t\t} else {\n\t\t\t\t\tif (other._minx < this._minx) {\n\t\t\t\t\t\tthis._minx = other._minx;\n\t\t\t\t\t}\n\t\t\t\t\tif (other._maxx > this._maxx) {\n\t\t\t\t\t\tthis._maxx = other._maxx;\n\t\t\t\t\t}\n\t\t\t\t\tif (other._miny < this._miny) {\n\t\t\t\t\t\tthis._miny = other._miny;\n\t\t\t\t\t}\n\t\t\t\t\tif (other._maxy > this._maxy) {\n\t\t\t\t\t\tthis._maxy = other._maxy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar x = arguments[0],\n\t\t\t    y = arguments[1];\n\t\t\tif (this.isNull()) {\n\t\t\t\tthis._minx = x;\n\t\t\t\tthis._maxx = x;\n\t\t\t\tthis._miny = y;\n\t\t\t\tthis._maxy = y;\n\t\t\t} else {\n\t\t\t\tif (x < this._minx) {\n\t\t\t\t\tthis._minx = x;\n\t\t\t\t}\n\t\t\t\tif (x > this._maxx) {\n\t\t\t\t\tthis._maxx = x;\n\t\t\t\t}\n\t\t\t\tif (y < this._miny) {\n\t\t\t\t\tthis._miny = y;\n\t\t\t\t}\n\t\t\t\tif (y > this._maxy) {\n\t\t\t\t\tthis._maxy = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tminExtent: function minExtent() {\n\t\tif (this.isNull()) return 0.0;\n\t\tvar w = this.getWidth();\n\t\tvar h = this.getHeight();\n\t\tif (w < h) return w;\n\t\treturn h;\n\t},\n\tgetWidth: function getWidth() {\n\t\tif (this.isNull()) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this._maxx - this._minx;\n\t},\n\tcompareTo: function compareTo(o) {\n\t\tvar env = o;\n\t\tif (this.isNull()) {\n\t\t\tif (env.isNull()) return 0;\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tif (env.isNull()) return 1;\n\t\t}\n\t\tif (this._minx < env._minx) return -1;\n\t\tif (this._minx > env._minx) return 1;\n\t\tif (this._miny < env._miny) return -1;\n\t\tif (this._miny > env._miny) return 1;\n\t\tif (this._maxx < env._maxx) return -1;\n\t\tif (this._maxx > env._maxx) return 1;\n\t\tif (this._maxy < env._maxy) return -1;\n\t\tif (this._maxy > env._maxy) return 1;\n\t\treturn 0;\n\t},\n\ttranslate: function translate(transX, transY) {\n\t\tif (this.isNull()) {\n\t\t\treturn null;\n\t\t}\n\t\tthis.init(this.getMinX() + transX, this.getMaxX() + transX, this.getMinY() + transY, this.getMaxY() + transY);\n\t},\n\ttoString: function toString() {\n\t\treturn \"Env[\" + this._minx + \" : \" + this._maxx + \", \" + this._miny + \" : \" + this._maxy + \"]\";\n\t},\n\tsetToNull: function setToNull() {\n\t\tthis._minx = 0;\n\t\tthis._maxx = -1;\n\t\tthis._miny = 0;\n\t\tthis._maxy = -1;\n\t},\n\tgetHeight: function getHeight() {\n\t\tif (this.isNull()) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this._maxy - this._miny;\n\t},\n\tmaxExtent: function maxExtent() {\n\t\tif (this.isNull()) return 0.0;\n\t\tvar w = this.getWidth();\n\t\tvar h = this.getHeight();\n\t\tif (w > h) return w;\n\t\treturn h;\n\t},\n\texpandBy: function expandBy() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar distance = arguments[0];\n\t\t\tthis.expandBy(distance, distance);\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar deltaX = arguments[0],\n\t\t\t    deltaY = arguments[1];\n\t\t\tif (this.isNull()) return null;\n\t\t\tthis._minx -= deltaX;\n\t\t\tthis._maxx += deltaX;\n\t\t\tthis._miny -= deltaY;\n\t\t\tthis._maxy += deltaY;\n\t\t\tif (this._minx > this._maxx || this._miny > this._maxy) this.setToNull();\n\t\t}\n\t},\n\tcontains: function contains() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Envelope) {\n\t\t\t\tvar other = arguments[0];\n\t\t\t\treturn this.covers(other);\n\t\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\t\tvar p = arguments[0];\n\t\t\t\treturn this.covers(p);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar x = arguments[0],\n\t\t\t    y = arguments[1];\n\t\t\treturn this.covers(x, y);\n\t\t}\n\t},\n\tcentre: function centre() {\n\t\tif (this.isNull()) return null;\n\t\treturn new Coordinate((this.getMinX() + this.getMaxX()) / 2.0, (this.getMinY() + this.getMaxY()) / 2.0);\n\t},\n\tinit: function init() {\n\t\tif (arguments.length === 0) {\n\t\t\tthis.setToNull();\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\t\tvar p = arguments[0];\n\t\t\t\tthis.init(p.x, p.x, p.y, p.y);\n\t\t\t} else if (arguments[0] instanceof Envelope) {\n\t\t\t\tvar env = arguments[0];\n\t\t\t\tthis._minx = env._minx;\n\t\t\t\tthis._maxx = env._maxx;\n\t\t\t\tthis._miny = env._miny;\n\t\t\t\tthis._maxy = env._maxy;\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar p1 = arguments[0],\n\t\t\t    p2 = arguments[1];\n\t\t\tthis.init(p1.x, p2.x, p1.y, p2.y);\n\t\t} else if (arguments.length === 4) {\n\t\t\tvar x1 = arguments[0],\n\t\t\t    x2 = arguments[1],\n\t\t\t    y1 = arguments[2],\n\t\t\t    y2 = arguments[3];\n\t\t\tif (x1 < x2) {\n\t\t\t\tthis._minx = x1;\n\t\t\t\tthis._maxx = x2;\n\t\t\t} else {\n\t\t\t\tthis._minx = x2;\n\t\t\t\tthis._maxx = x1;\n\t\t\t}\n\t\t\tif (y1 < y2) {\n\t\t\t\tthis._miny = y1;\n\t\t\t\tthis._maxy = y2;\n\t\t\t} else {\n\t\t\t\tthis._miny = y2;\n\t\t\t\tthis._maxy = y1;\n\t\t\t}\n\t\t}\n\t},\n\tgetMaxY: function getMaxY() {\n\t\treturn this._maxy;\n\t},\n\tdistance: function distance(env) {\n\t\tif (this.intersects(env)) return 0;\n\t\tvar dx = 0.0;\n\t\tif (this._maxx < env._minx) dx = env._minx - this._maxx;else if (this._minx > env._maxx) dx = this._minx - env._maxx;\n\t\tvar dy = 0.0;\n\t\tif (this._maxy < env._miny) dy = env._miny - this._maxy;else if (this._miny > env._maxy) dy = this._miny - env._maxy;\n\t\tif (dx === 0.0) return dy;\n\t\tif (dy === 0.0) return dx;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t},\n\thashCode: function hashCode() {\n\t\tvar result = 17;\n\t\tresult = 37 * result + Coordinate.hashCode(this._minx);\n\t\tresult = 37 * result + Coordinate.hashCode(this._maxx);\n\t\tresult = 37 * result + Coordinate.hashCode(this._miny);\n\t\tresult = 37 * result + Coordinate.hashCode(this._maxy);\n\t\treturn result;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Comparable, Serializable];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Envelope;\n\t}\n});\nEnvelope.intersects = function () {\n\tif (arguments.length === 3) {\n\t\tvar p1 = arguments[0],\n\t\t    p2 = arguments[1],\n\t\t    q = arguments[2];\n\t\tif (q.x >= (p1.x < p2.x ? p1.x : p2.x) && q.x <= (p1.x > p2.x ? p1.x : p2.x) && q.y >= (p1.y < p2.y ? p1.y : p2.y) && q.y <= (p1.y > p2.y ? p1.y : p2.y)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t} else if (arguments.length === 4) {\n\t\tvar p1 = arguments[0],\n\t\t    p2 = arguments[1],\n\t\t    q1 = arguments[2],\n\t\t    q2 = arguments[3];\n\t\tvar minq = Math.min(q1.x, q2.x);\n\t\tvar maxq = Math.max(q1.x, q2.x);\n\t\tvar minp = Math.min(p1.x, p2.x);\n\t\tvar maxp = Math.max(p1.x, p2.x);\n\t\tif (minp > maxq) return false;\n\t\tif (maxp < minq) return false;\n\t\tminq = Math.min(q1.y, q2.y);\n\t\tmaxq = Math.max(q1.y, q2.y);\n\t\tminp = Math.min(p1.y, p2.y);\n\t\tmaxp = Math.max(p1.y, p2.y);\n\t\tif (minp > maxq) return false;\n\t\tif (maxp < minq) return false;\n\t\treturn true;\n\t}\n};\nEnvelope.serialVersionUID = 5873921885273102420;\n\nfunction Exception() {}\n\nfunction NotRepresentableException() {\n\tException.call(this, \"Projective point not representable on the Cartesian plane.\");\n}\ninherits$1(NotRepresentableException, Exception);\nextend(NotRepresentableException.prototype, {\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn NotRepresentableException;\n\t}\n});\n\nfunction Location() {}\nextend(Location.prototype, {\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Location;\n\t}\n});\nLocation.toLocationSymbol = function (locationValue) {\n\tswitch (locationValue) {\n\t\tcase Location.EXTERIOR:\n\t\t\treturn 'e';\n\t\tcase Location.BOUNDARY:\n\t\t\treturn 'b';\n\t\tcase Location.INTERIOR:\n\t\t\treturn 'i';\n\t\tcase Location.NONE:\n\t\t\treturn '-';\n\t}\n\tthrow new IllegalArgumentException(\"Unknown location value: \" + locationValue);\n};\nLocation.INTERIOR = 0;\nLocation.BOUNDARY = 1;\nLocation.EXTERIOR = 2;\nLocation.NONE = -1;\n\nvar hasInterface = function (o, i) {\n  return o.interfaces_ && o.interfaces_().indexOf(i) > -1;\n};\n\nfunction MathUtil() {}\nextend(MathUtil.prototype, {\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn MathUtil;\n\t}\n});\nMathUtil.log10 = function (x) {\n\tvar ln = Math.log(x);\n\tif (Double.isInfinite(ln)) return ln;\n\tif (Double.isNaN(ln)) return ln;\n\treturn ln / MathUtil.LOG_10;\n};\nMathUtil.min = function (v1, v2, v3, v4) {\n\tvar min = v1;\n\tif (v2 < min) min = v2;\n\tif (v3 < min) min = v3;\n\tif (v4 < min) min = v4;\n\treturn min;\n};\nMathUtil.clamp = function () {\n\tif (typeof arguments[2] === \"number\" && typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\") {\n\t\tvar x = arguments[0],\n\t\t    min = arguments[1],\n\t\t    max = arguments[2];\n\t\tif (x < min) return min;\n\t\tif (x > max) return max;\n\t\treturn x;\n\t} else if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {\n\t\tvar x = arguments[0],\n\t\t    min = arguments[1],\n\t\t    max = arguments[2];\n\t\tif (x < min) return min;\n\t\tif (x > max) return max;\n\t\treturn x;\n\t}\n};\nMathUtil.wrap = function (index, max) {\n\tif (index < 0) {\n\t\treturn max - -index % max;\n\t}\n\treturn index % max;\n};\nMathUtil.max = function () {\n\tif (arguments.length === 3) {\n\t\tvar v1 = arguments[0],\n\t\t    v2 = arguments[1],\n\t\t    v3 = arguments[2];\n\t\tvar max = v1;\n\t\tif (v2 > max) max = v2;\n\t\tif (v3 > max) max = v3;\n\t\treturn max;\n\t} else if (arguments.length === 4) {\n\t\tvar v1 = arguments[0],\n\t\t    v2 = arguments[1],\n\t\t    v3 = arguments[2],\n\t\t    v4 = arguments[3];\n\t\tvar max = v1;\n\t\tif (v2 > max) max = v2;\n\t\tif (v3 > max) max = v3;\n\t\tif (v4 > max) max = v4;\n\t\treturn max;\n\t}\n};\nMathUtil.average = function (x1, x2) {\n\treturn (x1 + x2) / 2.0;\n};\nMathUtil.LOG_10 = Math.log(10);\n\nfunction StringBuffer(str) {\n  this.str = str;\n}\n\nStringBuffer.prototype.append = function (e) {\n  this.str += e;\n};\n\nStringBuffer.prototype.setCharAt = function (i, c) {\n  this.str = this.str.substr(0, i) + c + this.str.substr(i + 1);\n};\n\nStringBuffer.prototype.toString = function (e) {\n  return this.str;\n};\n\nfunction Integer(value) {\n  this.value = value;\n}\n\nInteger.prototype.intValue = function () {\n  return this.value;\n};\nInteger.prototype.compareTo = function (o) {\n  if (this.value < o) return -1;\n  if (this.value > o) return 1;\n  return 0;\n};\n\nInteger.isNaN = function (n) {\n  return Number.isNaN(n);\n};\n\nfunction Character() {}\nCharacter.isWhitespace = function (c) {\n  return c <= 32 && c >= 0 || c == 127;\n};\nCharacter.toUpperCase = function (c) {\n  return c.toUpperCase();\n};\n\nfunction DD() {\n\tthis._hi = 0.0;\n\tthis._lo = 0.0;\n\tif (arguments.length === 0) {\n\t\tthis.init(0.0);\n\t} else if (arguments.length === 1) {\n\t\tif (typeof arguments[0] === \"number\") {\n\t\t\tvar x = arguments[0];\n\t\t\tthis.init(x);\n\t\t} else if (arguments[0] instanceof DD) {\n\t\t\tvar dd = arguments[0];\n\t\t\tthis.init(dd);\n\t\t} else if (typeof arguments[0] === \"string\") {\n\t\t\tvar str = arguments[0];\n\t\t\tDD.call(this, DD.parse(str));\n\t\t}\n\t} else if (arguments.length === 2) {\n\t\tvar hi = arguments[0],\n\t\t    lo = arguments[1];\n\t\tthis.init(hi, lo);\n\t}\n}\nextend(DD.prototype, {\n\tle: function le(y) {\n\t\treturn this._hi < y._hi || this._hi === y._hi && this._lo <= y._lo;\n\t},\n\textractSignificantDigits: function extractSignificantDigits(insertDecimalPoint, magnitude) {\n\t\tvar y = this.abs();\n\t\tvar mag = DD.magnitude(y._hi);\n\t\tvar scale = DD.TEN.pow(mag);\n\t\ty = y.divide(scale);\n\t\tif (y.gt(DD.TEN)) {\n\t\t\ty = y.divide(DD.TEN);\n\t\t\tmag += 1;\n\t\t} else if (y.lt(DD.ONE)) {\n\t\t\ty = y.multiply(DD.TEN);\n\t\t\tmag -= 1;\n\t\t}\n\t\tvar decimalPointPos = mag + 1;\n\t\tvar buf = new StringBuffer();\n\t\tvar numDigits = DD.MAX_PRINT_DIGITS - 1;\n\t\tfor (var i = 0; i <= numDigits; i++) {\n\t\t\tif (insertDecimalPoint && i === decimalPointPos) {\n\t\t\t\tbuf.append('.');\n\t\t\t}\n\t\t\tvar digit = Math.trunc(y._hi);\n\t\t\tif (digit < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvar rebiasBy10 = false;\n\t\t\tvar digitChar = 0;\n\t\t\tif (digit > 9) {\n\t\t\t\trebiasBy10 = true;\n\t\t\t\tdigitChar = '9';\n\t\t\t} else {\n\t\t\t\tdigitChar = '0' + digit;\n\t\t\t}\n\t\t\tbuf.append(digitChar);\n\t\t\ty = y.subtract(DD.valueOf(digit)).multiply(DD.TEN);\n\t\t\tif (rebiasBy10) y.selfAdd(DD.TEN);\n\t\t\tvar continueExtractingDigits = true;\n\t\t\tvar remMag = DD.magnitude(y._hi);\n\t\t\tif (remMag < 0 && Math.abs(remMag) >= numDigits - i) continueExtractingDigits = false;\n\t\t\tif (!continueExtractingDigits) break;\n\t\t}\n\t\tmagnitude[0] = mag;\n\t\treturn buf.toString();\n\t},\n\tsqr: function sqr() {\n\t\treturn this.multiply(this);\n\t},\n\tdoubleValue: function doubleValue() {\n\t\treturn this._hi + this._lo;\n\t},\n\tsubtract: function subtract() {\n\t\tif (arguments[0] instanceof DD) {\n\t\t\tvar y = arguments[0];\n\t\t\treturn this.add(y.negate());\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tvar y = arguments[0];\n\t\t\treturn this.add(-y);\n\t\t}\n\t},\n\tequals: function equals() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar y = arguments[0];\n\t\t\treturn this._hi === y._hi && this._lo === y._lo;\n\t\t}\n\t},\n\tisZero: function isZero() {\n\t\treturn this._hi === 0.0 && this._lo === 0.0;\n\t},\n\tselfSubtract: function selfSubtract() {\n\t\tif (arguments[0] instanceof DD) {\n\t\t\tvar y = arguments[0];\n\t\t\tif (this.isNaN()) return this;\n\t\t\treturn this.selfAdd(-y._hi, -y._lo);\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tvar y = arguments[0];\n\t\t\tif (this.isNaN()) return this;\n\t\t\treturn this.selfAdd(-y, 0.0);\n\t\t}\n\t},\n\tgetSpecialNumberString: function getSpecialNumberString() {\n\t\tif (this.isZero()) return \"0.0\";\n\t\tif (this.isNaN()) return \"NaN \";\n\t\treturn null;\n\t},\n\tmin: function min(x) {\n\t\tif (this.le(x)) {\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn x;\n\t\t}\n\t},\n\tselfDivide: function selfDivide() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof DD) {\n\t\t\t\tvar y = arguments[0];\n\t\t\t\treturn this.selfDivide(y._hi, y._lo);\n\t\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\t\tvar y = arguments[0];\n\t\t\t\treturn this.selfDivide(y, 0.0);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar yhi = arguments[0],\n\t\t\t    ylo = arguments[1];\n\t\t\tvar hc = null,\n\t\t\t    tc = null,\n\t\t\t    hy = null,\n\t\t\t    ty = null,\n\t\t\t    C = null,\n\t\t\t    c = null,\n\t\t\t    U = null,\n\t\t\t    u = null;\n\t\t\tC = this._hi / yhi;\n\t\t\tc = DD.SPLIT * C;\n\t\t\thc = c - C;\n\t\t\tu = DD.SPLIT * yhi;\n\t\t\thc = c - hc;\n\t\t\ttc = C - hc;\n\t\t\thy = u - yhi;\n\t\t\tU = C * yhi;\n\t\t\thy = u - hy;\n\t\t\tty = yhi - hy;\n\t\t\tu = hc * hy - U + hc * ty + tc * hy + tc * ty;\n\t\t\tc = (this._hi - U - u + this._lo - C * ylo) / yhi;\n\t\t\tu = C + c;\n\t\t\tthis._hi = u;\n\t\t\tthis._lo = C - u + c;\n\t\t\treturn this;\n\t\t}\n\t},\n\tdump: function dump() {\n\t\treturn \"DD<\" + this._hi + \", \" + this._lo + \">\";\n\t},\n\tdivide: function divide() {\n\t\tif (arguments[0] instanceof DD) {\n\t\t\tvar y = arguments[0];\n\t\t\tvar hc = null,\n\t\t\t    tc = null,\n\t\t\t    hy = null,\n\t\t\t    ty = null,\n\t\t\t    C = null,\n\t\t\t    c = null,\n\t\t\t    U = null,\n\t\t\t    u = null;\n\t\t\tC = this._hi / y._hi;\n\t\t\tc = DD.SPLIT * C;\n\t\t\thc = c - C;\n\t\t\tu = DD.SPLIT * y._hi;\n\t\t\thc = c - hc;\n\t\t\ttc = C - hc;\n\t\t\thy = u - y._hi;\n\t\t\tU = C * y._hi;\n\t\t\thy = u - hy;\n\t\t\tty = y._hi - hy;\n\t\t\tu = hc * hy - U + hc * ty + tc * hy + tc * ty;\n\t\t\tc = (this._hi - U - u + this._lo - C * y._lo) / y._hi;\n\t\t\tu = C + c;\n\t\t\tvar zhi = u;\n\t\t\tvar zlo = C - u + c;\n\t\t\treturn new DD(zhi, zlo);\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tvar y = arguments[0];\n\t\t\tif (Double.isNaN(y)) return DD.createNaN();\n\t\t\treturn DD.copy(this).selfDivide(y, 0.0);\n\t\t}\n\t},\n\tge: function ge(y) {\n\t\treturn this._hi > y._hi || this._hi === y._hi && this._lo >= y._lo;\n\t},\n\tpow: function pow(exp) {\n\t\tif (exp === 0.0) return DD.valueOf(1.0);\n\t\tvar r = new DD(this);\n\t\tvar s = DD.valueOf(1.0);\n\t\tvar n = Math.abs(exp);\n\t\tif (n > 1) {\n\t\t\twhile (n > 0) {\n\t\t\t\tif (n % 2 === 1) {\n\t\t\t\t\ts.selfMultiply(r);\n\t\t\t\t}\n\t\t\t\tn /= 2;\n\t\t\t\tif (n > 0) r = r.sqr();\n\t\t\t}\n\t\t} else {\n\t\t\ts = r;\n\t\t}\n\t\tif (exp < 0) return s.reciprocal();\n\t\treturn s;\n\t},\n\tceil: function ceil() {\n\t\tif (this.isNaN()) return DD.NaN;\n\t\tvar fhi = Math.ceil(this._hi);\n\t\tvar flo = 0.0;\n\t\tif (fhi === this._hi) {\n\t\t\tflo = Math.ceil(this._lo);\n\t\t}\n\t\treturn new DD(fhi, flo);\n\t},\n\tcompareTo: function compareTo(o) {\n\t\tvar other = o;\n\t\tif (this._hi < other._hi) return -1;\n\t\tif (this._hi > other._hi) return 1;\n\t\tif (this._lo < other._lo) return -1;\n\t\tif (this._lo > other._lo) return 1;\n\t\treturn 0;\n\t},\n\trint: function rint() {\n\t\tif (this.isNaN()) return this;\n\t\tvar plus5 = this.add(0.5);\n\t\treturn plus5.floor();\n\t},\n\tsetValue: function setValue() {\n\t\tif (arguments[0] instanceof DD) {\n\t\t\tvar value = arguments[0];\n\t\t\tthis.init(value);\n\t\t\treturn this;\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tvar value = arguments[0];\n\t\t\tthis.init(value);\n\t\t\treturn this;\n\t\t}\n\t},\n\tmax: function max(x) {\n\t\tif (this.ge(x)) {\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn x;\n\t\t}\n\t},\n\tsqrt: function sqrt() {\n\t\tif (this.isZero()) return DD.valueOf(0.0);\n\t\tif (this.isNegative()) {\n\t\t\treturn DD.NaN;\n\t\t}\n\t\tvar x = 1.0 / Math.sqrt(this._hi);\n\t\tvar ax = this._hi * x;\n\t\tvar axdd = DD.valueOf(ax);\n\t\tvar diffSq = this.subtract(axdd.sqr());\n\t\tvar d2 = diffSq._hi * (x * 0.5);\n\t\treturn axdd.add(d2);\n\t},\n\tselfAdd: function selfAdd() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof DD) {\n\t\t\t\tvar y = arguments[0];\n\t\t\t\treturn this.selfAdd(y._hi, y._lo);\n\t\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\t\tvar y = arguments[0];\n\t\t\t\tvar H = null,\n\t\t\t\t    h = null,\n\t\t\t\t    S = null,\n\t\t\t\t    s = null,\n\t\t\t\t    e = null,\n\t\t\t\t    f = null;\n\t\t\t\tS = this._hi + y;\n\t\t\t\te = S - this._hi;\n\t\t\t\ts = S - e;\n\t\t\t\ts = y - e + (this._hi - s);\n\t\t\t\tf = s + this._lo;\n\t\t\t\tH = S + f;\n\t\t\t\th = f + (S - H);\n\t\t\t\tthis._hi = H + h;\n\t\t\t\tthis._lo = h + (H - this._hi);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar yhi = arguments[0],\n\t\t\t    ylo = arguments[1];\n\t\t\tvar H = null,\n\t\t\t    h = null,\n\t\t\t    T = null,\n\t\t\t    t = null,\n\t\t\t    S = null,\n\t\t\t    s = null,\n\t\t\t    e = null,\n\t\t\t    f = null;\n\t\t\tS = this._hi + yhi;\n\t\t\tT = this._lo + ylo;\n\t\t\te = S - this._hi;\n\t\t\tf = T - this._lo;\n\t\t\ts = S - e;\n\t\t\tt = T - f;\n\t\t\ts = yhi - e + (this._hi - s);\n\t\t\tt = ylo - f + (this._lo - t);\n\t\t\te = s + T;\n\t\t\tH = S + e;\n\t\t\th = e + (S - H);\n\t\t\te = t + h;\n\t\t\tvar zhi = H + e;\n\t\t\tvar zlo = e + (H - zhi);\n\t\t\tthis._hi = zhi;\n\t\t\tthis._lo = zlo;\n\t\t\treturn this;\n\t\t}\n\t},\n\tselfMultiply: function selfMultiply() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof DD) {\n\t\t\t\tvar y = arguments[0];\n\t\t\t\treturn this.selfMultiply(y._hi, y._lo);\n\t\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\t\tvar y = arguments[0];\n\t\t\t\treturn this.selfMultiply(y, 0.0);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar yhi = arguments[0],\n\t\t\t    ylo = arguments[1];\n\t\t\tvar hx = null,\n\t\t\t    tx = null,\n\t\t\t    hy = null,\n\t\t\t    ty = null,\n\t\t\t    C = null,\n\t\t\t    c = null;\n\t\t\tC = DD.SPLIT * this._hi;\n\t\t\thx = C - this._hi;\n\t\t\tc = DD.SPLIT * yhi;\n\t\t\thx = C - hx;\n\t\t\ttx = this._hi - hx;\n\t\t\thy = c - yhi;\n\t\t\tC = this._hi * yhi;\n\t\t\thy = c - hy;\n\t\t\tty = yhi - hy;\n\t\t\tc = hx * hy - C + hx * ty + tx * hy + tx * ty + (this._hi * ylo + this._lo * yhi);\n\t\t\tvar zhi = C + c;\n\t\t\thx = C - zhi;\n\t\t\tvar zlo = c + hx;\n\t\t\tthis._hi = zhi;\n\t\t\tthis._lo = zlo;\n\t\t\treturn this;\n\t\t}\n\t},\n\tselfSqr: function selfSqr() {\n\t\treturn this.selfMultiply(this);\n\t},\n\tfloor: function floor() {\n\t\tif (this.isNaN()) return DD.NaN;\n\t\tvar fhi = Math.floor(this._hi);\n\t\tvar flo = 0.0;\n\t\tif (fhi === this._hi) {\n\t\t\tflo = Math.floor(this._lo);\n\t\t}\n\t\treturn new DD(fhi, flo);\n\t},\n\tnegate: function negate() {\n\t\tif (this.isNaN()) return this;\n\t\treturn new DD(-this._hi, -this._lo);\n\t},\n\tclone: function clone() {\n\t\ttry {\n\t\t\treturn null;\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof CloneNotSupportedException) {\n\t\t\t\treturn null;\n\t\t\t} else throw ex;\n\t\t} finally {}\n\t},\n\tmultiply: function multiply() {\n\t\tif (arguments[0] instanceof DD) {\n\t\t\tvar y = arguments[0];\n\t\t\tif (y.isNaN()) return DD.createNaN();\n\t\t\treturn DD.copy(this).selfMultiply(y);\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tvar y = arguments[0];\n\t\t\tif (Double.isNaN(y)) return DD.createNaN();\n\t\t\treturn DD.copy(this).selfMultiply(y, 0.0);\n\t\t}\n\t},\n\tisNaN: function isNaN() {\n\t\treturn Double.isNaN(this._hi);\n\t},\n\tintValue: function intValue() {\n\t\treturn Math.trunc(this._hi);\n\t},\n\ttoString: function toString() {\n\t\tvar mag = DD.magnitude(this._hi);\n\t\tif (mag >= -3 && mag <= 20) return this.toStandardNotation();\n\t\treturn this.toSciNotation();\n\t},\n\ttoStandardNotation: function toStandardNotation() {\n\t\tvar specialStr = this.getSpecialNumberString();\n\t\tif (specialStr !== null) return specialStr;\n\t\tvar magnitude = new Array(1).fill(null);\n\t\tvar sigDigits = this.extractSignificantDigits(true, magnitude);\n\t\tvar decimalPointPos = magnitude[0] + 1;\n\t\tvar num = sigDigits;\n\t\tif (sigDigits.charAt(0) === '.') {\n\t\t\tnum = \"0\" + sigDigits;\n\t\t} else if (decimalPointPos < 0) {\n\t\t\tnum = \"0.\" + DD.stringOfChar('0', -decimalPointPos) + sigDigits;\n\t\t} else if (sigDigits.indexOf('.') === -1) {\n\t\t\tvar numZeroes = decimalPointPos - sigDigits.length;\n\t\t\tvar zeroes = DD.stringOfChar('0', numZeroes);\n\t\t\tnum = sigDigits + zeroes + \".0\";\n\t\t}\n\t\tif (this.isNegative()) return \"-\" + num;\n\t\treturn num;\n\t},\n\treciprocal: function reciprocal() {\n\t\tvar hc = null,\n\t\t    tc = null,\n\t\t    hy = null,\n\t\t    ty = null,\n\t\t    C = null,\n\t\t    c = null,\n\t\t    U = null,\n\t\t    u = null;\n\t\tC = 1.0 / this._hi;\n\t\tc = DD.SPLIT * C;\n\t\thc = c - C;\n\t\tu = DD.SPLIT * this._hi;\n\t\thc = c - hc;\n\t\ttc = C - hc;\n\t\thy = u - this._hi;\n\t\tU = C * this._hi;\n\t\thy = u - hy;\n\t\tty = this._hi - hy;\n\t\tu = hc * hy - U + hc * ty + tc * hy + tc * ty;\n\t\tc = (1.0 - U - u - C * this._lo) / this._hi;\n\t\tvar zhi = C + c;\n\t\tvar zlo = C - zhi + c;\n\t\treturn new DD(zhi, zlo);\n\t},\n\ttoSciNotation: function toSciNotation() {\n\t\tif (this.isZero()) return DD.SCI_NOT_ZERO;\n\t\tvar specialStr = this.getSpecialNumberString();\n\t\tif (specialStr !== null) return specialStr;\n\t\tvar magnitude = new Array(1).fill(null);\n\t\tvar digits = this.extractSignificantDigits(false, magnitude);\n\t\tvar expStr = DD.SCI_NOT_EXPONENT_CHAR + magnitude[0];\n\t\tif (digits.charAt(0) === '0') {\n\t\t\tthrow new IllegalStateException(\"Found leading zero: \" + digits);\n\t\t}\n\t\tvar trailingDigits = \"\";\n\t\tif (digits.length > 1) trailingDigits = digits.substring(1);\n\t\tvar digitsWithDecimal = digits.charAt(0) + \".\" + trailingDigits;\n\t\tif (this.isNegative()) return \"-\" + digitsWithDecimal + expStr;\n\t\treturn digitsWithDecimal + expStr;\n\t},\n\tabs: function abs() {\n\t\tif (this.isNaN()) return DD.NaN;\n\t\tif (this.isNegative()) return this.negate();\n\t\treturn new DD(this);\n\t},\n\tisPositive: function isPositive() {\n\t\treturn this._hi > 0.0 || this._hi === 0.0 && this._lo > 0.0;\n\t},\n\tlt: function lt(y) {\n\t\treturn this._hi < y._hi || this._hi === y._hi && this._lo < y._lo;\n\t},\n\tadd: function add() {\n\t\tif (arguments[0] instanceof DD) {\n\t\t\tvar y = arguments[0];\n\t\t\treturn DD.copy(this).selfAdd(y);\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tvar y = arguments[0];\n\t\t\treturn DD.copy(this).selfAdd(y);\n\t\t}\n\t},\n\tinit: function init() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (typeof arguments[0] === \"number\") {\n\t\t\t\tvar x = arguments[0];\n\t\t\t\tthis._hi = x;\n\t\t\t\tthis._lo = 0.0;\n\t\t\t} else if (arguments[0] instanceof DD) {\n\t\t\t\tvar dd = arguments[0];\n\t\t\t\tthis._hi = dd._hi;\n\t\t\t\tthis._lo = dd._lo;\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar hi = arguments[0],\n\t\t\t    lo = arguments[1];\n\t\t\tthis._hi = hi;\n\t\t\tthis._lo = lo;\n\t\t}\n\t},\n\tgt: function gt(y) {\n\t\treturn this._hi > y._hi || this._hi === y._hi && this._lo > y._lo;\n\t},\n\tisNegative: function isNegative() {\n\t\treturn this._hi < 0.0 || this._hi === 0.0 && this._lo < 0.0;\n\t},\n\ttrunc: function trunc() {\n\t\tif (this.isNaN()) return DD.NaN;\n\t\tif (this.isPositive()) return this.floor();else return this.ceil();\n\t},\n\tsignum: function signum() {\n\t\tif (this._hi > 0) return 1;\n\t\tif (this._hi < 0) return -1;\n\t\tif (this._lo > 0) return 1;\n\t\tif (this._lo < 0) return -1;\n\t\treturn 0;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Serializable, Comparable, Clonable];\n\t},\n\tgetClass: function getClass() {\n\t\treturn DD;\n\t}\n});\nDD.sqr = function (x) {\n\treturn DD.valueOf(x).selfMultiply(x);\n};\nDD.valueOf = function () {\n\tif (typeof arguments[0] === \"string\") {\n\t\tvar str = arguments[0];\n\t\treturn DD.parse(str);\n\t} else if (typeof arguments[0] === \"number\") {\n\t\tvar x = arguments[0];\n\t\treturn new DD(x);\n\t}\n};\nDD.sqrt = function (x) {\n\treturn DD.valueOf(x).sqrt();\n};\nDD.parse = function (str) {\n\tvar i = 0;\n\tvar strlen = str.length;\n\twhile (Character.isWhitespace(str.charAt(i))) {\n\t\ti++;\n\t}var isNegative = false;\n\tif (i < strlen) {\n\t\tvar signCh = str.charAt(i);\n\t\tif (signCh === '-' || signCh === '+') {\n\t\t\ti++;\n\t\t\tif (signCh === '-') isNegative = true;\n\t\t}\n\t}\n\tvar val = new DD();\n\tvar numDigits = 0;\n\tvar numBeforeDec = 0;\n\tvar exp = 0;\n\twhile (true) {\n\t\tif (i >= strlen) break;\n\t\tvar ch = str.charAt(i);\n\t\ti++;\n\t\tif (Character.isDigit(ch)) {\n\t\t\tvar d = ch - '0';\n\t\t\tval.selfMultiply(DD.TEN);\n\t\t\tval.selfAdd(d);\n\t\t\tnumDigits++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch === '.') {\n\t\t\tnumBeforeDec = numDigits;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch === 'e' || ch === 'E') {\n\t\t\tvar expStr = str.substring(i);\n\t\t\ttry {\n\t\t\t\texp = Integer.parseInt(expStr);\n\t\t\t} catch (ex) {\n\t\t\t\tif (ex instanceof NumberFormatException) {\n\t\t\t\t\tthrow new NumberFormatException(\"Invalid exponent \" + expStr + \" in string \" + str);\n\t\t\t\t} else throw ex;\n\t\t\t} finally {}\n\t\t\tbreak;\n\t\t}\n\t\tthrow new NumberFormatException(\"Unexpected character '\" + ch + \"' at position \" + i + \" in string \" + str);\n\t}\n\tvar val2 = val;\n\tvar numDecPlaces = numDigits - numBeforeDec - exp;\n\tif (numDecPlaces === 0) {\n\t\tval2 = val;\n\t} else if (numDecPlaces > 0) {\n\t\tvar scale = DD.TEN.pow(numDecPlaces);\n\t\tval2 = val.divide(scale);\n\t} else if (numDecPlaces < 0) {\n\t\tvar scale = DD.TEN.pow(-numDecPlaces);\n\t\tval2 = val.multiply(scale);\n\t}\n\tif (isNegative) {\n\t\treturn val2.negate();\n\t}\n\treturn val2;\n};\nDD.createNaN = function () {\n\treturn new DD(Double.NaN, Double.NaN);\n};\nDD.copy = function (dd) {\n\treturn new DD(dd);\n};\nDD.magnitude = function (x) {\n\tvar xAbs = Math.abs(x);\n\tvar xLog10 = Math.log(xAbs) / Math.log(10);\n\tvar xMag = Math.trunc(Math.floor(xLog10));\n\tvar xApprox = Math.pow(10, xMag);\n\tif (xApprox * 10 <= xAbs) xMag += 1;\n\treturn xMag;\n};\nDD.stringOfChar = function (ch, len) {\n\tvar buf = new StringBuffer();\n\tfor (var i = 0; i < len; i++) {\n\t\tbuf.append(ch);\n\t}\n\treturn buf.toString();\n};\nDD.PI = new DD(3.141592653589793116e+00, 1.224646799147353207e-16);\nDD.TWO_PI = new DD(6.283185307179586232e+00, 2.449293598294706414e-16);\nDD.PI_2 = new DD(1.570796326794896558e+00, 6.123233995736766036e-17);\nDD.E = new DD(2.718281828459045091e+00, 1.445646891729250158e-16);\nDD.NaN = new DD(Double.NaN, Double.NaN);\nDD.EPS = 1.23259516440783e-32;\nDD.SPLIT = 134217729.0;\nDD.MAX_PRINT_DIGITS = 32;\nDD.TEN = DD.valueOf(10.0);\nDD.ONE = DD.valueOf(1.0);\nDD.SCI_NOT_EXPONENT_CHAR = \"E\";\nDD.SCI_NOT_ZERO = \"0.0E0\";\n\nfunction CGAlgorithmsDD() {}\nextend(CGAlgorithmsDD.prototype, {\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn CGAlgorithmsDD;\n\t}\n});\nCGAlgorithmsDD.orientationIndex = function (p1, p2, q) {\n\tvar index = CGAlgorithmsDD.orientationIndexFilter(p1, p2, q);\n\tif (index <= 1) return index;\n\tvar dx1 = DD.valueOf(p2.x).selfAdd(-p1.x);\n\tvar dy1 = DD.valueOf(p2.y).selfAdd(-p1.y);\n\tvar dx2 = DD.valueOf(q.x).selfAdd(-p2.x);\n\tvar dy2 = DD.valueOf(q.y).selfAdd(-p2.y);\n\treturn dx1.selfMultiply(dy2).selfSubtract(dy1.selfMultiply(dx2)).signum();\n};\nCGAlgorithmsDD.signOfDet2x2 = function (x1, y1, x2, y2) {\n\tvar det = x1.multiply(y2).selfSubtract(y1.multiply(x2));\n\treturn det.signum();\n};\nCGAlgorithmsDD.intersection = function (p1, p2, q1, q2) {\n\tvar denom1 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p2.x).selfSubtract(p1.x));\n\tvar denom2 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p2.y).selfSubtract(p1.y));\n\tvar denom = denom1.subtract(denom2);\n\tvar numx1 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));\n\tvar numx2 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));\n\tvar numx = numx1.subtract(numx2);\n\tvar fracP = numx.selfDivide(denom).doubleValue();\n\tvar x = DD.valueOf(p1.x).selfAdd(DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(fracP)).doubleValue();\n\tvar numy1 = DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));\n\tvar numy2 = DD.valueOf(p2.y).selfSubtract(p1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));\n\tvar numy = numy1.subtract(numy2);\n\tvar fracQ = numy.selfDivide(denom).doubleValue();\n\tvar y = DD.valueOf(q1.y).selfAdd(DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(fracQ)).doubleValue();\n\treturn new Coordinate(x, y);\n};\nCGAlgorithmsDD.orientationIndexFilter = function (pa, pb, pc) {\n\tvar detsum = null;\n\tvar detleft = (pa.x - pc.x) * (pb.y - pc.y);\n\tvar detright = (pa.y - pc.y) * (pb.x - pc.x);\n\tvar det = detleft - detright;\n\tif (detleft > 0.0) {\n\t\tif (detright <= 0.0) {\n\t\t\treturn CGAlgorithmsDD.signum(det);\n\t\t} else {\n\t\t\tdetsum = detleft + detright;\n\t\t}\n\t} else if (detleft < 0.0) {\n\t\tif (detright >= 0.0) {\n\t\t\treturn CGAlgorithmsDD.signum(det);\n\t\t} else {\n\t\t\tdetsum = -detleft - detright;\n\t\t}\n\t} else {\n\t\treturn CGAlgorithmsDD.signum(det);\n\t}\n\tvar errbound = CGAlgorithmsDD.DP_SAFE_EPSILON * detsum;\n\tif (det >= errbound || -det >= errbound) {\n\t\treturn CGAlgorithmsDD.signum(det);\n\t}\n\treturn 2;\n};\nCGAlgorithmsDD.signum = function (x) {\n\tif (x > 0) return 1;\n\tif (x < 0) return -1;\n\treturn 0;\n};\nCGAlgorithmsDD.DP_SAFE_EPSILON = 1e-15;\n\nfunction CoordinateSequence() {}\nextend(CoordinateSequence.prototype, {\n\tsetOrdinate: function setOrdinate(index, ordinateIndex, value) {},\n\tsize: function size() {},\n\tgetOrdinate: function getOrdinate(index, ordinateIndex) {},\n\tgetCoordinate: function getCoordinate() {\n\t\t\n\t},\n\tgetCoordinateCopy: function getCoordinateCopy(i) {},\n\tgetDimension: function getDimension() {},\n\tgetX: function getX(index) {},\n\tclone: function clone() {},\n\texpandEnvelope: function expandEnvelope(env) {},\n\tcopy: function copy() {},\n\tgetY: function getY(index) {},\n\ttoCoordinateArray: function toCoordinateArray() {},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Clonable];\n\t},\n\tgetClass: function getClass() {\n\t\treturn CoordinateSequence;\n\t}\n});\nCoordinateSequence.X = 0;\nCoordinateSequence.Y = 1;\nCoordinateSequence.Z = 2;\nCoordinateSequence.M = 3;\n\nfunction System() {}\n\nSystem.arraycopy = function (src, srcPos, dest, destPos, len) {\n  var c = 0;\n  for (var i = srcPos; i < srcPos + len; i++) {\n    dest[destPos + c] = src[i];\n    c++;\n  }\n};\n\nSystem.getProperty = function (name) {\n  return {\n    'line.separator': '\\n'\n  }[name];\n};\n\nfunction HCoordinate() {\n\tthis.x = null;\n\tthis.y = null;\n\tthis.w = null;\n\tif (arguments.length === 0) {\n\t\tthis.x = 0.0;\n\t\tthis.y = 0.0;\n\t\tthis.w = 1.0;\n\t} else if (arguments.length === 1) {\n\t\tvar p = arguments[0];\n\t\tthis.x = p.x;\n\t\tthis.y = p.y;\n\t\tthis.w = 1.0;\n\t} else if (arguments.length === 2) {\n\t\tif (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\") {\n\t\t\tvar _x = arguments[0],\n\t\t\t    _y = arguments[1];\n\t\t\tthis.x = _x;\n\t\t\tthis.y = _y;\n\t\t\tthis.w = 1.0;\n\t\t} else if (arguments[0] instanceof HCoordinate && arguments[1] instanceof HCoordinate) {\n\t\t\tvar p1 = arguments[0],\n\t\t\t    p2 = arguments[1];\n\t\t\tthis.x = p1.y * p2.w - p2.y * p1.w;\n\t\t\tthis.y = p2.x * p1.w - p1.x * p2.w;\n\t\t\tthis.w = p1.x * p2.y - p2.x * p1.y;\n\t\t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n\t\t\tvar p1 = arguments[0],\n\t\t\t    p2 = arguments[1];\n\t\t\tthis.x = p1.y - p2.y;\n\t\t\tthis.y = p2.x - p1.x;\n\t\t\tthis.w = p1.x * p2.y - p2.x * p1.y;\n\t\t}\n\t} else if (arguments.length === 3) {\n\t\tvar _x = arguments[0],\n\t\t    _y = arguments[1],\n\t\t    _w = arguments[2];\n\t\tthis.x = _x;\n\t\tthis.y = _y;\n\t\tthis.w = _w;\n\t} else if (arguments.length === 4) {\n\t\tvar p1 = arguments[0],\n\t\t    p2 = arguments[1],\n\t\t    q1 = arguments[2],\n\t\t    q2 = arguments[3];\n\t\tvar px = p1.y - p2.y;\n\t\tvar py = p2.x - p1.x;\n\t\tvar pw = p1.x * p2.y - p2.x * p1.y;\n\t\tvar qx = q1.y - q2.y;\n\t\tvar qy = q2.x - q1.x;\n\t\tvar qw = q1.x * q2.y - q2.x * q1.y;\n\t\tthis.x = py * qw - qy * pw;\n\t\tthis.y = qx * pw - px * qw;\n\t\tthis.w = px * qy - qx * py;\n\t}\n}\nextend(HCoordinate.prototype, {\n\tgetY: function getY() {\n\t\tvar a = this.y / this.w;\n\t\tif (Double.isNaN(a) || Double.isInfinite(a)) {\n\t\t\tthrow new NotRepresentableException();\n\t\t}\n\t\treturn a;\n\t},\n\tgetX: function getX() {\n\t\tvar a = this.x / this.w;\n\t\tif (Double.isNaN(a) || Double.isInfinite(a)) {\n\t\t\tthrow new NotRepresentableException();\n\t\t}\n\t\treturn a;\n\t},\n\tgetCoordinate: function getCoordinate() {\n\t\tvar p = new Coordinate();\n\t\tp.x = this.getX();\n\t\tp.y = this.getY();\n\t\treturn p;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn HCoordinate;\n\t}\n});\nHCoordinate.intersection = function (p1, p2, q1, q2) {\n\tvar px = p1.y - p2.y;\n\tvar py = p2.x - p1.x;\n\tvar pw = p1.x * p2.y - p2.x * p1.y;\n\tvar qx = q1.y - q2.y;\n\tvar qy = q2.x - q1.x;\n\tvar qw = q1.x * q2.y - q2.x * q1.y;\n\tvar x = py * qw - qy * pw;\n\tvar y = qx * pw - px * qw;\n\tvar w = px * qy - qx * py;\n\tvar xInt = x / w;\n\tvar yInt = y / w;\n\tif (Double.isNaN(xInt) || Double.isInfinite(xInt) || Double.isNaN(yInt) || Double.isInfinite(yInt)) {\n\t\tthrow new NotRepresentableException();\n\t}\n\treturn new Coordinate(xInt, yInt);\n};\n\nfunction CoordinateSequenceFactory() {}\nextend(CoordinateSequenceFactory.prototype, {\n\tcreate: function create() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Array) {\n\t\t\t\t\n\t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\t\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\t\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn CoordinateSequenceFactory;\n\t}\n});\n\nfunction GeometryComponentFilter() {}\nextend(GeometryComponentFilter.prototype, {\n\tfilter: function filter(geom) {},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn GeometryComponentFilter;\n\t}\n});\n\nfunction Geometry() {\n\tthis._envelope = null;\n\tthis._factory = null;\n\tthis._SRID = null;\n\tthis._userData = null;\n\tvar factory = arguments[0];\n\tthis._factory = factory;\n\tthis._SRID = factory.getSRID();\n}\nextend(Geometry.prototype, {\n\tisGeometryCollection: function isGeometryCollection() {\n\t\treturn this.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION;\n\t},\n\tgetFactory: function getFactory() {\n\t\treturn this._factory;\n\t},\n\tgetGeometryN: function getGeometryN(n) {\n\t\treturn this;\n\t},\n\tgetArea: function getArea() {\n\t\treturn 0.0;\n\t},\n\tisRectangle: function isRectangle() {\n\t\treturn false;\n\t},\n\tequals: function equals() {\n\t\tif (arguments[0] instanceof Geometry) {\n\t\t\tvar g = arguments[0];\n\t\t\tif (g === null) return false;\n\t\t\treturn this.equalsTopo(g);\n\t\t} else if (arguments[0] instanceof Object) {\n\t\t\tvar o = arguments[0];\n\t\t\tif (!(o instanceof Geometry)) return false;\n\t\t\tvar g = o;\n\t\t\treturn this.equalsExact(g);\n\t\t}\n\t},\n\tequalsExact: function equalsExact(other) {\n\t\treturn this === other || this.equalsExact(other, 0);\n\t},\n\tgeometryChanged: function geometryChanged() {\n\t\tthis.apply(Geometry.geometryChangedFilter);\n\t},\n\tgeometryChangedAction: function geometryChangedAction() {\n\t\tthis._envelope = null;\n\t},\n\tequalsNorm: function equalsNorm(g) {\n\t\tif (g === null) return false;\n\t\treturn this.norm().equalsExact(g.norm());\n\t},\n\tgetLength: function getLength() {\n\t\treturn 0.0;\n\t},\n\tgetNumGeometries: function getNumGeometries() {\n\t\treturn 1;\n\t},\n\tcompareTo: function compareTo() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar o = arguments[0];\n\t\t\tvar other = o;\n\t\t\tif (this.getSortIndex() !== other.getSortIndex()) {\n\t\t\t\treturn this.getSortIndex() - other.getSortIndex();\n\t\t\t}\n\t\t\tif (this.isEmpty() && other.isEmpty()) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (this.isEmpty()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (other.isEmpty()) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn this.compareToSameClass(o);\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar o = arguments[0],\n\t\t\t    comp = arguments[1];\n\t\t\tvar other = o;\n\t\t\tif (this.getSortIndex() !== other.getSortIndex()) {\n\t\t\t\treturn this.getSortIndex() - other.getSortIndex();\n\t\t\t}\n\t\t\tif (this.isEmpty() && other.isEmpty()) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (this.isEmpty()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (other.isEmpty()) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn this.compareToSameClass(o, comp);\n\t\t}\n\t},\n\tgetUserData: function getUserData() {\n\t\treturn this._userData;\n\t},\n\tgetSRID: function getSRID() {\n\t\treturn this._SRID;\n\t},\n\tgetEnvelope: function getEnvelope() {\n\t\treturn this.getFactory().toGeometry(this.getEnvelopeInternal());\n\t},\n\tcheckNotGeometryCollection: function checkNotGeometryCollection(g) {\n\t\tif (g.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION) {\n\t\t\tthrow new IllegalArgumentException(\"This method does not support GeometryCollection arguments\");\n\t\t}\n\t},\n\tequal: function equal(a, b, tolerance) {\n\t\tif (tolerance === 0) {\n\t\t\treturn a.equals(b);\n\t\t}\n\t\treturn a.distance(b) <= tolerance;\n\t},\n\tnorm: function norm() {\n\t\tvar copy = this.copy();\n\t\tcopy.normalize();\n\t\treturn copy;\n\t},\n\tgetPrecisionModel: function getPrecisionModel() {\n\t\treturn this._factory.getPrecisionModel();\n\t},\n\tgetEnvelopeInternal: function getEnvelopeInternal() {\n\t\tif (this._envelope === null) {\n\t\t\tthis._envelope = this.computeEnvelopeInternal();\n\t\t}\n\t\treturn new Envelope(this._envelope);\n\t},\n\tsetSRID: function setSRID(SRID) {\n\t\tthis._SRID = SRID;\n\t},\n\tsetUserData: function setUserData(userData) {\n\t\tthis._userData = userData;\n\t},\n\tcompare: function compare(a, b) {\n\t\tvar i = a.iterator();\n\t\tvar j = b.iterator();\n\t\twhile (i.hasNext() && j.hasNext()) {\n\t\t\tvar aElement = i.next();\n\t\t\tvar bElement = j.next();\n\t\t\tvar comparison = aElement.compareTo(bElement);\n\t\t\tif (comparison !== 0) {\n\t\t\t\treturn comparison;\n\t\t\t}\n\t\t}\n\t\tif (i.hasNext()) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (j.hasNext()) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t},\n\thashCode: function hashCode() {\n\t\treturn this.getEnvelopeInternal().hashCode();\n\t},\n\tisGeometryCollectionOrDerived: function isGeometryCollectionOrDerived() {\n\t\tif (this.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === Geometry.SORTINDEX_MULTIPOINT || this.getSortIndex() === Geometry.SORTINDEX_MULTILINESTRING || this.getSortIndex() === Geometry.SORTINDEX_MULTIPOLYGON) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Clonable, Comparable, Serializable];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Geometry;\n\t}\n});\nGeometry.hasNonEmptyElements = function (geometries) {\n\tfor (var i = 0; i < geometries.length; i++) {\n\t\tif (!geometries[i].isEmpty()) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n};\nGeometry.hasNullElements = function (array) {\n\tfor (var i = 0; i < array.length; i++) {\n\t\tif (array[i] === null) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n};\nGeometry.serialVersionUID = 8763622679187376702;\nGeometry.SORTINDEX_POINT = 0;\nGeometry.SORTINDEX_MULTIPOINT = 1;\nGeometry.SORTINDEX_LINESTRING = 2;\nGeometry.SORTINDEX_LINEARRING = 3;\nGeometry.SORTINDEX_MULTILINESTRING = 4;\nGeometry.SORTINDEX_POLYGON = 5;\nGeometry.SORTINDEX_MULTIPOLYGON = 6;\nGeometry.SORTINDEX_GEOMETRYCOLLECTION = 7;\nGeometry.geometryChangedFilter = {\n\tinterfaces_: function interfaces_() {\n\t\treturn [GeometryComponentFilter];\n\t},\n\tfilter: function filter(geom) {\n\t\tgeom.geometryChangedAction();\n\t}\n};\n\nfunction CoordinateFilter() {}\nextend(CoordinateFilter.prototype, {\n\tfilter: function filter(coord) {},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn CoordinateFilter;\n\t}\n});\n\nfunction BoundaryNodeRule() {}\nextend(BoundaryNodeRule.prototype, {\n\tisInBoundary: function isInBoundary(boundaryCount) {},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn BoundaryNodeRule;\n\t}\n});\nfunction Mod2BoundaryNodeRule() {}\nextend(Mod2BoundaryNodeRule.prototype, {\n\tisInBoundary: function isInBoundary(boundaryCount) {\n\t\treturn boundaryCount % 2 === 1;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [BoundaryNodeRule];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Mod2BoundaryNodeRule;\n\t}\n});\nfunction EndPointBoundaryNodeRule() {}\nextend(EndPointBoundaryNodeRule.prototype, {\n\tisInBoundary: function isInBoundary(boundaryCount) {\n\t\treturn boundaryCount > 0;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [BoundaryNodeRule];\n\t},\n\tgetClass: function getClass() {\n\t\treturn EndPointBoundaryNodeRule;\n\t}\n});\nfunction MultiValentEndPointBoundaryNodeRule() {}\nextend(MultiValentEndPointBoundaryNodeRule.prototype, {\n\tisInBoundary: function isInBoundary(boundaryCount) {\n\t\treturn boundaryCount > 1;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [BoundaryNodeRule];\n\t},\n\tgetClass: function getClass() {\n\t\treturn MultiValentEndPointBoundaryNodeRule;\n\t}\n});\nfunction MonoValentEndPointBoundaryNodeRule() {}\nextend(MonoValentEndPointBoundaryNodeRule.prototype, {\n\tisInBoundary: function isInBoundary(boundaryCount) {\n\t\treturn boundaryCount === 1;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [BoundaryNodeRule];\n\t},\n\tgetClass: function getClass() {\n\t\treturn MonoValentEndPointBoundaryNodeRule;\n\t}\n});\nBoundaryNodeRule.Mod2BoundaryNodeRule = Mod2BoundaryNodeRule;\nBoundaryNodeRule.EndPointBoundaryNodeRule = EndPointBoundaryNodeRule;\nBoundaryNodeRule.MultiValentEndPointBoundaryNodeRule = MultiValentEndPointBoundaryNodeRule;\nBoundaryNodeRule.MonoValentEndPointBoundaryNodeRule = MonoValentEndPointBoundaryNodeRule;\nBoundaryNodeRule.MOD2_BOUNDARY_RULE = new Mod2BoundaryNodeRule();\nBoundaryNodeRule.ENDPOINT_BOUNDARY_RULE = new EndPointBoundaryNodeRule();\nBoundaryNodeRule.MULTIVALENT_ENDPOINT_BOUNDARY_RULE = new MultiValentEndPointBoundaryNodeRule();\nBoundaryNodeRule.MONOVALENT_ENDPOINT_BOUNDARY_RULE = new MonoValentEndPointBoundaryNodeRule();\nBoundaryNodeRule.OGC_SFS_BOUNDARY_RULE = BoundaryNodeRule.MOD2_BOUNDARY_RULE;\n\nfunction CoordinateArrays() {}\nextend(CoordinateArrays.prototype, {\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn CoordinateArrays;\n\t}\n});\nCoordinateArrays.isRing = function (pts) {\n\tif (pts.length < 4) return false;\n\tif (!pts[0].equals2D(pts[pts.length - 1])) return false;\n\treturn true;\n};\nCoordinateArrays.ptNotInList = function (testPts, pts) {\n\tfor (var i = 0; i < testPts.length; i++) {\n\t\tvar testPt = testPts[i];\n\t\tif (CoordinateArrays.indexOf(testPt, pts) < 0) return testPt;\n\t}\n\treturn null;\n};\nCoordinateArrays.scroll = function (coordinates, firstCoordinate) {\n\tvar i = CoordinateArrays.indexOf(firstCoordinate, coordinates);\n\tif (i < 0) return null;\n\tvar newCoordinates = new Array(coordinates.length).fill(null);\n\tSystem.arraycopy(coordinates, i, newCoordinates, 0, coordinates.length - i);\n\tSystem.arraycopy(coordinates, 0, newCoordinates, coordinates.length - i, i);\n\tSystem.arraycopy(newCoordinates, 0, coordinates, 0, coordinates.length);\n};\nCoordinateArrays.equals = function () {\n\tif (arguments.length === 2) {\n\t\tvar coord1 = arguments[0],\n\t\t    coord2 = arguments[1];\n\t\tif (coord1 === coord2) return true;\n\t\tif (coord1 === null || coord2 === null) return false;\n\t\tif (coord1.length !== coord2.length) return false;\n\t\tfor (var i = 0; i < coord1.length; i++) {\n\t\t\tif (!coord1[i].equals(coord2[i])) return false;\n\t\t}\n\t\treturn true;\n\t} else if (arguments.length === 3) {\n\t\tvar coord1 = arguments[0],\n\t\t    coord2 = arguments[1],\n\t\t    coordinateComparator = arguments[2];\n\t\tif (coord1 === coord2) return true;\n\t\tif (coord1 === null || coord2 === null) return false;\n\t\tif (coord1.length !== coord2.length) return false;\n\t\tfor (var i = 0; i < coord1.length; i++) {\n\t\t\tif (coordinateComparator.compare(coord1[i], coord2[i]) !== 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n};\nCoordinateArrays.intersection = function (coordinates, env) {\n\tvar coordList = new CoordinateList();\n\tfor (var i = 0; i < coordinates.length; i++) {\n\t\tif (env.intersects(coordinates[i])) coordList.add(coordinates[i], true);\n\t}\n\treturn coordList.toCoordinateArray();\n};\nCoordinateArrays.hasRepeatedPoints = function (coord) {\n\tfor (var i = 1; i < coord.length; i++) {\n\t\tif (coord[i - 1].equals(coord[i])) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n};\nCoordinateArrays.removeRepeatedPoints = function (coord) {\n\tif (!CoordinateArrays.hasRepeatedPoints(coord)) return coord;\n\tvar coordList = new CoordinateList(coord, false);\n\treturn coordList.toCoordinateArray();\n};\nCoordinateArrays.reverse = function (coord) {\n\tvar last = coord.length - 1;\n\tvar mid = Math.trunc(last / 2);\n\tfor (var i = 0; i <= mid; i++) {\n\t\tvar tmp = coord[i];\n\t\tcoord[i] = coord[last - i];\n\t\tcoord[last - i] = tmp;\n\t}\n};\nCoordinateArrays.removeNull = function (coord) {\n\tvar nonNull = 0;\n\tfor (var i = 0; i < coord.length; i++) {\n\t\tif (coord[i] !== null) nonNull++;\n\t}\n\tvar newCoord = new Array(nonNull).fill(null);\n\tif (nonNull === 0) return newCoord;\n\tvar j = 0;\n\tfor (var i = 0; i < coord.length; i++) {\n\t\tif (coord[i] !== null) newCoord[j++] = coord[i];\n\t}\n\treturn newCoord;\n};\nCoordinateArrays.copyDeep = function () {\n\tif (arguments.length === 1) {\n\t\tvar coordinates = arguments[0];\n\t\tvar copy = new Array(coordinates.length).fill(null);\n\t\tfor (var i = 0; i < coordinates.length; i++) {\n\t\t\tcopy[i] = new Coordinate(coordinates[i]);\n\t\t}\n\t\treturn copy;\n\t} else if (arguments.length === 5) {\n\t\tvar src = arguments[0],\n\t\t    srcStart = arguments[1],\n\t\t    dest = arguments[2],\n\t\t    destStart = arguments[3],\n\t\t    length = arguments[4];\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tdest[destStart + i] = new Coordinate(src[srcStart + i]);\n\t\t}\n\t}\n};\nCoordinateArrays.isEqualReversed = function (pts1, pts2) {\n\tfor (var i = 0; i < pts1.length; i++) {\n\t\tvar p1 = pts1[i];\n\t\tvar p2 = pts2[pts1.length - i - 1];\n\t\tif (p1.compareTo(p2) !== 0) return false;\n\t}\n\treturn true;\n};\nCoordinateArrays.envelope = function (coordinates) {\n\tvar env = new Envelope();\n\tfor (var i = 0; i < coordinates.length; i++) {\n\t\tenv.expandToInclude(coordinates[i]);\n\t}\n\treturn env;\n};\nCoordinateArrays.toCoordinateArray = function (coordList) {\n\treturn coordList.toArray(CoordinateArrays.coordArrayType);\n};\nCoordinateArrays.atLeastNCoordinatesOrNothing = function (n, c) {\n\treturn c.length >= n ? c : [];\n};\nCoordinateArrays.indexOf = function (coordinate, coordinates) {\n\tfor (var i = 0; i < coordinates.length; i++) {\n\t\tif (coordinate.equals(coordinates[i])) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\nCoordinateArrays.increasingDirection = function (pts) {\n\tfor (var i = 0; i < Math.trunc(pts.length / 2); i++) {\n\t\tvar j = pts.length - 1 - i;\n\t\tvar comp = pts[i].compareTo(pts[j]);\n\t\tif (comp !== 0) return comp;\n\t}\n\treturn 1;\n};\nCoordinateArrays.compare = function (pts1, pts2) {\n\tvar i = 0;\n\twhile (i < pts1.length && i < pts2.length) {\n\t\tvar compare = pts1[i].compareTo(pts2[i]);\n\t\tif (compare !== 0) return compare;\n\t\ti++;\n\t}\n\tif (i < pts2.length) return -1;\n\tif (i < pts1.length) return 1;\n\treturn 0;\n};\nCoordinateArrays.minCoordinate = function (coordinates) {\n\tvar minCoord = null;\n\tfor (var i = 0; i < coordinates.length; i++) {\n\t\tif (minCoord === null || minCoord.compareTo(coordinates[i]) > 0) {\n\t\t\tminCoord = coordinates[i];\n\t\t}\n\t}\n\treturn minCoord;\n};\nCoordinateArrays.extract = function (pts, start, end) {\n\tstart = MathUtil.clamp(start, 0, pts.length);\n\tend = MathUtil.clamp(end, -1, pts.length);\n\tvar npts = end - start + 1;\n\tif (end < 0) npts = 0;\n\tif (start >= pts.length) npts = 0;\n\tif (end < start) npts = 0;\n\tvar extractPts = new Array(npts).fill(null);\n\tif (npts === 0) return extractPts;\n\tvar iPts = 0;\n\tfor (var i = start; i <= end; i++) {\n\t\textractPts[iPts++] = pts[i];\n\t}\n\treturn extractPts;\n};\nfunction ForwardComparator() {}\nextend(ForwardComparator.prototype, {\n\tcompare: function compare(o1, o2) {\n\t\tvar pts1 = o1;\n\t\tvar pts2 = o2;\n\t\treturn CoordinateArrays.compare(pts1, pts2);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Comparator];\n\t},\n\tgetClass: function getClass() {\n\t\treturn ForwardComparator;\n\t}\n});\nfunction BidirectionalComparator() {}\nextend(BidirectionalComparator.prototype, {\n\tcompare: function compare(o1, o2) {\n\t\tvar pts1 = o1;\n\t\tvar pts2 = o2;\n\t\tif (pts1.length < pts2.length) return -1;\n\t\tif (pts1.length > pts2.length) return 1;\n\t\tif (pts1.length === 0) return 0;\n\t\tvar forwardComp = CoordinateArrays.compare(pts1, pts2);\n\t\tvar isEqualRev = CoordinateArrays.isEqualReversed(pts1, pts2);\n\t\tif (isEqualRev) return 0;\n\t\treturn forwardComp;\n\t},\n\tOLDcompare: function OLDcompare(o1, o2) {\n\t\tvar pts1 = o1;\n\t\tvar pts2 = o2;\n\t\tif (pts1.length < pts2.length) return -1;\n\t\tif (pts1.length > pts2.length) return 1;\n\t\tif (pts1.length === 0) return 0;\n\t\tvar dir1 = CoordinateArrays.increasingDirection(pts1);\n\t\tvar dir2 = CoordinateArrays.increasingDirection(pts2);\n\t\tvar i1 = dir1 > 0 ? 0 : pts1.length - 1;\n\t\tvar i2 = dir2 > 0 ? 0 : pts1.length - 1;\n\t\tfor (var i = 0; i < pts1.length; i++) {\n\t\t\tvar comparePt = pts1[i1].compareTo(pts2[i2]);\n\t\t\tif (comparePt !== 0) return comparePt;\n\t\t\ti1 += dir1;\n\t\t\ti2 += dir2;\n\t\t}\n\t\treturn 0;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Comparator];\n\t},\n\tgetClass: function getClass() {\n\t\treturn BidirectionalComparator;\n\t}\n});\nCoordinateArrays.ForwardComparator = ForwardComparator;\nCoordinateArrays.BidirectionalComparator = BidirectionalComparator;\nCoordinateArrays.coordArrayType = new Array(0).fill(null);\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Map.html\n *\n * @constructor\n * @private\n */\nfunction Map$3() {}\n\n/**\n * Returns the value to which the specified key is mapped, or null if this map\n * contains no mapping for the key.\n * @param {Object} key\n * @return {Object}\n */\nMap$3.prototype.get = function () {};\n\n/**\n * Associates the specified value with the specified key in this map (optional\n * operation).\n * @param {Object} key\n * @param {Object} value\n * @return {Object}\n */\nMap$3.prototype.put = function () {};\n\n/**\n * Returns the number of key-value mappings in this map.\n * @return {number}\n */\nMap$3.prototype.size = function () {};\n\n/**\n * Returns a Collection view of the values contained in this map.\n * @return {javascript.util.Collection}\n */\nMap$3.prototype.values = function () {};\n\n/**\n * Returns a {@link Set} view of the mappings contained in this map.\n * The set is backed by the map, so changes to the map are\n * reflected in the set, and vice-versa.  If the map is modified\n * while an iteration over the set is in progress (except through\n * the iterator's own <tt>remove</tt> operation, or through the\n * <tt>setValue</tt> operation on a map entry returned by the\n * iterator) the results of the iteration are undefined.  The set\n * supports element removal, which removes the corresponding\n * mapping from the map, via the <tt>Iterator.remove</tt>,\n * <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt> and\n * <tt>clear</tt> operations.  It does not support the\n * <tt>add</tt> or <tt>addAll</tt> operations.\n *\n * @return {Set} a set view of the mappings contained in this map\n */\nMap$3.prototype.entrySet = function () {};\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedMap.html\n *\n * @extends {Map}\n * @constructor\n * @private\n */\nfunction SortedMap() {}\nSortedMap.prototype = new Map$3();\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Set.html\n *\n * @extends {Collection}\n * @constructor\n * @private\n */\nfunction Set$2() {}\nSet$2.prototype = new Collection();\n\n/**\n * Returns true if this set contains the specified element. More formally,\n * returns true if and only if this set contains an element e such that (o==null ?\n * e==null : o.equals(e)).\n * @param {Object} e\n * @return {boolean}\n */\nSet$2.prototype.contains = function () {};\n\n/**\n * @see http://docs.oracle.com/javase/6/docs/api/java/util/HashSet.html\n *\n * @extends {javascript.util.Set}\n * @constructor\n * @private\n */\nfunction HashSet() {\n  /**\n   * @type {Array}\n   * @private\n  */\n  this.array_ = [];\n\n  if (arguments[0] instanceof Collection) {\n    this.addAll(arguments[0]);\n  }\n}\nHashSet.prototype = new Set$2();\n\n/**\n * @override\n */\nHashSet.prototype.contains = function (o) {\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    var e = this.array_[i];\n    if (e === o) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * @override\n */\nHashSet.prototype.add = function (o) {\n  if (this.contains(o)) {\n    return false;\n  }\n\n  this.array_.push(o);\n\n  return true;\n};\n\n/**\n * @override\n */\nHashSet.prototype.addAll = function (c) {\n  for (var i = c.iterator(); i.hasNext();) {\n    this.add(i.next());\n  }\n  return true;\n};\n\n/**\n * @override\n */\nHashSet.prototype.remove = function (o) {\n  throw new javascript.util.OperationNotSupported();\n};\n\n/**\n * @override\n */\nHashSet.prototype.size = function () {\n  return this.array_.length;\n};\n\n/**\n * @override\n */\nHashSet.prototype.isEmpty = function () {\n  return this.array_.length === 0;\n};\n\n/**\n * @override\n */\nHashSet.prototype.toArray = function () {\n  var array = [];\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    array.push(this.array_[i]);\n  }\n\n  return array;\n};\n\n/**\n * @override\n */\nHashSet.prototype.iterator = function () {\n  return new Iterator_$1(this);\n};\n\n/**\n * @extends {Iterator}\n * @param {HashSet} hashSet\n * @constructor\n * @private\n */\nvar Iterator_$1 = function Iterator_(hashSet) {\n  /**\n   * @type {HashSet}\n   * @private\n   */\n  this.hashSet_ = hashSet;\n  /**\n   * @type {number}\n   * @private\n   */\n  this.position_ = 0;\n};\n\n/**\n * @override\n */\nIterator_$1.prototype.next = function () {\n  if (this.position_ === this.hashSet_.size()) {\n    throw new NoSuchElementException();\n  }\n  return this.hashSet_.array_[this.position_++];\n};\n\n/**\n * @override\n */\nIterator_$1.prototype.hasNext = function () {\n  if (this.position_ < this.hashSet_.size()) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\n/**\n * @override\n */\nIterator_$1.prototype.remove = function () {\n  throw new OperationNotSupported();\n};\n\nvar BLACK = 0;\nvar RED = 1;\nfunction colorOf(p) {\n  return p == null ? BLACK : p.color;\n}\nfunction parentOf(p) {\n  return p == null ? null : p.parent;\n}\nfunction setColor(p, c) {\n  if (p !== null) p.color = c;\n}\nfunction leftOf(p) {\n  return p == null ? null : p.left;\n}\nfunction rightOf(p) {\n  return p == null ? null : p.right;\n}\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeMap.html\n *\n * @extends {SortedMap}\n * @constructor\n * @private\n */\nfunction TreeMap() {\n  /**\n   * @type {Object}\n   * @private\n   */\n  this.root_ = null;\n  /**\n   * @type {number}\n   * @private\n  */\n  this.size_ = 0;\n}\nTreeMap.prototype = new SortedMap();\n\n/**\n * @override\n */\nTreeMap.prototype.get = function (key) {\n  var p = this.root_;\n  while (p !== null) {\n    var cmp = key['compareTo'](p.key);\n    if (cmp < 0) {\n      p = p.left;\n    } else if (cmp > 0) {\n      p = p.right;\n    } else {\n      return p.value;\n    }\n  }\n  return null;\n};\n\n/**\n * @override\n */\nTreeMap.prototype.put = function (key, value) {\n  if (this.root_ === null) {\n    this.root_ = {\n      key: key,\n      value: value,\n      left: null,\n      right: null,\n      parent: null,\n      color: BLACK,\n      getValue: function getValue() {\n        return this.value;\n      },\n      getKey: function getKey() {\n        return this.key;\n      }\n    };\n    this.size_ = 1;\n    return null;\n  }\n  var t = this.root_,\n      parent,\n      cmp;\n  do {\n    parent = t;\n    cmp = key['compareTo'](t.key);\n    if (cmp < 0) {\n      t = t.left;\n    } else if (cmp > 0) {\n      t = t.right;\n    } else {\n      var oldValue = t.value;\n      t.value = value;\n      return oldValue;\n    }\n  } while (t !== null);\n  var e = {\n    key: key,\n    left: null,\n    right: null,\n    value: value,\n    parent: parent,\n    color: BLACK,\n    getValue: function getValue() {\n      return this.value;\n    },\n    getKey: function getKey() {\n      return this.key;\n    }\n  };\n  if (cmp < 0) {\n    parent.left = e;\n  } else {\n    parent.right = e;\n  }\n  this.fixAfterInsertion(e);\n  this.size_++;\n  return null;\n};\n\n/**\n * @param {Object} x\n */\nTreeMap.prototype.fixAfterInsertion = function (x) {\n  x.color = RED;\n  while (x != null && x != this.root_ && x.parent.color == RED) {\n    if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {\n      var y = rightOf(parentOf(parentOf(x)));\n      if (colorOf(y) == RED) {\n        setColor(parentOf(x), BLACK);\n        setColor(y, BLACK);\n        setColor(parentOf(parentOf(x)), RED);\n        x = parentOf(parentOf(x));\n      } else {\n        if (x == rightOf(parentOf(x))) {\n          x = parentOf(x);\n          this.rotateLeft(x);\n        }\n        setColor(parentOf(x), BLACK);\n        setColor(parentOf(parentOf(x)), RED);\n        this.rotateRight(parentOf(parentOf(x)));\n      }\n    } else {\n      var y = leftOf(parentOf(parentOf(x)));\n      if (colorOf(y) == RED) {\n        setColor(parentOf(x), BLACK);\n        setColor(y, BLACK);\n        setColor(parentOf(parentOf(x)), RED);\n        x = parentOf(parentOf(x));\n      } else {\n        if (x == leftOf(parentOf(x))) {\n          x = parentOf(x);\n          this.rotateRight(x);\n        }\n        setColor(parentOf(x), BLACK);\n        setColor(parentOf(parentOf(x)), RED);\n        this.rotateLeft(parentOf(parentOf(x)));\n      }\n    }\n  }\n  this.root_.color = BLACK;\n};\n\n/**\n * @override\n */\nTreeMap.prototype.values = function () {\n  var arrayList = new ArrayList();\n  var p = this.getFirstEntry();\n  if (p !== null) {\n    arrayList.add(p.value);\n    while ((p = TreeMap.successor(p)) !== null) {\n      arrayList.add(p.value);\n    }\n  }\n  return arrayList;\n};\n\n/**\n * @override\n */\nTreeMap.prototype.entrySet = function () {\n  var hashSet = new HashSet();\n  var p = this.getFirstEntry();\n  if (p !== null) {\n    hashSet.add(p);\n    while ((p = TreeMap.successor(p)) !== null) {\n      hashSet.add(p);\n    }\n  }\n  return hashSet;\n};\n\n/**\n * @param {Object} p\n */\nTreeMap.prototype.rotateLeft = function (p) {\n  if (p != null) {\n    var r = p.right;\n    p.right = r.left;\n    if (r.left != null) r.left.parent = p;\n    r.parent = p.parent;\n    if (p.parent == null) this.root_ = r;else if (p.parent.left == p) p.parent.left = r;else p.parent.right = r;\n    r.left = p;\n    p.parent = r;\n  }\n};\n\n/**\n * @param {Object} p\n */\nTreeMap.prototype.rotateRight = function (p) {\n  if (p != null) {\n    var l = p.left;\n    p.left = l.right;\n    if (l.right != null) l.right.parent = p;\n    l.parent = p.parent;\n    if (p.parent == null) this.root_ = l;else if (p.parent.right == p) p.parent.right = l;else p.parent.left = l;\n    l.right = p;\n    p.parent = l;\n  }\n};\n\n/**\n * @return {Object}\n */\nTreeMap.prototype.getFirstEntry = function () {\n  var p = this.root_;\n  if (p != null) {\n    while (p.left != null) {\n      p = p.left;\n    }\n  }\n  return p;\n};\n\n/**\n * @param {Object} t\n * @return {Object}\n * @private\n */\nTreeMap.successor = function (t) {\n  if (t === null) return null;else if (t.right !== null) {\n    var p = t.right;\n    while (p.left !== null) {\n      p = p.left;\n    }\n    return p;\n  } else {\n    var p = t.parent;\n    var ch = t;\n    while (p !== null && ch === p.right) {\n      ch = p;\n      p = p.parent;\n    }\n    return p;\n  }\n};\n\n/**\n * @override\n */\nTreeMap.prototype.size = function () {\n  return this.size_;\n};\n\nfunction Lineal() {}\nextend(Lineal.prototype, {\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Lineal;\n\t}\n});\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedSet.html\n *\n * @extends {Set}\n * @constructor\n * @private\n */\nfunction SortedSet() {}\nSortedSet.prototype = new Set$2();\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeSet.html\n *\n * @extends {SortedSet}\n * @constructor\n * @private\n */\nfunction TreeSet() {\n  /**\n   * @type {Array}\n   * @private\n  */\n  this.array_ = [];\n\n  if (arguments[0] instanceof Collection) {\n    this.addAll(arguments[0]);\n  }\n}\nTreeSet.prototype = new SortedSet();\n\n/**\n * @override\n */\nTreeSet.prototype.contains = function (o) {\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    var e = this.array_[i];\n    if (e['compareTo'](o) === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * @override\n */\nTreeSet.prototype.add = function (o) {\n  if (this.contains(o)) {\n    return false;\n  }\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    var e = this.array_[i];\n    if (e['compareTo'](o) === 1) {\n      this.array_.splice(i, 0, o);\n      return true;\n    }\n  }\n\n  this.array_.push(o);\n\n  return true;\n};\n\n/**\n * @override\n */\nTreeSet.prototype.addAll = function (c) {\n  for (var i = c.iterator(); i.hasNext();) {\n    this.add(i.next());\n  }\n  return true;\n};\n\n/**\n * @override\n */\nTreeSet.prototype.remove = function (e) {\n  throw new OperationNotSupported();\n};\n\n/**\n * @override\n */\nTreeSet.prototype.size = function () {\n  return this.array_.length;\n};\n\n/**\n * @override\n */\nTreeSet.prototype.isEmpty = function () {\n  return this.array_.length === 0;\n};\n\n/**\n * @override\n */\nTreeSet.prototype.toArray = function () {\n  var array = [];\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    array.push(this.array_[i]);\n  }\n\n  return array;\n};\n\n/**\n * @override\n */\nTreeSet.prototype.iterator = function () {\n  return new Iterator_$2(this);\n};\n\n/**\n * @extends {javascript.util.Iterator}\n * @param {javascript.util.TreeSet} treeSet\n * @constructor\n * @private\n */\nvar Iterator_$2 = function Iterator_(treeSet) {\n  /**\n   * @type {javascript.util.TreeSet}\n   * @private\n   */\n  this.treeSet_ = treeSet;\n  /**\n   * @type {number}\n   * @private\n   */\n  this.position_ = 0;\n};\n\n/**\n * @override\n */\nIterator_$2.prototype.next = function () {\n  if (this.position_ === this.treeSet_.size()) {\n    throw new NoSuchElementException();\n  }\n  return this.treeSet_.array_[this.position_++];\n};\n\n/**\n * @override\n */\nIterator_$2.prototype.hasNext = function () {\n  if (this.position_ < this.treeSet_.size()) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\n/**\n * @override\n */\nIterator_$2.prototype.remove = function () {\n  throw new OperationNotSupported();\n};\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Arrays.html\n *\n * @constructor\n * @private\n */\nfunction Arrays() {}\n\n/**\n */\nArrays.sort = function () {\n  var a = arguments[0],\n      i,\n      t,\n      comparator,\n      compare;\n  if (arguments.length === 1) {\n    compare = function compare(a, b) {\n      return a.compareTo(b);\n    };\n    a.sort(compare);\n    return;\n  } else if (arguments.length === 2) {\n    comparator = arguments[1];\n    compare = function compare(a, b) {\n      return comparator['compare'](a, b);\n    };\n    a.sort(compare);\n  } else if (arguments.length === 3) {\n    t = a.slice(arguments[1], arguments[2]);\n    t.sort();\n    var r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));\n    a.splice(0, a.length);\n    for (i = 0; i < r.length; i++) {\n      a.push(r[i]);\n    }\n    return;\n  } else if (arguments.length === 4) {\n    t = a.slice(arguments[1], arguments[2]);\n    comparator = arguments[3];\n    compare = function compare(a, b) {\n      return comparator['compare'](a, b);\n    };\n    t.sort(compare);\n    r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));\n    a.splice(0, a.length);\n    for (i = 0; i < r.length; i++) {\n      a.push(r[i]);\n    }\n    return;\n  }\n};\n\n/**\n * @param {Array} array\n * @return {ArrayList}\n */\nArrays.asList = function (array) {\n  var arrayList = new ArrayList();\n  for (var i = 0, len = array.length; i < len; i++) {\n    arrayList.add(array[i]);\n  }\n  return arrayList;\n};\n\nfunction Dimension() {}\nextend(Dimension.prototype, {\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Dimension;\n\t}\n});\nDimension.toDimensionSymbol = function (dimensionValue) {\n\tswitch (dimensionValue) {\n\t\tcase Dimension.FALSE:\n\t\t\treturn Dimension.SYM_FALSE;\n\t\tcase Dimension.TRUE:\n\t\t\treturn Dimension.SYM_TRUE;\n\t\tcase Dimension.DONTCARE:\n\t\t\treturn Dimension.SYM_DONTCARE;\n\t\tcase Dimension.P:\n\t\t\treturn Dimension.SYM_P;\n\t\tcase Dimension.L:\n\t\t\treturn Dimension.SYM_L;\n\t\tcase Dimension.A:\n\t\t\treturn Dimension.SYM_A;\n\t}\n\tthrow new IllegalArgumentException(\"Unknown dimension value: \" + dimensionValue);\n};\nDimension.toDimensionValue = function (dimensionSymbol) {\n\tswitch (Character.toUpperCase(dimensionSymbol)) {\n\t\tcase Dimension.SYM_FALSE:\n\t\t\treturn Dimension.FALSE;\n\t\tcase Dimension.SYM_TRUE:\n\t\t\treturn Dimension.TRUE;\n\t\tcase Dimension.SYM_DONTCARE:\n\t\t\treturn Dimension.DONTCARE;\n\t\tcase Dimension.SYM_P:\n\t\t\treturn Dimension.P;\n\t\tcase Dimension.SYM_L:\n\t\t\treturn Dimension.L;\n\t\tcase Dimension.SYM_A:\n\t\t\treturn Dimension.A;\n\t}\n\tthrow new IllegalArgumentException(\"Unknown dimension symbol: \" + dimensionSymbol);\n};\nDimension.P = 0;\nDimension.L = 1;\nDimension.A = 2;\nDimension.FALSE = -1;\nDimension.TRUE = -2;\nDimension.DONTCARE = -3;\nDimension.SYM_FALSE = 'F';\nDimension.SYM_TRUE = 'T';\nDimension.SYM_DONTCARE = '*';\nDimension.SYM_P = '0';\nDimension.SYM_L = '1';\nDimension.SYM_A = '2';\n\nfunction GeometryFilter() {}\nextend(GeometryFilter.prototype, {\n\tfilter: function filter(geom) {},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn GeometryFilter;\n\t}\n});\n\nfunction CoordinateSequenceFilter() {}\nextend(CoordinateSequenceFilter.prototype, {\n\tfilter: function filter(seq, i) {},\n\tisDone: function isDone() {},\n\tisGeometryChanged: function isGeometryChanged() {},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn CoordinateSequenceFilter;\n\t}\n});\n\nfunction GeometryCollection() {\n\tthis._geometries = null;\n\tvar geometries = arguments[0],\n\t    factory = arguments[1];\n\tGeometry.call(this, factory);\n\tif (geometries === null) {\n\t\tgeometries = [];\n\t}\n\tif (Geometry.hasNullElements(geometries)) {\n\t\tthrow new IllegalArgumentException(\"geometries must not contain null elements\");\n\t}\n\tthis._geometries = geometries;\n}\ninherits$1(GeometryCollection, Geometry);\nextend(GeometryCollection.prototype, {\n\tcomputeEnvelopeInternal: function computeEnvelopeInternal() {\n\t\tvar envelope = new Envelope();\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tenvelope.expandToInclude(this._geometries[i].getEnvelopeInternal());\n\t\t}\n\t\treturn envelope;\n\t},\n\tgetGeometryN: function getGeometryN(n) {\n\t\treturn this._geometries[n];\n\t},\n\tgetSortIndex: function getSortIndex() {\n\t\treturn Geometry.SORTINDEX_GEOMETRYCOLLECTION;\n\t},\n\tgetCoordinates: function getCoordinates() {\n\t\tvar coordinates = new Array(this.getNumPoints()).fill(null);\n\t\tvar k = -1;\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tvar childCoordinates = this._geometries[i].getCoordinates();\n\t\t\tfor (var j = 0; j < childCoordinates.length; j++) {\n\t\t\t\tk++;\n\t\t\t\tcoordinates[k] = childCoordinates[j];\n\t\t\t}\n\t\t}\n\t\treturn coordinates;\n\t},\n\tgetArea: function getArea() {\n\t\tvar area = 0.0;\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tarea += this._geometries[i].getArea();\n\t\t}\n\t\treturn area;\n\t},\n\tequalsExact: function equalsExact() {\n\t\tif (arguments.length === 2) {\n\t\t\tvar other = arguments[0],\n\t\t\t    tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar otherCollection = other;\n\t\t\tif (this._geometries.length !== otherCollection._geometries.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\t\tif (!this._geometries[i].equalsExact(otherCollection._geometries[i], tolerance)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else return Geometry.prototype.equalsExact.apply(this, arguments);\n\t},\n\tnormalize: function normalize() {\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tthis._geometries[i].normalize();\n\t\t}\n\t\tArrays.sort(this._geometries);\n\t},\n\tgetCoordinate: function getCoordinate() {\n\t\tif (this.isEmpty()) return null;\n\t\treturn this._geometries[0].getCoordinate();\n\t},\n\tgetBoundaryDimension: function getBoundaryDimension() {\n\t\tvar dimension = Dimension.FALSE;\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tdimension = Math.max(dimension, this._geometries[i].getBoundaryDimension());\n\t\t}\n\t\treturn dimension;\n\t},\n\tgetDimension: function getDimension() {\n\t\tvar dimension = Dimension.FALSE;\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tdimension = Math.max(dimension, this._geometries[i].getDimension());\n\t\t}\n\t\treturn dimension;\n\t},\n\tgetLength: function getLength() {\n\t\tvar sum = 0.0;\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tsum += this._geometries[i].getLength();\n\t\t}\n\t\treturn sum;\n\t},\n\tgetNumPoints: function getNumPoints() {\n\t\tvar numPoints = 0;\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tnumPoints += this._geometries[i].getNumPoints();\n\t\t}\n\t\treturn numPoints;\n\t},\n\tgetNumGeometries: function getNumGeometries() {\n\t\treturn this._geometries.length;\n\t},\n\treverse: function reverse() {\n\t\tvar n = this._geometries.length;\n\t\tvar revGeoms = new Array(n).fill(null);\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\trevGeoms[i] = this._geometries[i].reverse();\n\t\t}\n\t\treturn this.getFactory().createGeometryCollection(revGeoms);\n\t},\n\tcompareToSameClass: function compareToSameClass() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar o = arguments[0];\n\t\t\tvar theseElements = new TreeSet(Arrays.asList(this._geometries));\n\t\t\tvar otherElements = new TreeSet(Arrays.asList(o._geometries));\n\t\t\treturn this.compare(theseElements, otherElements);\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar o = arguments[0],\n\t\t\t    comp = arguments[1];\n\t\t\tvar gc = o;\n\t\t\tvar n1 = this.getNumGeometries();\n\t\t\tvar n2 = gc.getNumGeometries();\n\t\t\tvar i = 0;\n\t\t\twhile (i < n1 && i < n2) {\n\t\t\t\tvar thisGeom = this.getGeometryN(i);\n\t\t\t\tvar otherGeom = gc.getGeometryN(i);\n\t\t\t\tvar holeComp = thisGeom.compareToSameClass(otherGeom, comp);\n\t\t\t\tif (holeComp !== 0) return holeComp;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (i < n1) return 1;\n\t\t\tif (i < n2) return -1;\n\t\t\treturn 0;\n\t\t}\n\t},\n\tapply: function apply() {\n\t\tif (hasInterface(arguments[0], CoordinateFilter)) {\n\t\t\tvar filter = arguments[0];\n\t\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\t\tthis._geometries[i].apply(filter);\n\t\t\t}\n\t\t} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n\t\t\tvar filter = arguments[0];\n\t\t\tif (this._geometries.length === 0) return null;\n\t\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\t\tthis._geometries[i].apply(filter);\n\t\t\t\tif (filter.isDone()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (filter.isGeometryChanged()) this.geometryChanged();\n\t\t} else if (hasInterface(arguments[0], GeometryFilter)) {\n\t\t\tvar filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\t\tthis._geometries[i].apply(filter);\n\t\t\t}\n\t\t} else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n\t\t\tvar filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\t\tthis._geometries[i].apply(filter);\n\t\t\t}\n\t\t}\n\t},\n\tgetBoundary: function getBoundary() {\n\t\tthis.checkNotGeometryCollection(this);\n\t\tAssert.shouldNeverReachHere();\n\t\treturn null;\n\t},\n\tclone: function clone() {\n\t\tvar gc = Geometry.prototype.clone.call(this);\n\t\tgc._geometries = new Array(this._geometries.length).fill(null);\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tgc._geometries[i] = this._geometries[i].clone();\n\t\t}\n\t\treturn gc;\n\t},\n\tgetGeometryType: function getGeometryType() {\n\t\treturn \"GeometryCollection\";\n\t},\n\tcopy: function copy() {\n\t\tvar geometries = new Array(this._geometries.length).fill(null);\n\t\tfor (var i = 0; i < geometries.length; i++) {\n\t\t\tgeometries[i] = this._geometries[i].copy();\n\t\t}\n\t\treturn new GeometryCollection(geometries, this._factory);\n\t},\n\tisEmpty: function isEmpty() {\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tif (!this._geometries[i].isEmpty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn GeometryCollection;\n\t}\n});\nGeometryCollection.serialVersionUID = -5694727726395021467;\n\nfunction MultiLineString() {\n\tvar lineStrings = arguments[0],\n\t    factory = arguments[1];\n\tGeometryCollection.call(this, lineStrings, factory);\n}\ninherits$1(MultiLineString, GeometryCollection);\nextend(MultiLineString.prototype, {\n\tgetSortIndex: function getSortIndex() {\n\t\treturn Geometry.SORTINDEX_MULTILINESTRING;\n\t},\n\tequalsExact: function equalsExact() {\n\t\tif (arguments.length === 2) {\n\t\t\tvar other = arguments[0],\n\t\t\t    tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn GeometryCollection.prototype.equalsExact.call(this, other, tolerance);\n\t\t} else return GeometryCollection.prototype.equalsExact.apply(this, arguments);\n\t},\n\tgetBoundaryDimension: function getBoundaryDimension() {\n\t\tif (this.isClosed()) {\n\t\t\treturn Dimension.FALSE;\n\t\t}\n\t\treturn 0;\n\t},\n\tisClosed: function isClosed() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tif (!this._geometries[i].isClosed()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t},\n\tgetDimension: function getDimension() {\n\t\treturn 1;\n\t},\n\treverse: function reverse() {\n\t\tvar nLines = this._geometries.length;\n\t\tvar revLines = new Array(nLines).fill(null);\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\trevLines[nLines - 1 - i] = this._geometries[i].reverse();\n\t\t}\n\t\treturn this.getFactory().createMultiLineString(revLines);\n\t},\n\tgetBoundary: function getBoundary() {\n\t\treturn new BoundaryOp(this).getBoundary();\n\t},\n\tgetGeometryType: function getGeometryType() {\n\t\treturn \"MultiLineString\";\n\t},\n\tcopy: function copy() {\n\t\tvar lineStrings = new Array(this._geometries.length).fill(null);\n\t\tfor (var i = 0; i < lineStrings.length; i++) {\n\t\t\tlineStrings[i] = this._geometries[i].copy();\n\t\t}\n\t\treturn new MultiLineString(lineStrings, this._factory);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Lineal];\n\t},\n\tgetClass: function getClass() {\n\t\treturn MultiLineString;\n\t}\n});\nMultiLineString.serialVersionUID = 8166665132445433741;\n\nfunction BoundaryOp() {\n\tthis._geom = null;\n\tthis._geomFact = null;\n\tthis._bnRule = null;\n\tthis._endpointMap = null;\n\tif (arguments.length === 1) {\n\t\tvar geom = arguments[0];\n\t\tBoundaryOp.call(this, geom, BoundaryNodeRule.MOD2_BOUNDARY_RULE);\n\t} else if (arguments.length === 2) {\n\t\tvar geom = arguments[0],\n\t\t    bnRule = arguments[1];\n\t\tthis._geom = geom;\n\t\tthis._geomFact = geom.getFactory();\n\t\tthis._bnRule = bnRule;\n\t}\n}\nextend(BoundaryOp.prototype, {\n\tboundaryMultiLineString: function boundaryMultiLineString(mLine) {\n\t\tif (this._geom.isEmpty()) {\n\t\t\treturn this.getEmptyMultiPoint();\n\t\t}\n\t\tvar bdyPts = this.computeBoundaryCoordinates(mLine);\n\t\tif (bdyPts.length === 1) {\n\t\t\treturn this._geomFact.createPoint(bdyPts[0]);\n\t\t}\n\t\treturn this._geomFact.createMultiPointFromCoords(bdyPts);\n\t},\n\tgetBoundary: function getBoundary() {\n\t\tif (this._geom instanceof LineString) return this.boundaryLineString(this._geom);\n\t\tif (this._geom instanceof MultiLineString) return this.boundaryMultiLineString(this._geom);\n\t\treturn this._geom.getBoundary();\n\t},\n\tboundaryLineString: function boundaryLineString(line) {\n\t\tif (this._geom.isEmpty()) {\n\t\t\treturn this.getEmptyMultiPoint();\n\t\t}\n\t\tif (line.isClosed()) {\n\t\t\tvar closedEndpointOnBoundary = this._bnRule.isInBoundary(2);\n\t\t\tif (closedEndpointOnBoundary) {\n\t\t\t\treturn line.getStartPoint();\n\t\t\t} else {\n\t\t\t\treturn this._geomFact.createMultiPoint();\n\t\t\t}\n\t\t}\n\t\treturn this._geomFact.createMultiPoint([line.getStartPoint(), line.getEndPoint()]);\n\t},\n\tgetEmptyMultiPoint: function getEmptyMultiPoint() {\n\t\treturn this._geomFact.createMultiPoint();\n\t},\n\tcomputeBoundaryCoordinates: function computeBoundaryCoordinates(mLine) {\n\t\tvar bdyPts = new ArrayList();\n\t\tthis._endpointMap = new TreeMap();\n\t\tfor (var i = 0; i < mLine.getNumGeometries(); i++) {\n\t\t\tvar line = mLine.getGeometryN(i);\n\t\t\tif (line.getNumPoints() === 0) continue;\n\t\t\tthis.addEndpoint(line.getCoordinateN(0));\n\t\t\tthis.addEndpoint(line.getCoordinateN(line.getNumPoints() - 1));\n\t\t}\n\t\tfor (var it = this._endpointMap.entrySet().iterator(); it.hasNext();) {\n\t\t\tvar entry = it.next();\n\t\t\tvar counter = entry.getValue();\n\t\t\tvar valence = counter.count;\n\t\t\tif (this._bnRule.isInBoundary(valence)) {\n\t\t\t\tbdyPts.add(entry.getKey());\n\t\t\t}\n\t\t}\n\t\treturn CoordinateArrays.toCoordinateArray(bdyPts);\n\t},\n\taddEndpoint: function addEndpoint(pt) {\n\t\tvar counter = this._endpointMap.get(pt);\n\t\tif (counter === null) {\n\t\t\tcounter = new Counter();\n\t\t\tthis._endpointMap.put(pt, counter);\n\t\t}\n\t\tcounter.count++;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn BoundaryOp;\n\t}\n});\nBoundaryOp.getBoundary = function () {\n\tif (arguments.length === 1) {\n\t\tvar g = arguments[0];\n\t\tvar bop = new BoundaryOp(g);\n\t\treturn bop.getBoundary();\n\t} else if (arguments.length === 2) {\n\t\tvar g = arguments[0],\n\t\t    bnRule = arguments[1];\n\t\tvar bop = new BoundaryOp(g, bnRule);\n\t\treturn bop.getBoundary();\n\t}\n};\nfunction Counter() {\n\tthis.count = null;\n}\nextend(Counter.prototype, {\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Counter;\n\t}\n});\n\nfunction PrintStream() {}\n\nfunction StringReader() {}\n\nfunction DecimalFormat() {}\n\nfunction ByteArrayOutputStream() {}\n\nfunction IOException() {}\n\nfunction LineNumberReader() {}\n\nfunction StringUtil() {}\nextend(StringUtil.prototype, {\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn StringUtil;\n\t}\n});\nStringUtil.chars = function (c, n) {\n\tvar ch = new Array(n).fill(null);\n\tfor (var i = 0; i < n; i++) {\n\t\tch[i] = c;\n\t}\n\treturn new String(ch);\n};\nStringUtil.getStackTrace = function () {\n\tif (arguments.length === 1) {\n\t\tvar t = arguments[0];\n\t\tvar os = new ByteArrayOutputStream();\n\t\tvar ps = new PrintStream(os);\n\t\tt.printStackTrace(ps);\n\t\treturn os.toString();\n\t} else if (arguments.length === 2) {\n\t\tvar t = arguments[0],\n\t\t    depth = arguments[1];\n\t\tvar stackTrace = \"\";\n\t\tvar stringReader = new StringReader(StringUtil.getStackTrace(t));\n\t\tvar lineNumberReader = new LineNumberReader(stringReader);\n\t\tfor (var i = 0; i < depth; i++) {\n\t\t\ttry {\n\t\t\t\tstackTrace += lineNumberReader.readLine() + StringUtil.NEWLINE;\n\t\t\t} catch (e) {\n\t\t\t\tif (e instanceof IOException) {\n\t\t\t\t\tAssert.shouldNeverReachHere();\n\t\t\t\t} else throw e;\n\t\t\t} finally {}\n\t\t}\n\t\treturn stackTrace;\n\t}\n};\nStringUtil.split = function (s, separator) {\n\tvar separatorlen = separator.length;\n\tvar tokenList = new ArrayList();\n\tvar tmpString = \"\" + s;\n\tvar pos = tmpString.indexOf(separator);\n\twhile (pos >= 0) {\n\t\tvar token = tmpString.substring(0, pos);\n\t\ttokenList.add(token);\n\t\ttmpString = tmpString.substring(pos + separatorlen);\n\t\tpos = tmpString.indexOf(separator);\n\t}\n\tif (tmpString.length > 0) tokenList.add(tmpString);\n\tvar res = new Array(tokenList.size()).fill(null);\n\tfor (var i = 0; i < res.length; i++) {\n\t\tres[i] = tokenList.get(i);\n\t}\n\treturn res;\n};\nStringUtil.toString = function () {\n\tif (arguments.length === 1) {\n\t\tvar d = arguments[0];\n\t\treturn StringUtil.SIMPLE_ORDINATE_FORMAT.format(d);\n\t}\n};\nStringUtil.spaces = function (n) {\n\treturn StringUtil.chars(' ', n);\n};\nStringUtil.NEWLINE = System.getProperty(\"line.separator\");\nStringUtil.SIMPLE_ORDINATE_FORMAT = new DecimalFormat(\"0.#\");\n\nfunction CoordinateSequences() {}\nextend(CoordinateSequences.prototype, {\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn CoordinateSequences;\n\t}\n});\nCoordinateSequences.copyCoord = function (src, srcPos, dest, destPos) {\n\tvar minDim = Math.min(src.getDimension(), dest.getDimension());\n\tfor (var dim = 0; dim < minDim; dim++) {\n\t\tdest.setOrdinate(destPos, dim, src.getOrdinate(srcPos, dim));\n\t}\n};\nCoordinateSequences.isRing = function (seq) {\n\tvar n = seq.size();\n\tif (n === 0) return true;\n\tif (n <= 3) return false;\n\treturn seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);\n};\nCoordinateSequences.isEqual = function (cs1, cs2) {\n\tvar cs1Size = cs1.size();\n\tvar cs2Size = cs2.size();\n\tif (cs1Size !== cs2Size) return false;\n\tvar dim = Math.min(cs1.getDimension(), cs2.getDimension());\n\tfor (var i = 0; i < cs1Size; i++) {\n\t\tfor (var d = 0; d < dim; d++) {\n\t\t\tvar v1 = cs1.getOrdinate(i, d);\n\t\t\tvar v2 = cs2.getOrdinate(i, d);\n\t\t\tif (cs1.getOrdinate(i, d) === cs2.getOrdinate(i, d)) continue;\n\t\t\tif (Double.isNaN(v1) && Double.isNaN(v2)) continue;\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n};\nCoordinateSequences.extend = function (fact, seq, size) {\n\tvar newseq = fact.create(size, seq.getDimension());\n\tvar n = seq.size();\n\tCoordinateSequences.copy(seq, 0, newseq, 0, n);\n\tif (n > 0) {\n\t\tfor (var i = n; i < size; i++) {\n\t\t\tCoordinateSequences.copy(seq, n - 1, newseq, i, 1);\n\t\t}\n\t}\n\treturn newseq;\n};\nCoordinateSequences.reverse = function (seq) {\n\tvar last = seq.size() - 1;\n\tvar mid = Math.trunc(last / 2);\n\tfor (var i = 0; i <= mid; i++) {\n\t\tCoordinateSequences.swap(seq, i, last - i);\n\t}\n};\nCoordinateSequences.swap = function (seq, i, j) {\n\tif (i === j) return null;\n\tfor (var dim = 0; dim < seq.getDimension(); dim++) {\n\t\tvar tmp = seq.getOrdinate(i, dim);\n\t\tseq.setOrdinate(i, dim, seq.getOrdinate(j, dim));\n\t\tseq.setOrdinate(j, dim, tmp);\n\t}\n};\nCoordinateSequences.copy = function (src, srcPos, dest, destPos, length) {\n\tfor (var i = 0; i < length; i++) {\n\t\tCoordinateSequences.copyCoord(src, srcPos + i, dest, destPos + i);\n\t}\n};\nCoordinateSequences.toString = function () {\n\tif (arguments.length === 1) {\n\t\tvar cs = arguments[0];\n\t\tvar size = cs.size();\n\t\tif (size === 0) return \"()\";\n\t\tvar dim = cs.getDimension();\n\t\tvar buf = new StringBuffer();\n\t\tbuf.append('(');\n\t\tfor (var i = 0; i < size; i++) {\n\t\t\tif (i > 0) buf.append(\" \");\n\t\t\tfor (var d = 0; d < dim; d++) {\n\t\t\t\tif (d > 0) buf.append(\",\");\n\t\t\t\tbuf.append(StringUtil.toString(cs.getOrdinate(i, d)));\n\t\t\t}\n\t\t}\n\t\tbuf.append(')');\n\t\treturn buf.toString();\n\t}\n};\nCoordinateSequences.ensureValidRing = function (fact, seq) {\n\tvar n = seq.size();\n\tif (n === 0) return seq;\n\tif (n <= 3) return CoordinateSequences.createClosedRing(fact, seq, 4);\n\tvar isClosed = seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);\n\tif (isClosed) return seq;\n\treturn CoordinateSequences.createClosedRing(fact, seq, n + 1);\n};\nCoordinateSequences.createClosedRing = function (fact, seq, size) {\n\tvar newseq = fact.create(size, seq.getDimension());\n\tvar n = seq.size();\n\tCoordinateSequences.copy(seq, 0, newseq, 0, n);\n\tfor (var i = n; i < size; i++) {\n\t\tCoordinateSequences.copy(seq, 0, newseq, i, 1);\n\t}return newseq;\n};\n\nfunction LineString() {\n\tthis._points = null;\n\tvar points = arguments[0],\n\t    factory = arguments[1];\n\tGeometry.call(this, factory);\n\tthis.init(points);\n}\ninherits$1(LineString, Geometry);\nextend(LineString.prototype, {\n\tcomputeEnvelopeInternal: function computeEnvelopeInternal() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn new Envelope();\n\t\t}\n\t\treturn this._points.expandEnvelope(new Envelope());\n\t},\n\tisRing: function isRing() {\n\t\treturn this.isClosed() && this.isSimple();\n\t},\n\tgetSortIndex: function getSortIndex() {\n\t\treturn Geometry.SORTINDEX_LINESTRING;\n\t},\n\tgetCoordinates: function getCoordinates() {\n\t\treturn this._points.toCoordinateArray();\n\t},\n\tequalsExact: function equalsExact() {\n\t\tif (arguments.length === 2) {\n\t\t\tvar other = arguments[0],\n\t\t\t    tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar otherLineString = other;\n\t\t\tif (this._points.size() !== otherLineString._points.size()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (var i = 0; i < this._points.size(); i++) {\n\t\t\t\tif (!this.equal(this._points.getCoordinate(i), otherLineString._points.getCoordinate(i), tolerance)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else return Geometry.prototype.equalsExact.apply(this, arguments);\n\t},\n\tnormalize: function normalize() {\n\t\tfor (var i = 0; i < Math.trunc(this._points.size() / 2); i++) {\n\t\t\tvar j = this._points.size() - 1 - i;\n\t\t\tif (!this._points.getCoordinate(i).equals(this._points.getCoordinate(j))) {\n\t\t\t\tif (this._points.getCoordinate(i).compareTo(this._points.getCoordinate(j)) > 0) {\n\t\t\t\t\tCoordinateSequences.reverse(this._points);\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t},\n\tgetCoordinate: function getCoordinate() {\n\t\tif (this.isEmpty()) return null;\n\t\treturn this._points.getCoordinate(0);\n\t},\n\tgetBoundaryDimension: function getBoundaryDimension() {\n\t\tif (this.isClosed()) {\n\t\t\treturn Dimension.FALSE;\n\t\t}\n\t\treturn 0;\n\t},\n\tisClosed: function isClosed() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));\n\t},\n\tgetEndPoint: function getEndPoint() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.getPointN(this.getNumPoints() - 1);\n\t},\n\tgetDimension: function getDimension() {\n\t\treturn 1;\n\t},\n\tgetLength: function getLength() {\n\t\treturn CGAlgorithms.computeLength(this._points);\n\t},\n\tgetNumPoints: function getNumPoints() {\n\t\treturn this._points.size();\n\t},\n\treverse: function reverse() {\n\t\tvar seq = this._points.copy();\n\t\tCoordinateSequences.reverse(seq);\n\t\tvar revLine = this.getFactory().createLineString(seq);\n\t\treturn revLine;\n\t},\n\tcompareToSameClass: function compareToSameClass() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar o = arguments[0];\n\t\t\tvar line = o;\n\t\t\tvar i = 0;\n\t\t\tvar j = 0;\n\t\t\twhile (i < this._points.size() && j < line._points.size()) {\n\t\t\t\tvar comparison = this._points.getCoordinate(i).compareTo(line._points.getCoordinate(j));\n\t\t\t\tif (comparison !== 0) {\n\t\t\t\t\treturn comparison;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tif (i < this._points.size()) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (j < line._points.size()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar o = arguments[0],\n\t\t\t    comp = arguments[1];\n\t\t\tvar line = o;\n\t\t\treturn comp.compare(this._points, line._points);\n\t\t}\n\t},\n\tapply: function apply() {\n\t\tif (hasInterface(arguments[0], CoordinateFilter)) {\n\t\t\tvar filter = arguments[0];\n\t\t\tfor (var i = 0; i < this._points.size(); i++) {\n\t\t\t\tfilter.filter(this._points.getCoordinate(i));\n\t\t\t}\n\t\t} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n\t\t\tvar filter = arguments[0];\n\t\t\tif (this._points.size() === 0) return null;\n\t\t\tfor (var i = 0; i < this._points.size(); i++) {\n\t\t\t\tfilter.filter(this._points, i);\n\t\t\t\tif (filter.isDone()) break;\n\t\t\t}\n\t\t\tif (filter.isGeometryChanged()) this.geometryChanged();\n\t\t} else if (hasInterface(arguments[0], GeometryFilter)) {\n\t\t\tvar filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t} else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n\t\t\tvar filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t}\n\t},\n\tgetBoundary: function getBoundary() {\n\t\treturn new BoundaryOp(this).getBoundary();\n\t},\n\tisEquivalentClass: function isEquivalentClass(other) {\n\t\treturn other instanceof LineString;\n\t},\n\tclone: function clone() {\n\t\tvar ls = Geometry.prototype.clone.call(this);\n\t\tls._points = this._points.clone();\n\t\treturn ls;\n\t},\n\tgetCoordinateN: function getCoordinateN(n) {\n\t\treturn this._points.getCoordinate(n);\n\t},\n\tgetGeometryType: function getGeometryType() {\n\t\treturn \"LineString\";\n\t},\n\tcopy: function copy() {\n\t\treturn new LineString(this._points.copy(), this._factory);\n\t},\n\tgetCoordinateSequence: function getCoordinateSequence() {\n\t\treturn this._points;\n\t},\n\tisEmpty: function isEmpty() {\n\t\treturn this._points.size() === 0;\n\t},\n\tinit: function init(points) {\n\t\tif (points === null) {\n\t\t\tpoints = this.getFactory().getCoordinateSequenceFactory().create([]);\n\t\t}\n\t\tif (points.size() === 1) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid number of points in LineString (found \" + points.size() + \" - must be 0 or >= 2)\");\n\t\t}\n\t\tthis._points = points;\n\t},\n\tisCoordinate: function isCoordinate(pt) {\n\t\tfor (var i = 0; i < this._points.size(); i++) {\n\t\t\tif (this._points.getCoordinate(i).equals(pt)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tgetStartPoint: function getStartPoint() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.getPointN(0);\n\t},\n\tgetPointN: function getPointN(n) {\n\t\treturn this.getFactory().createPoint(this._points.getCoordinate(n));\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Lineal];\n\t},\n\tgetClass: function getClass() {\n\t\treturn LineString;\n\t}\n});\nLineString.serialVersionUID = 3110669828065365560;\n\nfunction Puntal() {}\nextend(Puntal.prototype, {\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Puntal;\n\t}\n});\n\nfunction Point() {\n\tthis._coordinates = null;\n\tvar coordinates = arguments[0],\n\t    factory = arguments[1];\n\tGeometry.call(this, factory);\n\tthis.init(coordinates);\n}\ninherits$1(Point, Geometry);\nextend(Point.prototype, {\n\tcomputeEnvelopeInternal: function computeEnvelopeInternal() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn new Envelope();\n\t\t}\n\t\tvar env = new Envelope();\n\t\tenv.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0));\n\t\treturn env;\n\t},\n\tgetSortIndex: function getSortIndex() {\n\t\treturn Geometry.SORTINDEX_POINT;\n\t},\n\tgetCoordinates: function getCoordinates() {\n\t\treturn this.isEmpty() ? [] : [this.getCoordinate()];\n\t},\n\tequalsExact: function equalsExact() {\n\t\tif (arguments.length === 2) {\n\t\t\tvar other = arguments[0],\n\t\t\t    tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (this.isEmpty() && other.isEmpty()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (this.isEmpty() !== other.isEmpty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn this.equal(other.getCoordinate(), this.getCoordinate(), tolerance);\n\t\t} else return Geometry.prototype.equalsExact.apply(this, arguments);\n\t},\n\tnormalize: function normalize() {},\n\tgetCoordinate: function getCoordinate() {\n\t\treturn this._coordinates.size() !== 0 ? this._coordinates.getCoordinate(0) : null;\n\t},\n\tgetBoundaryDimension: function getBoundaryDimension() {\n\t\treturn Dimension.FALSE;\n\t},\n\tgetDimension: function getDimension() {\n\t\treturn 0;\n\t},\n\tgetNumPoints: function getNumPoints() {\n\t\treturn this.isEmpty() ? 0 : 1;\n\t},\n\treverse: function reverse() {\n\t\treturn this.copy();\n\t},\n\tgetX: function getX() {\n\t\tif (this.getCoordinate() === null) {\n\t\t\tthrow new IllegalStateException(\"getX called on empty Point\");\n\t\t}\n\t\treturn this.getCoordinate().x;\n\t},\n\tcompareToSameClass: function compareToSameClass() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar other = arguments[0];\n\t\t\tvar point = other;\n\t\t\treturn this.getCoordinate().compareTo(point.getCoordinate());\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar other = arguments[0],\n\t\t\t    comp = arguments[1];\n\t\t\tvar point = other;\n\t\t\treturn comp.compare(this._coordinates, point._coordinates);\n\t\t}\n\t},\n\tapply: function apply() {\n\t\tif (hasInterface(arguments[0], CoordinateFilter)) {\n\t\t\tvar filter = arguments[0];\n\t\t\tif (this.isEmpty()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tfilter.filter(this.getCoordinate());\n\t\t} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n\t\t\tvar filter = arguments[0];\n\t\t\tif (this.isEmpty()) return null;\n\t\t\tfilter.filter(this._coordinates, 0);\n\t\t\tif (filter.isGeometryChanged()) this.geometryChanged();\n\t\t} else if (hasInterface(arguments[0], GeometryFilter)) {\n\t\t\tvar filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t} else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n\t\t\tvar filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t}\n\t},\n\tgetBoundary: function getBoundary() {\n\t\treturn this.getFactory().createGeometryCollection(null);\n\t},\n\tclone: function clone() {\n\t\tvar p = Geometry.prototype.clone.call(this);\n\t\tp._coordinates = this._coordinates.clone();\n\t\treturn p;\n\t},\n\tgetGeometryType: function getGeometryType() {\n\t\treturn \"Point\";\n\t},\n\tcopy: function copy() {\n\t\treturn new Point(this._coordinates.copy(), this._factory);\n\t},\n\tgetCoordinateSequence: function getCoordinateSequence() {\n\t\treturn this._coordinates;\n\t},\n\tgetY: function getY() {\n\t\tif (this.getCoordinate() === null) {\n\t\t\tthrow new IllegalStateException(\"getY called on empty Point\");\n\t\t}\n\t\treturn this.getCoordinate().y;\n\t},\n\tisEmpty: function isEmpty() {\n\t\treturn this._coordinates.size() === 0;\n\t},\n\tinit: function init(coordinates) {\n\t\tif (coordinates === null) {\n\t\t\tcoordinates = this.getFactory().getCoordinateSequenceFactory().create([]);\n\t\t}\n\t\tAssert.isTrue(coordinates.size() <= 1);\n\t\tthis._coordinates = coordinates;\n\t},\n\tisSimple: function isSimple() {\n\t\treturn true;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Puntal];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Point;\n\t}\n});\nPoint.serialVersionUID = 4902022702746614570;\n\nfunction Polygonal() {}\nextend(Polygonal.prototype, {\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Polygonal;\n\t}\n});\n\nfunction Polygon() {\n\tthis._shell = null;\n\tthis._holes = null;\n\tvar shell = arguments[0],\n\t    holes = arguments[1],\n\t    factory = arguments[2];\n\tGeometry.call(this, factory);\n\tif (shell === null) {\n\t\tshell = this.getFactory().createLinearRing();\n\t}\n\tif (holes === null) {\n\t\tholes = [];\n\t}\n\tif (Geometry.hasNullElements(holes)) {\n\t\tthrow new IllegalArgumentException(\"holes must not contain null elements\");\n\t}\n\tif (shell.isEmpty() && Geometry.hasNonEmptyElements(holes)) {\n\t\tthrow new IllegalArgumentException(\"shell is empty but holes are not\");\n\t}\n\tthis._shell = shell;\n\tthis._holes = holes;\n}\ninherits$1(Polygon, Geometry);\nextend(Polygon.prototype, {\n\tcomputeEnvelopeInternal: function computeEnvelopeInternal() {\n\t\treturn this._shell.getEnvelopeInternal();\n\t},\n\tgetSortIndex: function getSortIndex() {\n\t\treturn Geometry.SORTINDEX_POLYGON;\n\t},\n\tgetCoordinates: function getCoordinates() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn [];\n\t\t}\n\t\tvar coordinates = new Array(this.getNumPoints()).fill(null);\n\t\tvar k = -1;\n\t\tvar shellCoordinates = this._shell.getCoordinates();\n\t\tfor (var x = 0; x < shellCoordinates.length; x++) {\n\t\t\tk++;\n\t\t\tcoordinates[k] = shellCoordinates[x];\n\t\t}\n\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\tvar childCoordinates = this._holes[i].getCoordinates();\n\t\t\tfor (var j = 0; j < childCoordinates.length; j++) {\n\t\t\t\tk++;\n\t\t\t\tcoordinates[k] = childCoordinates[j];\n\t\t\t}\n\t\t}\n\t\treturn coordinates;\n\t},\n\tgetArea: function getArea() {\n\t\tvar area = 0.0;\n\t\tarea += Math.abs(CGAlgorithms.signedArea(this._shell.getCoordinateSequence()));\n\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\tarea -= Math.abs(CGAlgorithms.signedArea(this._holes[i].getCoordinateSequence()));\n\t\t}\n\t\treturn area;\n\t},\n\tisRectangle: function isRectangle() {\n\t\tif (this.getNumInteriorRing() !== 0) return false;\n\t\tif (this._shell === null) return false;\n\t\tif (this._shell.getNumPoints() !== 5) return false;\n\t\tvar seq = this._shell.getCoordinateSequence();\n\t\tvar env = this.getEnvelopeInternal();\n\t\tfor (var i = 0; i < 5; i++) {\n\t\t\tvar x = seq.getX(i);\n\t\t\tif (!(x === env.getMinX() || x === env.getMaxX())) return false;\n\t\t\tvar y = seq.getY(i);\n\t\t\tif (!(y === env.getMinY() || y === env.getMaxY())) return false;\n\t\t}\n\t\tvar prevX = seq.getX(0);\n\t\tvar prevY = seq.getY(0);\n\t\tfor (var i = 1; i <= 4; i++) {\n\t\t\tvar x = seq.getX(i);\n\t\t\tvar y = seq.getY(i);\n\t\t\tvar xChanged = x !== prevX;\n\t\t\tvar yChanged = y !== prevY;\n\t\t\tif (xChanged === yChanged) return false;\n\t\t\tprevX = x;\n\t\t\tprevY = y;\n\t\t}\n\t\treturn true;\n\t},\n\tequalsExact: function equalsExact() {\n\t\tif (arguments.length === 2) {\n\t\t\tvar other = arguments[0],\n\t\t\t    tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar otherPolygon = other;\n\t\t\tvar thisShell = this._shell;\n\t\t\tvar otherPolygonShell = otherPolygon._shell;\n\t\t\tif (!thisShell.equalsExact(otherPolygonShell, tolerance)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (this._holes.length !== otherPolygon._holes.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\t\tif (!this._holes[i].equalsExact(otherPolygon._holes[i], tolerance)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else return Geometry.prototype.equalsExact.apply(this, arguments);\n\t},\n\tnormalize: function normalize() {\n\t\tif (arguments.length === 0) {\n\t\t\tthis.normalize(this._shell, true);\n\t\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\t\tthis.normalize(this._holes[i], false);\n\t\t\t}\n\t\t\tArrays.sort(this._holes);\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar ring = arguments[0],\n\t\t\t    clockwise = arguments[1];\n\t\t\tif (ring.isEmpty()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tvar uniqueCoordinates = new Array(ring.getCoordinates().length - 1).fill(null);\n\t\t\tSystem.arraycopy(ring.getCoordinates(), 0, uniqueCoordinates, 0, uniqueCoordinates.length);\n\t\t\tvar minCoordinate = CoordinateArrays.minCoordinate(ring.getCoordinates());\n\t\t\tCoordinateArrays.scroll(uniqueCoordinates, minCoordinate);\n\t\t\tSystem.arraycopy(uniqueCoordinates, 0, ring.getCoordinates(), 0, uniqueCoordinates.length);\n\t\t\tring.getCoordinates()[uniqueCoordinates.length] = uniqueCoordinates[0];\n\t\t\tif (CGAlgorithms.isCCW(ring.getCoordinates()) === clockwise) {\n\t\t\t\tCoordinateArrays.reverse(ring.getCoordinates());\n\t\t\t}\n\t\t}\n\t},\n\tgetCoordinate: function getCoordinate() {\n\t\treturn this._shell.getCoordinate();\n\t},\n\tgetNumInteriorRing: function getNumInteriorRing() {\n\t\treturn this._holes.length;\n\t},\n\tgetBoundaryDimension: function getBoundaryDimension() {\n\t\treturn 1;\n\t},\n\tgetDimension: function getDimension() {\n\t\treturn 2;\n\t},\n\tgetLength: function getLength() {\n\t\tvar len = 0.0;\n\t\tlen += this._shell.getLength();\n\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\tlen += this._holes[i].getLength();\n\t\t}\n\t\treturn len;\n\t},\n\tgetNumPoints: function getNumPoints() {\n\t\tvar numPoints = this._shell.getNumPoints();\n\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\tnumPoints += this._holes[i].getNumPoints();\n\t\t}\n\t\treturn numPoints;\n\t},\n\treverse: function reverse() {\n\t\tvar poly = this.copy();\n\t\tpoly._shell = this._shell.copy().reverse();\n\t\tpoly._holes = new Array(this._holes.length).fill(null);\n\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\tpoly._holes[i] = this._holes[i].copy().reverse();\n\t\t}\n\t\treturn poly;\n\t},\n\tconvexHull: function convexHull() {\n\t\treturn this.getExteriorRing().convexHull();\n\t},\n\tcompareToSameClass: function compareToSameClass() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar o = arguments[0];\n\t\t\tvar thisShell = this._shell;\n\t\t\tvar otherShell = o._shell;\n\t\t\treturn thisShell.compareToSameClass(otherShell);\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar o = arguments[0],\n\t\t\t    comp = arguments[1];\n\t\t\tvar poly = o;\n\t\t\tvar thisShell = this._shell;\n\t\t\tvar otherShell = poly._shell;\n\t\t\tvar shellComp = thisShell.compareToSameClass(otherShell, comp);\n\t\t\tif (shellComp !== 0) return shellComp;\n\t\t\tvar nHole1 = this.getNumInteriorRing();\n\t\t\tvar nHole2 = poly.getNumInteriorRing();\n\t\t\tvar i = 0;\n\t\t\twhile (i < nHole1 && i < nHole2) {\n\t\t\t\tvar thisHole = this.getInteriorRingN(i);\n\t\t\t\tvar otherHole = poly.getInteriorRingN(i);\n\t\t\t\tvar holeComp = thisHole.compareToSameClass(otherHole, comp);\n\t\t\t\tif (holeComp !== 0) return holeComp;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (i < nHole1) return 1;\n\t\t\tif (i < nHole2) return -1;\n\t\t\treturn 0;\n\t\t}\n\t},\n\tapply: function apply() {\n\t\tif (hasInterface(arguments[0], CoordinateFilter)) {\n\t\t\tvar filter = arguments[0];\n\t\t\tthis._shell.apply(filter);\n\t\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\t\tthis._holes[i].apply(filter);\n\t\t\t}\n\t\t} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n\t\t\tvar filter = arguments[0];\n\t\t\tthis._shell.apply(filter);\n\t\t\tif (!filter.isDone()) {\n\t\t\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\t\t\tthis._holes[i].apply(filter);\n\t\t\t\t\tif (filter.isDone()) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (filter.isGeometryChanged()) this.geometryChanged();\n\t\t} else if (hasInterface(arguments[0], GeometryFilter)) {\n\t\t\tvar filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t} else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n\t\t\tvar filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t\tthis._shell.apply(filter);\n\t\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\t\tthis._holes[i].apply(filter);\n\t\t\t}\n\t\t}\n\t},\n\tgetBoundary: function getBoundary() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn this.getFactory().createMultiLineString();\n\t\t}\n\t\tvar rings = new Array(this._holes.length + 1).fill(null);\n\t\trings[0] = this._shell;\n\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\trings[i + 1] = this._holes[i];\n\t\t}\n\t\tif (rings.length <= 1) return this.getFactory().createLinearRing(rings[0].getCoordinateSequence());\n\t\treturn this.getFactory().createMultiLineString(rings);\n\t},\n\tclone: function clone() {\n\t\tvar poly = Geometry.prototype.clone.call(this);\n\t\tpoly._shell = this._shell.clone();\n\t\tpoly._holes = new Array(this._holes.length).fill(null);\n\t\tfor (var i = 0; i < this._holes.length; i++) {\n\t\t\tpoly._holes[i] = this._holes[i].clone();\n\t\t}\n\t\treturn poly;\n\t},\n\tgetGeometryType: function getGeometryType() {\n\t\treturn \"Polygon\";\n\t},\n\tcopy: function copy() {\n\t\tvar shell = this._shell.copy();\n\t\tvar holes = new Array(this._holes.length).fill(null);\n\t\tfor (var i = 0; i < holes.length; i++) {\n\t\t\tholes[i] = this._holes[i].copy();\n\t\t}\n\t\treturn new Polygon(shell, holes, this._factory);\n\t},\n\tgetExteriorRing: function getExteriorRing() {\n\t\treturn this._shell;\n\t},\n\tisEmpty: function isEmpty() {\n\t\treturn this._shell.isEmpty();\n\t},\n\tgetInteriorRingN: function getInteriorRingN(n) {\n\t\treturn this._holes[n];\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Polygonal];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Polygon;\n\t}\n});\nPolygon.serialVersionUID = -3494792200821764533;\n\nfunction MultiPoint() {\n\tvar points = arguments[0],\n\t    factory = arguments[1];\n\tGeometryCollection.call(this, points, factory);\n}\ninherits$1(MultiPoint, GeometryCollection);\nextend(MultiPoint.prototype, {\n\tgetSortIndex: function getSortIndex() {\n\t\treturn Geometry.SORTINDEX_MULTIPOINT;\n\t},\n\tisValid: function isValid() {\n\t\treturn true;\n\t},\n\tequalsExact: function equalsExact() {\n\t\tif (arguments.length === 2) {\n\t\t\tvar other = arguments[0],\n\t\t\t    tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn GeometryCollection.prototype.equalsExact.call(this, other, tolerance);\n\t\t} else return GeometryCollection.prototype.equalsExact.apply(this, arguments);\n\t},\n\tgetCoordinate: function getCoordinate() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar n = arguments[0];\n\t\t\treturn this._geometries[n].getCoordinate();\n\t\t} else return GeometryCollection.prototype.getCoordinate.apply(this, arguments);\n\t},\n\tgetBoundaryDimension: function getBoundaryDimension() {\n\t\treturn Dimension.FALSE;\n\t},\n\tgetDimension: function getDimension() {\n\t\treturn 0;\n\t},\n\tgetBoundary: function getBoundary() {\n\t\treturn this.getFactory().createGeometryCollection(null);\n\t},\n\tgetGeometryType: function getGeometryType() {\n\t\treturn \"MultiPoint\";\n\t},\n\tcopy: function copy() {\n\t\tvar points = new Array(this._geometries.length).fill(null);\n\t\tfor (var i = 0; i < points.length; i++) {\n\t\t\tpoints[i] = this._geometries[i].copy();\n\t\t}\n\t\treturn new MultiPoint(points, this._factory);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Puntal];\n\t},\n\tgetClass: function getClass() {\n\t\treturn MultiPoint;\n\t}\n});\nMultiPoint.serialVersionUID = -8048474874175355449;\n\nfunction LinearRing() {\n\tif (arguments[0] instanceof Coordinate && arguments[1] instanceof GeometryFactory) {\n\t\tvar points = arguments[0],\n\t\t    factory = arguments[1];\n\t\tLinearRing.call(this, factory.getCoordinateSequenceFactory().create(points), factory);\n\t} else if (hasInterface(arguments[0], CoordinateSequence) && arguments[1] instanceof GeometryFactory) {\n\t\tvar points = arguments[0],\n\t\t    factory = arguments[1];\n\t\tLineString.call(this, points, factory);\n\t\tthis.validateConstruction();\n\t}\n}\ninherits$1(LinearRing, LineString);\nextend(LinearRing.prototype, {\n\tgetSortIndex: function getSortIndex() {\n\t\treturn Geometry.SORTINDEX_LINEARRING;\n\t},\n\tgetBoundaryDimension: function getBoundaryDimension() {\n\t\treturn Dimension.FALSE;\n\t},\n\tisClosed: function isClosed() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn true;\n\t\t}\n\t\treturn LineString.prototype.isClosed.call(this);\n\t},\n\treverse: function reverse() {\n\t\tvar seq = this._points.copy();\n\t\tCoordinateSequences.reverse(seq);\n\t\tvar rev = this.getFactory().createLinearRing(seq);\n\t\treturn rev;\n\t},\n\tvalidateConstruction: function validateConstruction() {\n\t\tif (!this.isEmpty() && !LineString.prototype.isClosed.call(this)) {\n\t\t\tthrow new IllegalArgumentException(\"Points of LinearRing do not form a closed linestring\");\n\t\t}\n\t\tif (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < LinearRing.MINIMUM_VALID_SIZE) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid number of points in LinearRing (found \" + this.getCoordinateSequence().size() + \" - must be 0 or >= 4)\");\n\t\t}\n\t},\n\tgetGeometryType: function getGeometryType() {\n\t\treturn \"LinearRing\";\n\t},\n\tcopy: function copy() {\n\t\treturn new LinearRing(this._points.copy(), this._factory);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn LinearRing;\n\t}\n});\nLinearRing.MINIMUM_VALID_SIZE = 4;\nLinearRing.serialVersionUID = -4261142084085851829;\n\nfunction MultiPolygon() {\n\tvar polygons = arguments[0],\n\t    factory = arguments[1];\n\tGeometryCollection.call(this, polygons, factory);\n}\ninherits$1(MultiPolygon, GeometryCollection);\nextend(MultiPolygon.prototype, {\n\tgetSortIndex: function getSortIndex() {\n\t\treturn Geometry.SORTINDEX_MULTIPOLYGON;\n\t},\n\tequalsExact: function equalsExact() {\n\t\tif (arguments.length === 2) {\n\t\t\tvar other = arguments[0],\n\t\t\t    tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn GeometryCollection.prototype.equalsExact.call(this, other, tolerance);\n\t\t} else return GeometryCollection.prototype.equalsExact.apply(this, arguments);\n\t},\n\tgetBoundaryDimension: function getBoundaryDimension() {\n\t\treturn 1;\n\t},\n\tgetDimension: function getDimension() {\n\t\treturn 2;\n\t},\n\treverse: function reverse() {\n\t\tvar n = this._geometries.length;\n\t\tvar revGeoms = new Array(n).fill(null);\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\trevGeoms[i] = this._geometries[i].reverse();\n\t\t}\n\t\treturn this.getFactory().createMultiPolygon(revGeoms);\n\t},\n\tgetBoundary: function getBoundary() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn this.getFactory().createMultiLineString();\n\t\t}\n\t\tvar allRings = new ArrayList();\n\t\tfor (var i = 0; i < this._geometries.length; i++) {\n\t\t\tvar polygon = this._geometries[i];\n\t\t\tvar rings = polygon.getBoundary();\n\t\t\tfor (var j = 0; j < rings.getNumGeometries(); j++) {\n\t\t\t\tallRings.add(rings.getGeometryN(j));\n\t\t\t}\n\t\t}\n\t\tvar allRingsArray = new Array(allRings.size()).fill(null);\n\t\treturn this.getFactory().createMultiLineString(allRings.toArray(allRingsArray));\n\t},\n\tgetGeometryType: function getGeometryType() {\n\t\treturn \"MultiPolygon\";\n\t},\n\tcopy: function copy() {\n\t\tvar polygons = new Array(this._geometries.length).fill(null);\n\t\tfor (var i = 0; i < polygons.length; i++) {\n\t\t\tpolygons[i] = this._geometries[i].copy();\n\t\t}\n\t\treturn new MultiPolygon(polygons, this._factory);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Polygonal];\n\t},\n\tgetClass: function getClass() {\n\t\treturn MultiPolygon;\n\t}\n});\nMultiPolygon.serialVersionUID = -551033529766975875;\n\nfunction GeometryEditor() {\n\tthis._factory = null;\n\tthis._isUserDataCopied = false;\n\tif (arguments.length === 0) {} else if (arguments.length === 1) {\n\t\tvar factory = arguments[0];\n\t\tthis._factory = factory;\n\t}\n}\nextend(GeometryEditor.prototype, {\n\tsetCopyUserData: function setCopyUserData(isUserDataCopied) {\n\t\tthis._isUserDataCopied = isUserDataCopied;\n\t},\n\tedit: function edit(geometry, operation) {\n\t\tif (geometry === null) return null;\n\t\tvar result = this.editInternal(geometry, operation);\n\t\tif (this._isUserDataCopied) {\n\t\t\tresult.setUserData(geometry.getUserData());\n\t\t}\n\t\treturn result;\n\t},\n\teditInternal: function editInternal(geometry, operation) {\n\t\tif (this._factory === null) this._factory = geometry.getFactory();\n\t\tif (geometry instanceof GeometryCollection) {\n\t\t\treturn this.editGeometryCollection(geometry, operation);\n\t\t}\n\t\tif (geometry instanceof Polygon) {\n\t\t\treturn this.editPolygon(geometry, operation);\n\t\t}\n\t\tif (geometry instanceof Point) {\n\t\t\treturn operation.edit(geometry, this._factory);\n\t\t}\n\t\tif (geometry instanceof LineString) {\n\t\t\treturn operation.edit(geometry, this._factory);\n\t\t}\n\t\tAssert.shouldNeverReachHere(\"Unsupported Geometry class: \" + geometry.getClass().getName());\n\t\treturn null;\n\t},\n\teditGeometryCollection: function editGeometryCollection(collection, operation) {\n\t\tvar collectionForType = operation.edit(collection, this._factory);\n\t\tvar geometries = new ArrayList();\n\t\tfor (var i = 0; i < collectionForType.getNumGeometries(); i++) {\n\t\t\tvar geometry = this.edit(collectionForType.getGeometryN(i), operation);\n\t\t\tif (geometry === null || geometry.isEmpty()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgeometries.add(geometry);\n\t\t}\n\t\tif (collectionForType.getClass() === MultiPoint) {\n\t\t\treturn this._factory.createMultiPoint(geometries.toArray([]));\n\t\t}\n\t\tif (collectionForType.getClass() === MultiLineString) {\n\t\t\treturn this._factory.createMultiLineString(geometries.toArray([]));\n\t\t}\n\t\tif (collectionForType.getClass() === MultiPolygon) {\n\t\t\treturn this._factory.createMultiPolygon(geometries.toArray([]));\n\t\t}\n\t\treturn this._factory.createGeometryCollection(geometries.toArray([]));\n\t},\n\teditPolygon: function editPolygon(polygon, operation) {\n\t\tvar newPolygon = operation.edit(polygon, this._factory);\n\t\tif (newPolygon === null) newPolygon = this._factory.createPolygon(null);\n\t\tif (newPolygon.isEmpty()) {\n\t\t\treturn newPolygon;\n\t\t}\n\t\tvar shell = this.edit(newPolygon.getExteriorRing(), operation);\n\t\tif (shell === null || shell.isEmpty()) {\n\t\t\treturn this._factory.createPolygon();\n\t\t}\n\t\tvar holes = new ArrayList();\n\t\tfor (var i = 0; i < newPolygon.getNumInteriorRing(); i++) {\n\t\t\tvar hole = this.edit(newPolygon.getInteriorRingN(i), operation);\n\t\t\tif (hole === null || hole.isEmpty()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tholes.add(hole);\n\t\t}\n\t\treturn this._factory.createPolygon(shell, holes.toArray([]));\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn GeometryEditor;\n\t}\n});\nfunction GeometryEditorOperation() {}\nGeometryEditor.GeometryEditorOperation = GeometryEditorOperation;\nfunction NoOpGeometryOperation() {}\nextend(NoOpGeometryOperation.prototype, {\n\tedit: function edit(geometry, factory) {\n\t\treturn geometry;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [GeometryEditorOperation];\n\t},\n\tgetClass: function getClass() {\n\t\treturn NoOpGeometryOperation;\n\t}\n});\nfunction CoordinateOperation() {}\nextend(CoordinateOperation.prototype, {\n\tedit: function edit(geometry, factory) {\n\t\tvar coords = this.editCoordinates(geometry.getCoordinates(), geometry);\n\t\tif (coords === null) return geometry;\n\t\tif (geometry instanceof LinearRing) {\n\t\t\treturn factory.createLinearRing(coords);\n\t\t}\n\t\tif (geometry instanceof LineString) {\n\t\t\treturn factory.createLineString(coords);\n\t\t}\n\t\tif (geometry instanceof Point) {\n\t\t\tif (coords.length > 0) {\n\t\t\t\treturn factory.createPoint(coords[0]);\n\t\t\t} else {\n\t\t\t\treturn factory.createPoint();\n\t\t\t}\n\t\t}\n\t\treturn geometry;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [GeometryEditorOperation];\n\t},\n\tgetClass: function getClass() {\n\t\treturn CoordinateOperation;\n\t}\n});\nfunction CoordinateSequenceOperation() {}\nextend(CoordinateSequenceOperation.prototype, {\n\tedit: function edit(geometry, factory) {\n\t\tif (geometry instanceof LinearRing) {\n\t\t\treturn factory.createLinearRing(this.edit(geometry.getCoordinateSequence(), geometry));\n\t\t}\n\t\tif (geometry instanceof LineString) {\n\t\t\treturn factory.createLineString(this.edit(geometry.getCoordinateSequence(), geometry));\n\t\t}\n\t\tif (geometry instanceof Point) {\n\t\t\treturn factory.createPoint(this.edit(geometry.getCoordinateSequence(), geometry));\n\t\t}\n\t\treturn geometry;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [GeometryEditorOperation];\n\t},\n\tgetClass: function getClass() {\n\t\treturn CoordinateSequenceOperation;\n\t}\n});\nGeometryEditor.NoOpGeometryOperation = NoOpGeometryOperation;\nGeometryEditor.CoordinateOperation = CoordinateOperation;\nGeometryEditor.CoordinateSequenceOperation = CoordinateSequenceOperation;\n\nfunction CoordinateArraySequence() {\n\tthis._dimension = 3;\n\tthis._coordinates = null;\n\tif (arguments.length === 1) {\n\t\tif (arguments[0] instanceof Array) {\n\t\t\tvar coordinates = arguments[0];\n\t\t\tCoordinateArraySequence.call(this, coordinates, 3);\n\t\t} else if (Number.isInteger(arguments[0])) {\n\t\t\tvar size = arguments[0];\n\t\t\tthis._coordinates = new Array(size).fill(null);\n\t\t\tfor (var i = 0; i < size; i++) {\n\t\t\t\tthis._coordinates[i] = new Coordinate();\n\t\t\t}\n\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\tvar coordSeq = arguments[0];\n\t\t\tif (coordSeq === null) {\n\t\t\t\tthis._coordinates = new Array(0).fill(null);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tthis._dimension = coordSeq.getDimension();\n\t\t\tthis._coordinates = new Array(coordSeq.size()).fill(null);\n\t\t\tfor (var i = 0; i < this._coordinates.length; i++) {\n\t\t\t\tthis._coordinates[i] = coordSeq.getCoordinateCopy(i);\n\t\t\t}\n\t\t}\n\t} else if (arguments.length === 2) {\n\t\tif (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {\n\t\t\tvar coordinates = arguments[0],\n\t\t\t    dimension = arguments[1];\n\t\t\tthis._coordinates = coordinates;\n\t\t\tthis._dimension = dimension;\n\t\t\tif (coordinates === null) this._coordinates = new Array(0).fill(null);\n\t\t} else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {\n\t\t\tvar size = arguments[0],\n\t\t\t    dimension = arguments[1];\n\t\t\tthis._coordinates = new Array(size).fill(null);\n\t\t\tthis._dimension = dimension;\n\t\t\tfor (var i = 0; i < size; i++) {\n\t\t\t\tthis._coordinates[i] = new Coordinate();\n\t\t\t}\n\t\t}\n\t}\n}\nextend(CoordinateArraySequence.prototype, {\n\tsetOrdinate: function setOrdinate(index, ordinateIndex, value) {\n\t\tswitch (ordinateIndex) {\n\t\t\tcase CoordinateSequence.X:\n\t\t\t\tthis._coordinates[index].x = value;\n\t\t\t\tbreak;\n\t\t\tcase CoordinateSequence.Y:\n\t\t\t\tthis._coordinates[index].y = value;\n\t\t\t\tbreak;\n\t\t\tcase CoordinateSequence.Z:\n\t\t\t\tthis._coordinates[index].z = value;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException(\"invalid ordinateIndex\");\n\t\t}\n\t},\n\tsize: function size() {\n\t\treturn this._coordinates.length;\n\t},\n\tgetOrdinate: function getOrdinate(index, ordinateIndex) {\n\t\tswitch (ordinateIndex) {\n\t\t\tcase CoordinateSequence.X:\n\t\t\t\treturn this._coordinates[index].x;\n\t\t\tcase CoordinateSequence.Y:\n\t\t\t\treturn this._coordinates[index].y;\n\t\t\tcase CoordinateSequence.Z:\n\t\t\t\treturn this._coordinates[index].z;\n\t\t}\n\t\treturn Double.NaN;\n\t},\n\tgetCoordinate: function getCoordinate() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar i = arguments[0];\n\t\t\treturn this._coordinates[i];\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar index = arguments[0],\n\t\t\t    coord = arguments[1];\n\t\t\tcoord.x = this._coordinates[index].x;\n\t\t\tcoord.y = this._coordinates[index].y;\n\t\t\tcoord.z = this._coordinates[index].z;\n\t\t}\n\t},\n\tgetCoordinateCopy: function getCoordinateCopy(i) {\n\t\treturn new Coordinate(this._coordinates[i]);\n\t},\n\tgetDimension: function getDimension() {\n\t\treturn this._dimension;\n\t},\n\tgetX: function getX(index) {\n\t\treturn this._coordinates[index].x;\n\t},\n\tclone: function clone() {\n\t\tvar cloneCoordinates = new Array(this.size()).fill(null);\n\t\tfor (var i = 0; i < this._coordinates.length; i++) {\n\t\t\tcloneCoordinates[i] = this._coordinates[i].clone();\n\t\t}\n\t\treturn new CoordinateArraySequence(cloneCoordinates, this._dimension);\n\t},\n\texpandEnvelope: function expandEnvelope(env) {\n\t\tfor (var i = 0; i < this._coordinates.length; i++) {\n\t\t\tenv.expandToInclude(this._coordinates[i]);\n\t\t}\n\t\treturn env;\n\t},\n\tcopy: function copy() {\n\t\tvar cloneCoordinates = new Array(this.size()).fill(null);\n\t\tfor (var i = 0; i < this._coordinates.length; i++) {\n\t\t\tcloneCoordinates[i] = this._coordinates[i].copy();\n\t\t}\n\t\treturn new CoordinateArraySequence(cloneCoordinates, this._dimension);\n\t},\n\ttoString: function toString() {\n\t\tif (this._coordinates.length > 0) {\n\t\t\tvar strBuf = new StringBuffer(17 * this._coordinates.length);\n\t\t\tstrBuf.append('(');\n\t\t\tstrBuf.append(this._coordinates[0]);\n\t\t\tfor (var i = 1; i < this._coordinates.length; i++) {\n\t\t\t\tstrBuf.append(\", \");\n\t\t\t\tstrBuf.append(this._coordinates[i]);\n\t\t\t}\n\t\t\tstrBuf.append(')');\n\t\t\treturn strBuf.toString();\n\t\t} else {\n\t\t\treturn \"()\";\n\t\t}\n\t},\n\tgetY: function getY(index) {\n\t\treturn this._coordinates[index].y;\n\t},\n\ttoCoordinateArray: function toCoordinateArray() {\n\t\treturn this._coordinates;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [CoordinateSequence, Serializable];\n\t},\n\tgetClass: function getClass() {\n\t\treturn CoordinateArraySequence;\n\t}\n});\nCoordinateArraySequence.serialVersionUID = -915438501601840650;\n\nfunction CoordinateArraySequenceFactory() {}\nextend(CoordinateArraySequenceFactory.prototype, {\n\treadResolve: function readResolve() {\n\t\treturn CoordinateArraySequenceFactory.instance();\n\t},\n\tcreate: function create() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Array) {\n\t\t\t\tvar coordinates = arguments[0];\n\t\t\t\treturn new CoordinateArraySequence(coordinates);\n\t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tvar coordSeq = arguments[0];\n\t\t\t\treturn new CoordinateArraySequence(coordSeq);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar size = arguments[0],\n\t\t\t    dimension = arguments[1];\n\t\t\tif (dimension > 3) dimension = 3;\n\t\t\tif (dimension < 2) return new CoordinateArraySequence(size);\n\t\t\treturn new CoordinateArraySequence(size, dimension);\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [CoordinateSequenceFactory, Serializable];\n\t},\n\tgetClass: function getClass() {\n\t\treturn CoordinateArraySequenceFactory;\n\t}\n});\nCoordinateArraySequenceFactory.instance = function () {\n\treturn CoordinateArraySequenceFactory.instanceObject;\n};\nCoordinateArraySequenceFactory.serialVersionUID = -4099577099607551657;\nCoordinateArraySequenceFactory.instanceObject = new CoordinateArraySequenceFactory();\n\n// shared pointer\nvar i;\n// shortcuts\nvar defineProperty$1 = Object.defineProperty;\nfunction is(a, b) {\n  return a === b || a !== a && b !== b;\n} // eslint-disable-line\n\nvar MapPolyfill = createCollection({\n  // WeakMap#delete(key:void*):boolean\n  'delete': sharedDelete,\n  // :was Map#get(key:void*[, d3fault:void*]):void*\n  // Map#has(key:void*):boolean\n  has: mapHas,\n  // Map#get(key:void*):boolean\n  get: sharedGet,\n  // Map#set(key:void*, value:void*):void\n  set: sharedSet,\n  // Map#keys(void):Iterator\n  keys: sharedKeys,\n  // Map#values(void):Iterator\n  values: sharedValues,\n  // Map#entries(void):Iterator\n  entries: mapEntries,\n  // Map#forEach(callback:Function, context:void*):void ==> callback.call(context, key, value, mapObject) === not in specs`\n  forEach: sharedForEach,\n  // Map#clear():\n  clear: sharedClear\n});\n\n/**\n * ES6 collection constructor\n * @return {Function} a collection class\n */\nfunction createCollection(proto, objectOnly) {\n  function Collection(a) {\n    if (!this || this.constructor !== Collection) return new Collection(a);\n    this._keys = [];\n    this._values = [];\n    this._itp = []; // iteration pointers\n    this.objectOnly = objectOnly;\n\n    // parse initial iterable argument passed\n    if (a) init.call(this, a);\n  }\n\n  // define size for non object-only collections\n  if (!objectOnly) {\n    defineProperty$1(proto, 'size', {\n      get: sharedSize\n    });\n  }\n\n  // set prototype\n  proto.constructor = Collection;\n  Collection.prototype = proto;\n\n  return Collection;\n}\n\n/** parse initial iterable argument passed */\nfunction init(a) {\n  // init Set argument, like `[1,2,3,{}]`\n  if (this.add) a.forEach(this.add, this);\n  // init Map argument like `[[1,2], [{}, 4]]`\n  else a.forEach(function (a) {\n      this.set(a[0], a[1]);\n    }, this);\n}\n\n/** delete */\nfunction sharedDelete(key) {\n  if (this.has(key)) {\n    this._keys.splice(i, 1);\n    this._values.splice(i, 1);\n    // update iteration pointers\n    this._itp.forEach(function (p) {\n      if (i < p[0]) p[0]--;\n    });\n  }\n  // Aurora here does it while Canary doesn't\n  return i > -1;\n}\n\nfunction sharedGet(key) {\n  return this.has(key) ? this._values[i] : undefined;\n}\n\nfunction has(list, key) {\n  if (this.objectOnly && key !== Object(key)) throw new TypeError('Invalid value used as weak collection key');\n  // NaN or 0 passed\n  if (key !== key || key === 0) for (i = list.length; i-- && !is(list[i], key);) {} // eslint-disable-line\n  else i = list.indexOf(key);\n  return i > -1;\n}\n\nfunction mapHas(value) {\n  return has.call(this, this._keys, value);\n}\n\n/** @chainable */\nfunction sharedSet(key, value) {\n  this.has(key) ? this._values[i] = value : this._values[this._keys.push(key) - 1] = value;\n  return this;\n}\n\nfunction sharedClear() {\n  (this._keys || 0).length = this._values.length = 0;\n}\n\n/** keys, values, and iterate related methods */\nfunction sharedKeys() {\n  return sharedIterator(this._itp, this._keys);\n}\n\nfunction sharedValues() {\n  return sharedIterator(this._itp, this._values);\n}\n\nfunction mapEntries() {\n  return sharedIterator(this._itp, this._keys, this._values);\n}\n\nfunction sharedIterator(itp, array, array2) {\n  var p = [0];\n  var done = false;\n  itp.push(p);\n  return {\n    next: function next() {\n      var v;\n      var k = p[0];\n      if (!done && k < array.length) {\n        v = array2 ? [array[k], array2[k]] : array[k];\n        p[0]++;\n      } else {\n        done = true;\n        itp.splice(itp.indexOf(p), 1);\n      }\n      return { done: done, value: v };\n    }\n  };\n}\n\nfunction sharedSize() {\n  return this._values.length;\n}\n\nfunction sharedForEach(callback, context) {\n  var it = this.entries();\n  for (;;) {\n    var r = it.next();\n    if (r.done) break;\n    callback.call(context, r.value[1], r.value[0], this);\n  }\n}\n\nvar MapImpl = typeof Map === 'undefined' || !Map.prototype.values ? MapPolyfill : Map;\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/HashMap.html\n *\n * @extends {javascript.util.Map}\n * @constructor\n * @private\n */\nfunction HashMap() {\n  /**\n   * @type {Object}\n   * @private\n  */\n  this.map_ = new MapImpl();\n}\nHashMap.prototype = new Map$3();\n\n/**\n * @override\n */\nHashMap.prototype.get = function (key) {\n  return this.map_.get(key) || null;\n};\n\n/**\n * @override\n */\nHashMap.prototype.put = function (key, value) {\n  this.map_.set(key, value);\n  return value;\n};\n\n/**\n * @override\n */\nHashMap.prototype.values = function () {\n  var arrayList = new ArrayList();\n  var it = this.map_.values();\n  var o = it.next();\n  while (!o.done) {\n    arrayList.add(o.value);\n    o = it.next();\n  }\n  return arrayList;\n};\n\n/**\n * @override\n */\nHashMap.prototype.entrySet = function () {\n  var hashSet = new HashSet();\n  this.map_.entries().forEach(function (entry) {\n    return hashSet.add(entry);\n  });\n  return hashSet;\n};\n\n/**\n * @override\n */\nHashMap.prototype.size = function () {\n  return this.map_.size();\n};\n\nfunction PrecisionModel() {\n\tthis._modelType = null;\n\tthis._scale = null;\n\tif (arguments.length === 0) {\n\t\tthis._modelType = PrecisionModel.FLOATING;\n\t} else if (arguments.length === 1) {\n\t\tif (arguments[0] instanceof Type) {\n\t\t\tvar modelType = arguments[0];\n\t\t\tthis._modelType = modelType;\n\t\t\tif (modelType === PrecisionModel.FIXED) {\n\t\t\t\tthis.setScale(1.0);\n\t\t\t}\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tvar scale = arguments[0];\n\t\t\tthis._modelType = PrecisionModel.FIXED;\n\t\t\tthis.setScale(scale);\n\t\t} else if (arguments[0] instanceof PrecisionModel) {\n\t\t\tvar pm = arguments[0];\n\t\t\tthis._modelType = pm._modelType;\n\t\t\tthis._scale = pm._scale;\n\t\t}\n\t}\n}\nextend(PrecisionModel.prototype, {\n\tequals: function equals(other) {\n\t\tif (!(other instanceof PrecisionModel)) {\n\t\t\treturn false;\n\t\t}\n\t\tvar otherPrecisionModel = other;\n\t\treturn this._modelType === otherPrecisionModel._modelType && this._scale === otherPrecisionModel._scale;\n\t},\n\tcompareTo: function compareTo(o) {\n\t\tvar other = o;\n\t\tvar sigDigits = this.getMaximumSignificantDigits();\n\t\tvar otherSigDigits = other.getMaximumSignificantDigits();\n\t\treturn new Integer(sigDigits).compareTo(new Integer(otherSigDigits));\n\t},\n\tgetScale: function getScale() {\n\t\treturn this._scale;\n\t},\n\tisFloating: function isFloating() {\n\t\treturn this._modelType === PrecisionModel.FLOATING || this._modelType === PrecisionModel.FLOATING_SINGLE;\n\t},\n\tgetType: function getType() {\n\t\treturn this._modelType;\n\t},\n\ttoString: function toString() {\n\t\tvar description = \"UNKNOWN\";\n\t\tif (this._modelType === PrecisionModel.FLOATING) {\n\t\t\tdescription = \"Floating\";\n\t\t} else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {\n\t\t\tdescription = \"Floating-Single\";\n\t\t} else if (this._modelType === PrecisionModel.FIXED) {\n\t\t\tdescription = \"Fixed (Scale=\" + this.getScale() + \")\";\n\t\t}\n\t\treturn description;\n\t},\n\tmakePrecise: function makePrecise() {\n\t\tif (typeof arguments[0] === \"number\") {\n\t\t\tvar val = arguments[0];\n\t\t\tif (Double.isNaN(val)) return val;\n\t\t\tif (this._modelType === PrecisionModel.FLOATING_SINGLE) {\n\t\t\t\tvar floatSingleVal = val;\n\t\t\t\treturn floatSingleVal;\n\t\t\t}\n\t\t\tif (this._modelType === PrecisionModel.FIXED) {\n\t\t\t\treturn Math.round(val * this._scale) / this._scale;\n\t\t\t}\n\t\t\treturn val;\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tvar coord = arguments[0];\n\t\t\tif (this._modelType === PrecisionModel.FLOATING) return null;\n\t\t\tcoord.x = this.makePrecise(coord.x);\n\t\t\tcoord.y = this.makePrecise(coord.y);\n\t\t}\n\t},\n\tgetMaximumSignificantDigits: function getMaximumSignificantDigits() {\n\t\tvar maxSigDigits = 16;\n\t\tif (this._modelType === PrecisionModel.FLOATING) {\n\t\t\tmaxSigDigits = 16;\n\t\t} else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {\n\t\t\tmaxSigDigits = 6;\n\t\t} else if (this._modelType === PrecisionModel.FIXED) {\n\t\t\tmaxSigDigits = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)));\n\t\t}\n\t\treturn maxSigDigits;\n\t},\n\tsetScale: function setScale(scale) {\n\t\tthis._scale = Math.abs(scale);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Serializable, Comparable];\n\t},\n\tgetClass: function getClass() {\n\t\treturn PrecisionModel;\n\t}\n});\nPrecisionModel.mostPrecise = function (pm1, pm2) {\n\tif (pm1.compareTo(pm2) >= 0) return pm1;\n\treturn pm2;\n};\nfunction Type() {\n\tthis._name = null;\n\tvar name = arguments[0];\n\tthis._name = name;\n\tType.nameToTypeMap.put(name, this);\n}\nextend(Type.prototype, {\n\treadResolve: function readResolve() {\n\t\treturn Type.nameToTypeMap.get(this._name);\n\t},\n\ttoString: function toString() {\n\t\treturn this._name;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Serializable];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Type;\n\t}\n});\nType.serialVersionUID = -5528602631731589822;\nType.nameToTypeMap = new HashMap();\nPrecisionModel.Type = Type;\nPrecisionModel.serialVersionUID = 7777263578777803835;\nPrecisionModel.FIXED = new Type(\"FIXED\");\nPrecisionModel.FLOATING = new Type(\"FLOATING\");\nPrecisionModel.FLOATING_SINGLE = new Type(\"FLOATING SINGLE\");\nPrecisionModel.maximumPreciseValue = 9007199254740992.0;\n\nfunction GeometryFactory() {\n\tthis._precisionModel = null;\n\tthis._coordinateSequenceFactory = null;\n\tthis._SRID = null;\n\tif (arguments.length === 0) {\n\t\tGeometryFactory.call(this, new PrecisionModel(), 0);\n\t} else if (arguments.length === 1) {\n\t\tif (hasInterface(arguments[0], CoordinateSequenceFactory)) {\n\t\t\tvar coordinateSequenceFactory = arguments[0];\n\t\t\tGeometryFactory.call(this, new PrecisionModel(), 0, coordinateSequenceFactory);\n\t\t} else if (arguments[0] instanceof PrecisionModel) {\n\t\t\tvar precisionModel = arguments[0];\n\t\t\tGeometryFactory.call(this, precisionModel, 0, GeometryFactory.getDefaultCoordinateSequenceFactory());\n\t\t}\n\t} else if (arguments.length === 2) {\n\t\tvar precisionModel = arguments[0],\n\t\t    SRID = arguments[1];\n\t\tGeometryFactory.call(this, precisionModel, SRID, GeometryFactory.getDefaultCoordinateSequenceFactory());\n\t} else if (arguments.length === 3) {\n\t\tvar precisionModel = arguments[0],\n\t\t    SRID = arguments[1],\n\t\t    coordinateSequenceFactory = arguments[2];\n\t\tthis._precisionModel = precisionModel;\n\t\tthis._coordinateSequenceFactory = coordinateSequenceFactory;\n\t\tthis._SRID = SRID;\n\t}\n}\nextend(GeometryFactory.prototype, {\n\ttoGeometry: function toGeometry(envelope) {\n\t\tif (envelope.isNull()) {\n\t\t\treturn this.createPoint(null);\n\t\t}\n\t\tif (envelope.getMinX() === envelope.getMaxX() && envelope.getMinY() === envelope.getMaxY()) {\n\t\t\treturn this.createPoint(new Coordinate(envelope.getMinX(), envelope.getMinY()));\n\t\t}\n\t\tif (envelope.getMinX() === envelope.getMaxX() || envelope.getMinY() === envelope.getMaxY()) {\n\t\t\treturn this.createLineString([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY())]);\n\t\t}\n\t\treturn this.createPolygon(this.createLinearRing([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMinY())]), null);\n\t},\n\tcreateLineString: function createLineString() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn this.createLineString(this.getCoordinateSequenceFactory().create([]));\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Array) {\n\t\t\t\tvar coordinates = arguments[0];\n\t\t\t\treturn this.createLineString(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);\n\t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tvar coordinates = arguments[0];\n\t\t\t\treturn new LineString(coordinates, this);\n\t\t\t}\n\t\t}\n\t},\n\tcreateMultiLineString: function createMultiLineString() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn new MultiLineString(null, this);\n\t\t} else if (arguments.length === 1) {\n\t\t\tvar lineStrings = arguments[0];\n\t\t\treturn new MultiLineString(lineStrings, this);\n\t\t}\n\t},\n\tbuildGeometry: function buildGeometry(geomList) {\n\t\tvar geomClass = null;\n\t\tvar isHeterogeneous = false;\n\t\tvar hasGeometryCollection = false;\n\t\tfor (var i = geomList.iterator(); i.hasNext();) {\n\t\t\tvar geom = i.next();\n\t\t\tvar partClass = geom.getClass();\n\t\t\tif (geomClass === null) {\n\t\t\t\tgeomClass = partClass;\n\t\t\t}\n\t\t\tif (partClass !== geomClass) {\n\t\t\t\tisHeterogeneous = true;\n\t\t\t}\n\t\t\tif (geom.isGeometryCollectionOrDerived()) hasGeometryCollection = true;\n\t\t}\n\t\tif (geomClass === null) {\n\t\t\treturn this.createGeometryCollection();\n\t\t}\n\t\tif (isHeterogeneous || hasGeometryCollection) {\n\t\t\treturn this.createGeometryCollection(GeometryFactory.toGeometryArray(geomList));\n\t\t}\n\t\tvar geom0 = geomList.iterator().next();\n\t\tvar isCollection = geomList.size() > 1;\n\t\tif (isCollection) {\n\t\t\tif (geom0 instanceof Polygon) {\n\t\t\t\treturn this.createMultiPolygon(GeometryFactory.toPolygonArray(geomList));\n\t\t\t} else if (geom0 instanceof LineString) {\n\t\t\t\treturn this.createMultiLineString(GeometryFactory.toLineStringArray(geomList));\n\t\t\t} else if (geom0 instanceof Point) {\n\t\t\t\treturn this.createMultiPoint(GeometryFactory.toPointArray(geomList));\n\t\t\t}\n\t\t\tAssert.shouldNeverReachHere(\"Unhandled class: \" + geom0.getClass().getName());\n\t\t}\n\t\treturn geom0;\n\t},\n\tcreateMultiPointFromCoords: function createMultiPointFromCoords(coordinates) {\n\t\treturn this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);\n\t},\n\tcreatePoint: function createPoint() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn this.createPoint(this.getCoordinateSequenceFactory().create([]));\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\t\tvar coordinate = arguments[0];\n\t\t\t\treturn this.createPoint(coordinate !== null ? this.getCoordinateSequenceFactory().create([coordinate]) : null);\n\t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tvar coordinates = arguments[0];\n\t\t\t\treturn new Point(coordinates, this);\n\t\t\t}\n\t\t}\n\t},\n\tgetCoordinateSequenceFactory: function getCoordinateSequenceFactory() {\n\t\treturn this._coordinateSequenceFactory;\n\t},\n\tcreatePolygon: function createPolygon() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn new Polygon(null, null, this);\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tvar coordinates = arguments[0];\n\t\t\t\treturn this.createPolygon(this.createLinearRing(coordinates));\n\t\t\t} else if (arguments[0] instanceof Array) {\n\t\t\t\tvar coordinates = arguments[0];\n\t\t\t\treturn this.createPolygon(this.createLinearRing(coordinates));\n\t\t\t} else if (arguments[0] instanceof LinearRing) {\n\t\t\t\tvar shell = arguments[0];\n\t\t\t\treturn this.createPolygon(shell, null);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar shell = arguments[0],\n\t\t\t    holes = arguments[1];\n\t\t\treturn new Polygon(shell, holes, this);\n\t\t}\n\t},\n\tgetSRID: function getSRID() {\n\t\treturn this._SRID;\n\t},\n\tcreateGeometryCollection: function createGeometryCollection() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn new GeometryCollection(null, this);\n\t\t} else if (arguments.length === 1) {\n\t\t\tvar geometries = arguments[0];\n\t\t\treturn new GeometryCollection(geometries, this);\n\t\t}\n\t},\n\tcreateGeometry: function createGeometry(g) {\n\t\tvar editor = new GeometryEditor(this);\n\t\treturn editor.edit(g, {\n\t\t\tedit: function edit() {\n\t\t\t\tif (arguments.length === 2) {\n\t\t\t\t\tvar coordSeq = arguments[0];\n\t\t\t\t\treturn this._coordinateSequenceFactory.create(coordSeq);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t},\n\tgetPrecisionModel: function getPrecisionModel() {\n\t\treturn this._precisionModel;\n\t},\n\tcreateLinearRing: function createLinearRing() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn this.createLinearRing(this.getCoordinateSequenceFactory().create([]));\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Array) {\n\t\t\t\tvar coordinates = arguments[0];\n\t\t\t\treturn this.createLinearRing(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);\n\t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tvar coordinates = arguments[0];\n\t\t\t\treturn new LinearRing(coordinates, this);\n\t\t\t}\n\t\t}\n\t},\n\tcreateMultiPolygon: function createMultiPolygon() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn new MultiPolygon(null, this);\n\t\t} else if (arguments.length === 1) {\n\t\t\tvar polygons = arguments[0];\n\t\t\treturn new MultiPolygon(polygons, this);\n\t\t}\n\t},\n\tcreateMultiPoint: function createMultiPoint() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn new MultiPoint(null, this);\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Array) {\n\t\t\t\tvar point = arguments[0];\n\t\t\t\treturn new MultiPoint(point, this);\n\t\t\t} else if (arguments[0] instanceof Array) {\n\t\t\t\tvar coordinates = arguments[0];\n\t\t\t\treturn this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);\n\t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tvar coordinates = arguments[0];\n\t\t\t\tif (coordinates === null) {\n\t\t\t\t\treturn this.createMultiPoint(new Array(0).fill(null));\n\t\t\t\t}\n\t\t\t\tvar points = new Array(coordinates.size()).fill(null);\n\t\t\t\tfor (var i = 0; i < coordinates.size(); i++) {\n\t\t\t\t\tvar ptSeq = this.getCoordinateSequenceFactory().create(1, coordinates.getDimension());\n\t\t\t\t\tCoordinateSequences.copy(coordinates, i, ptSeq, 0, 1);\n\t\t\t\t\tpoints[i] = this.createPoint(ptSeq);\n\t\t\t\t}\n\t\t\t\treturn this.createMultiPoint(points);\n\t\t\t}\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Serializable];\n\t},\n\tgetClass: function getClass() {\n\t\treturn GeometryFactory;\n\t}\n});\nGeometryFactory.toMultiPolygonArray = function (multiPolygons) {\n\tvar multiPolygonArray = new Array(multiPolygons.size()).fill(null);\n\treturn multiPolygons.toArray(multiPolygonArray);\n};\nGeometryFactory.toGeometryArray = function (geometries) {\n\tif (geometries === null) return null;\n\tvar geometryArray = new Array(geometries.size()).fill(null);\n\treturn geometries.toArray(geometryArray);\n};\nGeometryFactory.getDefaultCoordinateSequenceFactory = function () {\n\treturn CoordinateArraySequenceFactory.instance();\n};\nGeometryFactory.toMultiLineStringArray = function (multiLineStrings) {\n\tvar multiLineStringArray = new Array(multiLineStrings.size()).fill(null);\n\treturn multiLineStrings.toArray(multiLineStringArray);\n};\nGeometryFactory.toLineStringArray = function (lineStrings) {\n\tvar lineStringArray = new Array(lineStrings.size()).fill(null);\n\treturn lineStrings.toArray(lineStringArray);\n};\nGeometryFactory.toMultiPointArray = function (multiPoints) {\n\tvar multiPointArray = new Array(multiPoints.size()).fill(null);\n\treturn multiPoints.toArray(multiPointArray);\n};\nGeometryFactory.toLinearRingArray = function (linearRings) {\n\tvar linearRingArray = new Array(linearRings.size()).fill(null);\n\treturn linearRings.toArray(linearRingArray);\n};\nGeometryFactory.toPointArray = function (points) {\n\tvar pointArray = new Array(points.size()).fill(null);\n\treturn points.toArray(pointArray);\n};\nGeometryFactory.toPolygonArray = function (polygons) {\n\tvar polygonArray = new Array(polygons.size()).fill(null);\n\treturn polygons.toArray(polygonArray);\n};\nGeometryFactory.createPointFromInternalCoord = function (coord, exemplar) {\n\texemplar.getPrecisionModel().makePrecise(coord);\n\treturn exemplar.getFactory().createPoint(coord);\n};\nGeometryFactory.serialVersionUID = -6820524753094095635;\n\nvar regExes = {\n  'typeStr': /^\\s*(\\w+)\\s*\\(\\s*(.*)\\s*\\)\\s*$/,\n  'emptyTypeStr': /^\\s*(\\w+)\\s*EMPTY\\s*$/,\n  'spaces': /\\s+/,\n  'parenComma': /\\)\\s*,\\s*\\(/,\n  'doubleParenComma': /\\)\\s*\\)\\s*,\\s*\\(\\s*\\(/, // can't use {2} here\n  'trimParens': /^\\s*\\(?(.*?)\\)?\\s*$/\n\n  /**\n   * Class for reading and writing Well-Known Text.\n   *\n   * NOTE: Adapted from OpenLayers 2.11 implementation.\n   */\n\n  /** Create a new parser for WKT\n   *\n   * @param {GeometryFactory} geometryFactory\n   * @return An instance of WKTParser.\n   * @constructor\n   * @private\n   */\n};function WKTParser(geometryFactory) {\n  this.geometryFactory = geometryFactory || new GeometryFactory();\n}\n\nextend(WKTParser.prototype, {\n  /**\n   * Deserialize a WKT string and return a geometry. Supports WKT for POINT,\n   * MULTIPOINT, LINESTRING, LINEARRING, MULTILINESTRING, POLYGON, MULTIPOLYGON,\n   * and GEOMETRYCOLLECTION.\n   *\n   * @param {String} wkt A WKT string.\n   * @return {Geometry} A geometry instance.\n   * @private\n   */\n  read: function read(wkt) {\n    var geometry, type, str;\n    wkt = wkt.replace(/[\\n\\r]/g, ' ');\n    var matches = regExes.typeStr.exec(wkt);\n    if (wkt.search('EMPTY') !== -1) {\n      matches = regExes.emptyTypeStr.exec(wkt);\n      matches[2] = undefined;\n    }\n    if (matches) {\n      type = matches[1].toLowerCase();\n      str = matches[2];\n      if (parse[type]) {\n        geometry = parse[type].apply(this, [str]);\n      }\n    }\n\n    if (geometry === undefined) throw new Error('Could not parse WKT ' + wkt);\n\n    return geometry;\n  },\n\n\n  /**\n   * Serialize a geometry into a WKT string.\n   *\n   * @param {Geometry} geometry A feature or array of features.\n   * @return {String} The WKT string representation of the input geometries.\n   * @private\n   */\n  write: function write(geometry) {\n    return this.extractGeometry(geometry);\n  },\n\n\n  /**\n   * Entry point to construct the WKT for a single Geometry object.\n   *\n   * @param {Geometry} geometry\n   * @return {String} A WKT string of representing the geometry.\n   * @private\n   */\n  extractGeometry: function extractGeometry(geometry) {\n    var type = geometry.getGeometryType().toLowerCase();\n    if (!extract$1[type]) {\n      return null;\n    }\n    var wktType = type.toUpperCase();\n    var data;\n    if (geometry.isEmpty()) {\n      data = wktType + ' EMPTY';\n    } else {\n      data = wktType + '(' + extract$1[type].apply(this, [geometry]) + ')';\n    }\n    return data;\n  }\n});\n\n/**\n * Object with properties corresponding to the geometry types. Property values\n * are functions that do the actual data extraction.\n * @private\n */\nvar extract$1 = {\n  coordinate: function coordinate(_coordinate) {\n    return _coordinate.x + ' ' + _coordinate.y;\n  },\n\n\n  /**\n   * Return a space delimited string of point coordinates.\n   *\n   * @param {Point}\n   *          point\n   * @return {String} A string of coordinates representing the point.\n   */\n  point: function point(_point) {\n    return extract$1.coordinate.call(this, _point._coordinates._coordinates[0]);\n  },\n\n\n  /**\n   * Return a comma delimited string of point coordinates from a multipoint.\n   *\n   * @param {MultiPoint}\n   *          multipoint\n   * @return {String} A string of point coordinate strings representing the\n   *         multipoint.\n   */\n  multipoint: function multipoint(_multipoint) {\n    var array = [];\n    for (var i = 0, len = _multipoint._geometries.length; i < len; ++i) {\n      array.push('(' + extract$1.point.apply(this, [_multipoint._geometries[i]]) + ')');\n    }\n    return array.join(',');\n  },\n\n\n  /**\n   * Return a comma delimited string of point coordinates from a line.\n   *\n   * @param {LineString} linestring\n   * @return {String} A string of point coordinate strings representing the linestring.\n   */\n  linestring: function linestring(_linestring) {\n    var array = [];\n    for (var i = 0, len = _linestring._points._coordinates.length; i < len; ++i) {\n      array.push(extract$1.coordinate.apply(this, [_linestring._points._coordinates[i]]));\n    }\n    return array.join(',');\n  },\n  linearring: function linearring(_linearring) {\n    var array = [];\n    for (var i = 0, len = _linearring._points._coordinates.length; i < len; ++i) {\n      array.push(extract$1.coordinate.apply(this, [_linearring._points._coordinates[i]]));\n    }\n    return array.join(',');\n  },\n\n\n  /**\n   * Return a comma delimited string of linestring strings from a\n   * multilinestring.\n   *\n   * @param {MultiLineString} multilinestring\n   * @return {String} A string of of linestring strings representing the multilinestring.\n   */\n  multilinestring: function multilinestring(_multilinestring) {\n    var array = [];\n    for (var i = 0, len = _multilinestring._geometries.length; i < len; ++i) {\n      array.push('(' + extract$1.linestring.apply(this, [_multilinestring._geometries[i]]) + ')');\n    }\n    return array.join(',');\n  },\n\n\n  /**\n   * Return a comma delimited string of linear ring arrays from a polygon.\n   *\n   * @param {Polygon} polygon\n   * @return {String} An array of linear ring arrays representing the polygon.\n   */\n  polygon: function polygon(_polygon) {\n    var array = [];\n    array.push('(' + extract$1.linestring.apply(this, [_polygon._shell]) + ')');\n    for (var i = 0, len = _polygon._holes.length; i < len; ++i) {\n      array.push('(' + extract$1.linestring.apply(this, [_polygon._holes[i]]) + ')');\n    }\n    return array.join(',');\n  },\n\n\n  /**\n   * Return an array of polygon arrays from a multipolygon.\n   *\n   * @param {MultiPolygon} multipolygon\n   * @return {String} An array of polygon arrays representing the multipolygon.\n   */\n  multipolygon: function multipolygon(_multipolygon) {\n    var array = [];\n    for (var i = 0, len = _multipolygon._geometries.length; i < len; ++i) {\n      array.push('(' + extract$1.polygon.apply(this, [_multipolygon._geometries[i]]) + ')');\n    }\n    return array.join(',');\n  },\n\n\n  /**\n   * Return the WKT portion between 'GEOMETRYCOLLECTION(' and ')' for an\n   * geometrycollection.\n   *\n   * @param {GeometryCollection} collection\n   * @return {String} internal WKT representation of the collection.\n   */\n  geometrycollection: function geometrycollection(collection) {\n    var array = [];\n    for (var i = 0, len = collection._geometries.length; i < len; ++i) {\n      array.push(this.extractGeometry(collection._geometries[i]));\n    }\n    return array.join(',');\n  }\n};\n\n/**\n * Object with properties corresponding to the geometry types. Property values\n * are functions that do the actual parsing.\n * @private\n */\nvar parse = {\n  /**\n   * Return point geometry given a point WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the point.\n   * @return {Point} A point geometry.\n   * @private\n   */\n  point: function point(str) {\n    if (str === undefined) {\n      return this.geometryFactory.createPoint();\n    }\n\n    var coords = str.trim().split(regExes.spaces);\n    return this.geometryFactory.createPoint(new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1])));\n  },\n\n\n  /**\n   * Return a multipoint geometry given a multipoint WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the multipoint.\n   * @return {Point} A multipoint feature.\n   * @private\n   */\n  multipoint: function multipoint(str) {\n    if (str === undefined) {\n      return this.geometryFactory.createMultiPoint();\n    }\n\n    var point;\n    var points = str.trim().split(',');\n    var components = [];\n    for (var i = 0, len = points.length; i < len; ++i) {\n      point = points[i].replace(regExes.trimParens, '$1');\n      components.push(parse.point.apply(this, [point]));\n    }\n    return this.geometryFactory.createMultiPoint(components);\n  },\n\n\n  /**\n   * Return a linestring geometry given a linestring WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the linestring.\n   * @return {LineString} A linestring geometry.\n   * @private\n   */\n  linestring: function linestring(str) {\n    if (str === undefined) {\n      return this.geometryFactory.createLineString();\n    }\n\n    var points = str.trim().split(',');\n    var components = [];\n    var coords;\n    for (var i = 0, len = points.length; i < len; ++i) {\n      coords = points[i].trim().split(regExes.spaces);\n      components.push(new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1])));\n    }\n    return this.geometryFactory.createLineString(components);\n  },\n\n\n  /**\n   * Return a linearring geometry given a linearring WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the linearring.\n   * @return {LinearRing} A linearring geometry.\n   * @private\n   */\n  linearring: function linearring(str) {\n    if (str === undefined) {\n      return this.geometryFactory.createLinearRing();\n    }\n\n    var points = str.trim().split(',');\n    var components = [];\n    var coords;\n    for (var i = 0, len = points.length; i < len; ++i) {\n      coords = points[i].trim().split(regExes.spaces);\n      components.push(new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1])));\n    }\n    return this.geometryFactory.createLinearRing(components);\n  },\n\n\n  /**\n   * Return a multilinestring geometry given a multilinestring WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the multilinestring.\n   * @return {MultiLineString} A multilinestring geometry.\n   * @private\n   */\n  multilinestring: function multilinestring(str) {\n    if (str === undefined) {\n      return this.geometryFactory.createMultiLineString();\n    }\n\n    var line;\n    var lines = str.trim().split(regExes.parenComma);\n    var components = [];\n    for (var i = 0, len = lines.length; i < len; ++i) {\n      line = lines[i].replace(regExes.trimParens, '$1');\n      components.push(parse.linestring.apply(this, [line]));\n    }\n    return this.geometryFactory.createMultiLineString(components);\n  },\n\n\n  /**\n   * Return a polygon geometry given a polygon WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the polygon.\n   * @return {Polygon} A polygon geometry.\n   * @private\n   */\n  polygon: function polygon(str) {\n    if (str === undefined) {\n      return this.geometryFactory.createPolygon();\n    }\n\n    var ring, linestring, linearring;\n    var rings = str.trim().split(regExes.parenComma);\n    var shell;\n    var holes = [];\n    for (var i = 0, len = rings.length; i < len; ++i) {\n      ring = rings[i].replace(regExes.trimParens, '$1');\n      linestring = parse.linestring.apply(this, [ring]);\n      linearring = this.geometryFactory.createLinearRing(linestring._points);\n      if (i === 0) {\n        shell = linearring;\n      } else {\n        holes.push(linearring);\n      }\n    }\n    return this.geometryFactory.createPolygon(shell, holes);\n  },\n\n\n  /**\n   * Return a multipolygon geometry given a multipolygon WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the multipolygon.\n   * @return {MultiPolygon} A multipolygon geometry.\n   * @private\n   */\n  multipolygon: function multipolygon(str) {\n    if (str === undefined) {\n      return this.geometryFactory.createMultiPolygon();\n    }\n\n    var polygon;\n    var polygons = str.trim().split(regExes.doubleParenComma);\n    var components = [];\n    for (var i = 0, len = polygons.length; i < len; ++i) {\n      polygon = polygons[i].replace(regExes.trimParens, '$1');\n      components.push(parse.polygon.apply(this, [polygon]));\n    }\n    return this.geometryFactory.createMultiPolygon(components);\n  },\n\n\n  /**\n   * Return a geometrycollection given a geometrycollection WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the geometrycollection.\n   * @return {GeometryCollection}\n   * @private\n   */\n  geometrycollection: function geometrycollection(str) {\n    if (str === undefined) {\n      return this.geometryFactory.createGeometryCollection();\n    }\n\n    // separate components of the collection with |\n    str = str.replace(/,\\s*([A-Za-z])/g, '|$1');\n    var wktArray = str.trim().split('|');\n    var components = [];\n    for (var i = 0, len = wktArray.length; i < len; ++i) {\n      components.push(this.read(wktArray[i]));\n    }\n    return this.geometryFactory.createGeometryCollection(components);\n  }\n};\n\n/**\n * Writes the Well-Known Text representation of a {@link Geometry}. The\n * Well-Known Text format is defined in the <A\n * HREF=\"http://www.opengis.org/techno/specs.htm\"> OGC Simple Features\n * Specification for SQL</A>.\n * <p>\n * The <code>WKTWriter</code> outputs coordinates rounded to the precision\n * model. Only the maximum number of decimal places necessary to represent the\n * ordinates to the required precision will be output.\n * <p>\n * The SFS WKT spec does not define a special tag for {@link LinearRing}s.\n * Under the spec, rings are output as <code>LINESTRING</code>s.\n */\n\n/**\n * @param {GeometryFactory} geometryFactory\n * @constructor\n */\nfunction WKTWriter(geometryFactory) {\n  this.parser = new WKTParser(geometryFactory);\n}\n\nextend(WKTWriter.prototype, {\n  /**\n   * Converts a <code>Geometry</code> to its Well-known Text representation.\n   *\n   * @param {Geometry} geometry a <code>Geometry</code> to process.\n   * @return {string} a <Geometry Tagged Text> string (see the OpenGIS Simple\n   *         Features Specification).\n   * @memberof WKTWriter\n   */\n  write: function write(geometry) {\n    return this.parser.write(geometry);\n  }\n});\n\nextend(WKTWriter, {\n  /**\n   * Generates the WKT for a <tt>LINESTRING</tt> specified by two\n   * {@link Coordinate}s.\n   *\n   * @param p0 the first coordinate.\n   * @param p1 the second coordinate.\n   *\n   * @return the WKT.\n   * @private\n   */\n  toLineString: function toLineString(p0, p1) {\n    if (arguments.length !== 2) {\n      throw new Error('Not implemented');\n    }\n\n    return 'LINESTRING ( ' + p0.x + ' ' + p0.y + ', ' + p1.x + ' ' + p1.y + ' )';\n  }\n});\n\nfunction LineIntersector() {\n\tthis._result = null;\n\tthis._inputLines = Array(2).fill().map(function () {\n\t\treturn Array(2);\n\t});\n\tthis._intPt = new Array(2).fill(null);\n\tthis._intLineIndex = null;\n\tthis._isProper = null;\n\tthis._pa = null;\n\tthis._pb = null;\n\tthis._precisionModel = null;\n\tthis._intPt[0] = new Coordinate();\n\tthis._intPt[1] = new Coordinate();\n\tthis._pa = this._intPt[0];\n\tthis._pb = this._intPt[1];\n\tthis._result = 0;\n}\nextend(LineIntersector.prototype, {\n\tgetIndexAlongSegment: function getIndexAlongSegment(segmentIndex, intIndex) {\n\t\tthis.computeIntLineIndex();\n\t\treturn this._intLineIndex[segmentIndex][intIndex];\n\t},\n\tgetTopologySummary: function getTopologySummary() {\n\t\tvar catBuf = new StringBuffer();\n\t\tif (this.isEndPoint()) catBuf.append(\" endpoint\");\n\t\tif (this._isProper) catBuf.append(\" proper\");\n\t\tif (this.isCollinear()) catBuf.append(\" collinear\");\n\t\treturn catBuf.toString();\n\t},\n\tcomputeIntersection: function computeIntersection(p1, p2, p3, p4) {\n\t\tthis._inputLines[0][0] = p1;\n\t\tthis._inputLines[0][1] = p2;\n\t\tthis._inputLines[1][0] = p3;\n\t\tthis._inputLines[1][1] = p4;\n\t\tthis._result = this.computeIntersect(p1, p2, p3, p4);\n\t},\n\tgetIntersectionNum: function getIntersectionNum() {\n\t\treturn this._result;\n\t},\n\tcomputeIntLineIndex: function computeIntLineIndex() {\n\t\tif (arguments.length === 0) {\n\t\t\tif (this._intLineIndex === null) {\n\t\t\t\tthis._intLineIndex = Array(2).fill().map(function () {\n\t\t\t\t\treturn Array(2);\n\t\t\t\t});\n\t\t\t\tthis.computeIntLineIndex(0);\n\t\t\t\tthis.computeIntLineIndex(1);\n\t\t\t}\n\t\t} else if (arguments.length === 1) {\n\t\t\tvar segmentIndex = arguments[0];\n\t\t\tvar dist0 = this.getEdgeDistance(segmentIndex, 0);\n\t\t\tvar dist1 = this.getEdgeDistance(segmentIndex, 1);\n\t\t\tif (dist0 > dist1) {\n\t\t\t\tthis._intLineIndex[segmentIndex][0] = 0;\n\t\t\t\tthis._intLineIndex[segmentIndex][1] = 1;\n\t\t\t} else {\n\t\t\t\tthis._intLineIndex[segmentIndex][0] = 1;\n\t\t\t\tthis._intLineIndex[segmentIndex][1] = 0;\n\t\t\t}\n\t\t}\n\t},\n\tisProper: function isProper() {\n\t\treturn this.hasIntersection() && this._isProper;\n\t},\n\tsetPrecisionModel: function setPrecisionModel(precisionModel) {\n\t\tthis._precisionModel = precisionModel;\n\t},\n\tisInteriorIntersection: function isInteriorIntersection() {\n\t\tif (arguments.length === 0) {\n\t\t\tif (this.isInteriorIntersection(0)) return true;\n\t\t\tif (this.isInteriorIntersection(1)) return true;\n\t\t\treturn false;\n\t\t} else if (arguments.length === 1) {\n\t\t\tvar inputLineIndex = arguments[0];\n\t\t\tfor (var i = 0; i < this._result; i++) {\n\t\t\t\tif (!(this._intPt[i].equals2D(this._inputLines[inputLineIndex][0]) || this._intPt[i].equals2D(this._inputLines[inputLineIndex][1]))) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t},\n\tgetIntersection: function getIntersection(intIndex) {\n\t\treturn this._intPt[intIndex];\n\t},\n\tisEndPoint: function isEndPoint() {\n\t\treturn this.hasIntersection() && !this._isProper;\n\t},\n\thasIntersection: function hasIntersection() {\n\t\treturn this._result !== LineIntersector.NO_INTERSECTION;\n\t},\n\tgetEdgeDistance: function getEdgeDistance(segmentIndex, intIndex) {\n\t\tvar dist = LineIntersector.computeEdgeDistance(this._intPt[intIndex], this._inputLines[segmentIndex][0], this._inputLines[segmentIndex][1]);\n\t\treturn dist;\n\t},\n\tisCollinear: function isCollinear() {\n\t\treturn this._result === LineIntersector.COLLINEAR_INTERSECTION;\n\t},\n\ttoString: function toString() {\n\t\treturn WKTWriter.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + \" - \" + WKTWriter.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();\n\t},\n\tgetEndpoint: function getEndpoint(segmentIndex, ptIndex) {\n\t\treturn this._inputLines[segmentIndex][ptIndex];\n\t},\n\tisIntersection: function isIntersection(pt) {\n\t\tfor (var i = 0; i < this._result; i++) {\n\t\t\tif (this._intPt[i].equals2D(pt)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tgetIntersectionAlongSegment: function getIntersectionAlongSegment(segmentIndex, intIndex) {\n\t\tthis.computeIntLineIndex();\n\t\treturn this._intPt[this._intLineIndex[segmentIndex][intIndex]];\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn LineIntersector;\n\t}\n});\nLineIntersector.computeEdgeDistance = function (p, p0, p1) {\n\tvar dx = Math.abs(p1.x - p0.x);\n\tvar dy = Math.abs(p1.y - p0.y);\n\tvar dist = -1.0;\n\tif (p.equals(p0)) {\n\t\tdist = 0.0;\n\t} else if (p.equals(p1)) {\n\t\tif (dx > dy) dist = dx;else dist = dy;\n\t} else {\n\t\tvar pdx = Math.abs(p.x - p0.x);\n\t\tvar pdy = Math.abs(p.y - p0.y);\n\t\tif (dx > dy) dist = pdx;else dist = pdy;\n\t\tif (dist === 0.0 && !p.equals(p0)) {\n\t\t\tdist = Math.max(pdx, pdy);\n\t\t}\n\t}\n\tAssert.isTrue(!(dist === 0.0 && !p.equals(p0)), \"Bad distance calculation\");\n\treturn dist;\n};\nLineIntersector.nonRobustComputeEdgeDistance = function (p, p1, p2) {\n\tvar dx = p.x - p1.x;\n\tvar dy = p.y - p1.y;\n\tvar dist = Math.sqrt(dx * dx + dy * dy);\n\tAssert.isTrue(!(dist === 0.0 && !p.equals(p1)), \"Invalid distance calculation\");\n\treturn dist;\n};\nLineIntersector.DONT_INTERSECT = 0;\nLineIntersector.DO_INTERSECT = 1;\nLineIntersector.COLLINEAR = 2;\nLineIntersector.NO_INTERSECTION = 0;\nLineIntersector.POINT_INTERSECTION = 1;\nLineIntersector.COLLINEAR_INTERSECTION = 2;\n\nfunction RobustLineIntersector() {\n\tLineIntersector.apply(this);\n}\ninherits$1(RobustLineIntersector, LineIntersector);\nextend(RobustLineIntersector.prototype, {\n\tisInSegmentEnvelopes: function isInSegmentEnvelopes(intPt) {\n\t\tvar env0 = new Envelope(this._inputLines[0][0], this._inputLines[0][1]);\n\t\tvar env1 = new Envelope(this._inputLines[1][0], this._inputLines[1][1]);\n\t\treturn env0.contains(intPt) && env1.contains(intPt);\n\t},\n\tcomputeIntersection: function computeIntersection() {\n\t\tif (arguments.length === 3) {\n\t\t\tvar p = arguments[0],\n\t\t\t    p1 = arguments[1],\n\t\t\t    p2 = arguments[2];\n\t\t\tthis._isProper = false;\n\t\t\tif (Envelope.intersects(p1, p2, p)) {\n\t\t\t\tif (CGAlgorithms.orientationIndex(p1, p2, p) === 0 && CGAlgorithms.orientationIndex(p2, p1, p) === 0) {\n\t\t\t\t\tthis._isProper = true;\n\t\t\t\t\tif (p.equals(p1) || p.equals(p2)) {\n\t\t\t\t\t\tthis._isProper = false;\n\t\t\t\t\t}\n\t\t\t\t\tthis._result = LineIntersector.POINT_INTERSECTION;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._result = LineIntersector.NO_INTERSECTION;\n\t\t} else return LineIntersector.prototype.computeIntersection.apply(this, arguments);\n\t},\n\tnormalizeToMinimum: function normalizeToMinimum(n1, n2, n3, n4, normPt) {\n\t\tnormPt.x = this.smallestInAbsValue(n1.x, n2.x, n3.x, n4.x);\n\t\tnormPt.y = this.smallestInAbsValue(n1.y, n2.y, n3.y, n4.y);\n\t\tn1.x -= normPt.x;\n\t\tn1.y -= normPt.y;\n\t\tn2.x -= normPt.x;\n\t\tn2.y -= normPt.y;\n\t\tn3.x -= normPt.x;\n\t\tn3.y -= normPt.y;\n\t\tn4.x -= normPt.x;\n\t\tn4.y -= normPt.y;\n\t},\n\tsafeHCoordinateIntersection: function safeHCoordinateIntersection(p1, p2, q1, q2) {\n\t\tvar intPt = null;\n\t\ttry {\n\t\t\tintPt = HCoordinate.intersection(p1, p2, q1, q2);\n\t\t} catch (e) {\n\t\t\tif (e instanceof NotRepresentableException) {\n\t\t\t\tintPt = RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2);\n\t\t\t} else throw e;\n\t\t} finally {}\n\t\treturn intPt;\n\t},\n\tintersection: function intersection(p1, p2, q1, q2) {\n\t\tvar intPt = this.intersectionWithNormalization(p1, p2, q1, q2);\n\t\tif (!this.isInSegmentEnvelopes(intPt)) {\n\t\t\tintPt = new Coordinate(RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2));\n\t\t}\n\t\tif (this._precisionModel !== null) {\n\t\t\tthis._precisionModel.makePrecise(intPt);\n\t\t}\n\t\treturn intPt;\n\t},\n\tsmallestInAbsValue: function smallestInAbsValue(x1, x2, x3, x4) {\n\t\tvar x = x1;\n\t\tvar xabs = Math.abs(x);\n\t\tif (Math.abs(x2) < xabs) {\n\t\t\tx = x2;\n\t\t\txabs = Math.abs(x2);\n\t\t}\n\t\tif (Math.abs(x3) < xabs) {\n\t\t\tx = x3;\n\t\t\txabs = Math.abs(x3);\n\t\t}\n\t\tif (Math.abs(x4) < xabs) {\n\t\t\tx = x4;\n\t\t}\n\t\treturn x;\n\t},\n\tcheckDD: function checkDD(p1, p2, q1, q2, intPt) {\n\t\tvar intPtDD = CGAlgorithmsDD.intersection(p1, p2, q1, q2);\n\t\tvar isIn = this.isInSegmentEnvelopes(intPtDD);\n\t\tSystem.out.println(\"DD in env = \" + isIn + \"  --------------------- \" + intPtDD);\n\t\tif (intPt.distance(intPtDD) > 0.0001) {\n\t\t\tSystem.out.println(\"Distance = \" + intPt.distance(intPtDD));\n\t\t}\n\t},\n\tintersectionWithNormalization: function intersectionWithNormalization(p1, p2, q1, q2) {\n\t\tvar n1 = new Coordinate(p1);\n\t\tvar n2 = new Coordinate(p2);\n\t\tvar n3 = new Coordinate(q1);\n\t\tvar n4 = new Coordinate(q2);\n\t\tvar normPt = new Coordinate();\n\t\tthis.normalizeToEnvCentre(n1, n2, n3, n4, normPt);\n\t\tvar intPt = this.safeHCoordinateIntersection(n1, n2, n3, n4);\n\t\tintPt.x += normPt.x;\n\t\tintPt.y += normPt.y;\n\t\treturn intPt;\n\t},\n\tcomputeCollinearIntersection: function computeCollinearIntersection(p1, p2, q1, q2) {\n\t\tvar p1q1p2 = Envelope.intersects(p1, p2, q1);\n\t\tvar p1q2p2 = Envelope.intersects(p1, p2, q2);\n\t\tvar q1p1q2 = Envelope.intersects(q1, q2, p1);\n\t\tvar q1p2q2 = Envelope.intersects(q1, q2, p2);\n\t\tif (p1q1p2 && p1q2p2) {\n\t\t\tthis._intPt[0] = q1;\n\t\t\tthis._intPt[1] = q2;\n\t\t\treturn LineIntersector.COLLINEAR_INTERSECTION;\n\t\t}\n\t\tif (q1p1q2 && q1p2q2) {\n\t\t\tthis._intPt[0] = p1;\n\t\t\tthis._intPt[1] = p2;\n\t\t\treturn LineIntersector.COLLINEAR_INTERSECTION;\n\t\t}\n\t\tif (p1q1p2 && q1p1q2) {\n\t\t\tthis._intPt[0] = q1;\n\t\t\tthis._intPt[1] = p1;\n\t\t\treturn q1.equals(p1) && !p1q2p2 && !q1p2q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n\t\t}\n\t\tif (p1q1p2 && q1p2q2) {\n\t\t\tthis._intPt[0] = q1;\n\t\t\tthis._intPt[1] = p2;\n\t\t\treturn q1.equals(p2) && !p1q2p2 && !q1p1q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n\t\t}\n\t\tif (p1q2p2 && q1p1q2) {\n\t\t\tthis._intPt[0] = q2;\n\t\t\tthis._intPt[1] = p1;\n\t\t\treturn q2.equals(p1) && !p1q1p2 && !q1p2q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n\t\t}\n\t\tif (p1q2p2 && q1p2q2) {\n\t\t\tthis._intPt[0] = q2;\n\t\t\tthis._intPt[1] = p2;\n\t\t\treturn q2.equals(p2) && !p1q1p2 && !q1p1q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n\t\t}\n\t\treturn LineIntersector.NO_INTERSECTION;\n\t},\n\tnormalizeToEnvCentre: function normalizeToEnvCentre(n00, n01, n10, n11, normPt) {\n\t\tvar minX0 = n00.x < n01.x ? n00.x : n01.x;\n\t\tvar minY0 = n00.y < n01.y ? n00.y : n01.y;\n\t\tvar maxX0 = n00.x > n01.x ? n00.x : n01.x;\n\t\tvar maxY0 = n00.y > n01.y ? n00.y : n01.y;\n\t\tvar minX1 = n10.x < n11.x ? n10.x : n11.x;\n\t\tvar minY1 = n10.y < n11.y ? n10.y : n11.y;\n\t\tvar maxX1 = n10.x > n11.x ? n10.x : n11.x;\n\t\tvar maxY1 = n10.y > n11.y ? n10.y : n11.y;\n\t\tvar intMinX = minX0 > minX1 ? minX0 : minX1;\n\t\tvar intMaxX = maxX0 < maxX1 ? maxX0 : maxX1;\n\t\tvar intMinY = minY0 > minY1 ? minY0 : minY1;\n\t\tvar intMaxY = maxY0 < maxY1 ? maxY0 : maxY1;\n\t\tvar intMidX = (intMinX + intMaxX) / 2.0;\n\t\tvar intMidY = (intMinY + intMaxY) / 2.0;\n\t\tnormPt.x = intMidX;\n\t\tnormPt.y = intMidY;\n\t\tn00.x -= normPt.x;\n\t\tn00.y -= normPt.y;\n\t\tn01.x -= normPt.x;\n\t\tn01.y -= normPt.y;\n\t\tn10.x -= normPt.x;\n\t\tn10.y -= normPt.y;\n\t\tn11.x -= normPt.x;\n\t\tn11.y -= normPt.y;\n\t},\n\tcomputeIntersect: function computeIntersect(p1, p2, q1, q2) {\n\t\tthis._isProper = false;\n\t\tif (!Envelope.intersects(p1, p2, q1, q2)) return LineIntersector.NO_INTERSECTION;\n\t\tvar Pq1 = CGAlgorithms.orientationIndex(p1, p2, q1);\n\t\tvar Pq2 = CGAlgorithms.orientationIndex(p1, p2, q2);\n\t\tif (Pq1 > 0 && Pq2 > 0 || Pq1 < 0 && Pq2 < 0) {\n\t\t\treturn LineIntersector.NO_INTERSECTION;\n\t\t}\n\t\tvar Qp1 = CGAlgorithms.orientationIndex(q1, q2, p1);\n\t\tvar Qp2 = CGAlgorithms.orientationIndex(q1, q2, p2);\n\t\tif (Qp1 > 0 && Qp2 > 0 || Qp1 < 0 && Qp2 < 0) {\n\t\t\treturn LineIntersector.NO_INTERSECTION;\n\t\t}\n\t\tvar collinear = Pq1 === 0 && Pq2 === 0 && Qp1 === 0 && Qp2 === 0;\n\t\tif (collinear) {\n\t\t\treturn this.computeCollinearIntersection(p1, p2, q1, q2);\n\t\t}\n\t\tif (Pq1 === 0 || Pq2 === 0 || Qp1 === 0 || Qp2 === 0) {\n\t\t\tthis._isProper = false;\n\t\t\tif (p1.equals2D(q1) || p1.equals2D(q2)) {\n\t\t\t\tthis._intPt[0] = p1;\n\t\t\t} else if (p2.equals2D(q1) || p2.equals2D(q2)) {\n\t\t\t\tthis._intPt[0] = p2;\n\t\t\t} else if (Pq1 === 0) {\n\t\t\t\tthis._intPt[0] = new Coordinate(q1);\n\t\t\t} else if (Pq2 === 0) {\n\t\t\t\tthis._intPt[0] = new Coordinate(q2);\n\t\t\t} else if (Qp1 === 0) {\n\t\t\t\tthis._intPt[0] = new Coordinate(p1);\n\t\t\t} else if (Qp2 === 0) {\n\t\t\t\tthis._intPt[0] = new Coordinate(p2);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._isProper = true;\n\t\t\tthis._intPt[0] = this.intersection(p1, p2, q1, q2);\n\t\t}\n\t\treturn LineIntersector.POINT_INTERSECTION;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn RobustLineIntersector;\n\t}\n});\nRobustLineIntersector.nearestEndpoint = function (p1, p2, q1, q2) {\n\tvar nearestPt = p1;\n\tvar minDist = CGAlgorithms.distancePointLine(p1, q1, q2);\n\tvar dist = CGAlgorithms.distancePointLine(p2, q1, q2);\n\tif (dist < minDist) {\n\t\tminDist = dist;\n\t\tnearestPt = p2;\n\t}\n\tdist = CGAlgorithms.distancePointLine(q1, p1, p2);\n\tif (dist < minDist) {\n\t\tminDist = dist;\n\t\tnearestPt = q1;\n\t}\n\tdist = CGAlgorithms.distancePointLine(q2, p1, p2);\n\tif (dist < minDist) {\n\t\tminDist = dist;\n\t\tnearestPt = q2;\n\t}\n\treturn nearestPt;\n};\n\nfunction RobustDeterminant() {}\nextend(RobustDeterminant.prototype, {\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn RobustDeterminant;\n\t}\n});\nRobustDeterminant.orientationIndex = function (p1, p2, q) {\n\tvar dx1 = p2.x - p1.x;\n\tvar dy1 = p2.y - p1.y;\n\tvar dx2 = q.x - p2.x;\n\tvar dy2 = q.y - p2.y;\n\treturn RobustDeterminant.signOfDet2x2(dx1, dy1, dx2, dy2);\n};\nRobustDeterminant.signOfDet2x2 = function (x1, y1, x2, y2) {\n\tvar sign = null;\n\tvar swap = null;\n\tvar k = null;\n\tsign = 1;\n\tif (x1 === 0.0 || y2 === 0.0) {\n\t\tif (y1 === 0.0 || x2 === 0.0) {\n\t\t\treturn 0;\n\t\t} else if (y1 > 0) {\n\t\t\tif (x2 > 0) {\n\t\t\t\treturn -sign;\n\t\t\t} else {\n\t\t\t\treturn sign;\n\t\t\t}\n\t\t} else {\n\t\t\tif (x2 > 0) {\n\t\t\t\treturn sign;\n\t\t\t} else {\n\t\t\t\treturn -sign;\n\t\t\t}\n\t\t}\n\t}\n\tif (y1 === 0.0 || x2 === 0.0) {\n\t\tif (y2 > 0) {\n\t\t\tif (x1 > 0) {\n\t\t\t\treturn sign;\n\t\t\t} else {\n\t\t\t\treturn -sign;\n\t\t\t}\n\t\t} else {\n\t\t\tif (x1 > 0) {\n\t\t\t\treturn -sign;\n\t\t\t} else {\n\t\t\t\treturn sign;\n\t\t\t}\n\t\t}\n\t}\n\tif (0.0 < y1) {\n\t\tif (0.0 < y2) {\n\t\t\tif (y1 <= y2) {\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tsign = -sign;\n\t\t\t\tswap = x1;\n\t\t\t\tx1 = x2;\n\t\t\t\tx2 = swap;\n\t\t\t\tswap = y1;\n\t\t\t\ty1 = y2;\n\t\t\t\ty2 = swap;\n\t\t\t}\n\t\t} else {\n\t\t\tif (y1 <= -y2) {\n\t\t\t\tsign = -sign;\n\t\t\t\tx2 = -x2;\n\t\t\t\ty2 = -y2;\n\t\t\t} else {\n\t\t\t\tswap = x1;\n\t\t\t\tx1 = -x2;\n\t\t\t\tx2 = swap;\n\t\t\t\tswap = y1;\n\t\t\t\ty1 = -y2;\n\t\t\t\ty2 = swap;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (0.0 < y2) {\n\t\t\tif (-y1 <= y2) {\n\t\t\t\tsign = -sign;\n\t\t\t\tx1 = -x1;\n\t\t\t\ty1 = -y1;\n\t\t\t} else {\n\t\t\t\tswap = -x1;\n\t\t\t\tx1 = x2;\n\t\t\t\tx2 = swap;\n\t\t\t\tswap = -y1;\n\t\t\t\ty1 = y2;\n\t\t\t\ty2 = swap;\n\t\t\t}\n\t\t} else {\n\t\t\tif (y1 >= y2) {\n\t\t\t\tx1 = -x1;\n\t\t\t\ty1 = -y1;\n\t\t\t\tx2 = -x2;\n\t\t\t\ty2 = -y2;\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tsign = -sign;\n\t\t\t\tswap = -x1;\n\t\t\t\tx1 = -x2;\n\t\t\t\tx2 = swap;\n\t\t\t\tswap = -y1;\n\t\t\t\ty1 = -y2;\n\t\t\t\ty2 = swap;\n\t\t\t}\n\t\t}\n\t}\n\tif (0.0 < x1) {\n\t\tif (0.0 < x2) {\n\t\t\tif (x1 <= x2) {\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\treturn sign;\n\t\t\t}\n\t\t} else {\n\t\t\treturn sign;\n\t\t}\n\t} else {\n\t\tif (0.0 < x2) {\n\t\t\treturn -sign;\n\t\t} else {\n\t\t\tif (x1 >= x2) {\n\t\t\t\tsign = -sign;\n\t\t\t\tx1 = -x1;\n\t\t\t\tx2 = -x2;\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\treturn -sign;\n\t\t\t}\n\t\t}\n\t}\n\twhile (true) {\n\t\tk = Math.floor(x2 / x1);\n\t\tx2 = x2 - k * x1;\n\t\ty2 = y2 - k * y1;\n\t\tif (y2 < 0.0) {\n\t\t\treturn -sign;\n\t\t}\n\t\tif (y2 > y1) {\n\t\t\treturn sign;\n\t\t}\n\t\tif (x1 > x2 + x2) {\n\t\t\tif (y1 < y2 + y2) {\n\t\t\t\treturn sign;\n\t\t\t}\n\t\t} else {\n\t\t\tif (y1 > y2 + y2) {\n\t\t\t\treturn -sign;\n\t\t\t} else {\n\t\t\t\tx2 = x1 - x2;\n\t\t\t\ty2 = y1 - y2;\n\t\t\t\tsign = -sign;\n\t\t\t}\n\t\t}\n\t\tif (y2 === 0.0) {\n\t\t\tif (x2 === 0.0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn -sign;\n\t\t\t}\n\t\t}\n\t\tif (x2 === 0.0) {\n\t\t\treturn sign;\n\t\t}\n\t\tk = Math.floor(x1 / x2);\n\t\tx1 = x1 - k * x2;\n\t\ty1 = y1 - k * y2;\n\t\tif (y1 < 0.0) {\n\t\t\treturn sign;\n\t\t}\n\t\tif (y1 > y2) {\n\t\t\treturn -sign;\n\t\t}\n\t\tif (x2 > x1 + x1) {\n\t\t\tif (y2 < y1 + y1) {\n\t\t\t\treturn -sign;\n\t\t\t}\n\t\t} else {\n\t\t\tif (y2 > y1 + y1) {\n\t\t\t\treturn sign;\n\t\t\t} else {\n\t\t\t\tx1 = x2 - x1;\n\t\t\t\ty1 = y2 - y1;\n\t\t\t\tsign = -sign;\n\t\t\t}\n\t\t}\n\t\tif (y1 === 0.0) {\n\t\t\tif (x1 === 0.0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn sign;\n\t\t\t}\n\t\t}\n\t\tif (x1 === 0.0) {\n\t\t\treturn -sign;\n\t\t}\n\t}\n};\n\nfunction RayCrossingCounter() {\n\tthis._p = null;\n\tthis._crossingCount = 0;\n\tthis._isPointOnSegment = false;\n\tvar p = arguments[0];\n\tthis._p = p;\n}\nextend(RayCrossingCounter.prototype, {\n\tcountSegment: function countSegment(p1, p2) {\n\t\tif (p1.x < this._p.x && p2.x < this._p.x) return null;\n\t\tif (this._p.x === p2.x && this._p.y === p2.y) {\n\t\t\tthis._isPointOnSegment = true;\n\t\t\treturn null;\n\t\t}\n\t\tif (p1.y === this._p.y && p2.y === this._p.y) {\n\t\t\tvar minx = p1.x;\n\t\t\tvar maxx = p2.x;\n\t\t\tif (minx > maxx) {\n\t\t\t\tminx = p2.x;\n\t\t\t\tmaxx = p1.x;\n\t\t\t}\n\t\t\tif (this._p.x >= minx && this._p.x <= maxx) {\n\t\t\t\tthis._isPointOnSegment = true;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tif (p1.y > this._p.y && p2.y <= this._p.y || p2.y > this._p.y && p1.y <= this._p.y) {\n\t\t\tvar x1 = p1.x - this._p.x;\n\t\t\tvar y1 = p1.y - this._p.y;\n\t\t\tvar x2 = p2.x - this._p.x;\n\t\t\tvar y2 = p2.y - this._p.y;\n\t\t\tvar xIntSign = RobustDeterminant.signOfDet2x2(x1, y1, x2, y2);\n\t\t\tif (xIntSign === 0.0) {\n\t\t\t\tthis._isPointOnSegment = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (y2 < y1) xIntSign = -xIntSign;\n\t\t\tif (xIntSign > 0.0) {\n\t\t\t\tthis._crossingCount++;\n\t\t\t}\n\t\t}\n\t},\n\tisPointInPolygon: function isPointInPolygon() {\n\t\treturn this.getLocation() !== Location.EXTERIOR;\n\t},\n\tgetLocation: function getLocation() {\n\t\tif (this._isPointOnSegment) return Location.BOUNDARY;\n\t\tif (this._crossingCount % 2 === 1) {\n\t\t\treturn Location.INTERIOR;\n\t\t}\n\t\treturn Location.EXTERIOR;\n\t},\n\tisOnSegment: function isOnSegment() {\n\t\treturn this._isPointOnSegment;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn RayCrossingCounter;\n\t}\n});\nRayCrossingCounter.locatePointInRing = function () {\n\tif (arguments[0] instanceof Coordinate && hasInterface(arguments[1], CoordinateSequence)) {\n\t\tvar p = arguments[0],\n\t\t    ring = arguments[1];\n\t\tvar counter = new RayCrossingCounter(p);\n\t\tvar p1 = new Coordinate();\n\t\tvar p2 = new Coordinate();\n\t\tfor (var i = 1; i < ring.size(); i++) {\n\t\t\tring.getCoordinate(i, p1);\n\t\t\tring.getCoordinate(i - 1, p2);\n\t\t\tcounter.countSegment(p1, p2);\n\t\t\tif (counter.isOnSegment()) return counter.getLocation();\n\t\t}\n\t\treturn counter.getLocation();\n\t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Array) {\n\t\tvar p = arguments[0],\n\t\t    ring = arguments[1];\n\t\tvar counter = new RayCrossingCounter(p);\n\t\tfor (var i = 1; i < ring.length; i++) {\n\t\t\tvar p1 = ring[i];\n\t\t\tvar p2 = ring[i - 1];\n\t\t\tcounter.countSegment(p1, p2);\n\t\t\tif (counter.isOnSegment()) return counter.getLocation();\n\t\t}\n\t\treturn counter.getLocation();\n\t}\n};\n\nfunction CGAlgorithms() {}\nextend(CGAlgorithms.prototype, {\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn CGAlgorithms;\n\t}\n});\nCGAlgorithms.orientationIndex = function (p1, p2, q) {\n\treturn CGAlgorithmsDD.orientationIndex(p1, p2, q);\n};\nCGAlgorithms.signedArea = function () {\n\tif (arguments[0] instanceof Array) {\n\t\tvar ring = arguments[0];\n\t\tif (ring.length < 3) return 0.0;\n\t\tvar sum = 0.0;\n\t\tvar x0 = ring[0].x;\n\t\tfor (var i = 1; i < ring.length - 1; i++) {\n\t\t\tvar x = ring[i].x - x0;\n\t\t\tvar y1 = ring[i + 1].y;\n\t\t\tvar y2 = ring[i - 1].y;\n\t\t\tsum += x * (y2 - y1);\n\t\t}\n\t\treturn sum / 2.0;\n\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\tvar ring = arguments[0];\n\t\tvar n = ring.size();\n\t\tif (n < 3) return 0.0;\n\t\tvar p0 = new Coordinate();\n\t\tvar p1 = new Coordinate();\n\t\tvar p2 = new Coordinate();\n\t\tring.getCoordinate(0, p1);\n\t\tring.getCoordinate(1, p2);\n\t\tvar x0 = p1.x;\n\t\tp2.x -= x0;\n\t\tvar sum = 0.0;\n\t\tfor (var i = 1; i < n - 1; i++) {\n\t\t\tp0.y = p1.y;\n\t\t\tp1.x = p2.x;\n\t\t\tp1.y = p2.y;\n\t\t\tring.getCoordinate(i + 1, p2);\n\t\t\tp2.x -= x0;\n\t\t\tsum += p1.x * (p0.y - p2.y);\n\t\t}\n\t\treturn sum / 2.0;\n\t}\n};\nCGAlgorithms.distanceLineLine = function (A, B, C, D) {\n\tif (A.equals(B)) return CGAlgorithms.distancePointLine(A, C, D);\n\tif (C.equals(D)) return CGAlgorithms.distancePointLine(D, A, B);\n\tvar noIntersection = false;\n\tif (!Envelope.intersects(A, B, C, D)) {\n\t\tnoIntersection = true;\n\t} else {\n\t\tvar denom = (B.x - A.x) * (D.y - C.y) - (B.y - A.y) * (D.x - C.x);\n\t\tif (denom === 0) {\n\t\t\tnoIntersection = true;\n\t\t} else {\n\t\t\tvar r_num = (A.y - C.y) * (D.x - C.x) - (A.x - C.x) * (D.y - C.y);\n\t\t\tvar s_num = (A.y - C.y) * (B.x - A.x) - (A.x - C.x) * (B.y - A.y);\n\t\t\tvar s = s_num / denom;\n\t\t\tvar r = r_num / denom;\n\t\t\tif (r < 0 || r > 1 || s < 0 || s > 1) {\n\t\t\t\tnoIntersection = true;\n\t\t\t}\n\t\t}\n\t}\n\tif (noIntersection) {\n\t\treturn MathUtil.min(CGAlgorithms.distancePointLine(A, C, D), CGAlgorithms.distancePointLine(B, C, D), CGAlgorithms.distancePointLine(C, A, B), CGAlgorithms.distancePointLine(D, A, B));\n\t}\n\treturn 0.0;\n};\nCGAlgorithms.isPointInRing = function (p, ring) {\n\treturn CGAlgorithms.locatePointInRing(p, ring) !== Location.EXTERIOR;\n};\nCGAlgorithms.computeLength = function (pts) {\n\tvar n = pts.size();\n\tif (n <= 1) return 0.0;\n\tvar len = 0.0;\n\tvar p = new Coordinate();\n\tpts.getCoordinate(0, p);\n\tvar x0 = p.x;\n\tvar y0 = p.y;\n\tfor (var i = 1; i < n; i++) {\n\t\tpts.getCoordinate(i, p);\n\t\tvar x1 = p.x;\n\t\tvar y1 = p.y;\n\t\tvar dx = x1 - x0;\n\t\tvar dy = y1 - y0;\n\t\tlen += Math.sqrt(dx * dx + dy * dy);\n\t\tx0 = x1;\n\t\ty0 = y1;\n\t}\n\treturn len;\n};\nCGAlgorithms.isCCW = function (ring) {\n\tvar nPts = ring.length - 1;\n\tif (nPts < 3) throw new IllegalArgumentException(\"Ring has fewer than 4 points, so orientation cannot be determined\");\n\tvar hiPt = ring[0];\n\tvar hiIndex = 0;\n\tfor (var i = 1; i <= nPts; i++) {\n\t\tvar p = ring[i];\n\t\tif (p.y > hiPt.y) {\n\t\t\thiPt = p;\n\t\t\thiIndex = i;\n\t\t}\n\t}\n\tvar iPrev = hiIndex;\n\tdo {\n\t\tiPrev = iPrev - 1;\n\t\tif (iPrev < 0) iPrev = nPts;\n\t} while (ring[iPrev].equals2D(hiPt) && iPrev !== hiIndex);\n\tvar iNext = hiIndex;\n\tdo {\n\t\tiNext = (iNext + 1) % nPts;\n\t} while (ring[iNext].equals2D(hiPt) && iNext !== hiIndex);\n\tvar prev = ring[iPrev];\n\tvar next = ring[iNext];\n\tif (prev.equals2D(hiPt) || next.equals2D(hiPt) || prev.equals2D(next)) return false;\n\tvar disc = CGAlgorithms.computeOrientation(prev, hiPt, next);\n\tvar isCCW = false;\n\tif (disc === 0) {\n\t\tisCCW = prev.x > next.x;\n\t} else {\n\t\tisCCW = disc > 0;\n\t}\n\treturn isCCW;\n};\nCGAlgorithms.locatePointInRing = function (p, ring) {\n\treturn RayCrossingCounter.locatePointInRing(p, ring);\n};\nCGAlgorithms.distancePointLinePerpendicular = function (p, A, B) {\n\tvar len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);\n\tvar s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;\n\treturn Math.abs(s) * Math.sqrt(len2);\n};\nCGAlgorithms.computeOrientation = function (p1, p2, q) {\n\treturn CGAlgorithms.orientationIndex(p1, p2, q);\n};\nCGAlgorithms.distancePointLine = function () {\n\tif (arguments.length === 2) {\n\t\tvar p = arguments[0],\n\t\t    line = arguments[1];\n\t\tif (line.length === 0) throw new IllegalArgumentException(\"Line array must contain at least one vertex\");\n\t\tvar minDistance = p.distance(line[0]);\n\t\tfor (var i = 0; i < line.length - 1; i++) {\n\t\t\tvar dist = CGAlgorithms.distancePointLine(p, line[i], line[i + 1]);\n\t\t\tif (dist < minDistance) {\n\t\t\t\tminDistance = dist;\n\t\t\t}\n\t\t}\n\t\treturn minDistance;\n\t} else if (arguments.length === 3) {\n\t\tvar p = arguments[0],\n\t\t    A = arguments[1],\n\t\t    B = arguments[2];\n\t\tif (A.x === B.x && A.y === B.y) return p.distance(A);\n\t\tvar len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);\n\t\tvar r = ((p.x - A.x) * (B.x - A.x) + (p.y - A.y) * (B.y - A.y)) / len2;\n\t\tif (r <= 0.0) return p.distance(A);\n\t\tif (r >= 1.0) return p.distance(B);\n\t\tvar s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;\n\t\treturn Math.abs(s) * Math.sqrt(len2);\n\t}\n};\nCGAlgorithms.isOnLine = function (p, pt) {\n\tvar lineIntersector = new RobustLineIntersector();\n\tfor (var i = 1; i < pt.length; i++) {\n\t\tvar p0 = pt[i - 1];\n\t\tvar p1 = pt[i];\n\t\tlineIntersector.computeIntersection(p, p0, p1);\n\t\tif (lineIntersector.hasIntersection()) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n};\nCGAlgorithms.CLOCKWISE = -1;\nCGAlgorithms.RIGHT = CGAlgorithms.CLOCKWISE;\nCGAlgorithms.COUNTERCLOCKWISE = 1;\nCGAlgorithms.LEFT = CGAlgorithms.COUNTERCLOCKWISE;\nCGAlgorithms.COLLINEAR = 0;\nCGAlgorithms.STRAIGHT = CGAlgorithms.COLLINEAR;\n\nfunction LineSegment() {\n\tthis.p0 = null;\n\tthis.p1 = null;\n\tif (arguments.length === 0) {\n\t\tLineSegment.call(this, new Coordinate(), new Coordinate());\n\t} else if (arguments.length === 1) {\n\t\tvar ls = arguments[0];\n\t\tLineSegment.call(this, ls.p0, ls.p1);\n\t} else if (arguments.length === 2) {\n\t\tvar p0 = arguments[0],\n\t\t    p1 = arguments[1];\n\t\tthis.p0 = p0;\n\t\tthis.p1 = p1;\n\t} else if (arguments.length === 4) {\n\t\tvar x0 = arguments[0],\n\t\t    y0 = arguments[1],\n\t\t    x1 = arguments[2],\n\t\t    y1 = arguments[3];\n\t\tLineSegment.call(this, new Coordinate(x0, y0), new Coordinate(x1, y1));\n\t}\n}\nextend(LineSegment.prototype, {\n\tminX: function minX() {\n\t\treturn Math.min(this.p0.x, this.p1.x);\n\t},\n\torientationIndex: function orientationIndex() {\n\t\tif (arguments[0] instanceof LineSegment) {\n\t\t\tvar seg = arguments[0];\n\t\t\tvar orient0 = CGAlgorithms.orientationIndex(this.p0, this.p1, seg.p0);\n\t\t\tvar orient1 = CGAlgorithms.orientationIndex(this.p0, this.p1, seg.p1);\n\t\t\tif (orient0 >= 0 && orient1 >= 0) return Math.max(orient0, orient1);\n\t\t\tif (orient0 <= 0 && orient1 <= 0) return Math.max(orient0, orient1);\n\t\t\treturn 0;\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tvar p = arguments[0];\n\t\t\treturn CGAlgorithms.orientationIndex(this.p0, this.p1, p);\n\t\t}\n\t},\n\ttoGeometry: function toGeometry(geomFactory) {\n\t\treturn geomFactory.createLineString([this.p0, this.p1]);\n\t},\n\tisVertical: function isVertical() {\n\t\treturn this.p0.x === this.p1.x;\n\t},\n\tequals: function equals(o) {\n\t\tif (!(o instanceof LineSegment)) {\n\t\t\treturn false;\n\t\t}\n\t\tvar other = o;\n\t\treturn this.p0.equals(other.p0) && this.p1.equals(other.p1);\n\t},\n\tintersection: function intersection(line) {\n\t\tvar li = new RobustLineIntersector();\n\t\tli.computeIntersection(this.p0, this.p1, line.p0, line.p1);\n\t\tif (li.hasIntersection()) return li.getIntersection(0);\n\t\treturn null;\n\t},\n\tproject: function project() {\n\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\tvar p = arguments[0];\n\t\t\tif (p.equals(this.p0) || p.equals(this.p1)) return new Coordinate(p);\n\t\t\tvar r = this.projectionFactor(p);\n\t\t\tvar coord = new Coordinate();\n\t\t\tcoord.x = this.p0.x + r * (this.p1.x - this.p0.x);\n\t\t\tcoord.y = this.p0.y + r * (this.p1.y - this.p0.y);\n\t\t\treturn coord;\n\t\t} else if (arguments[0] instanceof LineSegment) {\n\t\t\tvar seg = arguments[0];\n\t\t\tvar pf0 = this.projectionFactor(seg.p0);\n\t\t\tvar pf1 = this.projectionFactor(seg.p1);\n\t\t\tif (pf0 >= 1.0 && pf1 >= 1.0) return null;\n\t\t\tif (pf0 <= 0.0 && pf1 <= 0.0) return null;\n\t\t\tvar newp0 = this.project(seg.p0);\n\t\t\tif (pf0 < 0.0) newp0 = this.p0;\n\t\t\tif (pf0 > 1.0) newp0 = this.p1;\n\t\t\tvar newp1 = this.project(seg.p1);\n\t\t\tif (pf1 < 0.0) newp1 = this.p0;\n\t\t\tif (pf1 > 1.0) newp1 = this.p1;\n\t\t\treturn new LineSegment(newp0, newp1);\n\t\t}\n\t},\n\tnormalize: function normalize() {\n\t\tif (this.p1.compareTo(this.p0) < 0) this.reverse();\n\t},\n\tangle: function angle() {\n\t\treturn Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);\n\t},\n\tgetCoordinate: function getCoordinate(i) {\n\t\tif (i === 0) return this.p0;\n\t\treturn this.p1;\n\t},\n\tdistancePerpendicular: function distancePerpendicular(p) {\n\t\treturn CGAlgorithms.distancePointLinePerpendicular(p, this.p0, this.p1);\n\t},\n\tminY: function minY() {\n\t\treturn Math.min(this.p0.y, this.p1.y);\n\t},\n\tmidPoint: function midPoint() {\n\t\treturn LineSegment.midPoint(this.p0, this.p1);\n\t},\n\tprojectionFactor: function projectionFactor(p) {\n\t\tif (p.equals(this.p0)) return 0.0;\n\t\tif (p.equals(this.p1)) return 1.0;\n\t\tvar dx = this.p1.x - this.p0.x;\n\t\tvar dy = this.p1.y - this.p0.y;\n\t\tvar len = dx * dx + dy * dy;\n\t\tif (len <= 0.0) return Double.NaN;\n\t\tvar r = ((p.x - this.p0.x) * dx + (p.y - this.p0.y) * dy) / len;\n\t\treturn r;\n\t},\n\tclosestPoints: function closestPoints(line) {\n\t\tvar intPt = this.intersection(line);\n\t\tif (intPt !== null) {\n\t\t\treturn [intPt, intPt];\n\t\t}\n\t\tvar closestPt = new Array(2).fill(null);\n\t\tvar minDistance = Double.MAX_VALUE;\n\t\tvar dist = null;\n\t\tvar close00 = this.closestPoint(line.p0);\n\t\tminDistance = close00.distance(line.p0);\n\t\tclosestPt[0] = close00;\n\t\tclosestPt[1] = line.p0;\n\t\tvar close01 = this.closestPoint(line.p1);\n\t\tdist = close01.distance(line.p1);\n\t\tif (dist < minDistance) {\n\t\t\tminDistance = dist;\n\t\t\tclosestPt[0] = close01;\n\t\t\tclosestPt[1] = line.p1;\n\t\t}\n\t\tvar close10 = line.closestPoint(this.p0);\n\t\tdist = close10.distance(this.p0);\n\t\tif (dist < minDistance) {\n\t\t\tminDistance = dist;\n\t\t\tclosestPt[0] = this.p0;\n\t\t\tclosestPt[1] = close10;\n\t\t}\n\t\tvar close11 = line.closestPoint(this.p1);\n\t\tdist = close11.distance(this.p1);\n\t\tif (dist < minDistance) {\n\t\t\tminDistance = dist;\n\t\t\tclosestPt[0] = this.p1;\n\t\t\tclosestPt[1] = close11;\n\t\t}\n\t\treturn closestPt;\n\t},\n\tclosestPoint: function closestPoint(p) {\n\t\tvar factor = this.projectionFactor(p);\n\t\tif (factor > 0 && factor < 1) {\n\t\t\treturn this.project(p);\n\t\t}\n\t\tvar dist0 = this.p0.distance(p);\n\t\tvar dist1 = this.p1.distance(p);\n\t\tif (dist0 < dist1) return this.p0;\n\t\treturn this.p1;\n\t},\n\tmaxX: function maxX() {\n\t\treturn Math.max(this.p0.x, this.p1.x);\n\t},\n\tgetLength: function getLength() {\n\t\treturn this.p0.distance(this.p1);\n\t},\n\tcompareTo: function compareTo(o) {\n\t\tvar other = o;\n\t\tvar comp0 = this.p0.compareTo(other.p0);\n\t\tif (comp0 !== 0) return comp0;\n\t\treturn this.p1.compareTo(other.p1);\n\t},\n\treverse: function reverse() {\n\t\tvar temp = this.p0;\n\t\tthis.p0 = this.p1;\n\t\tthis.p1 = temp;\n\t},\n\tequalsTopo: function equalsTopo(other) {\n\t\treturn this.p0.equals(other.p0) && this.p1.equals(other.p1) || this.p0.equals(other.p1) && this.p1.equals(other.p0);\n\t},\n\tlineIntersection: function lineIntersection(line) {\n\t\ttry {\n\t\t\tvar intPt = HCoordinate.intersection(this.p0, this.p1, line.p0, line.p1);\n\t\t\treturn intPt;\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof NotRepresentableException) {} else throw ex;\n\t\t} finally {}\n\t\treturn null;\n\t},\n\tmaxY: function maxY() {\n\t\treturn Math.max(this.p0.y, this.p1.y);\n\t},\n\tpointAlongOffset: function pointAlongOffset(segmentLengthFraction, offsetDistance) {\n\t\tvar segx = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);\n\t\tvar segy = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);\n\t\tvar dx = this.p1.x - this.p0.x;\n\t\tvar dy = this.p1.y - this.p0.y;\n\t\tvar len = Math.sqrt(dx * dx + dy * dy);\n\t\tvar ux = 0.0;\n\t\tvar uy = 0.0;\n\t\tif (offsetDistance !== 0.0) {\n\t\t\tif (len <= 0.0) throw new IllegalStateException(\"Cannot compute offset from zero-length line segment\");\n\t\t\tux = offsetDistance * dx / len;\n\t\t\tuy = offsetDistance * dy / len;\n\t\t}\n\t\tvar offsetx = segx - uy;\n\t\tvar offsety = segy + ux;\n\t\tvar coord = new Coordinate(offsetx, offsety);\n\t\treturn coord;\n\t},\n\tsetCoordinates: function setCoordinates() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar ls = arguments[0];\n\t\t\tthis.setCoordinates(ls.p0, ls.p1);\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar p0 = arguments[0],\n\t\t\t    p1 = arguments[1];\n\t\t\tthis.p0.x = p0.x;\n\t\t\tthis.p0.y = p0.y;\n\t\t\tthis.p1.x = p1.x;\n\t\t\tthis.p1.y = p1.y;\n\t\t}\n\t},\n\tsegmentFraction: function segmentFraction(inputPt) {\n\t\tvar segFrac = this.projectionFactor(inputPt);\n\t\tif (segFrac < 0.0) segFrac = 0.0;else if (segFrac > 1.0 || Double.isNaN(segFrac)) segFrac = 1.0;\n\t\treturn segFrac;\n\t},\n\ttoString: function toString() {\n\t\treturn \"LINESTRING( \" + this.p0.x + \" \" + this.p0.y + \", \" + this.p1.x + \" \" + this.p1.y + \")\";\n\t},\n\tisHorizontal: function isHorizontal() {\n\t\treturn this.p0.y === this.p1.y;\n\t},\n\tdistance: function distance() {\n\t\tif (arguments[0] instanceof LineSegment) {\n\t\t\tvar ls = arguments[0];\n\t\t\treturn CGAlgorithms.distanceLineLine(this.p0, this.p1, ls.p0, ls.p1);\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tvar p = arguments[0];\n\t\t\treturn CGAlgorithms.distancePointLine(p, this.p0, this.p1);\n\t\t}\n\t},\n\tpointAlong: function pointAlong(segmentLengthFraction) {\n\t\tvar coord = new Coordinate();\n\t\tcoord.x = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);\n\t\tcoord.y = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);\n\t\treturn coord;\n\t},\n\thashCode: function hashCode() {\n\t\tvar bits0 = java.lang.Double.doubleToLongBits(this.p0.x);\n\t\tbits0 ^= java.lang.Double.doubleToLongBits(this.p0.y) * 31;\n\t\tvar hash0 = Math.trunc(bits0) ^ Math.trunc(bits0 >> 32);\n\t\tvar bits1 = java.lang.Double.doubleToLongBits(this.p1.x);\n\t\tbits1 ^= java.lang.Double.doubleToLongBits(this.p1.y) * 31;\n\t\tvar hash1 = Math.trunc(bits1) ^ Math.trunc(bits1 >> 32);\n\t\treturn hash0 ^ hash1;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Comparable, Serializable];\n\t},\n\tgetClass: function getClass() {\n\t\treturn LineSegment;\n\t}\n});\nLineSegment.midPoint = function (p0, p1) {\n\treturn new Coordinate((p0.x + p1.x) / 2, (p0.y + p1.y) / 2);\n};\nLineSegment.serialVersionUID = 3252005833466256227;\n\nfunction IntersectionMatrix() {\n\tthis._matrix = null;\n\tif (arguments.length === 0) {\n\t\tthis._matrix = Array(3).fill().map(function () {\n\t\t\treturn Array(3);\n\t\t});\n\t\tthis.setAll(Dimension.FALSE);\n\t} else if (arguments.length === 1) {\n\t\tif (typeof arguments[0] === \"string\") {\n\t\t\tvar elements = arguments[0];\n\t\t\tIntersectionMatrix.call(this);\n\t\t\tthis.set(elements);\n\t\t} else if (arguments[0] instanceof IntersectionMatrix) {\n\t\t\tvar other = arguments[0];\n\t\t\tIntersectionMatrix.call(this);\n\t\t\tthis._matrix[Location.INTERIOR][Location.INTERIOR] = other._matrix[Location.INTERIOR][Location.INTERIOR];\n\t\t\tthis._matrix[Location.INTERIOR][Location.BOUNDARY] = other._matrix[Location.INTERIOR][Location.BOUNDARY];\n\t\t\tthis._matrix[Location.INTERIOR][Location.EXTERIOR] = other._matrix[Location.INTERIOR][Location.EXTERIOR];\n\t\t\tthis._matrix[Location.BOUNDARY][Location.INTERIOR] = other._matrix[Location.BOUNDARY][Location.INTERIOR];\n\t\t\tthis._matrix[Location.BOUNDARY][Location.BOUNDARY] = other._matrix[Location.BOUNDARY][Location.BOUNDARY];\n\t\t\tthis._matrix[Location.BOUNDARY][Location.EXTERIOR] = other._matrix[Location.BOUNDARY][Location.EXTERIOR];\n\t\t\tthis._matrix[Location.EXTERIOR][Location.INTERIOR] = other._matrix[Location.EXTERIOR][Location.INTERIOR];\n\t\t\tthis._matrix[Location.EXTERIOR][Location.BOUNDARY] = other._matrix[Location.EXTERIOR][Location.BOUNDARY];\n\t\t\tthis._matrix[Location.EXTERIOR][Location.EXTERIOR] = other._matrix[Location.EXTERIOR][Location.EXTERIOR];\n\t\t}\n\t}\n}\nextend(IntersectionMatrix.prototype, {\n\tisIntersects: function isIntersects() {\n\t\treturn !this.isDisjoint();\n\t},\n\tisCovers: function isCovers() {\n\t\tvar hasPointInCommon = IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY]);\n\t\treturn hasPointInCommon && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE;\n\t},\n\tisCoveredBy: function isCoveredBy() {\n\t\tvar hasPointInCommon = IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY]);\n\t\treturn hasPointInCommon && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE;\n\t},\n\tset: function set() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar dimensionSymbols = arguments[0];\n\t\t\tfor (var i = 0; i < dimensionSymbols.length; i++) {\n\t\t\t\tvar row = Math.trunc(i / 3);\n\t\t\t\tvar col = i % 3;\n\t\t\t\tthis._matrix[row][col] = Dimension.toDimensionValue(dimensionSymbols.charAt(i));\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tvar row = arguments[0],\n\t\t\t    column = arguments[1],\n\t\t\t    dimensionValue = arguments[2];\n\t\t\tthis._matrix[row][column] = dimensionValue;\n\t\t}\n\t},\n\tisContains: function isContains() {\n\t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE;\n\t},\n\tsetAtLeast: function setAtLeast() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar minimumDimensionSymbols = arguments[0];\n\t\t\tfor (var i = 0; i < minimumDimensionSymbols.length; i++) {\n\t\t\t\tvar row = Math.trunc(i / 3);\n\t\t\t\tvar col = i % 3;\n\t\t\t\tthis.setAtLeast(row, col, Dimension.toDimensionValue(minimumDimensionSymbols.charAt(i)));\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tvar row = arguments[0],\n\t\t\t    column = arguments[1],\n\t\t\t    minimumDimensionValue = arguments[2];\n\t\t\tif (this._matrix[row][column] < minimumDimensionValue) {\n\t\t\t\tthis._matrix[row][column] = minimumDimensionValue;\n\t\t\t}\n\t\t}\n\t},\n\tsetAtLeastIfValid: function setAtLeastIfValid(row, column, minimumDimensionValue) {\n\t\tif (row >= 0 && column >= 0) {\n\t\t\tthis.setAtLeast(row, column, minimumDimensionValue);\n\t\t}\n\t},\n\tisWithin: function isWithin() {\n\t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE;\n\t},\n\tisTouches: function isTouches(dimensionOfGeometryA, dimensionOfGeometryB) {\n\t\tif (dimensionOfGeometryA > dimensionOfGeometryB) {\n\t\t\treturn this.isTouches(dimensionOfGeometryB, dimensionOfGeometryA);\n\t\t}\n\t\tif (dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.L) {\n\t\t\treturn this._matrix[Location.INTERIOR][Location.INTERIOR] === Dimension.FALSE && (IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY]));\n\t\t}\n\t\treturn false;\n\t},\n\tisOverlaps: function isOverlaps(dimensionOfGeometryA, dimensionOfGeometryB) {\n\t\tif (dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.A) {\n\t\t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR]);\n\t\t}\n\t\tif (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L) {\n\t\t\treturn this._matrix[Location.INTERIOR][Location.INTERIOR] === 1 && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR]);\n\t\t}\n\t\treturn false;\n\t},\n\tisEquals: function isEquals(dimensionOfGeometryA, dimensionOfGeometryB) {\n\t\tif (dimensionOfGeometryA !== dimensionOfGeometryB) {\n\t\t\treturn false;\n\t\t}\n\t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE;\n\t},\n\ttoString: function toString() {\n\t\tvar buf = new StringBuffer(\"123456789\");\n\t\tfor (var ai = 0; ai < 3; ai++) {\n\t\t\tfor (var bi = 0; bi < 3; bi++) {\n\t\t\t\tbuf.setCharAt(3 * ai + bi, Dimension.toDimensionSymbol(this._matrix[ai][bi]));\n\t\t\t}\n\t\t}\n\t\treturn buf.toString();\n\t},\n\tsetAll: function setAll(dimensionValue) {\n\t\tfor (var ai = 0; ai < 3; ai++) {\n\t\t\tfor (var bi = 0; bi < 3; bi++) {\n\t\t\t\tthis._matrix[ai][bi] = dimensionValue;\n\t\t\t}\n\t\t}\n\t},\n\tget: function get(row, column) {\n\t\treturn this._matrix[row][column];\n\t},\n\ttranspose: function transpose() {\n\t\tvar temp = this._matrix[1][0];\n\t\tthis._matrix[1][0] = this._matrix[0][1];\n\t\tthis._matrix[0][1] = temp;\n\t\ttemp = this._matrix[2][0];\n\t\tthis._matrix[2][0] = this._matrix[0][2];\n\t\tthis._matrix[0][2] = temp;\n\t\ttemp = this._matrix[2][1];\n\t\tthis._matrix[2][1] = this._matrix[1][2];\n\t\tthis._matrix[1][2] = temp;\n\t\treturn this;\n\t},\n\tmatches: function matches(requiredDimensionSymbols) {\n\t\tif (requiredDimensionSymbols.length !== 9) {\n\t\t\tthrow new IllegalArgumentException(\"Should be length 9: \" + requiredDimensionSymbols);\n\t\t}\n\t\tfor (var ai = 0; ai < 3; ai++) {\n\t\t\tfor (var bi = 0; bi < 3; bi++) {\n\t\t\t\tif (!IntersectionMatrix.matches(this._matrix[ai][bi], requiredDimensionSymbols.charAt(3 * ai + bi))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t},\n\tadd: function add(im) {\n\t\tfor (var i = 0; i < 3; i++) {\n\t\t\tfor (var j = 0; j < 3; j++) {\n\t\t\t\tthis.setAtLeast(i, j, im.get(i, j));\n\t\t\t}\n\t\t}\n\t},\n\tisDisjoint: function isDisjoint() {\n\t\treturn this._matrix[Location.INTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.INTERIOR][Location.BOUNDARY] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.BOUNDARY] === Dimension.FALSE;\n\t},\n\tisCrosses: function isCrosses(dimensionOfGeometryA, dimensionOfGeometryB) {\n\t\tif (dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.L || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.A) {\n\t\t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR]);\n\t\t}\n\t\tif (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.L) {\n\t\t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR]);\n\t\t}\n\t\tif (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L) {\n\t\t\treturn this._matrix[Location.INTERIOR][Location.INTERIOR] === 0;\n\t\t}\n\t\treturn false;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Clonable];\n\t},\n\tgetClass: function getClass() {\n\t\treturn IntersectionMatrix;\n\t}\n});\nIntersectionMatrix.matches = function () {\n\tif (Number.isInteger(arguments[0]) && typeof arguments[1] === \"string\") {\n\t\tvar actualDimensionValue = arguments[0],\n\t\t    requiredDimensionSymbol = arguments[1];\n\t\tif (requiredDimensionSymbol === Dimension.SYM_DONTCARE) {\n\t\t\treturn true;\n\t\t}\n\t\tif (requiredDimensionSymbol === Dimension.SYM_TRUE && (actualDimensionValue >= 0 || actualDimensionValue === Dimension.TRUE)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (requiredDimensionSymbol === Dimension.SYM_FALSE && actualDimensionValue === Dimension.FALSE) {\n\t\t\treturn true;\n\t\t}\n\t\tif (requiredDimensionSymbol === Dimension.SYM_P && actualDimensionValue === Dimension.P) {\n\t\t\treturn true;\n\t\t}\n\t\tif (requiredDimensionSymbol === Dimension.SYM_L && actualDimensionValue === Dimension.L) {\n\t\t\treturn true;\n\t\t}\n\t\tif (requiredDimensionSymbol === Dimension.SYM_A && actualDimensionValue === Dimension.A) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t} else if (typeof arguments[0] === \"string\" && typeof arguments[1] === \"string\") {\n\t\tvar actualDimensionSymbols = arguments[0],\n\t\t    requiredDimensionSymbols = arguments[1];\n\t\tvar m = new IntersectionMatrix(actualDimensionSymbols);\n\t\treturn m.matches(requiredDimensionSymbols);\n\t}\n};\nIntersectionMatrix.isTrue = function (actualDimensionValue) {\n\tif (actualDimensionValue >= 0 || actualDimensionValue === Dimension.TRUE) {\n\t\treturn true;\n\t}\n\treturn false;\n};\n\nfunction Centroid() {\n\tthis._areaBasePt = null;\n\tthis._triangleCent3 = new Coordinate();\n\tthis._areasum2 = 0;\n\tthis._cg3 = new Coordinate();\n\tthis._lineCentSum = new Coordinate();\n\tthis._totalLength = 0.0;\n\tthis._ptCount = 0;\n\tthis._ptCentSum = new Coordinate();\n\tvar geom = arguments[0];\n\tthis._areaBasePt = null;\n\tthis.add(geom);\n}\nextend(Centroid.prototype, {\n\taddPoint: function addPoint(pt) {\n\t\tthis._ptCount += 1;\n\t\tthis._ptCentSum.x += pt.x;\n\t\tthis._ptCentSum.y += pt.y;\n\t},\n\tsetBasePoint: function setBasePoint(basePt) {\n\t\tif (this._areaBasePt === null) this._areaBasePt = basePt;\n\t},\n\taddLineSegments: function addLineSegments(pts) {\n\t\tvar lineLen = 0.0;\n\t\tfor (var i = 0; i < pts.length - 1; i++) {\n\t\t\tvar segmentLen = pts[i].distance(pts[i + 1]);\n\t\t\tif (segmentLen === 0.0) continue;\n\t\t\tlineLen += segmentLen;\n\t\t\tvar midx = (pts[i].x + pts[i + 1].x) / 2;\n\t\t\tthis._lineCentSum.x += segmentLen * midx;\n\t\t\tvar midy = (pts[i].y + pts[i + 1].y) / 2;\n\t\t\tthis._lineCentSum.y += segmentLen * midy;\n\t\t}\n\t\tthis._totalLength += lineLen;\n\t\tif (lineLen === 0.0 && pts.length > 0) this.addPoint(pts[0]);\n\t},\n\taddHole: function addHole(pts) {\n\t\tvar isPositiveArea = CGAlgorithms.isCCW(pts);\n\t\tfor (var i = 0; i < pts.length - 1; i++) {\n\t\t\tthis.addTriangle(this._areaBasePt, pts[i], pts[i + 1], isPositiveArea);\n\t\t}\n\t\tthis.addLineSegments(pts);\n\t},\n\tgetCentroid: function getCentroid() {\n\t\tvar cent = new Coordinate();\n\t\tif (Math.abs(this._areasum2) > 0.0) {\n\t\t\tcent.x = this._cg3.x / 3 / this._areasum2;\n\t\t\tcent.y = this._cg3.y / 3 / this._areasum2;\n\t\t} else if (this._totalLength > 0.0) {\n\t\t\tcent.x = this._lineCentSum.x / this._totalLength;\n\t\t\tcent.y = this._lineCentSum.y / this._totalLength;\n\t\t} else if (this._ptCount > 0) {\n\t\t\tcent.x = this._ptCentSum.x / this._ptCount;\n\t\t\tcent.y = this._ptCentSum.y / this._ptCount;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t\treturn cent;\n\t},\n\taddShell: function addShell(pts) {\n\t\tif (pts.length > 0) this.setBasePoint(pts[0]);\n\t\tvar isPositiveArea = !CGAlgorithms.isCCW(pts);\n\t\tfor (var i = 0; i < pts.length - 1; i++) {\n\t\t\tthis.addTriangle(this._areaBasePt, pts[i], pts[i + 1], isPositiveArea);\n\t\t}\n\t\tthis.addLineSegments(pts);\n\t},\n\taddTriangle: function addTriangle(p0, p1, p2, isPositiveArea) {\n\t\tvar sign = isPositiveArea ? 1.0 : -1.0;\n\t\tCentroid.centroid3(p0, p1, p2, this._triangleCent3);\n\t\tvar area2 = Centroid.area2(p0, p1, p2);\n\t\tthis._cg3.x += sign * area2 * this._triangleCent3.x;\n\t\tthis._cg3.y += sign * area2 * this._triangleCent3.y;\n\t\tthis._areasum2 += sign * area2;\n\t},\n\tadd: function add() {\n\t\tif (arguments[0] instanceof Polygon) {\n\t\t\tvar poly = arguments[0];\n\t\t\tthis.addShell(poly.getExteriorRing().getCoordinates());\n\t\t\tfor (var i = 0; i < poly.getNumInteriorRing(); i++) {\n\t\t\t\tthis.addHole(poly.getInteriorRingN(i).getCoordinates());\n\t\t\t}\n\t\t} else if (arguments[0] instanceof Geometry) {\n\t\t\tvar geom = arguments[0];\n\t\t\tif (geom.isEmpty()) return null;\n\t\t\tif (geom instanceof Point) {\n\t\t\t\tthis.addPoint(geom.getCoordinate());\n\t\t\t} else if (geom instanceof LineString) {\n\t\t\t\tthis.addLineSegments(geom.getCoordinates());\n\t\t\t} else if (geom instanceof Polygon) {\n\t\t\t\tvar poly = geom;\n\t\t\t\tthis.add(poly);\n\t\t\t} else if (geom instanceof GeometryCollection) {\n\t\t\t\tvar gc = geom;\n\t\t\t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n\t\t\t\t\tthis.add(gc.getGeometryN(i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Centroid;\n\t}\n});\nCentroid.area2 = function (p1, p2, p3) {\n\treturn (p2.x - p1.x) * (p3.y - p1.y) - (p3.x - p1.x) * (p2.y - p1.y);\n};\nCentroid.centroid3 = function (p1, p2, p3, c) {\n\tc.x = p1.x + p2.x + p3.x;\n\tc.y = p1.y + p2.y + p3.y;\n\treturn null;\n};\nCentroid.getCentroid = function (geom) {\n\tvar cent = new Centroid(geom);\n\treturn cent.getCentroid();\n};\n\n/**\n * @param {string=} message Optional message\n * @extends {Error}\n * @constructor\n * @private\n */\nfunction EmptyStackException(message) {\n  this.message = message || '';\n}\nEmptyStackException.prototype = new Error();\n\n/**\n * @type {string}\n */\nEmptyStackException.prototype.name = 'EmptyStackException';\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Stack.html\n *\n * @extends {List}\n * @constructor\n * @private\n */\nfunction Stack$2() {\n  /**\n   * @type {Array}\n   * @private\n   */\n  this.array_ = [];\n}\nStack$2.prototype = new List();\n\n/**\n * @override\n */\nStack$2.prototype.add = function (e) {\n  this.array_.push(e);\n  return true;\n};\n\n/**\n * @override\n */\nStack$2.prototype.get = function (index) {\n  if (index < 0 || index >= this.size()) {\n    throw new IndexOutOfBoundsException();\n  }\n\n  return this.array_[index];\n};\n\n/**\n * Pushes an item onto the top of this stack.\n * @param {Object} e\n * @return {Object}\n */\nStack$2.prototype.push = function (e) {\n  this.array_.push(e);\n  return e;\n};\n\n/**\n * Pushes an item onto the top of this stack.\n * @param {Object} e\n * @return {Object}\n */\nStack$2.prototype.pop = function (e) {\n  if (this.array_.length === 0) {\n    throw new EmptyStackException();\n  }\n\n  return this.array_.pop();\n};\n\n/**\n * Looks at the object at the top of this stack without removing it from the\n * stack.\n * @return {Object}\n */\nStack$2.prototype.peek = function () {\n  if (this.array_.length === 0) {\n    throw new EmptyStackException();\n  }\n\n  return this.array_[this.array_.length - 1];\n};\n\n/**\n * Tests if this stack is empty.\n * @return {boolean} true if and only if this stack contains no items; false\n *         otherwise.\n */\nStack$2.prototype.empty = function () {\n  if (this.array_.length === 0) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\n/**\n * @return {boolean}\n */\nStack$2.prototype.isEmpty = function () {\n  return this.empty();\n};\n\n/**\n * Returns the 1-based position where an object is on this stack. If the object\n * o occurs as an item in this stack, this method returns the distance from the\n * top of the stack of the occurrence nearest the top of the stack; the topmost\n * item on the stack is considered to be at distance 1. The equals method is\n * used to compare o to the items in this stack.\n *\n * NOTE: does not currently actually use equals. (=== is used)\n *\n * @param {Object} o\n * @return {number} the 1-based position from the top of the stack where the\n *         object is located; the return value -1 indicates that the object is\n *         not on the stack.\n */\nStack$2.prototype.search = function (o) {\n  return this.array_.indexOf(o);\n};\n\n/**\n * @return {number}\n * @export\n */\nStack$2.prototype.size = function () {\n  return this.array_.length;\n};\n\n/**\n * @return {Array}\n */\nStack$2.prototype.toArray = function () {\n  var array = [];\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    array.push(this.array_[i]);\n  }\n\n  return array;\n};\n\nfunction UniqueCoordinateArrayFilter() {\n\tthis.treeSet = new TreeSet();\n\tthis.list = new ArrayList();\n}\nextend(UniqueCoordinateArrayFilter.prototype, {\n\tfilter: function filter(coord) {\n\t\tif (!this.treeSet.contains(coord)) {\n\t\t\tthis.list.add(coord);\n\t\t\tthis.treeSet.add(coord);\n\t\t}\n\t},\n\tgetCoordinates: function getCoordinates() {\n\t\tvar coordinates = new Array(this.list.size()).fill(null);\n\t\treturn this.list.toArray(coordinates);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [CoordinateFilter];\n\t},\n\tgetClass: function getClass() {\n\t\treturn UniqueCoordinateArrayFilter;\n\t}\n});\nUniqueCoordinateArrayFilter.filterCoordinates = function (coords) {\n\tvar filter = new UniqueCoordinateArrayFilter();\n\tfor (var i = 0; i < coords.length; i++) {\n\t\tfilter.filter(coords[i]);\n\t}\n\treturn filter.getCoordinates();\n};\n\nfunction ConvexHull() {\n\tthis._geomFactory = null;\n\tthis._inputPts = null;\n\tif (arguments.length === 1) {\n\t\tvar geometry = arguments[0];\n\t\tConvexHull.call(this, ConvexHull.extractCoordinates(geometry), geometry.getFactory());\n\t} else if (arguments.length === 2) {\n\t\tvar pts = arguments[0],\n\t\t    geomFactory = arguments[1];\n\t\tthis._inputPts = UniqueCoordinateArrayFilter.filterCoordinates(pts);\n\t\tthis._geomFactory = geomFactory;\n\t}\n}\nextend(ConvexHull.prototype, {\n\tpreSort: function preSort(pts) {\n\t\tvar t = null;\n\t\tfor (var i = 1; i < pts.length; i++) {\n\t\t\tif (pts[i].y < pts[0].y || pts[i].y === pts[0].y && pts[i].x < pts[0].x) {\n\t\t\t\tt = pts[0];\n\t\t\t\tpts[0] = pts[i];\n\t\t\t\tpts[i] = t;\n\t\t\t}\n\t\t}\n\t\tArrays.sort(pts, 1, pts.length, new RadialComparator(pts[0]));\n\t\treturn pts;\n\t},\n\tcomputeOctRing: function computeOctRing(inputPts) {\n\t\tvar octPts = this.computeOctPts(inputPts);\n\t\tvar coordList = new CoordinateList();\n\t\tcoordList.add(octPts, false);\n\t\tif (coordList.size() < 3) {\n\t\t\treturn null;\n\t\t}\n\t\tcoordList.closeRing();\n\t\treturn coordList.toCoordinateArray();\n\t},\n\tlineOrPolygon: function lineOrPolygon(coordinates) {\n\t\tcoordinates = this.cleanRing(coordinates);\n\t\tif (coordinates.length === 3) {\n\t\t\treturn this._geomFactory.createLineString([coordinates[0], coordinates[1]]);\n\t\t}\n\t\tvar linearRing = this._geomFactory.createLinearRing(coordinates);\n\t\treturn this._geomFactory.createPolygon(linearRing, null);\n\t},\n\tcleanRing: function cleanRing(original) {\n\t\tAssert.equals(original[0], original[original.length - 1]);\n\t\tvar cleanedRing = new ArrayList();\n\t\tvar previousDistinctCoordinate = null;\n\t\tfor (var i = 0; i <= original.length - 2; i++) {\n\t\t\tvar currentCoordinate = original[i];\n\t\t\tvar nextCoordinate = original[i + 1];\n\t\t\tif (currentCoordinate.equals(nextCoordinate)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (previousDistinctCoordinate !== null && this.isBetween(previousDistinctCoordinate, currentCoordinate, nextCoordinate)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcleanedRing.add(currentCoordinate);\n\t\t\tpreviousDistinctCoordinate = currentCoordinate;\n\t\t}\n\t\tcleanedRing.add(original[original.length - 1]);\n\t\tvar cleanedRingCoordinates = new Array(cleanedRing.size()).fill(null);\n\t\treturn cleanedRing.toArray(cleanedRingCoordinates);\n\t},\n\tisBetween: function isBetween(c1, c2, c3) {\n\t\tif (CGAlgorithms.computeOrientation(c1, c2, c3) !== 0) {\n\t\t\treturn false;\n\t\t}\n\t\tif (c1.x !== c3.x) {\n\t\t\tif (c1.x <= c2.x && c2.x <= c3.x) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (c3.x <= c2.x && c2.x <= c1.x) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tif (c1.y !== c3.y) {\n\t\t\tif (c1.y <= c2.y && c2.y <= c3.y) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (c3.y <= c2.y && c2.y <= c1.y) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\treduce: function reduce(inputPts) {\n\t\tvar polyPts = this.computeOctRing(inputPts);\n\t\tif (polyPts === null) return inputPts;\n\t\tvar reducedSet = new TreeSet();\n\t\tfor (var i = 0; i < polyPts.length; i++) {\n\t\t\treducedSet.add(polyPts[i]);\n\t\t}\n\t\tfor (var i = 0; i < inputPts.length; i++) {\n\t\t\tif (!CGAlgorithms.isPointInRing(inputPts[i], polyPts)) {\n\t\t\t\treducedSet.add(inputPts[i]);\n\t\t\t}\n\t\t}\n\t\tvar reducedPts = CoordinateArrays.toCoordinateArray(reducedSet);\n\t\tif (reducedPts.length < 3) return this.padArray3(reducedPts);\n\t\treturn reducedPts;\n\t},\n\tgetConvexHull: function getConvexHull() {\n\t\tif (this._inputPts.length === 0) {\n\t\t\treturn this._geomFactory.createGeometryCollection(null);\n\t\t}\n\t\tif (this._inputPts.length === 1) {\n\t\t\treturn this._geomFactory.createPoint(this._inputPts[0]);\n\t\t}\n\t\tif (this._inputPts.length === 2) {\n\t\t\treturn this._geomFactory.createLineString(this._inputPts);\n\t\t}\n\t\tvar reducedPts = this._inputPts;\n\t\tif (this._inputPts.length > 50) {\n\t\t\treducedPts = this.reduce(this._inputPts);\n\t\t}\n\t\tvar sortedPts = this.preSort(reducedPts);\n\t\tvar cHS = this.grahamScan(sortedPts);\n\t\tvar cH = this.toCoordinateArray(cHS);\n\t\treturn this.lineOrPolygon(cH);\n\t},\n\tpadArray3: function padArray3(pts) {\n\t\tvar pad = new Array(3).fill(null);\n\t\tfor (var i = 0; i < pad.length; i++) {\n\t\t\tif (i < pts.length) {\n\t\t\t\tpad[i] = pts[i];\n\t\t\t} else pad[i] = pts[0];\n\t\t}\n\t\treturn pad;\n\t},\n\tcomputeOctPts: function computeOctPts(inputPts) {\n\t\tvar pts = new Array(8).fill(null);\n\t\tfor (var j = 0; j < pts.length; j++) {\n\t\t\tpts[j] = inputPts[0];\n\t\t}\n\t\tfor (var i = 1; i < inputPts.length; i++) {\n\t\t\tif (inputPts[i].x < pts[0].x) {\n\t\t\t\tpts[0] = inputPts[i];\n\t\t\t}\n\t\t\tif (inputPts[i].x - inputPts[i].y < pts[1].x - pts[1].y) {\n\t\t\t\tpts[1] = inputPts[i];\n\t\t\t}\n\t\t\tif (inputPts[i].y > pts[2].y) {\n\t\t\t\tpts[2] = inputPts[i];\n\t\t\t}\n\t\t\tif (inputPts[i].x + inputPts[i].y > pts[3].x + pts[3].y) {\n\t\t\t\tpts[3] = inputPts[i];\n\t\t\t}\n\t\t\tif (inputPts[i].x > pts[4].x) {\n\t\t\t\tpts[4] = inputPts[i];\n\t\t\t}\n\t\t\tif (inputPts[i].x - inputPts[i].y > pts[5].x - pts[5].y) {\n\t\t\t\tpts[5] = inputPts[i];\n\t\t\t}\n\t\t\tif (inputPts[i].y < pts[6].y) {\n\t\t\t\tpts[6] = inputPts[i];\n\t\t\t}\n\t\t\tif (inputPts[i].x + inputPts[i].y < pts[7].x + pts[7].y) {\n\t\t\t\tpts[7] = inputPts[i];\n\t\t\t}\n\t\t}\n\t\treturn pts;\n\t},\n\ttoCoordinateArray: function toCoordinateArray(stack) {\n\t\tvar coordinates = new Array(stack.size()).fill(null);\n\t\tfor (var i = 0; i < stack.size(); i++) {\n\t\t\tvar coordinate = stack.get(i);\n\t\t\tcoordinates[i] = coordinate;\n\t\t}\n\t\treturn coordinates;\n\t},\n\tgrahamScan: function grahamScan(c) {\n\t\tvar p = null;\n\t\tvar ps = new Stack$2();\n\t\tp = ps.push(c[0]);\n\t\tp = ps.push(c[1]);\n\t\tp = ps.push(c[2]);\n\t\tfor (var i = 3; i < c.length; i++) {\n\t\t\tp = ps.pop();\n\t\t\twhile (!ps.empty() && CGAlgorithms.computeOrientation(ps.peek(), p, c[i]) > 0) {\n\t\t\t\tp = ps.pop();\n\t\t\t}\n\t\t\tp = ps.push(p);\n\t\t\tp = ps.push(c[i]);\n\t\t}\n\t\tp = ps.push(c[0]);\n\t\treturn ps;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn ConvexHull;\n\t}\n});\nConvexHull.extractCoordinates = function (geom) {\n\tvar filter = new UniqueCoordinateArrayFilter();\n\tgeom.apply(filter);\n\treturn filter.getCoordinates();\n};\nfunction RadialComparator() {\n\tthis._origin = null;\n\tvar origin = arguments[0];\n\tthis._origin = origin;\n}\nextend(RadialComparator.prototype, {\n\tcompare: function compare(o1, o2) {\n\t\tvar p1 = o1;\n\t\tvar p2 = o2;\n\t\treturn RadialComparator.polarCompare(this._origin, p1, p2);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Comparator];\n\t},\n\tgetClass: function getClass() {\n\t\treturn RadialComparator;\n\t}\n});\nRadialComparator.polarCompare = function (o, p, q) {\n\tvar dxp = p.x - o.x;\n\tvar dyp = p.y - o.y;\n\tvar dxq = q.x - o.x;\n\tvar dyq = q.y - o.y;\n\tvar orient = CGAlgorithms.computeOrientation(o, p, q);\n\tif (orient === CGAlgorithms.COUNTERCLOCKWISE) return 1;\n\tif (orient === CGAlgorithms.CLOCKWISE) return -1;\n\tvar op = dxp * dxp + dyp * dyp;\n\tvar oq = dxq * dxq + dyq * dyq;\n\tif (op < oq) {\n\t\treturn -1;\n\t}\n\tif (op > oq) {\n\t\treturn 1;\n\t}\n\treturn 0;\n};\nConvexHull.RadialComparator = RadialComparator;\n\nfunction GeometryTransformer() {\n\tthis._inputGeom = null;\n\tthis._factory = null;\n\tthis._pruneEmptyGeometry = true;\n\tthis._preserveGeometryCollectionType = true;\n\tthis._preserveCollections = false;\n\tthis._preserveType = false;\n}\nextend(GeometryTransformer.prototype, {\n\ttransformPoint: function transformPoint(geom, parent) {\n\t\treturn this._factory.createPoint(this.transformCoordinates(geom.getCoordinateSequence(), geom));\n\t},\n\ttransformPolygon: function transformPolygon(geom, parent) {\n\t\tvar isAllValidLinearRings = true;\n\t\tvar shell = this.transformLinearRing(geom.getExteriorRing(), geom);\n\t\tif (shell === null || !(shell instanceof LinearRing) || shell.isEmpty()) isAllValidLinearRings = false;\n\t\tvar holes = new ArrayList();\n\t\tfor (var i = 0; i < geom.getNumInteriorRing(); i++) {\n\t\t\tvar hole = this.transformLinearRing(geom.getInteriorRingN(i), geom);\n\t\t\tif (hole === null || hole.isEmpty()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!(hole instanceof LinearRing)) isAllValidLinearRings = false;\n\t\t\tholes.add(hole);\n\t\t}\n\t\tif (isAllValidLinearRings) return this._factory.createPolygon(shell, holes.toArray([]));else {\n\t\t\tvar components = new ArrayList();\n\t\t\tif (shell !== null) components.add(shell);\n\t\t\tcomponents.addAll(holes);\n\t\t\treturn this._factory.buildGeometry(components);\n\t\t}\n\t},\n\tcreateCoordinateSequence: function createCoordinateSequence(coords) {\n\t\treturn this._factory.getCoordinateSequenceFactory().create(coords);\n\t},\n\tgetInputGeometry: function getInputGeometry() {\n\t\treturn this._inputGeom;\n\t},\n\ttransformMultiLineString: function transformMultiLineString(geom, parent) {\n\t\tvar transGeomList = new ArrayList();\n\t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n\t\t\tvar transformGeom = this.transformLineString(geom.getGeometryN(i), geom);\n\t\t\tif (transformGeom === null) continue;\n\t\t\tif (transformGeom.isEmpty()) continue;\n\t\t\ttransGeomList.add(transformGeom);\n\t\t}\n\t\treturn this._factory.buildGeometry(transGeomList);\n\t},\n\ttransformCoordinates: function transformCoordinates(coords, parent) {\n\t\treturn this.copy(coords);\n\t},\n\ttransformLineString: function transformLineString(geom, parent) {\n\t\treturn this._factory.createLineString(this.transformCoordinates(geom.getCoordinateSequence(), geom));\n\t},\n\ttransformMultiPoint: function transformMultiPoint(geom, parent) {\n\t\tvar transGeomList = new ArrayList();\n\t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n\t\t\tvar transformGeom = this.transformPoint(geom.getGeometryN(i), geom);\n\t\t\tif (transformGeom === null) continue;\n\t\t\tif (transformGeom.isEmpty()) continue;\n\t\t\ttransGeomList.add(transformGeom);\n\t\t}\n\t\treturn this._factory.buildGeometry(transGeomList);\n\t},\n\ttransformMultiPolygon: function transformMultiPolygon(geom, parent) {\n\t\tvar transGeomList = new ArrayList();\n\t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n\t\t\tvar transformGeom = this.transformPolygon(geom.getGeometryN(i), geom);\n\t\t\tif (transformGeom === null) continue;\n\t\t\tif (transformGeom.isEmpty()) continue;\n\t\t\ttransGeomList.add(transformGeom);\n\t\t}\n\t\treturn this._factory.buildGeometry(transGeomList);\n\t},\n\tcopy: function copy(seq) {\n\t\treturn seq.copy();\n\t},\n\ttransformGeometryCollection: function transformGeometryCollection(geom, parent) {\n\t\tvar transGeomList = new ArrayList();\n\t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n\t\t\tvar transformGeom = this.transform(geom.getGeometryN(i));\n\t\t\tif (transformGeom === null) continue;\n\t\t\tif (this._pruneEmptyGeometry && transformGeom.isEmpty()) continue;\n\t\t\ttransGeomList.add(transformGeom);\n\t\t}\n\t\tif (this._preserveGeometryCollectionType) return this._factory.createGeometryCollection(GeometryFactory.toGeometryArray(transGeomList));\n\t\treturn this._factory.buildGeometry(transGeomList);\n\t},\n\ttransform: function transform(inputGeom) {\n\t\tthis._inputGeom = inputGeom;\n\t\tthis._factory = inputGeom.getFactory();\n\t\tif (inputGeom instanceof Point) return this.transformPoint(inputGeom, null);\n\t\tif (inputGeom instanceof MultiPoint) return this.transformMultiPoint(inputGeom, null);\n\t\tif (inputGeom instanceof LinearRing) return this.transformLinearRing(inputGeom, null);\n\t\tif (inputGeom instanceof LineString) return this.transformLineString(inputGeom, null);\n\t\tif (inputGeom instanceof MultiLineString) return this.transformMultiLineString(inputGeom, null);\n\t\tif (inputGeom instanceof Polygon) return this.transformPolygon(inputGeom, null);\n\t\tif (inputGeom instanceof MultiPolygon) return this.transformMultiPolygon(inputGeom, null);\n\t\tif (inputGeom instanceof GeometryCollection) return this.transformGeometryCollection(inputGeom, null);\n\t\tthrow new IllegalArgumentException(\"Unknown Geometry subtype: \" + inputGeom.getClass().getName());\n\t},\n\ttransformLinearRing: function transformLinearRing(geom, parent) {\n\t\tvar seq = this.transformCoordinates(geom.getCoordinateSequence(), geom);\n\t\tif (seq === null) return this._factory.createLinearRing(null);\n\t\tvar seqSize = seq.size();\n\t\tif (seqSize > 0 && seqSize < 4 && !this._preserveType) return this._factory.createLineString(seq);\n\t\treturn this._factory.createLinearRing(seq);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn GeometryTransformer;\n\t}\n});\n\nfunction LineStringSnapper() {\n\tthis._snapTolerance = 0.0;\n\tthis._srcPts = null;\n\tthis._seg = new LineSegment();\n\tthis._allowSnappingToSourceVertices = false;\n\tthis._isClosed = false;\n\tif (arguments[0] instanceof LineString && typeof arguments[1] === \"number\") {\n\t\tvar srcLine = arguments[0],\n\t\t    snapTolerance = arguments[1];\n\t\tLineStringSnapper.call(this, srcLine.getCoordinates(), snapTolerance);\n\t} else if (arguments[0] instanceof Array && typeof arguments[1] === \"number\") {\n\t\tvar srcPts = arguments[0],\n\t\t    snapTolerance = arguments[1];\n\t\tthis._srcPts = srcPts;\n\t\tthis._isClosed = LineStringSnapper.isClosed(srcPts);\n\t\tthis._snapTolerance = snapTolerance;\n\t}\n}\nextend(LineStringSnapper.prototype, {\n\tsnapVertices: function snapVertices(srcCoords, snapPts) {\n\t\tvar end = this._isClosed ? srcCoords.size() - 1 : srcCoords.size();\n\t\tfor (var i = 0; i < end; i++) {\n\t\t\tvar srcPt = srcCoords.get(i);\n\t\t\tvar snapVert = this.findSnapForVertex(srcPt, snapPts);\n\t\t\tif (snapVert !== null) {\n\t\t\t\tsrcCoords.set(i, new Coordinate(snapVert));\n\t\t\t\tif (i === 0 && this._isClosed) srcCoords.set(srcCoords.size() - 1, new Coordinate(snapVert));\n\t\t\t}\n\t\t}\n\t},\n\tfindSnapForVertex: function findSnapForVertex(pt, snapPts) {\n\t\tfor (var i = 0; i < snapPts.length; i++) {\n\t\t\tif (pt.equals2D(snapPts[i])) return null;\n\t\t\tif (pt.distance(snapPts[i]) < this._snapTolerance) return snapPts[i];\n\t\t}\n\t\treturn null;\n\t},\n\tsnapTo: function snapTo(snapPts) {\n\t\tvar coordList = new CoordinateList(this._srcPts);\n\t\tthis.snapVertices(coordList, snapPts);\n\t\tthis.snapSegments(coordList, snapPts);\n\t\tvar newPts = coordList.toCoordinateArray();\n\t\treturn newPts;\n\t},\n\tsnapSegments: function snapSegments(srcCoords, snapPts) {\n\t\tif (snapPts.length === 0) return null;\n\t\tvar distinctPtCount = snapPts.length;\n\t\tif (snapPts[0].equals2D(snapPts[snapPts.length - 1])) distinctPtCount = snapPts.length - 1;\n\t\tfor (var i = 0; i < distinctPtCount; i++) {\n\t\t\tvar snapPt = snapPts[i];\n\t\t\tvar index = this.findSegmentIndexToSnap(snapPt, srcCoords);\n\t\t\tif (index >= 0) {\n\t\t\t\tsrcCoords.add(index + 1, new Coordinate(snapPt), false);\n\t\t\t}\n\t\t}\n\t},\n\tfindSegmentIndexToSnap: function findSegmentIndexToSnap(snapPt, srcCoords) {\n\t\tvar minDist = Double.MAX_VALUE;\n\t\tvar snapIndex = -1;\n\t\tfor (var i = 0; i < srcCoords.size() - 1; i++) {\n\t\t\tthis._seg.p0 = srcCoords.get(i);\n\t\t\tthis._seg.p1 = srcCoords.get(i + 1);\n\t\t\tif (this._seg.p0.equals2D(snapPt) || this._seg.p1.equals2D(snapPt)) {\n\t\t\t\tif (this._allowSnappingToSourceVertices) continue;else return -1;\n\t\t\t}\n\t\t\tvar dist = this._seg.distance(snapPt);\n\t\t\tif (dist < this._snapTolerance && dist < minDist) {\n\t\t\t\tminDist = dist;\n\t\t\t\tsnapIndex = i;\n\t\t\t}\n\t\t}\n\t\treturn snapIndex;\n\t},\n\tsetAllowSnappingToSourceVertices: function setAllowSnappingToSourceVertices(allowSnappingToSourceVertices) {\n\t\tthis._allowSnappingToSourceVertices = allowSnappingToSourceVertices;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn LineStringSnapper;\n\t}\n});\nLineStringSnapper.isClosed = function (pts) {\n\tif (pts.length <= 1) return false;\n\treturn pts[0].equals2D(pts[pts.length - 1]);\n};\n\nfunction GeometrySnapper() {\n\tthis._srcGeom = null;\n\tvar srcGeom = arguments[0];\n\tthis._srcGeom = srcGeom;\n}\nextend(GeometrySnapper.prototype, {\n\tsnapTo: function snapTo(snapGeom, snapTolerance) {\n\t\tvar snapPts = this.extractTargetCoordinates(snapGeom);\n\t\tvar snapTrans = new SnapTransformer(snapTolerance, snapPts);\n\t\treturn snapTrans.transform(this._srcGeom);\n\t},\n\tsnapToSelf: function snapToSelf(snapTolerance, cleanResult) {\n\t\tvar snapPts = this.extractTargetCoordinates(this._srcGeom);\n\t\tvar snapTrans = new SnapTransformer(snapTolerance, snapPts, true);\n\t\tvar snappedGeom = snapTrans.transform(this._srcGeom);\n\t\tvar result = snappedGeom;\n\t\tif (cleanResult && hasInterface(result, Polygonal)) {\n\t\t\tresult = snappedGeom.buffer(0);\n\t\t}\n\t\treturn result;\n\t},\n\tcomputeSnapTolerance: function computeSnapTolerance(ringPts) {\n\t\tvar minSegLen = this.computeMinimumSegmentLength(ringPts);\n\t\tvar snapTol = minSegLen / 10;\n\t\treturn snapTol;\n\t},\n\textractTargetCoordinates: function extractTargetCoordinates(g) {\n\t\tvar ptSet = new TreeSet();\n\t\tvar pts = g.getCoordinates();\n\t\tfor (var i = 0; i < pts.length; i++) {\n\t\t\tptSet.add(pts[i]);\n\t\t}\n\t\treturn ptSet.toArray(new Array(0).fill(null));\n\t},\n\tcomputeMinimumSegmentLength: function computeMinimumSegmentLength(pts) {\n\t\tvar minSegLen = Double.MAX_VALUE;\n\t\tfor (var i = 0; i < pts.length - 1; i++) {\n\t\t\tvar segLen = pts[i].distance(pts[i + 1]);\n\t\t\tif (segLen < minSegLen) minSegLen = segLen;\n\t\t}\n\t\treturn minSegLen;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn GeometrySnapper;\n\t}\n});\nGeometrySnapper.snap = function (g0, g1, snapTolerance) {\n\tvar snapGeom = new Array(2).fill(null);\n\tvar snapper0 = new GeometrySnapper(g0);\n\tsnapGeom[0] = snapper0.snapTo(g1, snapTolerance);\n\tvar snapper1 = new GeometrySnapper(g1);\n\tsnapGeom[1] = snapper1.snapTo(snapGeom[0], snapTolerance);\n\treturn snapGeom;\n};\nGeometrySnapper.computeOverlaySnapTolerance = function () {\n\tif (arguments.length === 1) {\n\t\tvar g = arguments[0];\n\t\tvar snapTolerance = GeometrySnapper.computeSizeBasedSnapTolerance(g);\n\t\tvar pm = g.getPrecisionModel();\n\t\tif (pm.getType() === PrecisionModel.FIXED) {\n\t\t\tvar fixedSnapTol = 1 / pm.getScale() * 2 / 1.415;\n\t\t\tif (fixedSnapTol > snapTolerance) snapTolerance = fixedSnapTol;\n\t\t}\n\t\treturn snapTolerance;\n\t} else if (arguments.length === 2) {\n\t\tvar g0 = arguments[0],\n\t\t    g1 = arguments[1];\n\t\treturn Math.min(GeometrySnapper.computeOverlaySnapTolerance(g0), GeometrySnapper.computeOverlaySnapTolerance(g1));\n\t}\n};\nGeometrySnapper.computeSizeBasedSnapTolerance = function (g) {\n\tvar env = g.getEnvelopeInternal();\n\tvar minDimension = Math.min(env.getHeight(), env.getWidth());\n\tvar snapTol = minDimension * GeometrySnapper.SNAP_PRECISION_FACTOR;\n\treturn snapTol;\n};\nGeometrySnapper.snapToSelf = function (geom, snapTolerance, cleanResult) {\n\tvar snapper0 = new GeometrySnapper(geom);\n\treturn snapper0.snapToSelf(snapTolerance, cleanResult);\n};\nGeometrySnapper.SNAP_PRECISION_FACTOR = 1e-9;\nfunction SnapTransformer() {\n\tGeometryTransformer.apply(this);\n\tthis._snapTolerance = null;\n\tthis._snapPts = null;\n\tthis._isSelfSnap = false;\n\tif (arguments.length === 2) {\n\t\tvar snapTolerance = arguments[0],\n\t\t    snapPts = arguments[1];\n\t\tthis._snapTolerance = snapTolerance;\n\t\tthis._snapPts = snapPts;\n\t} else if (arguments.length === 3) {\n\t\tvar snapTolerance = arguments[0],\n\t\t    snapPts = arguments[1],\n\t\t    isSelfSnap = arguments[2];\n\t\tthis._snapTolerance = snapTolerance;\n\t\tthis._snapPts = snapPts;\n\t\tthis._isSelfSnap = isSelfSnap;\n\t}\n}\ninherits$1(SnapTransformer, GeometryTransformer);\nextend(SnapTransformer.prototype, {\n\tsnapLine: function snapLine(srcPts, snapPts) {\n\t\tvar snapper = new LineStringSnapper(srcPts, this._snapTolerance);\n\t\tsnapper.setAllowSnappingToSourceVertices(this._isSelfSnap);\n\t\treturn snapper.snapTo(snapPts);\n\t},\n\ttransformCoordinates: function transformCoordinates(coords, parent) {\n\t\tvar srcPts = coords.toCoordinateArray();\n\t\tvar newPts = this.snapLine(srcPts, this._snapPts);\n\t\treturn this._factory.getCoordinateSequenceFactory().create(newPts);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn SnapTransformer;\n\t}\n});\n\nfunction CommonBits() {\n\tthis._isFirst = true;\n\tthis._commonMantissaBitsCount = 53;\n\tthis._commonBits = 0;\n\tthis._commonSignExp = null;\n}\nextend(CommonBits.prototype, {\n\tgetCommon: function getCommon() {\n\t\treturn Double.longBitsToDouble(this._commonBits);\n\t},\n\tadd: function add(num) {\n\t\tvar numBits = Double.doubleToLongBits(num);\n\t\tif (this._isFirst) {\n\t\t\tthis._commonBits = numBits;\n\t\t\tthis._commonSignExp = CommonBits.signExpBits(this._commonBits);\n\t\t\tthis._isFirst = false;\n\t\t\treturn null;\n\t\t}\n\t\tvar numSignExp = CommonBits.signExpBits(numBits);\n\t\tif (numSignExp !== this._commonSignExp) {\n\t\t\tthis._commonBits = 0;\n\t\t\treturn null;\n\t\t}\n\t\tthis._commonMantissaBitsCount = CommonBits.numCommonMostSigMantissaBits(this._commonBits, numBits);\n\t\tthis._commonBits = CommonBits.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount));\n\t},\n\ttoString: function toString() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar bits = arguments[0];\n\t\t\tvar x = Double.longBitsToDouble(bits);\n\t\t\tvar numStr = Long.toBinaryString(bits);\n\t\t\tvar padStr = \"0000000000000000000000000000000000000000000000000000000000000000\" + numStr;\n\t\t\tvar bitStr = padStr.substring(padStr.length - 64);\n\t\t\tvar str = bitStr.substring(0, 1) + \"  \" + bitStr.substring(1, 12) + \"(exp) \" + bitStr.substring(12) + \" [ \" + x + \" ]\";\n\t\t\treturn str;\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn CommonBits;\n\t}\n});\nCommonBits.getBit = function (bits, i) {\n\tvar mask = 1 << i;\n\treturn (bits & mask) !== 0 ? 1 : 0;\n};\nCommonBits.signExpBits = function (num) {\n\treturn num >> 52;\n};\nCommonBits.zeroLowerBits = function (bits, nBits) {\n\tvar invMask = (1 << nBits) - 1;\n\tvar mask = ~invMask;\n\tvar zeroed = bits & mask;\n\treturn zeroed;\n};\nCommonBits.numCommonMostSigMantissaBits = function (num1, num2) {\n\tvar count = 0;\n\tfor (var i = 52; i >= 0; i--) {\n\t\tif (CommonBits.getBit(num1, i) !== CommonBits.getBit(num2, i)) return count;\n\t\tcount++;\n\t}\n\treturn 52;\n};\n\nfunction CommonBitsRemover() {\n\tthis._commonCoord = null;\n\tthis._ccFilter = new CommonCoordinateFilter();\n}\nextend(CommonBitsRemover.prototype, {\n\taddCommonBits: function addCommonBits(geom) {\n\t\tvar trans = new Translater(this._commonCoord);\n\t\tgeom.apply(trans);\n\t\tgeom.geometryChanged();\n\t},\n\tremoveCommonBits: function removeCommonBits(geom) {\n\t\tif (this._commonCoord.x === 0.0 && this._commonCoord.y === 0.0) return geom;\n\t\tvar invCoord = new Coordinate(this._commonCoord);\n\t\tinvCoord.x = -invCoord.x;\n\t\tinvCoord.y = -invCoord.y;\n\t\tvar trans = new Translater(invCoord);\n\t\tgeom.apply(trans);\n\t\tgeom.geometryChanged();\n\t\treturn geom;\n\t},\n\tgetCommonCoordinate: function getCommonCoordinate() {\n\t\treturn this._commonCoord;\n\t},\n\tadd: function add(geom) {\n\t\tgeom.apply(this._ccFilter);\n\t\tthis._commonCoord = this._ccFilter.getCommonCoordinate();\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn CommonBitsRemover;\n\t}\n});\nfunction CommonCoordinateFilter() {\n\tthis._commonBitsX = new CommonBits();\n\tthis._commonBitsY = new CommonBits();\n}\nextend(CommonCoordinateFilter.prototype, {\n\tfilter: function filter(coord) {\n\t\tthis._commonBitsX.add(coord.x);\n\t\tthis._commonBitsY.add(coord.y);\n\t},\n\tgetCommonCoordinate: function getCommonCoordinate() {\n\t\treturn new Coordinate(this._commonBitsX.getCommon(), this._commonBitsY.getCommon());\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [CoordinateFilter];\n\t},\n\tgetClass: function getClass() {\n\t\treturn CommonCoordinateFilter;\n\t}\n});\nfunction Translater() {\n\tthis.trans = null;\n\tvar trans = arguments[0];\n\tthis.trans = trans;\n}\nextend(Translater.prototype, {\n\tfilter: function filter(seq, i) {\n\t\tvar xp = seq.getOrdinate(i, 0) + this.trans.x;\n\t\tvar yp = seq.getOrdinate(i, 1) + this.trans.y;\n\t\tseq.setOrdinate(i, 0, xp);\n\t\tseq.setOrdinate(i, 1, yp);\n\t},\n\tisDone: function isDone() {\n\t\treturn false;\n\t},\n\tisGeometryChanged: function isGeometryChanged() {\n\t\treturn true;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [CoordinateSequenceFilter];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Translater;\n\t}\n});\nCommonBitsRemover.CommonCoordinateFilter = CommonCoordinateFilter;\nCommonBitsRemover.Translater = Translater;\n\nfunction GeometryCollectionIterator() {\n\tthis._parent = null;\n\tthis._atStart = null;\n\tthis._max = null;\n\tthis._index = null;\n\tthis._subcollectionIterator = null;\n\tvar parent = arguments[0];\n\tthis._parent = parent;\n\tthis._atStart = true;\n\tthis._index = 0;\n\tthis._max = parent.getNumGeometries();\n}\nextend(GeometryCollectionIterator.prototype, {\n\tnext: function next() {\n\t\tif (this._atStart) {\n\t\t\tthis._atStart = false;\n\t\t\tif (GeometryCollectionIterator.isAtomic(this._parent)) this._index++;\n\t\t\treturn this._parent;\n\t\t}\n\t\tif (this._subcollectionIterator !== null) {\n\t\t\tif (this._subcollectionIterator.hasNext()) {\n\t\t\t\treturn this._subcollectionIterator.next();\n\t\t\t} else {\n\t\t\t\tthis._subcollectionIterator = null;\n\t\t\t}\n\t\t}\n\t\tif (this._index >= this._max) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tvar obj = this._parent.getGeometryN(this._index++);\n\t\tif (obj instanceof GeometryCollection) {\n\t\t\tthis._subcollectionIterator = new GeometryCollectionIterator(obj);\n\t\t\treturn this._subcollectionIterator.next();\n\t\t}\n\t\treturn obj;\n\t},\n\tremove: function remove() {\n\t\tthrow new UnsupportedOperationException(this.getClass().getName());\n\t},\n\thasNext: function hasNext() {\n\t\tif (this._atStart) {\n\t\t\treturn true;\n\t\t}\n\t\tif (this._subcollectionIterator !== null) {\n\t\t\tif (this._subcollectionIterator.hasNext()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tthis._subcollectionIterator = null;\n\t\t}\n\t\tif (this._index >= this._max) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Iterator];\n\t},\n\tgetClass: function getClass() {\n\t\treturn GeometryCollectionIterator;\n\t}\n});\nGeometryCollectionIterator.isAtomic = function (geom) {\n\treturn !(geom instanceof GeometryCollection);\n};\n\nfunction PointLocator() {\n\tthis._boundaryRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;\n\tthis._isIn = null;\n\tthis._numBoundaries = null;\n\tif (arguments.length === 0) {} else if (arguments.length === 1) {\n\t\tvar boundaryRule = arguments[0];\n\t\tif (boundaryRule === null) throw new IllegalArgumentException(\"Rule must be non-null\");\n\t\tthis._boundaryRule = boundaryRule;\n\t}\n}\nextend(PointLocator.prototype, {\n\tlocateInternal: function locateInternal() {\n\t\tif (arguments[0] instanceof Coordinate && arguments[1] instanceof Polygon) {\n\t\t\tvar p = arguments[0],\n\t\t\t    poly = arguments[1];\n\t\t\tif (poly.isEmpty()) return Location.EXTERIOR;\n\t\t\tvar shell = poly.getExteriorRing();\n\t\t\tvar shellLoc = this.locateInPolygonRing(p, shell);\n\t\t\tif (shellLoc === Location.EXTERIOR) return Location.EXTERIOR;\n\t\t\tif (shellLoc === Location.BOUNDARY) return Location.BOUNDARY;\n\t\t\tfor (var i = 0; i < poly.getNumInteriorRing(); i++) {\n\t\t\t\tvar hole = poly.getInteriorRingN(i);\n\t\t\t\tvar holeLoc = this.locateInPolygonRing(p, hole);\n\t\t\t\tif (holeLoc === Location.INTERIOR) return Location.EXTERIOR;\n\t\t\t\tif (holeLoc === Location.BOUNDARY) return Location.BOUNDARY;\n\t\t\t}\n\t\t\treturn Location.INTERIOR;\n\t\t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof LineString) {\n\t\t\tvar p = arguments[0],\n\t\t\t    l = arguments[1];\n\t\t\tif (!l.getEnvelopeInternal().intersects(p)) return Location.EXTERIOR;\n\t\t\tvar pt = l.getCoordinates();\n\t\t\tif (!l.isClosed()) {\n\t\t\t\tif (p.equals(pt[0]) || p.equals(pt[pt.length - 1])) {\n\t\t\t\t\treturn Location.BOUNDARY;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (CGAlgorithms.isOnLine(p, pt)) return Location.INTERIOR;\n\t\t\treturn Location.EXTERIOR;\n\t\t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Point) {\n\t\t\tvar p = arguments[0],\n\t\t\t    pt = arguments[1];\n\t\t\tvar ptCoord = pt.getCoordinate();\n\t\t\tif (ptCoord.equals2D(p)) return Location.INTERIOR;\n\t\t\treturn Location.EXTERIOR;\n\t\t}\n\t},\n\tlocateInPolygonRing: function locateInPolygonRing(p, ring) {\n\t\tif (!ring.getEnvelopeInternal().intersects(p)) return Location.EXTERIOR;\n\t\treturn CGAlgorithms.locatePointInRing(p, ring.getCoordinates());\n\t},\n\tintersects: function intersects(p, geom) {\n\t\treturn this.locate(p, geom) !== Location.EXTERIOR;\n\t},\n\tupdateLocationInfo: function updateLocationInfo(loc) {\n\t\tif (loc === Location.INTERIOR) this._isIn = true;\n\t\tif (loc === Location.BOUNDARY) this._numBoundaries++;\n\t},\n\tcomputeLocation: function computeLocation(p, geom) {\n\t\tif (geom instanceof Point) {\n\t\t\tthis.updateLocationInfo(this.locateInternal(p, geom));\n\t\t}\n\t\tif (geom instanceof LineString) {\n\t\t\tthis.updateLocationInfo(this.locateInternal(p, geom));\n\t\t} else if (geom instanceof Polygon) {\n\t\t\tthis.updateLocationInfo(this.locateInternal(p, geom));\n\t\t} else if (geom instanceof MultiLineString) {\n\t\t\tvar ml = geom;\n\t\t\tfor (var i = 0; i < ml.getNumGeometries(); i++) {\n\t\t\t\tvar l = ml.getGeometryN(i);\n\t\t\t\tthis.updateLocationInfo(this.locateInternal(p, l));\n\t\t\t}\n\t\t} else if (geom instanceof MultiPolygon) {\n\t\t\tvar mpoly = geom;\n\t\t\tfor (var i = 0; i < mpoly.getNumGeometries(); i++) {\n\t\t\t\tvar poly = mpoly.getGeometryN(i);\n\t\t\t\tthis.updateLocationInfo(this.locateInternal(p, poly));\n\t\t\t}\n\t\t} else if (geom instanceof GeometryCollection) {\n\t\t\tvar geomi = new GeometryCollectionIterator(geom);\n\t\t\twhile (geomi.hasNext()) {\n\t\t\t\tvar g2 = geomi.next();\n\t\t\t\tif (g2 !== geom) this.computeLocation(p, g2);\n\t\t\t}\n\t\t}\n\t},\n\tlocate: function locate(p, geom) {\n\t\tif (geom.isEmpty()) return Location.EXTERIOR;\n\t\tif (geom instanceof LineString) {\n\t\t\treturn this.locateInternal(p, geom);\n\t\t} else if (geom instanceof Polygon) {\n\t\t\treturn this.locateInternal(p, geom);\n\t\t}\n\t\tthis._isIn = false;\n\t\tthis._numBoundaries = 0;\n\t\tthis.computeLocation(p, geom);\n\t\tif (this._boundaryRule.isInBoundary(this._numBoundaries)) return Location.BOUNDARY;\n\t\tif (this._numBoundaries > 0 || this._isIn) return Location.INTERIOR;\n\t\treturn Location.EXTERIOR;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn PointLocator;\n\t}\n});\n\nfunction Octant() {}\nextend(Octant.prototype, {\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Octant;\n\t}\n});\nOctant.octant = function () {\n\tif (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\") {\n\t\tvar dx = arguments[0],\n\t\t    dy = arguments[1];\n\t\tif (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException(\"Cannot compute the octant for point ( \" + dx + \", \" + dy + \" )\");\n\t\tvar adx = Math.abs(dx);\n\t\tvar ady = Math.abs(dy);\n\t\tif (dx >= 0) {\n\t\t\tif (dy >= 0) {\n\t\t\t\tif (adx >= ady) return 0;else return 1;\n\t\t\t} else {\n\t\t\t\tif (adx >= ady) return 7;else return 6;\n\t\t\t}\n\t\t} else {\n\t\t\tif (dy >= 0) {\n\t\t\t\tif (adx >= ady) return 3;else return 2;\n\t\t\t} else {\n\t\t\t\tif (adx >= ady) return 4;else return 5;\n\t\t\t}\n\t\t}\n\t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n\t\tvar p0 = arguments[0],\n\t\t    p1 = arguments[1];\n\t\tvar dx = p1.x - p0.x;\n\t\tvar dy = p1.y - p0.y;\n\t\tif (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException(\"Cannot compute the octant for two identical points \" + p0);\n\t\treturn Octant.octant(dx, dy);\n\t}\n};\n\nfunction SegmentString() {}\nextend(SegmentString.prototype, {\n\tgetCoordinates: function getCoordinates() {},\n\tsize: function size() {},\n\tgetCoordinate: function getCoordinate(i) {},\n\tisClosed: function isClosed() {},\n\tsetData: function setData(data) {},\n\tgetData: function getData() {},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn SegmentString;\n\t}\n});\n\nfunction BasicSegmentString() {\n\tthis._pts = null;\n\tthis._data = null;\n\tvar pts = arguments[0],\n\t    data = arguments[1];\n\tthis._pts = pts;\n\tthis._data = data;\n}\nextend(BasicSegmentString.prototype, {\n\tgetCoordinates: function getCoordinates() {\n\t\treturn this._pts;\n\t},\n\tsize: function size() {\n\t\treturn this._pts.length;\n\t},\n\tgetCoordinate: function getCoordinate(i) {\n\t\treturn this._pts[i];\n\t},\n\tisClosed: function isClosed() {\n\t\treturn this._pts[0].equals(this._pts[this._pts.length - 1]);\n\t},\n\tgetSegmentOctant: function getSegmentOctant(index) {\n\t\tif (index === this._pts.length - 1) return -1;\n\t\treturn Octant.octant(this.getCoordinate(index), this.getCoordinate(index + 1));\n\t},\n\tsetData: function setData(data) {\n\t\tthis._data = data;\n\t},\n\tgetData: function getData() {\n\t\treturn this._data;\n\t},\n\ttoString: function toString() {\n\t\treturn WKTWriter.toLineString(new CoordinateArraySequence(this._pts));\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [SegmentString];\n\t},\n\tgetClass: function getClass() {\n\t\treturn BasicSegmentString;\n\t}\n});\n\nfunction Boundable() {}\nextend(Boundable.prototype, {\n\tgetBounds: function getBounds() {},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Boundable;\n\t}\n});\n\nfunction ItemBoundable() {\n\tthis._bounds = null;\n\tthis._item = null;\n\tvar bounds = arguments[0],\n\t    item = arguments[1];\n\tthis._bounds = bounds;\n\tthis._item = item;\n}\nextend(ItemBoundable.prototype, {\n\tgetItem: function getItem() {\n\t\treturn this._item;\n\t},\n\tgetBounds: function getBounds() {\n\t\treturn this._bounds;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Boundable, Serializable];\n\t},\n\tgetClass: function getClass() {\n\t\treturn ItemBoundable;\n\t}\n});\n\nfunction PriorityQueue() {\n\tthis._size = null;\n\tthis._items = null;\n\tthis._size = 0;\n\tthis._items = new ArrayList();\n\tthis._items.add(null);\n}\nextend(PriorityQueue.prototype, {\n\tpoll: function poll() {\n\t\tif (this.isEmpty()) return null;\n\t\tvar minItem = this._items.get(1);\n\t\tthis._items.set(1, this._items.get(this._size));\n\t\tthis._size -= 1;\n\t\tthis.reorder(1);\n\t\treturn minItem;\n\t},\n\tsize: function size() {\n\t\treturn this._size;\n\t},\n\treorder: function reorder(hole) {\n\t\tvar child = null;\n\t\tvar tmp = this._items.get(hole);\n\t\tfor (; hole * 2 <= this._size; hole = child) {\n\t\t\tchild = hole * 2;\n\t\t\tif (child !== this._size && this._items.get(child + 1).compareTo(this._items.get(child)) < 0) child++;\n\t\t\tif (this._items.get(child).compareTo(tmp) < 0) this._items.set(hole, this._items.get(child));else break;\n\t\t}\n\t\tthis._items.set(hole, tmp);\n\t},\n\tclear: function clear() {\n\t\tthis._size = 0;\n\t\tthis._items.clear();\n\t},\n\tisEmpty: function isEmpty() {\n\t\treturn this._size === 0;\n\t},\n\tadd: function add(x) {\n\t\tthis._items.add(null);\n\t\tthis._size += 1;\n\t\tvar hole = this._size;\n\t\tthis._items.set(0, x);\n\t\tfor (; x.compareTo(this._items.get(Math.trunc(hole / 2))) < 0; hole /= 2) {\n\t\t\tthis._items.set(hole, this._items.get(Math.trunc(hole / 2)));\n\t\t}\n\t\tthis._items.set(hole, x);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn PriorityQueue;\n\t}\n});\n\nfunction ItemVisitor() {}\nextend(ItemVisitor.prototype, {\n\tvisitItem: function visitItem(item) {},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn ItemVisitor;\n\t}\n});\n\nfunction SpatialIndex() {}\nextend(SpatialIndex.prototype, {\n\tinsert: function insert(itemEnv, item) {},\n\tremove: function remove(itemEnv, item) {},\n\tquery: function query() {\n\t\t\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn SpatialIndex;\n\t}\n});\n\nfunction AbstractNode() {\n\tthis._childBoundables = new ArrayList();\n\tthis._bounds = null;\n\tthis._level = null;\n\tif (arguments.length === 0) {} else if (arguments.length === 1) {\n\t\tvar level = arguments[0];\n\t\tthis._level = level;\n\t}\n}\nextend(AbstractNode.prototype, {\n\tgetLevel: function getLevel() {\n\t\treturn this._level;\n\t},\n\tsize: function size() {\n\t\treturn this._childBoundables.size();\n\t},\n\tgetChildBoundables: function getChildBoundables() {\n\t\treturn this._childBoundables;\n\t},\n\taddChildBoundable: function addChildBoundable(childBoundable) {\n\t\tAssert.isTrue(this._bounds === null);\n\t\tthis._childBoundables.add(childBoundable);\n\t},\n\tisEmpty: function isEmpty() {\n\t\treturn this._childBoundables.isEmpty();\n\t},\n\tgetBounds: function getBounds() {\n\t\tif (this._bounds === null) {\n\t\t\tthis._bounds = this.computeBounds();\n\t\t}\n\t\treturn this._bounds;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Boundable, Serializable];\n\t},\n\tgetClass: function getClass() {\n\t\treturn AbstractNode;\n\t}\n});\nAbstractNode.serialVersionUID = 6493722185909573708;\n\nvar Collections = {\n  reverseOrder: function reverseOrder() {\n    return {\n      compare: function compare(a, b) {\n        return b.compareTo(a);\n      }\n    };\n  },\n  min: function min(l) {\n    Collections.sort(l);\n    return l.get(0);\n  },\n  sort: function sort(l, c) {\n    var a = l.toArray();\n    if (c) {\n      Arrays.sort(a, c);\n    } else {\n      Arrays.sort(a);\n    }\n    var i = l.iterator();\n    for (var pos = 0, alen = a.length; pos < alen; pos++) {\n      i.next();\n      i.set(a[pos]);\n    }\n  },\n  singletonList: function singletonList(o) {\n    var arrayList = new ArrayList();\n    arrayList.add(o);\n    return arrayList;\n  }\n};\n\nfunction BoundablePair() {\n\tthis._boundable1 = null;\n\tthis._boundable2 = null;\n\tthis._distance = null;\n\tthis._itemDistance = null;\n\tvar boundable1 = arguments[0],\n\t    boundable2 = arguments[1],\n\t    itemDistance = arguments[2];\n\tthis._boundable1 = boundable1;\n\tthis._boundable2 = boundable2;\n\tthis._itemDistance = itemDistance;\n\tthis._distance = this.distance();\n}\nextend(BoundablePair.prototype, {\n\texpandToQueue: function expandToQueue(priQ, minDistance) {\n\t\tvar isComp1 = BoundablePair.isComposite(this._boundable1);\n\t\tvar isComp2 = BoundablePair.isComposite(this._boundable2);\n\t\tif (isComp1 && isComp2) {\n\t\t\tif (BoundablePair.area(this._boundable1) > BoundablePair.area(this._boundable2)) {\n\t\t\t\tthis.expand(this._boundable1, this._boundable2, priQ, minDistance);\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\tthis.expand(this._boundable2, this._boundable1, priQ, minDistance);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else if (isComp1) {\n\t\t\tthis.expand(this._boundable1, this._boundable2, priQ, minDistance);\n\t\t\treturn null;\n\t\t} else if (isComp2) {\n\t\t\tthis.expand(this._boundable2, this._boundable1, priQ, minDistance);\n\t\t\treturn null;\n\t\t}\n\t\tthrow new IllegalArgumentException(\"neither boundable is composite\");\n\t},\n\tisLeaves: function isLeaves() {\n\t\treturn !(BoundablePair.isComposite(this._boundable1) || BoundablePair.isComposite(this._boundable2));\n\t},\n\tcompareTo: function compareTo(o) {\n\t\tvar nd = o;\n\t\tif (this._distance < nd._distance) return -1;\n\t\tif (this._distance > nd._distance) return 1;\n\t\treturn 0;\n\t},\n\texpand: function expand(bndComposite, bndOther, priQ, minDistance) {\n\t\tvar children = bndComposite.getChildBoundables();\n\t\tfor (var i = children.iterator(); i.hasNext();) {\n\t\t\tvar child = i.next();\n\t\t\tvar bp = new BoundablePair(child, bndOther, this._itemDistance);\n\t\t\tif (bp.getDistance() < minDistance) {\n\t\t\t\tpriQ.add(bp);\n\t\t\t}\n\t\t}\n\t},\n\tgetBoundable: function getBoundable(i) {\n\t\tif (i === 0) return this._boundable1;\n\t\treturn this._boundable2;\n\t},\n\tgetDistance: function getDistance() {\n\t\treturn this._distance;\n\t},\n\tdistance: function distance() {\n\t\tif (this.isLeaves()) {\n\t\t\treturn this._itemDistance.distance(this._boundable1, this._boundable2);\n\t\t}\n\t\treturn this._boundable1.getBounds().distance(this._boundable2.getBounds());\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Comparable];\n\t},\n\tgetClass: function getClass() {\n\t\treturn BoundablePair;\n\t}\n});\nBoundablePair.area = function (b) {\n\treturn b.getBounds().getArea();\n};\nBoundablePair.isComposite = function (item) {\n\treturn item instanceof AbstractNode;\n};\n\nfunction AbstractSTRtree() {\n\tthis._root = null;\n\tthis._built = false;\n\tthis._itemBoundables = new ArrayList();\n\tthis._nodeCapacity = null;\n\tif (arguments.length === 0) {\n\t\tAbstractSTRtree.call(this, AbstractSTRtree.DEFAULT_NODE_CAPACITY);\n\t} else if (arguments.length === 1) {\n\t\tvar nodeCapacity = arguments[0];\n\t\tAssert.isTrue(nodeCapacity > 1, \"Node capacity must be greater than 1\");\n\t\tthis._nodeCapacity = nodeCapacity;\n\t}\n}\nextend(AbstractSTRtree.prototype, {\n\tgetNodeCapacity: function getNodeCapacity() {\n\t\treturn this._nodeCapacity;\n\t},\n\tlastNode: function lastNode(nodes) {\n\t\treturn nodes.get(nodes.size() - 1);\n\t},\n\tsize: function size() {\n\t\tif (arguments.length === 0) {\n\t\t\tif (this.isEmpty()) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tthis.build();\n\t\t\treturn this.size(this._root);\n\t\t} else if (arguments.length === 1) {\n\t\t\tvar node = arguments[0];\n\t\t\tvar size = 0;\n\t\t\tfor (var i = node.getChildBoundables().iterator(); i.hasNext();) {\n\t\t\t\tvar childBoundable = i.next();\n\t\t\t\tif (childBoundable instanceof AbstractNode) {\n\t\t\t\t\tsize += this.size(childBoundable);\n\t\t\t\t} else if (childBoundable instanceof ItemBoundable) {\n\t\t\t\t\tsize += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn size;\n\t\t}\n\t},\n\tremoveItem: function removeItem(node, item) {\n\t\tvar childToRemove = null;\n\t\tfor (var i = node.getChildBoundables().iterator(); i.hasNext();) {\n\t\t\tvar childBoundable = i.next();\n\t\t\tif (childBoundable instanceof ItemBoundable) {\n\t\t\t\tif (childBoundable.getItem() === item) childToRemove = childBoundable;\n\t\t\t}\n\t\t}\n\t\tif (childToRemove !== null) {\n\t\t\tnode.getChildBoundables().remove(childToRemove);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\titemsTree: function itemsTree() {\n\t\tif (arguments.length === 0) {\n\t\t\tthis.build();\n\t\t\tvar valuesTree = this.itemsTree(this._root);\n\t\t\tif (valuesTree === null) return new ArrayList();\n\t\t\treturn valuesTree;\n\t\t} else if (arguments.length === 1) {\n\t\t\tvar node = arguments[0];\n\t\t\tvar valuesTreeForNode = new ArrayList();\n\t\t\tfor (var i = node.getChildBoundables().iterator(); i.hasNext();) {\n\t\t\t\tvar childBoundable = i.next();\n\t\t\t\tif (childBoundable instanceof AbstractNode) {\n\t\t\t\t\tvar valuesTreeForChild = this.itemsTree(childBoundable);\n\t\t\t\t\tif (valuesTreeForChild !== null) valuesTreeForNode.add(valuesTreeForChild);\n\t\t\t\t} else if (childBoundable instanceof ItemBoundable) {\n\t\t\t\t\tvaluesTreeForNode.add(childBoundable.getItem());\n\t\t\t\t} else {\n\t\t\t\t\tAssert.shouldNeverReachHere();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (valuesTreeForNode.size() <= 0) return null;\n\t\t\treturn valuesTreeForNode;\n\t\t}\n\t},\n\tinsert: function insert(bounds, item) {\n\t\tAssert.isTrue(!this._built, \"Cannot insert items into an STR packed R-tree after it has been built.\");\n\t\tthis._itemBoundables.add(new ItemBoundable(bounds, item));\n\t},\n\tboundablesAtLevel: function boundablesAtLevel() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar level = arguments[0];\n\t\t\tvar boundables = new ArrayList();\n\t\t\tthis.boundablesAtLevel(level, this._root, boundables);\n\t\t\treturn boundables;\n\t\t} else if (arguments.length === 3) {\n\t\t\tvar level = arguments[0],\n\t\t\t    top = arguments[1],\n\t\t\t    boundables = arguments[2];\n\t\t\tAssert.isTrue(level > -2);\n\t\t\tif (top.getLevel() === level) {\n\t\t\t\tboundables.add(top);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tfor (var i = top.getChildBoundables().iterator(); i.hasNext();) {\n\t\t\t\tvar boundable = i.next();\n\t\t\t\tif (boundable instanceof AbstractNode) {\n\t\t\t\t\tthis.boundablesAtLevel(level, boundable, boundables);\n\t\t\t\t} else {\n\t\t\t\t\tAssert.isTrue(boundable instanceof ItemBoundable);\n\t\t\t\t\tif (level === -1) {\n\t\t\t\t\t\tboundables.add(boundable);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t},\n\tquery: function query() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar searchBounds = arguments[0];\n\t\t\tthis.build();\n\t\t\tvar matches = new ArrayList();\n\t\t\tif (this.isEmpty()) {\n\t\t\t\treturn matches;\n\t\t\t}\n\t\t\tif (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {\n\t\t\t\tthis.query(searchBounds, this._root, matches);\n\t\t\t}\n\t\t\treturn matches;\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar searchBounds = arguments[0],\n\t\t\t    visitor = arguments[1];\n\t\t\tthis.build();\n\t\t\tif (this.isEmpty()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {\n\t\t\t\tthis.query(searchBounds, this._root, visitor);\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tif (hasInterface(arguments[2], ItemVisitor) && arguments[0] instanceof Object && arguments[1] instanceof AbstractNode) {\n\t\t\t\tvar searchBounds = arguments[0],\n\t\t\t\t    node = arguments[1],\n\t\t\t\t    visitor = arguments[2];\n\t\t\t\tvar childBoundables = node.getChildBoundables();\n\t\t\t\tfor (var i = 0; i < childBoundables.size(); i++) {\n\t\t\t\t\tvar childBoundable = childBoundables.get(i);\n\t\t\t\t\tif (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (childBoundable instanceof AbstractNode) {\n\t\t\t\t\t\tthis.query(searchBounds, childBoundable, visitor);\n\t\t\t\t\t} else if (childBoundable instanceof ItemBoundable) {\n\t\t\t\t\t\tvisitor.visitItem(childBoundable.getItem());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tAssert.shouldNeverReachHere();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (hasInterface(arguments[2], List) && arguments[0] instanceof Object && arguments[1] instanceof AbstractNode) {\n\t\t\t\tvar searchBounds = arguments[0],\n\t\t\t\t    node = arguments[1],\n\t\t\t\t    matches = arguments[2];\n\t\t\t\tvar childBoundables = node.getChildBoundables();\n\t\t\t\tfor (var i = 0; i < childBoundables.size(); i++) {\n\t\t\t\t\tvar childBoundable = childBoundables.get(i);\n\t\t\t\t\tif (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (childBoundable instanceof AbstractNode) {\n\t\t\t\t\t\tthis.query(searchBounds, childBoundable, matches);\n\t\t\t\t\t} else if (childBoundable instanceof ItemBoundable) {\n\t\t\t\t\t\tmatches.add(childBoundable.getItem());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tAssert.shouldNeverReachHere();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tbuild: function build() {\n\t\tif (this._built) return null;\n\t\tthis._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1);\n\t\tthis._itemBoundables = null;\n\t\tthis._built = true;\n\t},\n\tgetRoot: function getRoot() {\n\t\tthis.build();\n\t\treturn this._root;\n\t},\n\tremove: function remove() {\n\t\tif (arguments.length === 2) {\n\t\t\tvar searchBounds = arguments[0],\n\t\t\t    item = arguments[1];\n\t\t\tthis.build();\n\t\t\tif (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {\n\t\t\t\treturn this.remove(searchBounds, this._root, item);\n\t\t\t}\n\t\t\treturn false;\n\t\t} else if (arguments.length === 3) {\n\t\t\tvar searchBounds = arguments[0],\n\t\t\t    node = arguments[1],\n\t\t\t    item = arguments[2];\n\t\t\tvar found = this.removeItem(node, item);\n\t\t\tif (found) return true;\n\t\t\tvar childToPrune = null;\n\t\t\tfor (var i = node.getChildBoundables().iterator(); i.hasNext();) {\n\t\t\t\tvar childBoundable = i.next();\n\t\t\t\tif (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (childBoundable instanceof AbstractNode) {\n\t\t\t\t\tfound = this.remove(searchBounds, childBoundable, item);\n\t\t\t\t\tif (found) {\n\t\t\t\t\t\tchildToPrune = childBoundable;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (childToPrune !== null) {\n\t\t\t\tif (childToPrune.getChildBoundables().isEmpty()) {\n\t\t\t\t\tnode.getChildBoundables().remove(childToPrune);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn found;\n\t\t}\n\t},\n\tcreateHigherLevels: function createHigherLevels(boundablesOfALevel, level) {\n\t\tAssert.isTrue(!boundablesOfALevel.isEmpty());\n\t\tvar parentBoundables = this.createParentBoundables(boundablesOfALevel, level + 1);\n\t\tif (parentBoundables.size() === 1) {\n\t\t\treturn parentBoundables.get(0);\n\t\t}\n\t\treturn this.createHigherLevels(parentBoundables, level + 1);\n\t},\n\tdepth: function depth() {\n\t\tif (arguments.length === 0) {\n\t\t\tif (this.isEmpty()) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tthis.build();\n\t\t\treturn this.depth(this._root);\n\t\t} else if (arguments.length === 1) {\n\t\t\tvar node = arguments[0];\n\t\t\tvar maxChildDepth = 0;\n\t\t\tfor (var i = node.getChildBoundables().iterator(); i.hasNext();) {\n\t\t\t\tvar childBoundable = i.next();\n\t\t\t\tif (childBoundable instanceof AbstractNode) {\n\t\t\t\t\tvar childDepth = this.depth(childBoundable);\n\t\t\t\t\tif (childDepth > maxChildDepth) maxChildDepth = childDepth;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn maxChildDepth + 1;\n\t\t}\n\t},\n\tcreateParentBoundables: function createParentBoundables(childBoundables, newLevel) {\n\t\tAssert.isTrue(!childBoundables.isEmpty());\n\t\tvar parentBoundables = new ArrayList();\n\t\tparentBoundables.add(this.createNode(newLevel));\n\t\tvar sortedChildBoundables = new ArrayList(childBoundables);\n\t\tCollections.sort(sortedChildBoundables, this.getComparator());\n\t\tfor (var i = sortedChildBoundables.iterator(); i.hasNext();) {\n\t\t\tvar childBoundable = i.next();\n\t\t\tif (this.lastNode(parentBoundables).getChildBoundables().size() === this.getNodeCapacity()) {\n\t\t\t\tparentBoundables.add(this.createNode(newLevel));\n\t\t\t}\n\t\t\tthis.lastNode(parentBoundables).addChildBoundable(childBoundable);\n\t\t}\n\t\treturn parentBoundables;\n\t},\n\tisEmpty: function isEmpty() {\n\t\tif (!this._built) return this._itemBoundables.isEmpty();\n\t\treturn this._root.isEmpty();\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Serializable];\n\t},\n\tgetClass: function getClass() {\n\t\treturn AbstractSTRtree;\n\t}\n});\nAbstractSTRtree.compareDoubles = function (a, b) {\n\treturn a > b ? 1 : a < b ? -1 : 0;\n};\nfunction IntersectsOp$1() {}\nAbstractSTRtree.IntersectsOp = IntersectsOp$1;\nAbstractSTRtree.serialVersionUID = -3886435814360241337;\nAbstractSTRtree.DEFAULT_NODE_CAPACITY = 10;\n\nfunction ItemDistance() {}\nextend(ItemDistance.prototype, {\n\tdistance: function distance(item1, item2) {},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn ItemDistance;\n\t}\n});\n\nfunction STRtree() {\n\tif (arguments.length === 0) {\n\t\tSTRtree.call(this, STRtree.DEFAULT_NODE_CAPACITY);\n\t} else if (arguments.length === 1) {\n\t\tvar nodeCapacity = arguments[0];\n\t\tAbstractSTRtree.call(this, nodeCapacity);\n\t}\n}\ninherits$1(STRtree, AbstractSTRtree);\nextend(STRtree.prototype, {\n\tcreateParentBoundablesFromVerticalSlices: function createParentBoundablesFromVerticalSlices(verticalSlices, newLevel) {\n\t\tAssert.isTrue(verticalSlices.length > 0);\n\t\tvar parentBoundables = new ArrayList();\n\t\tfor (var i = 0; i < verticalSlices.length; i++) {\n\t\t\tparentBoundables.addAll(this.createParentBoundablesFromVerticalSlice(verticalSlices[i], newLevel));\n\t\t}\n\t\treturn parentBoundables;\n\t},\n\tcreateNode: function createNode(level) {\n\t\treturn new STRtreeNode(level);\n\t},\n\tsize: function size() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn AbstractSTRtree.prototype.size.call(this);\n\t\t} else return AbstractSTRtree.prototype.size.apply(this, arguments);\n\t},\n\tinsert: function insert() {\n\t\tif (arguments.length === 2) {\n\t\t\tvar itemEnv = arguments[0],\n\t\t\t    item = arguments[1];\n\t\t\tif (itemEnv.isNull()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tAbstractSTRtree.prototype.insert.call(this, itemEnv, item);\n\t\t} else return AbstractSTRtree.prototype.insert.apply(this, arguments);\n\t},\n\tgetIntersectsOp: function getIntersectsOp() {\n\t\treturn STRtree.intersectsOp;\n\t},\n\tverticalSlices: function verticalSlices(childBoundables, sliceCount) {\n\t\tvar sliceCapacity = Math.trunc(Math.ceil(childBoundables.size() / sliceCount));\n\t\tvar slices = new Array(sliceCount).fill(null);\n\t\tvar i = childBoundables.iterator();\n\t\tfor (var j = 0; j < sliceCount; j++) {\n\t\t\tslices[j] = new ArrayList();\n\t\t\tvar boundablesAddedToSlice = 0;\n\t\t\twhile (i.hasNext() && boundablesAddedToSlice < sliceCapacity) {\n\t\t\t\tvar childBoundable = i.next();\n\t\t\t\tslices[j].add(childBoundable);\n\t\t\t\tboundablesAddedToSlice++;\n\t\t\t}\n\t\t}\n\t\treturn slices;\n\t},\n\tquery: function query() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar searchEnv = arguments[0];\n\t\t\treturn AbstractSTRtree.prototype.query.call(this, searchEnv);\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar searchEnv = arguments[0],\n\t\t\t    visitor = arguments[1];\n\t\t\tAbstractSTRtree.prototype.query.call(this, searchEnv, visitor);\n\t\t} else if (arguments.length === 3) {\n\t\t\tif (hasInterface(arguments[2], ItemVisitor) && arguments[0] instanceof Object && arguments[1] instanceof AbstractNode) {\n\t\t\t\tvar searchBounds = arguments[0],\n\t\t\t\t    node = arguments[1],\n\t\t\t\t    visitor = arguments[2];\n\t\t\t\tAbstractSTRtree.prototype.query.call(this, searchBounds, node, visitor);\n\t\t\t} else if (hasInterface(arguments[2], List) && arguments[0] instanceof Object && arguments[1] instanceof AbstractNode) {\n\t\t\t\tvar searchBounds = arguments[0],\n\t\t\t\t    node = arguments[1],\n\t\t\t\t    matches = arguments[2];\n\t\t\t\tAbstractSTRtree.prototype.query.call(this, searchBounds, node, matches);\n\t\t\t}\n\t\t}\n\t},\n\tgetComparator: function getComparator() {\n\t\treturn STRtree.yComparator;\n\t},\n\tcreateParentBoundablesFromVerticalSlice: function createParentBoundablesFromVerticalSlice(childBoundables, newLevel) {\n\t\treturn AbstractSTRtree.prototype.createParentBoundables.call(this, childBoundables, newLevel);\n\t},\n\tremove: function remove() {\n\t\tif (arguments.length === 2) {\n\t\t\tvar itemEnv = arguments[0],\n\t\t\t    item = arguments[1];\n\t\t\treturn AbstractSTRtree.prototype.remove.call(this, itemEnv, item);\n\t\t} else return AbstractSTRtree.prototype.remove.apply(this, arguments);\n\t},\n\tdepth: function depth() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn AbstractSTRtree.prototype.depth.call(this);\n\t\t} else return AbstractSTRtree.prototype.depth.apply(this, arguments);\n\t},\n\tcreateParentBoundables: function createParentBoundables(childBoundables, newLevel) {\n\t\tAssert.isTrue(!childBoundables.isEmpty());\n\t\tvar minLeafCount = Math.trunc(Math.ceil(childBoundables.size() / this.getNodeCapacity()));\n\t\tvar sortedChildBoundables = new ArrayList(childBoundables);\n\t\tCollections.sort(sortedChildBoundables, STRtree.xComparator);\n\t\tvar verticalSlices = this.verticalSlices(sortedChildBoundables, Math.trunc(Math.ceil(Math.sqrt(minLeafCount))));\n\t\treturn this.createParentBoundablesFromVerticalSlices(verticalSlices, newLevel);\n\t},\n\tnearestNeighbour: function nearestNeighbour() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (hasInterface(arguments[0], ItemDistance)) {\n\t\t\t\tvar itemDist = arguments[0];\n\t\t\t\tvar bp = new BoundablePair(this.getRoot(), this.getRoot(), itemDist);\n\t\t\t\treturn this.nearestNeighbour(bp);\n\t\t\t} else if (arguments[0] instanceof BoundablePair) {\n\t\t\t\tvar initBndPair = arguments[0];\n\t\t\t\treturn this.nearestNeighbour(initBndPair, Double.POSITIVE_INFINITY);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tif (arguments[0] instanceof STRtree && hasInterface(arguments[1], ItemDistance)) {\n\t\t\t\tvar tree = arguments[0],\n\t\t\t\t    itemDist = arguments[1];\n\t\t\t\tvar bp = new BoundablePair(this.getRoot(), tree.getRoot(), itemDist);\n\t\t\t\treturn this.nearestNeighbour(bp);\n\t\t\t} else if (arguments[0] instanceof BoundablePair && typeof arguments[1] === \"number\") {\n\t\t\t\tvar initBndPair = arguments[0],\n\t\t\t\t    maxDistance = arguments[1];\n\t\t\t\tvar distanceLowerBound = maxDistance;\n\t\t\t\tvar minPair = null;\n\t\t\t\tvar priQ = new PriorityQueue();\n\t\t\t\tpriQ.add(initBndPair);\n\t\t\t\twhile (!priQ.isEmpty() && distanceLowerBound > 0.0) {\n\t\t\t\t\tvar bndPair = priQ.poll();\n\t\t\t\t\tvar currentDistance = bndPair.getDistance();\n\t\t\t\t\tif (currentDistance >= distanceLowerBound) break;\n\t\t\t\t\tif (bndPair.isLeaves()) {\n\t\t\t\t\t\tdistanceLowerBound = currentDistance;\n\t\t\t\t\t\tminPair = bndPair;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbndPair.expandToQueue(priQ, distanceLowerBound);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn [minPair.getBoundable(0).getItem(), minPair.getBoundable(1).getItem()];\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tvar env = arguments[0],\n\t\t\t    item = arguments[1],\n\t\t\t    itemDist = arguments[2];\n\t\t\tvar bnd = new ItemBoundable(env, item);\n\t\t\tvar bp = new BoundablePair(this.getRoot(), bnd, itemDist);\n\t\t\treturn this.nearestNeighbour(bp)[0];\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [SpatialIndex, Serializable];\n\t},\n\tgetClass: function getClass() {\n\t\treturn STRtree;\n\t}\n});\nSTRtree.centreX = function (e) {\n\treturn STRtree.avg(e.getMinX(), e.getMaxX());\n};\nSTRtree.avg = function (a, b) {\n\treturn (a + b) / 2;\n};\nSTRtree.centreY = function (e) {\n\treturn STRtree.avg(e.getMinY(), e.getMaxY());\n};\nfunction STRtreeNode() {\n\tvar level = arguments[0];\n\tAbstractNode.call(this, level);\n}\ninherits$1(STRtreeNode, AbstractNode);\nextend(STRtreeNode.prototype, {\n\tcomputeBounds: function computeBounds() {\n\t\tvar bounds = null;\n\t\tfor (var i = this.getChildBoundables().iterator(); i.hasNext();) {\n\t\t\tvar childBoundable = i.next();\n\t\t\tif (bounds === null) {\n\t\t\t\tbounds = new Envelope(childBoundable.getBounds());\n\t\t\t} else {\n\t\t\t\tbounds.expandToInclude(childBoundable.getBounds());\n\t\t\t}\n\t\t}\n\t\treturn bounds;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn STRtreeNode;\n\t}\n});\nSTRtree.STRtreeNode = STRtreeNode;\nSTRtree.serialVersionUID = 259274702368956900;\nSTRtree.xComparator = {\n\tinterfaces_: function interfaces_() {\n\t\treturn [Comparator];\n\t},\n\tcompare: function compare(o1, o2) {\n\t\treturn AbstractSTRtree.compareDoubles(STRtree.centreX(o1.getBounds()), STRtree.centreX(o2.getBounds()));\n\t}\n};\nSTRtree.yComparator = {\n\tinterfaces_: function interfaces_() {\n\t\treturn [Comparator];\n\t},\n\tcompare: function compare(o1, o2) {\n\t\treturn AbstractSTRtree.compareDoubles(STRtree.centreY(o1.getBounds()), STRtree.centreY(o2.getBounds()));\n\t}\n};\nSTRtree.intersectsOp = {\n\tinterfaces_: function interfaces_() {\n\t\treturn [IntersectsOp];\n\t},\n\tintersects: function intersects(aBounds, bBounds) {\n\t\treturn aBounds.intersects(bBounds);\n\t}\n};\nSTRtree.DEFAULT_NODE_CAPACITY = 10;\n\nfunction SegmentPointComparator() {}\nextend(SegmentPointComparator.prototype, {\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn SegmentPointComparator;\n\t}\n});\nSegmentPointComparator.relativeSign = function (x0, x1) {\n\tif (x0 < x1) return -1;\n\tif (x0 > x1) return 1;\n\treturn 0;\n};\nSegmentPointComparator.compare = function (octant, p0, p1) {\n\tif (p0.equals2D(p1)) return 0;\n\tvar xSign = SegmentPointComparator.relativeSign(p0.x, p1.x);\n\tvar ySign = SegmentPointComparator.relativeSign(p0.y, p1.y);\n\tswitch (octant) {\n\t\tcase 0:\n\t\t\treturn SegmentPointComparator.compareValue(xSign, ySign);\n\t\tcase 1:\n\t\t\treturn SegmentPointComparator.compareValue(ySign, xSign);\n\t\tcase 2:\n\t\t\treturn SegmentPointComparator.compareValue(ySign, -xSign);\n\t\tcase 3:\n\t\t\treturn SegmentPointComparator.compareValue(-xSign, ySign);\n\t\tcase 4:\n\t\t\treturn SegmentPointComparator.compareValue(-xSign, -ySign);\n\t\tcase 5:\n\t\t\treturn SegmentPointComparator.compareValue(-ySign, -xSign);\n\t\tcase 6:\n\t\t\treturn SegmentPointComparator.compareValue(-ySign, xSign);\n\t\tcase 7:\n\t\t\treturn SegmentPointComparator.compareValue(xSign, -ySign);\n\t}\n\tAssert.shouldNeverReachHere(\"invalid octant value\");\n\treturn 0;\n};\nSegmentPointComparator.compareValue = function (compareSign0, compareSign1) {\n\tif (compareSign0 < 0) return -1;\n\tif (compareSign0 > 0) return 1;\n\tif (compareSign1 < 0) return -1;\n\tif (compareSign1 > 0) return 1;\n\treturn 0;\n};\n\nfunction SegmentNode() {\n\tthis._segString = null;\n\tthis.coord = null;\n\tthis.segmentIndex = null;\n\tthis._segmentOctant = null;\n\tthis._isInterior = null;\n\tvar segString = arguments[0],\n\t    coord = arguments[1],\n\t    segmentIndex = arguments[2],\n\t    segmentOctant = arguments[3];\n\tthis._segString = segString;\n\tthis.coord = new Coordinate(coord);\n\tthis.segmentIndex = segmentIndex;\n\tthis._segmentOctant = segmentOctant;\n\tthis._isInterior = !coord.equals2D(segString.getCoordinate(segmentIndex));\n}\nextend(SegmentNode.prototype, {\n\tgetCoordinate: function getCoordinate() {\n\t\treturn this.coord;\n\t},\n\tprint: function print(out) {\n\t\tout.print(this.coord);\n\t\tout.print(\" seg # = \" + this.segmentIndex);\n\t},\n\tcompareTo: function compareTo(obj) {\n\t\tvar other = obj;\n\t\tif (this.segmentIndex < other.segmentIndex) return -1;\n\t\tif (this.segmentIndex > other.segmentIndex) return 1;\n\t\tif (this.coord.equals2D(other.coord)) return 0;\n\t\treturn SegmentPointComparator.compare(this._segmentOctant, this.coord, other.coord);\n\t},\n\tisEndPoint: function isEndPoint(maxSegmentIndex) {\n\t\tif (this.segmentIndex === 0 && !this._isInterior) return true;\n\t\tif (this.segmentIndex === maxSegmentIndex) return true;\n\t\treturn false;\n\t},\n\tisInterior: function isInterior() {\n\t\treturn this._isInterior;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Comparable];\n\t},\n\tgetClass: function getClass() {\n\t\treturn SegmentNode;\n\t}\n});\n\nfunction SegmentNodeList() {\n\tthis._nodeMap = new TreeMap();\n\tthis._edge = null;\n\tvar edge = arguments[0];\n\tthis._edge = edge;\n}\nextend(SegmentNodeList.prototype, {\n\tgetSplitCoordinates: function getSplitCoordinates() {\n\t\tvar coordList = new CoordinateList();\n\t\tthis.addEndpoints();\n\t\tvar it = this.iterator();\n\t\tvar eiPrev = it.next();\n\t\twhile (it.hasNext()) {\n\t\t\tvar ei = it.next();\n\t\t\tthis.addEdgeCoordinates(eiPrev, ei, coordList);\n\t\t\teiPrev = ei;\n\t\t}\n\t\treturn coordList.toCoordinateArray();\n\t},\n\taddCollapsedNodes: function addCollapsedNodes() {\n\t\tvar collapsedVertexIndexes = new ArrayList();\n\t\tthis.findCollapsesFromInsertedNodes(collapsedVertexIndexes);\n\t\tthis.findCollapsesFromExistingVertices(collapsedVertexIndexes);\n\t\tfor (var it = collapsedVertexIndexes.iterator(); it.hasNext();) {\n\t\t\tvar vertexIndex = it.next().intValue();\n\t\t\tthis.add(this._edge.getCoordinate(vertexIndex), vertexIndex);\n\t\t}\n\t},\n\tprint: function print(out) {\n\t\tout.println(\"Intersections:\");\n\t\tfor (var it = this.iterator(); it.hasNext();) {\n\t\t\tvar ei = it.next();\n\t\t\tei.print(out);\n\t\t}\n\t},\n\tfindCollapsesFromExistingVertices: function findCollapsesFromExistingVertices(collapsedVertexIndexes) {\n\t\tfor (var i = 0; i < this._edge.size() - 2; i++) {\n\t\t\tvar p0 = this._edge.getCoordinate(i);\n\t\t\tvar p1 = this._edge.getCoordinate(i + 1);\n\t\t\tvar p2 = this._edge.getCoordinate(i + 2);\n\t\t\tif (p0.equals2D(p2)) {\n\t\t\t\tcollapsedVertexIndexes.add(new Integer(i + 1));\n\t\t\t}\n\t\t}\n\t},\n\taddEdgeCoordinates: function addEdgeCoordinates(ei0, ei1, coordList) {\n\t\tvar npts = ei1.segmentIndex - ei0.segmentIndex + 2;\n\t\tvar lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);\n\t\tvar useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);\n\t\tif (!useIntPt1) {\n\t\t\tnpts--;\n\t\t}\n\t\tcoordList.add(new Coordinate(ei0.coord), false);\n\t\tfor (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {\n\t\t\tcoordList.add(this._edge.getCoordinate(i));\n\t\t}\n\t\tif (useIntPt1) {\n\t\t\tcoordList.add(new Coordinate(ei1.coord));\n\t\t}\n\t},\n\titerator: function iterator() {\n\t\treturn this._nodeMap.values().iterator();\n\t},\n\taddSplitEdges: function addSplitEdges(edgeList) {\n\t\tthis.addEndpoints();\n\t\tthis.addCollapsedNodes();\n\t\tvar it = this.iterator();\n\t\tvar eiPrev = it.next();\n\t\twhile (it.hasNext()) {\n\t\t\tvar ei = it.next();\n\t\t\tvar newEdge = this.createSplitEdge(eiPrev, ei);\n\t\t\tedgeList.add(newEdge);\n\t\t\teiPrev = ei;\n\t\t}\n\t},\n\tfindCollapseIndex: function findCollapseIndex(ei0, ei1, collapsedVertexIndex) {\n\t\tif (!ei0.coord.equals2D(ei1.coord)) return false;\n\t\tvar numVerticesBetween = ei1.segmentIndex - ei0.segmentIndex;\n\t\tif (!ei1.isInterior()) {\n\t\t\tnumVerticesBetween--;\n\t\t}\n\t\tif (numVerticesBetween === 1) {\n\t\t\tcollapsedVertexIndex[0] = ei0.segmentIndex + 1;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\tfindCollapsesFromInsertedNodes: function findCollapsesFromInsertedNodes(collapsedVertexIndexes) {\n\t\tvar collapsedVertexIndex = new Array(1).fill(null);\n\t\tvar it = this.iterator();\n\t\tvar eiPrev = it.next();\n\t\twhile (it.hasNext()) {\n\t\t\tvar ei = it.next();\n\t\t\tvar isCollapsed = this.findCollapseIndex(eiPrev, ei, collapsedVertexIndex);\n\t\t\tif (isCollapsed) collapsedVertexIndexes.add(new Integer(collapsedVertexIndex[0]));\n\t\t\teiPrev = ei;\n\t\t}\n\t},\n\tgetEdge: function getEdge() {\n\t\treturn this._edge;\n\t},\n\taddEndpoints: function addEndpoints() {\n\t\tvar maxSegIndex = this._edge.size() - 1;\n\t\tthis.add(this._edge.getCoordinate(0), 0);\n\t\tthis.add(this._edge.getCoordinate(maxSegIndex), maxSegIndex);\n\t},\n\tcreateSplitEdge: function createSplitEdge(ei0, ei1) {\n\t\tvar npts = ei1.segmentIndex - ei0.segmentIndex + 2;\n\t\tvar lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);\n\t\tvar useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);\n\t\tif (!useIntPt1) {\n\t\t\tnpts--;\n\t\t}\n\t\tvar pts = new Array(npts).fill(null);\n\t\tvar ipt = 0;\n\t\tpts[ipt++] = new Coordinate(ei0.coord);\n\t\tfor (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {\n\t\t\tpts[ipt++] = this._edge.getCoordinate(i);\n\t\t}\n\t\tif (useIntPt1) pts[ipt] = new Coordinate(ei1.coord);\n\t\treturn new NodedSegmentString(pts, this._edge.getData());\n\t},\n\tadd: function add(intPt, segmentIndex) {\n\t\tvar eiNew = new SegmentNode(this._edge, intPt, segmentIndex, this._edge.getSegmentOctant(segmentIndex));\n\t\tvar ei = this._nodeMap.get(eiNew);\n\t\tif (ei !== null) {\n\t\t\tAssert.isTrue(ei.coord.equals2D(intPt), \"Found equal nodes with different coordinates\");\n\t\t\treturn ei;\n\t\t}\n\t\tthis._nodeMap.put(eiNew, eiNew);\n\t\treturn eiNew;\n\t},\n\tcheckSplitEdgesCorrectness: function checkSplitEdgesCorrectness(splitEdges) {\n\t\tvar edgePts = this._edge.getCoordinates();\n\t\tvar split0 = splitEdges.get(0);\n\t\tvar pt0 = split0.getCoordinate(0);\n\t\tif (!pt0.equals2D(edgePts[0])) throw new RuntimeException(\"bad split edge start point at \" + pt0);\n\t\tvar splitn = splitEdges.get(splitEdges.size() - 1);\n\t\tvar splitnPts = splitn.getCoordinates();\n\t\tvar ptn = splitnPts[splitnPts.length - 1];\n\t\tif (!ptn.equals2D(edgePts[edgePts.length - 1])) throw new RuntimeException(\"bad split edge end point at \" + ptn);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn SegmentNodeList;\n\t}\n});\nfunction NodeVertexIterator() {\n\tthis._nodeList = null;\n\tthis._edge = null;\n\tthis._nodeIt = null;\n\tthis._currNode = null;\n\tthis._nextNode = null;\n\tthis._currSegIndex = 0;\n\tvar nodeList = arguments[0];\n\tthis._nodeList = nodeList;\n\tthis._edge = nodeList.getEdge();\n\tthis._nodeIt = nodeList.iterator();\n\tthis.readNextNode();\n}\nextend(NodeVertexIterator.prototype, {\n\tnext: function next() {\n\t\tif (this._currNode === null) {\n\t\t\tthis._currNode = this._nextNode;\n\t\t\tthis._currSegIndex = this._currNode.segmentIndex;\n\t\t\tthis.readNextNode();\n\t\t\treturn this._currNode;\n\t\t}\n\t\tif (this._nextNode === null) return null;\n\t\tif (this._nextNode.segmentIndex === this._currNode.segmentIndex) {\n\t\t\tthis._currNode = this._nextNode;\n\t\t\tthis._currSegIndex = this._currNode.segmentIndex;\n\t\t\tthis.readNextNode();\n\t\t\treturn this._currNode;\n\t\t}\n\t\tif (this._nextNode.segmentIndex > this._currNode.segmentIndex) {}\n\t\treturn null;\n\t},\n\tremove: function remove() {\n\t\tthrow new UnsupportedOperationException(this.getClass().getName());\n\t},\n\thasNext: function hasNext() {\n\t\tif (this._nextNode === null) return false;\n\t\treturn true;\n\t},\n\treadNextNode: function readNextNode() {\n\t\tif (this._nodeIt.hasNext()) this._nextNode = this._nodeIt.next();else this._nextNode = null;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Iterator];\n\t},\n\tgetClass: function getClass() {\n\t\treturn NodeVertexIterator;\n\t}\n});\n\nfunction NodableSegmentString() {}\nextend(NodableSegmentString.prototype, {\n\taddIntersection: function addIntersection(intPt, segmentIndex) {},\n\tinterfaces_: function interfaces_() {\n\t\treturn [SegmentString];\n\t},\n\tgetClass: function getClass() {\n\t\treturn NodableSegmentString;\n\t}\n});\n\nfunction NodedSegmentString() {\n\tthis._nodeList = new SegmentNodeList(this);\n\tthis._pts = null;\n\tthis._data = null;\n\tvar pts = arguments[0],\n\t    data = arguments[1];\n\tthis._pts = pts;\n\tthis._data = data;\n}\nextend(NodedSegmentString.prototype, {\n\tgetCoordinates: function getCoordinates() {\n\t\treturn this._pts;\n\t},\n\tsize: function size() {\n\t\treturn this._pts.length;\n\t},\n\tgetCoordinate: function getCoordinate(i) {\n\t\treturn this._pts[i];\n\t},\n\tisClosed: function isClosed() {\n\t\treturn this._pts[0].equals(this._pts[this._pts.length - 1]);\n\t},\n\tgetSegmentOctant: function getSegmentOctant(index) {\n\t\tif (index === this._pts.length - 1) return -1;\n\t\treturn this.safeOctant(this.getCoordinate(index), this.getCoordinate(index + 1));\n\t},\n\tsetData: function setData(data) {\n\t\tthis._data = data;\n\t},\n\tsafeOctant: function safeOctant(p0, p1) {\n\t\tif (p0.equals2D(p1)) return 0;\n\t\treturn Octant.octant(p0, p1);\n\t},\n\tgetData: function getData() {\n\t\treturn this._data;\n\t},\n\taddIntersection: function addIntersection() {\n\t\tif (arguments.length === 2) {\n\t\t\tvar intPt = arguments[0],\n\t\t\t    segmentIndex = arguments[1];\n\t\t\tthis.addIntersectionNode(intPt, segmentIndex);\n\t\t} else if (arguments.length === 4) {\n\t\t\tvar li = arguments[0],\n\t\t\t    segmentIndex = arguments[1],\n\t\t\t    geomIndex = arguments[2],\n\t\t\t    intIndex = arguments[3];\n\t\t\tvar intPt = new Coordinate(li.getIntersection(intIndex));\n\t\t\tthis.addIntersection(intPt, segmentIndex);\n\t\t}\n\t},\n\ttoString: function toString() {\n\t\treturn WKTWriter.toLineString(new CoordinateArraySequence(this._pts));\n\t},\n\tgetNodeList: function getNodeList() {\n\t\treturn this._nodeList;\n\t},\n\taddIntersectionNode: function addIntersectionNode(intPt, segmentIndex) {\n\t\tvar normalizedSegmentIndex = segmentIndex;\n\t\tvar nextSegIndex = normalizedSegmentIndex + 1;\n\t\tif (nextSegIndex < this._pts.length) {\n\t\t\tvar nextPt = this._pts[nextSegIndex];\n\t\t\tif (intPt.equals2D(nextPt)) {\n\t\t\t\tnormalizedSegmentIndex = nextSegIndex;\n\t\t\t}\n\t\t}\n\t\tvar ei = this._nodeList.add(intPt, normalizedSegmentIndex);\n\t\treturn ei;\n\t},\n\taddIntersections: function addIntersections(li, segmentIndex, geomIndex) {\n\t\tfor (var i = 0; i < li.getIntersectionNum(); i++) {\n\t\t\tthis.addIntersection(li, segmentIndex, geomIndex, i);\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [NodableSegmentString];\n\t},\n\tgetClass: function getClass() {\n\t\treturn NodedSegmentString;\n\t}\n});\nNodedSegmentString.getNodedSubstrings = function () {\n\tif (arguments.length === 1) {\n\t\tvar segStrings = arguments[0];\n\t\tvar resultEdgelist = new ArrayList();\n\t\tNodedSegmentString.getNodedSubstrings(segStrings, resultEdgelist);\n\t\treturn resultEdgelist;\n\t} else if (arguments.length === 2) {\n\t\tvar segStrings = arguments[0],\n\t\t    resultEdgelist = arguments[1];\n\t\tfor (var i = segStrings.iterator(); i.hasNext();) {\n\t\t\tvar ss = i.next();\n\t\t\tss.getNodeList().addSplitEdges(resultEdgelist);\n\t\t}\n\t}\n};\n\nfunction MonotoneChainOverlapAction() {\n\tthis.tempEnv1 = new Envelope();\n\tthis.tempEnv2 = new Envelope();\n\tthis._overlapSeg1 = new LineSegment();\n\tthis._overlapSeg2 = new LineSegment();\n}\nextend(MonotoneChainOverlapAction.prototype, {\n\toverlap: function overlap() {\n\t\tif (arguments.length === 2) {\n\t\t\t\n\t\t} else if (arguments.length === 4) {\n\t\t\tvar mc1 = arguments[0],\n\t\t\t    start1 = arguments[1],\n\t\t\t    mc2 = arguments[2],\n\t\t\t    start2 = arguments[3];\n\t\t\tmc1.getLineSegment(start1, this._overlapSeg1);\n\t\t\tmc2.getLineSegment(start2, this._overlapSeg2);\n\t\t\tthis.overlap(this._overlapSeg1, this._overlapSeg2);\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn MonotoneChainOverlapAction;\n\t}\n});\n\nfunction MonotoneChain() {\n\tthis._pts = null;\n\tthis._start = null;\n\tthis._end = null;\n\tthis._env = null;\n\tthis._context = null;\n\tthis._id = null;\n\tvar pts = arguments[0],\n\t    start = arguments[1],\n\t    end = arguments[2],\n\t    context = arguments[3];\n\tthis._pts = pts;\n\tthis._start = start;\n\tthis._end = end;\n\tthis._context = context;\n}\nextend(MonotoneChain.prototype, {\n\tgetLineSegment: function getLineSegment(index, ls) {\n\t\tls.p0 = this._pts[index];\n\t\tls.p1 = this._pts[index + 1];\n\t},\n\tcomputeSelect: function computeSelect(searchEnv, start0, end0, mcs) {\n\t\tvar p0 = this._pts[start0];\n\t\tvar p1 = this._pts[end0];\n\t\tmcs.tempEnv1.init(p0, p1);\n\t\tif (end0 - start0 === 1) {\n\t\t\tmcs.select(this, start0);\n\t\t\treturn null;\n\t\t}\n\t\tif (!searchEnv.intersects(mcs.tempEnv1)) return null;\n\t\tvar mid = Math.trunc((start0 + end0) / 2);\n\t\tif (start0 < mid) {\n\t\t\tthis.computeSelect(searchEnv, start0, mid, mcs);\n\t\t}\n\t\tif (mid < end0) {\n\t\t\tthis.computeSelect(searchEnv, mid, end0, mcs);\n\t\t}\n\t},\n\tgetCoordinates: function getCoordinates() {\n\t\tvar coord = new Array(this._end - this._start + 1).fill(null);\n\t\tvar index = 0;\n\t\tfor (var i = this._start; i <= this._end; i++) {\n\t\t\tcoord[index++] = this._pts[i];\n\t\t}\n\t\treturn coord;\n\t},\n\tcomputeOverlaps: function computeOverlaps(mc, mco) {\n\t\tthis.computeOverlapsInternal(this._start, this._end, mc, mc._start, mc._end, mco);\n\t},\n\tsetId: function setId(id) {\n\t\tthis._id = id;\n\t},\n\tselect: function select(searchEnv, mcs) {\n\t\tthis.computeSelect(searchEnv, this._start, this._end, mcs);\n\t},\n\tgetEnvelope: function getEnvelope() {\n\t\tif (this._env === null) {\n\t\t\tvar p0 = this._pts[this._start];\n\t\t\tvar p1 = this._pts[this._end];\n\t\t\tthis._env = new Envelope(p0, p1);\n\t\t}\n\t\treturn this._env;\n\t},\n\tgetEndIndex: function getEndIndex() {\n\t\treturn this._end;\n\t},\n\tgetStartIndex: function getStartIndex() {\n\t\treturn this._start;\n\t},\n\tgetContext: function getContext() {\n\t\treturn this._context;\n\t},\n\tgetId: function getId() {\n\t\treturn this._id;\n\t},\n\tcomputeOverlapsInternal: function computeOverlapsInternal(start0, end0, mc, start1, end1, mco) {\n\t\tvar p00 = this._pts[start0];\n\t\tvar p01 = this._pts[end0];\n\t\tvar p10 = mc._pts[start1];\n\t\tvar p11 = mc._pts[end1];\n\t\tif (end0 - start0 === 1 && end1 - start1 === 1) {\n\t\t\tmco.overlap(this, start0, mc, start1);\n\t\t\treturn null;\n\t\t}\n\t\tmco.tempEnv1.init(p00, p01);\n\t\tmco.tempEnv2.init(p10, p11);\n\t\tif (!mco.tempEnv1.intersects(mco.tempEnv2)) return null;\n\t\tvar mid0 = Math.trunc((start0 + end0) / 2);\n\t\tvar mid1 = Math.trunc((start1 + end1) / 2);\n\t\tif (start0 < mid0) {\n\t\t\tif (start1 < mid1) this.computeOverlapsInternal(start0, mid0, mc, start1, mid1, mco);\n\t\t\tif (mid1 < end1) this.computeOverlapsInternal(start0, mid0, mc, mid1, end1, mco);\n\t\t}\n\t\tif (mid0 < end0) {\n\t\t\tif (start1 < mid1) this.computeOverlapsInternal(mid0, end0, mc, start1, mid1, mco);\n\t\t\tif (mid1 < end1) this.computeOverlapsInternal(mid0, end0, mc, mid1, end1, mco);\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn MonotoneChain;\n\t}\n});\n\nfunction Quadrant() {}\nextend(Quadrant.prototype, {\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Quadrant;\n\t}\n});\nQuadrant.isNorthern = function (quad) {\n\treturn quad === Quadrant.NE || quad === Quadrant.NW;\n};\nQuadrant.isOpposite = function (quad1, quad2) {\n\tif (quad1 === quad2) return false;\n\tvar diff = (quad1 - quad2 + 4) % 4;\n\tif (diff === 2) return true;\n\treturn false;\n};\nQuadrant.commonHalfPlane = function (quad1, quad2) {\n\tif (quad1 === quad2) return quad1;\n\tvar diff = (quad1 - quad2 + 4) % 4;\n\tif (diff === 2) return -1;\n\tvar min = quad1 < quad2 ? quad1 : quad2;\n\tvar max = quad1 > quad2 ? quad1 : quad2;\n\tif (min === 0 && max === 3) return 3;\n\treturn min;\n};\nQuadrant.isInHalfPlane = function (quad, halfPlane) {\n\tif (halfPlane === Quadrant.SE) {\n\t\treturn quad === Quadrant.SE || quad === Quadrant.SW;\n\t}\n\treturn quad === halfPlane || quad === halfPlane + 1;\n};\nQuadrant.quadrant = function () {\n\tif (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\") {\n\t\tvar dx = arguments[0],\n\t\t    dy = arguments[1];\n\t\tif (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException(\"Cannot compute the quadrant for point ( \" + dx + \", \" + dy + \" )\");\n\t\tif (dx >= 0.0) {\n\t\t\tif (dy >= 0.0) return Quadrant.NE;else return Quadrant.SE;\n\t\t} else {\n\t\t\tif (dy >= 0.0) return Quadrant.NW;else return Quadrant.SW;\n\t\t}\n\t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n\t\tvar p0 = arguments[0],\n\t\t    p1 = arguments[1];\n\t\tif (p1.x === p0.x && p1.y === p0.y) throw new IllegalArgumentException(\"Cannot compute the quadrant for two identical points \" + p0);\n\t\tif (p1.x >= p0.x) {\n\t\t\tif (p1.y >= p0.y) return Quadrant.NE;else return Quadrant.SE;\n\t\t} else {\n\t\t\tif (p1.y >= p0.y) return Quadrant.NW;else return Quadrant.SW;\n\t\t}\n\t}\n};\nQuadrant.NE = 0;\nQuadrant.NW = 1;\nQuadrant.SW = 2;\nQuadrant.SE = 3;\n\nfunction MonotoneChainBuilder() {}\nextend(MonotoneChainBuilder.prototype, {\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn MonotoneChainBuilder;\n\t}\n});\nMonotoneChainBuilder.getChainStartIndices = function (pts) {\n\tvar start = 0;\n\tvar startIndexList = new ArrayList();\n\tstartIndexList.add(new Integer(start));\n\tdo {\n\t\tvar last = MonotoneChainBuilder.findChainEnd(pts, start);\n\t\tstartIndexList.add(new Integer(last));\n\t\tstart = last;\n\t} while (start < pts.length - 1);\n\tvar startIndex = MonotoneChainBuilder.toIntArray(startIndexList);\n\treturn startIndex;\n};\nMonotoneChainBuilder.findChainEnd = function (pts, start) {\n\tvar safeStart = start;\n\twhile (safeStart < pts.length - 1 && pts[safeStart].equals2D(pts[safeStart + 1])) {\n\t\tsafeStart++;\n\t}\n\tif (safeStart >= pts.length - 1) {\n\t\treturn pts.length - 1;\n\t}\n\tvar chainQuad = Quadrant.quadrant(pts[safeStart], pts[safeStart + 1]);\n\tvar last = start + 1;\n\twhile (last < pts.length) {\n\t\tif (!pts[last - 1].equals2D(pts[last])) {\n\t\t\tvar quad = Quadrant.quadrant(pts[last - 1], pts[last]);\n\t\t\tif (quad !== chainQuad) break;\n\t\t}\n\t\tlast++;\n\t}\n\treturn last - 1;\n};\nMonotoneChainBuilder.getChains = function () {\n\tif (arguments.length === 1) {\n\t\tvar pts = arguments[0];\n\t\treturn MonotoneChainBuilder.getChains(pts, null);\n\t} else if (arguments.length === 2) {\n\t\tvar pts = arguments[0],\n\t\t    context = arguments[1];\n\t\tvar mcList = new ArrayList();\n\t\tvar startIndex = MonotoneChainBuilder.getChainStartIndices(pts);\n\t\tfor (var i = 0; i < startIndex.length - 1; i++) {\n\t\t\tvar mc = new MonotoneChain(pts, startIndex[i], startIndex[i + 1], context);\n\t\t\tmcList.add(mc);\n\t\t}\n\t\treturn mcList;\n\t}\n};\nMonotoneChainBuilder.toIntArray = function (list) {\n\tvar array = new Array(list.size()).fill(null);\n\tfor (var i = 0; i < array.length; i++) {\n\t\tarray[i] = list.get(i).intValue();\n\t}\n\treturn array;\n};\n\nfunction Noder() {}\nextend(Noder.prototype, {\n\tcomputeNodes: function computeNodes(segStrings) {},\n\tgetNodedSubstrings: function getNodedSubstrings() {},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Noder;\n\t}\n});\n\nfunction SinglePassNoder() {\n\tthis._segInt = null;\n\tif (arguments.length === 0) {} else if (arguments.length === 1) {\n\t\tvar segInt = arguments[0];\n\t\tthis.setSegmentIntersector(segInt);\n\t}\n}\nextend(SinglePassNoder.prototype, {\n\tsetSegmentIntersector: function setSegmentIntersector(segInt) {\n\t\tthis._segInt = segInt;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Noder];\n\t},\n\tgetClass: function getClass() {\n\t\treturn SinglePassNoder;\n\t}\n});\n\nfunction MCIndexNoder() {\n\tthis._monoChains = new ArrayList();\n\tthis._index = new STRtree();\n\tthis._idCounter = 0;\n\tthis._nodedSegStrings = null;\n\tthis._nOverlaps = 0;\n\tif (arguments.length === 0) {} else if (arguments.length === 1) {\n\t\tvar si = arguments[0];\n\t\tSinglePassNoder.call(this, si);\n\t}\n}\ninherits$1(MCIndexNoder, SinglePassNoder);\nextend(MCIndexNoder.prototype, {\n\tgetMonotoneChains: function getMonotoneChains() {\n\t\treturn this._monoChains;\n\t},\n\tgetNodedSubstrings: function getNodedSubstrings() {\n\t\treturn NodedSegmentString.getNodedSubstrings(this._nodedSegStrings);\n\t},\n\tgetIndex: function getIndex() {\n\t\treturn this._index;\n\t},\n\tadd: function add(segStr) {\n\t\tvar segChains = MonotoneChainBuilder.getChains(segStr.getCoordinates(), segStr);\n\t\tfor (var i = segChains.iterator(); i.hasNext();) {\n\t\t\tvar mc = i.next();\n\t\t\tmc.setId(this._idCounter++);\n\t\t\tthis._index.insert(mc.getEnvelope(), mc);\n\t\t\tthis._monoChains.add(mc);\n\t\t}\n\t},\n\tcomputeNodes: function computeNodes(inputSegStrings) {\n\t\tthis._nodedSegStrings = inputSegStrings;\n\t\tfor (var i = inputSegStrings.iterator(); i.hasNext();) {\n\t\t\tthis.add(i.next());\n\t\t}\n\t\tthis.intersectChains();\n\t},\n\tintersectChains: function intersectChains() {\n\t\tvar overlapAction = new SegmentOverlapAction(this._segInt);\n\t\tfor (var i = this._monoChains.iterator(); i.hasNext();) {\n\t\t\tvar queryChain = i.next();\n\t\t\tvar overlapChains = this._index.query(queryChain.getEnvelope());\n\t\t\tfor (var j = overlapChains.iterator(); j.hasNext();) {\n\t\t\t\tvar testChain = j.next();\n\t\t\t\tif (testChain.getId() > queryChain.getId()) {\n\t\t\t\t\tqueryChain.computeOverlaps(testChain, overlapAction);\n\t\t\t\t\tthis._nOverlaps++;\n\t\t\t\t}\n\t\t\t\tif (this._segInt.isDone()) return null;\n\t\t\t}\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn MCIndexNoder;\n\t}\n});\nfunction SegmentOverlapAction() {\n\tMonotoneChainOverlapAction.apply(this);\n\tthis._si = null;\n\tvar si = arguments[0];\n\tthis._si = si;\n}\ninherits$1(SegmentOverlapAction, MonotoneChainOverlapAction);\nextend(SegmentOverlapAction.prototype, {\n\toverlap: function overlap() {\n\t\tif (arguments.length === 4) {\n\t\t\tvar mc1 = arguments[0],\n\t\t\t    start1 = arguments[1],\n\t\t\t    mc2 = arguments[2],\n\t\t\t    start2 = arguments[3];\n\t\t\tvar ss1 = mc1.getContext();\n\t\t\tvar ss2 = mc2.getContext();\n\t\t\tthis._si.processIntersections(ss1, start1, ss2, start2);\n\t\t} else return MonotoneChainOverlapAction.prototype.overlap.apply(this, arguments);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn SegmentOverlapAction;\n\t}\n});\nMCIndexNoder.SegmentOverlapAction = SegmentOverlapAction;\n\nfunction TopologyException() {\n\tthis.pt = null;\n\tif (arguments.length === 1) {\n\t\tvar msg = arguments[0];\n\t\tRuntimeException.call(this, msg);\n\t} else if (arguments.length === 2) {\n\t\tvar msg = arguments[0],\n\t\t    pt = arguments[1];\n\t\tRuntimeException.call(this, TopologyException.msgWithCoord(msg, pt));\n\t\tthis.name = 'TopologyException';\n\t\tthis.pt = new Coordinate(pt);\n\t}\n}\ninherits$1(TopologyException, RuntimeException);\nextend(TopologyException.prototype, {\n\tgetCoordinate: function getCoordinate() {\n\t\treturn this.pt;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn TopologyException;\n\t}\n});\nTopologyException.msgWithCoord = function (msg, pt) {\n\tif (pt !== null) return msg + \" [ \" + pt + \" ]\";\n\treturn msg;\n};\n\nfunction SegmentIntersector() {}\nextend(SegmentIntersector.prototype, {\n\tprocessIntersections: function processIntersections(e0, segIndex0, e1, segIndex1) {},\n\tisDone: function isDone() {},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn SegmentIntersector;\n\t}\n});\n\nfunction InteriorIntersectionFinder() {\n\tthis._findAllIntersections = false;\n\tthis._isCheckEndSegmentsOnly = false;\n\tthis._li = null;\n\tthis._interiorIntersection = null;\n\tthis._intSegments = null;\n\tthis._intersections = new ArrayList();\n\tthis._intersectionCount = 0;\n\tthis._keepIntersections = true;\n\tvar li = arguments[0];\n\tthis._li = li;\n\tthis._interiorIntersection = null;\n}\nextend(InteriorIntersectionFinder.prototype, {\n\tgetInteriorIntersection: function getInteriorIntersection() {\n\t\treturn this._interiorIntersection;\n\t},\n\tsetCheckEndSegmentsOnly: function setCheckEndSegmentsOnly(isCheckEndSegmentsOnly) {\n\t\tthis._isCheckEndSegmentsOnly = isCheckEndSegmentsOnly;\n\t},\n\tgetIntersectionSegments: function getIntersectionSegments() {\n\t\treturn this._intSegments;\n\t},\n\tcount: function count() {\n\t\treturn this._intersectionCount;\n\t},\n\tgetIntersections: function getIntersections() {\n\t\treturn this._intersections;\n\t},\n\tsetFindAllIntersections: function setFindAllIntersections(findAllIntersections) {\n\t\tthis._findAllIntersections = findAllIntersections;\n\t},\n\tsetKeepIntersections: function setKeepIntersections(keepIntersections) {\n\t\tthis._keepIntersections = keepIntersections;\n\t},\n\tprocessIntersections: function processIntersections(e0, segIndex0, e1, segIndex1) {\n\t\tif (!this._findAllIntersections && this.hasIntersection()) return null;\n\t\tif (e0 === e1 && segIndex0 === segIndex1) return null;\n\t\tif (this._isCheckEndSegmentsOnly) {\n\t\t\tvar isEndSegPresent = this.isEndSegment(e0, segIndex0) || this.isEndSegment(e1, segIndex1);\n\t\t\tif (!isEndSegPresent) return null;\n\t\t}\n\t\tvar p00 = e0.getCoordinates()[segIndex0];\n\t\tvar p01 = e0.getCoordinates()[segIndex0 + 1];\n\t\tvar p10 = e1.getCoordinates()[segIndex1];\n\t\tvar p11 = e1.getCoordinates()[segIndex1 + 1];\n\t\tthis._li.computeIntersection(p00, p01, p10, p11);\n\t\tif (this._li.hasIntersection()) {\n\t\t\tif (this._li.isInteriorIntersection()) {\n\t\t\t\tthis._intSegments = new Array(4).fill(null);\n\t\t\t\tthis._intSegments[0] = p00;\n\t\t\t\tthis._intSegments[1] = p01;\n\t\t\t\tthis._intSegments[2] = p10;\n\t\t\t\tthis._intSegments[3] = p11;\n\t\t\t\tthis._interiorIntersection = this._li.getIntersection(0);\n\t\t\t\tif (this._keepIntersections) this._intersections.add(this._interiorIntersection);\n\t\t\t\tthis._intersectionCount++;\n\t\t\t}\n\t\t}\n\t},\n\tisEndSegment: function isEndSegment(segStr, index) {\n\t\tif (index === 0) return true;\n\t\tif (index >= segStr.size() - 2) return true;\n\t\treturn false;\n\t},\n\thasIntersection: function hasIntersection() {\n\t\treturn this._interiorIntersection !== null;\n\t},\n\tisDone: function isDone() {\n\t\tif (this._findAllIntersections) return false;\n\t\treturn this._interiorIntersection !== null;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [SegmentIntersector];\n\t},\n\tgetClass: function getClass() {\n\t\treturn InteriorIntersectionFinder;\n\t}\n});\nInteriorIntersectionFinder.createAllIntersectionsFinder = function (li) {\n\tvar finder = new InteriorIntersectionFinder(li);\n\tfinder.setFindAllIntersections(true);\n\treturn finder;\n};\nInteriorIntersectionFinder.createAnyIntersectionFinder = function (li) {\n\treturn new InteriorIntersectionFinder(li);\n};\nInteriorIntersectionFinder.createIntersectionCounter = function (li) {\n\tvar finder = new InteriorIntersectionFinder(li);\n\tfinder.setFindAllIntersections(true);\n\tfinder.setKeepIntersections(false);\n\treturn finder;\n};\n\nfunction FastNodingValidator() {\n\tthis._li = new RobustLineIntersector();\n\tthis._segStrings = null;\n\tthis._findAllIntersections = false;\n\tthis._segInt = null;\n\tthis._isValid = true;\n\tvar segStrings = arguments[0];\n\tthis._segStrings = segStrings;\n}\nextend(FastNodingValidator.prototype, {\n\texecute: function execute() {\n\t\tif (this._segInt !== null) return null;\n\t\tthis.checkInteriorIntersections();\n\t},\n\tgetIntersections: function getIntersections() {\n\t\treturn this._segInt.getIntersections();\n\t},\n\tisValid: function isValid() {\n\t\tthis.execute();\n\t\treturn this._isValid;\n\t},\n\tsetFindAllIntersections: function setFindAllIntersections(findAllIntersections) {\n\t\tthis._findAllIntersections = findAllIntersections;\n\t},\n\tcheckInteriorIntersections: function checkInteriorIntersections() {\n\t\tthis._isValid = true;\n\t\tthis._segInt = new InteriorIntersectionFinder(this._li);\n\t\tthis._segInt.setFindAllIntersections(this._findAllIntersections);\n\t\tvar noder = new MCIndexNoder();\n\t\tnoder.setSegmentIntersector(this._segInt);\n\t\tnoder.computeNodes(this._segStrings);\n\t\tif (this._segInt.hasIntersection()) {\n\t\t\tthis._isValid = false;\n\t\t\treturn null;\n\t\t}\n\t},\n\tcheckValid: function checkValid() {\n\t\tthis.execute();\n\t\tif (!this._isValid) throw new TopologyException(this.getErrorMessage(), this._segInt.getInteriorIntersection());\n\t},\n\tgetErrorMessage: function getErrorMessage() {\n\t\tif (this._isValid) return \"no intersections found\";\n\t\tvar intSegs = this._segInt.getIntersectionSegments();\n\t\treturn \"found non-noded intersection between \" + WKTWriter.toLineString(intSegs[0], intSegs[1]) + \" and \" + WKTWriter.toLineString(intSegs[2], intSegs[3]);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn FastNodingValidator;\n\t}\n});\nFastNodingValidator.computeIntersections = function (segStrings) {\n\tvar nv = new FastNodingValidator(segStrings);\n\tnv.setFindAllIntersections(true);\n\tnv.isValid();\n\treturn nv.getIntersections();\n};\n\nfunction EdgeNodingValidator() {\n\tthis._nv = null;\n\tvar edges = arguments[0];\n\tthis._nv = new FastNodingValidator(EdgeNodingValidator.toSegmentStrings(edges));\n}\nextend(EdgeNodingValidator.prototype, {\n\tcheckValid: function checkValid() {\n\t\tthis._nv.checkValid();\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn EdgeNodingValidator;\n\t}\n});\nEdgeNodingValidator.toSegmentStrings = function (edges) {\n\tvar segStrings = new ArrayList();\n\tfor (var i = edges.iterator(); i.hasNext();) {\n\t\tvar e = i.next();\n\t\tsegStrings.add(new BasicSegmentString(e.getCoordinates(), e));\n\t}\n\treturn segStrings;\n};\nEdgeNodingValidator.checkValid = function (edges) {\n\tvar validator = new EdgeNodingValidator(edges);\n\tvalidator.checkValid();\n};\n\nfunction GeometryCollectionMapper() {\n\tthis._mapOp = null;\n\tvar mapOp = arguments[0];\n\tthis._mapOp = mapOp;\n}\nextend(GeometryCollectionMapper.prototype, {\n\tmap: function map(gc) {\n\t\tvar mapped = new ArrayList();\n\t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n\t\t\tvar g = this._mapOp.map(gc.getGeometryN(i));\n\t\t\tif (!g.isEmpty()) mapped.add(g);\n\t\t}\n\t\treturn gc.getFactory().createGeometryCollection(GeometryFactory.toGeometryArray(mapped));\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn GeometryCollectionMapper;\n\t}\n});\nGeometryCollectionMapper.map = function (gc, op) {\n\tvar mapper = new GeometryCollectionMapper(op);\n\treturn mapper.map(gc);\n};\n\nfunction Position() {}\nextend(Position.prototype, {\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Position;\n\t}\n});\nPosition.opposite = function (position) {\n\tif (position === Position.LEFT) return Position.RIGHT;\n\tif (position === Position.RIGHT) return Position.LEFT;\n\treturn position;\n};\nPosition.ON = 0;\nPosition.LEFT = 1;\nPosition.RIGHT = 2;\n\nfunction TopologyLocation() {\n\tthis.location = null;\n\tif (arguments.length === 1) {\n\t\tif (arguments[0] instanceof Array) {\n\t\t\tvar location = arguments[0];\n\t\t\tthis.init(location.length);\n\t\t} else if (Number.isInteger(arguments[0])) {\n\t\t\tvar on = arguments[0];\n\t\t\tthis.init(1);\n\t\t\tthis.location[Position.ON] = on;\n\t\t} else if (arguments[0] instanceof TopologyLocation) {\n\t\t\tvar gl = arguments[0];\n\t\t\tthis.init(gl.location.length);\n\t\t\tif (gl !== null) {\n\t\t\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\t\t\tthis.location[i] = gl.location[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (arguments.length === 3) {\n\t\tvar on = arguments[0],\n\t\t    left = arguments[1],\n\t\t    right = arguments[2];\n\t\tthis.init(3);\n\t\tthis.location[Position.ON] = on;\n\t\tthis.location[Position.LEFT] = left;\n\t\tthis.location[Position.RIGHT] = right;\n\t}\n}\nextend(TopologyLocation.prototype, {\n\tsetAllLocations: function setAllLocations(locValue) {\n\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\tthis.location[i] = locValue;\n\t\t}\n\t},\n\tisNull: function isNull() {\n\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\tif (this.location[i] !== Location.NONE) return false;\n\t\t}\n\t\treturn true;\n\t},\n\tsetAllLocationsIfNull: function setAllLocationsIfNull(locValue) {\n\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\tif (this.location[i] === Location.NONE) this.location[i] = locValue;\n\t\t}\n\t},\n\tisLine: function isLine() {\n\t\treturn this.location.length === 1;\n\t},\n\tmerge: function merge(gl) {\n\t\tif (gl.location.length > this.location.length) {\n\t\t\tvar newLoc = new Array(3).fill(null);\n\t\t\tnewLoc[Position.ON] = this.location[Position.ON];\n\t\t\tnewLoc[Position.LEFT] = Location.NONE;\n\t\t\tnewLoc[Position.RIGHT] = Location.NONE;\n\t\t\tthis.location = newLoc;\n\t\t}\n\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\tif (this.location[i] === Location.NONE && i < gl.location.length) this.location[i] = gl.location[i];\n\t\t}\n\t},\n\tgetLocations: function getLocations() {\n\t\treturn this.location;\n\t},\n\tflip: function flip() {\n\t\tif (this.location.length <= 1) return null;\n\t\tvar temp = this.location[Position.LEFT];\n\t\tthis.location[Position.LEFT] = this.location[Position.RIGHT];\n\t\tthis.location[Position.RIGHT] = temp;\n\t},\n\ttoString: function toString() {\n\t\tvar buf = new StringBuffer();\n\t\tif (this.location.length > 1) buf.append(Location.toLocationSymbol(this.location[Position.LEFT]));\n\t\tbuf.append(Location.toLocationSymbol(this.location[Position.ON]));\n\t\tif (this.location.length > 1) buf.append(Location.toLocationSymbol(this.location[Position.RIGHT]));\n\t\treturn buf.toString();\n\t},\n\tsetLocations: function setLocations(on, left, right) {\n\t\tthis.location[Position.ON] = on;\n\t\tthis.location[Position.LEFT] = left;\n\t\tthis.location[Position.RIGHT] = right;\n\t},\n\tget: function get(posIndex) {\n\t\tif (posIndex < this.location.length) return this.location[posIndex];\n\t\treturn Location.NONE;\n\t},\n\tisArea: function isArea() {\n\t\treturn this.location.length > 1;\n\t},\n\tisAnyNull: function isAnyNull() {\n\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\tif (this.location[i] === Location.NONE) return true;\n\t\t}\n\t\treturn false;\n\t},\n\tsetLocation: function setLocation() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar locValue = arguments[0];\n\t\t\tthis.setLocation(Position.ON, locValue);\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar locIndex = arguments[0],\n\t\t\t    locValue = arguments[1];\n\t\t\tthis.location[locIndex] = locValue;\n\t\t}\n\t},\n\tinit: function init(size) {\n\t\tthis.location = new Array(size).fill(null);\n\t\tthis.setAllLocations(Location.NONE);\n\t},\n\tisEqualOnSide: function isEqualOnSide(le, locIndex) {\n\t\treturn this.location[locIndex] === le.location[locIndex];\n\t},\n\tallPositionsEqual: function allPositionsEqual(loc) {\n\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\tif (this.location[i] !== loc) return false;\n\t\t}\n\t\treturn true;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn TopologyLocation;\n\t}\n});\n\nfunction Label() {\n\tthis.elt = new Array(2).fill(null);\n\tif (arguments.length === 1) {\n\t\tif (Number.isInteger(arguments[0])) {\n\t\t\tvar onLoc = arguments[0];\n\t\t\tthis.elt[0] = new TopologyLocation(onLoc);\n\t\t\tthis.elt[1] = new TopologyLocation(onLoc);\n\t\t} else if (arguments[0] instanceof Label) {\n\t\t\tvar lbl = arguments[0];\n\t\t\tthis.elt[0] = new TopologyLocation(lbl.elt[0]);\n\t\t\tthis.elt[1] = new TopologyLocation(lbl.elt[1]);\n\t\t}\n\t} else if (arguments.length === 2) {\n\t\tvar geomIndex = arguments[0],\n\t\t    onLoc = arguments[1];\n\t\tthis.elt[0] = new TopologyLocation(Location.NONE);\n\t\tthis.elt[1] = new TopologyLocation(Location.NONE);\n\t\tthis.elt[geomIndex].setLocation(onLoc);\n\t} else if (arguments.length === 3) {\n\t\tvar onLoc = arguments[0],\n\t\t    leftLoc = arguments[1],\n\t\t    rightLoc = arguments[2];\n\t\tthis.elt[0] = new TopologyLocation(onLoc, leftLoc, rightLoc);\n\t\tthis.elt[1] = new TopologyLocation(onLoc, leftLoc, rightLoc);\n\t} else if (arguments.length === 4) {\n\t\tvar geomIndex = arguments[0],\n\t\t    onLoc = arguments[1],\n\t\t    leftLoc = arguments[2],\n\t\t    rightLoc = arguments[3];\n\t\tthis.elt[0] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);\n\t\tthis.elt[1] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);\n\t\tthis.elt[geomIndex].setLocations(onLoc, leftLoc, rightLoc);\n\t}\n}\nextend(Label.prototype, {\n\tgetGeometryCount: function getGeometryCount() {\n\t\tvar count = 0;\n\t\tif (!this.elt[0].isNull()) count++;\n\t\tif (!this.elt[1].isNull()) count++;\n\t\treturn count;\n\t},\n\tsetAllLocations: function setAllLocations(geomIndex, location) {\n\t\tthis.elt[geomIndex].setAllLocations(location);\n\t},\n\tisNull: function isNull(geomIndex) {\n\t\treturn this.elt[geomIndex].isNull();\n\t},\n\tsetAllLocationsIfNull: function setAllLocationsIfNull() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar location = arguments[0];\n\t\t\tthis.setAllLocationsIfNull(0, location);\n\t\t\tthis.setAllLocationsIfNull(1, location);\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar geomIndex = arguments[0],\n\t\t\t    location = arguments[1];\n\t\t\tthis.elt[geomIndex].setAllLocationsIfNull(location);\n\t\t}\n\t},\n\tisLine: function isLine(geomIndex) {\n\t\treturn this.elt[geomIndex].isLine();\n\t},\n\tmerge: function merge(lbl) {\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tif (this.elt[i] === null && lbl.elt[i] !== null) {\n\t\t\t\tthis.elt[i] = new TopologyLocation(lbl.elt[i]);\n\t\t\t} else {\n\t\t\t\tthis.elt[i].merge(lbl.elt[i]);\n\t\t\t}\n\t\t}\n\t},\n\tflip: function flip() {\n\t\tthis.elt[0].flip();\n\t\tthis.elt[1].flip();\n\t},\n\tgetLocation: function getLocation() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar geomIndex = arguments[0];\n\t\t\treturn this.elt[geomIndex].get(Position.ON);\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar geomIndex = arguments[0],\n\t\t\t    posIndex = arguments[1];\n\t\t\treturn this.elt[geomIndex].get(posIndex);\n\t\t}\n\t},\n\ttoString: function toString() {\n\t\tvar buf = new StringBuffer();\n\t\tif (this.elt[0] !== null) {\n\t\t\tbuf.append(\"A:\");\n\t\t\tbuf.append(this.elt[0].toString());\n\t\t}\n\t\tif (this.elt[1] !== null) {\n\t\t\tbuf.append(\" B:\");\n\t\t\tbuf.append(this.elt[1].toString());\n\t\t}\n\t\treturn buf.toString();\n\t},\n\tisArea: function isArea() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn this.elt[0].isArea() || this.elt[1].isArea();\n\t\t} else if (arguments.length === 1) {\n\t\t\tvar geomIndex = arguments[0];\n\t\t\treturn this.elt[geomIndex].isArea();\n\t\t}\n\t},\n\tisAnyNull: function isAnyNull(geomIndex) {\n\t\treturn this.elt[geomIndex].isAnyNull();\n\t},\n\tsetLocation: function setLocation() {\n\t\tif (arguments.length === 2) {\n\t\t\tvar geomIndex = arguments[0],\n\t\t\t    location = arguments[1];\n\t\t\tthis.elt[geomIndex].setLocation(Position.ON, location);\n\t\t} else if (arguments.length === 3) {\n\t\t\tvar geomIndex = arguments[0],\n\t\t\t    posIndex = arguments[1],\n\t\t\t    location = arguments[2];\n\t\t\tthis.elt[geomIndex].setLocation(posIndex, location);\n\t\t}\n\t},\n\tisEqualOnSide: function isEqualOnSide(lbl, side) {\n\t\treturn this.elt[0].isEqualOnSide(lbl.elt[0], side) && this.elt[1].isEqualOnSide(lbl.elt[1], side);\n\t},\n\tallPositionsEqual: function allPositionsEqual(geomIndex, loc) {\n\t\treturn this.elt[geomIndex].allPositionsEqual(loc);\n\t},\n\ttoLine: function toLine(geomIndex) {\n\t\tif (this.elt[geomIndex].isArea()) this.elt[geomIndex] = new TopologyLocation(this.elt[geomIndex].location[0]);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Label;\n\t}\n});\nLabel.toLineLabel = function (label) {\n\tvar lineLabel = new Label(Location.NONE);\n\tfor (var i = 0; i < 2; i++) {\n\t\tlineLabel.setLocation(i, label.getLocation(i));\n\t}\n\treturn lineLabel;\n};\n\nfunction EdgeRing() {\n\tthis._startDe = null;\n\tthis._maxNodeDegree = -1;\n\tthis._edges = new ArrayList();\n\tthis._pts = new ArrayList();\n\tthis._label = new Label(Location.NONE);\n\tthis._ring = null;\n\tthis._isHole = null;\n\tthis._shell = null;\n\tthis._holes = new ArrayList();\n\tthis._geometryFactory = null;\n\tvar start = arguments[0],\n\t    geometryFactory = arguments[1];\n\tthis._geometryFactory = geometryFactory;\n\tthis.computePoints(start);\n\tthis.computeRing();\n}\nextend(EdgeRing.prototype, {\n\tcomputeRing: function computeRing() {\n\t\tif (this._ring !== null) return null;\n\t\tvar coord = new Array(this._pts.size()).fill(null);\n\t\tfor (var i = 0; i < this._pts.size(); i++) {\n\t\t\tcoord[i] = this._pts.get(i);\n\t\t}\n\t\tthis._ring = this._geometryFactory.createLinearRing(coord);\n\t\tthis._isHole = CGAlgorithms.isCCW(this._ring.getCoordinates());\n\t},\n\tisIsolated: function isIsolated() {\n\t\treturn this._label.getGeometryCount() === 1;\n\t},\n\tcomputePoints: function computePoints(start) {\n\t\tthis._startDe = start;\n\t\tvar de = start;\n\t\tvar isFirstEdge = true;\n\t\tdo {\n\t\t\tif (de === null) throw new TopologyException(\"Found null DirectedEdge\");\n\t\t\tif (de.getEdgeRing() === this) throw new TopologyException(\"Directed Edge visited twice during ring-building at \" + de.getCoordinate());\n\t\t\tthis._edges.add(de);\n\t\t\tvar label = de.getLabel();\n\t\t\tAssert.isTrue(label.isArea());\n\t\t\tthis.mergeLabel(label);\n\t\t\tthis.addPoints(de.getEdge(), de.isForward(), isFirstEdge);\n\t\t\tisFirstEdge = false;\n\t\t\tthis.setEdgeRing(de, this);\n\t\t\tde = this.getNext(de);\n\t\t} while (de !== this._startDe);\n\t},\n\tgetLinearRing: function getLinearRing() {\n\t\treturn this._ring;\n\t},\n\tgetCoordinate: function getCoordinate(i) {\n\t\treturn this._pts.get(i);\n\t},\n\tcomputeMaxNodeDegree: function computeMaxNodeDegree() {\n\t\tthis._maxNodeDegree = 0;\n\t\tvar de = this._startDe;\n\t\tdo {\n\t\t\tvar node = de.getNode();\n\t\t\tvar degree = node.getEdges().getOutgoingDegree(this);\n\t\t\tif (degree > this._maxNodeDegree) this._maxNodeDegree = degree;\n\t\t\tde = this.getNext(de);\n\t\t} while (de !== this._startDe);\n\t\tthis._maxNodeDegree *= 2;\n\t},\n\taddPoints: function addPoints(edge, isForward, isFirstEdge) {\n\t\tvar edgePts = edge.getCoordinates();\n\t\tif (isForward) {\n\t\t\tvar startIndex = 1;\n\t\t\tif (isFirstEdge) startIndex = 0;\n\t\t\tfor (var i = startIndex; i < edgePts.length; i++) {\n\t\t\t\tthis._pts.add(edgePts[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tvar startIndex = edgePts.length - 2;\n\t\t\tif (isFirstEdge) startIndex = edgePts.length - 1;\n\t\t\tfor (var i = startIndex; i >= 0; i--) {\n\t\t\t\tthis._pts.add(edgePts[i]);\n\t\t\t}\n\t\t}\n\t},\n\tisHole: function isHole() {\n\t\treturn this._isHole;\n\t},\n\tsetInResult: function setInResult() {\n\t\tvar de = this._startDe;\n\t\tdo {\n\t\t\tde.getEdge().setInResult(true);\n\t\t\tde = de.getNext();\n\t\t} while (de !== this._startDe);\n\t},\n\tcontainsPoint: function containsPoint(p) {\n\t\tvar shell = this.getLinearRing();\n\t\tvar env = shell.getEnvelopeInternal();\n\t\tif (!env.contains(p)) return false;\n\t\tif (!CGAlgorithms.isPointInRing(p, shell.getCoordinates())) return false;\n\t\tfor (var i = this._holes.iterator(); i.hasNext();) {\n\t\t\tvar hole = i.next();\n\t\t\tif (hole.containsPoint(p)) return false;\n\t\t}\n\t\treturn true;\n\t},\n\taddHole: function addHole(ring) {\n\t\tthis._holes.add(ring);\n\t},\n\tisShell: function isShell() {\n\t\treturn this._shell === null;\n\t},\n\tgetLabel: function getLabel() {\n\t\treturn this._label;\n\t},\n\tgetEdges: function getEdges() {\n\t\treturn this._edges;\n\t},\n\tgetMaxNodeDegree: function getMaxNodeDegree() {\n\t\tif (this._maxNodeDegree < 0) this.computeMaxNodeDegree();\n\t\treturn this._maxNodeDegree;\n\t},\n\tgetShell: function getShell() {\n\t\treturn this._shell;\n\t},\n\tmergeLabel: function mergeLabel() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar deLabel = arguments[0];\n\t\t\tthis.mergeLabel(deLabel, 0);\n\t\t\tthis.mergeLabel(deLabel, 1);\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar deLabel = arguments[0],\n\t\t\t    geomIndex = arguments[1];\n\t\t\tvar loc = deLabel.getLocation(geomIndex, Position.RIGHT);\n\t\t\tif (loc === Location.NONE) return null;\n\t\t\tif (this._label.getLocation(geomIndex) === Location.NONE) {\n\t\t\t\tthis._label.setLocation(geomIndex, loc);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t},\n\tsetShell: function setShell(shell) {\n\t\tthis._shell = shell;\n\t\tif (shell !== null) shell.addHole(this);\n\t},\n\ttoPolygon: function toPolygon(geometryFactory) {\n\t\tvar holeLR = new Array(this._holes.size()).fill(null);\n\t\tfor (var i = 0; i < this._holes.size(); i++) {\n\t\t\tholeLR[i] = this._holes.get(i).getLinearRing();\n\t\t}\n\t\tvar poly = geometryFactory.createPolygon(this.getLinearRing(), holeLR);\n\t\treturn poly;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn EdgeRing;\n\t}\n});\n\nfunction MinimalEdgeRing() {\n\tvar start = arguments[0],\n\t    geometryFactory = arguments[1];\n\tEdgeRing.call(this, start, geometryFactory);\n}\ninherits$1(MinimalEdgeRing, EdgeRing);\nextend(MinimalEdgeRing.prototype, {\n\tsetEdgeRing: function setEdgeRing(de, er) {\n\t\tde.setMinEdgeRing(er);\n\t},\n\tgetNext: function getNext(de) {\n\t\treturn de.getNextMin();\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn MinimalEdgeRing;\n\t}\n});\n\nfunction MaximalEdgeRing() {\n\tvar start = arguments[0],\n\t    geometryFactory = arguments[1];\n\tEdgeRing.call(this, start, geometryFactory);\n}\ninherits$1(MaximalEdgeRing, EdgeRing);\nextend(MaximalEdgeRing.prototype, {\n\tbuildMinimalRings: function buildMinimalRings() {\n\t\tvar minEdgeRings = new ArrayList();\n\t\tvar de = this._startDe;\n\t\tdo {\n\t\t\tif (de.getMinEdgeRing() === null) {\n\t\t\t\tvar minEr = new MinimalEdgeRing(de, this._geometryFactory);\n\t\t\t\tminEdgeRings.add(minEr);\n\t\t\t}\n\t\t\tde = de.getNext();\n\t\t} while (de !== this._startDe);\n\t\treturn minEdgeRings;\n\t},\n\tsetEdgeRing: function setEdgeRing(de, er) {\n\t\tde.setEdgeRing(er);\n\t},\n\tlinkDirectedEdgesForMinimalEdgeRings: function linkDirectedEdgesForMinimalEdgeRings() {\n\t\tvar de = this._startDe;\n\t\tdo {\n\t\t\tvar node = de.getNode();\n\t\t\tnode.getEdges().linkMinimalDirectedEdges(this);\n\t\t\tde = de.getNext();\n\t\t} while (de !== this._startDe);\n\t},\n\tgetNext: function getNext(de) {\n\t\treturn de.getNext();\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn MaximalEdgeRing;\n\t}\n});\n\nfunction GraphComponent() {\n\tthis._label = null;\n\tthis._isInResult = false;\n\tthis._isCovered = false;\n\tthis._isCoveredSet = false;\n\tthis._isVisited = false;\n\tif (arguments.length === 0) {} else if (arguments.length === 1) {\n\t\tvar label = arguments[0];\n\t\tthis._label = label;\n\t}\n}\nextend(GraphComponent.prototype, {\n\tsetVisited: function setVisited(isVisited) {\n\t\tthis._isVisited = isVisited;\n\t},\n\tsetInResult: function setInResult(isInResult) {\n\t\tthis._isInResult = isInResult;\n\t},\n\tisCovered: function isCovered() {\n\t\treturn this._isCovered;\n\t},\n\tisCoveredSet: function isCoveredSet() {\n\t\treturn this._isCoveredSet;\n\t},\n\tsetLabel: function setLabel(label) {\n\t\tthis._label = label;\n\t},\n\tgetLabel: function getLabel() {\n\t\treturn this._label;\n\t},\n\tsetCovered: function setCovered(isCovered) {\n\t\tthis._isCovered = isCovered;\n\t\tthis._isCoveredSet = true;\n\t},\n\tupdateIM: function updateIM(im) {\n\t\tAssert.isTrue(this._label.getGeometryCount() >= 2, \"found partial label\");\n\t\tthis.computeIM(im);\n\t},\n\tisInResult: function isInResult() {\n\t\treturn this._isInResult;\n\t},\n\tisVisited: function isVisited() {\n\t\treturn this._isVisited;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn GraphComponent;\n\t}\n});\n\nfunction Node() {\n\tGraphComponent.apply(this);\n\tthis._coord = null;\n\tthis._edges = null;\n\tvar coord = arguments[0],\n\t    edges = arguments[1];\n\tthis._coord = coord;\n\tthis._edges = edges;\n\tthis._label = new Label(0, Location.NONE);\n}\ninherits$1(Node, GraphComponent);\nextend(Node.prototype, {\n\tisIncidentEdgeInResult: function isIncidentEdgeInResult() {\n\t\tfor (var it = this.getEdges().getEdges().iterator(); it.hasNext();) {\n\t\t\tvar de = it.next();\n\t\t\tif (de.getEdge().isInResult()) return true;\n\t\t}\n\t\treturn false;\n\t},\n\tisIsolated: function isIsolated() {\n\t\treturn this._label.getGeometryCount() === 1;\n\t},\n\tgetCoordinate: function getCoordinate() {\n\t\treturn this._coord;\n\t},\n\tprint: function print(out) {\n\t\tout.println(\"node \" + this._coord + \" lbl: \" + this._label);\n\t},\n\tcomputeIM: function computeIM(im) {},\n\tcomputeMergedLocation: function computeMergedLocation(label2, eltIndex) {\n\t\tvar loc = Location.NONE;\n\t\tloc = this._label.getLocation(eltIndex);\n\t\tif (!label2.isNull(eltIndex)) {\n\t\t\tvar nLoc = label2.getLocation(eltIndex);\n\t\t\tif (loc !== Location.BOUNDARY) loc = nLoc;\n\t\t}\n\t\treturn loc;\n\t},\n\tsetLabel: function setLabel() {\n\t\tif (arguments.length === 2) {\n\t\t\tvar argIndex = arguments[0],\n\t\t\t    onLocation = arguments[1];\n\t\t\tif (this._label === null) {\n\t\t\t\tthis._label = new Label(argIndex, onLocation);\n\t\t\t} else this._label.setLocation(argIndex, onLocation);\n\t\t} else return GraphComponent.prototype.setLabel.apply(this, arguments);\n\t},\n\tgetEdges: function getEdges() {\n\t\treturn this._edges;\n\t},\n\tmergeLabel: function mergeLabel() {\n\t\tif (arguments[0] instanceof Node) {\n\t\t\tvar n = arguments[0];\n\t\t\tthis.mergeLabel(n._label);\n\t\t} else if (arguments[0] instanceof Label) {\n\t\t\tvar label2 = arguments[0];\n\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\tvar loc = this.computeMergedLocation(label2, i);\n\t\t\t\tvar thisLoc = this._label.getLocation(i);\n\t\t\t\tif (thisLoc === Location.NONE) this._label.setLocation(i, loc);\n\t\t\t}\n\t\t}\n\t},\n\tadd: function add(e) {\n\t\tthis._edges.insert(e);\n\t\te.setNode(this);\n\t},\n\tsetLabelBoundary: function setLabelBoundary(argIndex) {\n\t\tif (this._label === null) return null;\n\t\tvar loc = Location.NONE;\n\t\tif (this._label !== null) loc = this._label.getLocation(argIndex);\n\t\tvar newLoc = null;\n\t\tswitch (loc) {\n\t\t\tcase Location.BOUNDARY:\n\t\t\t\tnewLoc = Location.INTERIOR;\n\t\t\t\tbreak;\n\t\t\tcase Location.INTERIOR:\n\t\t\t\tnewLoc = Location.BOUNDARY;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tnewLoc = Location.BOUNDARY;\n\t\t\t\tbreak;\n\t\t}\n\t\tthis._label.setLocation(argIndex, newLoc);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Node;\n\t}\n});\n\nfunction NodeMap() {\n\tthis.nodeMap = new TreeMap();\n\tthis.nodeFact = null;\n\tvar nodeFact = arguments[0];\n\tthis.nodeFact = nodeFact;\n}\nextend(NodeMap.prototype, {\n\tfind: function find(coord) {\n\t\treturn this.nodeMap.get(coord);\n\t},\n\taddNode: function addNode() {\n\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\tvar coord = arguments[0];\n\t\t\tvar node = this.nodeMap.get(coord);\n\t\t\tif (node === null) {\n\t\t\t\tnode = this.nodeFact.createNode(coord);\n\t\t\t\tthis.nodeMap.put(coord, node);\n\t\t\t}\n\t\t\treturn node;\n\t\t} else if (arguments[0] instanceof Node) {\n\t\t\tvar n = arguments[0];\n\t\t\tvar node = this.nodeMap.get(n.getCoordinate());\n\t\t\tif (node === null) {\n\t\t\t\tthis.nodeMap.put(n.getCoordinate(), n);\n\t\t\t\treturn n;\n\t\t\t}\n\t\t\tnode.mergeLabel(n);\n\t\t\treturn node;\n\t\t}\n\t},\n\tprint: function print(out) {\n\t\tfor (var it = this.iterator(); it.hasNext();) {\n\t\t\tvar n = it.next();\n\t\t\tn.print(out);\n\t\t}\n\t},\n\titerator: function iterator() {\n\t\treturn this.nodeMap.values().iterator();\n\t},\n\tvalues: function values() {\n\t\treturn this.nodeMap.values();\n\t},\n\tgetBoundaryNodes: function getBoundaryNodes(geomIndex) {\n\t\tvar bdyNodes = new ArrayList();\n\t\tfor (var i = this.iterator(); i.hasNext();) {\n\t\t\tvar node = i.next();\n\t\t\tif (node.getLabel().getLocation(geomIndex) === Location.BOUNDARY) bdyNodes.add(node);\n\t\t}\n\t\treturn bdyNodes;\n\t},\n\tadd: function add(e) {\n\t\tvar p = e.getCoordinate();\n\t\tvar n = this.addNode(p);\n\t\tn.add(e);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn NodeMap;\n\t}\n});\n\nfunction EdgeEnd() {\n\tthis._edge = null;\n\tthis._label = null;\n\tthis._node = null;\n\tthis._p0 = null;\n\tthis._p1 = null;\n\tthis._dx = null;\n\tthis._dy = null;\n\tthis._quadrant = null;\n\tif (arguments.length === 1) {\n\t\tvar edge = arguments[0];\n\t\tthis._edge = edge;\n\t} else if (arguments.length === 3) {\n\t\tvar edge = arguments[0],\n\t\t    p0 = arguments[1],\n\t\t    p1 = arguments[2];\n\t\tEdgeEnd.call(this, edge, p0, p1, null);\n\t} else if (arguments.length === 4) {\n\t\tvar edge = arguments[0],\n\t\t    p0 = arguments[1],\n\t\t    p1 = arguments[2],\n\t\t    label = arguments[3];\n\t\tEdgeEnd.call(this, edge);\n\t\tthis.init(p0, p1);\n\t\tthis._label = label;\n\t}\n}\nextend(EdgeEnd.prototype, {\n\tcompareDirection: function compareDirection(e) {\n\t\tif (this._dx === e._dx && this._dy === e._dy) return 0;\n\t\tif (this._quadrant > e._quadrant) return 1;\n\t\tif (this._quadrant < e._quadrant) return -1;\n\t\treturn CGAlgorithms.computeOrientation(e._p0, e._p1, this._p1);\n\t},\n\tgetDy: function getDy() {\n\t\treturn this._dy;\n\t},\n\tgetCoordinate: function getCoordinate() {\n\t\treturn this._p0;\n\t},\n\tsetNode: function setNode(node) {\n\t\tthis._node = node;\n\t},\n\tprint: function print(out) {\n\t\tvar angle = Math.atan2(this._dy, this._dx);\n\t\tvar className = this.getClass().getName();\n\t\tvar lastDotPos = className.lastIndexOf('.');\n\t\tvar name = className.substring(lastDotPos + 1);\n\t\tout.print(\"  \" + name + \": \" + this._p0 + \" - \" + this._p1 + \" \" + this._quadrant + \":\" + angle + \"   \" + this._label);\n\t},\n\tcompareTo: function compareTo(obj) {\n\t\tvar e = obj;\n\t\treturn this.compareDirection(e);\n\t},\n\tgetDirectedCoordinate: function getDirectedCoordinate() {\n\t\treturn this._p1;\n\t},\n\tgetDx: function getDx() {\n\t\treturn this._dx;\n\t},\n\tgetLabel: function getLabel() {\n\t\treturn this._label;\n\t},\n\tgetEdge: function getEdge() {\n\t\treturn this._edge;\n\t},\n\tgetQuadrant: function getQuadrant() {\n\t\treturn this._quadrant;\n\t},\n\tgetNode: function getNode() {\n\t\treturn this._node;\n\t},\n\ttoString: function toString() {\n\t\tvar angle = Math.atan2(this._dy, this._dx);\n\t\tvar className = this.getClass().getName();\n\t\tvar lastDotPos = className.lastIndexOf('.');\n\t\tvar name = className.substring(lastDotPos + 1);\n\t\treturn \"  \" + name + \": \" + this._p0 + \" - \" + this._p1 + \" \" + this._quadrant + \":\" + angle + \"   \" + this._label;\n\t},\n\tcomputeLabel: function computeLabel(boundaryNodeRule) {},\n\tinit: function init(p0, p1) {\n\t\tthis._p0 = p0;\n\t\tthis._p1 = p1;\n\t\tthis._dx = p1.x - p0.x;\n\t\tthis._dy = p1.y - p0.y;\n\t\tthis._quadrant = Quadrant.quadrant(this._dx, this._dy);\n\t\tAssert.isTrue(!(this._dx === 0 && this._dy === 0), \"EdgeEnd with identical endpoints found\");\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Comparable];\n\t},\n\tgetClass: function getClass() {\n\t\treturn EdgeEnd;\n\t}\n});\n\nfunction DirectedEdge() {\n\tthis._isForward = null;\n\tthis._isInResult = false;\n\tthis._isVisited = false;\n\tthis._sym = null;\n\tthis._next = null;\n\tthis._nextMin = null;\n\tthis._edgeRing = null;\n\tthis._minEdgeRing = null;\n\tthis._depth = [0, -999, -999];\n\tvar edge = arguments[0],\n\t    isForward = arguments[1];\n\tEdgeEnd.call(this, edge);\n\tthis._isForward = isForward;\n\tif (isForward) {\n\t\tthis.init(edge.getCoordinate(0), edge.getCoordinate(1));\n\t} else {\n\t\tvar n = edge.getNumPoints() - 1;\n\t\tthis.init(edge.getCoordinate(n), edge.getCoordinate(n - 1));\n\t}\n\tthis.computeDirectedLabel();\n}\ninherits$1(DirectedEdge, EdgeEnd);\nextend(DirectedEdge.prototype, {\n\tgetNextMin: function getNextMin() {\n\t\treturn this._nextMin;\n\t},\n\tgetDepth: function getDepth(position) {\n\t\treturn this._depth[position];\n\t},\n\tsetVisited: function setVisited(isVisited) {\n\t\tthis._isVisited = isVisited;\n\t},\n\tcomputeDirectedLabel: function computeDirectedLabel() {\n\t\tthis._label = new Label(this._edge.getLabel());\n\t\tif (!this._isForward) this._label.flip();\n\t},\n\tgetNext: function getNext() {\n\t\treturn this._next;\n\t},\n\tsetDepth: function setDepth(position, depthVal) {\n\t\tif (this._depth[position] !== -999) {\n\t\t\tif (this._depth[position] !== depthVal) throw new TopologyException(\"assigned depths do not match\", this.getCoordinate());\n\t\t}\n\t\tthis._depth[position] = depthVal;\n\t},\n\tisInteriorAreaEdge: function isInteriorAreaEdge() {\n\t\tvar isInteriorAreaEdge = true;\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tif (!(this._label.isArea(i) && this._label.getLocation(i, Position.LEFT) === Location.INTERIOR && this._label.getLocation(i, Position.RIGHT) === Location.INTERIOR)) {\n\t\t\t\tisInteriorAreaEdge = false;\n\t\t\t}\n\t\t}\n\t\treturn isInteriorAreaEdge;\n\t},\n\tsetNextMin: function setNextMin(nextMin) {\n\t\tthis._nextMin = nextMin;\n\t},\n\tprint: function print(out) {\n\t\tEdgeEnd.prototype.print.call(this, out);\n\t\tout.print(\" \" + this._depth[Position.LEFT] + \"/\" + this._depth[Position.RIGHT]);\n\t\tout.print(\" (\" + this.getDepthDelta() + \")\");\n\t\tif (this._isInResult) out.print(\" inResult\");\n\t},\n\tsetMinEdgeRing: function setMinEdgeRing(minEdgeRing) {\n\t\tthis._minEdgeRing = minEdgeRing;\n\t},\n\tisLineEdge: function isLineEdge() {\n\t\tvar isLine = this._label.isLine(0) || this._label.isLine(1);\n\t\tvar isExteriorIfArea0 = !this._label.isArea(0) || this._label.allPositionsEqual(0, Location.EXTERIOR);\n\t\tvar isExteriorIfArea1 = !this._label.isArea(1) || this._label.allPositionsEqual(1, Location.EXTERIOR);\n\t\treturn isLine && isExteriorIfArea0 && isExteriorIfArea1;\n\t},\n\tsetEdgeRing: function setEdgeRing(edgeRing) {\n\t\tthis._edgeRing = edgeRing;\n\t},\n\tgetMinEdgeRing: function getMinEdgeRing() {\n\t\treturn this._minEdgeRing;\n\t},\n\tgetDepthDelta: function getDepthDelta() {\n\t\tvar depthDelta = this._edge.getDepthDelta();\n\t\tif (!this._isForward) depthDelta = -depthDelta;\n\t\treturn depthDelta;\n\t},\n\tsetInResult: function setInResult(isInResult) {\n\t\tthis._isInResult = isInResult;\n\t},\n\tgetSym: function getSym() {\n\t\treturn this._sym;\n\t},\n\tisForward: function isForward() {\n\t\treturn this._isForward;\n\t},\n\tgetEdge: function getEdge() {\n\t\treturn this._edge;\n\t},\n\tprintEdge: function printEdge(out) {\n\t\tthis.print(out);\n\t\tout.print(\" \");\n\t\tif (this._isForward) this._edge.print(out);else this._edge.printReverse(out);\n\t},\n\tsetSym: function setSym(de) {\n\t\tthis._sym = de;\n\t},\n\tsetVisitedEdge: function setVisitedEdge(isVisited) {\n\t\tthis.setVisited(isVisited);\n\t\tthis._sym.setVisited(isVisited);\n\t},\n\tsetEdgeDepths: function setEdgeDepths(position, depth) {\n\t\tvar depthDelta = this.getEdge().getDepthDelta();\n\t\tif (!this._isForward) depthDelta = -depthDelta;\n\t\tvar directionFactor = 1;\n\t\tif (position === Position.LEFT) directionFactor = -1;\n\t\tvar oppositePos = Position.opposite(position);\n\t\tvar delta = depthDelta * directionFactor;\n\t\tvar oppositeDepth = depth + delta;\n\t\tthis.setDepth(position, depth);\n\t\tthis.setDepth(oppositePos, oppositeDepth);\n\t},\n\tgetEdgeRing: function getEdgeRing() {\n\t\treturn this._edgeRing;\n\t},\n\tisInResult: function isInResult() {\n\t\treturn this._isInResult;\n\t},\n\tsetNext: function setNext(next) {\n\t\tthis._next = next;\n\t},\n\tisVisited: function isVisited() {\n\t\treturn this._isVisited;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn DirectedEdge;\n\t}\n});\nDirectedEdge.depthFactor = function (currLocation, nextLocation) {\n\tif (currLocation === Location.EXTERIOR && nextLocation === Location.INTERIOR) return 1;else if (currLocation === Location.INTERIOR && nextLocation === Location.EXTERIOR) return -1;\n\treturn 0;\n};\n\nfunction NodeFactory() {}\nextend(NodeFactory.prototype, {\n\tcreateNode: function createNode(coord) {\n\t\treturn new Node(coord, null);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn NodeFactory;\n\t}\n});\n\nfunction PlanarGraph() {\n\tthis._edges = new ArrayList();\n\tthis._nodes = null;\n\tthis._edgeEndList = new ArrayList();\n\tif (arguments.length === 0) {\n\t\tthis._nodes = new NodeMap(new NodeFactory());\n\t} else if (arguments.length === 1) {\n\t\tvar nodeFact = arguments[0];\n\t\tthis._nodes = new NodeMap(nodeFact);\n\t}\n}\nextend(PlanarGraph.prototype, {\n\tprintEdges: function printEdges(out) {\n\t\tout.println(\"Edges:\");\n\t\tfor (var i = 0; i < this._edges.size(); i++) {\n\t\t\tout.println(\"edge \" + i + \":\");\n\t\t\tvar e = this._edges.get(i);\n\t\t\te.print(out);\n\t\t\te.eiList.print(out);\n\t\t}\n\t},\n\tfind: function find(coord) {\n\t\treturn this._nodes.find(coord);\n\t},\n\taddNode: function addNode() {\n\t\tif (arguments[0] instanceof Node) {\n\t\t\tvar node = arguments[0];\n\t\t\treturn this._nodes.addNode(node);\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tvar coord = arguments[0];\n\t\t\treturn this._nodes.addNode(coord);\n\t\t}\n\t},\n\tgetNodeIterator: function getNodeIterator() {\n\t\treturn this._nodes.iterator();\n\t},\n\tlinkResultDirectedEdges: function linkResultDirectedEdges() {\n\t\tfor (var nodeit = this._nodes.iterator(); nodeit.hasNext();) {\n\t\t\tvar node = nodeit.next();\n\t\t\tnode.getEdges().linkResultDirectedEdges();\n\t\t}\n\t},\n\tdebugPrintln: function debugPrintln(o) {\n\t\tSystem.out.println(o);\n\t},\n\tisBoundaryNode: function isBoundaryNode(geomIndex, coord) {\n\t\tvar node = this._nodes.find(coord);\n\t\tif (node === null) return false;\n\t\tvar label = node.getLabel();\n\t\tif (label !== null && label.getLocation(geomIndex) === Location.BOUNDARY) return true;\n\t\treturn false;\n\t},\n\tlinkAllDirectedEdges: function linkAllDirectedEdges() {\n\t\tfor (var nodeit = this._nodes.iterator(); nodeit.hasNext();) {\n\t\t\tvar node = nodeit.next();\n\t\t\tnode.getEdges().linkAllDirectedEdges();\n\t\t}\n\t},\n\tmatchInSameDirection: function matchInSameDirection(p0, p1, ep0, ep1) {\n\t\tif (!p0.equals(ep0)) return false;\n\t\tif (CGAlgorithms.computeOrientation(p0, p1, ep1) === CGAlgorithms.COLLINEAR && Quadrant.quadrant(p0, p1) === Quadrant.quadrant(ep0, ep1)) return true;\n\t\treturn false;\n\t},\n\tgetEdgeEnds: function getEdgeEnds() {\n\t\treturn this._edgeEndList;\n\t},\n\tdebugPrint: function debugPrint(o) {\n\t\tSystem.out.print(o);\n\t},\n\tgetEdgeIterator: function getEdgeIterator() {\n\t\treturn this._edges.iterator();\n\t},\n\tfindEdgeInSameDirection: function findEdgeInSameDirection(p0, p1) {\n\t\tfor (var i = 0; i < this._edges.size(); i++) {\n\t\t\tvar e = this._edges.get(i);\n\t\t\tvar eCoord = e.getCoordinates();\n\t\t\tif (this.matchInSameDirection(p0, p1, eCoord[0], eCoord[1])) return e;\n\t\t\tif (this.matchInSameDirection(p0, p1, eCoord[eCoord.length - 1], eCoord[eCoord.length - 2])) return e;\n\t\t}\n\t\treturn null;\n\t},\n\tinsertEdge: function insertEdge(e) {\n\t\tthis._edges.add(e);\n\t},\n\tfindEdgeEnd: function findEdgeEnd(e) {\n\t\tfor (var i = this.getEdgeEnds().iterator(); i.hasNext();) {\n\t\t\tvar ee = i.next();\n\t\t\tif (ee.getEdge() === e) return ee;\n\t\t}\n\t\treturn null;\n\t},\n\taddEdges: function addEdges(edgesToAdd) {\n\t\tfor (var it = edgesToAdd.iterator(); it.hasNext();) {\n\t\t\tvar e = it.next();\n\t\t\tthis._edges.add(e);\n\t\t\tvar de1 = new DirectedEdge(e, true);\n\t\t\tvar de2 = new DirectedEdge(e, false);\n\t\t\tde1.setSym(de2);\n\t\t\tde2.setSym(de1);\n\t\t\tthis.add(de1);\n\t\t\tthis.add(de2);\n\t\t}\n\t},\n\tadd: function add(e) {\n\t\tthis._nodes.add(e);\n\t\tthis._edgeEndList.add(e);\n\t},\n\tgetNodes: function getNodes() {\n\t\treturn this._nodes.values();\n\t},\n\tfindEdge: function findEdge(p0, p1) {\n\t\tfor (var i = 0; i < this._edges.size(); i++) {\n\t\t\tvar e = this._edges.get(i);\n\t\t\tvar eCoord = e.getCoordinates();\n\t\t\tif (p0.equals(eCoord[0]) && p1.equals(eCoord[1])) return e;\n\t\t}\n\t\treturn null;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn PlanarGraph;\n\t}\n});\nPlanarGraph.linkResultDirectedEdges = function (nodes) {\n\tfor (var nodeit = nodes.iterator(); nodeit.hasNext();) {\n\t\tvar node = nodeit.next();\n\t\tnode.getEdges().linkResultDirectedEdges();\n\t}\n};\n\nfunction PolygonBuilder() {\n\tthis._geometryFactory = null;\n\tthis._shellList = new ArrayList();\n\tvar geometryFactory = arguments[0];\n\tthis._geometryFactory = geometryFactory;\n}\nextend(PolygonBuilder.prototype, {\n\tsortShellsAndHoles: function sortShellsAndHoles(edgeRings, shellList, freeHoleList) {\n\t\tfor (var it = edgeRings.iterator(); it.hasNext();) {\n\t\t\tvar er = it.next();\n\t\t\tif (er.isHole()) {\n\t\t\t\tfreeHoleList.add(er);\n\t\t\t} else {\n\t\t\t\tshellList.add(er);\n\t\t\t}\n\t\t}\n\t},\n\tcomputePolygons: function computePolygons(shellList) {\n\t\tvar resultPolyList = new ArrayList();\n\t\tfor (var it = shellList.iterator(); it.hasNext();) {\n\t\t\tvar er = it.next();\n\t\t\tvar poly = er.toPolygon(this._geometryFactory);\n\t\t\tresultPolyList.add(poly);\n\t\t}\n\t\treturn resultPolyList;\n\t},\n\tplaceFreeHoles: function placeFreeHoles(shellList, freeHoleList) {\n\t\tfor (var it = freeHoleList.iterator(); it.hasNext();) {\n\t\t\tvar hole = it.next();\n\t\t\tif (hole.getShell() === null) {\n\t\t\t\tvar shell = this.findEdgeRingContaining(hole, shellList);\n\t\t\t\tif (shell === null) throw new TopologyException(\"unable to assign hole to a shell\", hole.getCoordinate(0));\n\t\t\t\thole.setShell(shell);\n\t\t\t}\n\t\t}\n\t},\n\tbuildMinimalEdgeRings: function buildMinimalEdgeRings(maxEdgeRings, shellList, freeHoleList) {\n\t\tvar edgeRings = new ArrayList();\n\t\tfor (var it = maxEdgeRings.iterator(); it.hasNext();) {\n\t\t\tvar er = it.next();\n\t\t\tif (er.getMaxNodeDegree() > 2) {\n\t\t\t\ter.linkDirectedEdgesForMinimalEdgeRings();\n\t\t\t\tvar minEdgeRings = er.buildMinimalRings();\n\t\t\t\tvar shell = this.findShell(minEdgeRings);\n\t\t\t\tif (shell !== null) {\n\t\t\t\t\tthis.placePolygonHoles(shell, minEdgeRings);\n\t\t\t\t\tshellList.add(shell);\n\t\t\t\t} else {\n\t\t\t\t\tfreeHoleList.addAll(minEdgeRings);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tedgeRings.add(er);\n\t\t\t}\n\t\t}\n\t\treturn edgeRings;\n\t},\n\tcontainsPoint: function containsPoint(p) {\n\t\tfor (var it = this._shellList.iterator(); it.hasNext();) {\n\t\t\tvar er = it.next();\n\t\t\tif (er.containsPoint(p)) return true;\n\t\t}\n\t\treturn false;\n\t},\n\tbuildMaximalEdgeRings: function buildMaximalEdgeRings(dirEdges) {\n\t\tvar maxEdgeRings = new ArrayList();\n\t\tfor (var it = dirEdges.iterator(); it.hasNext();) {\n\t\t\tvar de = it.next();\n\t\t\tif (de.isInResult() && de.getLabel().isArea()) {\n\t\t\t\tif (de.getEdgeRing() === null) {\n\t\t\t\t\tvar er = new MaximalEdgeRing(de, this._geometryFactory);\n\t\t\t\t\tmaxEdgeRings.add(er);\n\t\t\t\t\ter.setInResult();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn maxEdgeRings;\n\t},\n\tplacePolygonHoles: function placePolygonHoles(shell, minEdgeRings) {\n\t\tfor (var it = minEdgeRings.iterator(); it.hasNext();) {\n\t\t\tvar er = it.next();\n\t\t\tif (er.isHole()) {\n\t\t\t\ter.setShell(shell);\n\t\t\t}\n\t\t}\n\t},\n\tgetPolygons: function getPolygons() {\n\t\tvar resultPolyList = this.computePolygons(this._shellList);\n\t\treturn resultPolyList;\n\t},\n\tfindEdgeRingContaining: function findEdgeRingContaining(testEr, shellList) {\n\t\tvar testRing = testEr.getLinearRing();\n\t\tvar testEnv = testRing.getEnvelopeInternal();\n\t\tvar testPt = testRing.getCoordinateN(0);\n\t\tvar minShell = null;\n\t\tvar minEnv = null;\n\t\tfor (var it = shellList.iterator(); it.hasNext();) {\n\t\t\tvar tryShell = it.next();\n\t\t\tvar tryRing = tryShell.getLinearRing();\n\t\t\tvar tryEnv = tryRing.getEnvelopeInternal();\n\t\t\tif (minShell !== null) minEnv = minShell.getLinearRing().getEnvelopeInternal();\n\t\t\tvar isContained = false;\n\t\t\tif (tryEnv.contains(testEnv) && CGAlgorithms.isPointInRing(testPt, tryRing.getCoordinates())) isContained = true;\n\t\t\tif (isContained) {\n\t\t\t\tif (minShell === null || minEnv.contains(tryEnv)) {\n\t\t\t\t\tminShell = tryShell;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn minShell;\n\t},\n\tfindShell: function findShell(minEdgeRings) {\n\t\tvar shellCount = 0;\n\t\tvar shell = null;\n\t\tfor (var it = minEdgeRings.iterator(); it.hasNext();) {\n\t\t\tvar er = it.next();\n\t\t\tif (!er.isHole()) {\n\t\t\t\tshell = er;\n\t\t\t\tshellCount++;\n\t\t\t}\n\t\t}\n\t\tAssert.isTrue(shellCount <= 1, \"found two shells in MinimalEdgeRing list\");\n\t\treturn shell;\n\t},\n\tadd: function add() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar graph = arguments[0];\n\t\t\tthis.add(graph.getEdgeEnds(), graph.getNodes());\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar dirEdges = arguments[0],\n\t\t\t    nodes = arguments[1];\n\t\t\tPlanarGraph.linkResultDirectedEdges(nodes);\n\t\t\tvar maxEdgeRings = this.buildMaximalEdgeRings(dirEdges);\n\t\t\tvar freeHoleList = new ArrayList();\n\t\t\tvar edgeRings = this.buildMinimalEdgeRings(maxEdgeRings, this._shellList, freeHoleList);\n\t\t\tthis.sortShellsAndHoles(edgeRings, this._shellList, freeHoleList);\n\t\t\tthis.placeFreeHoles(this._shellList, freeHoleList);\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn PolygonBuilder;\n\t}\n});\n\nfunction LineBuilder() {\n\tthis._op = null;\n\tthis._geometryFactory = null;\n\tthis._ptLocator = null;\n\tthis._lineEdgesList = new ArrayList();\n\tthis._resultLineList = new ArrayList();\n\tvar op = arguments[0],\n\t    geometryFactory = arguments[1],\n\t    ptLocator = arguments[2];\n\tthis._op = op;\n\tthis._geometryFactory = geometryFactory;\n\tthis._ptLocator = ptLocator;\n}\nextend(LineBuilder.prototype, {\n\tcollectLines: function collectLines(opCode) {\n\t\tfor (var it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext();) {\n\t\t\tvar de = it.next();\n\t\t\tthis.collectLineEdge(de, opCode, this._lineEdgesList);\n\t\t\tthis.collectBoundaryTouchEdge(de, opCode, this._lineEdgesList);\n\t\t}\n\t},\n\tlabelIsolatedLine: function labelIsolatedLine(e, targetIndex) {\n\t\tvar loc = this._ptLocator.locate(e.getCoordinate(), this._op.getArgGeometry(targetIndex));\n\t\te.getLabel().setLocation(targetIndex, loc);\n\t},\n\tbuild: function build(opCode) {\n\t\tthis.findCoveredLineEdges();\n\t\tthis.collectLines(opCode);\n\t\tthis.buildLines(opCode);\n\t\treturn this._resultLineList;\n\t},\n\tcollectLineEdge: function collectLineEdge(de, opCode, edges) {\n\t\tvar label = de.getLabel();\n\t\tvar e = de.getEdge();\n\t\tif (de.isLineEdge()) {\n\t\t\tif (!de.isVisited() && OverlayOp.isResultOfOp(label, opCode) && !e.isCovered()) {\n\t\t\t\tedges.add(e);\n\t\t\t\tde.setVisitedEdge(true);\n\t\t\t}\n\t\t}\n\t},\n\tfindCoveredLineEdges: function findCoveredLineEdges() {\n\t\tfor (var nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext();) {\n\t\t\tvar node = nodeit.next();\n\t\t\tnode.getEdges().findCoveredLineEdges();\n\t\t}\n\t\tfor (var it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext();) {\n\t\t\tvar de = it.next();\n\t\t\tvar e = de.getEdge();\n\t\t\tif (de.isLineEdge() && !e.isCoveredSet()) {\n\t\t\t\tvar isCovered = this._op.isCoveredByA(de.getCoordinate());\n\t\t\t\te.setCovered(isCovered);\n\t\t\t}\n\t\t}\n\t},\n\tlabelIsolatedLines: function labelIsolatedLines(edgesList) {\n\t\tfor (var it = edgesList.iterator(); it.hasNext();) {\n\t\t\tvar e = it.next();\n\t\t\tvar label = e.getLabel();\n\t\t\tif (e.isIsolated()) {\n\t\t\t\tif (label.isNull(0)) this.labelIsolatedLine(e, 0);else this.labelIsolatedLine(e, 1);\n\t\t\t}\n\t\t}\n\t},\n\tbuildLines: function buildLines(opCode) {\n\t\tfor (var it = this._lineEdgesList.iterator(); it.hasNext();) {\n\t\t\tvar e = it.next();\n\t\t\tvar label = e.getLabel();\n\t\t\tvar line = this._geometryFactory.createLineString(e.getCoordinates());\n\t\t\tthis._resultLineList.add(line);\n\t\t\te.setInResult(true);\n\t\t}\n\t},\n\tcollectBoundaryTouchEdge: function collectBoundaryTouchEdge(de, opCode, edges) {\n\t\tvar label = de.getLabel();\n\t\tif (de.isLineEdge()) return null;\n\t\tif (de.isVisited()) return null;\n\t\tif (de.isInteriorAreaEdge()) return null;\n\t\tif (de.getEdge().isInResult()) return null;\n\t\tAssert.isTrue(!(de.isInResult() || de.getSym().isInResult()) || !de.getEdge().isInResult());\n\t\tif (OverlayOp.isResultOfOp(label, opCode) && opCode === OverlayOp.INTERSECTION) {\n\t\t\tedges.add(de.getEdge());\n\t\t\tde.setVisitedEdge(true);\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn LineBuilder;\n\t}\n});\n\nfunction PointBuilder() {\n\tthis._op = null;\n\tthis._geometryFactory = null;\n\tthis._resultPointList = new ArrayList();\n\tvar op = arguments[0],\n\t    geometryFactory = arguments[1];\n\tthis._op = op;\n\tthis._geometryFactory = geometryFactory;\n}\nextend(PointBuilder.prototype, {\n\tfilterCoveredNodeToPoint: function filterCoveredNodeToPoint(n) {\n\t\tvar coord = n.getCoordinate();\n\t\tif (!this._op.isCoveredByLA(coord)) {\n\t\t\tvar pt = this._geometryFactory.createPoint(coord);\n\t\t\tthis._resultPointList.add(pt);\n\t\t}\n\t},\n\textractNonCoveredResultNodes: function extractNonCoveredResultNodes(opCode) {\n\t\tfor (var nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext();) {\n\t\t\tvar n = nodeit.next();\n\t\t\tif (n.isInResult()) continue;\n\t\t\tif (n.isIncidentEdgeInResult()) continue;\n\t\t\tif (n.getEdges().getDegree() === 0 || opCode === OverlayOp.INTERSECTION) {\n\t\t\t\tvar label = n.getLabel();\n\t\t\t\tif (OverlayOp.isResultOfOp(label, opCode)) {\n\t\t\t\t\tthis.filterCoveredNodeToPoint(n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tbuild: function build(opCode) {\n\t\tthis.extractNonCoveredResultNodes(opCode);\n\t\treturn this._resultPointList;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn PointBuilder;\n\t}\n});\n\nfunction PointOnGeometryLocator() {}\nextend(PointOnGeometryLocator.prototype, {\n\tlocate: function locate(p) {},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn PointOnGeometryLocator;\n\t}\n});\n\nfunction SimplePointInAreaLocator() {\n\tthis._geom = null;\n\tvar geom = arguments[0];\n\tthis._geom = geom;\n}\nextend(SimplePointInAreaLocator.prototype, {\n\tlocate: function locate(p) {\n\t\treturn SimplePointInAreaLocator.locate(p, this._geom);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [PointOnGeometryLocator];\n\t},\n\tgetClass: function getClass() {\n\t\treturn SimplePointInAreaLocator;\n\t}\n});\nSimplePointInAreaLocator.isPointInRing = function (p, ring) {\n\tif (!ring.getEnvelopeInternal().intersects(p)) return false;\n\treturn CGAlgorithms.isPointInRing(p, ring.getCoordinates());\n};\nSimplePointInAreaLocator.containsPointInPolygon = function (p, poly) {\n\tif (poly.isEmpty()) return false;\n\tvar shell = poly.getExteriorRing();\n\tif (!SimplePointInAreaLocator.isPointInRing(p, shell)) return false;\n\tfor (var i = 0; i < poly.getNumInteriorRing(); i++) {\n\t\tvar hole = poly.getInteriorRingN(i);\n\t\tif (SimplePointInAreaLocator.isPointInRing(p, hole)) return false;\n\t}\n\treturn true;\n};\nSimplePointInAreaLocator.containsPoint = function (p, geom) {\n\tif (geom instanceof Polygon) {\n\t\treturn SimplePointInAreaLocator.containsPointInPolygon(p, geom);\n\t} else if (geom instanceof GeometryCollection) {\n\t\tvar geomi = new GeometryCollectionIterator(geom);\n\t\twhile (geomi.hasNext()) {\n\t\t\tvar g2 = geomi.next();\n\t\t\tif (g2 !== geom) if (SimplePointInAreaLocator.containsPoint(p, g2)) return true;\n\t\t}\n\t}\n\treturn false;\n};\nSimplePointInAreaLocator.locate = function (p, geom) {\n\tif (geom.isEmpty()) return Location.EXTERIOR;\n\tif (SimplePointInAreaLocator.containsPoint(p, geom)) return Location.INTERIOR;\n\treturn Location.EXTERIOR;\n};\n\nfunction EdgeEndStar() {\n\tthis._edgeMap = new TreeMap();\n\tthis._edgeList = null;\n\tthis._ptInAreaLocation = [Location.NONE, Location.NONE];\n}\nextend(EdgeEndStar.prototype, {\n\tgetNextCW: function getNextCW(ee) {\n\t\tthis.getEdges();\n\t\tvar i = this._edgeList.indexOf(ee);\n\t\tvar iNextCW = i - 1;\n\t\tif (i === 0) iNextCW = this._edgeList.size() - 1;\n\t\treturn this._edgeList.get(iNextCW);\n\t},\n\tpropagateSideLabels: function propagateSideLabels(geomIndex) {\n\t\tvar startLoc = Location.NONE;\n\t\tfor (var it = this.iterator(); it.hasNext();) {\n\t\t\tvar e = it.next();\n\t\t\tvar label = e.getLabel();\n\t\t\tif (label.isArea(geomIndex) && label.getLocation(geomIndex, Position.LEFT) !== Location.NONE) startLoc = label.getLocation(geomIndex, Position.LEFT);\n\t\t}\n\t\tif (startLoc === Location.NONE) return null;\n\t\tvar currLoc = startLoc;\n\t\tfor (var it = this.iterator(); it.hasNext();) {\n\t\t\tvar e = it.next();\n\t\t\tvar label = e.getLabel();\n\t\t\tif (label.getLocation(geomIndex, Position.ON) === Location.NONE) label.setLocation(geomIndex, Position.ON, currLoc);\n\t\t\tif (label.isArea(geomIndex)) {\n\t\t\t\tvar leftLoc = label.getLocation(geomIndex, Position.LEFT);\n\t\t\t\tvar rightLoc = label.getLocation(geomIndex, Position.RIGHT);\n\t\t\t\tif (rightLoc !== Location.NONE) {\n\t\t\t\t\tif (rightLoc !== currLoc) throw new TopologyException(\"side location conflict\", e.getCoordinate());\n\t\t\t\t\tif (leftLoc === Location.NONE) {\n\t\t\t\t\t\tAssert.shouldNeverReachHere(\"found single null side (at \" + e.getCoordinate() + \")\");\n\t\t\t\t\t}\n\t\t\t\t\tcurrLoc = leftLoc;\n\t\t\t\t} else {\n\t\t\t\t\tAssert.isTrue(label.getLocation(geomIndex, Position.LEFT) === Location.NONE, \"found single null side\");\n\t\t\t\t\tlabel.setLocation(geomIndex, Position.RIGHT, currLoc);\n\t\t\t\t\tlabel.setLocation(geomIndex, Position.LEFT, currLoc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tgetCoordinate: function getCoordinate() {\n\t\tvar it = this.iterator();\n\t\tif (!it.hasNext()) return null;\n\t\tvar e = it.next();\n\t\treturn e.getCoordinate();\n\t},\n\tprint: function print(out) {\n\t\tSystem.out.println(\"EdgeEndStar:   \" + this.getCoordinate());\n\t\tfor (var it = this.iterator(); it.hasNext();) {\n\t\t\tvar e = it.next();\n\t\t\te.print(out);\n\t\t}\n\t},\n\tisAreaLabelsConsistent: function isAreaLabelsConsistent(geomGraph) {\n\t\tthis.computeEdgeEndLabels(geomGraph.getBoundaryNodeRule());\n\t\treturn this.checkAreaLabelsConsistent(0);\n\t},\n\tcheckAreaLabelsConsistent: function checkAreaLabelsConsistent(geomIndex) {\n\t\tvar edges = this.getEdges();\n\t\tif (edges.size() <= 0) return true;\n\t\tvar lastEdgeIndex = edges.size() - 1;\n\t\tvar startLabel = edges.get(lastEdgeIndex).getLabel();\n\t\tvar startLoc = startLabel.getLocation(geomIndex, Position.LEFT);\n\t\tAssert.isTrue(startLoc !== Location.NONE, \"Found unlabelled area edge\");\n\t\tvar currLoc = startLoc;\n\t\tfor (var it = this.iterator(); it.hasNext();) {\n\t\t\tvar e = it.next();\n\t\t\tvar label = e.getLabel();\n\t\t\tAssert.isTrue(label.isArea(geomIndex), \"Found non-area edge\");\n\t\t\tvar leftLoc = label.getLocation(geomIndex, Position.LEFT);\n\t\t\tvar rightLoc = label.getLocation(geomIndex, Position.RIGHT);\n\t\t\tif (leftLoc === rightLoc) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (rightLoc !== currLoc) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcurrLoc = leftLoc;\n\t\t}\n\t\treturn true;\n\t},\n\tfindIndex: function findIndex(eSearch) {\n\t\tthis.iterator();\n\t\tfor (var i = 0; i < this._edgeList.size(); i++) {\n\t\t\tvar e = this._edgeList.get(i);\n\t\t\tif (e === eSearch) return i;\n\t\t}\n\t\treturn -1;\n\t},\n\titerator: function iterator() {\n\t\treturn this.getEdges().iterator();\n\t},\n\tgetEdges: function getEdges() {\n\t\tif (this._edgeList === null) {\n\t\t\tthis._edgeList = new ArrayList(this._edgeMap.values());\n\t\t}\n\t\treturn this._edgeList;\n\t},\n\tgetLocation: function getLocation(geomIndex, p, geom) {\n\t\tif (this._ptInAreaLocation[geomIndex] === Location.NONE) {\n\t\t\tthis._ptInAreaLocation[geomIndex] = SimplePointInAreaLocator.locate(p, geom[geomIndex].getGeometry());\n\t\t}\n\t\treturn this._ptInAreaLocation[geomIndex];\n\t},\n\ttoString: function toString() {\n\t\tvar buf = new StringBuffer();\n\t\tbuf.append(\"EdgeEndStar:   \" + this.getCoordinate());\n\t\tbuf.append(\"\\n\");\n\t\tfor (var it = this.iterator(); it.hasNext();) {\n\t\t\tvar e = it.next();\n\t\t\tbuf.append(e);\n\t\t\tbuf.append(\"\\n\");\n\t\t}\n\t\treturn buf.toString();\n\t},\n\tcomputeEdgeEndLabels: function computeEdgeEndLabels(boundaryNodeRule) {\n\t\tfor (var it = this.iterator(); it.hasNext();) {\n\t\t\tvar ee = it.next();\n\t\t\tee.computeLabel(boundaryNodeRule);\n\t\t}\n\t},\n\tcomputeLabelling: function computeLabelling(geomGraph) {\n\t\tthis.computeEdgeEndLabels(geomGraph[0].getBoundaryNodeRule());\n\t\tthis.propagateSideLabels(0);\n\t\tthis.propagateSideLabels(1);\n\t\tvar hasDimensionalCollapseEdge = [false, false];\n\t\tfor (var it = this.iterator(); it.hasNext();) {\n\t\t\tvar e = it.next();\n\t\t\tvar label = e.getLabel();\n\t\t\tfor (var geomi = 0; geomi < 2; geomi++) {\n\t\t\t\tif (label.isLine(geomi) && label.getLocation(geomi) === Location.BOUNDARY) hasDimensionalCollapseEdge[geomi] = true;\n\t\t\t}\n\t\t}\n\t\tfor (var it = this.iterator(); it.hasNext();) {\n\t\t\tvar e = it.next();\n\t\t\tvar label = e.getLabel();\n\t\t\tfor (var geomi = 0; geomi < 2; geomi++) {\n\t\t\t\tif (label.isAnyNull(geomi)) {\n\t\t\t\t\tvar loc = Location.NONE;\n\t\t\t\t\tif (hasDimensionalCollapseEdge[geomi]) {\n\t\t\t\t\t\tloc = Location.EXTERIOR;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar p = e.getCoordinate();\n\t\t\t\t\t\tloc = this.getLocation(geomi, p, geomGraph);\n\t\t\t\t\t}\n\t\t\t\t\tlabel.setAllLocationsIfNull(geomi, loc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tgetDegree: function getDegree() {\n\t\treturn this._edgeMap.size();\n\t},\n\tinsertEdgeEnd: function insertEdgeEnd(e, obj) {\n\t\tthis._edgeMap.put(e, obj);\n\t\tthis._edgeList = null;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn EdgeEndStar;\n\t}\n});\n\nfunction DirectedEdgeStar() {\n\tEdgeEndStar.apply(this);\n\tthis._resultAreaEdgeList = null;\n\tthis._label = null;\n\tthis._SCANNING_FOR_INCOMING = 1;\n\tthis._LINKING_TO_OUTGOING = 2;\n}\ninherits$1(DirectedEdgeStar, EdgeEndStar);\nextend(DirectedEdgeStar.prototype, {\n\tlinkResultDirectedEdges: function linkResultDirectedEdges() {\n\t\tthis.getResultAreaEdges();\n\t\tvar firstOut = null;\n\t\tvar incoming = null;\n\t\tvar state = this._SCANNING_FOR_INCOMING;\n\t\tfor (var i = 0; i < this._resultAreaEdgeList.size(); i++) {\n\t\t\tvar nextOut = this._resultAreaEdgeList.get(i);\n\t\t\tvar nextIn = nextOut.getSym();\n\t\t\tif (!nextOut.getLabel().isArea()) continue;\n\t\t\tif (firstOut === null && nextOut.isInResult()) firstOut = nextOut;\n\t\t\tswitch (state) {\n\t\t\t\tcase this._SCANNING_FOR_INCOMING:\n\t\t\t\t\tif (!nextIn.isInResult()) continue;\n\t\t\t\t\tincoming = nextIn;\n\t\t\t\t\tstate = this._LINKING_TO_OUTGOING;\n\t\t\t\t\tbreak;\n\t\t\t\tcase this._LINKING_TO_OUTGOING:\n\t\t\t\t\tif (!nextOut.isInResult()) continue;\n\t\t\t\t\tincoming.setNext(nextOut);\n\t\t\t\t\tstate = this._SCANNING_FOR_INCOMING;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (state === this._LINKING_TO_OUTGOING) {\n\t\t\tif (firstOut === null) throw new TopologyException(\"no outgoing dirEdge found\", this.getCoordinate());\n\t\t\tAssert.isTrue(firstOut.isInResult(), \"unable to link last incoming dirEdge\");\n\t\t\tincoming.setNext(firstOut);\n\t\t}\n\t},\n\tinsert: function insert(ee) {\n\t\tvar de = ee;\n\t\tthis.insertEdgeEnd(de, de);\n\t},\n\tgetRightmostEdge: function getRightmostEdge() {\n\t\tvar edges = this.getEdges();\n\t\tvar size = edges.size();\n\t\tif (size < 1) return null;\n\t\tvar de0 = edges.get(0);\n\t\tif (size === 1) return de0;\n\t\tvar deLast = edges.get(size - 1);\n\t\tvar quad0 = de0.getQuadrant();\n\t\tvar quad1 = deLast.getQuadrant();\n\t\tif (Quadrant.isNorthern(quad0) && Quadrant.isNorthern(quad1)) return de0;else if (!Quadrant.isNorthern(quad0) && !Quadrant.isNorthern(quad1)) return deLast;else {\n\t\t\tif (de0.getDy() !== 0) return de0;else if (deLast.getDy() !== 0) return deLast;\n\t\t}\n\t\tAssert.shouldNeverReachHere(\"found two horizontal edges incident on node\");\n\t\treturn null;\n\t},\n\tprint: function print(out) {\n\t\tSystem.out.println(\"DirectedEdgeStar: \" + this.getCoordinate());\n\t\tfor (var it = this.iterator(); it.hasNext();) {\n\t\t\tvar de = it.next();\n\t\t\tout.print(\"out \");\n\t\t\tde.print(out);\n\t\t\tout.println();\n\t\t\tout.print(\"in \");\n\t\t\tde.getSym().print(out);\n\t\t\tout.println();\n\t\t}\n\t},\n\tgetResultAreaEdges: function getResultAreaEdges() {\n\t\tif (this._resultAreaEdgeList !== null) return this._resultAreaEdgeList;\n\t\tthis._resultAreaEdgeList = new ArrayList();\n\t\tfor (var it = this.iterator(); it.hasNext();) {\n\t\t\tvar de = it.next();\n\t\t\tif (de.isInResult() || de.getSym().isInResult()) this._resultAreaEdgeList.add(de);\n\t\t}\n\t\treturn this._resultAreaEdgeList;\n\t},\n\tupdateLabelling: function updateLabelling(nodeLabel) {\n\t\tfor (var it = this.iterator(); it.hasNext();) {\n\t\t\tvar de = it.next();\n\t\t\tvar label = de.getLabel();\n\t\t\tlabel.setAllLocationsIfNull(0, nodeLabel.getLocation(0));\n\t\t\tlabel.setAllLocationsIfNull(1, nodeLabel.getLocation(1));\n\t\t}\n\t},\n\tlinkAllDirectedEdges: function linkAllDirectedEdges() {\n\t\tthis.getEdges();\n\t\tvar prevOut = null;\n\t\tvar firstIn = null;\n\t\tfor (var i = this._edgeList.size() - 1; i >= 0; i--) {\n\t\t\tvar nextOut = this._edgeList.get(i);\n\t\t\tvar nextIn = nextOut.getSym();\n\t\t\tif (firstIn === null) firstIn = nextIn;\n\t\t\tif (prevOut !== null) nextIn.setNext(prevOut);\n\t\t\tprevOut = nextOut;\n\t\t}\n\t\tfirstIn.setNext(prevOut);\n\t},\n\tcomputeDepths: function computeDepths() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar de = arguments[0];\n\t\t\tvar edgeIndex = this.findIndex(de);\n\t\t\tvar label = de.getLabel();\n\t\t\tvar startDepth = de.getDepth(Position.LEFT);\n\t\t\tvar targetLastDepth = de.getDepth(Position.RIGHT);\n\t\t\tvar nextDepth = this.computeDepths(edgeIndex + 1, this._edgeList.size(), startDepth);\n\t\t\tvar lastDepth = this.computeDepths(0, edgeIndex, nextDepth);\n\t\t\tif (lastDepth !== targetLastDepth) throw new TopologyException(\"depth mismatch at \" + de.getCoordinate());\n\t\t} else if (arguments.length === 3) {\n\t\t\tvar startIndex = arguments[0],\n\t\t\t    endIndex = arguments[1],\n\t\t\t    startDepth = arguments[2];\n\t\t\tvar currDepth = startDepth;\n\t\t\tfor (var i = startIndex; i < endIndex; i++) {\n\t\t\t\tvar nextDe = this._edgeList.get(i);\n\t\t\t\tvar label = nextDe.getLabel();\n\t\t\t\tnextDe.setEdgeDepths(Position.RIGHT, currDepth);\n\t\t\t\tcurrDepth = nextDe.getDepth(Position.LEFT);\n\t\t\t}\n\t\t\treturn currDepth;\n\t\t}\n\t},\n\tmergeSymLabels: function mergeSymLabels() {\n\t\tfor (var it = this.iterator(); it.hasNext();) {\n\t\t\tvar de = it.next();\n\t\t\tvar label = de.getLabel();\n\t\t\tlabel.merge(de.getSym().getLabel());\n\t\t}\n\t},\n\tlinkMinimalDirectedEdges: function linkMinimalDirectedEdges(er) {\n\t\tvar firstOut = null;\n\t\tvar incoming = null;\n\t\tvar state = this._SCANNING_FOR_INCOMING;\n\t\tfor (var i = this._resultAreaEdgeList.size() - 1; i >= 0; i--) {\n\t\t\tvar nextOut = this._resultAreaEdgeList.get(i);\n\t\t\tvar nextIn = nextOut.getSym();\n\t\t\tif (firstOut === null && nextOut.getEdgeRing() === er) firstOut = nextOut;\n\t\t\tswitch (state) {\n\t\t\t\tcase this._SCANNING_FOR_INCOMING:\n\t\t\t\t\tif (nextIn.getEdgeRing() !== er) continue;\n\t\t\t\t\tincoming = nextIn;\n\t\t\t\t\tstate = this._LINKING_TO_OUTGOING;\n\t\t\t\t\tbreak;\n\t\t\t\tcase this._LINKING_TO_OUTGOING:\n\t\t\t\t\tif (nextOut.getEdgeRing() !== er) continue;\n\t\t\t\t\tincoming.setNextMin(nextOut);\n\t\t\t\t\tstate = this._SCANNING_FOR_INCOMING;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (state === this._LINKING_TO_OUTGOING) {\n\t\t\tAssert.isTrue(firstOut !== null, \"found null for first outgoing dirEdge\");\n\t\t\tAssert.isTrue(firstOut.getEdgeRing() === er, \"unable to link last incoming dirEdge\");\n\t\t\tincoming.setNextMin(firstOut);\n\t\t}\n\t},\n\tgetOutgoingDegree: function getOutgoingDegree() {\n\t\tif (arguments.length === 0) {\n\t\t\tvar degree = 0;\n\t\t\tfor (var it = this.iterator(); it.hasNext();) {\n\t\t\t\tvar de = it.next();\n\t\t\t\tif (de.isInResult()) degree++;\n\t\t\t}\n\t\t\treturn degree;\n\t\t} else if (arguments.length === 1) {\n\t\t\tvar er = arguments[0];\n\t\t\tvar degree = 0;\n\t\t\tfor (var it = this.iterator(); it.hasNext();) {\n\t\t\t\tvar de = it.next();\n\t\t\t\tif (de.getEdgeRing() === er) degree++;\n\t\t\t}\n\t\t\treturn degree;\n\t\t}\n\t},\n\tgetLabel: function getLabel() {\n\t\treturn this._label;\n\t},\n\tfindCoveredLineEdges: function findCoveredLineEdges() {\n\t\tvar startLoc = Location.NONE;\n\t\tfor (var it = this.iterator(); it.hasNext();) {\n\t\t\tvar nextOut = it.next();\n\t\t\tvar nextIn = nextOut.getSym();\n\t\t\tif (!nextOut.isLineEdge()) {\n\t\t\t\tif (nextOut.isInResult()) {\n\t\t\t\t\tstartLoc = Location.INTERIOR;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (nextIn.isInResult()) {\n\t\t\t\t\tstartLoc = Location.EXTERIOR;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (startLoc === Location.NONE) return null;\n\t\tvar currLoc = startLoc;\n\t\tfor (var it = this.iterator(); it.hasNext();) {\n\t\t\tvar nextOut = it.next();\n\t\t\tvar nextIn = nextOut.getSym();\n\t\t\tif (nextOut.isLineEdge()) {\n\t\t\t\tnextOut.getEdge().setCovered(currLoc === Location.INTERIOR);\n\t\t\t} else {\n\t\t\t\tif (nextOut.isInResult()) currLoc = Location.EXTERIOR;\n\t\t\t\tif (nextIn.isInResult()) currLoc = Location.INTERIOR;\n\t\t\t}\n\t\t}\n\t},\n\tcomputeLabelling: function computeLabelling(geom) {\n\t\tEdgeEndStar.prototype.computeLabelling.call(this, geom);\n\t\tthis._label = new Label(Location.NONE);\n\t\tfor (var it = this.iterator(); it.hasNext();) {\n\t\t\tvar ee = it.next();\n\t\t\tvar e = ee.getEdge();\n\t\t\tvar eLabel = e.getLabel();\n\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\tvar eLoc = eLabel.getLocation(i);\n\t\t\t\tif (eLoc === Location.INTERIOR || eLoc === Location.BOUNDARY) this._label.setLocation(i, Location.INTERIOR);\n\t\t\t}\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn DirectedEdgeStar;\n\t}\n});\n\nfunction OverlayNodeFactory() {\n\tNodeFactory.apply(this);\n}\ninherits$1(OverlayNodeFactory, NodeFactory);\nextend(OverlayNodeFactory.prototype, {\n\tcreateNode: function createNode(coord) {\n\t\treturn new Node(coord, new DirectedEdgeStar());\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn OverlayNodeFactory;\n\t}\n});\n\nfunction MonotoneChain$1() {\n\tthis.mce = null;\n\tthis.chainIndex = null;\n\tvar mce = arguments[0],\n\t    chainIndex = arguments[1];\n\tthis.mce = mce;\n\tthis.chainIndex = chainIndex;\n}\nextend(MonotoneChain$1.prototype, {\n\tcomputeIntersections: function computeIntersections(mc, si) {\n\t\tthis.mce.computeIntersectsForChain(this.chainIndex, mc.mce, mc.chainIndex, si);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn MonotoneChain$1;\n\t}\n});\n\nfunction SweepLineEvent() {\n\tthis._label = null;\n\tthis._xValue = null;\n\tthis._eventType = null;\n\tthis._insertEvent = null;\n\tthis._deleteEventIndex = null;\n\tthis._obj = null;\n\tif (arguments.length === 2) {\n\t\tvar x = arguments[0],\n\t\t    insertEvent = arguments[1];\n\t\tthis._eventType = SweepLineEvent.DELETE;\n\t\tthis._xValue = x;\n\t\tthis._insertEvent = insertEvent;\n\t} else if (arguments.length === 3) {\n\t\tvar label = arguments[0],\n\t\t    x = arguments[1],\n\t\t    obj = arguments[2];\n\t\tthis._eventType = SweepLineEvent.INSERT;\n\t\tthis._label = label;\n\t\tthis._xValue = x;\n\t\tthis._obj = obj;\n\t}\n}\nextend(SweepLineEvent.prototype, {\n\tisDelete: function isDelete() {\n\t\treturn this._eventType === SweepLineEvent.DELETE;\n\t},\n\tsetDeleteEventIndex: function setDeleteEventIndex(deleteEventIndex) {\n\t\tthis._deleteEventIndex = deleteEventIndex;\n\t},\n\tgetObject: function getObject() {\n\t\treturn this._obj;\n\t},\n\tcompareTo: function compareTo(o) {\n\t\tvar pe = o;\n\t\tif (this._xValue < pe._xValue) return -1;\n\t\tif (this._xValue > pe._xValue) return 1;\n\t\tif (this._eventType < pe._eventType) return -1;\n\t\tif (this._eventType > pe._eventType) return 1;\n\t\treturn 0;\n\t},\n\tgetInsertEvent: function getInsertEvent() {\n\t\treturn this._insertEvent;\n\t},\n\tisInsert: function isInsert() {\n\t\treturn this._eventType === SweepLineEvent.INSERT;\n\t},\n\tisSameLabel: function isSameLabel(ev) {\n\t\tif (this._label === null) return false;\n\t\treturn this._label === ev._label;\n\t},\n\tgetDeleteEventIndex: function getDeleteEventIndex() {\n\t\treturn this._deleteEventIndex;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Comparable];\n\t},\n\tgetClass: function getClass() {\n\t\treturn SweepLineEvent;\n\t}\n});\nSweepLineEvent.INSERT = 1;\nSweepLineEvent.DELETE = 2;\n\nfunction EdgeSetIntersector() {}\nextend(EdgeSetIntersector.prototype, {\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn EdgeSetIntersector;\n\t}\n});\n\nfunction SegmentIntersector$1() {\n\tthis._hasIntersection = false;\n\tthis._hasProper = false;\n\tthis._hasProperInterior = false;\n\tthis._properIntersectionPoint = null;\n\tthis._li = null;\n\tthis._includeProper = null;\n\tthis._recordIsolated = null;\n\tthis._isSelfIntersection = null;\n\tthis._numIntersections = 0;\n\tthis.numTests = 0;\n\tthis._bdyNodes = null;\n\tthis._isDone = false;\n\tthis._isDoneWhenProperInt = false;\n\tvar li = arguments[0],\n\t    includeProper = arguments[1],\n\t    recordIsolated = arguments[2];\n\tthis._li = li;\n\tthis._includeProper = includeProper;\n\tthis._recordIsolated = recordIsolated;\n}\nextend(SegmentIntersector$1.prototype, {\n\tisTrivialIntersection: function isTrivialIntersection(e0, segIndex0, e1, segIndex1) {\n\t\tif (e0 === e1) {\n\t\t\tif (this._li.getIntersectionNum() === 1) {\n\t\t\t\tif (SegmentIntersector$1.isAdjacentSegments(segIndex0, segIndex1)) return true;\n\t\t\t\tif (e0.isClosed()) {\n\t\t\t\t\tvar maxSegIndex = e0.getNumPoints() - 1;\n\t\t\t\t\tif (segIndex0 === 0 && segIndex1 === maxSegIndex || segIndex1 === 0 && segIndex0 === maxSegIndex) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tgetProperIntersectionPoint: function getProperIntersectionPoint() {\n\t\treturn this._properIntersectionPoint;\n\t},\n\tsetIsDoneIfProperInt: function setIsDoneIfProperInt(isDoneWhenProperInt) {\n\t\tthis._isDoneWhenProperInt = isDoneWhenProperInt;\n\t},\n\thasProperInteriorIntersection: function hasProperInteriorIntersection() {\n\t\treturn this._hasProperInterior;\n\t},\n\tisBoundaryPointInternal: function isBoundaryPointInternal(li, bdyNodes) {\n\t\tfor (var i = bdyNodes.iterator(); i.hasNext();) {\n\t\t\tvar node = i.next();\n\t\t\tvar pt = node.getCoordinate();\n\t\t\tif (li.isIntersection(pt)) return true;\n\t\t}\n\t\treturn false;\n\t},\n\thasProperIntersection: function hasProperIntersection() {\n\t\treturn this._hasProper;\n\t},\n\thasIntersection: function hasIntersection() {\n\t\treturn this._hasIntersection;\n\t},\n\tisDone: function isDone() {\n\t\treturn this._isDone;\n\t},\n\tisBoundaryPoint: function isBoundaryPoint(li, bdyNodes) {\n\t\tif (bdyNodes === null) return false;\n\t\tif (this.isBoundaryPointInternal(li, bdyNodes[0])) return true;\n\t\tif (this.isBoundaryPointInternal(li, bdyNodes[1])) return true;\n\t\treturn false;\n\t},\n\tsetBoundaryNodes: function setBoundaryNodes(bdyNodes0, bdyNodes1) {\n\t\tthis._bdyNodes = new Array(2).fill(null);\n\t\tthis._bdyNodes[0] = bdyNodes0;\n\t\tthis._bdyNodes[1] = bdyNodes1;\n\t},\n\taddIntersections: function addIntersections(e0, segIndex0, e1, segIndex1) {\n\t\tif (e0 === e1 && segIndex0 === segIndex1) return null;\n\t\tthis.numTests++;\n\t\tvar p00 = e0.getCoordinates()[segIndex0];\n\t\tvar p01 = e0.getCoordinates()[segIndex0 + 1];\n\t\tvar p10 = e1.getCoordinates()[segIndex1];\n\t\tvar p11 = e1.getCoordinates()[segIndex1 + 1];\n\t\tthis._li.computeIntersection(p00, p01, p10, p11);\n\t\tif (this._li.hasIntersection()) {\n\t\t\tif (this._recordIsolated) {\n\t\t\t\te0.setIsolated(false);\n\t\t\t\te1.setIsolated(false);\n\t\t\t}\n\t\t\tthis._numIntersections++;\n\t\t\tif (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {\n\t\t\t\tthis._hasIntersection = true;\n\t\t\t\tif (this._includeProper || !this._li.isProper()) {\n\t\t\t\t\te0.addIntersections(this._li, segIndex0, 0);\n\t\t\t\t\te1.addIntersections(this._li, segIndex1, 1);\n\t\t\t\t}\n\t\t\t\tif (this._li.isProper()) {\n\t\t\t\t\tthis._properIntersectionPoint = this._li.getIntersection(0).copy();\n\t\t\t\t\tthis._hasProper = true;\n\t\t\t\t\tif (this._isDoneWhenProperInt) {\n\t\t\t\t\t\tthis._isDone = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (!this.isBoundaryPoint(this._li, this._bdyNodes)) this._hasProperInterior = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn SegmentIntersector$1;\n\t}\n});\nSegmentIntersector$1.isAdjacentSegments = function (i1, i2) {\n\treturn Math.abs(i1 - i2) === 1;\n};\n\nfunction SimpleMCSweepLineIntersector() {\n\tEdgeSetIntersector.apply(this);\n\tthis.events = new ArrayList();\n\tthis.nOverlaps = null;\n}\ninherits$1(SimpleMCSweepLineIntersector, EdgeSetIntersector);\nextend(SimpleMCSweepLineIntersector.prototype, {\n\tprepareEvents: function prepareEvents() {\n\t\tCollections.sort(this.events);\n\t\tfor (var i = 0; i < this.events.size(); i++) {\n\t\t\tvar ev = this.events.get(i);\n\t\t\tif (ev.isDelete()) {\n\t\t\t\tev.getInsertEvent().setDeleteEventIndex(i);\n\t\t\t}\n\t\t}\n\t},\n\tcomputeIntersections: function computeIntersections() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar si = arguments[0];\n\t\t\tthis.nOverlaps = 0;\n\t\t\tthis.prepareEvents();\n\t\t\tfor (var i = 0; i < this.events.size(); i++) {\n\t\t\t\tvar ev = this.events.get(i);\n\t\t\t\tif (ev.isInsert()) {\n\t\t\t\t\tthis.processOverlaps(i, ev.getDeleteEventIndex(), ev, si);\n\t\t\t\t}\n\t\t\t\tif (si.isDone()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tif (arguments[2] instanceof SegmentIntersector$1 && hasInterface(arguments[0], List) && hasInterface(arguments[1], List)) {\n\t\t\t\tvar edges0 = arguments[0],\n\t\t\t\t    edges1 = arguments[1],\n\t\t\t\t    si = arguments[2];\n\t\t\t\tthis.addEdges(edges0, edges0);\n\t\t\t\tthis.addEdges(edges1, edges1);\n\t\t\t\tthis.computeIntersections(si);\n\t\t\t} else if (typeof arguments[2] === \"boolean\" && hasInterface(arguments[0], List) && arguments[1] instanceof SegmentIntersector$1) {\n\t\t\t\tvar edges = arguments[0],\n\t\t\t\t    si = arguments[1],\n\t\t\t\t    testAllSegments = arguments[2];\n\t\t\t\tif (testAllSegments) this.addEdges(edges, null);else this.addEdges(edges);\n\t\t\t\tthis.computeIntersections(si);\n\t\t\t}\n\t\t}\n\t},\n\taddEdge: function addEdge(edge, edgeSet) {\n\t\tvar mce = edge.getMonotoneChainEdge();\n\t\tvar startIndex = mce.getStartIndexes();\n\t\tfor (var i = 0; i < startIndex.length - 1; i++) {\n\t\t\tvar mc = new MonotoneChain$1(mce, i);\n\t\t\tvar insertEvent = new SweepLineEvent(edgeSet, mce.getMinX(i), mc);\n\t\t\tthis.events.add(insertEvent);\n\t\t\tthis.events.add(new SweepLineEvent(mce.getMaxX(i), insertEvent));\n\t\t}\n\t},\n\tprocessOverlaps: function processOverlaps(start, end, ev0, si) {\n\t\tvar mc0 = ev0.getObject();\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar ev1 = this.events.get(i);\n\t\t\tif (ev1.isInsert()) {\n\t\t\t\tvar mc1 = ev1.getObject();\n\t\t\t\tif (!ev0.isSameLabel(ev1)) {\n\t\t\t\t\tmc0.computeIntersections(mc1, si);\n\t\t\t\t\tthis.nOverlaps++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\taddEdges: function addEdges() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar edges = arguments[0];\n\t\t\tfor (var i = edges.iterator(); i.hasNext();) {\n\t\t\t\tvar edge = i.next();\n\t\t\t\tthis.addEdge(edge, edge);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar edges = arguments[0],\n\t\t\t    edgeSet = arguments[1];\n\t\t\tfor (var i = edges.iterator(); i.hasNext();) {\n\t\t\t\tvar edge = i.next();\n\t\t\t\tthis.addEdge(edge, edgeSet);\n\t\t\t}\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn SimpleMCSweepLineIntersector;\n\t}\n});\n\nfunction IntervalRTreeNode$1() {\n\tthis._min = Double.POSITIVE_INFINITY;\n\tthis._max = Double.NEGATIVE_INFINITY;\n}\nextend(IntervalRTreeNode$1.prototype, {\n\tgetMin: function getMin() {\n\t\treturn this._min;\n\t},\n\tintersects: function intersects(queryMin, queryMax) {\n\t\tif (this._min > queryMax || this._max < queryMin) return false;\n\t\treturn true;\n\t},\n\tgetMax: function getMax() {\n\t\treturn this._max;\n\t},\n\ttoString: function toString() {\n\t\treturn WKTWriter.toLineString(new Coordinate(this._min, 0), new Coordinate(this._max, 0));\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn IntervalRTreeNode$1;\n\t}\n});\nfunction NodeComparator() {}\nextend(NodeComparator.prototype, {\n\tcompare: function compare(o1, o2) {\n\t\tvar n1 = o1;\n\t\tvar n2 = o2;\n\t\tvar mid1 = (n1._min + n1._max) / 2;\n\t\tvar mid2 = (n2._min + n2._max) / 2;\n\t\tif (mid1 < mid2) return -1;\n\t\tif (mid1 > mid2) return 1;\n\t\treturn 0;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Comparator];\n\t},\n\tgetClass: function getClass() {\n\t\treturn NodeComparator;\n\t}\n});\nIntervalRTreeNode$1.NodeComparator = NodeComparator;\n\nfunction IntervalRTreeLeafNode() {\n\tIntervalRTreeNode$1.apply(this);\n\tthis._item = null;\n\tvar min = arguments[0],\n\t    max = arguments[1],\n\t    item = arguments[2];\n\tthis._min = min;\n\tthis._max = max;\n\tthis._item = item;\n}\ninherits$1(IntervalRTreeLeafNode, IntervalRTreeNode$1);\nextend(IntervalRTreeLeafNode.prototype, {\n\tquery: function query(queryMin, queryMax, visitor) {\n\t\tif (!this.intersects(queryMin, queryMax)) return null;\n\t\tvisitor.visitItem(this._item);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn IntervalRTreeLeafNode;\n\t}\n});\n\nfunction IntervalRTreeBranchNode() {\n\tIntervalRTreeNode$1.apply(this);\n\tthis._node1 = null;\n\tthis._node2 = null;\n\tvar n1 = arguments[0],\n\t    n2 = arguments[1];\n\tthis._node1 = n1;\n\tthis._node2 = n2;\n\tthis.buildExtent(this._node1, this._node2);\n}\ninherits$1(IntervalRTreeBranchNode, IntervalRTreeNode$1);\nextend(IntervalRTreeBranchNode.prototype, {\n\tbuildExtent: function buildExtent(n1, n2) {\n\t\tthis._min = Math.min(n1._min, n2._min);\n\t\tthis._max = Math.max(n1._max, n2._max);\n\t},\n\tquery: function query(queryMin, queryMax, visitor) {\n\t\tif (!this.intersects(queryMin, queryMax)) {\n\t\t\treturn null;\n\t\t}\n\t\tif (this._node1 !== null) this._node1.query(queryMin, queryMax, visitor);\n\t\tif (this._node2 !== null) this._node2.query(queryMin, queryMax, visitor);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn IntervalRTreeBranchNode;\n\t}\n});\n\nfunction SortedPackedIntervalRTree() {\n\tthis._leaves = new ArrayList();\n\tthis._root = null;\n\tthis._level = 0;\n}\nextend(SortedPackedIntervalRTree.prototype, {\n\tbuildTree: function buildTree() {\n\t\tCollections.sort(this._leaves, new IntervalRTreeNode.NodeComparator());\n\t\tvar src = this._leaves;\n\t\tvar temp = null;\n\t\tvar dest = new ArrayList();\n\t\twhile (true) {\n\t\t\tthis.buildLevel(src, dest);\n\t\t\tif (dest.size() === 1) return dest.get(0);\n\t\t\ttemp = src;\n\t\t\tsrc = dest;\n\t\t\tdest = temp;\n\t\t}\n\t},\n\tinsert: function insert(min, max, item) {\n\t\tif (this._root !== null) throw new IllegalStateException(\"Index cannot be added to once it has been queried\");\n\t\tthis._leaves.add(new IntervalRTreeLeafNode(min, max, item));\n\t},\n\tquery: function query(min, max, visitor) {\n\t\tthis.init();\n\t\tthis._root.query(min, max, visitor);\n\t},\n\tbuildRoot: function buildRoot() {\n\t\tif (this._root !== null) return null;\n\t\tthis._root = this.buildTree();\n\t},\n\tprintNode: function printNode(node) {\n\t\tSystem.out.println(WKTWriter.toLineString(new Coordinate(node._min, this._level), new Coordinate(node._max, this._level)));\n\t},\n\tinit: function init() {\n\t\tif (this._root !== null) return null;\n\t\tthis.buildRoot();\n\t},\n\tbuildLevel: function buildLevel(src, dest) {\n\t\tthis._level++;\n\t\tdest.clear();\n\t\tfor (var i = 0; i < src.size(); i += 2) {\n\t\t\tvar n1 = src.get(i);\n\t\t\tvar n2 = i + 1 < src.size() ? src.get(i) : null;\n\t\t\tif (n2 === null) {\n\t\t\t\tdest.add(n1);\n\t\t\t} else {\n\t\t\t\tvar node = new IntervalRTreeBranchNode(src.get(i), src.get(i + 1));\n\t\t\t\tdest.add(node);\n\t\t\t}\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn SortedPackedIntervalRTree;\n\t}\n});\n\nfunction LinearComponentExtracter() {\n\tthis._lines = null;\n\tthis._isForcedToLineString = false;\n\tif (arguments.length === 1) {\n\t\tvar lines = arguments[0];\n\t\tthis._lines = lines;\n\t} else if (arguments.length === 2) {\n\t\tvar lines = arguments[0],\n\t\t    isForcedToLineString = arguments[1];\n\t\tthis._lines = lines;\n\t\tthis._isForcedToLineString = isForcedToLineString;\n\t}\n}\nextend(LinearComponentExtracter.prototype, {\n\tfilter: function filter(geom) {\n\t\tif (this._isForcedToLineString && geom instanceof LinearRing) {\n\t\t\tvar line = geom.getFactory().createLineString(geom.getCoordinateSequence());\n\t\t\tthis._lines.add(line);\n\t\t\treturn null;\n\t\t}\n\t\tif (geom instanceof LineString) this._lines.add(geom);\n\t},\n\tsetForceToLineString: function setForceToLineString(isForcedToLineString) {\n\t\tthis._isForcedToLineString = isForcedToLineString;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [GeometryComponentFilter];\n\t},\n\tgetClass: function getClass() {\n\t\treturn LinearComponentExtracter;\n\t}\n});\nLinearComponentExtracter.getGeometry = function () {\n\tif (arguments.length === 1) {\n\t\tvar geom = arguments[0];\n\t\treturn geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom));\n\t} else if (arguments.length === 2) {\n\t\tvar geom = arguments[0],\n\t\t    forceToLineString = arguments[1];\n\t\treturn geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom, forceToLineString));\n\t}\n};\nLinearComponentExtracter.getLines = function () {\n\tif (arguments.length === 1) {\n\t\tvar geom = arguments[0];\n\t\treturn LinearComponentExtracter.getLines(geom, false);\n\t} else if (arguments.length === 2) {\n\t\tif (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection)) {\n\t\t\tvar geoms = arguments[0],\n\t\t\t    lines = arguments[1];\n\t\t\tfor (var i = geoms.iterator(); i.hasNext();) {\n\t\t\t\tvar g = i.next();\n\t\t\t\tLinearComponentExtracter.getLines(g, lines);\n\t\t\t}\n\t\t\treturn lines;\n\t\t} else if (arguments[0] instanceof Geometry && typeof arguments[1] === \"boolean\") {\n\t\t\tvar geom = arguments[0],\n\t\t\t    forceToLineString = arguments[1];\n\t\t\tvar lines = new ArrayList();\n\t\t\tgeom.apply(new LinearComponentExtracter(lines, forceToLineString));\n\t\t\treturn lines;\n\t\t} else if (arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection)) {\n\t\t\tvar geom = arguments[0],\n\t\t\t    lines = arguments[1];\n\t\t\tif (geom instanceof LineString) {\n\t\t\t\tlines.add(geom);\n\t\t\t} else {\n\t\t\t\tgeom.apply(new LinearComponentExtracter(lines));\n\t\t\t}\n\t\t\treturn lines;\n\t\t}\n\t} else if (arguments.length === 3) {\n\t\tif (typeof arguments[2] === \"boolean\" && hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection)) {\n\t\t\tvar geoms = arguments[0],\n\t\t\t    lines = arguments[1],\n\t\t\t    forceToLineString = arguments[2];\n\t\t\tfor (var i = geoms.iterator(); i.hasNext();) {\n\t\t\t\tvar g = i.next();\n\t\t\t\tLinearComponentExtracter.getLines(g, lines, forceToLineString);\n\t\t\t}\n\t\t\treturn lines;\n\t\t} else if (typeof arguments[2] === \"boolean\" && arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection)) {\n\t\t\tvar geom = arguments[0],\n\t\t\t    lines = arguments[1],\n\t\t\t    forceToLineString = arguments[2];\n\t\t\tgeom.apply(new LinearComponentExtracter(lines, forceToLineString));\n\t\t\treturn lines;\n\t\t}\n\t}\n};\n\nfunction ArrayListVisitor() {\n\tthis._items = new ArrayList();\n}\nextend(ArrayListVisitor.prototype, {\n\tvisitItem: function visitItem(item) {\n\t\tthis._items.add(item);\n\t},\n\tgetItems: function getItems() {\n\t\treturn this._items;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [ItemVisitor];\n\t},\n\tgetClass: function getClass() {\n\t\treturn ArrayListVisitor;\n\t}\n});\n\nfunction IndexedPointInAreaLocator() {\n\tthis._index = null;\n\tvar g = arguments[0];\n\tif (!hasInterface(g, Polygonal)) throw new IllegalArgumentException(\"Argument must be Polygonal\");\n\tthis._index = new IntervalIndexedGeometry(g);\n}\nextend(IndexedPointInAreaLocator.prototype, {\n\tlocate: function locate(p) {\n\t\tvar rcc = new RayCrossingCounter(p);\n\t\tvar visitor = new SegmentVisitor(rcc);\n\t\tthis._index.query(p.y, p.y, visitor);\n\t\treturn rcc.getLocation();\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [PointOnGeometryLocator];\n\t},\n\tgetClass: function getClass() {\n\t\treturn IndexedPointInAreaLocator;\n\t}\n});\nfunction SegmentVisitor() {\n\tthis._counter = null;\n\tvar counter = arguments[0];\n\tthis._counter = counter;\n}\nextend(SegmentVisitor.prototype, {\n\tvisitItem: function visitItem(item) {\n\t\tvar seg = item;\n\t\tthis._counter.countSegment(seg.getCoordinate(0), seg.getCoordinate(1));\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [ItemVisitor];\n\t},\n\tgetClass: function getClass() {\n\t\treturn SegmentVisitor;\n\t}\n});\nfunction IntervalIndexedGeometry() {\n\tthis._index = new SortedPackedIntervalRTree();\n\tvar geom = arguments[0];\n\tthis.init(geom);\n}\nextend(IntervalIndexedGeometry.prototype, {\n\tinit: function init(geom) {\n\t\tvar lines = LinearComponentExtracter.getLines(geom);\n\t\tfor (var i = lines.iterator(); i.hasNext();) {\n\t\t\tvar line = i.next();\n\t\t\tvar pts = line.getCoordinates();\n\t\t\tthis.addLine(pts);\n\t\t}\n\t},\n\taddLine: function addLine(pts) {\n\t\tfor (var i = 1; i < pts.length; i++) {\n\t\t\tvar seg = new LineSegment(pts[i - 1], pts[i]);\n\t\t\tvar min = Math.min(seg.p0.y, seg.p1.y);\n\t\t\tvar max = Math.max(seg.p0.y, seg.p1.y);\n\t\t\tthis._index.insert(min, max, seg);\n\t\t}\n\t},\n\tquery: function query() {\n\t\tif (arguments.length === 2) {\n\t\t\tvar min = arguments[0],\n\t\t\t    max = arguments[1];\n\t\t\tvar visitor = new ArrayListVisitor();\n\t\t\tthis._index.query(min, max, visitor);\n\t\t\treturn visitor.getItems();\n\t\t} else if (arguments.length === 3) {\n\t\t\tvar min = arguments[0],\n\t\t\t    max = arguments[1],\n\t\t\t    visitor = arguments[2];\n\t\t\tthis._index.query(min, max, visitor);\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn IntervalIndexedGeometry;\n\t}\n});\nIndexedPointInAreaLocator.SegmentVisitor = SegmentVisitor;\nIndexedPointInAreaLocator.IntervalIndexedGeometry = IntervalIndexedGeometry;\n\nfunction EdgeIntersection() {\n\tthis.coord = null;\n\tthis.segmentIndex = null;\n\tthis.dist = null;\n\tvar coord = arguments[0],\n\t    segmentIndex = arguments[1],\n\t    dist = arguments[2];\n\tthis.coord = new Coordinate(coord);\n\tthis.segmentIndex = segmentIndex;\n\tthis.dist = dist;\n}\nextend(EdgeIntersection.prototype, {\n\tgetSegmentIndex: function getSegmentIndex() {\n\t\treturn this.segmentIndex;\n\t},\n\tgetCoordinate: function getCoordinate() {\n\t\treturn this.coord;\n\t},\n\tprint: function print(out) {\n\t\tout.print(this.coord);\n\t\tout.print(\" seg # = \" + this.segmentIndex);\n\t\tout.println(\" dist = \" + this.dist);\n\t},\n\tcompareTo: function compareTo(obj) {\n\t\tvar other = obj;\n\t\treturn this.compare(other.segmentIndex, other.dist);\n\t},\n\tisEndPoint: function isEndPoint(maxSegmentIndex) {\n\t\tif (this.segmentIndex === 0 && this.dist === 0.0) return true;\n\t\tif (this.segmentIndex === maxSegmentIndex) return true;\n\t\treturn false;\n\t},\n\ttoString: function toString() {\n\t\treturn this.coord + \" seg # = \" + this.segmentIndex + \" dist = \" + this.dist;\n\t},\n\tgetDistance: function getDistance() {\n\t\treturn this.dist;\n\t},\n\tcompare: function compare(segmentIndex, dist) {\n\t\tif (this.segmentIndex < segmentIndex) return -1;\n\t\tif (this.segmentIndex > segmentIndex) return 1;\n\t\tif (this.dist < dist) return -1;\n\t\tif (this.dist > dist) return 1;\n\t\treturn 0;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Comparable];\n\t},\n\tgetClass: function getClass() {\n\t\treturn EdgeIntersection;\n\t}\n});\n\nfunction EdgeIntersectionList() {\n\tthis._nodeMap = new TreeMap();\n\tthis.edge = null;\n\tvar edge = arguments[0];\n\tthis.edge = edge;\n}\nextend(EdgeIntersectionList.prototype, {\n\tprint: function print(out) {\n\t\tout.println(\"Intersections:\");\n\t\tfor (var it = this.iterator(); it.hasNext();) {\n\t\t\tvar ei = it.next();\n\t\t\tei.print(out);\n\t\t}\n\t},\n\titerator: function iterator() {\n\t\treturn this._nodeMap.values().iterator();\n\t},\n\taddSplitEdges: function addSplitEdges(edgeList) {\n\t\tthis.addEndpoints();\n\t\tvar it = this.iterator();\n\t\tvar eiPrev = it.next();\n\t\twhile (it.hasNext()) {\n\t\t\tvar ei = it.next();\n\t\t\tvar newEdge = this.createSplitEdge(eiPrev, ei);\n\t\t\tedgeList.add(newEdge);\n\t\t\teiPrev = ei;\n\t\t}\n\t},\n\taddEndpoints: function addEndpoints() {\n\t\tvar maxSegIndex = this.edge.pts.length - 1;\n\t\tthis.add(this.edge.pts[0], 0, 0.0);\n\t\tthis.add(this.edge.pts[maxSegIndex], maxSegIndex, 0.0);\n\t},\n\tcreateSplitEdge: function createSplitEdge(ei0, ei1) {\n\t\tvar npts = ei1.segmentIndex - ei0.segmentIndex + 2;\n\t\tvar lastSegStartPt = this.edge.pts[ei1.segmentIndex];\n\t\tvar useIntPt1 = ei1.dist > 0.0 || !ei1.coord.equals2D(lastSegStartPt);\n\t\tif (!useIntPt1) {\n\t\t\tnpts--;\n\t\t}\n\t\tvar pts = new Array(npts).fill(null);\n\t\tvar ipt = 0;\n\t\tpts[ipt++] = new Coordinate(ei0.coord);\n\t\tfor (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {\n\t\t\tpts[ipt++] = this.edge.pts[i];\n\t\t}\n\t\tif (useIntPt1) pts[ipt] = ei1.coord;\n\t\treturn new Edge(pts, new Label(this.edge._label));\n\t},\n\tadd: function add(intPt, segmentIndex, dist) {\n\t\tvar eiNew = new EdgeIntersection(intPt, segmentIndex, dist);\n\t\tvar ei = this._nodeMap.get(eiNew);\n\t\tif (ei !== null) {\n\t\t\treturn ei;\n\t\t}\n\t\tthis._nodeMap.put(eiNew, eiNew);\n\t\treturn eiNew;\n\t},\n\tisIntersection: function isIntersection(pt) {\n\t\tfor (var it = this.iterator(); it.hasNext();) {\n\t\t\tvar ei = it.next();\n\t\t\tif (ei.coord.equals(pt)) return true;\n\t\t}\n\t\treturn false;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn EdgeIntersectionList;\n\t}\n});\n\nfunction MonotoneChainIndexer() {}\nextend(MonotoneChainIndexer.prototype, {\n\tgetChainStartIndices: function getChainStartIndices(pts) {\n\t\tvar start = 0;\n\t\tvar startIndexList = new ArrayList();\n\t\tstartIndexList.add(new Integer(start));\n\t\tdo {\n\t\t\tvar last = this.findChainEnd(pts, start);\n\t\t\tstartIndexList.add(new Integer(last));\n\t\t\tstart = last;\n\t\t} while (start < pts.length - 1);\n\t\tvar startIndex = MonotoneChainIndexer.toIntArray(startIndexList);\n\t\treturn startIndex;\n\t},\n\tfindChainEnd: function findChainEnd(pts, start) {\n\t\tvar chainQuad = Quadrant.quadrant(pts[start], pts[start + 1]);\n\t\tvar last = start + 1;\n\t\twhile (last < pts.length) {\n\t\t\tvar quad = Quadrant.quadrant(pts[last - 1], pts[last]);\n\t\t\tif (quad !== chainQuad) break;\n\t\t\tlast++;\n\t\t}\n\t\treturn last - 1;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn MonotoneChainIndexer;\n\t}\n});\nMonotoneChainIndexer.toIntArray = function (list) {\n\tvar array = new Array(list.size()).fill(null);\n\tfor (var i = 0; i < array.length; i++) {\n\t\tarray[i] = list.get(i).intValue();\n\t}\n\treturn array;\n};\n\nfunction MonotoneChainEdge() {\n\tthis.e = null;\n\tthis.pts = null;\n\tthis.startIndex = null;\n\tthis.env1 = new Envelope();\n\tthis.env2 = new Envelope();\n\tvar e = arguments[0];\n\tthis.e = e;\n\tthis.pts = e.getCoordinates();\n\tvar mcb = new MonotoneChainIndexer();\n\tthis.startIndex = mcb.getChainStartIndices(this.pts);\n}\nextend(MonotoneChainEdge.prototype, {\n\tgetCoordinates: function getCoordinates() {\n\t\treturn this.pts;\n\t},\n\tgetMaxX: function getMaxX(chainIndex) {\n\t\tvar x1 = this.pts[this.startIndex[chainIndex]].x;\n\t\tvar x2 = this.pts[this.startIndex[chainIndex + 1]].x;\n\t\treturn x1 > x2 ? x1 : x2;\n\t},\n\tgetMinX: function getMinX(chainIndex) {\n\t\tvar x1 = this.pts[this.startIndex[chainIndex]].x;\n\t\tvar x2 = this.pts[this.startIndex[chainIndex + 1]].x;\n\t\treturn x1 < x2 ? x1 : x2;\n\t},\n\tcomputeIntersectsForChain: function computeIntersectsForChain() {\n\t\tif (arguments.length === 4) {\n\t\t\tvar chainIndex0 = arguments[0],\n\t\t\t    mce = arguments[1],\n\t\t\t    chainIndex1 = arguments[2],\n\t\t\t    si = arguments[3];\n\t\t\tthis.computeIntersectsForChain(this.startIndex[chainIndex0], this.startIndex[chainIndex0 + 1], mce, mce.startIndex[chainIndex1], mce.startIndex[chainIndex1 + 1], si);\n\t\t} else if (arguments.length === 6) {\n\t\t\tvar start0 = arguments[0],\n\t\t\t    end0 = arguments[1],\n\t\t\t    mce = arguments[2],\n\t\t\t    start1 = arguments[3],\n\t\t\t    end1 = arguments[4],\n\t\t\t    ei = arguments[5];\n\t\t\tvar p00 = this.pts[start0];\n\t\t\tvar p01 = this.pts[end0];\n\t\t\tvar p10 = mce.pts[start1];\n\t\t\tvar p11 = mce.pts[end1];\n\t\t\tif (end0 - start0 === 1 && end1 - start1 === 1) {\n\t\t\t\tei.addIntersections(this.e, start0, mce.e, start1);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tthis.env1.init(p00, p01);\n\t\t\tthis.env2.init(p10, p11);\n\t\t\tif (!this.env1.intersects(this.env2)) return null;\n\t\t\tvar mid0 = Math.trunc((start0 + end0) / 2);\n\t\t\tvar mid1 = Math.trunc((start1 + end1) / 2);\n\t\t\tif (start0 < mid0) {\n\t\t\t\tif (start1 < mid1) this.computeIntersectsForChain(start0, mid0, mce, start1, mid1, ei);\n\t\t\t\tif (mid1 < end1) this.computeIntersectsForChain(start0, mid0, mce, mid1, end1, ei);\n\t\t\t}\n\t\t\tif (mid0 < end0) {\n\t\t\t\tif (start1 < mid1) this.computeIntersectsForChain(mid0, end0, mce, start1, mid1, ei);\n\t\t\t\tif (mid1 < end1) this.computeIntersectsForChain(mid0, end0, mce, mid1, end1, ei);\n\t\t\t}\n\t\t}\n\t},\n\tgetStartIndexes: function getStartIndexes() {\n\t\treturn this.startIndex;\n\t},\n\tcomputeIntersects: function computeIntersects(mce, si) {\n\t\tfor (var i = 0; i < this.startIndex.length - 1; i++) {\n\t\t\tfor (var j = 0; j < mce.startIndex.length - 1; j++) {\n\t\t\t\tthis.computeIntersectsForChain(i, mce, j, si);\n\t\t\t}\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn MonotoneChainEdge;\n\t}\n});\n\nfunction Depth() {\n\tthis._depth = Array(2).fill().map(function () {\n\t\treturn Array(3);\n\t});\n\tfor (var i = 0; i < 2; i++) {\n\t\tfor (var j = 0; j < 3; j++) {\n\t\t\tthis._depth[i][j] = Depth.NULL_VALUE;\n\t\t}\n\t}\n}\nextend(Depth.prototype, {\n\tgetDepth: function getDepth(geomIndex, posIndex) {\n\t\treturn this._depth[geomIndex][posIndex];\n\t},\n\tsetDepth: function setDepth(geomIndex, posIndex, depthValue) {\n\t\tthis._depth[geomIndex][posIndex] = depthValue;\n\t},\n\tisNull: function isNull() {\n\t\tif (arguments.length === 0) {\n\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\tfor (var j = 0; j < 3; j++) {\n\t\t\t\t\tif (this._depth[i][j] !== Depth.NULL_VALUE) return false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else if (arguments.length === 1) {\n\t\t\tvar geomIndex = arguments[0];\n\t\t\treturn this._depth[geomIndex][1] === Depth.NULL_VALUE;\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar geomIndex = arguments[0],\n\t\t\t    posIndex = arguments[1];\n\t\t\treturn this._depth[geomIndex][posIndex] === Depth.NULL_VALUE;\n\t\t}\n\t},\n\tnormalize: function normalize() {\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tif (!this.isNull(i)) {\n\t\t\t\tvar minDepth = this._depth[i][1];\n\t\t\t\tif (this._depth[i][2] < minDepth) minDepth = this._depth[i][2];\n\t\t\t\tif (minDepth < 0) minDepth = 0;\n\t\t\t\tfor (var j = 1; j < 3; j++) {\n\t\t\t\t\tvar newValue = 0;\n\t\t\t\t\tif (this._depth[i][j] > minDepth) newValue = 1;\n\t\t\t\t\tthis._depth[i][j] = newValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tgetDelta: function getDelta(geomIndex) {\n\t\treturn this._depth[geomIndex][Position.RIGHT] - this._depth[geomIndex][Position.LEFT];\n\t},\n\tgetLocation: function getLocation(geomIndex, posIndex) {\n\t\tif (this._depth[geomIndex][posIndex] <= 0) return Location.EXTERIOR;\n\t\treturn Location.INTERIOR;\n\t},\n\ttoString: function toString() {\n\t\treturn \"A: \" + this._depth[0][1] + \",\" + this._depth[0][2] + \" B: \" + this._depth[1][1] + \",\" + this._depth[1][2];\n\t},\n\tadd: function add() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar lbl = arguments[0];\n\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\tfor (var j = 1; j < 3; j++) {\n\t\t\t\t\tvar loc = lbl.getLocation(i, j);\n\t\t\t\t\tif (loc === Location.EXTERIOR || loc === Location.INTERIOR) {\n\t\t\t\t\t\tif (this.isNull(i, j)) {\n\t\t\t\t\t\t\tthis._depth[i][j] = Depth.depthAtLocation(loc);\n\t\t\t\t\t\t} else this._depth[i][j] += Depth.depthAtLocation(loc);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tvar geomIndex = arguments[0],\n\t\t\t    posIndex = arguments[1],\n\t\t\t    location = arguments[2];\n\t\t\tif (location === Location.INTERIOR) this._depth[geomIndex][posIndex]++;\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Depth;\n\t}\n});\nDepth.depthAtLocation = function (location) {\n\tif (location === Location.EXTERIOR) return 0;\n\tif (location === Location.INTERIOR) return 1;\n\treturn Depth.NULL_VALUE;\n};\nDepth.NULL_VALUE = -1;\n\nfunction Edge() {\n\tGraphComponent.apply(this);\n\tthis.pts = null;\n\tthis._env = null;\n\tthis.eiList = new EdgeIntersectionList(this);\n\tthis._name = null;\n\tthis._mce = null;\n\tthis._isIsolated = true;\n\tthis._depth = new Depth();\n\tthis._depthDelta = 0;\n\tif (arguments.length === 1) {\n\t\tvar pts = arguments[0];\n\t\tEdge.call(this, pts, null);\n\t} else if (arguments.length === 2) {\n\t\tvar pts = arguments[0],\n\t\t    label = arguments[1];\n\t\tthis.pts = pts;\n\t\tthis._label = label;\n\t}\n}\ninherits$1(Edge, GraphComponent);\nextend(Edge.prototype, {\n\tgetDepth: function getDepth() {\n\t\treturn this._depth;\n\t},\n\tgetCollapsedEdge: function getCollapsedEdge() {\n\t\tvar newPts = new Array(2).fill(null);\n\t\tnewPts[0] = this.pts[0];\n\t\tnewPts[1] = this.pts[1];\n\t\tvar newe = new Edge(newPts, Label.toLineLabel(this._label));\n\t\treturn newe;\n\t},\n\tisIsolated: function isIsolated() {\n\t\treturn this._isIsolated;\n\t},\n\tgetCoordinates: function getCoordinates() {\n\t\treturn this.pts;\n\t},\n\tsetIsolated: function setIsolated(isIsolated) {\n\t\tthis._isIsolated = isIsolated;\n\t},\n\tsetName: function setName(name) {\n\t\tthis._name = name;\n\t},\n\tequals: function equals(o) {\n\t\tif (!(o instanceof Edge)) return false;\n\t\tvar e = o;\n\t\tif (this.pts.length !== e.pts.length) return false;\n\t\tvar isEqualForward = true;\n\t\tvar isEqualReverse = true;\n\t\tvar iRev = this.pts.length;\n\t\tfor (var i = 0; i < this.pts.length; i++) {\n\t\t\tif (!this.pts[i].equals2D(e.pts[i])) {\n\t\t\t\tisEqualForward = false;\n\t\t\t}\n\t\t\tif (!this.pts[i].equals2D(e.pts[--iRev])) {\n\t\t\t\tisEqualReverse = false;\n\t\t\t}\n\t\t\tif (!isEqualForward && !isEqualReverse) return false;\n\t\t}\n\t\treturn true;\n\t},\n\tgetCoordinate: function getCoordinate() {\n\t\tif (arguments.length === 0) {\n\t\t\tif (this.pts.length > 0) return this.pts[0];\n\t\t\treturn null;\n\t\t} else if (arguments.length === 1) {\n\t\t\tvar i = arguments[0];\n\t\t\treturn this.pts[i];\n\t\t}\n\t},\n\tprint: function print(out) {\n\t\tout.print(\"edge \" + this._name + \": \");\n\t\tout.print(\"LINESTRING (\");\n\t\tfor (var i = 0; i < this.pts.length; i++) {\n\t\t\tif (i > 0) out.print(\",\");\n\t\t\tout.print(this.pts[i].x + \" \" + this.pts[i].y);\n\t\t}\n\t\tout.print(\")  \" + this._label + \" \" + this._depthDelta);\n\t},\n\tcomputeIM: function computeIM(im) {\n\t\tEdge.updateIM(this._label, im);\n\t},\n\tisCollapsed: function isCollapsed() {\n\t\tif (!this._label.isArea()) return false;\n\t\tif (this.pts.length !== 3) return false;\n\t\tif (this.pts[0].equals(this.pts[2])) return true;\n\t\treturn false;\n\t},\n\tisClosed: function isClosed() {\n\t\treturn this.pts[0].equals(this.pts[this.pts.length - 1]);\n\t},\n\tgetMaximumSegmentIndex: function getMaximumSegmentIndex() {\n\t\treturn this.pts.length - 1;\n\t},\n\tgetDepthDelta: function getDepthDelta() {\n\t\treturn this._depthDelta;\n\t},\n\tgetNumPoints: function getNumPoints() {\n\t\treturn this.pts.length;\n\t},\n\tprintReverse: function printReverse(out) {\n\t\tout.print(\"edge \" + this._name + \": \");\n\t\tfor (var i = this.pts.length - 1; i >= 0; i--) {\n\t\t\tout.print(this.pts[i] + \" \");\n\t\t}\n\t\tout.println(\"\");\n\t},\n\tgetMonotoneChainEdge: function getMonotoneChainEdge() {\n\t\tif (this._mce === null) this._mce = new MonotoneChainEdge(this);\n\t\treturn this._mce;\n\t},\n\tgetEnvelope: function getEnvelope() {\n\t\tif (this._env === null) {\n\t\t\tthis._env = new Envelope();\n\t\t\tfor (var i = 0; i < this.pts.length; i++) {\n\t\t\t\tthis._env.expandToInclude(this.pts[i]);\n\t\t\t}\n\t\t}\n\t\treturn this._env;\n\t},\n\taddIntersection: function addIntersection(li, segmentIndex, geomIndex, intIndex) {\n\t\tvar intPt = new Coordinate(li.getIntersection(intIndex));\n\t\tvar normalizedSegmentIndex = segmentIndex;\n\t\tvar dist = li.getEdgeDistance(geomIndex, intIndex);\n\t\tvar nextSegIndex = normalizedSegmentIndex + 1;\n\t\tif (nextSegIndex < this.pts.length) {\n\t\t\tvar nextPt = this.pts[nextSegIndex];\n\t\t\tif (intPt.equals2D(nextPt)) {\n\t\t\t\tnormalizedSegmentIndex = nextSegIndex;\n\t\t\t\tdist = 0.0;\n\t\t\t}\n\t\t}\n\t\tvar ei = this.eiList.add(intPt, normalizedSegmentIndex, dist);\n\t},\n\ttoString: function toString() {\n\t\tvar buf = new StringBuffer();\n\t\tbuf.append(\"edge \" + this._name + \": \");\n\t\tbuf.append(\"LINESTRING (\");\n\t\tfor (var i = 0; i < this.pts.length; i++) {\n\t\t\tif (i > 0) buf.append(\",\");\n\t\t\tbuf.append(this.pts[i].x + \" \" + this.pts[i].y);\n\t\t}\n\t\tbuf.append(\")  \" + this._label + \" \" + this._depthDelta);\n\t\treturn buf.toString();\n\t},\n\tisPointwiseEqual: function isPointwiseEqual(e) {\n\t\tif (this.pts.length !== e.pts.length) return false;\n\t\tfor (var i = 0; i < this.pts.length; i++) {\n\t\t\tif (!this.pts[i].equals2D(e.pts[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t},\n\tsetDepthDelta: function setDepthDelta(depthDelta) {\n\t\tthis._depthDelta = depthDelta;\n\t},\n\tgetEdgeIntersectionList: function getEdgeIntersectionList() {\n\t\treturn this.eiList;\n\t},\n\taddIntersections: function addIntersections(li, segmentIndex, geomIndex) {\n\t\tfor (var i = 0; i < li.getIntersectionNum(); i++) {\n\t\t\tthis.addIntersection(li, segmentIndex, geomIndex, i);\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Edge;\n\t}\n});\nEdge.updateIM = function () {\n\tif (arguments.length === 2) {\n\t\tvar label = arguments[0],\n\t\t    im = arguments[1];\n\t\tim.setAtLeastIfValid(label.getLocation(0, Position.ON), label.getLocation(1, Position.ON), 1);\n\t\tif (label.isArea()) {\n\t\t\tim.setAtLeastIfValid(label.getLocation(0, Position.LEFT), label.getLocation(1, Position.LEFT), 2);\n\t\t\tim.setAtLeastIfValid(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), 2);\n\t\t}\n\t} else return GraphComponent.prototype.updateIM.apply(this, arguments);\n};\n\nfunction GeometryGraph() {\n\tPlanarGraph.apply(this);\n\tthis._parentGeom = null;\n\tthis._lineEdgeMap = new HashMap();\n\tthis._boundaryNodeRule = null;\n\tthis._useBoundaryDeterminationRule = true;\n\tthis._argIndex = null;\n\tthis._boundaryNodes = null;\n\tthis._hasTooFewPoints = false;\n\tthis._invalidPoint = null;\n\tthis._areaPtLocator = null;\n\tthis._ptLocator = new PointLocator();\n\tif (arguments.length === 2) {\n\t\tvar argIndex = arguments[0],\n\t\t    parentGeom = arguments[1];\n\t\tGeometryGraph.call(this, argIndex, parentGeom, BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE);\n\t} else if (arguments.length === 3) {\n\t\tvar argIndex = arguments[0],\n\t\t    parentGeom = arguments[1],\n\t\t    boundaryNodeRule = arguments[2];\n\t\tthis._argIndex = argIndex;\n\t\tthis._parentGeom = parentGeom;\n\t\tthis._boundaryNodeRule = boundaryNodeRule;\n\t\tif (parentGeom !== null) {\n\t\t\tthis.add(parentGeom);\n\t\t}\n\t}\n}\ninherits$1(GeometryGraph, PlanarGraph);\nextend(GeometryGraph.prototype, {\n\tinsertBoundaryPoint: function insertBoundaryPoint(argIndex, coord) {\n\t\tvar n = this._nodes.addNode(coord);\n\t\tvar lbl = n.getLabel();\n\t\tvar boundaryCount = 1;\n\t\tvar loc = Location.NONE;\n\t\tloc = lbl.getLocation(argIndex, Position.ON);\n\t\tif (loc === Location.BOUNDARY) boundaryCount++;\n\t\tvar newLoc = GeometryGraph.determineBoundary(this._boundaryNodeRule, boundaryCount);\n\t\tlbl.setLocation(argIndex, newLoc);\n\t},\n\tcomputeSelfNodes: function computeSelfNodes() {\n\t\tif (arguments.length === 2) {\n\t\t\tvar li = arguments[0],\n\t\t\t    computeRingSelfNodes = arguments[1];\n\t\t\treturn this.computeSelfNodes(li, computeRingSelfNodes, false);\n\t\t} else if (arguments.length === 3) {\n\t\t\tvar li = arguments[0],\n\t\t\t    computeRingSelfNodes = arguments[1],\n\t\t\t    isDoneIfProperInt = arguments[2];\n\t\t\tvar si = new SegmentIntersector$1(li, true, false);\n\t\t\tsi.setIsDoneIfProperInt(isDoneIfProperInt);\n\t\t\tvar esi = this.createEdgeSetIntersector();\n\t\t\tvar isRings = this._parentGeom instanceof LinearRing || this._parentGeom instanceof Polygon || this._parentGeom instanceof MultiPolygon;\n\t\t\tvar computeAllSegments = computeRingSelfNodes || !isRings;\n\t\t\tesi.computeIntersections(this._edges, si, computeAllSegments);\n\t\t\tthis.addSelfIntersectionNodes(this._argIndex);\n\t\t\treturn si;\n\t\t}\n\t},\n\tcomputeSplitEdges: function computeSplitEdges(edgelist) {\n\t\tfor (var i = this._edges.iterator(); i.hasNext();) {\n\t\t\tvar e = i.next();\n\t\t\te.eiList.addSplitEdges(edgelist);\n\t\t}\n\t},\n\tcomputeEdgeIntersections: function computeEdgeIntersections(g, li, includeProper) {\n\t\tvar si = new SegmentIntersector$1(li, includeProper, true);\n\t\tsi.setBoundaryNodes(this.getBoundaryNodes(), g.getBoundaryNodes());\n\t\tvar esi = this.createEdgeSetIntersector();\n\t\tesi.computeIntersections(this._edges, g._edges, si);\n\t\treturn si;\n\t},\n\tgetGeometry: function getGeometry() {\n\t\treturn this._parentGeom;\n\t},\n\tgetBoundaryNodeRule: function getBoundaryNodeRule() {\n\t\treturn this._boundaryNodeRule;\n\t},\n\thasTooFewPoints: function hasTooFewPoints() {\n\t\treturn this._hasTooFewPoints;\n\t},\n\taddPoint: function addPoint() {\n\t\tif (arguments[0] instanceof Point) {\n\t\t\tvar p = arguments[0];\n\t\t\tvar coord = p.getCoordinate();\n\t\t\tthis.insertPoint(this._argIndex, coord, Location.INTERIOR);\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tvar pt = arguments[0];\n\t\t\tthis.insertPoint(this._argIndex, pt, Location.INTERIOR);\n\t\t}\n\t},\n\taddPolygon: function addPolygon(p) {\n\t\tthis.addPolygonRing(p.getExteriorRing(), Location.EXTERIOR, Location.INTERIOR);\n\t\tfor (var i = 0; i < p.getNumInteriorRing(); i++) {\n\t\t\tvar hole = p.getInteriorRingN(i);\n\t\t\tthis.addPolygonRing(hole, Location.INTERIOR, Location.EXTERIOR);\n\t\t}\n\t},\n\taddEdge: function addEdge(e) {\n\t\tthis.insertEdge(e);\n\t\tvar coord = e.getCoordinates();\n\t\tthis.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);\n\t\tthis.insertPoint(this._argIndex, coord[coord.length - 1], Location.BOUNDARY);\n\t},\n\taddLineString: function addLineString(line) {\n\t\tvar coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());\n\t\tif (coord.length < 2) {\n\t\t\tthis._hasTooFewPoints = true;\n\t\t\tthis._invalidPoint = coord[0];\n\t\t\treturn null;\n\t\t}\n\t\tvar e = new Edge(coord, new Label(this._argIndex, Location.INTERIOR));\n\t\tthis._lineEdgeMap.put(line, e);\n\t\tthis.insertEdge(e);\n\t\tAssert.isTrue(coord.length >= 2, \"found LineString with single point\");\n\t\tthis.insertBoundaryPoint(this._argIndex, coord[0]);\n\t\tthis.insertBoundaryPoint(this._argIndex, coord[coord.length - 1]);\n\t},\n\tgetInvalidPoint: function getInvalidPoint() {\n\t\treturn this._invalidPoint;\n\t},\n\tgetBoundaryPoints: function getBoundaryPoints() {\n\t\tvar coll = this.getBoundaryNodes();\n\t\tvar pts = new Array(coll.size()).fill(null);\n\t\tvar i = 0;\n\t\tfor (var it = coll.iterator(); it.hasNext();) {\n\t\t\tvar node = it.next();\n\t\t\tpts[i++] = node.getCoordinate().copy();\n\t\t}\n\t\treturn pts;\n\t},\n\tgetBoundaryNodes: function getBoundaryNodes() {\n\t\tif (this._boundaryNodes === null) this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex);\n\t\treturn this._boundaryNodes;\n\t},\n\taddSelfIntersectionNode: function addSelfIntersectionNode(argIndex, coord, loc) {\n\t\tif (this.isBoundaryNode(argIndex, coord)) return null;\n\t\tif (loc === Location.BOUNDARY && this._useBoundaryDeterminationRule) this.insertBoundaryPoint(argIndex, coord);else this.insertPoint(argIndex, coord, loc);\n\t},\n\taddPolygonRing: function addPolygonRing(lr, cwLeft, cwRight) {\n\t\tif (lr.isEmpty()) return null;\n\t\tvar coord = CoordinateArrays.removeRepeatedPoints(lr.getCoordinates());\n\t\tif (coord.length < 4) {\n\t\t\tthis._hasTooFewPoints = true;\n\t\t\tthis._invalidPoint = coord[0];\n\t\t\treturn null;\n\t\t}\n\t\tvar left = cwLeft;\n\t\tvar right = cwRight;\n\t\tif (CGAlgorithms.isCCW(coord)) {\n\t\t\tleft = cwRight;\n\t\t\tright = cwLeft;\n\t\t}\n\t\tvar e = new Edge(coord, new Label(this._argIndex, Location.BOUNDARY, left, right));\n\t\tthis._lineEdgeMap.put(lr, e);\n\t\tthis.insertEdge(e);\n\t\tthis.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);\n\t},\n\tinsertPoint: function insertPoint(argIndex, coord, onLocation) {\n\t\tvar n = this._nodes.addNode(coord);\n\t\tvar lbl = n.getLabel();\n\t\tif (lbl === null) {\n\t\t\tn._label = new Label(argIndex, onLocation);\n\t\t} else lbl.setLocation(argIndex, onLocation);\n\t},\n\tcreateEdgeSetIntersector: function createEdgeSetIntersector() {\n\t\treturn new SimpleMCSweepLineIntersector();\n\t},\n\taddSelfIntersectionNodes: function addSelfIntersectionNodes(argIndex) {\n\t\tfor (var i = this._edges.iterator(); i.hasNext();) {\n\t\t\tvar e = i.next();\n\t\t\tvar eLoc = e.getLabel().getLocation(argIndex);\n\t\t\tfor (var eiIt = e.eiList.iterator(); eiIt.hasNext();) {\n\t\t\t\tvar ei = eiIt.next();\n\t\t\t\tthis.addSelfIntersectionNode(argIndex, ei.coord, eLoc);\n\t\t\t}\n\t\t}\n\t},\n\tadd: function add() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar g = arguments[0];\n\t\t\tif (g.isEmpty()) return null;\n\t\t\tif (g instanceof MultiPolygon) this._useBoundaryDeterminationRule = false;\n\t\t\tif (g instanceof Polygon) this.addPolygon(g);else if (g instanceof LineString) this.addLineString(g);else if (g instanceof Point) this.addPoint(g);else if (g instanceof MultiPoint) this.addCollection(g);else if (g instanceof MultiLineString) this.addCollection(g);else if (g instanceof MultiPolygon) this.addCollection(g);else if (g instanceof GeometryCollection) this.addCollection(g);else throw new UnsupportedOperationException(g.getClass().getName());\n\t\t} else return PlanarGraph.prototype.add.apply(this, arguments);\n\t},\n\taddCollection: function addCollection(gc) {\n\t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n\t\t\tvar g = gc.getGeometryN(i);\n\t\t\tthis.add(g);\n\t\t}\n\t},\n\tlocate: function locate(pt) {\n\t\tif (hasInterface(this._parentGeom, Polygonal) && this._parentGeom.getNumGeometries() > 50) {\n\t\t\tif (this._areaPtLocator === null) {\n\t\t\t\tthis._areaPtLocator = new IndexedPointInAreaLocator(this._parentGeom);\n\t\t\t}\n\t\t\treturn this._areaPtLocator.locate(pt);\n\t\t}\n\t\treturn this._ptLocator.locate(pt, this._parentGeom);\n\t},\n\tfindEdge: function findEdge() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar line = arguments[0];\n\t\t\treturn this._lineEdgeMap.get(line);\n\t\t} else return PlanarGraph.prototype.findEdge.apply(this, arguments);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn GeometryGraph;\n\t}\n});\nGeometryGraph.determineBoundary = function (boundaryNodeRule, boundaryCount) {\n\treturn boundaryNodeRule.isInBoundary(boundaryCount) ? Location.BOUNDARY : Location.INTERIOR;\n};\n\nfunction GeometryGraphOperation() {\n\tthis._li = new RobustLineIntersector();\n\tthis._resultPrecisionModel = null;\n\tthis._arg = null;\n\tif (arguments.length === 1) {\n\t\tvar g0 = arguments[0];\n\t\tthis.setComputationPrecision(g0.getPrecisionModel());\n\t\tthis._arg = new Array(1).fill(null);\n\t\tthis._arg[0] = new GeometryGraph(0, g0);\n\t\t\n\t} else if (arguments.length === 2) {\n\t\tvar g0 = arguments[0],\n\t\t    g1 = arguments[1];\n\t\tGeometryGraphOperation.call(this, g0, g1, BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE);\n\t} else if (arguments.length === 3) {\n\t\tvar g0 = arguments[0],\n\t\t    g1 = arguments[1],\n\t\t    boundaryNodeRule = arguments[2];\n\t\tif (g0.getPrecisionModel().compareTo(g1.getPrecisionModel()) >= 0) this.setComputationPrecision(g0.getPrecisionModel());else this.setComputationPrecision(g1.getPrecisionModel());\n\t\tthis._arg = new Array(2).fill(null);\n\t\tthis._arg[0] = new GeometryGraph(0, g0, boundaryNodeRule);\n\t\tthis._arg[1] = new GeometryGraph(1, g1, boundaryNodeRule);\n\t}\n}\nextend(GeometryGraphOperation.prototype, {\n\tgetArgGeometry: function getArgGeometry(i) {\n\t\treturn this._arg[i].getGeometry();\n\t},\n\tsetComputationPrecision: function setComputationPrecision(pm) {\n\t\tthis._resultPrecisionModel = pm;\n\t\tthis._li.setPrecisionModel(this._resultPrecisionModel);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn GeometryGraphOperation;\n\t}\n});\n\nfunction OrientedCoordinateArray() {\n\tthis._pts = null;\n\tthis._orientation = null;\n\tvar pts = arguments[0];\n\tthis._pts = pts;\n\tthis._orientation = OrientedCoordinateArray.orientation(pts);\n}\nextend(OrientedCoordinateArray.prototype, {\n\tcompareTo: function compareTo(o1) {\n\t\tvar oca = o1;\n\t\tvar comp = OrientedCoordinateArray.compareOriented(this._pts, this._orientation, oca._pts, oca._orientation);\n\t\treturn comp;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Comparable];\n\t},\n\tgetClass: function getClass() {\n\t\treturn OrientedCoordinateArray;\n\t}\n});\nOrientedCoordinateArray.orientation = function (pts) {\n\treturn CoordinateArrays.increasingDirection(pts) === 1;\n};\nOrientedCoordinateArray.compareOriented = function (pts1, orientation1, pts2, orientation2) {\n\tvar dir1 = orientation1 ? 1 : -1;\n\tvar dir2 = orientation2 ? 1 : -1;\n\tvar limit1 = orientation1 ? pts1.length : -1;\n\tvar limit2 = orientation2 ? pts2.length : -1;\n\tvar i1 = orientation1 ? 0 : pts1.length - 1;\n\tvar i2 = orientation2 ? 0 : pts2.length - 1;\n\twhile (true) {\n\t\tvar compPt = pts1[i1].compareTo(pts2[i2]);\n\t\tif (compPt !== 0) return compPt;\n\t\ti1 += dir1;\n\t\ti2 += dir2;\n\t\tvar done1 = i1 === limit1;\n\t\tvar done2 = i2 === limit2;\n\t\tif (done1 && !done2) return -1;\n\t\tif (!done1 && done2) return 1;\n\t\tif (done1 && done2) return 0;\n\t}\n};\n\nfunction EdgeList() {\n\tthis._edges = new ArrayList();\n\tthis._ocaMap = new TreeMap();\n}\nextend(EdgeList.prototype, {\n\tprint: function print(out) {\n\t\tout.print(\"MULTILINESTRING ( \");\n\t\tfor (var j = 0; j < this._edges.size(); j++) {\n\t\t\tvar e = this._edges.get(j);\n\t\t\tif (j > 0) out.print(\",\");\n\t\t\tout.print(\"(\");\n\t\t\tvar pts = e.getCoordinates();\n\t\t\tfor (var i = 0; i < pts.length; i++) {\n\t\t\t\tif (i > 0) out.print(\",\");\n\t\t\t\tout.print(pts[i].x + \" \" + pts[i].y);\n\t\t\t}\n\t\t\tout.println(\")\");\n\t\t}\n\t\tout.print(\")  \");\n\t},\n\taddAll: function addAll(edgeColl) {\n\t\tfor (var i = edgeColl.iterator(); i.hasNext();) {\n\t\t\tthis.add(i.next());\n\t\t}\n\t},\n\tfindEdgeIndex: function findEdgeIndex(e) {\n\t\tfor (var i = 0; i < this._edges.size(); i++) {\n\t\t\tif (this._edges.get(i).equals(e)) return i;\n\t\t}\n\t\treturn -1;\n\t},\n\titerator: function iterator() {\n\t\treturn this._edges.iterator();\n\t},\n\tgetEdges: function getEdges() {\n\t\treturn this._edges;\n\t},\n\tget: function get(i) {\n\t\treturn this._edges.get(i);\n\t},\n\tfindEqualEdge: function findEqualEdge(e) {\n\t\tvar oca = new OrientedCoordinateArray(e.getCoordinates());\n\t\tvar matchEdge = this._ocaMap.get(oca);\n\t\treturn matchEdge;\n\t},\n\tadd: function add(e) {\n\t\tthis._edges.add(e);\n\t\tvar oca = new OrientedCoordinateArray(e.getCoordinates());\n\t\tthis._ocaMap.put(oca, e);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn EdgeList;\n\t}\n});\n\nfunction OverlayOp() {\n\tthis._ptLocator = new PointLocator();\n\tthis._geomFact = null;\n\tthis._resultGeom = null;\n\tthis._graph = null;\n\tthis._edgeList = new EdgeList();\n\tthis._resultPolyList = new ArrayList();\n\tthis._resultLineList = new ArrayList();\n\tthis._resultPointList = new ArrayList();\n\tvar g0 = arguments[0],\n\t    g1 = arguments[1];\n\tGeometryGraphOperation.call(this, g0, g1);\n\tthis._graph = new PlanarGraph(new OverlayNodeFactory());\n\tthis._geomFact = g0.getFactory();\n}\ninherits$1(OverlayOp, GeometryGraphOperation);\nextend(OverlayOp.prototype, {\n\tinsertUniqueEdge: function insertUniqueEdge(e) {\n\t\tvar existingEdge = this._edgeList.findEqualEdge(e);\n\t\tif (existingEdge !== null) {\n\t\t\tvar existingLabel = existingEdge.getLabel();\n\t\t\tvar labelToMerge = e.getLabel();\n\t\t\tif (!existingEdge.isPointwiseEqual(e)) {\n\t\t\t\tlabelToMerge = new Label(e.getLabel());\n\t\t\t\tlabelToMerge.flip();\n\t\t\t}\n\t\t\tvar depth = existingEdge.getDepth();\n\t\t\tif (depth.isNull()) {\n\t\t\t\tdepth.add(existingLabel);\n\t\t\t}\n\t\t\tdepth.add(labelToMerge);\n\t\t\texistingLabel.merge(labelToMerge);\n\t\t} else {\n\t\t\tthis._edgeList.add(e);\n\t\t}\n\t},\n\tgetGraph: function getGraph() {\n\t\treturn this._graph;\n\t},\n\tcancelDuplicateResultEdges: function cancelDuplicateResultEdges() {\n\t\tfor (var it = this._graph.getEdgeEnds().iterator(); it.hasNext();) {\n\t\t\tvar de = it.next();\n\t\t\tvar sym = de.getSym();\n\t\t\tif (de.isInResult() && sym.isInResult()) {\n\t\t\t\tde.setInResult(false);\n\t\t\t\tsym.setInResult(false);\n\t\t\t}\n\t\t}\n\t},\n\tisCoveredByLA: function isCoveredByLA(coord) {\n\t\tif (this.isCovered(coord, this._resultLineList)) return true;\n\t\tif (this.isCovered(coord, this._resultPolyList)) return true;\n\t\treturn false;\n\t},\n\tcomputeGeometry: function computeGeometry(resultPointList, resultLineList, resultPolyList, opcode) {\n\t\tvar geomList = new ArrayList();\n\t\tgeomList.addAll(resultPointList);\n\t\tgeomList.addAll(resultLineList);\n\t\tgeomList.addAll(resultPolyList);\n\t\tif (geomList.isEmpty()) return OverlayOp.createEmptyResult(opcode, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact);\n\t\treturn this._geomFact.buildGeometry(geomList);\n\t},\n\tmergeSymLabels: function mergeSymLabels() {\n\t\tfor (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {\n\t\t\tvar node = nodeit.next();\n\t\t\tnode.getEdges().mergeSymLabels();\n\t\t}\n\t},\n\tisCovered: function isCovered(coord, geomList) {\n\t\tfor (var it = geomList.iterator(); it.hasNext();) {\n\t\t\tvar geom = it.next();\n\t\t\tvar loc = this._ptLocator.locate(coord, geom);\n\t\t\tif (loc !== Location.EXTERIOR) return true;\n\t\t}\n\t\treturn false;\n\t},\n\treplaceCollapsedEdges: function replaceCollapsedEdges() {\n\t\tvar newEdges = new ArrayList();\n\t\tfor (var it = this._edgeList.iterator(); it.hasNext();) {\n\t\t\tvar e = it.next();\n\t\t\tif (e.isCollapsed()) {\n\t\t\t\tit.remove();\n\t\t\t\tnewEdges.add(e.getCollapsedEdge());\n\t\t\t}\n\t\t}\n\t\tthis._edgeList.addAll(newEdges);\n\t},\n\tupdateNodeLabelling: function updateNodeLabelling() {\n\t\tfor (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {\n\t\t\tvar node = nodeit.next();\n\t\t\tvar lbl = node.getEdges().getLabel();\n\t\t\tnode.getLabel().merge(lbl);\n\t\t}\n\t},\n\tgetResultGeometry: function getResultGeometry(overlayOpCode) {\n\t\tthis.computeOverlay(overlayOpCode);\n\t\treturn this._resultGeom;\n\t},\n\tinsertUniqueEdges: function insertUniqueEdges(edges) {\n\t\tfor (var i = edges.iterator(); i.hasNext();) {\n\t\t\tvar e = i.next();\n\t\t\tthis.insertUniqueEdge(e);\n\t\t}\n\t},\n\tcomputeOverlay: function computeOverlay(opCode) {\n\t\tthis.copyPoints(0);\n\t\tthis.copyPoints(1);\n\t\tthis._arg[0].computeSelfNodes(this._li, false);\n\t\tthis._arg[1].computeSelfNodes(this._li, false);\n\t\tthis._arg[0].computeEdgeIntersections(this._arg[1], this._li, true);\n\t\tvar baseSplitEdges = new ArrayList();\n\t\tthis._arg[0].computeSplitEdges(baseSplitEdges);\n\t\tthis._arg[1].computeSplitEdges(baseSplitEdges);\n\t\tthis.insertUniqueEdges(baseSplitEdges);\n\t\tthis.computeLabelsFromDepths();\n\t\tthis.replaceCollapsedEdges();\n\t\tEdgeNodingValidator.checkValid(this._edgeList.getEdges());\n\t\tthis._graph.addEdges(this._edgeList.getEdges());\n\t\tthis.computeLabelling();\n\t\tthis.labelIncompleteNodes();\n\t\tthis.findResultAreaEdges(opCode);\n\t\tthis.cancelDuplicateResultEdges();\n\t\tvar polyBuilder = new PolygonBuilder(this._geomFact);\n\t\tpolyBuilder.add(this._graph);\n\t\tthis._resultPolyList = polyBuilder.getPolygons();\n\t\tvar lineBuilder = new LineBuilder(this, this._geomFact, this._ptLocator);\n\t\tthis._resultLineList = lineBuilder.build(opCode);\n\t\tvar pointBuilder = new PointBuilder(this, this._geomFact, this._ptLocator);\n\t\tthis._resultPointList = pointBuilder.build(opCode);\n\t\tthis._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, opCode);\n\t},\n\tlabelIncompleteNode: function labelIncompleteNode(n, targetIndex) {\n\t\tvar loc = this._ptLocator.locate(n.getCoordinate(), this._arg[targetIndex].getGeometry());\n\t\tn.getLabel().setLocation(targetIndex, loc);\n\t},\n\tcopyPoints: function copyPoints(argIndex) {\n\t\tfor (var i = this._arg[argIndex].getNodeIterator(); i.hasNext();) {\n\t\t\tvar graphNode = i.next();\n\t\t\tvar newNode = this._graph.addNode(graphNode.getCoordinate());\n\t\t\tnewNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));\n\t\t}\n\t},\n\tfindResultAreaEdges: function findResultAreaEdges(opCode) {\n\t\tfor (var it = this._graph.getEdgeEnds().iterator(); it.hasNext();) {\n\t\t\tvar de = it.next();\n\t\t\tvar label = de.getLabel();\n\t\t\tif (label.isArea() && !de.isInteriorAreaEdge() && OverlayOp.isResultOfOp(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), opCode)) {\n\t\t\t\tde.setInResult(true);\n\t\t\t}\n\t\t}\n\t},\n\tcomputeLabelsFromDepths: function computeLabelsFromDepths() {\n\t\tfor (var it = this._edgeList.iterator(); it.hasNext();) {\n\t\t\tvar e = it.next();\n\t\t\tvar lbl = e.getLabel();\n\t\t\tvar depth = e.getDepth();\n\t\t\tif (!depth.isNull()) {\n\t\t\t\tdepth.normalize();\n\t\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\t\tif (!lbl.isNull(i) && lbl.isArea() && !depth.isNull(i)) {\n\t\t\t\t\t\tif (depth.getDelta(i) === 0) {\n\t\t\t\t\t\t\tlbl.toLine(i);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tAssert.isTrue(!depth.isNull(i, Position.LEFT), \"depth of LEFT side has not been initialized\");\n\t\t\t\t\t\t\tlbl.setLocation(i, Position.LEFT, depth.getLocation(i, Position.LEFT));\n\t\t\t\t\t\t\tAssert.isTrue(!depth.isNull(i, Position.RIGHT), \"depth of RIGHT side has not been initialized\");\n\t\t\t\t\t\t\tlbl.setLocation(i, Position.RIGHT, depth.getLocation(i, Position.RIGHT));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tcomputeLabelling: function computeLabelling() {\n\t\tfor (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {\n\t\t\tvar node = nodeit.next();\n\t\t\tnode.getEdges().computeLabelling(this._arg);\n\t\t}\n\t\tthis.mergeSymLabels();\n\t\tthis.updateNodeLabelling();\n\t},\n\tlabelIncompleteNodes: function labelIncompleteNodes() {\n\t\tfor (var ni = this._graph.getNodes().iterator(); ni.hasNext();) {\n\t\t\tvar n = ni.next();\n\t\t\tvar label = n.getLabel();\n\t\t\tif (n.isIsolated()) {\n\t\t\t\tif (label.isNull(0)) this.labelIncompleteNode(n, 0);else this.labelIncompleteNode(n, 1);\n\t\t\t}\n\t\t\tn.getEdges().updateLabelling(label);\n\t\t}\n\t},\n\tisCoveredByA: function isCoveredByA(coord) {\n\t\tif (this.isCovered(coord, this._resultPolyList)) return true;\n\t\treturn false;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn OverlayOp;\n\t}\n});\nOverlayOp.overlayOp = function (geom0, geom1, opCode) {\n\tvar gov = new OverlayOp(geom0, geom1);\n\tvar geomOv = gov.getResultGeometry(opCode);\n\treturn geomOv;\n};\nOverlayOp.intersection = function (g, other) {\n\tif (g.isEmpty() || other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.INTERSECTION, g, other, g.getFactory());\n\tif (g.isGeometryCollection()) {\n\t\tvar g2 = other;\n\t\treturn GeometryCollectionMapper.map(g, {\n\t\t\tinterfaces_: function interfaces_() {\n\t\t\t\treturn [MapOp];\n\t\t\t},\n\t\t\tmap: function map(g) {\n\t\t\t\treturn g.intersection(g2);\n\t\t\t}\n\t\t});\n\t}\n\tg.checkNotGeometryCollection(g);\n\tg.checkNotGeometryCollection(other);\n\treturn SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.INTERSECTION);\n};\nOverlayOp.symDifference = function (g, other) {\n\tif (g.isEmpty() || other.isEmpty()) {\n\t\tif (g.isEmpty() && other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.SYMDIFFERENCE, g, other, g.getFactory());\n\t\tif (g.isEmpty()) return other.copy();\n\t\tif (other.isEmpty()) return g.copy();\n\t}\n\tg.checkNotGeometryCollection(g);\n\tg.checkNotGeometryCollection(other);\n\treturn SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.SYMDIFFERENCE);\n};\nOverlayOp.resultDimension = function (opCode, g0, g1) {\n\tvar dim0 = g0.getDimension();\n\tvar dim1 = g1.getDimension();\n\tvar resultDimension = -1;\n\tswitch (opCode) {\n\t\tcase OverlayOp.INTERSECTION:\n\t\t\tresultDimension = Math.min(dim0, dim1);\n\t\t\tbreak;\n\t\tcase OverlayOp.UNION:\n\t\t\tresultDimension = Math.max(dim0, dim1);\n\t\t\tbreak;\n\t\tcase OverlayOp.DIFFERENCE:\n\t\t\tresultDimension = dim0;\n\t\t\tbreak;\n\t\tcase OverlayOp.SYMDIFFERENCE:\n\t\t\tresultDimension = Math.max(dim0, dim1);\n\t\t\tbreak;\n\t}\n\treturn resultDimension;\n};\nOverlayOp.createEmptyResult = function (overlayOpCode, a, b, geomFact) {\n\tvar result = null;\n\tswitch (OverlayOp.resultDimension(overlayOpCode, a, b)) {\n\t\tcase -1:\n\t\t\tresult = geomFact.createGeometryCollection(new Array(0).fill(null));\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tresult = geomFact.createPoint();\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tresult = geomFact.createLineString();\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tresult = geomFact.createPolygon();\n\t\t\tbreak;\n\t}\n\treturn result;\n};\nOverlayOp.difference = function (g, other) {\n\tif (g.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.DIFFERENCE, g, other, g.getFactory());\n\tif (other.isEmpty()) return g.copy();\n\tg.checkNotGeometryCollection(g);\n\tg.checkNotGeometryCollection(other);\n\treturn SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.DIFFERENCE);\n};\nOverlayOp.isResultOfOp = function () {\n\tif (arguments.length === 2) {\n\t\tvar label = arguments[0],\n\t\t    opCode = arguments[1];\n\t\tvar loc0 = label.getLocation(0);\n\t\tvar loc1 = label.getLocation(1);\n\t\treturn OverlayOp.isResultOfOp(loc0, loc1, opCode);\n\t} else if (arguments.length === 3) {\n\t\tvar loc0 = arguments[0],\n\t\t    loc1 = arguments[1],\n\t\t    overlayOpCode = arguments[2];\n\t\tif (loc0 === Location.BOUNDARY) loc0 = Location.INTERIOR;\n\t\tif (loc1 === Location.BOUNDARY) loc1 = Location.INTERIOR;\n\t\tswitch (overlayOpCode) {\n\t\t\tcase OverlayOp.INTERSECTION:\n\t\t\t\treturn loc0 === Location.INTERIOR && loc1 === Location.INTERIOR;\n\t\t\tcase OverlayOp.UNION:\n\t\t\t\treturn loc0 === Location.INTERIOR || loc1 === Location.INTERIOR;\n\t\t\tcase OverlayOp.DIFFERENCE:\n\t\t\t\treturn loc0 === Location.INTERIOR && loc1 !== Location.INTERIOR;\n\t\t\tcase OverlayOp.SYMDIFFERENCE:\n\t\t\t\treturn loc0 === Location.INTERIOR && loc1 !== Location.INTERIOR || loc0 !== Location.INTERIOR && loc1 === Location.INTERIOR;\n\t\t}\n\t\treturn false;\n\t}\n};\nOverlayOp.INTERSECTION = 1;\nOverlayOp.UNION = 2;\nOverlayOp.DIFFERENCE = 3;\nOverlayOp.SYMDIFFERENCE = 4;\n\nfunction SnapOverlayOp() {\n\tthis._geom = new Array(2).fill(null);\n\tthis._snapTolerance = null;\n\tthis._cbr = null;\n\tvar g1 = arguments[0],\n\t    g2 = arguments[1];\n\tthis._geom[0] = g1;\n\tthis._geom[1] = g2;\n\tthis.computeSnapTolerance();\n}\nextend(SnapOverlayOp.prototype, {\n\tselfSnap: function selfSnap(geom) {\n\t\tvar snapper0 = new GeometrySnapper(geom);\n\t\tvar snapGeom = snapper0.snapTo(geom, this._snapTolerance);\n\t\treturn snapGeom;\n\t},\n\tremoveCommonBits: function removeCommonBits(geom) {\n\t\tthis._cbr = new CommonBitsRemover();\n\t\tthis._cbr.add(geom[0]);\n\t\tthis._cbr.add(geom[1]);\n\t\tvar remGeom = new Array(2).fill(null);\n\t\tremGeom[0] = this._cbr.removeCommonBits(geom[0].copy());\n\t\tremGeom[1] = this._cbr.removeCommonBits(geom[1].copy());\n\t\treturn remGeom;\n\t},\n\tprepareResult: function prepareResult(geom) {\n\t\tthis._cbr.addCommonBits(geom);\n\t\treturn geom;\n\t},\n\tgetResultGeometry: function getResultGeometry(opCode) {\n\t\tvar prepGeom = this.snap(this._geom);\n\t\tvar result = OverlayOp.overlayOp(prepGeom[0], prepGeom[1], opCode);\n\t\treturn this.prepareResult(result);\n\t},\n\tcheckValid: function checkValid(g) {\n\t\tif (!g.isValid()) {\n\t\t\tSystem.out.println(\"Snapped geometry is invalid\");\n\t\t}\n\t},\n\tcomputeSnapTolerance: function computeSnapTolerance() {\n\t\tthis._snapTolerance = GeometrySnapper.computeOverlaySnapTolerance(this._geom[0], this._geom[1]);\n\t},\n\tsnap: function snap(geom) {\n\t\tvar remGeom = this.removeCommonBits(geom);\n\t\tvar snapGeom = GeometrySnapper.snap(remGeom[0], remGeom[1], this._snapTolerance);\n\t\treturn snapGeom;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn SnapOverlayOp;\n\t}\n});\nSnapOverlayOp.overlayOp = function (g0, g1, opCode) {\n\tvar op = new SnapOverlayOp(g0, g1);\n\treturn op.getResultGeometry(opCode);\n};\nSnapOverlayOp.union = function (g0, g1) {\n\treturn SnapOverlayOp.overlayOp(g0, g1, OverlayOp.UNION);\n};\nSnapOverlayOp.intersection = function (g0, g1) {\n\treturn SnapOverlayOp.overlayOp(g0, g1, OverlayOp.INTERSECTION);\n};\nSnapOverlayOp.symDifference = function (g0, g1) {\n\treturn SnapOverlayOp.overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE);\n};\nSnapOverlayOp.difference = function (g0, g1) {\n\treturn SnapOverlayOp.overlayOp(g0, g1, OverlayOp.DIFFERENCE);\n};\n\nfunction SnapIfNeededOverlayOp() {\n\tthis._geom = new Array(2).fill(null);\n\tvar g1 = arguments[0],\n\t    g2 = arguments[1];\n\tthis._geom[0] = g1;\n\tthis._geom[1] = g2;\n}\nextend(SnapIfNeededOverlayOp.prototype, {\n\tgetResultGeometry: function getResultGeometry(opCode) {\n\t\tvar result = null;\n\t\tvar isSuccess = false;\n\t\tvar savedException = null;\n\t\ttry {\n\t\t\tresult = OverlayOp.overlayOp(this._geom[0], this._geom[1], opCode);\n\t\t\tvar isValid = true;\n\t\t\tif (isValid) isSuccess = true;\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof RuntimeException) {\n\t\t\t\tsavedException = ex;\n\t\t\t} else throw ex;\n\t\t} finally {}\n\t\tif (!isSuccess) {\n\t\t\ttry {\n\t\t\t\tresult = SnapOverlayOp.overlayOp(this._geom[0], this._geom[1], opCode);\n\t\t\t} catch (ex) {\n\t\t\t\tif (ex instanceof RuntimeException) {\n\t\t\t\t\tthrow savedException;\n\t\t\t\t} else throw ex;\n\t\t\t} finally {}\n\t\t}\n\t\treturn result;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn SnapIfNeededOverlayOp;\n\t}\n});\nSnapIfNeededOverlayOp.overlayOp = function (g0, g1, opCode) {\n\tvar op = new SnapIfNeededOverlayOp(g0, g1);\n\treturn op.getResultGeometry(opCode);\n};\nSnapIfNeededOverlayOp.union = function (g0, g1) {\n\treturn SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.UNION);\n};\nSnapIfNeededOverlayOp.intersection = function (g0, g1) {\n\treturn SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.INTERSECTION);\n};\nSnapIfNeededOverlayOp.symDifference = function (g0, g1) {\n\treturn SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE);\n};\nSnapIfNeededOverlayOp.difference = function (g0, g1) {\n\treturn SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.DIFFERENCE);\n};\n\nfunction InteriorPointArea() {\n\tthis._factory = null;\n\tthis._interiorPoint = null;\n\tthis._maxWidth = 0.0;\n\tvar g = arguments[0];\n\tthis._factory = g.getFactory();\n\tthis.add(g);\n}\nextend(InteriorPointArea.prototype, {\n\taddPolygon: function addPolygon(geometry) {\n\t\tif (geometry.isEmpty()) return null;\n\t\tvar intPt = null;\n\t\tvar width = 0;\n\t\tvar bisector = this.horizontalBisector(geometry);\n\t\tif (bisector.getLength() === 0.0) {\n\t\t\twidth = 0;\n\t\t\tintPt = bisector.getCoordinate();\n\t\t} else {\n\t\t\tvar intersections = SnapIfNeededOverlayOp.overlayOp(bisector, geometry, OverlayOp.INTERSECTION);\n\t\t\tvar widestIntersection = this.widestGeometry(intersections);\n\t\t\twidth = widestIntersection.getEnvelopeInternal().getWidth();\n\t\t\tintPt = InteriorPointArea.centre(widestIntersection.getEnvelopeInternal());\n\t\t}\n\t\tif (this._interiorPoint === null || width > this._maxWidth) {\n\t\t\tthis._interiorPoint = intPt;\n\t\t\tthis._maxWidth = width;\n\t\t}\n\t},\n\tgetInteriorPoint: function getInteriorPoint() {\n\t\treturn this._interiorPoint;\n\t},\n\twidestGeometry: function widestGeometry() {\n\t\tif (arguments[0] instanceof GeometryCollection) {\n\t\t\tvar gc = arguments[0];\n\t\t\tif (gc.isEmpty()) {\n\t\t\t\treturn gc;\n\t\t\t}\n\t\t\tvar widestGeometry = gc.getGeometryN(0);\n\t\t\tfor (var i = 1; i < gc.getNumGeometries(); i++) {\n\t\t\t\tif (gc.getGeometryN(i).getEnvelopeInternal().getWidth() > widestGeometry.getEnvelopeInternal().getWidth()) {\n\t\t\t\t\twidestGeometry = gc.getGeometryN(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn widestGeometry;\n\t\t} else if (arguments[0] instanceof Geometry) {\n\t\t\tvar geometry = arguments[0];\n\t\t\tif (!(geometry instanceof GeometryCollection)) {\n\t\t\t\treturn geometry;\n\t\t\t}\n\t\t\treturn this.widestGeometry(geometry);\n\t\t}\n\t},\n\thorizontalBisector: function horizontalBisector(geometry) {\n\t\tvar envelope = geometry.getEnvelopeInternal();\n\t\tvar bisectY = SafeBisectorFinder.getBisectorY(geometry);\n\t\treturn this._factory.createLineString([new Coordinate(envelope.getMinX(), bisectY), new Coordinate(envelope.getMaxX(), bisectY)]);\n\t},\n\tadd: function add(geom) {\n\t\tif (geom instanceof Polygon) {\n\t\t\tthis.addPolygon(geom);\n\t\t} else if (geom instanceof GeometryCollection) {\n\t\t\tvar gc = geom;\n\t\t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n\t\t\t\tthis.add(gc.getGeometryN(i));\n\t\t\t}\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn InteriorPointArea;\n\t}\n});\nInteriorPointArea.centre = function (envelope) {\n\treturn new Coordinate(InteriorPointArea.avg(envelope.getMinX(), envelope.getMaxX()), InteriorPointArea.avg(envelope.getMinY(), envelope.getMaxY()));\n};\nInteriorPointArea.avg = function (a, b) {\n\treturn (a + b) / 2.0;\n};\nfunction SafeBisectorFinder() {\n\tthis._poly = null;\n\tthis._centreY = null;\n\tthis._hiY = Double.MAX_VALUE;\n\tthis._loY = -Double.MAX_VALUE;\n\tvar poly = arguments[0];\n\tthis._poly = poly;\n\tthis._hiY = poly.getEnvelopeInternal().getMaxY();\n\tthis._loY = poly.getEnvelopeInternal().getMinY();\n\tthis._centreY = InteriorPointArea.avg(this._loY, this._hiY);\n}\nextend(SafeBisectorFinder.prototype, {\n\tupdateInterval: function updateInterval(y) {\n\t\tif (y <= this._centreY) {\n\t\t\tif (y > this._loY) this._loY = y;\n\t\t} else if (y > this._centreY) {\n\t\t\tif (y < this._hiY) {\n\t\t\t\tthis._hiY = y;\n\t\t\t}\n\t\t}\n\t},\n\tgetBisectorY: function getBisectorY() {\n\t\tthis.process(this._poly.getExteriorRing());\n\t\tfor (var i = 0; i < this._poly.getNumInteriorRing(); i++) {\n\t\t\tthis.process(this._poly.getInteriorRingN(i));\n\t\t}\n\t\tvar bisectY = InteriorPointArea.avg(this._hiY, this._loY);\n\t\treturn bisectY;\n\t},\n\tprocess: function process(line) {\n\t\tvar seq = line.getCoordinateSequence();\n\t\tfor (var i = 0; i < seq.size(); i++) {\n\t\t\tvar y = seq.getY(i);\n\t\t\tthis.updateInterval(y);\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn SafeBisectorFinder;\n\t}\n});\nSafeBisectorFinder.getBisectorY = function (poly) {\n\tvar finder = new SafeBisectorFinder(poly);\n\treturn finder.getBisectorY();\n};\nInteriorPointArea.SafeBisectorFinder = SafeBisectorFinder;\n\nfunction InteriorPointLine() {\n\tthis._centroid = null;\n\tthis._minDistance = Double.MAX_VALUE;\n\tthis._interiorPoint = null;\n\tvar g = arguments[0];\n\tthis._centroid = g.getCentroid().getCoordinate();\n\tthis.addInterior(g);\n\tif (this._interiorPoint === null) this.addEndpoints(g);\n}\nextend(InteriorPointLine.prototype, {\n\taddEndpoints: function addEndpoints() {\n\t\tif (arguments[0] instanceof Geometry) {\n\t\t\tvar geom = arguments[0];\n\t\t\tif (geom instanceof LineString) {\n\t\t\t\tthis.addEndpoints(geom.getCoordinates());\n\t\t\t} else if (geom instanceof GeometryCollection) {\n\t\t\t\tvar gc = geom;\n\t\t\t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n\t\t\t\t\tthis.addEndpoints(gc.getGeometryN(i));\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arguments[0] instanceof Array) {\n\t\t\tvar pts = arguments[0];\n\t\t\tthis.add(pts[0]);\n\t\t\tthis.add(pts[pts.length - 1]);\n\t\t}\n\t},\n\tgetInteriorPoint: function getInteriorPoint() {\n\t\treturn this._interiorPoint;\n\t},\n\taddInterior: function addInterior() {\n\t\tif (arguments[0] instanceof Geometry) {\n\t\t\tvar geom = arguments[0];\n\t\t\tif (geom instanceof LineString) {\n\t\t\t\tthis.addInterior(geom.getCoordinates());\n\t\t\t} else if (geom instanceof GeometryCollection) {\n\t\t\t\tvar gc = geom;\n\t\t\t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n\t\t\t\t\tthis.addInterior(gc.getGeometryN(i));\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arguments[0] instanceof Array) {\n\t\t\tvar pts = arguments[0];\n\t\t\tfor (var i = 1; i < pts.length - 1; i++) {\n\t\t\t\tthis.add(pts[i]);\n\t\t\t}\n\t\t}\n\t},\n\tadd: function add(point) {\n\t\tvar dist = point.distance(this._centroid);\n\t\tif (dist < this._minDistance) {\n\t\t\tthis._interiorPoint = new Coordinate(point);\n\t\t\tthis._minDistance = dist;\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn InteriorPointLine;\n\t}\n});\n\nfunction InteriorPointPoint() {\n\tthis._centroid = null;\n\tthis._minDistance = Double.MAX_VALUE;\n\tthis._interiorPoint = null;\n\tvar g = arguments[0];\n\tthis._centroid = g.getCentroid().getCoordinate();\n\tthis.add(g);\n}\nextend(InteriorPointPoint.prototype, {\n\tgetInteriorPoint: function getInteriorPoint() {\n\t\treturn this._interiorPoint;\n\t},\n\tadd: function add() {\n\t\tif (arguments[0] instanceof Geometry) {\n\t\t\tvar geom = arguments[0];\n\t\t\tif (geom instanceof Point) {\n\t\t\t\tthis.add(geom.getCoordinate());\n\t\t\t} else if (geom instanceof GeometryCollection) {\n\t\t\t\tvar gc = geom;\n\t\t\t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n\t\t\t\t\tthis.add(gc.getGeometryN(i));\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tvar point = arguments[0];\n\t\t\tvar dist = point.distance(this._centroid);\n\t\t\tif (dist < this._minDistance) {\n\t\t\t\tthis._interiorPoint = new Coordinate(point);\n\t\t\t\tthis._minDistance = dist;\n\t\t\t}\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn InteriorPointPoint;\n\t}\n});\n\nfunction MonotoneChainSelectAction() {\n\tthis.tempEnv1 = new Envelope();\n\tthis.selectedSegment = new LineSegment();\n}\nextend(MonotoneChainSelectAction.prototype, {\n\tselect: function select() {\n\t\tif (arguments.length === 1) {\n\t\t\t\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar mc = arguments[0],\n\t\t\t    startIndex = arguments[1];\n\t\t\tmc.getLineSegment(startIndex, this.selectedSegment);\n\t\t\tthis.select(this.selectedSegment);\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn MonotoneChainSelectAction;\n\t}\n});\n\nfunction NodeBase() {\n\tthis._items = new ArrayList();\n\tthis._subnode = [null, null];\n}\nextend(NodeBase.prototype, {\n\thasChildren: function hasChildren() {\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tif (this._subnode[i] !== null) return true;\n\t\t}\n\t\treturn false;\n\t},\n\tisPrunable: function isPrunable() {\n\t\treturn !(this.hasChildren() || this.hasItems());\n\t},\n\taddAllItems: function addAllItems(items) {\n\t\titems.addAll(this._items);\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tif (this._subnode[i] !== null) {\n\t\t\t\tthis._subnode[i].addAllItems(items);\n\t\t\t}\n\t\t}\n\t\treturn items;\n\t},\n\tsize: function size() {\n\t\tvar subSize = 0;\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tif (this._subnode[i] !== null) {\n\t\t\t\tsubSize += this._subnode[i].size();\n\t\t\t}\n\t\t}\n\t\treturn subSize + this._items.size();\n\t},\n\taddAllItemsFromOverlapping: function addAllItemsFromOverlapping(interval, resultItems) {\n\t\tif (interval !== null && !this.isSearchMatch(interval)) return null;\n\t\tresultItems.addAll(this._items);\n\t\tif (this._subnode[0] !== null) this._subnode[0].addAllItemsFromOverlapping(interval, resultItems);\n\t\tif (this._subnode[1] !== null) this._subnode[1].addAllItemsFromOverlapping(interval, resultItems);\n\t},\n\thasItems: function hasItems() {\n\t\treturn !this._items.isEmpty();\n\t},\n\tremove: function remove(itemInterval, item) {\n\t\tif (!this.isSearchMatch(itemInterval)) return false;\n\t\tvar found = false;\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tif (this._subnode[i] !== null) {\n\t\t\t\tfound = this._subnode[i].remove(itemInterval, item);\n\t\t\t\tif (found) {\n\t\t\t\t\tif (this._subnode[i].isPrunable()) this._subnode[i] = null;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (found) return found;\n\t\tfound = this._items.remove(item);\n\t\treturn found;\n\t},\n\tgetItems: function getItems() {\n\t\treturn this._items;\n\t},\n\tdepth: function depth() {\n\t\tvar maxSubDepth = 0;\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tif (this._subnode[i] !== null) {\n\t\t\t\tvar sqd = this._subnode[i].depth();\n\t\t\t\tif (sqd > maxSubDepth) maxSubDepth = sqd;\n\t\t\t}\n\t\t}\n\t\treturn maxSubDepth + 1;\n\t},\n\tnodeSize: function nodeSize() {\n\t\tvar subSize = 0;\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tif (this._subnode[i] !== null) {\n\t\t\t\tsubSize += this._subnode[i].nodeSize();\n\t\t\t}\n\t\t}\n\t\treturn subSize + 1;\n\t},\n\tadd: function add(item) {\n\t\tthis._items.add(item);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn NodeBase;\n\t}\n});\nNodeBase.getSubnodeIndex = function (interval, centre) {\n\tvar subnodeIndex = -1;\n\tif (interval.min >= centre) subnodeIndex = 1;\n\tif (interval.max <= centre) subnodeIndex = 0;\n\treturn subnodeIndex;\n};\n\nfunction Interval() {\n\tthis.min = null;\n\tthis.max = null;\n\tif (arguments.length === 0) {\n\t\tthis.min = 0.0;\n\t\tthis.max = 0.0;\n\t} else if (arguments.length === 1) {\n\t\tvar interval = arguments[0];\n\t\tthis.init(interval.min, interval.max);\n\t} else if (arguments.length === 2) {\n\t\tvar min = arguments[0],\n\t\t    max = arguments[1];\n\t\tthis.init(min, max);\n\t}\n}\nextend(Interval.prototype, {\n\texpandToInclude: function expandToInclude(interval) {\n\t\tif (interval.max > this.max) this.max = interval.max;\n\t\tif (interval.min < this.min) this.min = interval.min;\n\t},\n\tgetWidth: function getWidth() {\n\t\treturn this.max - this.min;\n\t},\n\toverlaps: function overlaps() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar interval = arguments[0];\n\t\t\treturn this.overlaps(interval.min, interval.max);\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar min = arguments[0],\n\t\t\t    max = arguments[1];\n\t\t\tif (this.min > max || this.max < min) return false;\n\t\t\treturn true;\n\t\t}\n\t},\n\tgetMin: function getMin() {\n\t\treturn this.min;\n\t},\n\ttoString: function toString() {\n\t\treturn \"[\" + this.min + \", \" + this.max + \"]\";\n\t},\n\tcontains: function contains() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Interval) {\n\t\t\t\tvar interval = arguments[0];\n\t\t\t\treturn this.contains(interval.min, interval.max);\n\t\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\t\tvar p = arguments[0];\n\t\t\t\treturn p >= this.min && p <= this.max;\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar min = arguments[0],\n\t\t\t    max = arguments[1];\n\t\t\treturn min >= this.min && max <= this.max;\n\t\t}\n\t},\n\tinit: function init(min, max) {\n\t\tthis.min = min;\n\t\tthis.max = max;\n\t\tif (min > max) {\n\t\t\tthis.min = max;\n\t\t\tthis.max = min;\n\t\t}\n\t},\n\tgetMax: function getMax() {\n\t\treturn this.max;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Interval;\n\t}\n});\n\nfunction DoubleBits() {}\nDoubleBits.exponent = function (d) {\n  return CVTFWD(64, d) - 1023;\n};\nDoubleBits.powerOf2 = function (exp) {\n  return Math.pow(2, exp);\n};\n\n/**\n * Calculates the exponent of the bit-pattern for a number. Uses code from:\n * http://www.merlyn.demon.co.uk/js-exact.htm\n *\n * @param {Number}\n *          NumW 32 or 64 to denote the number of bits.\n * @param {Number}\n *          Qty the number to calculate the bit pattern for.\n * @return {Number} The integer value of the exponent.\n */\nfunction CVTFWD(NumW, Qty) {\n  var Sign;\n  var Expo;\n  var Mant;\n  var Bin;\n  var Inf = {\n    32: {\n      d: 0x7F,\n      c: 0x80,\n      b: 0,\n      a: 0\n    },\n    64: {\n      d: 0x7FF0,\n      c: 0,\n      b: 0,\n      a: 0\n    }\n  };\n  var ExW = {\n    32: 8,\n    64: 11\n  }[NumW];\n\n  if (!Bin) {\n    Sign = Qty < 0 || 1 / Qty < 0; // OK for +-0\n    if (!isFinite(Qty)) {\n      Bin = Inf[NumW];\n      if (Sign) {\n        Bin.d += 1 << NumW / 4 - 1;\n      }\n      Expo = Math.pow(2, ExW) - 1;\n      Mant = 0;\n    }\n  }\n\n  if (!Bin) {\n    Expo = {\n      32: 127,\n      64: 1023\n    }[NumW];\n    Mant = Math.abs(Qty);\n    while (Mant >= 2) {\n      Expo++;\n      Mant /= 2;\n    }\n    while (Mant < 1 && Expo > 0) {\n      Expo--;\n      Mant *= 2;\n    }\n    if (Expo <= 0) {\n      Mant /= 2;\n    }\n    if (NumW === 32 && Expo > 254) {\n      Bin = {\n        d: Sign ? 0xFF : 0x7F,\n        c: 0x80,\n        b: 0,\n        a: 0\n      };\n      Expo = Math.pow(2, ExW) - 1;\n      Mant = 0;\n    }\n  }\n\n  return Expo;\n}\n\nfunction Key() {\n\tthis._pt = 0.0;\n\tthis._level = 0;\n\tthis._interval = null;\n\tvar interval = arguments[0];\n\tthis.computeKey(interval);\n}\nextend(Key.prototype, {\n\tgetInterval: function getInterval() {\n\t\treturn this._interval;\n\t},\n\tgetLevel: function getLevel() {\n\t\treturn this._level;\n\t},\n\tcomputeKey: function computeKey(itemInterval) {\n\t\tthis._level = Key.computeLevel(itemInterval);\n\t\tthis._interval = new Interval();\n\t\tthis.computeInterval(this._level, itemInterval);\n\t\twhile (!this._interval.contains(itemInterval)) {\n\t\t\tthis._level += 1;\n\t\t\tthis.computeInterval(this._level, itemInterval);\n\t\t}\n\t},\n\tcomputeInterval: function computeInterval(level, itemInterval) {\n\t\tvar size = DoubleBits.powerOf2(level);\n\t\tthis._pt = Math.floor(itemInterval.getMin() / size) * size;\n\t\tthis._interval.init(this._pt, this._pt + size);\n\t},\n\tgetPoint: function getPoint() {\n\t\treturn this._pt;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Key;\n\t}\n});\nKey.computeLevel = function (interval) {\n\tvar dx = interval.getWidth();\n\tvar level = DoubleBits.exponent(dx) + 1;\n\treturn level;\n};\n\nfunction Node$1() {\n\tNodeBase.apply(this);\n\tthis._interval = null;\n\tthis._centre = null;\n\tthis._level = null;\n\tvar interval = arguments[0],\n\t    level = arguments[1];\n\tthis._interval = interval;\n\tthis._level = level;\n\tthis._centre = (interval.getMin() + interval.getMax()) / 2;\n}\ninherits$1(Node$1, NodeBase);\nextend(Node$1.prototype, {\n\tgetInterval: function getInterval() {\n\t\treturn this._interval;\n\t},\n\tfind: function find(searchInterval) {\n\t\tvar subnodeIndex = NodeBase.getSubnodeIndex(searchInterval, this._centre);\n\t\tif (subnodeIndex === -1) return this;\n\t\tif (this._subnode[subnodeIndex] !== null) {\n\t\t\tvar node = this._subnode[subnodeIndex];\n\t\t\treturn node.find(searchInterval);\n\t\t}\n\t\treturn this;\n\t},\n\tinsert: function insert(node) {\n\t\tAssert.isTrue(this._interval === null || this._interval.contains(node._interval));\n\t\tvar index = NodeBase.getSubnodeIndex(node._interval, this._centre);\n\t\tif (node._level === this._level - 1) {\n\t\t\tthis._subnode[index] = node;\n\t\t} else {\n\t\t\tvar childNode = this.createSubnode(index);\n\t\t\tchildNode.insert(node);\n\t\t\tthis._subnode[index] = childNode;\n\t\t}\n\t},\n\tisSearchMatch: function isSearchMatch(itemInterval) {\n\t\treturn itemInterval.overlaps(this._interval);\n\t},\n\tgetSubnode: function getSubnode(index) {\n\t\tif (this._subnode[index] === null) {\n\t\t\tthis._subnode[index] = this.createSubnode(index);\n\t\t}\n\t\treturn this._subnode[index];\n\t},\n\tgetNode: function getNode(searchInterval) {\n\t\tvar subnodeIndex = NodeBase.getSubnodeIndex(searchInterval, this._centre);\n\t\tif (subnodeIndex !== -1) {\n\t\t\tvar node = this.getSubnode(subnodeIndex);\n\t\t\treturn node.getNode(searchInterval);\n\t\t} else {\n\t\t\treturn this;\n\t\t}\n\t},\n\tcreateSubnode: function createSubnode(index) {\n\t\tvar min = 0.0;\n\t\tvar max = 0.0;\n\t\tswitch (index) {\n\t\t\tcase 0:\n\t\t\t\tmin = this._interval.getMin();\n\t\t\t\tmax = this._centre;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tmin = this._centre;\n\t\t\t\tmax = this._interval.getMax();\n\t\t\t\tbreak;\n\t\t}\n\t\tvar subInt = new Interval(min, max);\n\t\tvar node = new Node$1(subInt, this._level - 1);\n\t\treturn node;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Node$1;\n\t}\n});\nNode$1.createNode = function (itemInterval) {\n\tvar key = new Key(itemInterval);\n\tvar node = new Node$1(key.getInterval(), key.getLevel());\n\treturn node;\n};\nNode$1.createExpanded = function (node, addInterval) {\n\tvar expandInt = new Interval(addInterval);\n\tif (node !== null) expandInt.expandToInclude(node._interval);\n\tvar largerNode = Node$1.createNode(expandInt);\n\tif (node !== null) largerNode.insert(node);\n\treturn largerNode;\n};\n\nfunction IntervalSize() {}\nextend(IntervalSize.prototype, {\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn IntervalSize;\n\t}\n});\nIntervalSize.isZeroWidth = function (min, max) {\n\tvar width = max - min;\n\tif (width === 0.0) return true;\n\tvar maxAbs = Math.max(Math.abs(min), Math.abs(max));\n\tvar scaledInterval = width / maxAbs;\n\tvar level = DoubleBits.exponent(scaledInterval);\n\treturn level <= IntervalSize.MIN_BINARY_EXPONENT;\n};\nIntervalSize.MIN_BINARY_EXPONENT = -50;\n\nfunction Root() {\n\tNodeBase.apply(this);\n}\ninherits$1(Root, NodeBase);\nextend(Root.prototype, {\n\tinsert: function insert(itemInterval, item) {\n\t\tvar index = NodeBase.getSubnodeIndex(itemInterval, Root.origin);\n\t\tif (index === -1) {\n\t\t\tthis.add(item);\n\t\t\treturn null;\n\t\t}\n\t\tvar node = this._subnode[index];\n\t\tif (node === null || !node.getInterval().contains(itemInterval)) {\n\t\t\tvar largerNode = Node$1.createExpanded(node, itemInterval);\n\t\t\tthis._subnode[index] = largerNode;\n\t\t}\n\t\tthis.insertContained(this._subnode[index], itemInterval, item);\n\t},\n\tisSearchMatch: function isSearchMatch(interval) {\n\t\treturn true;\n\t},\n\tinsertContained: function insertContained(tree, itemInterval, item) {\n\t\tAssert.isTrue(tree.getInterval().contains(itemInterval));\n\t\tvar isZeroArea = IntervalSize.isZeroWidth(itemInterval.getMin(), itemInterval.getMax());\n\t\tvar node = null;\n\t\tif (isZeroArea) node = tree.find(itemInterval);else node = tree.getNode(itemInterval);\n\t\tnode.add(item);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Root;\n\t}\n});\nRoot.origin = 0.0;\n\nfunction Bintree() {\n\tthis._root = null;\n\tthis._minExtent = 1.0;\n\tthis._root = new Root();\n}\nextend(Bintree.prototype, {\n\tsize: function size() {\n\t\tif (this._root !== null) return this._root.size();\n\t\treturn 0;\n\t},\n\tinsert: function insert(itemInterval, item) {\n\t\tthis.collectStats(itemInterval);\n\t\tvar insertInterval = Bintree.ensureExtent(itemInterval, this._minExtent);\n\t\tthis._root.insert(insertInterval, item);\n\t},\n\tquery: function query() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (typeof arguments[0] === \"number\") {\n\t\t\t\tvar x = arguments[0];\n\t\t\t\treturn this.query(new Interval(x, x));\n\t\t\t} else if (arguments[0] instanceof Interval) {\n\t\t\t\tvar interval = arguments[0];\n\t\t\t\tvar foundItems = new ArrayList();\n\t\t\t\tthis.query(interval, foundItems);\n\t\t\t\treturn foundItems;\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar interval = arguments[0],\n\t\t\t    foundItems = arguments[1];\n\t\t\tthis._root.addAllItemsFromOverlapping(interval, foundItems);\n\t\t}\n\t},\n\titerator: function iterator() {\n\t\tvar foundItems = new ArrayList();\n\t\tthis._root.addAllItems(foundItems);\n\t\treturn foundItems.iterator();\n\t},\n\tremove: function remove(itemInterval, item) {\n\t\tvar insertInterval = Bintree.ensureExtent(itemInterval, this._minExtent);\n\t\treturn this._root.remove(insertInterval, item);\n\t},\n\tcollectStats: function collectStats(interval) {\n\t\tvar del = interval.getWidth();\n\t\tif (del < this._minExtent && del > 0.0) this._minExtent = del;\n\t},\n\tdepth: function depth() {\n\t\tif (this._root !== null) return this._root.depth();\n\t\treturn 0;\n\t},\n\tnodeSize: function nodeSize() {\n\t\tif (this._root !== null) return this._root.nodeSize();\n\t\treturn 0;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Bintree;\n\t}\n});\nBintree.ensureExtent = function (itemInterval, minExtent) {\n\tvar min = itemInterval.getMin();\n\tvar max = itemInterval.getMax();\n\tif (min !== max) return itemInterval;\n\tif (min === max) {\n\t\tmin = min - minExtent / 2.0;\n\t\tmax = min + minExtent / 2.0;\n\t}\n\treturn new Interval(min, max);\n};\n\nfunction PointInRing() {}\nextend(PointInRing.prototype, {\n\tisInside: function isInside(pt) {},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn PointInRing;\n\t}\n});\n\nfunction MCPointInRing() {\n\tthis._ring = null;\n\tthis._tree = null;\n\tthis._crossings = 0;\n\tthis._interval = new Interval();\n\tvar ring = arguments[0];\n\tthis._ring = ring;\n\tthis.buildIndex();\n}\nextend(MCPointInRing.prototype, {\n\ttestLineSegment: function testLineSegment(p, seg) {\n\t\tvar xInt = null;\n\t\tvar x1 = null;\n\t\tvar y1 = null;\n\t\tvar x2 = null;\n\t\tvar y2 = null;\n\t\tvar p1 = seg.p0;\n\t\tvar p2 = seg.p1;\n\t\tx1 = p1.x - p.x;\n\t\ty1 = p1.y - p.y;\n\t\tx2 = p2.x - p.x;\n\t\ty2 = p2.y - p.y;\n\t\tif (y1 > 0 && y2 <= 0 || y2 > 0 && y1 <= 0) {\n\t\t\txInt = RobustDeterminant.signOfDet2x2(x1, y1, x2, y2) / (y2 - y1);\n\t\t\tif (0.0 < xInt) {\n\t\t\t\tthis._crossings++;\n\t\t\t}\n\t\t}\n\t},\n\tbuildIndex: function buildIndex() {\n\t\tthis._tree = new Bintree();\n\t\tvar pts = CoordinateArrays.removeRepeatedPoints(this._ring.getCoordinates());\n\t\tvar mcList = MonotoneChainBuilder.getChains(pts);\n\t\tfor (var i = 0; i < mcList.size(); i++) {\n\t\t\tvar mc = mcList.get(i);\n\t\t\tvar mcEnv = mc.getEnvelope();\n\t\t\tthis._interval.min = mcEnv.getMinY();\n\t\t\tthis._interval.max = mcEnv.getMaxY();\n\t\t\tthis._tree.insert(this._interval, mc);\n\t\t}\n\t},\n\ttestMonotoneChain: function testMonotoneChain(rayEnv, mcSelecter, mc) {\n\t\tmc.select(rayEnv, mcSelecter);\n\t},\n\tisInside: function isInside(pt) {\n\t\tthis._crossings = 0;\n\t\tvar rayEnv = new Envelope(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, pt.y, pt.y);\n\t\tthis._interval.min = pt.y;\n\t\tthis._interval.max = pt.y;\n\t\tvar segs = this._tree.query(this._interval);\n\t\tvar mcSelecter = new MCSelecter(this, pt);\n\t\tfor (var i = segs.iterator(); i.hasNext();) {\n\t\t\tvar mc = i.next();\n\t\t\tthis.testMonotoneChain(rayEnv, mcSelecter, mc);\n\t\t}\n\t\tif (this._crossings % 2 === 1) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [PointInRing];\n\t},\n\tgetClass: function getClass() {\n\t\treturn MCPointInRing;\n\t}\n});\nfunction MCSelecter() {\n\tMonotoneChainSelectAction.apply(this);\n\tthis.mcp = null;\n\tthis.p = null;\n\tvar mcp = arguments[0],\n\t    p = arguments[1];\n\tthis.mcp = mcp;\n\tthis.p = p;\n}\ninherits$1(MCSelecter, MonotoneChainSelectAction);\nextend(MCSelecter.prototype, {\n\tselect: function select() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar ls = arguments[0];\n\t\t\tthis.mcp.testLineSegment(this.p, ls);\n\t\t} else return MonotoneChainSelectAction.prototype.select.apply(this, arguments);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn MCSelecter;\n\t}\n});\nMCPointInRing.MCSelecter = MCSelecter;\n\nfunction Angle() {}\nextend(Angle.prototype, {\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Angle;\n\t}\n});\nAngle.toDegrees = function (radians) {\n\treturn radians * 180 / Math.PI;\n};\nAngle.normalize = function (angle) {\n\twhile (angle > Math.PI) {\n\t\tangle -= Angle.PI_TIMES_2;\n\t}while (angle <= -Math.PI) {\n\t\tangle += Angle.PI_TIMES_2;\n\t}return angle;\n};\nAngle.angle = function () {\n\tif (arguments.length === 1) {\n\t\tvar p = arguments[0];\n\t\treturn Math.atan2(p.y, p.x);\n\t} else if (arguments.length === 2) {\n\t\tvar p0 = arguments[0],\n\t\t    p1 = arguments[1];\n\t\tvar dx = p1.x - p0.x;\n\t\tvar dy = p1.y - p0.y;\n\t\treturn Math.atan2(dy, dx);\n\t}\n};\nAngle.isAcute = function (p0, p1, p2) {\n\tvar dx0 = p0.x - p1.x;\n\tvar dy0 = p0.y - p1.y;\n\tvar dx1 = p2.x - p1.x;\n\tvar dy1 = p2.y - p1.y;\n\tvar dotprod = dx0 * dx1 + dy0 * dy1;\n\treturn dotprod > 0;\n};\nAngle.isObtuse = function (p0, p1, p2) {\n\tvar dx0 = p0.x - p1.x;\n\tvar dy0 = p0.y - p1.y;\n\tvar dx1 = p2.x - p1.x;\n\tvar dy1 = p2.y - p1.y;\n\tvar dotprod = dx0 * dx1 + dy0 * dy1;\n\treturn dotprod < 0;\n};\nAngle.interiorAngle = function (p0, p1, p2) {\n\tvar anglePrev = Angle.angle(p1, p0);\n\tvar angleNext = Angle.angle(p1, p2);\n\treturn Math.abs(angleNext - anglePrev);\n};\nAngle.normalizePositive = function (angle) {\n\tif (angle < 0.0) {\n\t\twhile (angle < 0.0) {\n\t\t\tangle += Angle.PI_TIMES_2;\n\t\t}if (angle >= Angle.PI_TIMES_2) angle = 0.0;\n\t} else {\n\t\twhile (angle >= Angle.PI_TIMES_2) {\n\t\t\tangle -= Angle.PI_TIMES_2;\n\t\t}if (angle < 0.0) angle = 0.0;\n\t}\n\treturn angle;\n};\nAngle.angleBetween = function (tip1, tail, tip2) {\n\tvar a1 = Angle.angle(tail, tip1);\n\tvar a2 = Angle.angle(tail, tip2);\n\treturn Angle.diff(a1, a2);\n};\nAngle.diff = function (ang1, ang2) {\n\tvar delAngle = null;\n\tif (ang1 < ang2) {\n\t\tdelAngle = ang2 - ang1;\n\t} else {\n\t\tdelAngle = ang1 - ang2;\n\t}\n\tif (delAngle > Math.PI) {\n\t\tdelAngle = 2 * Math.PI - delAngle;\n\t}\n\treturn delAngle;\n};\nAngle.toRadians = function (angleDegrees) {\n\treturn angleDegrees * Math.PI / 180.0;\n};\nAngle.getTurn = function (ang1, ang2) {\n\tvar crossproduct = Math.sin(ang2 - ang1);\n\tif (crossproduct > 0) {\n\t\treturn Angle.COUNTERCLOCKWISE;\n\t}\n\tif (crossproduct < 0) {\n\t\treturn Angle.CLOCKWISE;\n\t}\n\treturn Angle.NONE;\n};\nAngle.angleBetweenOriented = function (tip1, tail, tip2) {\n\tvar a1 = Angle.angle(tail, tip1);\n\tvar a2 = Angle.angle(tail, tip2);\n\tvar angDel = a2 - a1;\n\tif (angDel <= -Math.PI) return angDel + Angle.PI_TIMES_2;\n\tif (angDel > Math.PI) return angDel - Angle.PI_TIMES_2;\n\treturn angDel;\n};\nAngle.PI_TIMES_2 = 2.0 * Math.PI;\nAngle.PI_OVER_2 = Math.PI / 2.0;\nAngle.PI_OVER_4 = Math.PI / 4.0;\nAngle.COUNTERCLOCKWISE = CGAlgorithms.COUNTERCLOCKWISE;\nAngle.CLOCKWISE = CGAlgorithms.CLOCKWISE;\nAngle.NONE = CGAlgorithms.COLLINEAR;\n\nfunction Triangle$1() {\n\tthis.p0 = null;\n\tthis.p1 = null;\n\tthis.p2 = null;\n\tvar p0 = arguments[0],\n\t    p1 = arguments[1],\n\t    p2 = arguments[2];\n\tthis.p0 = p0;\n\tthis.p1 = p1;\n\tthis.p2 = p2;\n}\nextend(Triangle$1.prototype, {\n\tarea: function area() {\n\t\treturn Triangle$1.area(this.p0, this.p1, this.p2);\n\t},\n\tsignedArea: function signedArea() {\n\t\treturn Triangle$1.signedArea(this.p0, this.p1, this.p2);\n\t},\n\tinterpolateZ: function interpolateZ(p) {\n\t\tif (p === null) throw new IllegalArgumentException(\"Supplied point is null.\");\n\t\treturn Triangle$1.interpolateZ(p, this.p0, this.p1, this.p2);\n\t},\n\tlongestSideLength: function longestSideLength() {\n\t\treturn Triangle$1.longestSideLength(this.p0, this.p1, this.p2);\n\t},\n\tisAcute: function isAcute() {\n\t\treturn Triangle$1.isAcute(this.p0, this.p1, this.p2);\n\t},\n\tcircumcentre: function circumcentre() {\n\t\treturn Triangle$1.circumcentre(this.p0, this.p1, this.p2);\n\t},\n\tarea3D: function area3D() {\n\t\treturn Triangle$1.area3D(this.p0, this.p1, this.p2);\n\t},\n\tcentroid: function centroid() {\n\t\treturn Triangle$1.centroid(this.p0, this.p1, this.p2);\n\t},\n\tinCentre: function inCentre() {\n\t\treturn Triangle$1.inCentre(this.p0, this.p1, this.p2);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Triangle$1;\n\t}\n});\nTriangle$1.area = function (a, b, c) {\n\treturn Math.abs(((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2);\n};\nTriangle$1.signedArea = function (a, b, c) {\n\treturn ((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2;\n};\nTriangle$1.det = function (m00, m01, m10, m11) {\n\treturn m00 * m11 - m01 * m10;\n};\nTriangle$1.interpolateZ = function (p, v0, v1, v2) {\n\tvar x0 = v0.x;\n\tvar y0 = v0.y;\n\tvar a = v1.x - x0;\n\tvar b = v2.x - x0;\n\tvar c = v1.y - y0;\n\tvar d = v2.y - y0;\n\tvar det = a * d - b * c;\n\tvar dx = p.x - x0;\n\tvar dy = p.y - y0;\n\tvar t = (d * dx - b * dy) / det;\n\tvar u = (-c * dx + a * dy) / det;\n\tvar z = v0.z + t * (v1.z - v0.z) + u * (v2.z - v0.z);\n\treturn z;\n};\nTriangle$1.longestSideLength = function (a, b, c) {\n\tvar lenAB = a.distance(b);\n\tvar lenBC = b.distance(c);\n\tvar lenCA = c.distance(a);\n\tvar maxLen = lenAB;\n\tif (lenBC > maxLen) maxLen = lenBC;\n\tif (lenCA > maxLen) maxLen = lenCA;\n\treturn maxLen;\n};\nTriangle$1.isAcute = function (a, b, c) {\n\tif (!Angle.isAcute(a, b, c)) return false;\n\tif (!Angle.isAcute(b, c, a)) return false;\n\tif (!Angle.isAcute(c, a, b)) return false;\n\treturn true;\n};\nTriangle$1.circumcentre = function (a, b, c) {\n\tvar cx = c.x;\n\tvar cy = c.y;\n\tvar ax = a.x - cx;\n\tvar ay = a.y - cy;\n\tvar bx = b.x - cx;\n\tvar by = b.y - cy;\n\tvar denom = 2 * Triangle$1.det(ax, ay, bx, by);\n\tvar numx = Triangle$1.det(ay, ax * ax + ay * ay, by, bx * bx + by * by);\n\tvar numy = Triangle$1.det(ax, ax * ax + ay * ay, bx, bx * bx + by * by);\n\tvar ccx = cx - numx / denom;\n\tvar ccy = cy + numy / denom;\n\treturn new Coordinate(ccx, ccy);\n};\nTriangle$1.perpendicularBisector = function (a, b) {\n\tvar dx = b.x - a.x;\n\tvar dy = b.y - a.y;\n\tvar l1 = new HCoordinate(a.x + dx / 2.0, a.y + dy / 2.0, 1.0);\n\tvar l2 = new HCoordinate(a.x - dy + dx / 2.0, a.y + dx + dy / 2.0, 1.0);\n\treturn new HCoordinate(l1, l2);\n};\nTriangle$1.angleBisector = function (a, b, c) {\n\tvar len0 = b.distance(a);\n\tvar len2 = b.distance(c);\n\tvar frac = len0 / (len0 + len2);\n\tvar dx = c.x - a.x;\n\tvar dy = c.y - a.y;\n\tvar splitPt = new Coordinate(a.x + frac * dx, a.y + frac * dy);\n\treturn splitPt;\n};\nTriangle$1.area3D = function (a, b, c) {\n\tvar ux = b.x - a.x;\n\tvar uy = b.y - a.y;\n\tvar uz = b.z - a.z;\n\tvar vx = c.x - a.x;\n\tvar vy = c.y - a.y;\n\tvar vz = c.z - a.z;\n\tvar crossx = uy * vz - uz * vy;\n\tvar crossy = uz * vx - ux * vz;\n\tvar crossz = ux * vy - uy * vx;\n\tvar absSq = crossx * crossx + crossy * crossy + crossz * crossz;\n\tvar area3D = Math.sqrt(absSq) / 2;\n\treturn area3D;\n};\nTriangle$1.centroid = function (a, b, c) {\n\tvar x = (a.x + b.x + c.x) / 3;\n\tvar y = (a.y + b.y + c.y) / 3;\n\treturn new Coordinate(x, y);\n};\nTriangle$1.inCentre = function (a, b, c) {\n\tvar len0 = b.distance(c);\n\tvar len1 = a.distance(c);\n\tvar len2 = a.distance(b);\n\tvar circum = len0 + len1 + len2;\n\tvar inCentreX = (len0 * a.x + len1 * b.x + len2 * c.x) / circum;\n\tvar inCentreY = (len0 * a.y + len1 * b.y + len2 * c.y) / circum;\n\treturn new Coordinate(inCentreX, inCentreY);\n};\n\nfunction MinimumBoundingCircle() {\n\tthis._input = null;\n\tthis._extremalPts = null;\n\tthis._centre = null;\n\tthis._radius = 0.0;\n\tvar geom = arguments[0];\n\tthis._input = geom;\n}\nextend(MinimumBoundingCircle.prototype, {\n\tgetRadius: function getRadius() {\n\t\tthis.compute();\n\t\treturn this._radius;\n\t},\n\tgetDiameter: function getDiameter() {\n\t\tthis.compute();\n\t\tswitch (this._extremalPts.length) {\n\t\t\tcase 0:\n\t\t\t\treturn this._input.getFactory().createLineString();\n\t\t\tcase 1:\n\t\t\t\treturn this._input.getFactory().createPoint(this._centre);\n\t\t}\n\t\tvar p0 = this._extremalPts[0];\n\t\tvar p1 = this._extremalPts[1];\n\t\treturn this._input.getFactory().createLineString([p0, p1]);\n\t},\n\tgetExtremalPoints: function getExtremalPoints() {\n\t\tthis.compute();\n\t\treturn this._extremalPts;\n\t},\n\tcomputeCirclePoints: function computeCirclePoints() {\n\t\tif (this._input.isEmpty()) {\n\t\t\tthis._extremalPts = new Array(0).fill(null);\n\t\t\treturn null;\n\t\t}\n\t\tif (this._input.getNumPoints() === 1) {\n\t\t\tvar pts = this._input.getCoordinates();\n\t\t\tthis._extremalPts = [new Coordinate(pts[0])];\n\t\t\treturn null;\n\t\t}\n\t\tvar convexHull = this._input.convexHull();\n\t\tvar hullPts = convexHull.getCoordinates();\n\t\tvar pts = hullPts;\n\t\tif (hullPts[0].equals2D(hullPts[hullPts.length - 1])) {\n\t\t\tpts = new Array(hullPts.length - 1).fill(null);\n\t\t\tCoordinateArrays.copyDeep(hullPts, 0, pts, 0, hullPts.length - 1);\n\t\t}\n\t\tif (pts.length <= 2) {\n\t\t\tthis._extremalPts = CoordinateArrays.copyDeep(pts);\n\t\t\treturn null;\n\t\t}\n\t\tvar P = MinimumBoundingCircle.lowestPoint(pts);\n\t\tvar Q = MinimumBoundingCircle.pointWitMinAngleWithX(pts, P);\n\t\tfor (var i = 0; i < pts.length; i++) {\n\t\t\tvar R = MinimumBoundingCircle.pointWithMinAngleWithSegment(pts, P, Q);\n\t\t\tif (Angle.isObtuse(P, R, Q)) {\n\t\t\t\tthis._extremalPts = [new Coordinate(P), new Coordinate(Q)];\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (Angle.isObtuse(R, P, Q)) {\n\t\t\t\tP = R;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Angle.isObtuse(R, Q, P)) {\n\t\t\t\tQ = R;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis._extremalPts = [new Coordinate(P), new Coordinate(Q), new Coordinate(R)];\n\t\t\treturn null;\n\t\t}\n\t\tAssert.shouldNeverReachHere(\"Logic failure in Minimum Bounding Circle algorithm!\");\n\t},\n\tcompute: function compute() {\n\t\tif (this._extremalPts !== null) return null;\n\t\tthis.computeCirclePoints();\n\t\tthis.computeCentre();\n\t\tif (this._centre !== null) this._radius = this._centre.distance(this._extremalPts[0]);\n\t},\n\tgetFarthestPoints: function getFarthestPoints() {\n\t\tthis.compute();\n\t\tswitch (this._extremalPts.length) {\n\t\t\tcase 0:\n\t\t\t\treturn this._input.getFactory().createLineString();\n\t\t\tcase 1:\n\t\t\t\treturn this._input.getFactory().createPoint(this._centre);\n\t\t}\n\t\tvar p0 = this._extremalPts[0];\n\t\tvar p1 = this._extremalPts[this._extremalPts.length - 1];\n\t\treturn this._input.getFactory().createLineString([p0, p1]);\n\t},\n\tgetCircle: function getCircle() {\n\t\tthis.compute();\n\t\tif (this._centre === null) return this._input.getFactory().createPolygon();\n\t\tvar centrePoint = this._input.getFactory().createPoint(this._centre);\n\t\tif (this._radius === 0.0) return centrePoint;\n\t\treturn centrePoint.buffer(this._radius);\n\t},\n\tgetCentre: function getCentre() {\n\t\tthis.compute();\n\t\treturn this._centre;\n\t},\n\tcomputeCentre: function computeCentre() {\n\t\tswitch (this._extremalPts.length) {\n\t\t\tcase 0:\n\t\t\t\tthis._centre = null;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tthis._centre = this._extremalPts[0];\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tthis._centre = new Coordinate((this._extremalPts[0].x + this._extremalPts[1].x) / 2.0, (this._extremalPts[0].y + this._extremalPts[1].y) / 2.0);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tthis._centre = Triangle$1.circumcentre(this._extremalPts[0], this._extremalPts[1], this._extremalPts[2]);\n\t\t\t\tbreak;\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn MinimumBoundingCircle;\n\t}\n});\nMinimumBoundingCircle.pointWitMinAngleWithX = function (pts, P) {\n\tvar minSin = Double.MAX_VALUE;\n\tvar minAngPt = null;\n\tfor (var i = 0; i < pts.length; i++) {\n\t\tvar p = pts[i];\n\t\tif (p === P) continue;\n\t\tvar dx = p.x - P.x;\n\t\tvar dy = p.y - P.y;\n\t\tif (dy < 0) dy = -dy;\n\t\tvar len = Math.sqrt(dx * dx + dy * dy);\n\t\tvar sin = dy / len;\n\t\tif (sin < minSin) {\n\t\t\tminSin = sin;\n\t\t\tminAngPt = p;\n\t\t}\n\t}\n\treturn minAngPt;\n};\nMinimumBoundingCircle.lowestPoint = function (pts) {\n\tvar min = pts[0];\n\tfor (var i = 1; i < pts.length; i++) {\n\t\tif (pts[i].y < min.y) min = pts[i];\n\t}\n\treturn min;\n};\nMinimumBoundingCircle.pointWithMinAngleWithSegment = function (pts, P, Q) {\n\tvar minAng = Double.MAX_VALUE;\n\tvar minAngPt = null;\n\tfor (var i = 0; i < pts.length; i++) {\n\t\tvar p = pts[i];\n\t\tif (p === P) continue;\n\t\tif (p === Q) continue;\n\t\tvar ang = Angle.angleBetween(P, p, Q);\n\t\tif (ang < minAng) {\n\t\t\tminAng = ang;\n\t\t\tminAngPt = p;\n\t\t}\n\t}\n\treturn minAngPt;\n};\n\nfunction MinimumDiameter() {\n\tthis._inputGeom = null;\n\tthis._isConvex = null;\n\tthis._convexHullPts = null;\n\tthis._minBaseSeg = new LineSegment();\n\tthis._minWidthPt = null;\n\tthis._minPtIndex = null;\n\tthis._minWidth = 0.0;\n\tif (arguments.length === 1) {\n\t\tvar inputGeom = arguments[0];\n\t\tMinimumDiameter.call(this, inputGeom, false);\n\t} else if (arguments.length === 2) {\n\t\tvar inputGeom = arguments[0],\n\t\t    isConvex = arguments[1];\n\t\tthis._inputGeom = inputGeom;\n\t\tthis._isConvex = isConvex;\n\t}\n}\nextend(MinimumDiameter.prototype, {\n\tgetWidthCoordinate: function getWidthCoordinate() {\n\t\tthis.computeMinimumDiameter();\n\t\treturn this._minWidthPt;\n\t},\n\tgetSupportingSegment: function getSupportingSegment() {\n\t\tthis.computeMinimumDiameter();\n\t\treturn this._inputGeom.getFactory().createLineString([this._minBaseSeg.p0, this._minBaseSeg.p1]);\n\t},\n\tgetDiameter: function getDiameter() {\n\t\tthis.computeMinimumDiameter();\n\t\tif (this._minWidthPt === null) return this._inputGeom.getFactory().createLineString(null);\n\t\tvar basePt = this._minBaseSeg.project(this._minWidthPt);\n\t\treturn this._inputGeom.getFactory().createLineString([basePt, this._minWidthPt]);\n\t},\n\tcomputeWidthConvex: function computeWidthConvex(convexGeom) {\n\t\tif (convexGeom instanceof Polygon) this._convexHullPts = convexGeom.getExteriorRing().getCoordinates();else this._convexHullPts = convexGeom.getCoordinates();\n\t\tif (this._convexHullPts.length === 0) {\n\t\t\tthis._minWidth = 0.0;\n\t\t\tthis._minWidthPt = null;\n\t\t\tthis._minBaseSeg = null;\n\t\t} else if (this._convexHullPts.length === 1) {\n\t\t\tthis._minWidth = 0.0;\n\t\t\tthis._minWidthPt = this._convexHullPts[0];\n\t\t\tthis._minBaseSeg.p0 = this._convexHullPts[0];\n\t\t\tthis._minBaseSeg.p1 = this._convexHullPts[0];\n\t\t} else if (this._convexHullPts.length === 2 || this._convexHullPts.length === 3) {\n\t\t\tthis._minWidth = 0.0;\n\t\t\tthis._minWidthPt = this._convexHullPts[0];\n\t\t\tthis._minBaseSeg.p0 = this._convexHullPts[0];\n\t\t\tthis._minBaseSeg.p1 = this._convexHullPts[1];\n\t\t} else this.computeConvexRingMinDiameter(this._convexHullPts);\n\t},\n\tcomputeConvexRingMinDiameter: function computeConvexRingMinDiameter(pts) {\n\t\tthis._minWidth = Double.MAX_VALUE;\n\t\tvar currMaxIndex = 1;\n\t\tvar seg = new LineSegment();\n\t\tfor (var i = 0; i < pts.length - 1; i++) {\n\t\t\tseg.p0 = pts[i];\n\t\t\tseg.p1 = pts[i + 1];\n\t\t\tcurrMaxIndex = this.findMaxPerpDistance(pts, seg, currMaxIndex);\n\t\t}\n\t},\n\tcomputeMinimumDiameter: function computeMinimumDiameter() {\n\t\tif (this._minWidthPt !== null) return null;\n\t\tif (this._isConvex) this.computeWidthConvex(this._inputGeom);else {\n\t\t\tvar convexGeom = new ConvexHull(this._inputGeom).getConvexHull();\n\t\t\tthis.computeWidthConvex(convexGeom);\n\t\t}\n\t},\n\tgetLength: function getLength() {\n\t\tthis.computeMinimumDiameter();\n\t\treturn this._minWidth;\n\t},\n\tfindMaxPerpDistance: function findMaxPerpDistance(pts, seg, startIndex) {\n\t\tvar maxPerpDistance = seg.distancePerpendicular(pts[startIndex]);\n\t\tvar nextPerpDistance = maxPerpDistance;\n\t\tvar maxIndex = startIndex;\n\t\tvar nextIndex = maxIndex;\n\t\twhile (nextPerpDistance >= maxPerpDistance) {\n\t\t\tmaxPerpDistance = nextPerpDistance;\n\t\t\tmaxIndex = nextIndex;\n\t\t\tnextIndex = MinimumDiameter.nextIndex(pts, maxIndex);\n\t\t\tnextPerpDistance = seg.distancePerpendicular(pts[nextIndex]);\n\t\t}\n\t\tif (maxPerpDistance < this._minWidth) {\n\t\t\tthis._minPtIndex = maxIndex;\n\t\t\tthis._minWidth = maxPerpDistance;\n\t\t\tthis._minWidthPt = pts[this._minPtIndex];\n\t\t\tthis._minBaseSeg = new LineSegment(seg);\n\t\t}\n\t\treturn maxIndex;\n\t},\n\tgetMinimumRectangle: function getMinimumRectangle() {\n\t\tthis.computeMinimumDiameter();\n\t\tif (this._minWidth === 0.0) {\n\t\t\tif (this._minBaseSeg.p0.equals2D(this._minBaseSeg.p1)) {\n\t\t\t\treturn this._inputGeom.getFactory().createPoint(this._minBaseSeg.p0);\n\t\t\t}\n\t\t\treturn this._minBaseSeg.toGeometry(this._inputGeom.getFactory());\n\t\t}\n\t\tvar dx = this._minBaseSeg.p1.x - this._minBaseSeg.p0.x;\n\t\tvar dy = this._minBaseSeg.p1.y - this._minBaseSeg.p0.y;\n\t\tvar minPara = Double.MAX_VALUE;\n\t\tvar maxPara = -Double.MAX_VALUE;\n\t\tvar minPerp = Double.MAX_VALUE;\n\t\tvar maxPerp = -Double.MAX_VALUE;\n\t\tfor (var i = 0; i < this._convexHullPts.length; i++) {\n\t\t\tvar paraC = MinimumDiameter.computeC(dx, dy, this._convexHullPts[i]);\n\t\t\tif (paraC > maxPara) maxPara = paraC;\n\t\t\tif (paraC < minPara) minPara = paraC;\n\t\t\tvar perpC = MinimumDiameter.computeC(-dy, dx, this._convexHullPts[i]);\n\t\t\tif (perpC > maxPerp) maxPerp = perpC;\n\t\t\tif (perpC < minPerp) minPerp = perpC;\n\t\t}\n\t\tvar maxPerpLine = MinimumDiameter.computeSegmentForLine(-dx, -dy, maxPerp);\n\t\tvar minPerpLine = MinimumDiameter.computeSegmentForLine(-dx, -dy, minPerp);\n\t\tvar maxParaLine = MinimumDiameter.computeSegmentForLine(-dy, dx, maxPara);\n\t\tvar minParaLine = MinimumDiameter.computeSegmentForLine(-dy, dx, minPara);\n\t\tvar p0 = maxParaLine.lineIntersection(maxPerpLine);\n\t\tvar p1 = minParaLine.lineIntersection(maxPerpLine);\n\t\tvar p2 = minParaLine.lineIntersection(minPerpLine);\n\t\tvar p3 = maxParaLine.lineIntersection(minPerpLine);\n\t\tvar shell = this._inputGeom.getFactory().createLinearRing([p0, p1, p2, p3, p0]);\n\t\treturn this._inputGeom.getFactory().createPolygon(shell, null);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn MinimumDiameter;\n\t}\n});\nMinimumDiameter.nextIndex = function (pts, index) {\n\tindex++;\n\tif (index >= pts.length) index = 0;\n\treturn index;\n};\nMinimumDiameter.computeC = function (a, b, p) {\n\treturn a * p.y - b * p.x;\n};\nMinimumDiameter.getMinimumDiameter = function (geom) {\n\treturn new MinimumDiameter(geom).getDiameter();\n};\nMinimumDiameter.getMinimumRectangle = function (geom) {\n\treturn new MinimumDiameter(geom).getMinimumRectangle();\n};\nMinimumDiameter.computeSegmentForLine = function (a, b, c) {\n\tvar p0 = null;\n\tvar p1 = null;\n\tif (Math.abs(b) > Math.abs(a)) {\n\t\tp0 = new Coordinate(0.0, c / b);\n\t\tp1 = new Coordinate(1.0, c / b - a / b);\n\t} else {\n\t\tp0 = new Coordinate(c / a, 0.0);\n\t\tp1 = new Coordinate(c / a - b / a, 1.0);\n\t}\n\treturn new LineSegment(p0, p1);\n};\n\nfunction Densifier() {\n\tthis._inputGeom = null;\n\tthis._distanceTolerance = null;\n\tvar inputGeom = arguments[0];\n\tthis._inputGeom = inputGeom;\n}\nextend(Densifier.prototype, {\n\tgetResultGeometry: function getResultGeometry() {\n\t\treturn new DensifyTransformer(this._distanceTolerance).transform(this._inputGeom);\n\t},\n\tsetDistanceTolerance: function setDistanceTolerance(distanceTolerance) {\n\t\tif (distanceTolerance <= 0.0) throw new IllegalArgumentException(\"Tolerance must be positive\");\n\t\tthis._distanceTolerance = distanceTolerance;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Densifier;\n\t}\n});\nDensifier.densifyPoints = function (pts, distanceTolerance, precModel) {\n\tvar seg = new LineSegment();\n\tvar coordList = new CoordinateList();\n\tfor (var i = 0; i < pts.length - 1; i++) {\n\t\tseg.p0 = pts[i];\n\t\tseg.p1 = pts[i + 1];\n\t\tcoordList.add(seg.p0, false);\n\t\tvar len = seg.getLength();\n\t\tvar densifiedSegCount = Math.trunc(len / distanceTolerance) + 1;\n\t\tif (densifiedSegCount > 1) {\n\t\t\tvar densifiedSegLen = len / densifiedSegCount;\n\t\t\tfor (var j = 1; j < densifiedSegCount; j++) {\n\t\t\t\tvar segFract = j * densifiedSegLen / len;\n\t\t\t\tvar p = seg.pointAlong(segFract);\n\t\t\t\tprecModel.makePrecise(p);\n\t\t\t\tcoordList.add(p, false);\n\t\t\t}\n\t\t}\n\t}\n\tcoordList.add(pts[pts.length - 1], false);\n\treturn coordList.toCoordinateArray();\n};\nDensifier.densify = function (geom, distanceTolerance) {\n\tvar densifier = new Densifier(geom);\n\tdensifier.setDistanceTolerance(distanceTolerance);\n\treturn densifier.getResultGeometry();\n};\nfunction DensifyTransformer() {\n\tGeometryTransformer.apply(this);\n\tthis.distanceTolerance = null;\n\tvar distanceTolerance = arguments[0];\n\tthis.distanceTolerance = distanceTolerance;\n}\ninherits$1(DensifyTransformer, GeometryTransformer);\nextend(DensifyTransformer.prototype, {\n\ttransformMultiPolygon: function transformMultiPolygon(geom, parent) {\n\t\tvar roughGeom = GeometryTransformer.prototype.transformMultiPolygon.call(this, geom, parent);\n\t\treturn this.createValidArea(roughGeom);\n\t},\n\ttransformPolygon: function transformPolygon(geom, parent) {\n\t\tvar roughGeom = GeometryTransformer.prototype.transformPolygon.call(this, geom, parent);\n\t\tif (parent instanceof MultiPolygon) {\n\t\t\treturn roughGeom;\n\t\t}\n\t\treturn this.createValidArea(roughGeom);\n\t},\n\ttransformCoordinates: function transformCoordinates(coords, parent) {\n\t\tvar inputPts = coords.toCoordinateArray();\n\t\tvar newPts = Densifier.densifyPoints(inputPts, this.distanceTolerance, parent.getPrecisionModel());\n\t\tif (parent instanceof LineString && newPts.length === 1) {\n\t\t\tnewPts = new Array(0).fill(null);\n\t\t}\n\t\treturn this._factory.getCoordinateSequenceFactory().create(newPts);\n\t},\n\tcreateValidArea: function createValidArea(roughAreaGeom) {\n\t\treturn roughAreaGeom.buffer(0.0);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn DensifyTransformer;\n\t}\n});\nDensifier.DensifyTransformer = DensifyTransformer;\n\nfunction HalfEdge() {\n\tthis._orig = null;\n\tthis._sym = null;\n\tthis._next = null;\n\tvar orig = arguments[0];\n\tthis._orig = orig;\n}\nextend(HalfEdge.prototype, {\n\tfind: function find(dest) {\n\t\tvar oNext = this;\n\t\tdo {\n\t\t\tif (oNext === null) return null;\n\t\t\tif (oNext.dest().equals2D(dest)) return oNext;\n\t\t\toNext = oNext.oNext();\n\t\t} while (oNext !== this);\n\t\treturn null;\n\t},\n\tdest: function dest() {\n\t\treturn this._sym._orig;\n\t},\n\toNext: function oNext() {\n\t\treturn this._sym._next;\n\t},\n\tinsert: function insert(e) {\n\t\tif (this.oNext() === this) {\n\t\t\tthis.insertAfter(e);\n\t\t\treturn null;\n\t\t}\n\t\tvar ecmp = this.compareTo(e);\n\t\tvar ePrev = this;\n\t\tdo {\n\t\t\tvar oNext = ePrev.oNext();\n\t\t\tvar cmp = oNext.compareTo(e);\n\t\t\tif (cmp !== ecmp || oNext === this) {\n\t\t\t\tePrev.insertAfter(e);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tePrev = oNext;\n\t\t} while (ePrev !== this);\n\t\tAssert.shouldNeverReachHere();\n\t},\n\tinsertAfter: function insertAfter(e) {\n\t\tAssert.equals(this._orig, e.orig());\n\t\tvar save = this.oNext();\n\t\tthis._sym.setNext(e);\n\t\te.sym().setNext(save);\n\t},\n\tdegree: function degree() {\n\t\tvar degree = 0;\n\t\tvar e = this;\n\t\tdo {\n\t\t\tdegree++;\n\t\t\te = e.oNext();\n\t\t} while (e !== this);\n\t\treturn degree;\n\t},\n\tequals: function equals() {\n\t\tif (arguments.length === 2) {\n\t\t\tvar p0 = arguments[0],\n\t\t\t    p1 = arguments[1];\n\t\t\treturn this._orig.equals2D(p0) && this._sym._orig.equals(p1);\n\t\t}\n\t},\n\tdeltaY: function deltaY() {\n\t\treturn this._sym._orig.y - this._orig.y;\n\t},\n\tsym: function sym() {\n\t\treturn this._sym;\n\t},\n\tprev: function prev() {\n\t\treturn this._sym.next()._sym;\n\t},\n\tcompareAngularDirection: function compareAngularDirection(e) {\n\t\tvar dx = this.deltaX();\n\t\tvar dy = this.deltaY();\n\t\tvar dx2 = e.deltaX();\n\t\tvar dy2 = e.deltaY();\n\t\tif (dx === dx2 && dy === dy2) return 0;\n\t\tvar quadrant = Quadrant.quadrant(dx, dy);\n\t\tvar quadrant2 = Quadrant.quadrant(dx2, dy2);\n\t\tif (quadrant > quadrant2) return 1;\n\t\tif (quadrant < quadrant2) return -1;\n\t\treturn CGAlgorithms.computeOrientation(e._orig, e.dest(), this.dest());\n\t},\n\tprevNode: function prevNode() {\n\t\tvar e = this;\n\t\twhile (e.degree() === 2) {\n\t\t\te = e.prev();\n\t\t\tif (e === this) return null;\n\t\t}\n\t\treturn e;\n\t},\n\tcompareTo: function compareTo(obj) {\n\t\tvar e = obj;\n\t\tvar comp = this.compareAngularDirection(e);\n\t\treturn comp;\n\t},\n\tnext: function next() {\n\t\treturn this._next;\n\t},\n\tsetSym: function setSym(e) {\n\t\tthis._sym = e;\n\t},\n\torig: function orig() {\n\t\treturn this._orig;\n\t},\n\ttoString: function toString() {\n\t\treturn \"HE(\" + this._orig.x + \" \" + this._orig.y + \", \" + this._sym._orig.x + \" \" + this._sym._orig.y + \")\";\n\t},\n\tsetNext: function setNext(e) {\n\t\tthis._next = e;\n\t},\n\tinit: function init(e) {\n\t\tthis.setSym(e);\n\t\te.setSym(this);\n\t\tthis.setNext(e);\n\t\te.setNext(this);\n\t},\n\tdeltaX: function deltaX() {\n\t\treturn this._sym._orig.x - this._orig.x;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn HalfEdge;\n\t}\n});\nHalfEdge.init = function (e0, e1) {\n\tif (e0._sym !== null || e1._sym !== null || e0._next !== null || e1._next !== null) throw new IllegalStateException(\"Edges are already initialized\");\n\te0.init(e1);\n\treturn e0;\n};\nHalfEdge.create = function (p0, p1) {\n\tvar e0 = new HalfEdge(p0);\n\tvar e1 = new HalfEdge(p1);\n\te0.init(e1);\n\treturn e0;\n};\n\nfunction MarkHalfEdge() {\n\tthis._isMarked = false;\n\tvar orig = arguments[0];\n\tHalfEdge.call(this, orig);\n}\ninherits$1(MarkHalfEdge, HalfEdge);\nextend(MarkHalfEdge.prototype, {\n\tmark: function mark() {\n\t\tthis._isMarked = true;\n\t},\n\tsetMark: function setMark(isMarked) {\n\t\tthis._isMarked = isMarked;\n\t},\n\tisMarked: function isMarked() {\n\t\treturn this._isMarked;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn MarkHalfEdge;\n\t}\n});\nMarkHalfEdge.setMarkBoth = function (e, isMarked) {\n\te.setMark(isMarked);\n\te.sym().setMark(isMarked);\n};\nMarkHalfEdge.isMarked = function (e) {\n\treturn e.isMarked();\n};\nMarkHalfEdge.setMark = function (e, isMarked) {\n\te.setMark(isMarked);\n};\nMarkHalfEdge.markBoth = function (e) {\n\te.mark();\n\te.sym().mark();\n};\nMarkHalfEdge.mark = function (e) {\n\te.mark();\n};\n\nfunction EdgeGraph() {\n\tthis._vertexMap = new HashMap();\n}\nextend(EdgeGraph.prototype, {\n\tinsert: function insert(orig, dest, eAdj) {\n\t\tvar e = this.create(orig, dest);\n\t\tif (eAdj !== null) {\n\t\t\teAdj.insert(e);\n\t\t} else {\n\t\t\tthis._vertexMap.put(orig, e);\n\t\t}\n\t\tvar eAdjDest = this._vertexMap.get(dest);\n\t\tif (eAdjDest !== null) {\n\t\t\teAdjDest.insert(e.sym());\n\t\t} else {\n\t\t\tthis._vertexMap.put(dest, e.sym());\n\t\t}\n\t\treturn e;\n\t},\n\tcreate: function create(p0, p1) {\n\t\tvar e0 = this.createEdge(p0);\n\t\tvar e1 = this.createEdge(p1);\n\t\tHalfEdge.init(e0, e1);\n\t\treturn e0;\n\t},\n\tcreateEdge: function createEdge(orig) {\n\t\treturn new HalfEdge(orig);\n\t},\n\taddEdge: function addEdge(orig, dest) {\n\t\tif (!EdgeGraph.isValidEdge(orig, dest)) return null;\n\t\tvar eAdj = this._vertexMap.get(orig);\n\t\tvar eSame = null;\n\t\tif (eAdj !== null) {\n\t\t\teSame = eAdj.find(dest);\n\t\t}\n\t\tif (eSame !== null) {\n\t\t\treturn eSame;\n\t\t}\n\t\tvar e = this.insert(orig, dest, eAdj);\n\t\treturn e;\n\t},\n\tgetVertexEdges: function getVertexEdges() {\n\t\treturn this._vertexMap.values();\n\t},\n\tfindEdge: function findEdge(orig, dest) {\n\t\tvar e = this._vertexMap.get(orig);\n\t\tif (e === null) return null;\n\t\treturn e.find(dest);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn EdgeGraph;\n\t}\n});\nEdgeGraph.isValidEdge = function (orig, dest) {\n\tvar cmp = dest.compareTo(orig);\n\treturn cmp !== 0;\n};\n\nfunction DissolveHalfEdge() {\n\tthis._isStart = false;\n\tvar orig = arguments[0];\n\tMarkHalfEdge.call(this, orig);\n}\ninherits$1(DissolveHalfEdge, MarkHalfEdge);\nextend(DissolveHalfEdge.prototype, {\n\tsetStart: function setStart() {\n\t\tthis._isStart = true;\n\t},\n\tisStart: function isStart() {\n\t\treturn this._isStart;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn DissolveHalfEdge;\n\t}\n});\n\nfunction DissolveEdgeGraph() {\n\tEdgeGraph.apply(this);\n}\ninherits$1(DissolveEdgeGraph, EdgeGraph);\nextend(DissolveEdgeGraph.prototype, {\n\tcreateEdge: function createEdge(p0) {\n\t\treturn new DissolveHalfEdge(p0);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn DissolveEdgeGraph;\n\t}\n});\n\nfunction LineDissolver() {\n\tthis._result = null;\n\tthis._factory = null;\n\tthis._graph = null;\n\tthis._lines = new ArrayList();\n\tthis._nodeEdgeStack = new Stack$2();\n\tthis._ringStartEdge = null;\n\tthis._graph = new DissolveEdgeGraph();\n}\nextend(LineDissolver.prototype, {\n\taddLine: function addLine(line) {\n\t\tthis._lines.add(this._factory.createLineString(line.toCoordinateArray()));\n\t},\n\tupdateRingStartEdge: function updateRingStartEdge(e) {\n\t\tif (!e.isStart()) {\n\t\t\te = e.sym();\n\t\t\tif (!e.isStart()) return null;\n\t\t}\n\t\tif (this._ringStartEdge === null) {\n\t\t\tthis._ringStartEdge = e;\n\t\t\treturn null;\n\t\t}\n\t\tif (e.orig().compareTo(this._ringStartEdge.orig()) < 0) {\n\t\t\tthis._ringStartEdge = e;\n\t\t}\n\t},\n\tgetResult: function getResult() {\n\t\tif (this._result === null) this.computeResult();\n\t\treturn this._result;\n\t},\n\tprocess: function process(e) {\n\t\tvar eNode = e.prevNode();\n\t\tif (eNode === null) eNode = e;\n\t\tthis.stackEdges(eNode);\n\t\tthis.buildLines();\n\t},\n\tbuildRing: function buildRing(eStartRing) {\n\t\tvar line = new CoordinateList();\n\t\tvar e = eStartRing;\n\t\tline.add(e.orig().copy(), false);\n\t\twhile (e.sym().degree() === 2) {\n\t\t\tvar eNext = e.next();\n\t\t\tif (eNext === eStartRing) break;\n\t\t\tline.add(eNext.orig().copy(), false);\n\t\t\te = eNext;\n\t\t}\n\t\tline.add(e.dest().copy(), false);\n\t\tthis.addLine(line);\n\t},\n\tbuildLine: function buildLine(eStart) {\n\t\tvar line = new CoordinateList();\n\t\tvar e = eStart;\n\t\tthis._ringStartEdge = null;\n\t\tMarkHalfEdge.markBoth(e);\n\t\tline.add(e.orig().copy(), false);\n\t\twhile (e.sym().degree() === 2) {\n\t\t\tthis.updateRingStartEdge(e);\n\t\t\tvar eNext = e.next();\n\t\t\tif (eNext === eStart) {\n\t\t\t\tthis.buildRing(this._ringStartEdge);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tline.add(eNext.orig().copy(), false);\n\t\t\te = eNext;\n\t\t\tMarkHalfEdge.markBoth(e);\n\t\t}\n\t\tline.add(e.dest().copy(), false);\n\t\tthis.stackEdges(e.sym());\n\t\tthis.addLine(line);\n\t},\n\tstackEdges: function stackEdges(node) {\n\t\tvar e = node;\n\t\tdo {\n\t\t\tif (!MarkHalfEdge.isMarked(e)) this._nodeEdgeStack.add(e);\n\t\t\te = e.oNext();\n\t\t} while (e !== node);\n\t},\n\tcomputeResult: function computeResult() {\n\t\tvar edges = this._graph.getVertexEdges();\n\t\tfor (var i = edges.iterator(); i.hasNext();) {\n\t\t\tvar e = i.next();\n\t\t\tif (MarkHalfEdge.isMarked(e)) continue;\n\t\t\tthis.process(e);\n\t\t}\n\t\tthis._result = this._factory.buildGeometry(this._lines);\n\t},\n\tbuildLines: function buildLines() {\n\t\twhile (!this._nodeEdgeStack.empty()) {\n\t\t\tvar e = this._nodeEdgeStack.pop();\n\t\t\tif (MarkHalfEdge.isMarked(e)) continue;\n\t\t\tthis.buildLine(e);\n\t\t}\n\t},\n\tadd: function add() {\n\t\tif (arguments[0] instanceof Geometry) {\n\t\t\tvar geometry = arguments[0];\n\t\t\tgeometry.apply({\n\t\t\t\tinterfaces_: function interfaces_() {\n\t\t\t\t\treturn [GeometryComponentFilter];\n\t\t\t\t},\n\t\t\t\tfilter: function filter(component) {\n\t\t\t\t\tif (component instanceof LineString) {\n\t\t\t\t\t\tthis.add(component);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (hasInterface(arguments[0], Collection)) {\n\t\t\tvar geometries = arguments[0];\n\t\t\tfor (var i = geometries.iterator(); i.hasNext();) {\n\t\t\t\tvar geometry = i.next();\n\t\t\t\tthis.add(geometry);\n\t\t\t}\n\t\t} else if (arguments[0] instanceof LineString) {\n\t\t\tvar lineString = arguments[0];\n\t\t\tif (this._factory === null) {\n\t\t\t\tthis._factory = lineString.getFactory();\n\t\t\t}\n\t\t\tvar seq = lineString.getCoordinateSequence();\n\t\t\tvar doneStart = false;\n\t\t\tfor (var i = 1; i < seq.size(); i++) {\n\t\t\t\tvar e = this._graph.addEdge(seq.getCoordinate(i - 1), seq.getCoordinate(i));\n\t\t\t\tif (e === null) continue;\n\t\t\t\tif (!doneStart) {\n\t\t\t\t\te.setStart();\n\t\t\t\t\tdoneStart = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn LineDissolver;\n\t}\n});\nLineDissolver.dissolve = function (g) {\n\tvar d = new LineDissolver();\n\td.add(g);\n\treturn d.getResult();\n};\n\nfunction NodeBase$1() {\n\tthis._items = new ArrayList();\n\tthis._subnode = new Array(4).fill(null);\n}\nextend(NodeBase$1.prototype, {\n\thasChildren: function hasChildren() {\n\t\tfor (var i = 0; i < 4; i++) {\n\t\t\tif (this._subnode[i] !== null) return true;\n\t\t}\n\t\treturn false;\n\t},\n\tisPrunable: function isPrunable() {\n\t\treturn !(this.hasChildren() || this.hasItems());\n\t},\n\taddAllItems: function addAllItems(resultItems) {\n\t\tresultItems.addAll(this._items);\n\t\tfor (var i = 0; i < 4; i++) {\n\t\t\tif (this._subnode[i] !== null) {\n\t\t\t\tthis._subnode[i].addAllItems(resultItems);\n\t\t\t}\n\t\t}\n\t\treturn resultItems;\n\t},\n\tgetNodeCount: function getNodeCount() {\n\t\tvar subSize = 0;\n\t\tfor (var i = 0; i < 4; i++) {\n\t\t\tif (this._subnode[i] !== null) {\n\t\t\t\tsubSize += this._subnode[i].size();\n\t\t\t}\n\t\t}\n\t\treturn subSize + 1;\n\t},\n\tsize: function size() {\n\t\tvar subSize = 0;\n\t\tfor (var i = 0; i < 4; i++) {\n\t\t\tif (this._subnode[i] !== null) {\n\t\t\t\tsubSize += this._subnode[i].size();\n\t\t\t}\n\t\t}\n\t\treturn subSize + this._items.size();\n\t},\n\taddAllItemsFromOverlapping: function addAllItemsFromOverlapping(searchEnv, resultItems) {\n\t\tif (!this.isSearchMatch(searchEnv)) return null;\n\t\tresultItems.addAll(this._items);\n\t\tfor (var i = 0; i < 4; i++) {\n\t\t\tif (this._subnode[i] !== null) {\n\t\t\t\tthis._subnode[i].addAllItemsFromOverlapping(searchEnv, resultItems);\n\t\t\t}\n\t\t}\n\t},\n\tvisitItems: function visitItems(searchEnv, visitor) {\n\t\tfor (var i = this._items.iterator(); i.hasNext();) {\n\t\t\tvisitor.visitItem(i.next());\n\t\t}\n\t},\n\thasItems: function hasItems() {\n\t\treturn !this._items.isEmpty();\n\t},\n\tremove: function remove(itemEnv, item) {\n\t\tif (!this.isSearchMatch(itemEnv)) return false;\n\t\tvar found = false;\n\t\tfor (var i = 0; i < 4; i++) {\n\t\t\tif (this._subnode[i] !== null) {\n\t\t\t\tfound = this._subnode[i].remove(itemEnv, item);\n\t\t\t\tif (found) {\n\t\t\t\t\tif (this._subnode[i].isPrunable()) this._subnode[i] = null;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (found) return found;\n\t\tfound = this._items.remove(item);\n\t\treturn found;\n\t},\n\tvisit: function visit(searchEnv, visitor) {\n\t\tif (!this.isSearchMatch(searchEnv)) return null;\n\t\tthis.visitItems(searchEnv, visitor);\n\t\tfor (var i = 0; i < 4; i++) {\n\t\t\tif (this._subnode[i] !== null) {\n\t\t\t\tthis._subnode[i].visit(searchEnv, visitor);\n\t\t\t}\n\t\t}\n\t},\n\tgetItems: function getItems() {\n\t\treturn this._items;\n\t},\n\tdepth: function depth() {\n\t\tvar maxSubDepth = 0;\n\t\tfor (var i = 0; i < 4; i++) {\n\t\t\tif (this._subnode[i] !== null) {\n\t\t\t\tvar sqd = this._subnode[i].depth();\n\t\t\t\tif (sqd > maxSubDepth) maxSubDepth = sqd;\n\t\t\t}\n\t\t}\n\t\treturn maxSubDepth + 1;\n\t},\n\tisEmpty: function isEmpty() {\n\t\tvar isEmpty = true;\n\t\tif (!this._items.isEmpty()) isEmpty = false;\n\t\tfor (var i = 0; i < 4; i++) {\n\t\t\tif (this._subnode[i] !== null) {\n\t\t\t\tif (!this._subnode[i].isEmpty()) isEmpty = false;\n\t\t\t}\n\t\t}\n\t\treturn isEmpty;\n\t},\n\tadd: function add(item) {\n\t\tthis._items.add(item);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Serializable];\n\t},\n\tgetClass: function getClass() {\n\t\treturn NodeBase$1;\n\t}\n});\nNodeBase$1.getSubnodeIndex = function (env, centrex, centrey) {\n\tvar subnodeIndex = -1;\n\tif (env.getMinX() >= centrex) {\n\t\tif (env.getMinY() >= centrey) subnodeIndex = 3;\n\t\tif (env.getMaxY() <= centrey) subnodeIndex = 1;\n\t}\n\tif (env.getMaxX() <= centrex) {\n\t\tif (env.getMinY() >= centrey) subnodeIndex = 2;\n\t\tif (env.getMaxY() <= centrey) subnodeIndex = 0;\n\t}\n\treturn subnodeIndex;\n};\n\nfunction Key$1() {\n\tthis._pt = new Coordinate();\n\tthis._level = 0;\n\tthis._env = null;\n\tvar itemEnv = arguments[0];\n\tthis.computeKey(itemEnv);\n}\nextend(Key$1.prototype, {\n\tgetLevel: function getLevel() {\n\t\treturn this._level;\n\t},\n\tcomputeKey: function computeKey() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar itemEnv = arguments[0];\n\t\t\tthis._level = Key$1.computeQuadLevel(itemEnv);\n\t\t\tthis._env = new Envelope();\n\t\t\tthis.computeKey(this._level, itemEnv);\n\t\t\twhile (!this._env.contains(itemEnv)) {\n\t\t\t\tthis._level += 1;\n\t\t\t\tthis.computeKey(this._level, itemEnv);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar level = arguments[0],\n\t\t\t    itemEnv = arguments[1];\n\t\t\tvar quadSize = DoubleBits.powerOf2(level);\n\t\t\tthis._pt.x = Math.floor(itemEnv.getMinX() / quadSize) * quadSize;\n\t\t\tthis._pt.y = Math.floor(itemEnv.getMinY() / quadSize) * quadSize;\n\t\t\tthis._env.init(this._pt.x, this._pt.x + quadSize, this._pt.y, this._pt.y + quadSize);\n\t\t}\n\t},\n\tgetEnvelope: function getEnvelope() {\n\t\treturn this._env;\n\t},\n\tgetCentre: function getCentre() {\n\t\treturn new Coordinate((this._env.getMinX() + this._env.getMaxX()) / 2, (this._env.getMinY() + this._env.getMaxY()) / 2);\n\t},\n\tgetPoint: function getPoint() {\n\t\treturn this._pt;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Key$1;\n\t}\n});\nKey$1.computeQuadLevel = function (env) {\n\tvar dx = env.getWidth();\n\tvar dy = env.getHeight();\n\tvar dMax = dx > dy ? dx : dy;\n\tvar level = DoubleBits.exponent(dMax) + 1;\n\treturn level;\n};\n\nfunction Node$2() {\n\tNodeBase$1.apply(this);\n\tthis._env = null;\n\tthis._centrex = null;\n\tthis._centrey = null;\n\tthis._level = null;\n\tvar env = arguments[0],\n\t    level = arguments[1];\n\tthis._env = env;\n\tthis._level = level;\n\tthis._centrex = (env.getMinX() + env.getMaxX()) / 2;\n\tthis._centrey = (env.getMinY() + env.getMaxY()) / 2;\n}\ninherits$1(Node$2, NodeBase$1);\nextend(Node$2.prototype, {\n\tfind: function find(searchEnv) {\n\t\tvar subnodeIndex = NodeBase$1.getSubnodeIndex(searchEnv, this._centrex, this._centrey);\n\t\tif (subnodeIndex === -1) return this;\n\t\tif (this._subnode[subnodeIndex] !== null) {\n\t\t\tvar node = this._subnode[subnodeIndex];\n\t\t\treturn node.find(searchEnv);\n\t\t}\n\t\treturn this;\n\t},\n\tisSearchMatch: function isSearchMatch(searchEnv) {\n\t\treturn this._env.intersects(searchEnv);\n\t},\n\tgetSubnode: function getSubnode(index) {\n\t\tif (this._subnode[index] === null) {\n\t\t\tthis._subnode[index] = this.createSubnode(index);\n\t\t}\n\t\treturn this._subnode[index];\n\t},\n\tgetEnvelope: function getEnvelope() {\n\t\treturn this._env;\n\t},\n\tgetNode: function getNode(searchEnv) {\n\t\tvar subnodeIndex = NodeBase$1.getSubnodeIndex(searchEnv, this._centrex, this._centrey);\n\t\tif (subnodeIndex !== -1) {\n\t\t\tvar node = this.getSubnode(subnodeIndex);\n\t\t\treturn node.getNode(searchEnv);\n\t\t} else {\n\t\t\treturn this;\n\t\t}\n\t},\n\tcreateSubnode: function createSubnode(index) {\n\t\tvar minx = 0.0;\n\t\tvar maxx = 0.0;\n\t\tvar miny = 0.0;\n\t\tvar maxy = 0.0;\n\t\tswitch (index) {\n\t\t\tcase 0:\n\t\t\t\tminx = this._env.getMinX();\n\t\t\t\tmaxx = this._centrex;\n\t\t\t\tminy = this._env.getMinY();\n\t\t\t\tmaxy = this._centrey;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tminx = this._centrex;\n\t\t\t\tmaxx = this._env.getMaxX();\n\t\t\t\tminy = this._env.getMinY();\n\t\t\t\tmaxy = this._centrey;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tminx = this._env.getMinX();\n\t\t\t\tmaxx = this._centrex;\n\t\t\t\tminy = this._centrey;\n\t\t\t\tmaxy = this._env.getMaxY();\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tminx = this._centrex;\n\t\t\t\tmaxx = this._env.getMaxX();\n\t\t\t\tminy = this._centrey;\n\t\t\t\tmaxy = this._env.getMaxY();\n\t\t\t\tbreak;\n\t\t}\n\t\tvar sqEnv = new Envelope(minx, maxx, miny, maxy);\n\t\tvar node = new Node$2(sqEnv, this._level - 1);\n\t\treturn node;\n\t},\n\tinsertNode: function insertNode(node) {\n\t\tAssert.isTrue(this._env === null || this._env.contains(node._env));\n\t\tvar index = NodeBase$1.getSubnodeIndex(node._env, this._centrex, this._centrey);\n\t\tif (node._level === this._level - 1) {\n\t\t\tthis._subnode[index] = node;\n\t\t} else {\n\t\t\tvar childNode = this.createSubnode(index);\n\t\t\tchildNode.insertNode(node);\n\t\t\tthis._subnode[index] = childNode;\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Node$2;\n\t}\n});\nNode$2.createNode = function (env) {\n\tvar key = new Key$1(env);\n\tvar node = new Node$2(key.getEnvelope(), key.getLevel());\n\treturn node;\n};\nNode$2.createExpanded = function (node, addEnv) {\n\tvar expandEnv = new Envelope(addEnv);\n\tif (node !== null) expandEnv.expandToInclude(node._env);\n\tvar largerNode = Node$2.createNode(expandEnv);\n\tif (node !== null) largerNode.insertNode(node);\n\treturn largerNode;\n};\n\nfunction Root$1() {\n\tNodeBase$1.apply(this);\n}\ninherits$1(Root$1, NodeBase$1);\nextend(Root$1.prototype, {\n\tinsert: function insert(itemEnv, item) {\n\t\tvar index = NodeBase$1.getSubnodeIndex(itemEnv, Root$1.origin.x, Root$1.origin.y);\n\t\tif (index === -1) {\n\t\t\tthis.add(item);\n\t\t\treturn null;\n\t\t}\n\t\tvar node = this._subnode[index];\n\t\tif (node === null || !node.getEnvelope().contains(itemEnv)) {\n\t\t\tvar largerNode = Node$2.createExpanded(node, itemEnv);\n\t\t\tthis._subnode[index] = largerNode;\n\t\t}\n\t\tthis.insertContained(this._subnode[index], itemEnv, item);\n\t},\n\tisSearchMatch: function isSearchMatch(searchEnv) {\n\t\treturn true;\n\t},\n\tinsertContained: function insertContained(tree, itemEnv, item) {\n\t\tAssert.isTrue(tree.getEnvelope().contains(itemEnv));\n\t\tvar isZeroX = IntervalSize.isZeroWidth(itemEnv.getMinX(), itemEnv.getMaxX());\n\t\tvar isZeroY = IntervalSize.isZeroWidth(itemEnv.getMinY(), itemEnv.getMaxY());\n\t\tvar node = null;\n\t\tif (isZeroX || isZeroY) node = tree.find(itemEnv);else node = tree.getNode(itemEnv);\n\t\tnode.add(item);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Root$1;\n\t}\n});\nRoot$1.origin = new Coordinate(0.0, 0.0);\n\nfunction Quadtree() {\n\tthis._root = null;\n\tthis._minExtent = 1.0;\n\tthis._root = new Root$1();\n}\nextend(Quadtree.prototype, {\n\tsize: function size() {\n\t\tif (this._root !== null) return this._root.size();\n\t\treturn 0;\n\t},\n\tinsert: function insert(itemEnv, item) {\n\t\tthis.collectStats(itemEnv);\n\t\tvar insertEnv = Quadtree.ensureExtent(itemEnv, this._minExtent);\n\t\tthis._root.insert(insertEnv, item);\n\t},\n\tquery: function query() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar searchEnv = arguments[0];\n\t\t\tvar visitor = new ArrayListVisitor();\n\t\t\tthis.query(searchEnv, visitor);\n\t\t\treturn visitor.getItems();\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar searchEnv = arguments[0],\n\t\t\t    visitor = arguments[1];\n\t\t\tthis._root.visit(searchEnv, visitor);\n\t\t}\n\t},\n\tqueryAll: function queryAll() {\n\t\tvar foundItems = new ArrayList();\n\t\tthis._root.addAllItems(foundItems);\n\t\treturn foundItems;\n\t},\n\tremove: function remove(itemEnv, item) {\n\t\tvar posEnv = Quadtree.ensureExtent(itemEnv, this._minExtent);\n\t\treturn this._root.remove(posEnv, item);\n\t},\n\tcollectStats: function collectStats(itemEnv) {\n\t\tvar delX = itemEnv.getWidth();\n\t\tif (delX < this._minExtent && delX > 0.0) this._minExtent = delX;\n\t\tvar delY = itemEnv.getHeight();\n\t\tif (delY < this._minExtent && delY > 0.0) this._minExtent = delY;\n\t},\n\tdepth: function depth() {\n\t\tif (this._root !== null) return this._root.depth();\n\t\treturn 0;\n\t},\n\tisEmpty: function isEmpty() {\n\t\tif (this._root === null) return true;\n\t\treturn false;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [SpatialIndex, Serializable];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Quadtree;\n\t}\n});\nQuadtree.ensureExtent = function (itemEnv, minExtent) {\n\tvar minx = itemEnv.getMinX();\n\tvar maxx = itemEnv.getMaxX();\n\tvar miny = itemEnv.getMinY();\n\tvar maxy = itemEnv.getMaxY();\n\tif (minx !== maxx && miny !== maxy) return itemEnv;\n\tif (minx === maxx) {\n\t\tminx = minx - minExtent / 2.0;\n\t\tmaxx = minx + minExtent / 2.0;\n\t}\n\tif (miny === maxy) {\n\t\tminy = miny - minExtent / 2.0;\n\t\tmaxy = miny + minExtent / 2.0;\n\t}\n\treturn new Envelope(minx, maxx, miny, maxy);\n};\nQuadtree.serialVersionUID = -7461163625812743604;\n\nvar geometryTypes = ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon'];\n\n/**\n * Class for reading and writing Well-Known Text.Create a new parser for GeoJSON\n * NOTE: Adapted from OpenLayers 2.11 implementation.\n */\n\n/**\n * Create a new parser for GeoJSON\n *\n * @param {GeometryFactory} geometryFactory\n * @return An instance of GeoJsonParser.\n * @constructor\n * @private\n */\nfunction GeoJSONParser(geometryFactory) {\n  this.geometryFactory = geometryFactory || new GeometryFactory();\n}\n\nextend(GeoJSONParser.prototype, {\n  /**\n   * Deserialize a GeoJSON object and return the Geometry or Feature(Collection) with JSTS Geometries\n   *\n   * @param {}\n   *          A GeoJSON object.\n   * @return {} A Geometry instance or object representing a Feature(Collection) with Geometry instances.\n   * @private\n   */\n  read: function read(json) {\n    var obj;\n    if (typeof json === 'string') {\n      obj = JSON.parse(json);\n    } else {\n      obj = json;\n    }\n\n    var type = obj.type;\n\n    if (!parse$1[type]) {\n      throw new Error('Unknown GeoJSON type: ' + obj.type);\n    }\n\n    if (geometryTypes.indexOf(type) !== -1) {\n      return parse$1[type].apply(this, [obj.coordinates]);\n    } else if (type === 'GeometryCollection') {\n      return parse$1[type].apply(this, [obj.geometries]);\n    }\n\n    // feature or feature collection\n    return parse$1[type].apply(this, [obj]);\n  },\n\n\n  /**\n   * Serialize a Geometry object into GeoJSON\n   *\n   * @param {Geometry}\n   *          geometry A Geometry or array of Geometries.\n   * @return {Object} A GeoJSON object represting the input Geometry/Geometries.\n   * @private\n   */\n  write: function write(geometry) {\n    var type = geometry.getGeometryType();\n\n    if (!extract$2[type]) {\n      throw new Error('Geometry is not supported');\n    }\n\n    return extract$2[type].apply(this, [geometry]);\n  }\n});\n\nvar parse$1 = {\n  /**\n   * Parse a GeoJSON Feature object\n   *\n   * @param {Object}\n   *          obj Object to parse.\n   *\n   * @return {Object} Feature with geometry/bbox converted to JSTS Geometries.\n   */\n  Feature: function Feature(obj) {\n    var feature = {};\n\n    // copy features\n    for (var key in obj) {\n      feature[key] = obj[key];\n    }\n\n    // parse geometry\n    if (obj.geometry) {\n      var type = obj.geometry.type;\n      if (!parse$1[type]) {\n        throw new Error('Unknown GeoJSON type: ' + obj.type);\n      }\n      feature.geometry = this.read(obj.geometry);\n    }\n\n    // bbox\n    if (obj.bbox) {\n      feature.bbox = parse$1.bbox.apply(this, [obj.bbox]);\n    }\n\n    return feature;\n  },\n\n  /**\n   * Parse a GeoJSON FeatureCollection object\n   *\n   * @param {Object}\n   *          obj Object to parse.\n   *\n   * @return {Object} FeatureCollection with geometry/bbox converted to JSTS Geometries.\n   */\n  FeatureCollection: function FeatureCollection(obj) {\n    var featureCollection = {};\n\n    if (obj.features) {\n      featureCollection.features = [];\n\n      for (var i = 0; i < obj.features.length; ++i) {\n        featureCollection.features.push(this.read(obj.features[i]));\n      }\n    }\n\n    if (obj.bbox) {\n      featureCollection.bbox = this.parse.bbox.apply(this, [obj.bbox]);\n    }\n\n    return featureCollection;\n  },\n\n  /**\n   * Convert the ordinates in an array to an array of Coordinates\n   *\n   * @param {Array}\n   *          array Array with {Number}s.\n   *\n   * @return {Array} Array with Coordinates.\n   */\n  coordinates: function coordinates(array) {\n    var coordinates = [];\n    for (var i = 0; i < array.length; ++i) {\n      var sub = array[i];\n      coordinates.push(new Coordinate(sub[0], sub[1]));\n    }\n    return coordinates;\n  },\n\n  /**\n   * Convert the bbox to a LinearRing\n   *\n   * @param {Array}\n   *          array Array with [xMin, yMin, xMax, yMax].\n   *\n   * @return {Array} Array with Coordinates.\n   */\n  bbox: function bbox(array) {\n    return this.geometryFactory.createLinearRing([new Coordinate(array[0], array[1]), new Coordinate(array[2], array[1]), new Coordinate(array[2], array[3]), new Coordinate(array[0], array[3]), new Coordinate(array[0], array[1])]);\n  },\n\n  /**\n   * Convert an Array with ordinates to a Point\n   *\n   * @param {Array}\n   *          array Array with ordinates.\n   *\n   * @return {Point} Point.\n   */\n  Point: function Point(array) {\n    var coordinate = new Coordinate(array[0], array[1]);\n    return this.geometryFactory.createPoint(coordinate);\n  },\n\n  /**\n   * Convert an Array with coordinates to a MultiPoint\n   *\n   * @param {Array}\n   *          array Array with coordinates.\n   *\n   * @return {MultiPoint} MultiPoint.\n   */\n  MultiPoint: function MultiPoint(array) {\n    var points = [];\n    for (var i = 0; i < array.length; ++i) {\n      points.push(parse$1.Point.apply(this, [array[i]]));\n    }\n    return this.geometryFactory.createMultiPoint(points);\n  },\n\n  /**\n   * Convert an Array with coordinates to a LineString\n   *\n   * @param {Array}\n   *          array Array with coordinates.\n   *\n   * @return {LineString} LineString.\n   */\n  LineString: function LineString(array) {\n    var coordinates = parse$1.coordinates.apply(this, [array]);\n    return this.geometryFactory.createLineString(coordinates);\n  },\n\n  /**\n   * Convert an Array with coordinates to a MultiLineString\n   *\n   * @param {Array}\n   *          array Array with coordinates.\n   *\n   * @return {MultiLineString} MultiLineString.\n   */\n  MultiLineString: function MultiLineString(array) {\n    var lineStrings = [];\n    for (var i = 0; i < array.length; ++i) {\n      lineStrings.push(parse$1.LineString.apply(this, [array[i]]));\n    }\n    return this.geometryFactory.createMultiLineString(lineStrings);\n  },\n\n  /**\n   * Convert an Array to a Polygon\n   *\n   * @param {Array}\n   *          array Array with shell and holes.\n   *\n   * @return {Polygon} Polygon.\n   */\n  Polygon: function Polygon(array) {\n    var shellCoordinates = parse$1.coordinates.apply(this, [array[0]]);\n    var shell = this.geometryFactory.createLinearRing(shellCoordinates);\n    var holes = [];\n    for (var i = 1; i < array.length; ++i) {\n      var hole = array[i];\n      var coordinates = parse$1.coordinates.apply(this, [hole]);\n      var linearRing = this.geometryFactory.createLinearRing(coordinates);\n      holes.push(linearRing);\n    }\n    return this.geometryFactory.createPolygon(shell, holes);\n  },\n\n  /**\n   * Convert an Array to a MultiPolygon\n   *\n   * @param {Array}\n   *          array Array of arrays with shell and rings.\n   *\n   * @return {MultiPolygon} MultiPolygon.\n   */\n  MultiPolygon: function MultiPolygon(array) {\n    var polygons = [];\n    for (var i = 0; i < array.length; ++i) {\n      var polygon = array[i];\n      polygons.push(parse$1.Polygon.apply(this, [polygon]));\n    }\n    return this.geometryFactory.createMultiPolygon(polygons);\n  },\n\n  /**\n   * Convert an Array to a GeometryCollection\n   *\n   * @param {Array}\n   *          array Array of GeoJSON geometries.\n   *\n   * @return {GeometryCollection} GeometryCollection.\n   */\n  GeometryCollection: function GeometryCollection(array) {\n    var geometries = [];\n    for (var i = 0; i < array.length; ++i) {\n      var geometry = array[i];\n      geometries.push(this.read(geometry));\n    }\n    return this.geometryFactory.createGeometryCollection(geometries);\n  }\n};\n\nvar extract$2 = {\n  /**\n   * Convert a Coordinate to an Array\n   *\n   * @param {Coordinate}\n   *          coordinate Coordinate to convert.\n   *\n   * @return {Array} Array of ordinates.\n   */\n  coordinate: function coordinate(_coordinate) {\n    return [_coordinate.x, _coordinate.y];\n  },\n\n  /**\n   * Convert a Point to a GeoJSON object\n   *\n   * @param {Point}\n   *          point Point to convert.\n   *\n   * @return {Array} Array of 2 ordinates (paired to a coordinate).\n   */\n  Point: function Point(point) {\n    var array = extract$2.coordinate.apply(this, [point.getCoordinate()]);\n    return {\n      type: 'Point',\n      coordinates: array\n    };\n  },\n\n  /**\n   * Convert a MultiPoint to a GeoJSON object\n   *\n   * @param {MultiPoint}\n   *          multipoint MultiPoint to convert.\n   *\n   * @return {Array} Array of coordinates.\n   */\n  MultiPoint: function MultiPoint(multipoint) {\n    var array = [];\n    for (var i = 0; i < multipoint._geometries.length; ++i) {\n      var point = multipoint._geometries[i];\n      var geoJson = extract$2.Point.apply(this, [point]);\n      array.push(geoJson.coordinates);\n    }\n    return {\n      type: 'MultiPoint',\n      coordinates: array\n    };\n  },\n\n  /**\n   * Convert a LineString to a GeoJSON object\n   *\n   * @param {LineString}\n   *          linestring LineString to convert.\n   *\n   * @return {Array} Array of coordinates.\n   */\n  LineString: function LineString(linestring) {\n    var array = [];\n    var coordinates = linestring.getCoordinates();\n    for (var i = 0; i < coordinates.length; ++i) {\n      var coordinate = coordinates[i];\n      array.push(extract$2.coordinate.apply(this, [coordinate]));\n    }\n    return {\n      type: 'LineString',\n      coordinates: array\n    };\n  },\n\n  /**\n   * Convert a MultiLineString to a GeoJSON object\n   *\n   * @param {MultiLineString}\n   *          multilinestring MultiLineString to convert.\n   *\n   * @return {Array} Array of Array of coordinates.\n   */\n  MultiLineString: function MultiLineString(multilinestring) {\n    var array = [];\n    for (var i = 0; i < multilinestring._geometries.length; ++i) {\n      var linestring = multilinestring._geometries[i];\n      var geoJson = extract$2.LineString.apply(this, [linestring]);\n      array.push(geoJson.coordinates);\n    }\n    return {\n      type: 'MultiLineString',\n      coordinates: array\n    };\n  },\n\n  /**\n   * Convert a Polygon to a GeoJSON object\n   *\n   * @param {Polygon}\n   *          polygon Polygon to convert.\n   *\n   * @return {Array} Array with shell, holes.\n   */\n  Polygon: function Polygon(polygon) {\n    var array = [];\n    var shellGeoJson = extract$2.LineString.apply(this, [polygon._shell]);\n    array.push(shellGeoJson.coordinates);\n    for (var i = 0; i < polygon._holes.length; ++i) {\n      var hole = polygon._holes[i];\n      var holeGeoJson = extract$2.LineString.apply(this, [hole]);\n      array.push(holeGeoJson.coordinates);\n    }\n    return {\n      type: 'Polygon',\n      coordinates: array\n    };\n  },\n\n  /**\n   * Convert a MultiPolygon to a GeoJSON object\n   *\n   * @param {MultiPolygon}\n   *          multipolygon MultiPolygon to convert.\n   *\n   * @return {Array} Array of polygons.\n   */\n  MultiPolygon: function MultiPolygon(multipolygon) {\n    var array = [];\n    for (var i = 0; i < multipolygon._geometries.length; ++i) {\n      var polygon = multipolygon._geometries[i];\n      var geoJson = extract$2.Polygon.apply(this, [polygon]);\n      array.push(geoJson.coordinates);\n    }\n    return {\n      type: 'MultiPolygon',\n      coordinates: array\n    };\n  },\n\n  /**\n   * Convert a GeometryCollection to a GeoJSON object\n   *\n   * @param {GeometryCollection}\n   *          collection GeometryCollection to convert.\n   *\n   * @return {Array} Array of geometries.\n   */\n  GeometryCollection: function GeometryCollection(collection) {\n    var array = [];\n    for (var i = 0; i < collection._geometries.length; ++i) {\n      var geometry = collection._geometries[i];\n      var type = geometry.getGeometryType();\n      array.push(extract$2[type].apply(this, [geometry]));\n    }\n    return {\n      type: 'GeometryCollection',\n      geometries: array\n    };\n  }\n};\n\n/**\n * Converts a geometry in GeoJSON to a {@link Geometry}.\n */\n\n/**\n * A <code>GeoJSONReader</code> is parameterized by a <code>GeometryFactory</code>,\n * to allow it to create <code>Geometry</code> objects of the appropriate\n * implementation. In particular, the <code>GeometryFactory</code> determines\n * the <code>PrecisionModel</code> and <code>SRID</code> that is used.\n *\n * @param {GeometryFactory} geometryFactory\n * @constructor\n */\nfunction GeoJSONReader(geometryFactory) {\n  this.geometryFactory = geometryFactory || new GeometryFactory();\n  this.precisionModel = this.geometryFactory.getPrecisionModel();\n  this.parser = new GeoJSONParser(this.geometryFactory);\n}\n\nextend(GeoJSONReader.prototype, {\n  /**\n   * Reads a GeoJSON representation of a {@link Geometry}\n   *\n   * Will also parse GeoJSON Features/FeatureCollections as custom objects.\n   *\n   * @param {Object|String} geoJson a GeoJSON Object or String.\n   * @return {Geometry|Object} a <code>Geometry or Feature/FeatureCollection representation.</code>\n   * @memberof GeoJSONReader\n   */\n  read: function read(geoJson) {\n    var geometry = this.parser.read(geoJson);\n\n    if (this.precisionModel.getType() === PrecisionModel.FIXED) {\n      this.reducePrecision(geometry);\n    }\n\n    return geometry;\n  },\n\n\n  // NOTE: this is a hack\n  reducePrecision: function reducePrecision(geometry) {\n    var i, len;\n\n    if (geometry.coordinate) {\n      this.precisionModel.makePrecise(geometry.coordinate);\n    } else if (geometry.points) {\n      for (i = 0, len = geometry.points.length; i < len; i++) {\n        this.precisionModel.makePrecise(geometry.points[i]);\n      }\n    } else if (geometry.geometries) {\n      for (i = 0, len = geometry.geometries.length; i < len; i++) {\n        this.reducePrecision(geometry.geometries[i]);\n      }\n    }\n  }\n});\n\n/**\n * @module GeoJSONWriter\n */\n\n/**\n * Writes the GeoJSON representation of a {@link Geometry}. The\n * The GeoJSON format is defined <A\n * HREF=\"http://geojson.org/geojson-spec.html\">here</A>.\n */\n\n/**\n * The <code>GeoJSONWriter</code> outputs coordinates rounded to the precision\n * model. Only the maximum number of decimal places necessary to represent the\n * ordinates to the required precision will be output.\n *\n * @param {GeometryFactory} geometryFactory\n * @constructor\n */\nfunction GeoJSONWriter() {\n  this.parser = new GeoJSONParser(this.geometryFactory);\n}\n\nextend(GeoJSONWriter.prototype, {\n  /**\n   * Converts a <code>Geometry</code> to its GeoJSON representation.\n   *\n   * @param {Geometry}\n   *          geometry a <code>Geometry</code> to process.\n   * @return {Object} The GeoJSON representation of the Geometry.\n   * @memberof GeoJSONWriter\n   */\n  write: function write(geometry) {\n    return this.parser.write(geometry);\n  }\n});\n\n/**\n * Converts a geometry in Well-Known Text format to a {@link Geometry}.\n * <p>\n * <code>WKTReader</code> supports extracting <code>Geometry</code> objects\n * from either {@link Reader}s or {@link String}s. This allows it to function\n * as a parser to read <code>Geometry</code> objects from text blocks embedded\n * in other data formats (e.g. XML).\n */\n\n/**\n * A <code>WKTReader</code> is parameterized by a <code>GeometryFactory</code>,\n * to allow it to create <code>Geometry</code> objects of the appropriate\n * implementation. In particular, the <code>GeometryFactory</code> determines\n * the <code>PrecisionModel</code> and <code>SRID</code> that is used.\n * @param {GeometryFactory} geometryFactory\n * @constructor\n */\nfunction WKTReader(geometryFactory) {\n  this.geometryFactory = geometryFactory || new GeometryFactory();\n  this.precisionModel = this.geometryFactory.getPrecisionModel();\n  this.parser = new WKTParser(this.geometryFactory);\n}\n\nextend(WKTReader.prototype, {\n  /**\n   * Reads a Well-Known Text representation of a {@link Geometry}\n   *\n   * @param {string}\n   *          wkt a <Geometry Tagged Text> string (see the OpenGIS Simple Features\n   *          Specification).\n   * @return {Geometry} a <code>Geometry</code> read from\n   *         <code>string.</code>\n   * @memberof WKTReader\n   */\n  read: function read(wkt) {\n    var geometry = this.parser.read(wkt);\n\n    // TODO: port and use GeometryPrecisionReducer, this is a hack\n    if (this.precisionModel.getType() === PrecisionModel.FIXED) {\n      this.reducePrecision(geometry);\n    }\n\n    return geometry;\n  },\n  reducePrecision: function reducePrecision(geometry) {\n    if (geometry.coordinate) {\n      this.precisionModel.makePrecise(geometry.coordinate);\n    } else if (geometry._points) {\n      for (var i = 0, len = geometry._points._coordinates.length; i < len; i++) {\n        this.precisionModel.makePrecise(geometry._points._coordinates[i]);\n      }\n    } else if (geometry._geometries) {\n      for (var i = 0, len = geometry._geometries.length; i < len; i++) {\n        this.reducePrecision(geometry._geometries[i]);\n      }\n    }\n  }\n});\n\n/*eslint-disable no-undef */\n\nfunction p2c(p) {\n  return [p.x, p.y];\n}\n\n/**\n * OpenLayers 3 Geometry parser and writer\n * @param {GeometryFactory} geometryFactory\n * @param {ol} olReference\n * @constructor\n */\nfunction OL3Parser(geometryFactory, olReference) {\n  this.geometryFactory = geometryFactory || new GeometryFactory();\n  this.ol = olReference || typeof ol !== 'undefined' && ol;\n}\n\nextend(OL3Parser.prototype, {\n  /**\n   * @param geometry {ol.geom.Geometry}\n   * @return {Geometry}\n   * @memberof OL3Parser\n   */\n  read: function read(geometry) {\n    var ol = this.ol;\n    if (geometry instanceof ol.geom.Point) {\n      return this.convertFromPoint(geometry);\n    } else if (geometry instanceof ol.geom.LineString) {\n      return this.convertFromLineString(geometry);\n    } else if (geometry instanceof ol.geom.LinearRing) {\n      return this.convertFromLinearRing(geometry);\n    } else if (geometry instanceof ol.geom.Polygon) {\n      return this.convertFromPolygon(geometry);\n    } else if (geometry instanceof ol.geom.MultiPoint) {\n      return this.convertFromMultiPoint(geometry);\n    } else if (geometry instanceof ol.geom.MultiLineString) {\n      return this.convertFromMultiLineString(geometry);\n    } else if (geometry instanceof ol.geom.MultiPolygon) {\n      return this.convertFromMultiPolygon(geometry);\n    } else if (geometry instanceof ol.geom.GeometryCollection) {\n      return this.convertFromCollection(geometry);\n    }\n  },\n  convertFromPoint: function convertFromPoint(point) {\n    var coordinates = point.getCoordinates();\n    return this.geometryFactory.createPoint(new Coordinate(coordinates[0], coordinates[1]));\n  },\n  convertFromLineString: function convertFromLineString(lineString) {\n    return this.geometryFactory.createLineString(lineString.getCoordinates().map(function (coordinates) {\n      return new Coordinate(coordinates[0], coordinates[1]);\n    }));\n  },\n  convertFromLinearRing: function convertFromLinearRing(linearRing) {\n    return this.geometryFactory.createLinearRing(linearRing.getCoordinates().map(function (coordinates) {\n      return new Coordinate(coordinates[0], coordinates[1]);\n    }));\n  },\n  convertFromPolygon: function convertFromPolygon(polygon) {\n    var linearRings = polygon.getLinearRings();\n    var shell = null;\n    var holes = [];\n    for (var i = 0; i < linearRings.length; i++) {\n      var linearRing = this.convertFromLinearRing(linearRings[i]);\n      if (i === 0) {\n        shell = linearRing;\n      } else {\n        holes.push(linearRing);\n      }\n    }\n    return this.geometryFactory.createPolygon(shell, holes);\n  },\n  convertFromMultiPoint: function convertFromMultiPoint(multiPoint) {\n    var points = multiPoint.getPoints().map(function (point) {\n      return this.convertFromPoint(point);\n    }, this);\n    return this.geometryFactory.createMultiPoint(points);\n  },\n  convertFromMultiLineString: function convertFromMultiLineString(multiLineString) {\n    var lineStrings = multiLineString.getLineStrings().map(function (lineString) {\n      return this.convertFromLineString(lineString);\n    }, this);\n    return this.geometryFactory.createMultiLineString(lineStrings);\n  },\n  convertFromMultiPolygon: function convertFromMultiPolygon(multiPolygon) {\n    var polygons = multiPolygon.getPolygons().map(function (polygon) {\n      return this.convertFromPolygon(polygon);\n    }, this);\n    return this.geometryFactory.createMultiPolygon(polygons);\n  },\n  convertFromCollection: function convertFromCollection(collection) {\n    var geometries = collection.getGeometries().map(function (geometry) {\n      return this.read(geometry);\n    }, this);\n    return this.geometryFactory.createGeometryCollection(geometries);\n  },\n\n\n  /**\n   * @param geometry\n   *          {Geometry}\n   * @return {ol.geom.Geometry}\n   * @memberof! OL3Parser\n   */\n  write: function write(geometry) {\n    if (geometry.getGeometryType() === 'Point') {\n      return this.convertToPoint(geometry.getCoordinate());\n    } else if (geometry.getGeometryType() === 'LineString') {\n      return this.convertToLineString(geometry);\n    } else if (geometry.getGeometryType() === 'LinearRing') {\n      return this.convertToLinearRing(geometry);\n    } else if (geometry.getGeometryType() === 'Polygon') {\n      return this.convertToPolygon(geometry);\n    } else if (geometry.getGeometryType() === 'MultiPoint') {\n      return this.convertToMultiPoint(geometry);\n    } else if (geometry.getGeometryType() === 'MultiLineString') {\n      return this.convertToMultiLineString(geometry);\n    } else if (geometry.getGeometryType() === 'MultiPolygon') {\n      return this.convertToMultiPolygon(geometry);\n    } else if (geometry.getGeometryType() === 'GeometryCollection') {\n      return this.convertToCollection(geometry);\n    }\n  },\n  convertToPoint: function convertToPoint(coordinate) {\n    return new this.ol.geom.Point([coordinate.x, coordinate.y]);\n  },\n  convertToLineString: function convertToLineString(lineString) {\n    var points = lineString.points.coordinates.map(p2c);\n    return new this.ol.geom.LineString(points);\n  },\n  convertToLinearRing: function convertToLinearRing(linearRing) {\n    var points = linearRing.points.coordinates.map(p2c);\n    return new this.ol.geom.LinearRing(points);\n  },\n  convertToPolygon: function convertToPolygon(polygon) {\n    var rings = [polygon.shell.points.coordinates.map(p2c)];\n    for (var i = 0; i < polygon.holes.length; i++) {\n      rings.push(polygon.holes[i].points.coordinates.map(p2c));\n    }\n    return new this.ol.geom.Polygon(rings);\n  },\n  convertToMultiPoint: function convertToMultiPoint(multiPoint) {\n    return new this.ol.geom.MultiPoint(multiPoint.getCoordinates().map(p2c));\n  },\n  convertToMultiLineString: function convertToMultiLineString(multiLineString) {\n    var lineStrings = [];\n    for (var i = 0; i < multiLineString.geometries.length; i++) {\n      lineStrings.push(this.convertToLineString(multiLineString.geometries[i]).getCoordinates());\n    }\n    return new this.ol.geom.MultiLineString(lineStrings);\n  },\n  convertToMultiPolygon: function convertToMultiPolygon(multiPolygon) {\n    var polygons = [];\n    for (var i = 0; i < multiPolygon.geometries.length; i++) {\n      polygons.push(this.convertToPolygon(multiPolygon.geometries[i]).getCoordinates());\n    }\n    return new this.ol.geom.MultiPolygon(polygons);\n  },\n  convertToCollection: function convertToCollection(geometryCollection) {\n    var geometries = [];\n    for (var i = 0; i < geometryCollection.geometries.length; i++) {\n      var geometry = geometryCollection.geometries[i];\n      geometries.push(this.write(geometry));\n    }\n    return new this.ol.geom.GeometryCollection(geometries);\n  }\n});\n\nfunction ScaledNoder() {\n\tthis._noder = null;\n\tthis._scaleFactor = null;\n\tthis._offsetX = null;\n\tthis._offsetY = null;\n\tthis._isScaled = false;\n\tif (arguments.length === 2) {\n\t\tvar noder = arguments[0],\n\t\t    scaleFactor = arguments[1];\n\t\tScaledNoder.call(this, noder, scaleFactor, 0, 0);\n\t} else if (arguments.length === 4) {\n\t\tvar noder = arguments[0],\n\t\t    scaleFactor = arguments[1];\n\t\tthis._noder = noder;\n\t\tthis._scaleFactor = scaleFactor;\n\t\tthis._isScaled = !this.isIntegerPrecision();\n\t}\n}\nextend(ScaledNoder.prototype, {\n\trescale: function rescale() {\n\t\tif (hasInterface(arguments[0], Collection)) {\n\t\t\tvar segStrings = arguments[0];\n\t\t\tfor (var i = segStrings.iterator(); i.hasNext();) {\n\t\t\t\tvar ss = i.next();\n\t\t\t\tthis.rescale(ss.getCoordinates());\n\t\t\t}\n\t\t} else if (arguments[0] instanceof Array) {\n\t\t\tvar pts = arguments[0];\n\t\t\tvar p0 = null;\n\t\t\tvar p1 = null;\n\t\t\tif (pts.length === 2) {\n\t\t\t\tp0 = new Coordinate(pts[0]);\n\t\t\t\tp1 = new Coordinate(pts[1]);\n\t\t\t}\n\t\t\tfor (var i = 0; i < pts.length; i++) {\n\t\t\t\tpts[i].x = pts[i].x / this._scaleFactor + this._offsetX;\n\t\t\t\tpts[i].y = pts[i].y / this._scaleFactor + this._offsetY;\n\t\t\t}\n\t\t\tif (pts.length === 2 && pts[0].equals2D(pts[1])) {\n\t\t\t\tSystem.out.println(pts);\n\t\t\t}\n\t\t}\n\t},\n\tscale: function scale() {\n\t\tif (hasInterface(arguments[0], Collection)) {\n\t\t\tvar segStrings = arguments[0];\n\t\t\tvar nodedSegmentStrings = new ArrayList();\n\t\t\tfor (var i = segStrings.iterator(); i.hasNext();) {\n\t\t\t\tvar ss = i.next();\n\t\t\t\tnodedSegmentStrings.add(new NodedSegmentString(this.scale(ss.getCoordinates()), ss.getData()));\n\t\t\t}\n\t\t\treturn nodedSegmentStrings;\n\t\t} else if (arguments[0] instanceof Array) {\n\t\t\tvar pts = arguments[0];\n\t\t\tvar roundPts = new Array(pts.length).fill(null);\n\t\t\tfor (var i = 0; i < pts.length; i++) {\n\t\t\t\troundPts[i] = new Coordinate(Math.round((pts[i].x - this._offsetX) * this._scaleFactor), Math.round((pts[i].y - this._offsetY) * this._scaleFactor), pts[i].z);\n\t\t\t}\n\t\t\tvar roundPtsNoDup = CoordinateArrays.removeRepeatedPoints(roundPts);\n\t\t\treturn roundPtsNoDup;\n\t\t}\n\t},\n\tisIntegerPrecision: function isIntegerPrecision() {\n\t\treturn this._scaleFactor === 1.0;\n\t},\n\tgetNodedSubstrings: function getNodedSubstrings() {\n\t\tvar splitSS = this._noder.getNodedSubstrings();\n\t\tif (this._isScaled) this.rescale(splitSS);\n\t\treturn splitSS;\n\t},\n\tcomputeNodes: function computeNodes(inputSegStrings) {\n\t\tvar intSegStrings = inputSegStrings;\n\t\tif (this._isScaled) intSegStrings = this.scale(inputSegStrings);\n\t\tthis._noder.computeNodes(intSegStrings);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Noder];\n\t},\n\tgetClass: function getClass() {\n\t\treturn ScaledNoder;\n\t}\n});\n\nfunction IsSimpleOp() {\n\tthis._inputGeom = null;\n\tthis._isClosedEndpointsInInterior = true;\n\tthis._nonSimpleLocation = null;\n\tif (arguments.length === 1) {\n\t\tvar geom = arguments[0];\n\t\tthis._inputGeom = geom;\n\t} else if (arguments.length === 2) {\n\t\tvar geom = arguments[0],\n\t\t    boundaryNodeRule = arguments[1];\n\t\tthis._inputGeom = geom;\n\t\tthis._isClosedEndpointsInInterior = !boundaryNodeRule.isInBoundary(2);\n\t}\n}\nextend(IsSimpleOp.prototype, {\n\tisSimpleMultiPoint: function isSimpleMultiPoint(mp) {\n\t\tif (mp.isEmpty()) return true;\n\t\tvar points = new TreeSet();\n\t\tfor (var i = 0; i < mp.getNumGeometries(); i++) {\n\t\t\tvar pt = mp.getGeometryN(i);\n\t\t\tvar p = pt.getCoordinate();\n\t\t\tif (points.contains(p)) {\n\t\t\t\tthis._nonSimpleLocation = p;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpoints.add(p);\n\t\t}\n\t\treturn true;\n\t},\n\tisSimplePolygonal: function isSimplePolygonal(geom) {\n\t\tvar rings = LinearComponentExtracter.getLines(geom);\n\t\tfor (var i = rings.iterator(); i.hasNext();) {\n\t\t\tvar ring = i.next();\n\t\t\tif (!this.isSimpleLinearGeometry(ring)) return false;\n\t\t}\n\t\treturn true;\n\t},\n\thasClosedEndpointIntersection: function hasClosedEndpointIntersection(graph) {\n\t\tvar endPoints = new TreeMap();\n\t\tfor (var i = graph.getEdgeIterator(); i.hasNext();) {\n\t\t\tvar e = i.next();\n\t\t\tvar maxSegmentIndex = e.getMaximumSegmentIndex();\n\t\t\tvar isClosed = e.isClosed();\n\t\t\tvar p0 = e.getCoordinate(0);\n\t\t\tthis.addEndpoint(endPoints, p0, isClosed);\n\t\t\tvar p1 = e.getCoordinate(e.getNumPoints() - 1);\n\t\t\tthis.addEndpoint(endPoints, p1, isClosed);\n\t\t}\n\t\tfor (var i = endPoints.values().iterator(); i.hasNext();) {\n\t\t\tvar eiInfo = i.next();\n\t\t\tif (eiInfo.isClosed && eiInfo.degree !== 2) {\n\t\t\t\tthis._nonSimpleLocation = eiInfo.getCoordinate();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tgetNonSimpleLocation: function getNonSimpleLocation() {\n\t\treturn this._nonSimpleLocation;\n\t},\n\tisSimpleLinearGeometry: function isSimpleLinearGeometry(geom) {\n\t\tif (geom.isEmpty()) return true;\n\t\tvar graph = new GeometryGraph(0, geom);\n\t\tvar li = new RobustLineIntersector();\n\t\tvar si = graph.computeSelfNodes(li, true);\n\t\tif (!si.hasIntersection()) return true;\n\t\tif (si.hasProperIntersection()) {\n\t\t\tthis._nonSimpleLocation = si.getProperIntersectionPoint();\n\t\t\treturn false;\n\t\t}\n\t\tif (this.hasNonEndpointIntersection(graph)) return false;\n\t\tif (this._isClosedEndpointsInInterior) {\n\t\t\tif (this.hasClosedEndpointIntersection(graph)) return false;\n\t\t}\n\t\treturn true;\n\t},\n\thasNonEndpointIntersection: function hasNonEndpointIntersection(graph) {\n\t\tfor (var i = graph.getEdgeIterator(); i.hasNext();) {\n\t\t\tvar e = i.next();\n\t\t\tvar maxSegmentIndex = e.getMaximumSegmentIndex();\n\t\t\tfor (var eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext();) {\n\t\t\t\tvar ei = eiIt.next();\n\t\t\t\tif (!ei.isEndPoint(maxSegmentIndex)) {\n\t\t\t\t\tthis._nonSimpleLocation = ei.getCoordinate();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\taddEndpoint: function addEndpoint(endPoints, p, isClosed) {\n\t\tvar eiInfo = endPoints.get(p);\n\t\tif (eiInfo === null) {\n\t\t\teiInfo = new EndpointInfo(p);\n\t\t\tendPoints.put(p, eiInfo);\n\t\t}\n\t\teiInfo.addEndpoint(isClosed);\n\t},\n\tcomputeSimple: function computeSimple(geom) {\n\t\tthis._nonSimpleLocation = null;\n\t\tif (geom.isEmpty()) return true;\n\t\tif (geom instanceof LineString) return this.isSimpleLinearGeometry(geom);\n\t\tif (geom instanceof MultiLineString) return this.isSimpleLinearGeometry(geom);\n\t\tif (geom instanceof MultiPoint) return this.isSimpleMultiPoint(geom);\n\t\tif (hasInterface(geom, Polygonal)) return this.isSimplePolygonal(geom);\n\t\tif (geom instanceof GeometryCollection) return this.isSimpleGeometryCollection(geom);\n\t\treturn true;\n\t},\n\tisSimple: function isSimple() {\n\t\tthis._nonSimpleLocation = null;\n\t\treturn this.computeSimple(this._inputGeom);\n\t},\n\tisSimpleGeometryCollection: function isSimpleGeometryCollection(geom) {\n\t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n\t\t\tvar comp = geom.getGeometryN(i);\n\t\t\tif (!this.computeSimple(comp)) return false;\n\t\t}\n\t\treturn true;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn IsSimpleOp;\n\t}\n});\nfunction EndpointInfo() {\n\tthis.pt = null;\n\tthis.isClosed = null;\n\tthis.degree = null;\n\tvar pt = arguments[0];\n\tthis.pt = pt;\n\tthis.isClosed = false;\n\tthis.degree = 0;\n}\nextend(EndpointInfo.prototype, {\n\taddEndpoint: function addEndpoint(isClosed) {\n\t\tthis.degree++;\n\t\tthis.isClosed |= isClosed;\n\t},\n\tgetCoordinate: function getCoordinate() {\n\t\treturn this.pt;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn EndpointInfo;\n\t}\n});\nIsSimpleOp.EndpointInfo = EndpointInfo;\n\nfunction BufferParameters() {\n\tthis._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;\n\tthis._endCapStyle = BufferParameters.CAP_ROUND;\n\tthis._joinStyle = BufferParameters.JOIN_ROUND;\n\tthis._mitreLimit = BufferParameters.DEFAULT_MITRE_LIMIT;\n\tthis._isSingleSided = false;\n\tthis._simplifyFactor = BufferParameters.DEFAULT_SIMPLIFY_FACTOR;\n\tif (arguments.length === 0) {} else if (arguments.length === 1) {\n\t\tvar quadrantSegments = arguments[0];\n\t\tthis.setQuadrantSegments(quadrantSegments);\n\t} else if (arguments.length === 2) {\n\t\tvar quadrantSegments = arguments[0],\n\t\t    endCapStyle = arguments[1];\n\t\tthis.setQuadrantSegments(quadrantSegments);\n\t\tthis.setEndCapStyle(endCapStyle);\n\t} else if (arguments.length === 4) {\n\t\tvar quadrantSegments = arguments[0],\n\t\t    endCapStyle = arguments[1],\n\t\t    joinStyle = arguments[2],\n\t\t    mitreLimit = arguments[3];\n\t\tthis.setQuadrantSegments(quadrantSegments);\n\t\tthis.setEndCapStyle(endCapStyle);\n\t\tthis.setJoinStyle(joinStyle);\n\t\tthis.setMitreLimit(mitreLimit);\n\t}\n}\nextend(BufferParameters.prototype, {\n\tgetEndCapStyle: function getEndCapStyle() {\n\t\treturn this._endCapStyle;\n\t},\n\tisSingleSided: function isSingleSided() {\n\t\treturn this._isSingleSided;\n\t},\n\tsetQuadrantSegments: function setQuadrantSegments(quadSegs) {\n\t\tthis._quadrantSegments = quadSegs;\n\t\tif (this._quadrantSegments === 0) this._joinStyle = BufferParameters.JOIN_BEVEL;\n\t\tif (this._quadrantSegments < 0) {\n\t\t\tthis._joinStyle = BufferParameters.JOIN_MITRE;\n\t\t\tthis._mitreLimit = Math.abs(this._quadrantSegments);\n\t\t}\n\t\tif (quadSegs <= 0) {\n\t\t\tthis._quadrantSegments = 1;\n\t\t}\n\t\tif (this._joinStyle !== BufferParameters.JOIN_ROUND) {\n\t\t\tthis._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;\n\t\t}\n\t},\n\tgetJoinStyle: function getJoinStyle() {\n\t\treturn this._joinStyle;\n\t},\n\tsetJoinStyle: function setJoinStyle(joinStyle) {\n\t\tthis._joinStyle = joinStyle;\n\t},\n\tsetSimplifyFactor: function setSimplifyFactor(simplifyFactor) {\n\t\tthis._simplifyFactor = simplifyFactor < 0 ? 0 : simplifyFactor;\n\t},\n\tgetSimplifyFactor: function getSimplifyFactor() {\n\t\treturn this._simplifyFactor;\n\t},\n\tgetQuadrantSegments: function getQuadrantSegments() {\n\t\treturn this._quadrantSegments;\n\t},\n\tsetEndCapStyle: function setEndCapStyle(endCapStyle) {\n\t\tthis._endCapStyle = endCapStyle;\n\t},\n\tgetMitreLimit: function getMitreLimit() {\n\t\treturn this._mitreLimit;\n\t},\n\tsetMitreLimit: function setMitreLimit(mitreLimit) {\n\t\tthis._mitreLimit = mitreLimit;\n\t},\n\tsetSingleSided: function setSingleSided(isSingleSided) {\n\t\tthis._isSingleSided = isSingleSided;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn BufferParameters;\n\t}\n});\nBufferParameters.bufferDistanceError = function (quadSegs) {\n\tvar alpha = Math.PI / 2.0 / quadSegs;\n\treturn 1 - Math.cos(alpha / 2.0);\n};\nBufferParameters.CAP_ROUND = 1;\nBufferParameters.CAP_FLAT = 2;\nBufferParameters.CAP_SQUARE = 3;\nBufferParameters.JOIN_ROUND = 1;\nBufferParameters.JOIN_MITRE = 2;\nBufferParameters.JOIN_BEVEL = 3;\nBufferParameters.DEFAULT_QUADRANT_SEGMENTS = 8;\nBufferParameters.DEFAULT_MITRE_LIMIT = 5.0;\nBufferParameters.DEFAULT_SIMPLIFY_FACTOR = 0.01;\n\nfunction RightmostEdgeFinder() {\n\tthis._minIndex = -1;\n\tthis._minCoord = null;\n\tthis._minDe = null;\n\tthis._orientedDe = null;\n}\nextend(RightmostEdgeFinder.prototype, {\n\tgetCoordinate: function getCoordinate() {\n\t\treturn this._minCoord;\n\t},\n\tgetRightmostSide: function getRightmostSide(de, index) {\n\t\tvar side = this.getRightmostSideOfSegment(de, index);\n\t\tif (side < 0) side = this.getRightmostSideOfSegment(de, index - 1);\n\t\tif (side < 0) {\n\t\t\tthis._minCoord = null;\n\t\t\tthis.checkForRightmostCoordinate(de);\n\t\t}\n\t\treturn side;\n\t},\n\tfindRightmostEdgeAtVertex: function findRightmostEdgeAtVertex() {\n\t\tvar pts = this._minDe.getEdge().getCoordinates();\n\t\tAssert.isTrue(this._minIndex > 0 && this._minIndex < pts.length, \"rightmost point expected to be interior vertex of edge\");\n\t\tvar pPrev = pts[this._minIndex - 1];\n\t\tvar pNext = pts[this._minIndex + 1];\n\t\tvar orientation = CGAlgorithms.computeOrientation(this._minCoord, pNext, pPrev);\n\t\tvar usePrev = false;\n\t\tif (pPrev.y < this._minCoord.y && pNext.y < this._minCoord.y && orientation === CGAlgorithms.COUNTERCLOCKWISE) {\n\t\t\tusePrev = true;\n\t\t} else if (pPrev.y > this._minCoord.y && pNext.y > this._minCoord.y && orientation === CGAlgorithms.CLOCKWISE) {\n\t\t\tusePrev = true;\n\t\t}\n\t\tif (usePrev) {\n\t\t\tthis._minIndex = this._minIndex - 1;\n\t\t}\n\t},\n\tgetRightmostSideOfSegment: function getRightmostSideOfSegment(de, i) {\n\t\tvar e = de.getEdge();\n\t\tvar coord = e.getCoordinates();\n\t\tif (i < 0 || i + 1 >= coord.length) return -1;\n\t\tif (coord[i].y === coord[i + 1].y) return -1;\n\t\tvar pos = Position.LEFT;\n\t\tif (coord[i].y < coord[i + 1].y) pos = Position.RIGHT;\n\t\treturn pos;\n\t},\n\tgetEdge: function getEdge() {\n\t\treturn this._orientedDe;\n\t},\n\tcheckForRightmostCoordinate: function checkForRightmostCoordinate(de) {\n\t\tvar coord = de.getEdge().getCoordinates();\n\t\tfor (var i = 0; i < coord.length - 1; i++) {\n\t\t\tif (this._minCoord === null || coord[i].x > this._minCoord.x) {\n\t\t\t\tthis._minDe = de;\n\t\t\t\tthis._minIndex = i;\n\t\t\t\tthis._minCoord = coord[i];\n\t\t\t}\n\t\t}\n\t},\n\tfindRightmostEdgeAtNode: function findRightmostEdgeAtNode() {\n\t\tvar node = this._minDe.getNode();\n\t\tvar star = node.getEdges();\n\t\tthis._minDe = star.getRightmostEdge();\n\t\tif (!this._minDe.isForward()) {\n\t\t\tthis._minDe = this._minDe.getSym();\n\t\t\tthis._minIndex = this._minDe.getEdge().getCoordinates().length - 1;\n\t\t}\n\t},\n\tfindEdge: function findEdge(dirEdgeList) {\n\t\tfor (var i = dirEdgeList.iterator(); i.hasNext();) {\n\t\t\tvar de = i.next();\n\t\t\tif (!de.isForward()) continue;\n\t\t\tthis.checkForRightmostCoordinate(de);\n\t\t}\n\t\tAssert.isTrue(this._minIndex !== 0 || this._minCoord.equals(this._minDe.getCoordinate()), \"inconsistency in rightmost processing\");\n\t\tif (this._minIndex === 0) {\n\t\t\tthis.findRightmostEdgeAtNode();\n\t\t} else {\n\t\t\tthis.findRightmostEdgeAtVertex();\n\t\t}\n\t\tthis._orientedDe = this._minDe;\n\t\tvar rightmostSide = this.getRightmostSide(this._minDe, this._minIndex);\n\t\tif (rightmostSide === Position.LEFT) {\n\t\t\tthis._orientedDe = this._minDe.getSym();\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn RightmostEdgeFinder;\n\t}\n});\n\nfunction LinkedList() {\n  this.array_ = [];\n}\nLinkedList.prototype.addLast = function (e) {\n  this.array_.push(e);\n};\nLinkedList.prototype.removeFirst = function () {\n  return this.array_.shift();\n};\nLinkedList.prototype.isEmpty = function () {\n  return this.array_.length === 0;\n};\n\nfunction BufferSubgraph() {\n\tthis._finder = null;\n\tthis._dirEdgeList = new ArrayList();\n\tthis._nodes = new ArrayList();\n\tthis._rightMostCoord = null;\n\tthis._env = null;\n\tthis._finder = new RightmostEdgeFinder();\n}\nextend(BufferSubgraph.prototype, {\n\tclearVisitedEdges: function clearVisitedEdges() {\n\t\tfor (var it = this._dirEdgeList.iterator(); it.hasNext();) {\n\t\t\tvar de = it.next();\n\t\t\tde.setVisited(false);\n\t\t}\n\t},\n\tgetRightmostCoordinate: function getRightmostCoordinate() {\n\t\treturn this._rightMostCoord;\n\t},\n\tcomputeNodeDepth: function computeNodeDepth(n) {\n\t\tvar startEdge = null;\n\t\tfor (var i = n.getEdges().iterator(); i.hasNext();) {\n\t\t\tvar de = i.next();\n\t\t\tif (de.isVisited() || de.getSym().isVisited()) {\n\t\t\t\tstartEdge = de;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (startEdge === null) throw new TopologyException(\"unable to find edge to compute depths at \" + n.getCoordinate());\n\t\tn.getEdges().computeDepths(startEdge);\n\t\tfor (var i = n.getEdges().iterator(); i.hasNext();) {\n\t\t\tvar de = i.next();\n\t\t\tde.setVisited(true);\n\t\t\tthis.copySymDepths(de);\n\t\t}\n\t},\n\tcomputeDepth: function computeDepth(outsideDepth) {\n\t\tthis.clearVisitedEdges();\n\t\tvar de = this._finder.getEdge();\n\t\tvar n = de.getNode();\n\t\tvar label = de.getLabel();\n\t\tde.setEdgeDepths(Position.RIGHT, outsideDepth);\n\t\tthis.copySymDepths(de);\n\t\tthis.computeDepths(de);\n\t},\n\tcreate: function create(node) {\n\t\tthis.addReachable(node);\n\t\tthis._finder.findEdge(this._dirEdgeList);\n\t\tthis._rightMostCoord = this._finder.getCoordinate();\n\t},\n\tfindResultEdges: function findResultEdges() {\n\t\tfor (var it = this._dirEdgeList.iterator(); it.hasNext();) {\n\t\t\tvar de = it.next();\n\t\t\tif (de.getDepth(Position.RIGHT) >= 1 && de.getDepth(Position.LEFT) <= 0 && !de.isInteriorAreaEdge()) {\n\t\t\t\tde.setInResult(true);\n\t\t\t}\n\t\t}\n\t},\n\tcomputeDepths: function computeDepths(startEdge) {\n\t\tvar nodesVisited = new HashSet();\n\t\tvar nodeQueue = new LinkedList();\n\t\tvar startNode = startEdge.getNode();\n\t\tnodeQueue.addLast(startNode);\n\t\tnodesVisited.add(startNode);\n\t\tstartEdge.setVisited(true);\n\t\twhile (!nodeQueue.isEmpty()) {\n\t\t\tvar n = nodeQueue.removeFirst();\n\t\t\tnodesVisited.add(n);\n\t\t\tthis.computeNodeDepth(n);\n\t\t\tfor (var i = n.getEdges().iterator(); i.hasNext();) {\n\t\t\t\tvar de = i.next();\n\t\t\t\tvar sym = de.getSym();\n\t\t\t\tif (sym.isVisited()) continue;\n\t\t\t\tvar adjNode = sym.getNode();\n\t\t\t\tif (!nodesVisited.contains(adjNode)) {\n\t\t\t\t\tnodeQueue.addLast(adjNode);\n\t\t\t\t\tnodesVisited.add(adjNode);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tcompareTo: function compareTo(o) {\n\t\tvar graph = o;\n\t\tif (this._rightMostCoord.x < graph._rightMostCoord.x) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (this._rightMostCoord.x > graph._rightMostCoord.x) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t},\n\tgetEnvelope: function getEnvelope() {\n\t\tif (this._env === null) {\n\t\t\tvar edgeEnv = new Envelope();\n\t\t\tfor (var it = this._dirEdgeList.iterator(); it.hasNext();) {\n\t\t\t\tvar dirEdge = it.next();\n\t\t\t\tvar pts = dirEdge.getEdge().getCoordinates();\n\t\t\t\tfor (var i = 0; i < pts.length - 1; i++) {\n\t\t\t\t\tedgeEnv.expandToInclude(pts[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._env = edgeEnv;\n\t\t}\n\t\treturn this._env;\n\t},\n\taddReachable: function addReachable(startNode) {\n\t\tvar nodeStack = new Stack$2();\n\t\tnodeStack.add(startNode);\n\t\twhile (!nodeStack.empty()) {\n\t\t\tvar node = nodeStack.pop();\n\t\t\tthis.add(node, nodeStack);\n\t\t}\n\t},\n\tcopySymDepths: function copySymDepths(de) {\n\t\tvar sym = de.getSym();\n\t\tsym.setDepth(Position.LEFT, de.getDepth(Position.RIGHT));\n\t\tsym.setDepth(Position.RIGHT, de.getDepth(Position.LEFT));\n\t},\n\tadd: function add(node, nodeStack) {\n\t\tnode.setVisited(true);\n\t\tthis._nodes.add(node);\n\t\tfor (var i = node.getEdges().iterator(); i.hasNext();) {\n\t\t\tvar de = i.next();\n\t\t\tthis._dirEdgeList.add(de);\n\t\t\tvar sym = de.getSym();\n\t\t\tvar symNode = sym.getNode();\n\t\t\tif (!symNode.isVisited()) nodeStack.push(symNode);\n\t\t}\n\t},\n\tgetNodes: function getNodes() {\n\t\treturn this._nodes;\n\t},\n\tgetDirectedEdges: function getDirectedEdges() {\n\t\treturn this._dirEdgeList;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Comparable];\n\t},\n\tgetClass: function getClass() {\n\t\treturn BufferSubgraph;\n\t}\n});\n\nfunction BufferInputLineSimplifier() {\n\tthis._inputLine = null;\n\tthis._distanceTol = null;\n\tthis._isDeleted = null;\n\tthis._angleOrientation = CGAlgorithms.COUNTERCLOCKWISE;\n\tvar inputLine = arguments[0];\n\tthis._inputLine = inputLine;\n}\nextend(BufferInputLineSimplifier.prototype, {\n\tisDeletable: function isDeletable(i0, i1, i2, distanceTol) {\n\t\tvar p0 = this._inputLine[i0];\n\t\tvar p1 = this._inputLine[i1];\n\t\tvar p2 = this._inputLine[i2];\n\t\tif (!this.isConcave(p0, p1, p2)) return false;\n\t\tif (!this.isShallow(p0, p1, p2, distanceTol)) return false;\n\t\treturn this.isShallowSampled(p0, p1, i0, i2, distanceTol);\n\t},\n\tdeleteShallowConcavities: function deleteShallowConcavities() {\n\t\tvar index = 1;\n\t\tvar maxIndex = this._inputLine.length - 1;\n\t\tvar midIndex = this.findNextNonDeletedIndex(index);\n\t\tvar lastIndex = this.findNextNonDeletedIndex(midIndex);\n\t\tvar isChanged = false;\n\t\twhile (lastIndex < this._inputLine.length) {\n\t\t\tvar isMiddleVertexDeleted = false;\n\t\t\tif (this.isDeletable(index, midIndex, lastIndex, this._distanceTol)) {\n\t\t\t\tthis._isDeleted[midIndex] = BufferInputLineSimplifier.DELETE;\n\t\t\t\tisMiddleVertexDeleted = true;\n\t\t\t\tisChanged = true;\n\t\t\t}\n\t\t\tif (isMiddleVertexDeleted) index = lastIndex;else index = midIndex;\n\t\t\tmidIndex = this.findNextNonDeletedIndex(index);\n\t\t\tlastIndex = this.findNextNonDeletedIndex(midIndex);\n\t\t}\n\t\treturn isChanged;\n\t},\n\tisShallowConcavity: function isShallowConcavity(p0, p1, p2, distanceTol) {\n\t\tvar orientation = CGAlgorithms.computeOrientation(p0, p1, p2);\n\t\tvar isAngleToSimplify = orientation === this._angleOrientation;\n\t\tif (!isAngleToSimplify) return false;\n\t\tvar dist = CGAlgorithms.distancePointLine(p1, p0, p2);\n\t\treturn dist < distanceTol;\n\t},\n\tisShallowSampled: function isShallowSampled(p0, p2, i0, i2, distanceTol) {\n\t\tvar inc = Math.trunc((i2 - i0) / BufferInputLineSimplifier.NUM_PTS_TO_CHECK);\n\t\tif (inc <= 0) inc = 1;\n\t\tfor (var i = i0; i < i2; i += inc) {\n\t\t\tif (!this.isShallow(p0, p2, this._inputLine[i], distanceTol)) return false;\n\t\t}\n\t\treturn true;\n\t},\n\tisConcave: function isConcave(p0, p1, p2) {\n\t\tvar orientation = CGAlgorithms.computeOrientation(p0, p1, p2);\n\t\tvar isConcave = orientation === this._angleOrientation;\n\t\treturn isConcave;\n\t},\n\tsimplify: function simplify(distanceTol) {\n\t\tthis._distanceTol = Math.abs(distanceTol);\n\t\tif (distanceTol < 0) this._angleOrientation = CGAlgorithms.CLOCKWISE;\n\t\tthis._isDeleted = new Array(this._inputLine.length).fill(null);\n\t\tvar isChanged = false;\n\t\tdo {\n\t\t\tisChanged = this.deleteShallowConcavities();\n\t\t} while (isChanged);\n\t\treturn this.collapseLine();\n\t},\n\tfindNextNonDeletedIndex: function findNextNonDeletedIndex(index) {\n\t\tvar next = index + 1;\n\t\twhile (next < this._inputLine.length && this._isDeleted[next] === BufferInputLineSimplifier.DELETE) {\n\t\t\tnext++;\n\t\t}return next;\n\t},\n\tisShallow: function isShallow(p0, p1, p2, distanceTol) {\n\t\tvar dist = CGAlgorithms.distancePointLine(p1, p0, p2);\n\t\treturn dist < distanceTol;\n\t},\n\tcollapseLine: function collapseLine() {\n\t\tvar coordList = new CoordinateList();\n\t\tfor (var i = 0; i < this._inputLine.length; i++) {\n\t\t\tif (this._isDeleted[i] !== BufferInputLineSimplifier.DELETE) coordList.add(this._inputLine[i]);\n\t\t}\n\t\treturn coordList.toCoordinateArray();\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn BufferInputLineSimplifier;\n\t}\n});\nBufferInputLineSimplifier.simplify = function (inputLine, distanceTol) {\n\tvar simp = new BufferInputLineSimplifier(inputLine);\n\treturn simp.simplify(distanceTol);\n};\nBufferInputLineSimplifier.INIT = 0;\nBufferInputLineSimplifier.DELETE = 1;\nBufferInputLineSimplifier.KEEP = 1;\nBufferInputLineSimplifier.NUM_PTS_TO_CHECK = 10;\n\nfunction OffsetSegmentString() {\n\tthis._ptList = null;\n\tthis._precisionModel = null;\n\tthis._minimimVertexDistance = 0.0;\n\tthis._ptList = new ArrayList();\n}\nextend(OffsetSegmentString.prototype, {\n\tgetCoordinates: function getCoordinates() {\n\t\tvar coord = this._ptList.toArray(OffsetSegmentString.COORDINATE_ARRAY_TYPE);\n\t\treturn coord;\n\t},\n\tsetPrecisionModel: function setPrecisionModel(precisionModel) {\n\t\tthis._precisionModel = precisionModel;\n\t},\n\taddPt: function addPt(pt) {\n\t\tvar bufPt = new Coordinate(pt);\n\t\tthis._precisionModel.makePrecise(bufPt);\n\t\tif (this.isRedundant(bufPt)) return null;\n\t\tthis._ptList.add(bufPt);\n\t},\n\treverse: function reverse() {},\n\taddPts: function addPts(pt, isForward) {\n\t\tif (isForward) {\n\t\t\tfor (var i = 0; i < pt.length; i++) {\n\t\t\t\tthis.addPt(pt[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (var i = pt.length - 1; i >= 0; i--) {\n\t\t\t\tthis.addPt(pt[i]);\n\t\t\t}\n\t\t}\n\t},\n\tisRedundant: function isRedundant(pt) {\n\t\tif (this._ptList.size() < 1) return false;\n\t\tvar lastPt = this._ptList.get(this._ptList.size() - 1);\n\t\tvar ptDist = pt.distance(lastPt);\n\t\tif (ptDist < this._minimimVertexDistance) return true;\n\t\treturn false;\n\t},\n\ttoString: function toString() {\n\t\tvar fact = new GeometryFactory();\n\t\tvar line = fact.createLineString(this.getCoordinates());\n\t\treturn line.toString();\n\t},\n\tcloseRing: function closeRing() {\n\t\tif (this._ptList.size() < 1) return null;\n\t\tvar startPt = new Coordinate(this._ptList.get(0));\n\t\tvar lastPt = this._ptList.get(this._ptList.size() - 1);\n\t\tvar last2Pt = null;\n\t\tif (this._ptList.size() >= 2) last2Pt = this._ptList.get(this._ptList.size() - 2);\n\t\tif (startPt.equals(lastPt)) return null;\n\t\tthis._ptList.add(startPt);\n\t},\n\tsetMinimumVertexDistance: function setMinimumVertexDistance(minimimVertexDistance) {\n\t\tthis._minimimVertexDistance = minimimVertexDistance;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn OffsetSegmentString;\n\t}\n});\nOffsetSegmentString.COORDINATE_ARRAY_TYPE = new Array(0).fill(null);\n\nfunction OffsetSegmentGenerator() {\n\tthis._maxCurveSegmentError = 0.0;\n\tthis._filletAngleQuantum = null;\n\tthis._closingSegLengthFactor = 1;\n\tthis._segList = null;\n\tthis._distance = 0.0;\n\tthis._precisionModel = null;\n\tthis._bufParams = null;\n\tthis._li = null;\n\tthis._s0 = null;\n\tthis._s1 = null;\n\tthis._s2 = null;\n\tthis._seg0 = new LineSegment();\n\tthis._seg1 = new LineSegment();\n\tthis._offset0 = new LineSegment();\n\tthis._offset1 = new LineSegment();\n\tthis._side = 0;\n\tthis._hasNarrowConcaveAngle = false;\n\tvar precisionModel = arguments[0],\n\t    bufParams = arguments[1],\n\t    distance = arguments[2];\n\tthis._precisionModel = precisionModel;\n\tthis._bufParams = bufParams;\n\tthis._li = new RobustLineIntersector();\n\tthis._filletAngleQuantum = Math.PI / 2.0 / bufParams.getQuadrantSegments();\n\tif (bufParams.getQuadrantSegments() >= 8 && bufParams.getJoinStyle() === BufferParameters.JOIN_ROUND) this._closingSegLengthFactor = OffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR;\n\tthis.init(distance);\n}\nextend(OffsetSegmentGenerator.prototype, {\n\taddNextSegment: function addNextSegment(p, addStartPoint) {\n\t\tthis._s0 = this._s1;\n\t\tthis._s1 = this._s2;\n\t\tthis._s2 = p;\n\t\tthis._seg0.setCoordinates(this._s0, this._s1);\n\t\tthis.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0);\n\t\tthis._seg1.setCoordinates(this._s1, this._s2);\n\t\tthis.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1);\n\t\tif (this._s1.equals(this._s2)) return null;\n\t\tvar orientation = CGAlgorithms.computeOrientation(this._s0, this._s1, this._s2);\n\t\tvar outsideTurn = orientation === CGAlgorithms.CLOCKWISE && this._side === Position.LEFT || orientation === CGAlgorithms.COUNTERCLOCKWISE && this._side === Position.RIGHT;\n\t\tif (orientation === 0) {\n\t\t\tthis.addCollinear(addStartPoint);\n\t\t} else if (outsideTurn) {\n\t\t\tthis.addOutsideTurn(orientation, addStartPoint);\n\t\t} else {\n\t\t\tthis.addInsideTurn(orientation, addStartPoint);\n\t\t}\n\t},\n\taddLineEndCap: function addLineEndCap(p0, p1) {\n\t\tvar seg = new LineSegment(p0, p1);\n\t\tvar offsetL = new LineSegment();\n\t\tthis.computeOffsetSegment(seg, Position.LEFT, this._distance, offsetL);\n\t\tvar offsetR = new LineSegment();\n\t\tthis.computeOffsetSegment(seg, Position.RIGHT, this._distance, offsetR);\n\t\tvar dx = p1.x - p0.x;\n\t\tvar dy = p1.y - p0.y;\n\t\tvar angle = Math.atan2(dy, dx);\n\t\tswitch (this._bufParams.getEndCapStyle()) {\n\t\t\tcase BufferParameters.CAP_ROUND:\n\t\t\t\tthis._segList.addPt(offsetL.p1);\n\t\t\t\tthis.addFilletArc(p1, angle + Math.PI / 2, angle - Math.PI / 2, CGAlgorithms.CLOCKWISE, this._distance);\n\t\t\t\tthis._segList.addPt(offsetR.p1);\n\t\t\t\tbreak;\n\t\t\tcase BufferParameters.CAP_FLAT:\n\t\t\t\tthis._segList.addPt(offsetL.p1);\n\t\t\t\tthis._segList.addPt(offsetR.p1);\n\t\t\t\tbreak;\n\t\t\tcase BufferParameters.CAP_SQUARE:\n\t\t\t\tvar squareCapSideOffset = new Coordinate();\n\t\t\t\tsquareCapSideOffset.x = Math.abs(this._distance) * Math.cos(angle);\n\t\t\t\tsquareCapSideOffset.y = Math.abs(this._distance) * Math.sin(angle);\n\t\t\t\tvar squareCapLOffset = new Coordinate(offsetL.p1.x + squareCapSideOffset.x, offsetL.p1.y + squareCapSideOffset.y);\n\t\t\t\tvar squareCapROffset = new Coordinate(offsetR.p1.x + squareCapSideOffset.x, offsetR.p1.y + squareCapSideOffset.y);\n\t\t\t\tthis._segList.addPt(squareCapLOffset);\n\t\t\t\tthis._segList.addPt(squareCapROffset);\n\t\t\t\tbreak;\n\t\t}\n\t},\n\tgetCoordinates: function getCoordinates() {\n\t\tvar pts = this._segList.getCoordinates();\n\t\treturn pts;\n\t},\n\taddMitreJoin: function addMitreJoin(p, offset0, offset1, distance) {\n\t\tvar isMitreWithinLimit = true;\n\t\tvar intPt = null;\n\t\ttry {\n\t\t\tintPt = HCoordinate.intersection(offset0.p0, offset0.p1, offset1.p0, offset1.p1);\n\t\t\tvar mitreRatio = distance <= 0.0 ? 1.0 : intPt.distance(p) / Math.abs(distance);\n\t\t\tif (mitreRatio > this._bufParams.getMitreLimit()) isMitreWithinLimit = false;\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof NotRepresentableException) {\n\t\t\t\tintPt = new Coordinate(0, 0);\n\t\t\t\tisMitreWithinLimit = false;\n\t\t\t} else throw ex;\n\t\t} finally {}\n\t\tif (isMitreWithinLimit) {\n\t\t\tthis._segList.addPt(intPt);\n\t\t} else {\n\t\t\tthis.addLimitedMitreJoin(offset0, offset1, distance, this._bufParams.getMitreLimit());\n\t\t}\n\t},\n\taddFilletCorner: function addFilletCorner(p, p0, p1, direction, radius) {\n\t\tvar dx0 = p0.x - p.x;\n\t\tvar dy0 = p0.y - p.y;\n\t\tvar startAngle = Math.atan2(dy0, dx0);\n\t\tvar dx1 = p1.x - p.x;\n\t\tvar dy1 = p1.y - p.y;\n\t\tvar endAngle = Math.atan2(dy1, dx1);\n\t\tif (direction === CGAlgorithms.CLOCKWISE) {\n\t\t\tif (startAngle <= endAngle) startAngle += 2.0 * Math.PI;\n\t\t} else {\n\t\t\tif (startAngle >= endAngle) startAngle -= 2.0 * Math.PI;\n\t\t}\n\t\tthis._segList.addPt(p0);\n\t\tthis.addFilletArc(p, startAngle, endAngle, direction, radius);\n\t\tthis._segList.addPt(p1);\n\t},\n\taddOutsideTurn: function addOutsideTurn(orientation, addStartPoint) {\n\t\tif (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR) {\n\t\t\tthis._segList.addPt(this._offset0.p1);\n\t\t\treturn null;\n\t\t}\n\t\tif (this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {\n\t\t\tthis.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance);\n\t\t} else if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL) {\n\t\t\tthis.addBevelJoin(this._offset0, this._offset1);\n\t\t} else {\n\t\t\tif (addStartPoint) this._segList.addPt(this._offset0.p1);\n\t\t\tthis.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, orientation, this._distance);\n\t\t\tthis._segList.addPt(this._offset1.p0);\n\t\t}\n\t},\n\tcreateSquare: function createSquare(p) {\n\t\tthis._segList.addPt(new Coordinate(p.x + this._distance, p.y + this._distance));\n\t\tthis._segList.addPt(new Coordinate(p.x + this._distance, p.y - this._distance));\n\t\tthis._segList.addPt(new Coordinate(p.x - this._distance, p.y - this._distance));\n\t\tthis._segList.addPt(new Coordinate(p.x - this._distance, p.y + this._distance));\n\t\tthis._segList.closeRing();\n\t},\n\taddSegments: function addSegments(pt, isForward) {\n\t\tthis._segList.addPts(pt, isForward);\n\t},\n\taddFirstSegment: function addFirstSegment() {\n\t\tthis._segList.addPt(this._offset1.p0);\n\t},\n\taddLastSegment: function addLastSegment() {\n\t\tthis._segList.addPt(this._offset1.p1);\n\t},\n\tinitSideSegments: function initSideSegments(s1, s2, side) {\n\t\tthis._s1 = s1;\n\t\tthis._s2 = s2;\n\t\tthis._side = side;\n\t\tthis._seg1.setCoordinates(s1, s2);\n\t\tthis.computeOffsetSegment(this._seg1, side, this._distance, this._offset1);\n\t},\n\taddLimitedMitreJoin: function addLimitedMitreJoin(offset0, offset1, distance, mitreLimit) {\n\t\tvar basePt = this._seg0.p1;\n\t\tvar ang0 = Angle.angle(basePt, this._seg0.p0);\n\t\tvar ang1 = Angle.angle(basePt, this._seg1.p1);\n\t\tvar angDiff = Angle.angleBetweenOriented(this._seg0.p0, basePt, this._seg1.p1);\n\t\tvar angDiffHalf = angDiff / 2;\n\t\tvar midAng = Angle.normalize(ang0 + angDiffHalf);\n\t\tvar mitreMidAng = Angle.normalize(midAng + Math.PI);\n\t\tvar mitreDist = mitreLimit * distance;\n\t\tvar bevelDelta = mitreDist * Math.abs(Math.sin(angDiffHalf));\n\t\tvar bevelHalfLen = distance - bevelDelta;\n\t\tvar bevelMidX = basePt.x + mitreDist * Math.cos(mitreMidAng);\n\t\tvar bevelMidY = basePt.y + mitreDist * Math.sin(mitreMidAng);\n\t\tvar bevelMidPt = new Coordinate(bevelMidX, bevelMidY);\n\t\tvar mitreMidLine = new LineSegment(basePt, bevelMidPt);\n\t\tvar bevelEndLeft = mitreMidLine.pointAlongOffset(1.0, bevelHalfLen);\n\t\tvar bevelEndRight = mitreMidLine.pointAlongOffset(1.0, -bevelHalfLen);\n\t\tif (this._side === Position.LEFT) {\n\t\t\tthis._segList.addPt(bevelEndLeft);\n\t\t\tthis._segList.addPt(bevelEndRight);\n\t\t} else {\n\t\t\tthis._segList.addPt(bevelEndRight);\n\t\t\tthis._segList.addPt(bevelEndLeft);\n\t\t}\n\t},\n\tcomputeOffsetSegment: function computeOffsetSegment(seg, side, distance, offset) {\n\t\tvar sideSign = side === Position.LEFT ? 1 : -1;\n\t\tvar dx = seg.p1.x - seg.p0.x;\n\t\tvar dy = seg.p1.y - seg.p0.y;\n\t\tvar len = Math.sqrt(dx * dx + dy * dy);\n\t\tvar ux = sideSign * distance * dx / len;\n\t\tvar uy = sideSign * distance * dy / len;\n\t\toffset.p0.x = seg.p0.x - uy;\n\t\toffset.p0.y = seg.p0.y + ux;\n\t\toffset.p1.x = seg.p1.x - uy;\n\t\toffset.p1.y = seg.p1.y + ux;\n\t},\n\taddFilletArc: function addFilletArc(p, startAngle, endAngle, direction, radius) {\n\t\tvar directionFactor = direction === CGAlgorithms.CLOCKWISE ? -1 : 1;\n\t\tvar totalAngle = Math.abs(startAngle - endAngle);\n\t\tvar nSegs = Math.trunc(totalAngle / this._filletAngleQuantum + 0.5);\n\t\tif (nSegs < 1) return null;\n\t\tvar initAngle = null,\n\t\t    currAngleInc = null;\n\t\tinitAngle = 0.0;\n\t\tcurrAngleInc = totalAngle / nSegs;\n\t\tvar currAngle = initAngle;\n\t\tvar pt = new Coordinate();\n\t\twhile (currAngle < totalAngle) {\n\t\t\tvar angle = startAngle + directionFactor * currAngle;\n\t\t\tpt.x = p.x + radius * Math.cos(angle);\n\t\t\tpt.y = p.y + radius * Math.sin(angle);\n\t\t\tthis._segList.addPt(pt);\n\t\t\tcurrAngle += currAngleInc;\n\t\t}\n\t},\n\taddInsideTurn: function addInsideTurn(orientation, addStartPoint) {\n\t\tthis._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1);\n\t\tif (this._li.hasIntersection()) {\n\t\t\tthis._segList.addPt(this._li.getIntersection(0));\n\t\t} else {\n\t\t\tthis._hasNarrowConcaveAngle = true;\n\t\t\tif (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) {\n\t\t\t\tthis._segList.addPt(this._offset0.p1);\n\t\t\t} else {\n\t\t\t\tthis._segList.addPt(this._offset0.p1);\n\t\t\t\tif (this._closingSegLengthFactor > 0) {\n\t\t\t\t\tvar mid0 = new Coordinate((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));\n\t\t\t\t\tthis._segList.addPt(mid0);\n\t\t\t\t\tvar mid1 = new Coordinate((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));\n\t\t\t\t\tthis._segList.addPt(mid1);\n\t\t\t\t} else {\n\t\t\t\t\tthis._segList.addPt(this._s1);\n\t\t\t\t}\n\t\t\t\tthis._segList.addPt(this._offset1.p0);\n\t\t\t}\n\t\t}\n\t},\n\tcreateCircle: function createCircle(p) {\n\t\tvar pt = new Coordinate(p.x + this._distance, p.y);\n\t\tthis._segList.addPt(pt);\n\t\tthis.addFilletArc(p, 0.0, 2.0 * Math.PI, -1, this._distance);\n\t\tthis._segList.closeRing();\n\t},\n\taddBevelJoin: function addBevelJoin(offset0, offset1) {\n\t\tthis._segList.addPt(offset0.p1);\n\t\tthis._segList.addPt(offset1.p0);\n\t},\n\tinit: function init(distance) {\n\t\tthis._distance = distance;\n\t\tthis._maxCurveSegmentError = distance * (1 - Math.cos(this._filletAngleQuantum / 2.0));\n\t\tthis._segList = new OffsetSegmentString();\n\t\tthis._segList.setPrecisionModel(this._precisionModel);\n\t\tthis._segList.setMinimumVertexDistance(distance * OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);\n\t},\n\taddCollinear: function addCollinear(addStartPoint) {\n\t\tthis._li.computeIntersection(this._s0, this._s1, this._s1, this._s2);\n\t\tvar numInt = this._li.getIntersectionNum();\n\t\tif (numInt >= 2) {\n\t\t\tif (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL || this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {\n\t\t\t\tif (addStartPoint) this._segList.addPt(this._offset0.p1);\n\t\t\t\tthis._segList.addPt(this._offset1.p0);\n\t\t\t} else {\n\t\t\t\tthis.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, CGAlgorithms.CLOCKWISE, this._distance);\n\t\t\t}\n\t\t}\n\t},\n\tcloseRing: function closeRing() {\n\t\tthis._segList.closeRing();\n\t},\n\thasNarrowConcaveAngle: function hasNarrowConcaveAngle() {\n\t\treturn this._hasNarrowConcaveAngle;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn OffsetSegmentGenerator;\n\t}\n});\nOffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR = 1.0E-3;\nOffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = 1.0E-3;\nOffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1.0E-6;\nOffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR = 80;\n\nfunction OffsetCurveBuilder() {\n\tthis._distance = 0.0;\n\tthis._precisionModel = null;\n\tthis._bufParams = null;\n\tvar precisionModel = arguments[0],\n\t    bufParams = arguments[1];\n\tthis._precisionModel = precisionModel;\n\tthis._bufParams = bufParams;\n}\nextend(OffsetCurveBuilder.prototype, {\n\tgetOffsetCurve: function getOffsetCurve(inputPts, distance) {\n\t\tthis._distance = distance;\n\t\tif (distance === 0.0) return null;\n\t\tvar isRightSide = distance < 0.0;\n\t\tvar posDistance = Math.abs(distance);\n\t\tvar segGen = this.getSegGen(posDistance);\n\t\tif (inputPts.length <= 1) {\n\t\t\tthis.computePointCurve(inputPts[0], segGen);\n\t\t} else {\n\t\t\tthis.computeOffsetCurve(inputPts, isRightSide, segGen);\n\t\t}\n\t\tvar curvePts = segGen.getCoordinates();\n\t\tif (isRightSide) CoordinateArrays.reverse(curvePts);\n\t\treturn curvePts;\n\t},\n\tcomputeSingleSidedBufferCurve: function computeSingleSidedBufferCurve(inputPts, isRightSide, segGen) {\n\t\tvar distTol = this.simplifyTolerance(this._distance);\n\t\tif (isRightSide) {\n\t\t\tsegGen.addSegments(inputPts, true);\n\t\t\tvar simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);\n\t\t\tvar n2 = simp2.length - 1;\n\t\t\tsegGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);\n\t\t\tsegGen.addFirstSegment();\n\t\t\tfor (var i = n2 - 2; i >= 0; i--) {\n\t\t\t\tsegGen.addNextSegment(simp2[i], true);\n\t\t\t}\n\t\t} else {\n\t\t\tsegGen.addSegments(inputPts, false);\n\t\t\tvar simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);\n\t\t\tvar n1 = simp1.length - 1;\n\t\t\tsegGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);\n\t\t\tsegGen.addFirstSegment();\n\t\t\tfor (var i = 2; i <= n1; i++) {\n\t\t\t\tsegGen.addNextSegment(simp1[i], true);\n\t\t\t}\n\t\t}\n\t\tsegGen.addLastSegment();\n\t\tsegGen.closeRing();\n\t},\n\tcomputeRingBufferCurve: function computeRingBufferCurve(inputPts, side, segGen) {\n\t\tvar distTol = this.simplifyTolerance(this._distance);\n\t\tif (side === Position.RIGHT) distTol = -distTol;\n\t\tvar simp = BufferInputLineSimplifier.simplify(inputPts, distTol);\n\t\tvar n = simp.length - 1;\n\t\tsegGen.initSideSegments(simp[n - 1], simp[0], side);\n\t\tfor (var i = 1; i <= n; i++) {\n\t\t\tvar addStartPoint = i !== 1;\n\t\t\tsegGen.addNextSegment(simp[i], addStartPoint);\n\t\t}\n\t\tsegGen.closeRing();\n\t},\n\tcomputeLineBufferCurve: function computeLineBufferCurve(inputPts, segGen) {\n\t\tvar distTol = this.simplifyTolerance(this._distance);\n\t\tvar simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);\n\t\tvar n1 = simp1.length - 1;\n\t\tsegGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);\n\t\tfor (var i = 2; i <= n1; i++) {\n\t\t\tsegGen.addNextSegment(simp1[i], true);\n\t\t}\n\t\tsegGen.addLastSegment();\n\t\tsegGen.addLineEndCap(simp1[n1 - 1], simp1[n1]);\n\t\tvar simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);\n\t\tvar n2 = simp2.length - 1;\n\t\tsegGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);\n\t\tfor (var i = n2 - 2; i >= 0; i--) {\n\t\t\tsegGen.addNextSegment(simp2[i], true);\n\t\t}\n\t\tsegGen.addLastSegment();\n\t\tsegGen.addLineEndCap(simp2[1], simp2[0]);\n\t\tsegGen.closeRing();\n\t},\n\tcomputePointCurve: function computePointCurve(pt, segGen) {\n\t\tswitch (this._bufParams.getEndCapStyle()) {\n\t\t\tcase BufferParameters.CAP_ROUND:\n\t\t\t\tsegGen.createCircle(pt);\n\t\t\t\tbreak;\n\t\t\tcase BufferParameters.CAP_SQUARE:\n\t\t\t\tsegGen.createSquare(pt);\n\t\t\t\tbreak;\n\t\t}\n\t},\n\tgetLineCurve: function getLineCurve(inputPts, distance) {\n\t\tthis._distance = distance;\n\t\tif (distance < 0.0 && !this._bufParams.isSingleSided()) return null;\n\t\tif (distance === 0.0) return null;\n\t\tvar posDistance = Math.abs(distance);\n\t\tvar segGen = this.getSegGen(posDistance);\n\t\tif (inputPts.length <= 1) {\n\t\t\tthis.computePointCurve(inputPts[0], segGen);\n\t\t} else {\n\t\t\tif (this._bufParams.isSingleSided()) {\n\t\t\t\tvar isRightSide = distance < 0.0;\n\t\t\t\tthis.computeSingleSidedBufferCurve(inputPts, isRightSide, segGen);\n\t\t\t} else this.computeLineBufferCurve(inputPts, segGen);\n\t\t}\n\t\tvar lineCoord = segGen.getCoordinates();\n\t\treturn lineCoord;\n\t},\n\tgetBufferParameters: function getBufferParameters() {\n\t\treturn this._bufParams;\n\t},\n\tsimplifyTolerance: function simplifyTolerance(bufDistance) {\n\t\treturn bufDistance * this._bufParams.getSimplifyFactor();\n\t},\n\tgetRingCurve: function getRingCurve(inputPts, side, distance) {\n\t\tthis._distance = distance;\n\t\tif (inputPts.length <= 2) return this.getLineCurve(inputPts, distance);\n\t\tif (distance === 0.0) {\n\t\t\treturn OffsetCurveBuilder.copyCoordinates(inputPts);\n\t\t}\n\t\tvar segGen = this.getSegGen(distance);\n\t\tthis.computeRingBufferCurve(inputPts, side, segGen);\n\t\treturn segGen.getCoordinates();\n\t},\n\tcomputeOffsetCurve: function computeOffsetCurve(inputPts, isRightSide, segGen) {\n\t\tvar distTol = this.simplifyTolerance(this._distance);\n\t\tif (isRightSide) {\n\t\t\tvar simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);\n\t\t\tvar n2 = simp2.length - 1;\n\t\t\tsegGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);\n\t\t\tsegGen.addFirstSegment();\n\t\t\tfor (var i = n2 - 2; i >= 0; i--) {\n\t\t\t\tsegGen.addNextSegment(simp2[i], true);\n\t\t\t}\n\t\t} else {\n\t\t\tvar simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);\n\t\t\tvar n1 = simp1.length - 1;\n\t\t\tsegGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);\n\t\t\tsegGen.addFirstSegment();\n\t\t\tfor (var i = 2; i <= n1; i++) {\n\t\t\t\tsegGen.addNextSegment(simp1[i], true);\n\t\t\t}\n\t\t}\n\t\tsegGen.addLastSegment();\n\t},\n\tgetSegGen: function getSegGen(distance) {\n\t\treturn new OffsetSegmentGenerator(this._precisionModel, this._bufParams, distance);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn OffsetCurveBuilder;\n\t}\n});\nOffsetCurveBuilder.copyCoordinates = function (pts) {\n\tvar copy = new Array(pts.length).fill(null);\n\tfor (var i = 0; i < copy.length; i++) {\n\t\tcopy[i] = new Coordinate(pts[i]);\n\t}\n\treturn copy;\n};\n\nfunction SubgraphDepthLocater() {\n\tthis._subgraphs = null;\n\tthis._seg = new LineSegment();\n\tthis._cga = new CGAlgorithms();\n\tvar subgraphs = arguments[0];\n\tthis._subgraphs = subgraphs;\n}\nextend(SubgraphDepthLocater.prototype, {\n\tfindStabbedSegments: function findStabbedSegments() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar stabbingRayLeftPt = arguments[0];\n\t\t\tvar stabbedSegments = new ArrayList();\n\t\t\tfor (var i = this._subgraphs.iterator(); i.hasNext();) {\n\t\t\t\tvar bsg = i.next();\n\t\t\t\tvar env = bsg.getEnvelope();\n\t\t\t\tif (stabbingRayLeftPt.y < env.getMinY() || stabbingRayLeftPt.y > env.getMaxY()) continue;\n\t\t\t\tthis.findStabbedSegments(stabbingRayLeftPt, bsg.getDirectedEdges(), stabbedSegments);\n\t\t\t}\n\t\t\treturn stabbedSegments;\n\t\t} else if (arguments.length === 3) {\n\t\t\tif (hasInterface(arguments[2], List) && arguments[0] instanceof Coordinate && arguments[1] instanceof DirectedEdge) {\n\t\t\t\tvar stabbingRayLeftPt = arguments[0],\n\t\t\t\t    dirEdge = arguments[1],\n\t\t\t\t    stabbedSegments = arguments[2];\n\t\t\t\tvar pts = dirEdge.getEdge().getCoordinates();\n\t\t\t\tfor (var i = 0; i < pts.length - 1; i++) {\n\t\t\t\t\tthis._seg.p0 = pts[i];\n\t\t\t\t\tthis._seg.p1 = pts[i + 1];\n\t\t\t\t\tif (this._seg.p0.y > this._seg.p1.y) this._seg.reverse();\n\t\t\t\t\tvar maxx = Math.max(this._seg.p0.x, this._seg.p1.x);\n\t\t\t\t\tif (maxx < stabbingRayLeftPt.x) continue;\n\t\t\t\t\tif (this._seg.isHorizontal()) continue;\n\t\t\t\t\tif (stabbingRayLeftPt.y < this._seg.p0.y || stabbingRayLeftPt.y > this._seg.p1.y) continue;\n\t\t\t\t\tif (CGAlgorithms.computeOrientation(this._seg.p0, this._seg.p1, stabbingRayLeftPt) === CGAlgorithms.RIGHT) continue;\n\t\t\t\t\tvar depth = dirEdge.getDepth(Position.LEFT);\n\t\t\t\t\tif (!this._seg.p0.equals(pts[i])) depth = dirEdge.getDepth(Position.RIGHT);\n\t\t\t\t\tvar ds = new DepthSegment(this._seg, depth);\n\t\t\t\t\tstabbedSegments.add(ds);\n\t\t\t\t}\n\t\t\t} else if (hasInterface(arguments[2], List) && arguments[0] instanceof Coordinate && hasInterface(arguments[1], List)) {\n\t\t\t\tvar stabbingRayLeftPt = arguments[0],\n\t\t\t\t    dirEdges = arguments[1],\n\t\t\t\t    stabbedSegments = arguments[2];\n\t\t\t\tfor (var i = dirEdges.iterator(); i.hasNext();) {\n\t\t\t\t\tvar de = i.next();\n\t\t\t\t\tif (!de.isForward()) continue;\n\t\t\t\t\tthis.findStabbedSegments(stabbingRayLeftPt, de, stabbedSegments);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tgetDepth: function getDepth(p) {\n\t\tvar stabbedSegments = this.findStabbedSegments(p);\n\t\tif (stabbedSegments.size() === 0) return 0;\n\t\tvar ds = Collections.min(stabbedSegments);\n\t\treturn ds._leftDepth;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn SubgraphDepthLocater;\n\t}\n});\nfunction DepthSegment() {\n\tthis._upwardSeg = null;\n\tthis._leftDepth = null;\n\tvar seg = arguments[0],\n\t    depth = arguments[1];\n\tthis._upwardSeg = new LineSegment(seg);\n\tthis._leftDepth = depth;\n}\nextend(DepthSegment.prototype, {\n\tcompareTo: function compareTo(obj) {\n\t\tvar other = obj;\n\t\tif (this._upwardSeg.minX() >= other._upwardSeg.maxX()) return 1;\n\t\tif (this._upwardSeg.maxX() <= other._upwardSeg.minX()) return -1;\n\t\tvar orientIndex = this._upwardSeg.orientationIndex(other._upwardSeg);\n\t\tif (orientIndex !== 0) return orientIndex;\n\t\torientIndex = -1 * other._upwardSeg.orientationIndex(this._upwardSeg);\n\t\tif (orientIndex !== 0) return orientIndex;\n\t\treturn this._upwardSeg.compareTo(other._upwardSeg);\n\t},\n\tcompareX: function compareX(seg0, seg1) {\n\t\tvar compare0 = seg0.p0.compareTo(seg1.p0);\n\t\tif (compare0 !== 0) return compare0;\n\t\treturn seg0.p1.compareTo(seg1.p1);\n\t},\n\ttoString: function toString() {\n\t\treturn this._upwardSeg.toString();\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Comparable];\n\t},\n\tgetClass: function getClass() {\n\t\treturn DepthSegment;\n\t}\n});\nSubgraphDepthLocater.DepthSegment = DepthSegment;\n\nfunction OffsetCurveSetBuilder() {\n\tthis._inputGeom = null;\n\tthis._distance = null;\n\tthis._curveBuilder = null;\n\tthis._curveList = new ArrayList();\n\tvar inputGeom = arguments[0],\n\t    distance = arguments[1],\n\t    curveBuilder = arguments[2];\n\tthis._inputGeom = inputGeom;\n\tthis._distance = distance;\n\tthis._curveBuilder = curveBuilder;\n}\nextend(OffsetCurveSetBuilder.prototype, {\n\taddPoint: function addPoint(p) {\n\t\tif (this._distance <= 0.0) return null;\n\t\tvar coord = p.getCoordinates();\n\t\tvar curve = this._curveBuilder.getLineCurve(coord, this._distance);\n\t\tthis.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);\n\t},\n\taddPolygon: function addPolygon(p) {\n\t\tvar offsetDistance = this._distance;\n\t\tvar offsetSide = Position.LEFT;\n\t\tif (this._distance < 0.0) {\n\t\t\toffsetDistance = -this._distance;\n\t\t\toffsetSide = Position.RIGHT;\n\t\t}\n\t\tvar shell = p.getExteriorRing();\n\t\tvar shellCoord = CoordinateArrays.removeRepeatedPoints(shell.getCoordinates());\n\t\tif (this._distance < 0.0 && this.isErodedCompletely(shell, this._distance)) return null;\n\t\tif (this._distance <= 0.0 && shellCoord.length < 3) return null;\n\t\tthis.addPolygonRing(shellCoord, offsetDistance, offsetSide, Location.EXTERIOR, Location.INTERIOR);\n\t\tfor (var i = 0; i < p.getNumInteriorRing(); i++) {\n\t\t\tvar hole = p.getInteriorRingN(i);\n\t\t\tvar holeCoord = CoordinateArrays.removeRepeatedPoints(hole.getCoordinates());\n\t\t\tif (this._distance > 0.0 && this.isErodedCompletely(hole, -this._distance)) continue;\n\t\t\tthis.addPolygonRing(holeCoord, offsetDistance, Position.opposite(offsetSide), Location.INTERIOR, Location.EXTERIOR);\n\t\t}\n\t},\n\tisTriangleErodedCompletely: function isTriangleErodedCompletely(triangleCoord, bufferDistance) {\n\t\tvar tri = new Triangle$1(triangleCoord[0], triangleCoord[1], triangleCoord[2]);\n\t\tvar inCentre = tri.inCentre();\n\t\tvar distToCentre = CGAlgorithms.distancePointLine(inCentre, tri.p0, tri.p1);\n\t\treturn distToCentre < Math.abs(bufferDistance);\n\t},\n\taddLineString: function addLineString(line) {\n\t\tif (this._distance <= 0.0 && !this._curveBuilder.getBufferParameters().isSingleSided()) return null;\n\t\tvar coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());\n\t\tvar curve = this._curveBuilder.getLineCurve(coord, this._distance);\n\t\tthis.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);\n\t},\n\taddCurve: function addCurve(coord, leftLoc, rightLoc) {\n\t\tif (coord === null || coord.length < 2) return null;\n\t\tvar e = new NodedSegmentString(coord, new Label(0, Location.BOUNDARY, leftLoc, rightLoc));\n\t\tthis._curveList.add(e);\n\t},\n\tgetCurves: function getCurves() {\n\t\tthis.add(this._inputGeom);\n\t\treturn this._curveList;\n\t},\n\taddPolygonRing: function addPolygonRing(coord, offsetDistance, side, cwLeftLoc, cwRightLoc) {\n\t\tif (offsetDistance === 0.0 && coord.length < LinearRing.MINIMUM_VALID_SIZE) return null;\n\t\tvar leftLoc = cwLeftLoc;\n\t\tvar rightLoc = cwRightLoc;\n\t\tif (coord.length >= LinearRing.MINIMUM_VALID_SIZE && CGAlgorithms.isCCW(coord)) {\n\t\t\tleftLoc = cwRightLoc;\n\t\t\trightLoc = cwLeftLoc;\n\t\t\tside = Position.opposite(side);\n\t\t}\n\t\tvar curve = this._curveBuilder.getRingCurve(coord, side, offsetDistance);\n\t\tthis.addCurve(curve, leftLoc, rightLoc);\n\t},\n\tadd: function add(g) {\n\t\tif (g.isEmpty()) return null;\n\t\tif (g instanceof Polygon) this.addPolygon(g);else if (g instanceof LineString) this.addLineString(g);else if (g instanceof Point) this.addPoint(g);else if (g instanceof MultiPoint) this.addCollection(g);else if (g instanceof MultiLineString) this.addCollection(g);else if (g instanceof MultiPolygon) this.addCollection(g);else if (g instanceof GeometryCollection) this.addCollection(g);else throw new UnsupportedOperationException(g.getClass().getName());\n\t},\n\tisErodedCompletely: function isErodedCompletely(ring, bufferDistance) {\n\t\tvar ringCoord = ring.getCoordinates();\n\t\tif (ringCoord.length < 4) return bufferDistance < 0;\n\t\tif (ringCoord.length === 4) return this.isTriangleErodedCompletely(ringCoord, bufferDistance);\n\t\tvar env = ring.getEnvelopeInternal();\n\t\tvar envMinDimension = Math.min(env.getHeight(), env.getWidth());\n\t\tif (bufferDistance < 0.0 && 2 * Math.abs(bufferDistance) > envMinDimension) return true;\n\t\treturn false;\n\t},\n\taddCollection: function addCollection(gc) {\n\t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n\t\t\tvar g = gc.getGeometryN(i);\n\t\t\tthis.add(g);\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn OffsetCurveSetBuilder;\n\t}\n});\n\nfunction IntersectionAdder() {\n\tthis._hasIntersection = false;\n\tthis._hasProper = false;\n\tthis._hasProperInterior = false;\n\tthis._hasInterior = false;\n\tthis._properIntersectionPoint = null;\n\tthis._li = null;\n\tthis._isSelfIntersection = null;\n\tthis.numIntersections = 0;\n\tthis.numInteriorIntersections = 0;\n\tthis.numProperIntersections = 0;\n\tthis.numTests = 0;\n\tvar li = arguments[0];\n\tthis._li = li;\n}\nextend(IntersectionAdder.prototype, {\n\tisTrivialIntersection: function isTrivialIntersection(e0, segIndex0, e1, segIndex1) {\n\t\tif (e0 === e1) {\n\t\t\tif (this._li.getIntersectionNum() === 1) {\n\t\t\t\tif (IntersectionAdder.isAdjacentSegments(segIndex0, segIndex1)) return true;\n\t\t\t\tif (e0.isClosed()) {\n\t\t\t\t\tvar maxSegIndex = e0.size() - 1;\n\t\t\t\t\tif (segIndex0 === 0 && segIndex1 === maxSegIndex || segIndex1 === 0 && segIndex0 === maxSegIndex) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tgetProperIntersectionPoint: function getProperIntersectionPoint() {\n\t\treturn this._properIntersectionPoint;\n\t},\n\thasProperInteriorIntersection: function hasProperInteriorIntersection() {\n\t\treturn this._hasProperInterior;\n\t},\n\tgetLineIntersector: function getLineIntersector() {\n\t\treturn this._li;\n\t},\n\thasProperIntersection: function hasProperIntersection() {\n\t\treturn this._hasProper;\n\t},\n\tprocessIntersections: function processIntersections(e0, segIndex0, e1, segIndex1) {\n\t\tif (e0 === e1 && segIndex0 === segIndex1) return null;\n\t\tthis.numTests++;\n\t\tvar p00 = e0.getCoordinates()[segIndex0];\n\t\tvar p01 = e0.getCoordinates()[segIndex0 + 1];\n\t\tvar p10 = e1.getCoordinates()[segIndex1];\n\t\tvar p11 = e1.getCoordinates()[segIndex1 + 1];\n\t\tthis._li.computeIntersection(p00, p01, p10, p11);\n\t\tif (this._li.hasIntersection()) {\n\t\t\tthis.numIntersections++;\n\t\t\tif (this._li.isInteriorIntersection()) {\n\t\t\t\tthis.numInteriorIntersections++;\n\t\t\t\tthis._hasInterior = true;\n\t\t\t}\n\t\t\tif (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {\n\t\t\t\tthis._hasIntersection = true;\n\t\t\t\te0.addIntersections(this._li, segIndex0, 0);\n\t\t\t\te1.addIntersections(this._li, segIndex1, 1);\n\t\t\t\tif (this._li.isProper()) {\n\t\t\t\t\tthis.numProperIntersections++;\n\t\t\t\t\tthis._hasProper = true;\n\t\t\t\t\tthis._hasProperInterior = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\thasIntersection: function hasIntersection() {\n\t\treturn this._hasIntersection;\n\t},\n\tisDone: function isDone() {\n\t\treturn false;\n\t},\n\thasInteriorIntersection: function hasInteriorIntersection() {\n\t\treturn this._hasInterior;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [SegmentIntersector];\n\t},\n\tgetClass: function getClass() {\n\t\treturn IntersectionAdder;\n\t}\n});\nIntersectionAdder.isAdjacentSegments = function (i1, i2) {\n\treturn Math.abs(i1 - i2) === 1;\n};\n\nfunction BufferBuilder() {\n\tthis._bufParams = null;\n\tthis._workingPrecisionModel = null;\n\tthis._workingNoder = null;\n\tthis._geomFact = null;\n\tthis._graph = null;\n\tthis._edgeList = new EdgeList();\n\tvar bufParams = arguments[0];\n\tthis._bufParams = bufParams;\n}\nextend(BufferBuilder.prototype, {\n\tsetWorkingPrecisionModel: function setWorkingPrecisionModel(pm) {\n\t\tthis._workingPrecisionModel = pm;\n\t},\n\tinsertUniqueEdge: function insertUniqueEdge(e) {\n\t\tvar existingEdge = this._edgeList.findEqualEdge(e);\n\t\tif (existingEdge !== null) {\n\t\t\tvar existingLabel = existingEdge.getLabel();\n\t\t\tvar labelToMerge = e.getLabel();\n\t\t\tif (!existingEdge.isPointwiseEqual(e)) {\n\t\t\t\tlabelToMerge = new Label(e.getLabel());\n\t\t\t\tlabelToMerge.flip();\n\t\t\t}\n\t\t\texistingLabel.merge(labelToMerge);\n\t\t\tvar mergeDelta = BufferBuilder.depthDelta(labelToMerge);\n\t\t\tvar existingDelta = existingEdge.getDepthDelta();\n\t\t\tvar newDelta = existingDelta + mergeDelta;\n\t\t\texistingEdge.setDepthDelta(newDelta);\n\t\t} else {\n\t\t\tthis._edgeList.add(e);\n\t\t\te.setDepthDelta(BufferBuilder.depthDelta(e.getLabel()));\n\t\t}\n\t},\n\tbuildSubgraphs: function buildSubgraphs(subgraphList, polyBuilder) {\n\t\tvar processedGraphs = new ArrayList();\n\t\tfor (var i = subgraphList.iterator(); i.hasNext();) {\n\t\t\tvar subgraph = i.next();\n\t\t\tvar p = subgraph.getRightmostCoordinate();\n\t\t\tvar locater = new SubgraphDepthLocater(processedGraphs);\n\t\t\tvar outsideDepth = locater.getDepth(p);\n\t\t\tsubgraph.computeDepth(outsideDepth);\n\t\t\tsubgraph.findResultEdges();\n\t\t\tprocessedGraphs.add(subgraph);\n\t\t\tpolyBuilder.add(subgraph.getDirectedEdges(), subgraph.getNodes());\n\t\t}\n\t},\n\tcreateSubgraphs: function createSubgraphs(graph) {\n\t\tvar subgraphList = new ArrayList();\n\t\tfor (var i = graph.getNodes().iterator(); i.hasNext();) {\n\t\t\tvar node = i.next();\n\t\t\tif (!node.isVisited()) {\n\t\t\t\tvar subgraph = new BufferSubgraph();\n\t\t\t\tsubgraph.create(node);\n\t\t\t\tsubgraphList.add(subgraph);\n\t\t\t}\n\t\t}\n\t\tCollections.sort(subgraphList, Collections.reverseOrder());\n\t\treturn subgraphList;\n\t},\n\tcreateEmptyResultGeometry: function createEmptyResultGeometry() {\n\t\tvar emptyGeom = this._geomFact.createPolygon();\n\t\treturn emptyGeom;\n\t},\n\tgetNoder: function getNoder(precisionModel) {\n\t\tif (this._workingNoder !== null) return this._workingNoder;\n\t\tvar noder = new MCIndexNoder();\n\t\tvar li = new RobustLineIntersector();\n\t\tli.setPrecisionModel(precisionModel);\n\t\tnoder.setSegmentIntersector(new IntersectionAdder(li));\n\t\treturn noder;\n\t},\n\tbuffer: function buffer(g, distance) {\n\t\tvar precisionModel = this._workingPrecisionModel;\n\t\tif (precisionModel === null) precisionModel = g.getPrecisionModel();\n\t\tthis._geomFact = g.getFactory();\n\t\tvar curveBuilder = new OffsetCurveBuilder(precisionModel, this._bufParams);\n\t\tvar curveSetBuilder = new OffsetCurveSetBuilder(g, distance, curveBuilder);\n\t\tvar bufferSegStrList = curveSetBuilder.getCurves();\n\t\tif (bufferSegStrList.size() <= 0) {\n\t\t\treturn this.createEmptyResultGeometry();\n\t\t}\n\t\tthis.computeNodedEdges(bufferSegStrList, precisionModel);\n\t\tthis._graph = new PlanarGraph(new OverlayNodeFactory());\n\t\tthis._graph.addEdges(this._edgeList.getEdges());\n\t\tvar subgraphList = this.createSubgraphs(this._graph);\n\t\tvar polyBuilder = new PolygonBuilder(this._geomFact);\n\t\tthis.buildSubgraphs(subgraphList, polyBuilder);\n\t\tvar resultPolyList = polyBuilder.getPolygons();\n\t\tif (resultPolyList.size() <= 0) {\n\t\t\treturn this.createEmptyResultGeometry();\n\t\t}\n\t\tvar resultGeom = this._geomFact.buildGeometry(resultPolyList);\n\t\treturn resultGeom;\n\t},\n\tcomputeNodedEdges: function computeNodedEdges(bufferSegStrList, precisionModel) {\n\t\tvar noder = this.getNoder(precisionModel);\n\t\tnoder.computeNodes(bufferSegStrList);\n\t\tvar nodedSegStrings = noder.getNodedSubstrings();\n\t\tfor (var i = nodedSegStrings.iterator(); i.hasNext();) {\n\t\t\tvar segStr = i.next();\n\t\t\tvar pts = segStr.getCoordinates();\n\t\t\tif (pts.length === 2 && pts[0].equals2D(pts[1])) continue;\n\t\t\tvar oldLabel = segStr.getData();\n\t\t\tvar edge = new Edge(segStr.getCoordinates(), new Label(oldLabel));\n\t\t\tthis.insertUniqueEdge(edge);\n\t\t}\n\t},\n\tsetNoder: function setNoder(noder) {\n\t\tthis._workingNoder = noder;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn BufferBuilder;\n\t}\n});\nBufferBuilder.depthDelta = function (label) {\n\tvar lLoc = label.getLocation(0, Position.LEFT);\n\tvar rLoc = label.getLocation(0, Position.RIGHT);\n\tif (lLoc === Location.INTERIOR && rLoc === Location.EXTERIOR) return 1;else if (lLoc === Location.EXTERIOR && rLoc === Location.INTERIOR) return -1;\n\treturn 0;\n};\nBufferBuilder.convertSegStrings = function (it) {\n\tvar fact = new GeometryFactory();\n\tvar lines = new ArrayList();\n\twhile (it.hasNext()) {\n\t\tvar ss = it.next();\n\t\tvar line = fact.createLineString(ss.getCoordinates());\n\t\tlines.add(line);\n\t}\n\treturn fact.buildGeometry(lines);\n};\n\nfunction NodingValidator() {\n\tthis._li = new RobustLineIntersector();\n\tthis._segStrings = null;\n\tvar segStrings = arguments[0];\n\tthis._segStrings = segStrings;\n}\nextend(NodingValidator.prototype, {\n\tcheckEndPtVertexIntersections: function checkEndPtVertexIntersections() {\n\t\tif (arguments.length === 0) {\n\t\t\tfor (var i = this._segStrings.iterator(); i.hasNext();) {\n\t\t\t\tvar ss = i.next();\n\t\t\t\tvar pts = ss.getCoordinates();\n\t\t\t\tthis.checkEndPtVertexIntersections(pts[0], this._segStrings);\n\t\t\t\tthis.checkEndPtVertexIntersections(pts[pts.length - 1], this._segStrings);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar testPt = arguments[0],\n\t\t\t    segStrings = arguments[1];\n\t\t\tfor (var i = segStrings.iterator(); i.hasNext();) {\n\t\t\t\tvar ss = i.next();\n\t\t\t\tvar pts = ss.getCoordinates();\n\t\t\t\tfor (var j = 1; j < pts.length - 1; j++) {\n\t\t\t\t\tif (pts[j].equals(testPt)) throw new RuntimeException(\"found endpt/interior pt intersection at index \" + j + \" :pt \" + testPt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tcheckInteriorIntersections: function checkInteriorIntersections() {\n\t\tif (arguments.length === 0) {\n\t\t\tfor (var i = this._segStrings.iterator(); i.hasNext();) {\n\t\t\t\tvar ss0 = i.next();\n\t\t\t\tfor (var j = this._segStrings.iterator(); j.hasNext();) {\n\t\t\t\t\tvar ss1 = j.next();\n\t\t\t\t\tthis.checkInteriorIntersections(ss0, ss1);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar ss0 = arguments[0],\n\t\t\t    ss1 = arguments[1];\n\t\t\tvar pts0 = ss0.getCoordinates();\n\t\t\tvar pts1 = ss1.getCoordinates();\n\t\t\tfor (var i0 = 0; i0 < pts0.length - 1; i0++) {\n\t\t\t\tfor (var i1 = 0; i1 < pts1.length - 1; i1++) {\n\t\t\t\t\tthis.checkInteriorIntersections(ss0, i0, ss1, i1);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arguments.length === 4) {\n\t\t\tvar e0 = arguments[0],\n\t\t\t    segIndex0 = arguments[1],\n\t\t\t    e1 = arguments[2],\n\t\t\t    segIndex1 = arguments[3];\n\t\t\tif (e0 === e1 && segIndex0 === segIndex1) return null;\n\t\t\tvar p00 = e0.getCoordinates()[segIndex0];\n\t\t\tvar p01 = e0.getCoordinates()[segIndex0 + 1];\n\t\t\tvar p10 = e1.getCoordinates()[segIndex1];\n\t\t\tvar p11 = e1.getCoordinates()[segIndex1 + 1];\n\t\t\tthis._li.computeIntersection(p00, p01, p10, p11);\n\t\t\tif (this._li.hasIntersection()) {\n\t\t\t\tif (this._li.isProper() || this.hasInteriorIntersection(this._li, p00, p01) || this.hasInteriorIntersection(this._li, p10, p11)) {\n\t\t\t\t\tthrow new RuntimeException(\"found non-noded intersection at \" + p00 + \"-\" + p01 + \" and \" + p10 + \"-\" + p11);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tcheckValid: function checkValid() {\n\t\tthis.checkEndPtVertexIntersections();\n\t\tthis.checkInteriorIntersections();\n\t\tthis.checkCollapses();\n\t},\n\tcheckCollapses: function checkCollapses() {\n\t\tif (arguments.length === 0) {\n\t\t\tfor (var i = this._segStrings.iterator(); i.hasNext();) {\n\t\t\t\tvar ss = i.next();\n\t\t\t\tthis.checkCollapses(ss);\n\t\t\t}\n\t\t} else if (arguments.length === 1) {\n\t\t\tvar ss = arguments[0];\n\t\t\tvar pts = ss.getCoordinates();\n\t\t\tfor (var i = 0; i < pts.length - 2; i++) {\n\t\t\t\tthis.checkCollapse(pts[i], pts[i + 1], pts[i + 2]);\n\t\t\t}\n\t\t}\n\t},\n\thasInteriorIntersection: function hasInteriorIntersection(li, p0, p1) {\n\t\tfor (var i = 0; i < li.getIntersectionNum(); i++) {\n\t\t\tvar intPt = li.getIntersection(i);\n\t\t\tif (!(intPt.equals(p0) || intPt.equals(p1))) return true;\n\t\t}\n\t\treturn false;\n\t},\n\tcheckCollapse: function checkCollapse(p0, p1, p2) {\n\t\tif (p0.equals(p2)) throw new RuntimeException(\"found non-noded collapse at \" + NodingValidator.fact.createLineString([p0, p1, p2]));\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn NodingValidator;\n\t}\n});\nNodingValidator.fact = new GeometryFactory();\n\nfunction HotPixel() {\n\tthis._li = null;\n\tthis._pt = null;\n\tthis._originalPt = null;\n\tthis._ptScaled = null;\n\tthis._p0Scaled = null;\n\tthis._p1Scaled = null;\n\tthis._scaleFactor = null;\n\tthis._minx = null;\n\tthis._maxx = null;\n\tthis._miny = null;\n\tthis._maxy = null;\n\tthis._corner = new Array(4).fill(null);\n\tthis._safeEnv = null;\n\tvar pt = arguments[0],\n\t    scaleFactor = arguments[1],\n\t    li = arguments[2];\n\tthis._originalPt = pt;\n\tthis._pt = pt;\n\tthis._scaleFactor = scaleFactor;\n\tthis._li = li;\n\tif (scaleFactor <= 0) throw new IllegalArgumentException(\"Scale factor must be non-zero\");\n\tif (scaleFactor !== 1.0) {\n\t\tthis._pt = new Coordinate(this.scale(pt.x), this.scale(pt.y));\n\t\tthis._p0Scaled = new Coordinate();\n\t\tthis._p1Scaled = new Coordinate();\n\t}\n\tthis.initCorners(this._pt);\n}\nextend(HotPixel.prototype, {\n\tintersectsScaled: function intersectsScaled(p0, p1) {\n\t\tvar segMinx = Math.min(p0.x, p1.x);\n\t\tvar segMaxx = Math.max(p0.x, p1.x);\n\t\tvar segMiny = Math.min(p0.y, p1.y);\n\t\tvar segMaxy = Math.max(p0.y, p1.y);\n\t\tvar isOutsidePixelEnv = this._maxx < segMinx || this._minx > segMaxx || this._maxy < segMiny || this._miny > segMaxy;\n\t\tif (isOutsidePixelEnv) return false;\n\t\tvar intersects = this.intersectsToleranceSquare(p0, p1);\n\t\tAssert.isTrue(!(isOutsidePixelEnv && intersects), \"Found bad envelope test\");\n\t\treturn intersects;\n\t},\n\tinitCorners: function initCorners(pt) {\n\t\tvar tolerance = 0.5;\n\t\tthis._minx = pt.x - tolerance;\n\t\tthis._maxx = pt.x + tolerance;\n\t\tthis._miny = pt.y - tolerance;\n\t\tthis._maxy = pt.y + tolerance;\n\t\tthis._corner[0] = new Coordinate(this._maxx, this._maxy);\n\t\tthis._corner[1] = new Coordinate(this._minx, this._maxy);\n\t\tthis._corner[2] = new Coordinate(this._minx, this._miny);\n\t\tthis._corner[3] = new Coordinate(this._maxx, this._miny);\n\t},\n\tintersects: function intersects(p0, p1) {\n\t\tif (this._scaleFactor === 1.0) return this.intersectsScaled(p0, p1);\n\t\tthis.copyScaled(p0, this._p0Scaled);\n\t\tthis.copyScaled(p1, this._p1Scaled);\n\t\treturn this.intersectsScaled(this._p0Scaled, this._p1Scaled);\n\t},\n\tscale: function scale(val) {\n\t\treturn Math.round(val * this._scaleFactor);\n\t},\n\tgetCoordinate: function getCoordinate() {\n\t\treturn this._originalPt;\n\t},\n\tcopyScaled: function copyScaled(p, pScaled) {\n\t\tpScaled.x = this.scale(p.x);\n\t\tpScaled.y = this.scale(p.y);\n\t},\n\tgetSafeEnvelope: function getSafeEnvelope() {\n\t\tif (this._safeEnv === null) {\n\t\t\tvar safeTolerance = HotPixel.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;\n\t\t\tthis._safeEnv = new Envelope(this._originalPt.x - safeTolerance, this._originalPt.x + safeTolerance, this._originalPt.y - safeTolerance, this._originalPt.y + safeTolerance);\n\t\t}\n\t\treturn this._safeEnv;\n\t},\n\tintersectsPixelClosure: function intersectsPixelClosure(p0, p1) {\n\t\tthis._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);\n\t\tif (this._li.hasIntersection()) return true;\n\t\tthis._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);\n\t\tif (this._li.hasIntersection()) return true;\n\t\tthis._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);\n\t\tif (this._li.hasIntersection()) return true;\n\t\tthis._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);\n\t\tif (this._li.hasIntersection()) return true;\n\t\treturn false;\n\t},\n\tintersectsToleranceSquare: function intersectsToleranceSquare(p0, p1) {\n\t\tvar intersectsLeft = false;\n\t\tvar intersectsBottom = false;\n\t\tthis._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);\n\t\tif (this._li.isProper()) return true;\n\t\tthis._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);\n\t\tif (this._li.isProper()) return true;\n\t\tif (this._li.hasIntersection()) intersectsLeft = true;\n\t\tthis._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);\n\t\tif (this._li.isProper()) return true;\n\t\tif (this._li.hasIntersection()) intersectsBottom = true;\n\t\tthis._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);\n\t\tif (this._li.isProper()) return true;\n\t\tif (intersectsLeft && intersectsBottom) return true;\n\t\tif (p0.equals(this._pt)) return true;\n\t\tif (p1.equals(this._pt)) return true;\n\t\treturn false;\n\t},\n\taddSnappedNode: function addSnappedNode(segStr, segIndex) {\n\t\tvar p0 = segStr.getCoordinate(segIndex);\n\t\tvar p1 = segStr.getCoordinate(segIndex + 1);\n\t\tif (this.intersects(p0, p1)) {\n\t\t\tsegStr.addIntersection(this.getCoordinate(), segIndex);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn HotPixel;\n\t}\n});\nHotPixel.SAFE_ENV_EXPANSION_FACTOR = 0.75;\n\nfunction MCIndexPointSnapper() {\n\tthis._index = null;\n\tvar index = arguments[0];\n\tthis._index = index;\n}\nextend(MCIndexPointSnapper.prototype, {\n\tsnap: function snap() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar hotPixel = arguments[0];\n\t\t\treturn this.snap(hotPixel, null, -1);\n\t\t} else if (arguments.length === 3) {\n\t\t\tvar hotPixel = arguments[0],\n\t\t\t    parentEdge = arguments[1],\n\t\t\t    hotPixelVertexIndex = arguments[2];\n\t\t\tvar pixelEnv = hotPixel.getSafeEnvelope();\n\t\t\tvar hotPixelSnapAction = new HotPixelSnapAction(hotPixel, parentEdge, hotPixelVertexIndex);\n\t\t\tthis._index.query(pixelEnv, {\n\t\t\t\tinterfaces_: function interfaces_() {\n\t\t\t\t\treturn [ItemVisitor];\n\t\t\t\t},\n\t\t\t\tvisitItem: function visitItem(item) {\n\t\t\t\t\tvar testChain = item;\n\t\t\t\t\ttestChain.select(pixelEnv, hotPixelSnapAction);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn hotPixelSnapAction.isNodeAdded();\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn MCIndexPointSnapper;\n\t}\n});\nfunction HotPixelSnapAction() {\n\tMonotoneChainSelectAction.apply(this);\n\tthis._hotPixel = null;\n\tthis._parentEdge = null;\n\tthis._hotPixelVertexIndex = null;\n\tthis._isNodeAdded = false;\n\tvar hotPixel = arguments[0],\n\t    parentEdge = arguments[1],\n\t    hotPixelVertexIndex = arguments[2];\n\tthis._hotPixel = hotPixel;\n\tthis._parentEdge = parentEdge;\n\tthis._hotPixelVertexIndex = hotPixelVertexIndex;\n}\ninherits$1(HotPixelSnapAction, MonotoneChainSelectAction);\nextend(HotPixelSnapAction.prototype, {\n\tisNodeAdded: function isNodeAdded() {\n\t\treturn this._isNodeAdded;\n\t},\n\tselect: function select() {\n\t\tif (arguments.length === 2) {\n\t\t\tvar mc = arguments[0],\n\t\t\t    startIndex = arguments[1];\n\t\t\tvar ss = mc.getContext();\n\t\t\tif (this._parentEdge !== null) {\n\t\t\t\tif (ss === this._parentEdge && startIndex === this._hotPixelVertexIndex) return null;\n\t\t\t}\n\t\t\tthis._isNodeAdded = this._hotPixel.addSnappedNode(ss, startIndex);\n\t\t} else return MonotoneChainSelectAction.prototype.select.apply(this, arguments);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn HotPixelSnapAction;\n\t}\n});\nMCIndexPointSnapper.HotPixelSnapAction = HotPixelSnapAction;\n\nfunction InteriorIntersectionFinderAdder() {\n\tthis._li = null;\n\tthis._interiorIntersections = null;\n\tvar li = arguments[0];\n\tthis._li = li;\n\tthis._interiorIntersections = new ArrayList();\n}\nextend(InteriorIntersectionFinderAdder.prototype, {\n\tprocessIntersections: function processIntersections(e0, segIndex0, e1, segIndex1) {\n\t\tif (e0 === e1 && segIndex0 === segIndex1) return null;\n\t\tvar p00 = e0.getCoordinates()[segIndex0];\n\t\tvar p01 = e0.getCoordinates()[segIndex0 + 1];\n\t\tvar p10 = e1.getCoordinates()[segIndex1];\n\t\tvar p11 = e1.getCoordinates()[segIndex1 + 1];\n\t\tthis._li.computeIntersection(p00, p01, p10, p11);\n\t\tif (this._li.hasIntersection()) {\n\t\t\tif (this._li.isInteriorIntersection()) {\n\t\t\t\tfor (var intIndex = 0; intIndex < this._li.getIntersectionNum(); intIndex++) {\n\t\t\t\t\tthis._interiorIntersections.add(this._li.getIntersection(intIndex));\n\t\t\t\t}\n\t\t\t\te0.addIntersections(this._li, segIndex0, 0);\n\t\t\t\te1.addIntersections(this._li, segIndex1, 1);\n\t\t\t}\n\t\t}\n\t},\n\tisDone: function isDone() {\n\t\treturn false;\n\t},\n\tgetInteriorIntersections: function getInteriorIntersections() {\n\t\treturn this._interiorIntersections;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [SegmentIntersector];\n\t},\n\tgetClass: function getClass() {\n\t\treturn InteriorIntersectionFinderAdder;\n\t}\n});\n\nfunction MCIndexSnapRounder() {\n\tthis._pm = null;\n\tthis._li = null;\n\tthis._scaleFactor = null;\n\tthis._noder = null;\n\tthis._pointSnapper = null;\n\tthis._nodedSegStrings = null;\n\tvar pm = arguments[0];\n\tthis._pm = pm;\n\tthis._li = new RobustLineIntersector();\n\tthis._li.setPrecisionModel(pm);\n\tthis._scaleFactor = pm.getScale();\n}\nextend(MCIndexSnapRounder.prototype, {\n\tcheckCorrectness: function checkCorrectness(inputSegmentStrings) {\n\t\tvar resultSegStrings = NodedSegmentString.getNodedSubstrings(inputSegmentStrings);\n\t\tvar nv = new NodingValidator(resultSegStrings);\n\t\ttry {\n\t\t\tnv.checkValid();\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof Exception) {\n\t\t\t\tex.printStackTrace();\n\t\t\t} else throw ex;\n\t\t} finally {}\n\t},\n\tgetNodedSubstrings: function getNodedSubstrings() {\n\t\treturn NodedSegmentString.getNodedSubstrings(this._nodedSegStrings);\n\t},\n\tsnapRound: function snapRound(segStrings, li) {\n\t\tvar intersections = this.findInteriorIntersections(segStrings, li);\n\t\tthis.computeIntersectionSnaps(intersections);\n\t\tthis.computeVertexSnaps(segStrings);\n\t},\n\tfindInteriorIntersections: function findInteriorIntersections(segStrings, li) {\n\t\tvar intFinderAdder = new InteriorIntersectionFinderAdder(li);\n\t\tthis._noder.setSegmentIntersector(intFinderAdder);\n\t\tthis._noder.computeNodes(segStrings);\n\t\treturn intFinderAdder.getInteriorIntersections();\n\t},\n\tcomputeVertexSnaps: function computeVertexSnaps() {\n\t\tif (hasInterface(arguments[0], Collection)) {\n\t\t\tvar edges = arguments[0];\n\t\t\tfor (var i0 = edges.iterator(); i0.hasNext();) {\n\t\t\t\tvar edge0 = i0.next();\n\t\t\t\tthis.computeVertexSnaps(edge0);\n\t\t\t}\n\t\t} else if (arguments[0] instanceof NodedSegmentString) {\n\t\t\tvar e = arguments[0];\n\t\t\tvar pts0 = e.getCoordinates();\n\t\t\tfor (var i = 0; i < pts0.length; i++) {\n\t\t\t\tvar hotPixel = new HotPixel(pts0[i], this._scaleFactor, this._li);\n\t\t\t\tvar isNodeAdded = this._pointSnapper.snap(hotPixel, e, i);\n\t\t\t\tif (isNodeAdded) {\n\t\t\t\t\te.addIntersection(pts0[i], i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tcomputeNodes: function computeNodes(inputSegmentStrings) {\n\t\tthis._nodedSegStrings = inputSegmentStrings;\n\t\tthis._noder = new MCIndexNoder();\n\t\tthis._pointSnapper = new MCIndexPointSnapper(this._noder.getIndex());\n\t\tthis.snapRound(inputSegmentStrings, this._li);\n\t},\n\tcomputeIntersectionSnaps: function computeIntersectionSnaps(snapPts) {\n\t\tfor (var it = snapPts.iterator(); it.hasNext();) {\n\t\t\tvar snapPt = it.next();\n\t\t\tvar hotPixel = new HotPixel(snapPt, this._scaleFactor, this._li);\n\t\t\tthis._pointSnapper.snap(hotPixel);\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Noder];\n\t},\n\tgetClass: function getClass() {\n\t\treturn MCIndexSnapRounder;\n\t}\n});\n\nfunction BufferOp() {\n\tthis._argGeom = null;\n\tthis._distance = null;\n\tthis._bufParams = new BufferParameters();\n\tthis._resultGeometry = null;\n\tthis._saveException = null;\n\tif (arguments.length === 1) {\n\t\tvar g = arguments[0];\n\t\tthis._argGeom = g;\n\t} else if (arguments.length === 2) {\n\t\tvar g = arguments[0],\n\t\t    bufParams = arguments[1];\n\t\tthis._argGeom = g;\n\t\tthis._bufParams = bufParams;\n\t}\n}\nextend(BufferOp.prototype, {\n\tbufferFixedPrecision: function bufferFixedPrecision(fixedPM) {\n\t\tvar noder = new ScaledNoder(new MCIndexSnapRounder(new PrecisionModel(1.0)), fixedPM.getScale());\n\t\tvar bufBuilder = new BufferBuilder(this._bufParams);\n\t\tbufBuilder.setWorkingPrecisionModel(fixedPM);\n\t\tbufBuilder.setNoder(noder);\n\t\tthis._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);\n\t},\n\tbufferReducedPrecision: function bufferReducedPrecision() {\n\t\tif (arguments.length === 0) {\n\t\t\tfor (var precDigits = BufferOp.MAX_PRECISION_DIGITS; precDigits >= 0; precDigits--) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.bufferReducedPrecision(precDigits);\n\t\t\t\t} catch (ex) {\n\t\t\t\t\tif (ex instanceof TopologyException) {\n\t\t\t\t\t\tthis._saveException = ex;\n\t\t\t\t\t} else throw ex;\n\t\t\t\t} finally {}\n\t\t\t\tif (this._resultGeometry !== null) return null;\n\t\t\t}\n\t\t\tthrow this._saveException;\n\t\t} else if (arguments.length === 1) {\n\t\t\tvar precisionDigits = arguments[0];\n\t\t\tvar sizeBasedScaleFactor = BufferOp.precisionScaleFactor(this._argGeom, this._distance, precisionDigits);\n\t\t\tvar fixedPM = new PrecisionModel(sizeBasedScaleFactor);\n\t\t\tthis.bufferFixedPrecision(fixedPM);\n\t\t}\n\t},\n\tcomputeGeometry: function computeGeometry() {\n\t\tthis.bufferOriginalPrecision();\n\t\tif (this._resultGeometry !== null) return null;\n\t\tvar argPM = this._argGeom.getFactory().getPrecisionModel();\n\t\tif (argPM.getType() === PrecisionModel.FIXED) this.bufferFixedPrecision(argPM);else this.bufferReducedPrecision();\n\t},\n\tsetQuadrantSegments: function setQuadrantSegments(quadrantSegments) {\n\t\tthis._bufParams.setQuadrantSegments(quadrantSegments);\n\t},\n\tbufferOriginalPrecision: function bufferOriginalPrecision() {\n\t\ttry {\n\t\t\tvar bufBuilder = new BufferBuilder(this._bufParams);\n\t\t\tthis._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof RuntimeException) {\n\t\t\t\tthis._saveException = ex;\n\t\t\t} else throw ex;\n\t\t} finally {}\n\t},\n\tgetResultGeometry: function getResultGeometry(distance) {\n\t\tthis._distance = distance;\n\t\tthis.computeGeometry();\n\t\treturn this._resultGeometry;\n\t},\n\tsetEndCapStyle: function setEndCapStyle(endCapStyle) {\n\t\tthis._bufParams.setEndCapStyle(endCapStyle);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn BufferOp;\n\t}\n});\nBufferOp.bufferOp = function () {\n\tif (arguments.length === 2) {\n\t\tvar g = arguments[0],\n\t\t    distance = arguments[1];\n\t\tvar gBuf = new BufferOp(g);\n\t\tvar geomBuf = gBuf.getResultGeometry(distance);\n\t\treturn geomBuf;\n\t} else if (arguments.length === 3) {\n\t\tif (Number.isInteger(arguments[2]) && arguments[0] instanceof Geometry && typeof arguments[1] === \"number\") {\n\t\t\tvar g = arguments[0],\n\t\t\t    distance = arguments[1],\n\t\t\t    quadrantSegments = arguments[2];\n\t\t\tvar bufOp = new BufferOp(g);\n\t\t\tbufOp.setQuadrantSegments(quadrantSegments);\n\t\t\tvar geomBuf = bufOp.getResultGeometry(distance);\n\t\t\treturn geomBuf;\n\t\t} else if (arguments[2] instanceof BufferParameters && arguments[0] instanceof Geometry && typeof arguments[1] === \"number\") {\n\t\t\tvar g = arguments[0],\n\t\t\t    distance = arguments[1],\n\t\t\t    params = arguments[2];\n\t\t\tvar bufOp = new BufferOp(g, params);\n\t\t\tvar geomBuf = bufOp.getResultGeometry(distance);\n\t\t\treturn geomBuf;\n\t\t}\n\t} else if (arguments.length === 4) {\n\t\tvar g = arguments[0],\n\t\t    distance = arguments[1],\n\t\t    quadrantSegments = arguments[2],\n\t\t    endCapStyle = arguments[3];\n\t\tvar bufOp = new BufferOp(g);\n\t\tbufOp.setQuadrantSegments(quadrantSegments);\n\t\tbufOp.setEndCapStyle(endCapStyle);\n\t\tvar geomBuf = bufOp.getResultGeometry(distance);\n\t\treturn geomBuf;\n\t}\n};\nBufferOp.precisionScaleFactor = function (g, distance, maxPrecisionDigits) {\n\tvar env = g.getEnvelopeInternal();\n\tvar envMax = MathUtil.max(Math.abs(env.getMaxX()), Math.abs(env.getMaxY()), Math.abs(env.getMinX()), Math.abs(env.getMinY()));\n\tvar expandByDistance = distance > 0.0 ? distance : 0.0;\n\tvar bufEnvMax = envMax + 2 * expandByDistance;\n\tvar bufEnvPrecisionDigits = Math.trunc(Math.log(bufEnvMax) / Math.log(10) + 1.0);\n\tvar minUnitLog10 = maxPrecisionDigits - bufEnvPrecisionDigits;\n\tvar scaleFactor = Math.pow(10.0, minUnitLog10);\n\treturn scaleFactor;\n};\nBufferOp.CAP_ROUND = BufferParameters.CAP_ROUND;\nBufferOp.CAP_BUTT = BufferParameters.CAP_FLAT;\nBufferOp.CAP_FLAT = BufferParameters.CAP_FLAT;\nBufferOp.CAP_SQUARE = BufferParameters.CAP_SQUARE;\nBufferOp.MAX_PRECISION_DIGITS = 12;\n\nfunction PolygonExtracter() {\n\tthis._comps = null;\n\tvar comps = arguments[0];\n\tthis._comps = comps;\n}\nextend(PolygonExtracter.prototype, {\n\tfilter: function filter(geom) {\n\t\tif (geom instanceof Polygon) this._comps.add(geom);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [GeometryFilter];\n\t},\n\tgetClass: function getClass() {\n\t\treturn PolygonExtracter;\n\t}\n});\nPolygonExtracter.getPolygons = function () {\n\tif (arguments.length === 1) {\n\t\tvar geom = arguments[0];\n\t\treturn PolygonExtracter.getPolygons(geom, new ArrayList());\n\t} else if (arguments.length === 2) {\n\t\tvar geom = arguments[0],\n\t\t    list = arguments[1];\n\t\tif (geom instanceof Polygon) {\n\t\t\tlist.add(geom);\n\t\t} else if (geom instanceof GeometryCollection) {\n\t\t\tgeom.apply(new PolygonExtracter(list));\n\t\t}\n\t\treturn list;\n\t}\n};\n\nfunction GeometryLocation() {\n\tthis._component = null;\n\tthis._segIndex = null;\n\tthis._pt = null;\n\tif (arguments.length === 2) {\n\t\tvar component = arguments[0],\n\t\t    pt = arguments[1];\n\t\tGeometryLocation.call(this, component, GeometryLocation.INSIDE_AREA, pt);\n\t} else if (arguments.length === 3) {\n\t\tvar component = arguments[0],\n\t\t    segIndex = arguments[1],\n\t\t    pt = arguments[2];\n\t\tthis._component = component;\n\t\tthis._segIndex = segIndex;\n\t\tthis._pt = pt;\n\t}\n}\nextend(GeometryLocation.prototype, {\n\tisInsideArea: function isInsideArea() {\n\t\treturn this._segIndex === GeometryLocation.INSIDE_AREA;\n\t},\n\tgetCoordinate: function getCoordinate() {\n\t\treturn this._pt;\n\t},\n\tgetGeometryComponent: function getGeometryComponent() {\n\t\treturn this._component;\n\t},\n\tgetSegmentIndex: function getSegmentIndex() {\n\t\treturn this._segIndex;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn GeometryLocation;\n\t}\n});\nGeometryLocation.INSIDE_AREA = -1;\n\nfunction PointExtracter() {\n\tthis._pts = null;\n\tvar pts = arguments[0];\n\tthis._pts = pts;\n}\nextend(PointExtracter.prototype, {\n\tfilter: function filter(geom) {\n\t\tif (geom instanceof Point) this._pts.add(geom);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [GeometryFilter];\n\t},\n\tgetClass: function getClass() {\n\t\treturn PointExtracter;\n\t}\n});\nPointExtracter.getPoints = function () {\n\tif (arguments.length === 1) {\n\t\tvar geom = arguments[0];\n\t\tif (geom instanceof Point) {\n\t\t\treturn Collections.singletonList(geom);\n\t\t}\n\t\treturn PointExtracter.getPoints(geom, new ArrayList());\n\t} else if (arguments.length === 2) {\n\t\tvar geom = arguments[0],\n\t\t    list = arguments[1];\n\t\tif (geom instanceof Point) {\n\t\t\tlist.add(geom);\n\t\t} else if (geom instanceof GeometryCollection) {\n\t\t\tgeom.apply(new PointExtracter(list));\n\t\t}\n\t\treturn list;\n\t}\n};\n\nfunction ConnectedElementLocationFilter() {\n\tthis._locations = null;\n\tvar locations = arguments[0];\n\tthis._locations = locations;\n}\nextend(ConnectedElementLocationFilter.prototype, {\n\tfilter: function filter(geom) {\n\t\tif (geom instanceof Point || geom instanceof LineString || geom instanceof Polygon) this._locations.add(new GeometryLocation(geom, 0, geom.getCoordinate()));\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [GeometryFilter];\n\t},\n\tgetClass: function getClass() {\n\t\treturn ConnectedElementLocationFilter;\n\t}\n});\nConnectedElementLocationFilter.getLocations = function (geom) {\n\tvar locations = new ArrayList();\n\tgeom.apply(new ConnectedElementLocationFilter(locations));\n\treturn locations;\n};\n\nfunction DistanceOp() {\n\tthis._geom = null;\n\tthis._terminateDistance = 0.0;\n\tthis._ptLocator = new PointLocator();\n\tthis._minDistanceLocation = null;\n\tthis._minDistance = Double.MAX_VALUE;\n\tif (arguments.length === 2) {\n\t\tvar g0 = arguments[0],\n\t\t    g1 = arguments[1];\n\t\tDistanceOp.call(this, g0, g1, 0.0);\n\t} else if (arguments.length === 3) {\n\t\tvar g0 = arguments[0],\n\t\t    g1 = arguments[1],\n\t\t    terminateDistance = arguments[2];\n\t\tthis._geom = new Array(2).fill(null);\n\t\tthis._geom[0] = g0;\n\t\tthis._geom[1] = g1;\n\t\tthis._terminateDistance = terminateDistance;\n\t}\n}\nextend(DistanceOp.prototype, {\n\tcomputeContainmentDistance: function computeContainmentDistance() {\n\t\tif (arguments.length === 0) {\n\t\t\tvar locPtPoly = new Array(2).fill(null);\n\t\t\tthis.computeContainmentDistance(0, locPtPoly);\n\t\t\tif (this._minDistance <= this._terminateDistance) return null;\n\t\t\tthis.computeContainmentDistance(1, locPtPoly);\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar polyGeomIndex = arguments[0],\n\t\t\t    locPtPoly = arguments[1];\n\t\t\tvar locationsIndex = 1 - polyGeomIndex;\n\t\t\tvar polys = PolygonExtracter.getPolygons(this._geom[polyGeomIndex]);\n\t\t\tif (polys.size() > 0) {\n\t\t\t\tvar insideLocs = ConnectedElementLocationFilter.getLocations(this._geom[locationsIndex]);\n\t\t\t\tthis.computeContainmentDistance(insideLocs, polys, locPtPoly);\n\t\t\t\tif (this._minDistance <= this._terminateDistance) {\n\t\t\t\t\tthis._minDistanceLocation[locationsIndex] = locPtPoly[0];\n\t\t\t\t\tthis._minDistanceLocation[polyGeomIndex] = locPtPoly[1];\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tif (arguments[2] instanceof Array && hasInterface(arguments[0], List) && hasInterface(arguments[1], List)) {\n\t\t\t\tvar locs = arguments[0],\n\t\t\t\t    polys = arguments[1],\n\t\t\t\t    locPtPoly = arguments[2];\n\t\t\t\tfor (var i = 0; i < locs.size(); i++) {\n\t\t\t\t\tvar loc = locs.get(i);\n\t\t\t\t\tfor (var j = 0; j < polys.size(); j++) {\n\t\t\t\t\t\tthis.computeContainmentDistance(loc, polys.get(j), locPtPoly);\n\t\t\t\t\t\tif (this._minDistance <= this._terminateDistance) return null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (arguments[2] instanceof Array && arguments[0] instanceof GeometryLocation && arguments[1] instanceof Polygon) {\n\t\t\t\tvar ptLoc = arguments[0],\n\t\t\t\t    poly = arguments[1],\n\t\t\t\t    locPtPoly = arguments[2];\n\t\t\t\tvar pt = ptLoc.getCoordinate();\n\t\t\t\tif (Location.EXTERIOR !== this._ptLocator.locate(pt, poly)) {\n\t\t\t\t\tthis._minDistance = 0.0;\n\t\t\t\t\tlocPtPoly[0] = ptLoc;\n\t\t\t\t\tlocPtPoly[1] = new GeometryLocation(poly, pt);\n\t\t\t\t\t\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tcomputeMinDistanceLinesPoints: function computeMinDistanceLinesPoints(lines, points, locGeom) {\n\t\tfor (var i = 0; i < lines.size(); i++) {\n\t\t\tvar line = lines.get(i);\n\t\t\tfor (var j = 0; j < points.size(); j++) {\n\t\t\t\tvar pt = points.get(j);\n\t\t\t\tthis.computeMinDistance(line, pt, locGeom);\n\t\t\t\tif (this._minDistance <= this._terminateDistance) return null;\n\t\t\t}\n\t\t}\n\t},\n\tcomputeFacetDistance: function computeFacetDistance() {\n\t\tvar locGeom = new Array(2).fill(null);\n\t\tvar lines0 = LinearComponentExtracter.getLines(this._geom[0]);\n\t\tvar lines1 = LinearComponentExtracter.getLines(this._geom[1]);\n\t\tvar pts0 = PointExtracter.getPoints(this._geom[0]);\n\t\tvar pts1 = PointExtracter.getPoints(this._geom[1]);\n\t\tthis.computeMinDistanceLines(lines0, lines1, locGeom);\n\t\tthis.updateMinDistance(locGeom, false);\n\t\tif (this._minDistance <= this._terminateDistance) return null;\n\t\tlocGeom[0] = null;\n\t\tlocGeom[1] = null;\n\t\tthis.computeMinDistanceLinesPoints(lines0, pts1, locGeom);\n\t\tthis.updateMinDistance(locGeom, false);\n\t\tif (this._minDistance <= this._terminateDistance) return null;\n\t\tlocGeom[0] = null;\n\t\tlocGeom[1] = null;\n\t\tthis.computeMinDistanceLinesPoints(lines1, pts0, locGeom);\n\t\tthis.updateMinDistance(locGeom, true);\n\t\tif (this._minDistance <= this._terminateDistance) return null;\n\t\tlocGeom[0] = null;\n\t\tlocGeom[1] = null;\n\t\tthis.computeMinDistancePoints(pts0, pts1, locGeom);\n\t\tthis.updateMinDistance(locGeom, false);\n\t},\n\tnearestLocations: function nearestLocations() {\n\t\tthis.computeMinDistance();\n\t\treturn this._minDistanceLocation;\n\t},\n\tupdateMinDistance: function updateMinDistance(locGeom, flip) {\n\t\tif (locGeom[0] === null) return null;\n\t\tif (flip) {\n\t\t\tthis._minDistanceLocation[0] = locGeom[1];\n\t\t\tthis._minDistanceLocation[1] = locGeom[0];\n\t\t} else {\n\t\t\tthis._minDistanceLocation[0] = locGeom[0];\n\t\t\tthis._minDistanceLocation[1] = locGeom[1];\n\t\t}\n\t},\n\tnearestPoints: function nearestPoints() {\n\t\tthis.computeMinDistance();\n\t\tvar nearestPts = [this._minDistanceLocation[0].getCoordinate(), this._minDistanceLocation[1].getCoordinate()];\n\t\treturn nearestPts;\n\t},\n\tcomputeMinDistance: function computeMinDistance() {\n\t\tif (arguments.length === 0) {\n\t\t\tif (this._minDistanceLocation !== null) return null;\n\t\t\tthis._minDistanceLocation = new Array(2).fill(null);\n\t\t\tthis.computeContainmentDistance();\n\t\t\tif (this._minDistance <= this._terminateDistance) return null;\n\t\t\tthis.computeFacetDistance();\n\t\t} else if (arguments.length === 3) {\n\t\t\tif (arguments[2] instanceof Array && arguments[0] instanceof LineString && arguments[1] instanceof Point) {\n\t\t\t\tvar line = arguments[0],\n\t\t\t\t    pt = arguments[1],\n\t\t\t\t    locGeom = arguments[2];\n\t\t\t\tif (line.getEnvelopeInternal().distance(pt.getEnvelopeInternal()) > this._minDistance) return null;\n\t\t\t\tvar coord0 = line.getCoordinates();\n\t\t\t\tvar coord = pt.getCoordinate();\n\t\t\t\tfor (var i = 0; i < coord0.length - 1; i++) {\n\t\t\t\t\tvar dist = CGAlgorithms.distancePointLine(coord, coord0[i], coord0[i + 1]);\n\t\t\t\t\tif (dist < this._minDistance) {\n\t\t\t\t\t\tthis._minDistance = dist;\n\t\t\t\t\t\tvar seg = new LineSegment(coord0[i], coord0[i + 1]);\n\t\t\t\t\t\tvar segClosestPoint = seg.closestPoint(coord);\n\t\t\t\t\t\tlocGeom[0] = new GeometryLocation(line, i, segClosestPoint);\n\t\t\t\t\t\tlocGeom[1] = new GeometryLocation(pt, 0, coord);\n\t\t\t\t\t}\n\t\t\t\t\tif (this._minDistance <= this._terminateDistance) return null;\n\t\t\t\t}\n\t\t\t} else if (arguments[2] instanceof Array && arguments[0] instanceof LineString && arguments[1] instanceof LineString) {\n\t\t\t\tvar line0 = arguments[0],\n\t\t\t\t    line1 = arguments[1],\n\t\t\t\t    locGeom = arguments[2];\n\t\t\t\tif (line0.getEnvelopeInternal().distance(line1.getEnvelopeInternal()) > this._minDistance) return null;\n\t\t\t\tvar coord0 = line0.getCoordinates();\n\t\t\t\tvar coord1 = line1.getCoordinates();\n\t\t\t\tfor (var i = 0; i < coord0.length - 1; i++) {\n\t\t\t\t\tfor (var j = 0; j < coord1.length - 1; j++) {\n\t\t\t\t\t\tvar dist = CGAlgorithms.distanceLineLine(coord0[i], coord0[i + 1], coord1[j], coord1[j + 1]);\n\t\t\t\t\t\tif (dist < this._minDistance) {\n\t\t\t\t\t\t\tthis._minDistance = dist;\n\t\t\t\t\t\t\tvar seg0 = new LineSegment(coord0[i], coord0[i + 1]);\n\t\t\t\t\t\t\tvar seg1 = new LineSegment(coord1[j], coord1[j + 1]);\n\t\t\t\t\t\t\tvar closestPt = seg0.closestPoints(seg1);\n\t\t\t\t\t\t\tlocGeom[0] = new GeometryLocation(line0, i, closestPt[0]);\n\t\t\t\t\t\t\tlocGeom[1] = new GeometryLocation(line1, j, closestPt[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (this._minDistance <= this._terminateDistance) return null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tcomputeMinDistancePoints: function computeMinDistancePoints(points0, points1, locGeom) {\n\t\tfor (var i = 0; i < points0.size(); i++) {\n\t\t\tvar pt0 = points0.get(i);\n\t\t\tfor (var j = 0; j < points1.size(); j++) {\n\t\t\t\tvar pt1 = points1.get(j);\n\t\t\t\tvar dist = pt0.getCoordinate().distance(pt1.getCoordinate());\n\t\t\t\tif (dist < this._minDistance) {\n\t\t\t\t\tthis._minDistance = dist;\n\t\t\t\t\tlocGeom[0] = new GeometryLocation(pt0, 0, pt0.getCoordinate());\n\t\t\t\t\tlocGeom[1] = new GeometryLocation(pt1, 0, pt1.getCoordinate());\n\t\t\t\t}\n\t\t\t\tif (this._minDistance <= this._terminateDistance) return null;\n\t\t\t}\n\t\t}\n\t},\n\tdistance: function distance() {\n\t\tif (this._geom[0] === null || this._geom[1] === null) throw new IllegalArgumentException(\"null geometries are not supported\");\n\t\tif (this._geom[0].isEmpty() || this._geom[1].isEmpty()) return 0.0;\n\t\tthis.computeMinDistance();\n\t\treturn this._minDistance;\n\t},\n\tcomputeMinDistanceLines: function computeMinDistanceLines(lines0, lines1, locGeom) {\n\t\tfor (var i = 0; i < lines0.size(); i++) {\n\t\t\tvar line0 = lines0.get(i);\n\t\t\tfor (var j = 0; j < lines1.size(); j++) {\n\t\t\t\tvar line1 = lines1.get(j);\n\t\t\t\tthis.computeMinDistance(line0, line1, locGeom);\n\t\t\t\tif (this._minDistance <= this._terminateDistance) return null;\n\t\t\t}\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn DistanceOp;\n\t}\n});\nDistanceOp.distance = function (g0, g1) {\n\tvar distOp = new DistanceOp(g0, g1);\n\treturn distOp.distance();\n};\nDistanceOp.isWithinDistance = function (g0, g1, distance) {\n\tvar distOp = new DistanceOp(g0, g1, distance);\n\treturn distOp.distance() <= distance;\n};\nDistanceOp.nearestPoints = function (g0, g1) {\n\tvar distOp = new DistanceOp(g0, g1);\n\treturn distOp.nearestPoints();\n};\n\nfunction EdgeString() {\n\tthis._factory = null;\n\tthis._directedEdges = new ArrayList();\n\tthis._coordinates = null;\n\tvar factory = arguments[0];\n\tthis._factory = factory;\n}\nextend(EdgeString.prototype, {\n\tgetCoordinates: function getCoordinates() {\n\t\tif (this._coordinates === null) {\n\t\t\tvar forwardDirectedEdges = 0;\n\t\t\tvar reverseDirectedEdges = 0;\n\t\t\tvar coordinateList = new CoordinateList();\n\t\t\tfor (var i = this._directedEdges.iterator(); i.hasNext();) {\n\t\t\t\tvar directedEdge = i.next();\n\t\t\t\tif (directedEdge.getEdgeDirection()) {\n\t\t\t\t\tforwardDirectedEdges++;\n\t\t\t\t} else {\n\t\t\t\t\treverseDirectedEdges++;\n\t\t\t\t}\n\t\t\t\tcoordinateList.add(directedEdge.getEdge().getLine().getCoordinates(), false, directedEdge.getEdgeDirection());\n\t\t\t}\n\t\t\tthis._coordinates = coordinateList.toCoordinateArray();\n\t\t\tif (reverseDirectedEdges > forwardDirectedEdges) {\n\t\t\t\tCoordinateArrays.reverse(this._coordinates);\n\t\t\t}\n\t\t}\n\t\treturn this._coordinates;\n\t},\n\ttoLineString: function toLineString() {\n\t\treturn this._factory.createLineString(this.getCoordinates());\n\t},\n\tadd: function add(directedEdge) {\n\t\tthis._directedEdges.add(directedEdge);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn EdgeString;\n\t}\n});\n\nfunction GraphComponent$1() {\n\tthis._isMarked = false;\n\tthis._isVisited = false;\n\tthis._data = null;\n}\nextend(GraphComponent$1.prototype, {\n\tsetVisited: function setVisited(isVisited) {\n\t\tthis._isVisited = isVisited;\n\t},\n\tisMarked: function isMarked() {\n\t\treturn this._isMarked;\n\t},\n\tsetData: function setData(data) {\n\t\tthis._data = data;\n\t},\n\tgetData: function getData() {\n\t\treturn this._data;\n\t},\n\tsetMarked: function setMarked(isMarked) {\n\t\tthis._isMarked = isMarked;\n\t},\n\tgetContext: function getContext() {\n\t\treturn this._data;\n\t},\n\tisVisited: function isVisited() {\n\t\treturn this._isVisited;\n\t},\n\tsetContext: function setContext(data) {\n\t\tthis._data = data;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn GraphComponent$1;\n\t}\n});\nGraphComponent$1.getComponentWithVisitedState = function (i, visitedState) {\n\twhile (i.hasNext()) {\n\t\tvar comp = i.next();\n\t\tif (comp.isVisited() === visitedState) return comp;\n\t}\n\treturn null;\n};\nGraphComponent$1.setVisited = function (i, visited) {\n\twhile (i.hasNext()) {\n\t\tvar comp = i.next();\n\t\tcomp.setVisited(visited);\n\t}\n};\nGraphComponent$1.setMarked = function (i, marked) {\n\twhile (i.hasNext()) {\n\t\tvar comp = i.next();\n\t\tcomp.setMarked(marked);\n\t}\n};\n\nfunction DirectedEdge$1() {\n\tGraphComponent$1.apply(this);\n\tthis._parentEdge = null;\n\tthis._from = null;\n\tthis._to = null;\n\tthis._p0 = null;\n\tthis._p1 = null;\n\tthis._sym = null;\n\tthis._edgeDirection = null;\n\tthis._quadrant = null;\n\tthis._angle = null;\n\tvar from = arguments[0],\n\t    to = arguments[1],\n\t    directionPt = arguments[2],\n\t    edgeDirection = arguments[3];\n\tthis._from = from;\n\tthis._to = to;\n\tthis._edgeDirection = edgeDirection;\n\tthis._p0 = from.getCoordinate();\n\tthis._p1 = directionPt;\n\tvar dx = this._p1.x - this._p0.x;\n\tvar dy = this._p1.y - this._p0.y;\n\tthis._quadrant = Quadrant.quadrant(dx, dy);\n\tthis._angle = Math.atan2(dy, dx);\n}\ninherits$1(DirectedEdge$1, GraphComponent$1);\nextend(DirectedEdge$1.prototype, {\n\tisRemoved: function isRemoved() {\n\t\treturn this._parentEdge === null;\n\t},\n\tcompareDirection: function compareDirection(e) {\n\t\tif (this._quadrant > e._quadrant) return 1;\n\t\tif (this._quadrant < e._quadrant) return -1;\n\t\treturn CGAlgorithms.computeOrientation(e._p0, e._p1, this._p1);\n\t},\n\tgetCoordinate: function getCoordinate() {\n\t\treturn this._from.getCoordinate();\n\t},\n\tprint: function print(out) {\n\t\tvar className = this.getClass().getName();\n\t\tvar lastDotPos = className.lastIndexOf('.');\n\t\tvar name = className.substring(lastDotPos + 1);\n\t\tout.print(\"  \" + name + \": \" + this._p0 + \" - \" + this._p1 + \" \" + this._quadrant + \":\" + this._angle);\n\t},\n\tgetDirectionPt: function getDirectionPt() {\n\t\treturn this._p1;\n\t},\n\tgetAngle: function getAngle() {\n\t\treturn this._angle;\n\t},\n\tcompareTo: function compareTo(obj) {\n\t\tvar de = obj;\n\t\treturn this.compareDirection(de);\n\t},\n\tgetFromNode: function getFromNode() {\n\t\treturn this._from;\n\t},\n\tgetSym: function getSym() {\n\t\treturn this._sym;\n\t},\n\tsetEdge: function setEdge(parentEdge) {\n\t\tthis._parentEdge = parentEdge;\n\t},\n\tremove: function remove() {\n\t\tthis._sym = null;\n\t\tthis._parentEdge = null;\n\t},\n\tgetEdge: function getEdge() {\n\t\treturn this._parentEdge;\n\t},\n\tgetQuadrant: function getQuadrant() {\n\t\treturn this._quadrant;\n\t},\n\tsetSym: function setSym(sym) {\n\t\tthis._sym = sym;\n\t},\n\tgetToNode: function getToNode() {\n\t\treturn this._to;\n\t},\n\tgetEdgeDirection: function getEdgeDirection() {\n\t\treturn this._edgeDirection;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Comparable];\n\t},\n\tgetClass: function getClass() {\n\t\treturn DirectedEdge$1;\n\t}\n});\nDirectedEdge$1.toEdges = function (dirEdges) {\n\tvar edges = new ArrayList();\n\tfor (var i = dirEdges.iterator(); i.hasNext();) {\n\t\tedges.add(i.next()._parentEdge);\n\t}\n\treturn edges;\n};\n\nfunction LineMergeDirectedEdge() {\n\tvar from = arguments[0],\n\t    to = arguments[1],\n\t    directionPt = arguments[2],\n\t    edgeDirection = arguments[3];\n\tDirectedEdge$1.call(this, from, to, directionPt, edgeDirection);\n}\ninherits$1(LineMergeDirectedEdge, DirectedEdge$1);\nextend(LineMergeDirectedEdge.prototype, {\n\tgetNext: function getNext() {\n\t\tif (this.getToNode().getDegree() !== 2) {\n\t\t\treturn null;\n\t\t}\n\t\tif (this.getToNode().getOutEdges().getEdges().get(0) === this.getSym()) {\n\t\t\treturn this.getToNode().getOutEdges().getEdges().get(1);\n\t\t}\n\t\tAssert.isTrue(this.getToNode().getOutEdges().getEdges().get(1) === this.getSym());\n\t\treturn this.getToNode().getOutEdges().getEdges().get(0);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn LineMergeDirectedEdge;\n\t}\n});\n\nfunction Edge$1() {\n\tGraphComponent$1.apply(this);\n\tthis._dirEdge = null;\n\tif (arguments.length === 0) {} else if (arguments.length === 2) {\n\t\tvar de0 = arguments[0],\n\t\t    de1 = arguments[1];\n\t\tthis.setDirectedEdges(de0, de1);\n\t}\n}\ninherits$1(Edge$1, GraphComponent$1);\nextend(Edge$1.prototype, {\n\tisRemoved: function isRemoved() {\n\t\treturn this._dirEdge === null;\n\t},\n\tsetDirectedEdges: function setDirectedEdges(de0, de1) {\n\t\tthis._dirEdge = [de0, de1];\n\t\tde0.setEdge(this);\n\t\tde1.setEdge(this);\n\t\tde0.setSym(de1);\n\t\tde1.setSym(de0);\n\t\tde0.getFromNode().addOutEdge(de0);\n\t\tde1.getFromNode().addOutEdge(de1);\n\t},\n\tgetDirEdge: function getDirEdge() {\n\t\tif (Number.isInteger(arguments[0])) {\n\t\t\tvar i = arguments[0];\n\t\t\treturn this._dirEdge[i];\n\t\t} else if (arguments[0] instanceof Node$3) {\n\t\t\tvar fromNode = arguments[0];\n\t\t\tif (this._dirEdge[0].getFromNode() === fromNode) return this._dirEdge[0];\n\t\t\tif (this._dirEdge[1].getFromNode() === fromNode) return this._dirEdge[1];\n\t\t\treturn null;\n\t\t}\n\t},\n\tremove: function remove() {\n\t\tthis._dirEdge = null;\n\t},\n\tgetOppositeNode: function getOppositeNode(node) {\n\t\tif (this._dirEdge[0].getFromNode() === node) return this._dirEdge[0].getToNode();\n\t\tif (this._dirEdge[1].getFromNode() === node) return this._dirEdge[1].getToNode();\n\t\treturn null;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Edge$1;\n\t}\n});\n\nfunction DirectedEdgeStar$1() {\n\tthis._outEdges = new ArrayList();\n\tthis._sorted = false;\n}\nextend(DirectedEdgeStar$1.prototype, {\n\tgetNextEdge: function getNextEdge(dirEdge) {\n\t\tvar i = this.getIndex(dirEdge);\n\t\treturn this._outEdges.get(this.getIndex(i + 1));\n\t},\n\tgetCoordinate: function getCoordinate() {\n\t\tvar it = this.iterator();\n\t\tif (!it.hasNext()) return null;\n\t\tvar e = it.next();\n\t\treturn e.getCoordinate();\n\t},\n\titerator: function iterator() {\n\t\tthis.sortEdges();\n\t\treturn this._outEdges.iterator();\n\t},\n\tsortEdges: function sortEdges() {\n\t\tif (!this._sorted) {\n\t\t\tCollections.sort(this._outEdges);\n\t\t\tthis._sorted = true;\n\t\t}\n\t},\n\tremove: function remove(de) {\n\t\tthis._outEdges.remove(de);\n\t},\n\tgetEdges: function getEdges() {\n\t\tthis.sortEdges();\n\t\treturn this._outEdges;\n\t},\n\tgetNextCWEdge: function getNextCWEdge(dirEdge) {\n\t\tvar i = this.getIndex(dirEdge);\n\t\treturn this._outEdges.get(this.getIndex(i - 1));\n\t},\n\tgetIndex: function getIndex() {\n\t\tif (arguments[0] instanceof Edge$1) {\n\t\t\tvar edge = arguments[0];\n\t\t\tthis.sortEdges();\n\t\t\tfor (var i = 0; i < this._outEdges.size(); i++) {\n\t\t\t\tvar de = this._outEdges.get(i);\n\t\t\t\tif (de.getEdge() === edge) return i;\n\t\t\t}\n\t\t\treturn -1;\n\t\t} else if (arguments[0] instanceof DirectedEdge$1) {\n\t\t\tvar dirEdge = arguments[0];\n\t\t\tthis.sortEdges();\n\t\t\tfor (var i = 0; i < this._outEdges.size(); i++) {\n\t\t\t\tvar de = this._outEdges.get(i);\n\t\t\t\tif (de === dirEdge) return i;\n\t\t\t}\n\t\t\treturn -1;\n\t\t} else if (Number.isInteger(arguments[0])) {\n\t\t\tvar i = arguments[0];\n\t\t\tvar modi = i % this._outEdges.size();\n\t\t\tif (modi < 0) modi += this._outEdges.size();\n\t\t\treturn modi;\n\t\t}\n\t},\n\tadd: function add(de) {\n\t\tthis._outEdges.add(de);\n\t\tthis._sorted = false;\n\t},\n\tgetDegree: function getDegree() {\n\t\treturn this._outEdges.size();\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn DirectedEdgeStar$1;\n\t}\n});\n\nfunction Node$3() {\n\tGraphComponent$1.apply(this);\n\tthis._pt = null;\n\tthis._deStar = null;\n\tif (arguments.length === 1) {\n\t\tvar pt = arguments[0];\n\t\tNode$3.call(this, pt, new DirectedEdgeStar$1());\n\t} else if (arguments.length === 2) {\n\t\tvar pt = arguments[0],\n\t\t    deStar = arguments[1];\n\t\tthis._pt = pt;\n\t\tthis._deStar = deStar;\n\t}\n}\ninherits$1(Node$3, GraphComponent$1);\nextend(Node$3.prototype, {\n\tisRemoved: function isRemoved() {\n\t\treturn this._pt === null;\n\t},\n\taddOutEdge: function addOutEdge(de) {\n\t\tthis._deStar.add(de);\n\t},\n\tgetCoordinate: function getCoordinate() {\n\t\treturn this._pt;\n\t},\n\tgetOutEdges: function getOutEdges() {\n\t\treturn this._deStar;\n\t},\n\tremove: function remove() {\n\t\tif (arguments.length === 0) {\n\t\t\tthis._pt = null;\n\t\t} else if (arguments.length === 1) {\n\t\t\tvar de = arguments[0];\n\t\t\tthis._deStar.remove(de);\n\t\t}\n\t},\n\tgetIndex: function getIndex(edge) {\n\t\treturn this._deStar.getIndex(edge);\n\t},\n\tgetDegree: function getDegree() {\n\t\treturn this._deStar.getDegree();\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Node$3;\n\t}\n});\nNode$3.getEdgesBetween = function (node0, node1) {\n\tvar edges0 = DirectedEdge$1.toEdges(node0.getOutEdges().getEdges());\n\tvar commonEdges = new HashSet(edges0);\n\tvar edges1 = DirectedEdge$1.toEdges(node1.getOutEdges().getEdges());\n\tcommonEdges.retainAll(edges1);\n\treturn commonEdges;\n};\n\nfunction LineMergeEdge() {\n\tEdge$1.apply(this);\n\tthis._line = null;\n\tvar line = arguments[0];\n\tthis._line = line;\n}\ninherits$1(LineMergeEdge, Edge$1);\nextend(LineMergeEdge.prototype, {\n\tgetLine: function getLine() {\n\t\treturn this._line;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn LineMergeEdge;\n\t}\n});\n\nfunction NodeMap$1() {\n\tthis._nodeMap = new TreeMap();\n}\nextend(NodeMap$1.prototype, {\n\tfind: function find(coord) {\n\t\treturn this._nodeMap.get(coord);\n\t},\n\titerator: function iterator() {\n\t\treturn this._nodeMap.values().iterator();\n\t},\n\tremove: function remove(pt) {\n\t\treturn this._nodeMap.remove(pt);\n\t},\n\tvalues: function values() {\n\t\treturn this._nodeMap.values();\n\t},\n\tadd: function add(n) {\n\t\tthis._nodeMap.put(n.getCoordinate(), n);\n\t\treturn n;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn NodeMap$1;\n\t}\n});\n\nfunction PlanarGraph$1() {\n\tthis._edges = new HashSet();\n\tthis._dirEdges = new HashSet();\n\tthis._nodeMap = new NodeMap$1();\n}\nextend(PlanarGraph$1.prototype, {\n\tfindNodesOfDegree: function findNodesOfDegree(degree) {\n\t\tvar nodesFound = new ArrayList();\n\t\tfor (var i = this.nodeIterator(); i.hasNext();) {\n\t\t\tvar node = i.next();\n\t\t\tif (node.getDegree() === degree) nodesFound.add(node);\n\t\t}\n\t\treturn nodesFound;\n\t},\n\tdirEdgeIterator: function dirEdgeIterator() {\n\t\treturn this._dirEdges.iterator();\n\t},\n\tedgeIterator: function edgeIterator() {\n\t\treturn this._edges.iterator();\n\t},\n\tremove: function remove() {\n\t\tif (arguments[0] instanceof Edge$1) {\n\t\t\tvar edge = arguments[0];\n\t\t\tthis.remove(edge.getDirEdge(0));\n\t\t\tthis.remove(edge.getDirEdge(1));\n\t\t\tthis._edges.remove(edge);\n\t\t\tedge.remove();\n\t\t} else if (arguments[0] instanceof DirectedEdge$1) {\n\t\t\tvar de = arguments[0];\n\t\t\tvar sym = de.getSym();\n\t\t\tif (sym !== null) sym.setSym(null);\n\t\t\tde.getFromNode().remove(de);\n\t\t\tde.remove();\n\t\t\tthis._dirEdges.remove(de);\n\t\t} else if (arguments[0] instanceof Node$3) {\n\t\t\tvar node = arguments[0];\n\t\t\tvar outEdges = node.getOutEdges().getEdges();\n\t\t\tfor (var i = outEdges.iterator(); i.hasNext();) {\n\t\t\t\tvar de = i.next();\n\t\t\t\tvar sym = de.getSym();\n\t\t\t\tif (sym !== null) this.remove(sym);\n\t\t\t\tthis._dirEdges.remove(de);\n\t\t\t\tvar edge = de.getEdge();\n\t\t\t\tif (edge !== null) {\n\t\t\t\t\tthis._edges.remove(edge);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._nodeMap.remove(node.getCoordinate());\n\t\t\tnode.remove();\n\t\t}\n\t},\n\tfindNode: function findNode(pt) {\n\t\treturn this._nodeMap.find(pt);\n\t},\n\tgetEdges: function getEdges() {\n\t\treturn this._edges;\n\t},\n\tnodeIterator: function nodeIterator() {\n\t\treturn this._nodeMap.iterator();\n\t},\n\tcontains: function contains() {\n\t\tif (arguments[0] instanceof Edge$1) {\n\t\t\tvar e = arguments[0];\n\t\t\treturn this._edges.contains(e);\n\t\t} else if (arguments[0] instanceof DirectedEdge$1) {\n\t\t\tvar de = arguments[0];\n\t\t\treturn this._dirEdges.contains(de);\n\t\t}\n\t},\n\tadd: function add() {\n\t\tif (arguments[0] instanceof Node$3) {\n\t\t\tvar node = arguments[0];\n\t\t\tthis._nodeMap.add(node);\n\t\t} else if (arguments[0] instanceof Edge$1) {\n\t\t\tvar edge = arguments[0];\n\t\t\tthis._edges.add(edge);\n\t\t\tthis.add(edge.getDirEdge(0));\n\t\t\tthis.add(edge.getDirEdge(1));\n\t\t} else if (arguments[0] instanceof DirectedEdge$1) {\n\t\t\tvar dirEdge = arguments[0];\n\t\t\tthis._dirEdges.add(dirEdge);\n\t\t}\n\t},\n\tgetNodes: function getNodes() {\n\t\treturn this._nodeMap.values();\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn PlanarGraph$1;\n\t}\n});\n\nfunction LineMergeGraph() {\n\tPlanarGraph$1.apply(this);\n}\ninherits$1(LineMergeGraph, PlanarGraph$1);\nextend(LineMergeGraph.prototype, {\n\taddEdge: function addEdge(lineString) {\n\t\tif (lineString.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\t\tvar coordinates = CoordinateArrays.removeRepeatedPoints(lineString.getCoordinates());\n\t\tif (coordinates.length <= 1) return null;\n\t\tvar startCoordinate = coordinates[0];\n\t\tvar endCoordinate = coordinates[coordinates.length - 1];\n\t\tvar startNode = this.getNode(startCoordinate);\n\t\tvar endNode = this.getNode(endCoordinate);\n\t\tvar directedEdge0 = new LineMergeDirectedEdge(startNode, endNode, coordinates[1], true);\n\t\tvar directedEdge1 = new LineMergeDirectedEdge(endNode, startNode, coordinates[coordinates.length - 2], false);\n\t\tvar edge = new LineMergeEdge(lineString);\n\t\tedge.setDirectedEdges(directedEdge0, directedEdge1);\n\t\tthis.add(edge);\n\t},\n\tgetNode: function getNode(coordinate) {\n\t\tvar node = this.findNode(coordinate);\n\t\tif (node === null) {\n\t\t\tnode = new Node$3(coordinate);\n\t\t\tthis.add(node);\n\t\t}\n\t\treturn node;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn LineMergeGraph;\n\t}\n});\n\nfunction LineMerger() {\n\tthis._graph = new LineMergeGraph();\n\tthis._mergedLineStrings = null;\n\tthis._factory = null;\n\tthis._edgeStrings = null;\n}\nextend(LineMerger.prototype, {\n\tbuildEdgeStringsForUnprocessedNodes: function buildEdgeStringsForUnprocessedNodes() {\n\t\tfor (var i = this._graph.getNodes().iterator(); i.hasNext();) {\n\t\t\tvar node = i.next();\n\t\t\tif (!node.isMarked()) {\n\t\t\t\tAssert.isTrue(node.getDegree() === 2);\n\t\t\t\tthis.buildEdgeStringsStartingAt(node);\n\t\t\t\tnode.setMarked(true);\n\t\t\t}\n\t\t}\n\t},\n\tbuildEdgeStringsForNonDegree2Nodes: function buildEdgeStringsForNonDegree2Nodes() {\n\t\tfor (var i = this._graph.getNodes().iterator(); i.hasNext();) {\n\t\t\tvar node = i.next();\n\t\t\tif (node.getDegree() !== 2) {\n\t\t\t\tthis.buildEdgeStringsStartingAt(node);\n\t\t\t\tnode.setMarked(true);\n\t\t\t}\n\t\t}\n\t},\n\tbuildEdgeStringsForObviousStartNodes: function buildEdgeStringsForObviousStartNodes() {\n\t\tthis.buildEdgeStringsForNonDegree2Nodes();\n\t},\n\tgetMergedLineStrings: function getMergedLineStrings() {\n\t\tthis.merge();\n\t\treturn this._mergedLineStrings;\n\t},\n\tbuildEdgeStringsStartingAt: function buildEdgeStringsStartingAt(node) {\n\t\tfor (var i = node.getOutEdges().iterator(); i.hasNext();) {\n\t\t\tvar directedEdge = i.next();\n\t\t\tif (directedEdge.getEdge().isMarked()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis._edgeStrings.add(this.buildEdgeStringStartingWith(directedEdge));\n\t\t}\n\t},\n\tmerge: function merge() {\n\t\tif (this._mergedLineStrings !== null) {\n\t\t\treturn null;\n\t\t}\n\t\tGraphComponent$1.setMarked(this._graph.nodeIterator(), false);\n\t\tGraphComponent$1.setMarked(this._graph.edgeIterator(), false);\n\t\tthis._edgeStrings = new ArrayList();\n\t\tthis.buildEdgeStringsForObviousStartNodes();\n\t\tthis.buildEdgeStringsForIsolatedLoops();\n\t\tthis._mergedLineStrings = new ArrayList();\n\t\tfor (var i = this._edgeStrings.iterator(); i.hasNext();) {\n\t\t\tvar edgeString = i.next();\n\t\t\tthis._mergedLineStrings.add(edgeString.toLineString());\n\t\t}\n\t},\n\tbuildEdgeStringStartingWith: function buildEdgeStringStartingWith(start) {\n\t\tvar edgeString = new EdgeString(this._factory);\n\t\tvar current = start;\n\t\tdo {\n\t\t\tedgeString.add(current);\n\t\t\tcurrent.getEdge().setMarked(true);\n\t\t\tcurrent = current.getNext();\n\t\t} while (current !== null && current !== start);\n\t\treturn edgeString;\n\t},\n\tadd: function add() {\n\t\tif (arguments[0] instanceof Geometry) {\n\t\t\tvar geometry = arguments[0];\n\t\t\tgeometry.apply({\n\t\t\t\tinterfaces_: function interfaces_() {\n\t\t\t\t\treturn [GeometryComponentFilter];\n\t\t\t\t},\n\t\t\t\tfilter: function filter(component) {\n\t\t\t\t\tif (component instanceof LineString) {\n\t\t\t\t\t\tthis.add(component);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (hasInterface(arguments[0], Collection)) {\n\t\t\tvar geometries = arguments[0];\n\t\t\tthis._mergedLineStrings = null;\n\t\t\tfor (var i = geometries.iterator(); i.hasNext();) {\n\t\t\t\tvar geometry = i.next();\n\t\t\t\tthis.add(geometry);\n\t\t\t}\n\t\t} else if (arguments[0] instanceof LineString) {\n\t\t\tvar lineString = arguments[0];\n\t\t\tif (this._factory === null) {\n\t\t\t\tthis._factory = lineString.getFactory();\n\t\t\t}\n\t\t\tthis._graph.addEdge(lineString);\n\t\t}\n\t},\n\tbuildEdgeStringsForIsolatedLoops: function buildEdgeStringsForIsolatedLoops() {\n\t\tthis.buildEdgeStringsForUnprocessedNodes();\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn LineMerger;\n\t}\n});\n\nfunction PolygonizeDirectedEdge() {\n\tthis._edgeRing = null;\n\tthis._next = null;\n\tthis._label = -1;\n\tvar from = arguments[0],\n\t    to = arguments[1],\n\t    directionPt = arguments[2],\n\t    edgeDirection = arguments[3];\n\tDirectedEdge$1.call(this, from, to, directionPt, edgeDirection);\n}\ninherits$1(PolygonizeDirectedEdge, DirectedEdge$1);\nextend(PolygonizeDirectedEdge.prototype, {\n\tgetNext: function getNext() {\n\t\treturn this._next;\n\t},\n\tisInRing: function isInRing() {\n\t\treturn this._edgeRing !== null;\n\t},\n\tsetRing: function setRing(edgeRing) {\n\t\tthis._edgeRing = edgeRing;\n\t},\n\tsetLabel: function setLabel(label) {\n\t\tthis._label = label;\n\t},\n\tgetLabel: function getLabel() {\n\t\treturn this._label;\n\t},\n\tsetNext: function setNext(next) {\n\t\tthis._next = next;\n\t},\n\tgetRing: function getRing() {\n\t\treturn this._edgeRing;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn PolygonizeDirectedEdge;\n\t}\n});\n\nfunction PolygonizeEdge() {\n\tEdge$1.apply(this);\n\tthis._line = null;\n\tvar line = arguments[0];\n\tthis._line = line;\n}\ninherits$1(PolygonizeEdge, Edge$1);\nextend(PolygonizeEdge.prototype, {\n\tgetLine: function getLine() {\n\t\treturn this._line;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn PolygonizeEdge;\n\t}\n});\n\nfunction ConnectedInteriorTester() {\n\tthis._geometryFactory = new GeometryFactory();\n\tthis._geomGraph = null;\n\tthis._disconnectedRingcoord = null;\n\tvar geomGraph = arguments[0];\n\tthis._geomGraph = geomGraph;\n}\nextend(ConnectedInteriorTester.prototype, {\n\tvisitInteriorRing: function visitInteriorRing(ring, graph) {\n\t\tvar pts = ring.getCoordinates();\n\t\tvar pt0 = pts[0];\n\t\tvar pt1 = ConnectedInteriorTester.findDifferentPoint(pts, pt0);\n\t\tvar e = graph.findEdgeInSameDirection(pt0, pt1);\n\t\tvar de = graph.findEdgeEnd(e);\n\t\tvar intDe = null;\n\t\tif (de.getLabel().getLocation(0, Position.RIGHT) === Location.INTERIOR) {\n\t\t\tintDe = de;\n\t\t} else if (de.getSym().getLabel().getLocation(0, Position.RIGHT) === Location.INTERIOR) {\n\t\t\tintDe = de.getSym();\n\t\t}\n\t\tAssert.isTrue(intDe !== null, \"unable to find dirEdge with Interior on RHS\");\n\t\tthis.visitLinkedDirectedEdges(intDe);\n\t},\n\tvisitShellInteriors: function visitShellInteriors(g, graph) {\n\t\tif (g instanceof Polygon) {\n\t\t\tvar p = g;\n\t\t\tthis.visitInteriorRing(p.getExteriorRing(), graph);\n\t\t}\n\t\tif (g instanceof MultiPolygon) {\n\t\t\tvar mp = g;\n\t\t\tfor (var i = 0; i < mp.getNumGeometries(); i++) {\n\t\t\t\tvar p = mp.getGeometryN(i);\n\t\t\t\tthis.visitInteriorRing(p.getExteriorRing(), graph);\n\t\t\t}\n\t\t}\n\t},\n\tgetCoordinate: function getCoordinate() {\n\t\treturn this._disconnectedRingcoord;\n\t},\n\tsetInteriorEdgesInResult: function setInteriorEdgesInResult(graph) {\n\t\tfor (var it = graph.getEdgeEnds().iterator(); it.hasNext();) {\n\t\t\tvar de = it.next();\n\t\t\tif (de.getLabel().getLocation(0, Position.RIGHT) === Location.INTERIOR) {\n\t\t\t\tde.setInResult(true);\n\t\t\t}\n\t\t}\n\t},\n\tvisitLinkedDirectedEdges: function visitLinkedDirectedEdges(start) {\n\t\tvar startDe = start;\n\t\tvar de = start;\n\t\tdo {\n\t\t\tAssert.isTrue(de !== null, \"found null Directed Edge\");\n\t\t\tde.setVisited(true);\n\t\t\tde = de.getNext();\n\t\t} while (de !== startDe);\n\t},\n\tbuildEdgeRings: function buildEdgeRings(dirEdges) {\n\t\tvar edgeRings = new ArrayList();\n\t\tfor (var it = dirEdges.iterator(); it.hasNext();) {\n\t\t\tvar de = it.next();\n\t\t\tif (de.isInResult() && de.getEdgeRing() === null) {\n\t\t\t\tvar er = new MaximalEdgeRing(de, this._geometryFactory);\n\t\t\t\ter.linkDirectedEdgesForMinimalEdgeRings();\n\t\t\t\tvar minEdgeRings = er.buildMinimalRings();\n\t\t\t\tedgeRings.addAll(minEdgeRings);\n\t\t\t}\n\t\t}\n\t\treturn edgeRings;\n\t},\n\thasUnvisitedShellEdge: function hasUnvisitedShellEdge(edgeRings) {\n\t\tfor (var i = 0; i < edgeRings.size(); i++) {\n\t\t\tvar er = edgeRings.get(i);\n\t\t\tif (er.isHole()) continue;\n\t\t\tvar edges = er.getEdges();\n\t\t\tvar de = edges.get(0);\n\t\t\tif (de.getLabel().getLocation(0, Position.RIGHT) !== Location.INTERIOR) continue;\n\t\t\tfor (var j = 0; j < edges.size(); j++) {\n\t\t\t\tde = edges.get(j);\n\t\t\t\tif (!de.isVisited()) {\n\t\t\t\t\tthis._disconnectedRingcoord = de.getCoordinate();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tisInteriorsConnected: function isInteriorsConnected() {\n\t\tvar splitEdges = new ArrayList();\n\t\tthis._geomGraph.computeSplitEdges(splitEdges);\n\t\tvar graph = new PlanarGraph(new OverlayNodeFactory());\n\t\tgraph.addEdges(splitEdges);\n\t\tthis.setInteriorEdgesInResult(graph);\n\t\tgraph.linkResultDirectedEdges();\n\t\tvar edgeRings = this.buildEdgeRings(graph.getEdgeEnds());\n\t\tthis.visitShellInteriors(this._geomGraph.getGeometry(), graph);\n\t\treturn !this.hasUnvisitedShellEdge(edgeRings);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn ConnectedInteriorTester;\n\t}\n});\nConnectedInteriorTester.findDifferentPoint = function (coord, pt) {\n\tfor (var i = 0; i < coord.length; i++) {\n\t\tif (!coord[i].equals(pt)) return coord[i];\n\t}\n\treturn null;\n};\n\nfunction EdgeEndBuilder() {}\nextend(EdgeEndBuilder.prototype, {\n\tcreateEdgeEndForNext: function createEdgeEndForNext(edge, l, eiCurr, eiNext) {\n\t\tvar iNext = eiCurr.segmentIndex + 1;\n\t\tif (iNext >= edge.getNumPoints() && eiNext === null) return null;\n\t\tvar pNext = edge.getCoordinate(iNext);\n\t\tif (eiNext !== null && eiNext.segmentIndex === eiCurr.segmentIndex) pNext = eiNext.coord;\n\t\tvar e = new EdgeEnd(edge, eiCurr.coord, pNext, new Label(edge.getLabel()));\n\t\tl.add(e);\n\t},\n\tcreateEdgeEndForPrev: function createEdgeEndForPrev(edge, l, eiCurr, eiPrev) {\n\t\tvar iPrev = eiCurr.segmentIndex;\n\t\tif (eiCurr.dist === 0.0) {\n\t\t\tif (iPrev === 0) return null;\n\t\t\tiPrev--;\n\t\t}\n\t\tvar pPrev = edge.getCoordinate(iPrev);\n\t\tif (eiPrev !== null && eiPrev.segmentIndex >= iPrev) pPrev = eiPrev.coord;\n\t\tvar label = new Label(edge.getLabel());\n\t\tlabel.flip();\n\t\tvar e = new EdgeEnd(edge, eiCurr.coord, pPrev, label);\n\t\tl.add(e);\n\t},\n\tcomputeEdgeEnds: function computeEdgeEnds() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar edges = arguments[0];\n\t\t\tvar l = new ArrayList();\n\t\t\tfor (var i = edges; i.hasNext();) {\n\t\t\t\tvar e = i.next();\n\t\t\t\tthis.computeEdgeEnds(e, l);\n\t\t\t}\n\t\t\treturn l;\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar edge = arguments[0],\n\t\t\t    l = arguments[1];\n\t\t\tvar eiList = edge.getEdgeIntersectionList();\n\t\t\teiList.addEndpoints();\n\t\t\tvar it = eiList.iterator();\n\t\t\tvar eiPrev = null;\n\t\t\tvar eiCurr = null;\n\t\t\tif (!it.hasNext()) return null;\n\t\t\tvar eiNext = it.next();\n\t\t\tdo {\n\t\t\t\teiPrev = eiCurr;\n\t\t\t\teiCurr = eiNext;\n\t\t\t\teiNext = null;\n\t\t\t\tif (it.hasNext()) eiNext = it.next();\n\t\t\t\tif (eiCurr !== null) {\n\t\t\t\t\tthis.createEdgeEndForPrev(edge, l, eiCurr, eiPrev);\n\t\t\t\t\tthis.createEdgeEndForNext(edge, l, eiCurr, eiNext);\n\t\t\t\t}\n\t\t\t} while (eiCurr !== null);\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn EdgeEndBuilder;\n\t}\n});\n\nfunction EdgeEndBundle() {\n\tthis._edgeEnds = new ArrayList();\n\tif (arguments.length === 1) {\n\t\tvar e = arguments[0];\n\t\tEdgeEndBundle.call(this, null, e);\n\t} else if (arguments.length === 2) {\n\t\tvar boundaryNodeRule = arguments[0],\n\t\t    e = arguments[1];\n\t\tEdgeEnd.call(this, e.getEdge(), e.getCoordinate(), e.getDirectedCoordinate(), new Label(e.getLabel()));\n\t\tthis.insert(e);\n\t}\n}\ninherits$1(EdgeEndBundle, EdgeEnd);\nextend(EdgeEndBundle.prototype, {\n\tinsert: function insert(e) {\n\t\tthis._edgeEnds.add(e);\n\t},\n\tprint: function print(out) {\n\t\tout.println(\"EdgeEndBundle--> Label: \" + this._label);\n\t\tfor (var it = this.iterator(); it.hasNext();) {\n\t\t\tvar ee = it.next();\n\t\t\tee.print(out);\n\t\t\tout.println();\n\t\t}\n\t},\n\titerator: function iterator() {\n\t\treturn this._edgeEnds.iterator();\n\t},\n\tgetEdgeEnds: function getEdgeEnds() {\n\t\treturn this._edgeEnds;\n\t},\n\tcomputeLabelOn: function computeLabelOn(geomIndex, boundaryNodeRule) {\n\t\tvar boundaryCount = 0;\n\t\tvar foundInterior = false;\n\t\tfor (var it = this.iterator(); it.hasNext();) {\n\t\t\tvar e = it.next();\n\t\t\tvar loc = e.getLabel().getLocation(geomIndex);\n\t\t\tif (loc === Location.BOUNDARY) boundaryCount++;\n\t\t\tif (loc === Location.INTERIOR) foundInterior = true;\n\t\t}\n\t\tvar loc = Location.NONE;\n\t\tif (foundInterior) loc = Location.INTERIOR;\n\t\tif (boundaryCount > 0) {\n\t\t\tloc = GeometryGraph.determineBoundary(boundaryNodeRule, boundaryCount);\n\t\t}\n\t\tthis._label.setLocation(geomIndex, loc);\n\t},\n\tcomputeLabelSide: function computeLabelSide(geomIndex, side) {\n\t\tfor (var it = this.iterator(); it.hasNext();) {\n\t\t\tvar e = it.next();\n\t\t\tif (e.getLabel().isArea()) {\n\t\t\t\tvar loc = e.getLabel().getLocation(geomIndex, side);\n\t\t\t\tif (loc === Location.INTERIOR) {\n\t\t\t\t\tthis._label.setLocation(geomIndex, side, Location.INTERIOR);\n\t\t\t\t\treturn null;\n\t\t\t\t} else if (loc === Location.EXTERIOR) this._label.setLocation(geomIndex, side, Location.EXTERIOR);\n\t\t\t}\n\t\t}\n\t},\n\tgetLabel: function getLabel() {\n\t\treturn this._label;\n\t},\n\tcomputeLabelSides: function computeLabelSides(geomIndex) {\n\t\tthis.computeLabelSide(geomIndex, Position.LEFT);\n\t\tthis.computeLabelSide(geomIndex, Position.RIGHT);\n\t},\n\tupdateIM: function updateIM(im) {\n\t\tEdge.updateIM(this._label, im);\n\t},\n\tcomputeLabel: function computeLabel(boundaryNodeRule) {\n\t\tvar isArea = false;\n\t\tfor (var it = this.iterator(); it.hasNext();) {\n\t\t\tvar e = it.next();\n\t\t\tif (e.getLabel().isArea()) isArea = true;\n\t\t}\n\t\tif (isArea) this._label = new Label(Location.NONE, Location.NONE, Location.NONE);else this._label = new Label(Location.NONE);\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tthis.computeLabelOn(i, boundaryNodeRule);\n\t\t\tif (isArea) this.computeLabelSides(i);\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn EdgeEndBundle;\n\t}\n});\n\nfunction EdgeEndBundleStar() {\n\tEdgeEndStar.apply(this);\n}\ninherits$1(EdgeEndBundleStar, EdgeEndStar);\nextend(EdgeEndBundleStar.prototype, {\n\tupdateIM: function updateIM(im) {\n\t\tfor (var it = this.iterator(); it.hasNext();) {\n\t\t\tvar esb = it.next();\n\t\t\tesb.updateIM(im);\n\t\t}\n\t},\n\tinsert: function insert(e) {\n\t\tvar eb = this._edgeMap.get(e);\n\t\tif (eb === null) {\n\t\t\teb = new EdgeEndBundle(e);\n\t\t\tthis.insertEdgeEnd(e, eb);\n\t\t} else {\n\t\t\teb.insert(e);\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn EdgeEndBundleStar;\n\t}\n});\n\nfunction RelateNode() {\n\tvar coord = arguments[0],\n\t    edges = arguments[1];\n\tNode.call(this, coord, edges);\n}\ninherits$1(RelateNode, Node);\nextend(RelateNode.prototype, {\n\tupdateIMFromEdges: function updateIMFromEdges(im) {\n\t\tthis._edges.updateIM(im);\n\t},\n\tcomputeIM: function computeIM(im) {\n\t\tim.setAtLeastIfValid(this._label.getLocation(0), this._label.getLocation(1), 0);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn RelateNode;\n\t}\n});\n\nfunction RelateNodeFactory() {\n\tNodeFactory.apply(this);\n}\ninherits$1(RelateNodeFactory, NodeFactory);\nextend(RelateNodeFactory.prototype, {\n\tcreateNode: function createNode(coord) {\n\t\treturn new RelateNode(coord, new EdgeEndBundleStar());\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn RelateNodeFactory;\n\t}\n});\n\nfunction RelateNodeGraph() {\n\tthis._nodes = new NodeMap(new RelateNodeFactory());\n}\nextend(RelateNodeGraph.prototype, {\n\tinsertEdgeEnds: function insertEdgeEnds(ee) {\n\t\tfor (var i = ee.iterator(); i.hasNext();) {\n\t\t\tvar e = i.next();\n\t\t\tthis._nodes.add(e);\n\t\t}\n\t},\n\tgetNodeIterator: function getNodeIterator() {\n\t\treturn this._nodes.iterator();\n\t},\n\tcopyNodesAndLabels: function copyNodesAndLabels(geomGraph, argIndex) {\n\t\tfor (var nodeIt = geomGraph.getNodeIterator(); nodeIt.hasNext();) {\n\t\t\tvar graphNode = nodeIt.next();\n\t\t\tvar newNode = this._nodes.addNode(graphNode.getCoordinate());\n\t\t\tnewNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));\n\t\t}\n\t},\n\tbuild: function build(geomGraph) {\n\t\tthis.computeIntersectionNodes(geomGraph, 0);\n\t\tthis.copyNodesAndLabels(geomGraph, 0);\n\t\tvar eeBuilder = new EdgeEndBuilder();\n\t\tvar eeList = eeBuilder.computeEdgeEnds(geomGraph.getEdgeIterator());\n\t\tthis.insertEdgeEnds(eeList);\n\t},\n\tcomputeIntersectionNodes: function computeIntersectionNodes(geomGraph, argIndex) {\n\t\tfor (var edgeIt = geomGraph.getEdgeIterator(); edgeIt.hasNext();) {\n\t\t\tvar e = edgeIt.next();\n\t\t\tvar eLoc = e.getLabel().getLocation(argIndex);\n\t\t\tfor (var eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext();) {\n\t\t\t\tvar ei = eiIt.next();\n\t\t\t\tvar n = this._nodes.addNode(ei.coord);\n\t\t\t\tif (eLoc === Location.BOUNDARY) n.setLabelBoundary(argIndex);else {\n\t\t\t\t\tif (n.getLabel().isNull(argIndex)) n.setLabel(argIndex, Location.INTERIOR);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn RelateNodeGraph;\n\t}\n});\n\nfunction ConsistentAreaTester() {\n\tthis._li = new RobustLineIntersector();\n\tthis._geomGraph = null;\n\tthis._nodeGraph = new RelateNodeGraph();\n\tthis._invalidPoint = null;\n\tvar geomGraph = arguments[0];\n\tthis._geomGraph = geomGraph;\n}\nextend(ConsistentAreaTester.prototype, {\n\tisNodeEdgeAreaLabelsConsistent: function isNodeEdgeAreaLabelsConsistent() {\n\t\tfor (var nodeIt = this._nodeGraph.getNodeIterator(); nodeIt.hasNext();) {\n\t\t\tvar node = nodeIt.next();\n\t\t\tif (!node.getEdges().isAreaLabelsConsistent(this._geomGraph)) {\n\t\t\t\tthis._invalidPoint = node.getCoordinate().copy();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t},\n\tgetInvalidPoint: function getInvalidPoint() {\n\t\treturn this._invalidPoint;\n\t},\n\thasDuplicateRings: function hasDuplicateRings() {\n\t\tfor (var nodeIt = this._nodeGraph.getNodeIterator(); nodeIt.hasNext();) {\n\t\t\tvar node = nodeIt.next();\n\t\t\tfor (var i = node.getEdges().iterator(); i.hasNext();) {\n\t\t\t\tvar eeb = i.next();\n\t\t\t\tif (eeb.getEdgeEnds().size() > 1) {\n\t\t\t\t\tthis._invalidPoint = eeb.getEdge().getCoordinate(0);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tisNodeConsistentArea: function isNodeConsistentArea() {\n\t\tvar intersector = this._geomGraph.computeSelfNodes(this._li, true, true);\n\t\tif (intersector.hasProperIntersection()) {\n\t\t\tthis._invalidPoint = intersector.getProperIntersectionPoint();\n\t\t\treturn false;\n\t\t}\n\t\tthis._nodeGraph.build(this._geomGraph);\n\t\treturn this.isNodeEdgeAreaLabelsConsistent();\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn ConsistentAreaTester;\n\t}\n});\n\nfunction IndexedNestedRingTester() {\n\tthis._graph = null;\n\tthis._rings = new ArrayList();\n\tthis._totalEnv = new Envelope();\n\tthis._index = null;\n\tthis._nestedPt = null;\n\tvar graph = arguments[0];\n\tthis._graph = graph;\n}\nextend(IndexedNestedRingTester.prototype, {\n\tbuildIndex: function buildIndex() {\n\t\tthis._index = new STRtree();\n\t\tfor (var i = 0; i < this._rings.size(); i++) {\n\t\t\tvar ring = this._rings.get(i);\n\t\t\tvar env = ring.getEnvelopeInternal();\n\t\t\tthis._index.insert(env, ring);\n\t\t}\n\t},\n\tgetNestedPoint: function getNestedPoint() {\n\t\treturn this._nestedPt;\n\t},\n\tisNonNested: function isNonNested() {\n\t\tthis.buildIndex();\n\t\tfor (var i = 0; i < this._rings.size(); i++) {\n\t\t\tvar innerRing = this._rings.get(i);\n\t\t\tvar innerRingPts = innerRing.getCoordinates();\n\t\t\tvar results = this._index.query(innerRing.getEnvelopeInternal());\n\t\t\tfor (var j = 0; j < results.size(); j++) {\n\t\t\t\tvar searchRing = results.get(j);\n\t\t\t\tvar searchRingPts = searchRing.getCoordinates();\n\t\t\t\tif (innerRing === searchRing) continue;\n\t\t\t\tif (!innerRing.getEnvelopeInternal().intersects(searchRing.getEnvelopeInternal())) continue;\n\t\t\t\tvar innerRingPt = IsValidOp.findPtNotNode(innerRingPts, searchRing, this._graph);\n\t\t\t\tif (innerRingPt === null) continue;\n\t\t\t\tvar isInside = CGAlgorithms.isPointInRing(innerRingPt, searchRingPts);\n\t\t\t\tif (isInside) {\n\t\t\t\t\tthis._nestedPt = innerRingPt;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t},\n\tadd: function add(ring) {\n\t\tthis._rings.add(ring);\n\t\tthis._totalEnv.expandToInclude(ring.getEnvelopeInternal());\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn IndexedNestedRingTester;\n\t}\n});\n\nfunction TopologyValidationError() {\n\tthis._errorType = null;\n\tthis._pt = null;\n\tif (arguments.length === 1) {\n\t\tvar errorType = arguments[0];\n\t\tTopologyValidationError.call(this, errorType, null);\n\t} else if (arguments.length === 2) {\n\t\tvar errorType = arguments[0],\n\t\t    pt = arguments[1];\n\t\tthis._errorType = errorType;\n\t\tif (pt !== null) this._pt = pt.copy();\n\t}\n}\nextend(TopologyValidationError.prototype, {\n\tgetErrorType: function getErrorType() {\n\t\treturn this._errorType;\n\t},\n\tgetMessage: function getMessage() {\n\t\treturn TopologyValidationError.errMsg[this._errorType];\n\t},\n\tgetCoordinate: function getCoordinate() {\n\t\treturn this._pt;\n\t},\n\ttoString: function toString() {\n\t\tvar locStr = \"\";\n\t\tif (this._pt !== null) locStr = \" at or near point \" + this._pt;\n\t\treturn this.getMessage() + locStr;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn TopologyValidationError;\n\t}\n});\nTopologyValidationError.ERROR = 0;\nTopologyValidationError.REPEATED_POINT = 1;\nTopologyValidationError.HOLE_OUTSIDE_SHELL = 2;\nTopologyValidationError.NESTED_HOLES = 3;\nTopologyValidationError.DISCONNECTED_INTERIOR = 4;\nTopologyValidationError.SELF_INTERSECTION = 5;\nTopologyValidationError.RING_SELF_INTERSECTION = 6;\nTopologyValidationError.NESTED_SHELLS = 7;\nTopologyValidationError.DUPLICATE_RINGS = 8;\nTopologyValidationError.TOO_FEW_POINTS = 9;\nTopologyValidationError.INVALID_COORDINATE = 10;\nTopologyValidationError.RING_NOT_CLOSED = 11;\nTopologyValidationError.errMsg = [\"Topology Validation Error\", \"Repeated Point\", \"Hole lies outside shell\", \"Holes are nested\", \"Interior is disconnected\", \"Self-intersection\", \"Ring Self-intersection\", \"Nested shells\", \"Duplicate Rings\", \"Too few distinct points in geometry component\", \"Invalid Coordinate\", \"Ring is not closed\"];\n\nfunction IsValidOp() {\n\tthis._parentGeometry = null;\n\tthis._isSelfTouchingRingFormingHoleValid = false;\n\tthis._validErr = null;\n\tvar parentGeometry = arguments[0];\n\tthis._parentGeometry = parentGeometry;\n}\nextend(IsValidOp.prototype, {\n\tcheckInvalidCoordinates: function checkInvalidCoordinates() {\n\t\tif (arguments[0] instanceof Array) {\n\t\t\tvar coords = arguments[0];\n\t\t\tfor (var i = 0; i < coords.length; i++) {\n\t\t\t\tif (!IsValidOp.isValid(coords[i])) {\n\t\t\t\t\tthis._validErr = new TopologyValidationError(TopologyValidationError.INVALID_COORDINATE, coords[i]);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arguments[0] instanceof Polygon) {\n\t\t\tvar poly = arguments[0];\n\t\t\tthis.checkInvalidCoordinates(poly.getExteriorRing().getCoordinates());\n\t\t\tif (this._validErr !== null) return null;\n\t\t\tfor (var i = 0; i < poly.getNumInteriorRing(); i++) {\n\t\t\t\tthis.checkInvalidCoordinates(poly.getInteriorRingN(i).getCoordinates());\n\t\t\t\tif (this._validErr !== null) return null;\n\t\t\t}\n\t\t}\n\t},\n\tcheckHolesNotNested: function checkHolesNotNested(p, graph) {\n\t\tvar nestedTester = new IndexedNestedRingTester(graph);\n\t\tfor (var i = 0; i < p.getNumInteriorRing(); i++) {\n\t\t\tvar innerHole = p.getInteriorRingN(i);\n\t\t\tnestedTester.add(innerHole);\n\t\t}\n\t\tvar isNonNested = nestedTester.isNonNested();\n\t\tif (!isNonNested) {\n\t\t\tthis._validErr = new TopologyValidationError(TopologyValidationError.NESTED_HOLES, nestedTester.getNestedPoint());\n\t\t}\n\t},\n\tcheckConsistentArea: function checkConsistentArea(graph) {\n\t\tvar cat = new ConsistentAreaTester(graph);\n\t\tvar isValidArea = cat.isNodeConsistentArea();\n\t\tif (!isValidArea) {\n\t\t\tthis._validErr = new TopologyValidationError(TopologyValidationError.SELF_INTERSECTION, cat.getInvalidPoint());\n\t\t\treturn null;\n\t\t}\n\t\tif (cat.hasDuplicateRings()) {\n\t\t\tthis._validErr = new TopologyValidationError(TopologyValidationError.DUPLICATE_RINGS, cat.getInvalidPoint());\n\t\t}\n\t},\n\tisValid: function isValid() {\n\t\tthis.checkValid(this._parentGeometry);\n\t\treturn this._validErr === null;\n\t},\n\tcheckShellInsideHole: function checkShellInsideHole(shell, hole, graph) {\n\t\tvar shellPts = shell.getCoordinates();\n\t\tvar holePts = hole.getCoordinates();\n\t\tvar shellPt = IsValidOp.findPtNotNode(shellPts, hole, graph);\n\t\tif (shellPt !== null) {\n\t\t\tvar insideHole = CGAlgorithms.isPointInRing(shellPt, holePts);\n\t\t\tif (!insideHole) {\n\t\t\t\treturn shellPt;\n\t\t\t}\n\t\t}\n\t\tvar holePt = IsValidOp.findPtNotNode(holePts, shell, graph);\n\t\tif (holePt !== null) {\n\t\t\tvar insideShell = CGAlgorithms.isPointInRing(holePt, shellPts);\n\t\t\tif (insideShell) {\n\t\t\t\treturn holePt;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tAssert.shouldNeverReachHere(\"points in shell and hole appear to be equal\");\n\t\treturn null;\n\t},\n\tcheckNoSelfIntersectingRings: function checkNoSelfIntersectingRings(graph) {\n\t\tfor (var i = graph.getEdgeIterator(); i.hasNext();) {\n\t\t\tvar e = i.next();\n\t\t\tthis.checkNoSelfIntersectingRing(e.getEdgeIntersectionList());\n\t\t\tif (this._validErr !== null) return null;\n\t\t}\n\t},\n\tcheckConnectedInteriors: function checkConnectedInteriors(graph) {\n\t\tvar cit = new ConnectedInteriorTester(graph);\n\t\tif (!cit.isInteriorsConnected()) this._validErr = new TopologyValidationError(TopologyValidationError.DISCONNECTED_INTERIOR, cit.getCoordinate());\n\t},\n\tcheckNoSelfIntersectingRing: function checkNoSelfIntersectingRing(eiList) {\n\t\tvar nodeSet = new TreeSet();\n\t\tvar isFirst = true;\n\t\tfor (var i = eiList.iterator(); i.hasNext();) {\n\t\t\tvar ei = i.next();\n\t\t\tif (isFirst) {\n\t\t\t\tisFirst = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (nodeSet.contains(ei.coord)) {\n\t\t\t\tthis._validErr = new TopologyValidationError(TopologyValidationError.RING_SELF_INTERSECTION, ei.coord);\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\tnodeSet.add(ei.coord);\n\t\t\t}\n\t\t}\n\t},\n\tcheckHolesInShell: function checkHolesInShell(p, graph) {\n\t\tvar shell = p.getExteriorRing();\n\t\tvar pir = new MCPointInRing(shell);\n\t\tfor (var i = 0; i < p.getNumInteriorRing(); i++) {\n\t\t\tvar hole = p.getInteriorRingN(i);\n\t\t\tvar holePt = IsValidOp.findPtNotNode(hole.getCoordinates(), shell, graph);\n\t\t\tif (holePt === null) return null;\n\t\t\tvar outside = !pir.isInside(holePt);\n\t\t\tif (outside) {\n\t\t\t\tthis._validErr = new TopologyValidationError(TopologyValidationError.HOLE_OUTSIDE_SHELL, holePt);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t},\n\tcheckTooFewPoints: function checkTooFewPoints(graph) {\n\t\tif (graph.hasTooFewPoints()) {\n\t\t\tthis._validErr = new TopologyValidationError(TopologyValidationError.TOO_FEW_POINTS, graph.getInvalidPoint());\n\t\t\treturn null;\n\t\t}\n\t},\n\tgetValidationError: function getValidationError() {\n\t\tthis.checkValid(this._parentGeometry);\n\t\treturn this._validErr;\n\t},\n\tcheckValid: function checkValid() {\n\t\tif (arguments[0] instanceof Point) {\n\t\t\tvar g = arguments[0];\n\t\t\tthis.checkInvalidCoordinates(g.getCoordinates());\n\t\t} else if (arguments[0] instanceof MultiPoint) {\n\t\t\tvar g = arguments[0];\n\t\t\tthis.checkInvalidCoordinates(g.getCoordinates());\n\t\t} else if (arguments[0] instanceof LinearRing) {\n\t\t\tvar g = arguments[0];\n\t\t\tthis.checkInvalidCoordinates(g.getCoordinates());\n\t\t\tif (this._validErr !== null) return null;\n\t\t\tthis.checkClosedRing(g);\n\t\t\tif (this._validErr !== null) return null;\n\t\t\tvar graph = new GeometryGraph(0, g);\n\t\t\tthis.checkTooFewPoints(graph);\n\t\t\tif (this._validErr !== null) return null;\n\t\t\tvar li = new RobustLineIntersector();\n\t\t\tgraph.computeSelfNodes(li, true, true);\n\t\t\tthis.checkNoSelfIntersectingRings(graph);\n\t\t} else if (arguments[0] instanceof LineString) {\n\t\t\tvar g = arguments[0];\n\t\t\tthis.checkInvalidCoordinates(g.getCoordinates());\n\t\t\tif (this._validErr !== null) return null;\n\t\t\tvar graph = new GeometryGraph(0, g);\n\t\t\tthis.checkTooFewPoints(graph);\n\t\t} else if (arguments[0] instanceof Polygon) {\n\t\t\tvar g = arguments[0];\n\t\t\tthis.checkInvalidCoordinates(g);\n\t\t\tif (this._validErr !== null) return null;\n\t\t\tthis.checkClosedRings(g);\n\t\t\tif (this._validErr !== null) return null;\n\t\t\tvar graph = new GeometryGraph(0, g);\n\t\t\tthis.checkTooFewPoints(graph);\n\t\t\tif (this._validErr !== null) return null;\n\t\t\tthis.checkConsistentArea(graph);\n\t\t\tif (this._validErr !== null) return null;\n\t\t\tif (!this._isSelfTouchingRingFormingHoleValid) {\n\t\t\t\tthis.checkNoSelfIntersectingRings(graph);\n\t\t\t\tif (this._validErr !== null) return null;\n\t\t\t}\n\t\t\tthis.checkHolesInShell(g, graph);\n\t\t\tif (this._validErr !== null) return null;\n\t\t\tthis.checkHolesNotNested(g, graph);\n\t\t\tif (this._validErr !== null) return null;\n\t\t\tthis.checkConnectedInteriors(graph);\n\t\t} else if (arguments[0] instanceof MultiPolygon) {\n\t\t\tvar g = arguments[0];\n\t\t\tfor (var i = 0; i < g.getNumGeometries(); i++) {\n\t\t\t\tvar p = g.getGeometryN(i);\n\t\t\t\tthis.checkInvalidCoordinates(p);\n\t\t\t\tif (this._validErr !== null) return null;\n\t\t\t\tthis.checkClosedRings(p);\n\t\t\t\tif (this._validErr !== null) return null;\n\t\t\t}\n\t\t\tvar graph = new GeometryGraph(0, g);\n\t\t\tthis.checkTooFewPoints(graph);\n\t\t\tif (this._validErr !== null) return null;\n\t\t\tthis.checkConsistentArea(graph);\n\t\t\tif (this._validErr !== null) return null;\n\t\t\tif (!this._isSelfTouchingRingFormingHoleValid) {\n\t\t\t\tthis.checkNoSelfIntersectingRings(graph);\n\t\t\t\tif (this._validErr !== null) return null;\n\t\t\t}\n\t\t\tfor (var i = 0; i < g.getNumGeometries(); i++) {\n\t\t\t\tvar p = g.getGeometryN(i);\n\t\t\t\tthis.checkHolesInShell(p, graph);\n\t\t\t\tif (this._validErr !== null) return null;\n\t\t\t}\n\t\t\tfor (var i = 0; i < g.getNumGeometries(); i++) {\n\t\t\t\tvar p = g.getGeometryN(i);\n\t\t\t\tthis.checkHolesNotNested(p, graph);\n\t\t\t\tif (this._validErr !== null) return null;\n\t\t\t}\n\t\t\tthis.checkShellsNotNested(g, graph);\n\t\t\tif (this._validErr !== null) return null;\n\t\t\tthis.checkConnectedInteriors(graph);\n\t\t} else if (arguments[0] instanceof GeometryCollection) {\n\t\t\tvar gc = arguments[0];\n\t\t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n\t\t\t\tvar g = gc.getGeometryN(i);\n\t\t\t\tthis.checkValid(g);\n\t\t\t\tif (this._validErr !== null) return null;\n\t\t\t}\n\t\t} else if (arguments[0] instanceof Geometry) {\n\t\t\tvar g = arguments[0];\n\t\t\tthis._validErr = null;\n\t\t\tif (g.isEmpty()) return null;\n\t\t\tif (g instanceof Point) this.checkValid(g);else if (g instanceof MultiPoint) this.checkValid(g);else if (g instanceof LinearRing) this.checkValid(g);else if (g instanceof LineString) this.checkValid(g);else if (g instanceof Polygon) this.checkValid(g);else if (g instanceof MultiPolygon) this.checkValid(g);else if (g instanceof GeometryCollection) this.checkValid(g);else throw new UnsupportedOperationException(g.getClass().getName());\n\t\t}\n\t},\n\tsetSelfTouchingRingFormingHoleValid: function setSelfTouchingRingFormingHoleValid(isValid) {\n\t\tthis._isSelfTouchingRingFormingHoleValid = isValid;\n\t},\n\tcheckShellNotNested: function checkShellNotNested(shell, p, graph) {\n\t\tvar shellPts = shell.getCoordinates();\n\t\tvar polyShell = p.getExteriorRing();\n\t\tvar polyPts = polyShell.getCoordinates();\n\t\tvar shellPt = IsValidOp.findPtNotNode(shellPts, polyShell, graph);\n\t\tif (shellPt === null) return null;\n\t\tvar insidePolyShell = CGAlgorithms.isPointInRing(shellPt, polyPts);\n\t\tif (!insidePolyShell) return null;\n\t\tif (p.getNumInteriorRing() <= 0) {\n\t\t\tthis._validErr = new TopologyValidationError(TopologyValidationError.NESTED_SHELLS, shellPt);\n\t\t\treturn null;\n\t\t}\n\t\tvar badNestedPt = null;\n\t\tfor (var i = 0; i < p.getNumInteriorRing(); i++) {\n\t\t\tvar hole = p.getInteriorRingN(i);\n\t\t\tbadNestedPt = this.checkShellInsideHole(shell, hole, graph);\n\t\t\tif (badNestedPt === null) return null;\n\t\t}\n\t\tthis._validErr = new TopologyValidationError(TopologyValidationError.NESTED_SHELLS, badNestedPt);\n\t},\n\tcheckClosedRings: function checkClosedRings(poly) {\n\t\tthis.checkClosedRing(poly.getExteriorRing());\n\t\tif (this._validErr !== null) return null;\n\t\tfor (var i = 0; i < poly.getNumInteriorRing(); i++) {\n\t\t\tthis.checkClosedRing(poly.getInteriorRingN(i));\n\t\t\tif (this._validErr !== null) return null;\n\t\t}\n\t},\n\tcheckClosedRing: function checkClosedRing(ring) {\n\t\tif (!ring.isClosed()) {\n\t\t\tvar pt = null;\n\t\t\tif (ring.getNumPoints() >= 1) pt = ring.getCoordinateN(0);\n\t\t\tthis._validErr = new TopologyValidationError(TopologyValidationError.RING_NOT_CLOSED, pt);\n\t\t}\n\t},\n\tcheckShellsNotNested: function checkShellsNotNested(mp, graph) {\n\t\tfor (var i = 0; i < mp.getNumGeometries(); i++) {\n\t\t\tvar p = mp.getGeometryN(i);\n\t\t\tvar shell = p.getExteriorRing();\n\t\t\tfor (var j = 0; j < mp.getNumGeometries(); j++) {\n\t\t\t\tif (i === j) continue;\n\t\t\t\tvar p2 = mp.getGeometryN(j);\n\t\t\t\tthis.checkShellNotNested(shell, p2, graph);\n\t\t\t\tif (this._validErr !== null) return null;\n\t\t\t}\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn IsValidOp;\n\t}\n});\nIsValidOp.findPtNotNode = function (testCoords, searchRing, graph) {\n\tvar searchEdge = graph.findEdge(searchRing);\n\tvar eiList = searchEdge.getEdgeIntersectionList();\n\tfor (var i = 0; i < testCoords.length; i++) {\n\t\tvar pt = testCoords[i];\n\t\tif (!eiList.isIntersection(pt)) return pt;\n\t}\n\treturn null;\n};\nIsValidOp.isValid = function () {\n\tif (arguments[0] instanceof Geometry) {\n\t\tvar geom = arguments[0];\n\t\tvar isValidOp = new IsValidOp(geom);\n\t\treturn isValidOp.isValid();\n\t} else if (arguments[0] instanceof Coordinate) {\n\t\tvar coord = arguments[0];\n\t\tif (Double.isNaN(coord.x)) return false;\n\t\tif (Double.isInfinite(coord.x)) return false;\n\t\tif (Double.isNaN(coord.y)) return false;\n\t\tif (Double.isInfinite(coord.y)) return false;\n\t\treturn true;\n\t}\n};\n\nfunction EdgeRing$1() {\n\tthis._factory = null;\n\tthis._deList = new ArrayList();\n\tthis._lowestEdge = null;\n\tthis._ring = null;\n\tthis._ringPts = null;\n\tthis._holes = null;\n\tthis._shell = null;\n\tthis._isHole = null;\n\tthis._isProcessed = false;\n\tthis._isIncludedSet = false;\n\tthis._isIncluded = false;\n\tvar factory = arguments[0];\n\tthis._factory = factory;\n}\nextend(EdgeRing$1.prototype, {\n\tisIncluded: function isIncluded() {\n\t\treturn this._isIncluded;\n\t},\n\tgetCoordinates: function getCoordinates() {\n\t\tif (this._ringPts === null) {\n\t\t\tvar coordList = new CoordinateList();\n\t\t\tfor (var i = this._deList.iterator(); i.hasNext();) {\n\t\t\t\tvar de = i.next();\n\t\t\t\tvar edge = de.getEdge();\n\t\t\t\tEdgeRing$1.addEdge(edge.getLine().getCoordinates(), de.getEdgeDirection(), coordList);\n\t\t\t}\n\t\t\tthis._ringPts = coordList.toCoordinateArray();\n\t\t}\n\t\treturn this._ringPts;\n\t},\n\tisIncludedSet: function isIncludedSet() {\n\t\treturn this._isIncludedSet;\n\t},\n\tisValid: function isValid() {\n\t\tthis.getCoordinates();\n\t\tif (this._ringPts.length <= 3) return false;\n\t\tthis.getRing();\n\t\treturn IsValidOp.isValid(this._ring);\n\t},\n\tbuild: function build(startDE) {\n\t\tvar de = startDE;\n\t\tdo {\n\t\t\tthis.add(de);\n\t\t\tde.setRing(this);\n\t\t\tde = de.getNext();\n\t\t\tAssert.isTrue(de !== null, \"found null DE in ring\");\n\t\t\tAssert.isTrue(de === startDE || !de.isInRing(), \"found DE already in ring\");\n\t\t} while (de !== startDE);\n\t},\n\tisOuterHole: function isOuterHole() {\n\t\tif (!this._isHole) return false;\n\t\treturn !this.hasShell();\n\t},\n\tgetPolygon: function getPolygon() {\n\t\tvar holeLR = null;\n\t\tif (this._holes !== null) {\n\t\t\tholeLR = new Array(this._holes.size()).fill(null);\n\t\t\tfor (var i = 0; i < this._holes.size(); i++) {\n\t\t\t\tholeLR[i] = this._holes.get(i);\n\t\t\t}\n\t\t}\n\t\tvar poly = this._factory.createPolygon(this._ring, holeLR);\n\t\treturn poly;\n\t},\n\tisHole: function isHole() {\n\t\treturn this._isHole;\n\t},\n\tisProcessed: function isProcessed() {\n\t\treturn this._isProcessed;\n\t},\n\taddHole: function addHole() {\n\t\tif (arguments[0] instanceof LinearRing) {\n\t\t\tvar hole = arguments[0];\n\t\t\tif (this._holes === null) this._holes = new ArrayList();\n\t\t\tthis._holes.add(hole);\n\t\t} else if (arguments[0] instanceof EdgeRing$1) {\n\t\t\tvar holeER = arguments[0];\n\t\t\tholeER.setShell(this);\n\t\t\tvar hole = holeER.getRing();\n\t\t\tif (this._holes === null) this._holes = new ArrayList();\n\t\t\tthis._holes.add(hole);\n\t\t}\n\t},\n\tsetIncluded: function setIncluded(isIncluded) {\n\t\tthis._isIncluded = isIncluded;\n\t\tthis._isIncludedSet = true;\n\t},\n\tgetOuterHole: function getOuterHole() {\n\t\tif (this.isHole()) return null;\n\t\tfor (var i = 0; i < this._deList.size(); i++) {\n\t\t\tvar de = this._deList.get(i);\n\t\t\tvar adjRing = de.getSym().getRing();\n\t\t\tif (adjRing.isOuterHole()) return adjRing;\n\t\t}\n\t\treturn null;\n\t},\n\tcomputeHole: function computeHole() {\n\t\tvar ring = this.getRing();\n\t\tthis._isHole = CGAlgorithms.isCCW(ring.getCoordinates());\n\t},\n\thasShell: function hasShell() {\n\t\treturn this._shell !== null;\n\t},\n\tisOuterShell: function isOuterShell() {\n\t\treturn this.getOuterHole() !== null;\n\t},\n\tgetLineString: function getLineString() {\n\t\tthis.getCoordinates();\n\t\treturn this._factory.createLineString(this._ringPts);\n\t},\n\ttoString: function toString() {\n\t\treturn WKTWriter.toLineString(new CoordinateArraySequence(this.getCoordinates()));\n\t},\n\tgetShell: function getShell() {\n\t\tif (this.isHole()) return this._shell;\n\t\treturn this;\n\t},\n\tadd: function add(de) {\n\t\tthis._deList.add(de);\n\t},\n\tgetRing: function getRing() {\n\t\tif (this._ring !== null) return this._ring;\n\t\tthis.getCoordinates();\n\t\tif (this._ringPts.length < 3) System.out.println(this._ringPts);\n\t\ttry {\n\t\t\tthis._ring = this._factory.createLinearRing(this._ringPts);\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof Exception) {\n\t\t\t\tSystem.out.println(this._ringPts);\n\t\t\t} else throw ex;\n\t\t} finally {}\n\t\treturn this._ring;\n\t},\n\tupdateIncluded: function updateIncluded() {\n\t\tif (this.isHole()) return null;\n\t\tfor (var i = 0; i < this._deList.size(); i++) {\n\t\t\tvar de = this._deList.get(i);\n\t\t\tvar adjShell = de.getSym().getRing().getShell();\n\t\t\tif (adjShell !== null && adjShell.isIncludedSet()) {\n\t\t\t\tthis.setIncluded(!adjShell.isIncluded());\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t},\n\tsetShell: function setShell(shell) {\n\t\tthis._shell = shell;\n\t},\n\tsetProcessed: function setProcessed(isProcessed) {\n\t\tthis._isProcessed = isProcessed;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn EdgeRing$1;\n\t}\n});\nEdgeRing$1.findDirEdgesInRing = function (startDE) {\n\tvar de = startDE;\n\tvar edges = new ArrayList();\n\tdo {\n\t\tedges.add(de);\n\t\tde = de.getNext();\n\t\tAssert.isTrue(de !== null, \"found null DE in ring\");\n\t\tAssert.isTrue(de === startDE || !de.isInRing(), \"found DE already in ring\");\n\t} while (de !== startDE);\n\treturn edges;\n};\nEdgeRing$1.addEdge = function (coords, isForward, coordList) {\n\tif (isForward) {\n\t\tfor (var i = 0; i < coords.length; i++) {\n\t\t\tcoordList.add(coords[i], false);\n\t\t}\n\t} else {\n\t\tfor (var i = coords.length - 1; i >= 0; i--) {\n\t\t\tcoordList.add(coords[i], false);\n\t\t}\n\t}\n};\nEdgeRing$1.findEdgeRingContaining = function (testEr, shellList) {\n\tvar testRing = testEr.getRing();\n\tvar testEnv = testRing.getEnvelopeInternal();\n\tvar testPt = testRing.getCoordinateN(0);\n\tvar minShell = null;\n\tvar minShellEnv = null;\n\tfor (var it = shellList.iterator(); it.hasNext();) {\n\t\tvar tryShell = it.next();\n\t\tvar tryShellRing = tryShell.getRing();\n\t\tvar tryShellEnv = tryShellRing.getEnvelopeInternal();\n\t\tif (tryShellEnv.equals(testEnv)) continue;\n\t\tif (!tryShellEnv.contains(testEnv)) continue;\n\t\ttestPt = CoordinateArrays.ptNotInList(testRing.getCoordinates(), tryShellRing.getCoordinates());\n\t\tvar isContained = false;\n\t\tif (CGAlgorithms.isPointInRing(testPt, tryShellRing.getCoordinates())) isContained = true;\n\t\tif (isContained) {\n\t\t\tif (minShell === null || minShellEnv.contains(tryShellEnv)) {\n\t\t\t\tminShell = tryShell;\n\t\t\t\tminShellEnv = minShell.getRing().getEnvelopeInternal();\n\t\t\t}\n\t\t}\n\t}\n\treturn minShell;\n};\nfunction EnvelopeComparator() {}\nextend(EnvelopeComparator.prototype, {\n\tcompare: function compare(obj0, obj1) {\n\t\tvar r0 = obj0;\n\t\tvar r1 = obj1;\n\t\treturn r0.getRing().getEnvelope().compareTo(r1.getRing().getEnvelope());\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Comparator];\n\t},\n\tgetClass: function getClass() {\n\t\treturn EnvelopeComparator;\n\t}\n});\nEdgeRing$1.EnvelopeComparator = EnvelopeComparator;\n\nfunction PolygonizeGraph() {\n\tPlanarGraph$1.apply(this);\n\tthis._factory = null;\n\tvar factory = arguments[0];\n\tthis._factory = factory;\n}\ninherits$1(PolygonizeGraph, PlanarGraph$1);\nextend(PolygonizeGraph.prototype, {\n\tfindEdgeRing: function findEdgeRing(startDE) {\n\t\tvar er = new EdgeRing$1(this._factory);\n\t\ter.build(startDE);\n\t\treturn er;\n\t},\n\tcomputeDepthParity: function computeDepthParity() {\n\t\tif (arguments.length === 0) {\n\t\t\twhile (true) {\n\t\t\t\tvar de = null;\n\t\t\t\tif (de === null) return null;\n\t\t\t\tthis.computeDepthParity(de);\n\t\t\t}\n\t\t} else if (arguments.length === 1) {\n\t\t\tvar de = arguments[0];\n\t\t}\n\t},\n\tcomputeNextCWEdges: function computeNextCWEdges() {\n\t\tfor (var iNode = this.nodeIterator(); iNode.hasNext();) {\n\t\t\tvar node = iNode.next();\n\t\t\tPolygonizeGraph.computeNextCWEdges(node);\n\t\t}\n\t},\n\taddEdge: function addEdge(line) {\n\t\tif (line.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\t\tvar linePts = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());\n\t\tif (linePts.length < 2) {\n\t\t\treturn null;\n\t\t}\n\t\tvar startPt = linePts[0];\n\t\tvar endPt = linePts[linePts.length - 1];\n\t\tvar nStart = this.getNode(startPt);\n\t\tvar nEnd = this.getNode(endPt);\n\t\tvar de0 = new PolygonizeDirectedEdge(nStart, nEnd, linePts[1], true);\n\t\tvar de1 = new PolygonizeDirectedEdge(nEnd, nStart, linePts[linePts.length - 2], false);\n\t\tvar edge = new PolygonizeEdge(line);\n\t\tedge.setDirectedEdges(de0, de1);\n\t\tthis.add(edge);\n\t},\n\tdeleteCutEdges: function deleteCutEdges() {\n\t\tthis.computeNextCWEdges();\n\t\tPolygonizeGraph.findLabeledEdgeRings(this._dirEdges);\n\t\tvar cutLines = new ArrayList();\n\t\tfor (var i = this._dirEdges.iterator(); i.hasNext();) {\n\t\t\tvar de = i.next();\n\t\t\tif (de.isMarked()) continue;\n\t\t\tvar sym = de.getSym();\n\t\t\tif (de.getLabel() === sym.getLabel()) {\n\t\t\t\tde.setMarked(true);\n\t\t\t\tsym.setMarked(true);\n\t\t\t\tvar e = de.getEdge();\n\t\t\t\tcutLines.add(e.getLine());\n\t\t\t}\n\t\t}\n\t\treturn cutLines;\n\t},\n\tgetEdgeRings: function getEdgeRings() {\n\t\tthis.computeNextCWEdges();\n\t\tPolygonizeGraph.label(this._dirEdges, -1);\n\t\tvar maximalRings = PolygonizeGraph.findLabeledEdgeRings(this._dirEdges);\n\t\tthis.convertMaximalToMinimalEdgeRings(maximalRings);\n\t\tvar edgeRingList = new ArrayList();\n\t\tfor (var i = this._dirEdges.iterator(); i.hasNext();) {\n\t\t\tvar de = i.next();\n\t\t\tif (de.isMarked()) continue;\n\t\t\tif (de.isInRing()) continue;\n\t\t\tvar er = this.findEdgeRing(de);\n\t\t\tedgeRingList.add(er);\n\t\t}\n\t\treturn edgeRingList;\n\t},\n\tgetNode: function getNode(pt) {\n\t\tvar node = this.findNode(pt);\n\t\tif (node === null) {\n\t\t\tnode = new Node$3(pt);\n\t\t\tthis.add(node);\n\t\t}\n\t\treturn node;\n\t},\n\tconvertMaximalToMinimalEdgeRings: function convertMaximalToMinimalEdgeRings(ringEdges) {\n\t\tfor (var i = ringEdges.iterator(); i.hasNext();) {\n\t\t\tvar de = i.next();\n\t\t\tvar label = de.getLabel();\n\t\t\tvar intNodes = PolygonizeGraph.findIntersectionNodes(de, label);\n\t\t\tif (intNodes === null) continue;\n\t\t\tfor (var iNode = intNodes.iterator(); iNode.hasNext();) {\n\t\t\t\tvar node = iNode.next();\n\t\t\t\tPolygonizeGraph.computeNextCCWEdges(node, label);\n\t\t\t}\n\t\t}\n\t},\n\tdeleteDangles: function deleteDangles() {\n\t\tvar nodesToRemove = this.findNodesOfDegree(1);\n\t\tvar dangleLines = new HashSet();\n\t\tvar nodeStack = new Stack$2();\n\t\tfor (var i = nodesToRemove.iterator(); i.hasNext();) {\n\t\t\tnodeStack.push(i.next());\n\t\t}\n\t\twhile (!nodeStack.isEmpty()) {\n\t\t\tvar node = nodeStack.pop();\n\t\t\tPolygonizeGraph.deleteAllEdges(node);\n\t\t\tvar nodeOutEdges = node.getOutEdges().getEdges();\n\t\t\tfor (var i = nodeOutEdges.iterator(); i.hasNext();) {\n\t\t\t\tvar de = i.next();\n\t\t\t\tde.setMarked(true);\n\t\t\t\tvar sym = de.getSym();\n\t\t\t\tif (sym !== null) sym.setMarked(true);\n\t\t\t\tvar e = de.getEdge();\n\t\t\t\tdangleLines.add(e.getLine());\n\t\t\t\tvar toNode = de.getToNode();\n\t\t\t\tif (PolygonizeGraph.getDegreeNonDeleted(toNode) === 1) nodeStack.push(toNode);\n\t\t\t}\n\t\t}\n\t\treturn dangleLines;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn PolygonizeGraph;\n\t}\n});\nPolygonizeGraph.findLabeledEdgeRings = function (dirEdges) {\n\tvar edgeRingStarts = new ArrayList();\n\tvar currLabel = 1;\n\tfor (var i = dirEdges.iterator(); i.hasNext();) {\n\t\tvar de = i.next();\n\t\tif (de.isMarked()) continue;\n\t\tif (de.getLabel() >= 0) continue;\n\t\tedgeRingStarts.add(de);\n\t\tvar edges = EdgeRing$1.findDirEdgesInRing(de);\n\t\tPolygonizeGraph.label(edges, currLabel);\n\t\tcurrLabel++;\n\t}\n\treturn edgeRingStarts;\n};\nPolygonizeGraph.getDegreeNonDeleted = function (node) {\n\tvar edges = node.getOutEdges().getEdges();\n\tvar degree = 0;\n\tfor (var i = edges.iterator(); i.hasNext();) {\n\t\tvar de = i.next();\n\t\tif (!de.isMarked()) degree++;\n\t}\n\treturn degree;\n};\nPolygonizeGraph.deleteAllEdges = function (node) {\n\tvar edges = node.getOutEdges().getEdges();\n\tfor (var i = edges.iterator(); i.hasNext();) {\n\t\tvar de = i.next();\n\t\tde.setMarked(true);\n\t\tvar sym = de.getSym();\n\t\tif (sym !== null) sym.setMarked(true);\n\t}\n};\nPolygonizeGraph.label = function (dirEdges, label) {\n\tfor (var i = dirEdges.iterator(); i.hasNext();) {\n\t\tvar de = i.next();\n\t\tde.setLabel(label);\n\t}\n};\nPolygonizeGraph.computeNextCWEdges = function (node) {\n\tvar deStar = node.getOutEdges();\n\tvar startDE = null;\n\tvar prevDE = null;\n\tfor (var i = deStar.getEdges().iterator(); i.hasNext();) {\n\t\tvar outDE = i.next();\n\t\tif (outDE.isMarked()) continue;\n\t\tif (startDE === null) startDE = outDE;\n\t\tif (prevDE !== null) {\n\t\t\tvar sym = prevDE.getSym();\n\t\t\tsym.setNext(outDE);\n\t\t}\n\t\tprevDE = outDE;\n\t}\n\tif (prevDE !== null) {\n\t\tvar sym = prevDE.getSym();\n\t\tsym.setNext(startDE);\n\t}\n};\nPolygonizeGraph.computeNextCCWEdges = function (node, label) {\n\tvar deStar = node.getOutEdges();\n\tvar firstOutDE = null;\n\tvar prevInDE = null;\n\tvar edges = deStar.getEdges();\n\tfor (var i = edges.size() - 1; i >= 0; i--) {\n\t\tvar de = edges.get(i);\n\t\tvar sym = de.getSym();\n\t\tvar outDE = null;\n\t\tif (de.getLabel() === label) outDE = de;\n\t\tvar inDE = null;\n\t\tif (sym.getLabel() === label) inDE = sym;\n\t\tif (outDE === null && inDE === null) continue;\n\t\tif (inDE !== null) {\n\t\t\tprevInDE = inDE;\n\t\t}\n\t\tif (outDE !== null) {\n\t\t\tif (prevInDE !== null) {\n\t\t\t\tprevInDE.setNext(outDE);\n\t\t\t\tprevInDE = null;\n\t\t\t}\n\t\t\tif (firstOutDE === null) firstOutDE = outDE;\n\t\t}\n\t}\n\tif (prevInDE !== null) {\n\t\tAssert.isTrue(firstOutDE !== null);\n\t\tprevInDE.setNext(firstOutDE);\n\t}\n};\nPolygonizeGraph.getDegree = function (node, label) {\n\tvar edges = node.getOutEdges().getEdges();\n\tvar degree = 0;\n\tfor (var i = edges.iterator(); i.hasNext();) {\n\t\tvar de = i.next();\n\t\tif (de.getLabel() === label) degree++;\n\t}\n\treturn degree;\n};\nPolygonizeGraph.findIntersectionNodes = function (startDE, label) {\n\tvar de = startDE;\n\tvar intNodes = null;\n\tdo {\n\t\tvar node = de.getFromNode();\n\t\tif (PolygonizeGraph.getDegree(node, label) > 1) {\n\t\t\tif (intNodes === null) intNodes = new ArrayList();\n\t\t\tintNodes.add(node);\n\t\t}\n\t\tde = de.getNext();\n\t\tAssert.isTrue(de !== null, \"found null DE in ring\");\n\t\tAssert.isTrue(de === startDE || !de.isInRing(), \"found DE already in ring\");\n\t} while (de !== startDE);\n\treturn intNodes;\n};\n\nfunction Polygonizer() {\n\tthis._lineStringAdder = new LineStringAdder(this);\n\tthis._graph = null;\n\tthis._dangles = new ArrayList();\n\tthis._cutEdges = new ArrayList();\n\tthis._invalidRingLines = new ArrayList();\n\tthis._holeList = null;\n\tthis._shellList = null;\n\tthis._polyList = null;\n\tthis._isCheckingRingsValid = true;\n\tthis._extractOnlyPolygonal = null;\n\tthis._geomFactory = null;\n\tif (arguments.length === 0) {\n\t\tPolygonizer.call(this, false);\n\t} else if (arguments.length === 1) {\n\t\tvar extractOnlyPolygonal = arguments[0];\n\t\tthis._extractOnlyPolygonal = extractOnlyPolygonal;\n\t}\n}\nextend(Polygonizer.prototype, {\n\tgetGeometry: function getGeometry() {\n\t\tif (this._geomFactory === null) this._geomFactory = new GeometryFactory();\n\t\tthis.polygonize();\n\t\tif (this._extractOnlyPolygonal) {\n\t\t\treturn this._geomFactory.buildGeometry(this._polyList);\n\t\t}\n\t\treturn this._geomFactory.createGeometryCollection(GeometryFactory.toGeometryArray(this._polyList));\n\t},\n\tgetInvalidRingLines: function getInvalidRingLines() {\n\t\tthis.polygonize();\n\t\treturn this._invalidRingLines;\n\t},\n\tfindValidRings: function findValidRings(edgeRingList, validEdgeRingList, invalidRingList) {\n\t\tfor (var i = edgeRingList.iterator(); i.hasNext();) {\n\t\t\tvar er = i.next();\n\t\t\tif (er.isValid()) validEdgeRingList.add(er);else invalidRingList.add(er.getLineString());\n\t\t}\n\t},\n\tpolygonize: function polygonize() {\n\t\tif (this._polyList !== null) return null;\n\t\tthis._polyList = new ArrayList();\n\t\tif (this._graph === null) return null;\n\t\tthis._dangles = this._graph.deleteDangles();\n\t\tthis._cutEdges = this._graph.deleteCutEdges();\n\t\tvar edgeRingList = this._graph.getEdgeRings();\n\t\tvar validEdgeRingList = new ArrayList();\n\t\tthis._invalidRingLines = new ArrayList();\n\t\tif (this._isCheckingRingsValid) {\n\t\t\tthis.findValidRings(edgeRingList, validEdgeRingList, this._invalidRingLines);\n\t\t} else {\n\t\t\tvalidEdgeRingList = edgeRingList;\n\t\t}\n\t\tthis.findShellsAndHoles(validEdgeRingList);\n\t\tPolygonizer.assignHolesToShells(this._holeList, this._shellList);\n\t\tCollections.sort(this._shellList, new EdgeRing$1.EnvelopeComparator());\n\t\tvar includeAll = true;\n\t\tif (this._extractOnlyPolygonal) {\n\t\t\tPolygonizer.findDisjointShells(this._shellList);\n\t\t\tincludeAll = false;\n\t\t}\n\t\tthis._polyList = Polygonizer.extractPolygons(this._shellList, includeAll);\n\t},\n\tgetDangles: function getDangles() {\n\t\tthis.polygonize();\n\t\treturn this._dangles;\n\t},\n\tgetCutEdges: function getCutEdges() {\n\t\tthis.polygonize();\n\t\treturn this._cutEdges;\n\t},\n\tgetPolygons: function getPolygons() {\n\t\tthis.polygonize();\n\t\treturn this._polyList;\n\t},\n\tadd: function add() {\n\t\tif (hasInterface(arguments[0], Collection)) {\n\t\t\tvar geomList = arguments[0];\n\t\t\tfor (var i = geomList.iterator(); i.hasNext();) {\n\t\t\t\tvar geometry = i.next();\n\t\t\t\tthis.add(geometry);\n\t\t\t}\n\t\t} else if (arguments[0] instanceof LineString) {\n\t\t\tvar line = arguments[0];\n\t\t\tthis._geomFactory = line.getFactory();\n\t\t\tif (this._graph === null) this._graph = new PolygonizeGraph(this._geomFactory);\n\t\t\tthis._graph.addEdge(line);\n\t\t} else if (arguments[0] instanceof Geometry) {\n\t\t\tvar g = arguments[0];\n\t\t\tg.apply(this._lineStringAdder);\n\t\t}\n\t},\n\tsetCheckRingsValid: function setCheckRingsValid(isCheckingRingsValid) {\n\t\tthis._isCheckingRingsValid = isCheckingRingsValid;\n\t},\n\tfindShellsAndHoles: function findShellsAndHoles(edgeRingList) {\n\t\tthis._holeList = new ArrayList();\n\t\tthis._shellList = new ArrayList();\n\t\tfor (var i = edgeRingList.iterator(); i.hasNext();) {\n\t\t\tvar er = i.next();\n\t\t\ter.computeHole();\n\t\t\tif (er.isHole()) this._holeList.add(er);else this._shellList.add(er);\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Polygonizer;\n\t}\n});\nPolygonizer.findOuterShells = function (shellList) {\n\tfor (var i = shellList.iterator(); i.hasNext();) {\n\t\tvar er = i.next();\n\t\tvar outerHoleER = er.getOuterHole();\n\t\tif (outerHoleER !== null && !outerHoleER.isProcessed()) {\n\t\t\ter.setIncluded(true);\n\t\t\touterHoleER.setProcessed(true);\n\t\t}\n\t}\n};\nPolygonizer.extractPolygons = function (shellList, includeAll) {\n\tvar polyList = new ArrayList();\n\tfor (var i = shellList.iterator(); i.hasNext();) {\n\t\tvar er = i.next();\n\t\tif (includeAll || er.isIncluded()) {\n\t\t\tpolyList.add(er.getPolygon());\n\t\t}\n\t}\n\treturn polyList;\n};\nPolygonizer.assignHolesToShells = function (holeList, shellList) {\n\tfor (var i = holeList.iterator(); i.hasNext();) {\n\t\tvar holeER = i.next();\n\t\tPolygonizer.assignHoleToShell(holeER, shellList);\n\t}\n};\nPolygonizer.assignHoleToShell = function (holeER, shellList) {\n\tvar shell = EdgeRing$1.findEdgeRingContaining(holeER, shellList);\n\tif (shell !== null) {\n\t\tshell.addHole(holeER);\n\t}\n};\nPolygonizer.findDisjointShells = function (shellList) {\n\tPolygonizer.findOuterShells(shellList);\n\tvar isMoreToScan = null;\n\tdo {\n\t\tisMoreToScan = false;\n\t\tfor (var i = shellList.iterator(); i.hasNext();) {\n\t\t\tvar er = i.next();\n\t\t\tif (er.isIncludedSet()) continue;\n\t\t\ter.updateIncluded();\n\t\t\tif (!er.isIncludedSet()) {\n\t\t\t\tisMoreToScan = true;\n\t\t\t}\n\t\t}\n\t} while (isMoreToScan);\n};\nfunction LineStringAdder() {\n\tthis.p = null;\n\tvar p = arguments[0];\n\tthis.p = p;\n}\nextend(LineStringAdder.prototype, {\n\tfilter: function filter(g) {\n\t\tif (g instanceof LineString) this.p.add(g);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [GeometryComponentFilter];\n\t},\n\tgetClass: function getClass() {\n\t\treturn LineStringAdder;\n\t}\n});\nPolygonizer.LineStringAdder = LineStringAdder;\n\nfunction RelateComputer() {\n\tthis._li = new RobustLineIntersector();\n\tthis._ptLocator = new PointLocator();\n\tthis._arg = null;\n\tthis._nodes = new NodeMap(new RelateNodeFactory());\n\tthis._im = null;\n\tthis._isolatedEdges = new ArrayList();\n\tthis._invalidPoint = null;\n\tvar arg = arguments[0];\n\tthis._arg = arg;\n}\nextend(RelateComputer.prototype, {\n\tinsertEdgeEnds: function insertEdgeEnds(ee) {\n\t\tfor (var i = ee.iterator(); i.hasNext();) {\n\t\t\tvar e = i.next();\n\t\t\tthis._nodes.add(e);\n\t\t}\n\t},\n\tcomputeProperIntersectionIM: function computeProperIntersectionIM(intersector, im) {\n\t\tvar dimA = this._arg[0].getGeometry().getDimension();\n\t\tvar dimB = this._arg[1].getGeometry().getDimension();\n\t\tvar hasProper = intersector.hasProperIntersection();\n\t\tvar hasProperInterior = intersector.hasProperInteriorIntersection();\n\t\tif (dimA === 2 && dimB === 2) {\n\t\t\tif (hasProper) im.setAtLeast(\"212101212\");\n\t\t} else if (dimA === 2 && dimB === 1) {\n\t\t\tif (hasProper) im.setAtLeast(\"FFF0FFFF2\");\n\t\t\tif (hasProperInterior) im.setAtLeast(\"1FFFFF1FF\");\n\t\t} else if (dimA === 1 && dimB === 2) {\n\t\t\tif (hasProper) im.setAtLeast(\"F0FFFFFF2\");\n\t\t\tif (hasProperInterior) im.setAtLeast(\"1F1FFFFFF\");\n\t\t} else if (dimA === 1 && dimB === 1) {\n\t\t\tif (hasProperInterior) im.setAtLeast(\"0FFFFFFFF\");\n\t\t}\n\t},\n\tlabelIsolatedEdges: function labelIsolatedEdges(thisIndex, targetIndex) {\n\t\tfor (var ei = this._arg[thisIndex].getEdgeIterator(); ei.hasNext();) {\n\t\t\tvar e = ei.next();\n\t\t\tif (e.isIsolated()) {\n\t\t\t\tthis.labelIsolatedEdge(e, targetIndex, this._arg[targetIndex].getGeometry());\n\t\t\t\tthis._isolatedEdges.add(e);\n\t\t\t}\n\t\t}\n\t},\n\tlabelIsolatedEdge: function labelIsolatedEdge(e, targetIndex, target) {\n\t\tif (target.getDimension() > 0) {\n\t\t\tvar loc = this._ptLocator.locate(e.getCoordinate(), target);\n\t\t\te.getLabel().setAllLocations(targetIndex, loc);\n\t\t} else {\n\t\t\te.getLabel().setAllLocations(targetIndex, Location.EXTERIOR);\n\t\t}\n\t},\n\tcomputeIM: function computeIM() {\n\t\tvar im = new IntersectionMatrix();\n\t\tim.set(Location.EXTERIOR, Location.EXTERIOR, 2);\n\t\tif (!this._arg[0].getGeometry().getEnvelopeInternal().intersects(this._arg[1].getGeometry().getEnvelopeInternal())) {\n\t\t\tthis.computeDisjointIM(im);\n\t\t\treturn im;\n\t\t}\n\t\tthis._arg[0].computeSelfNodes(this._li, false);\n\t\tthis._arg[1].computeSelfNodes(this._li, false);\n\t\tvar intersector = this._arg[0].computeEdgeIntersections(this._arg[1], this._li, false);\n\t\tthis.computeIntersectionNodes(0);\n\t\tthis.computeIntersectionNodes(1);\n\t\tthis.copyNodesAndLabels(0);\n\t\tthis.copyNodesAndLabels(1);\n\t\tthis.labelIsolatedNodes();\n\t\tthis.computeProperIntersectionIM(intersector, im);\n\t\tvar eeBuilder = new EdgeEndBuilder();\n\t\tvar ee0 = eeBuilder.computeEdgeEnds(this._arg[0].getEdgeIterator());\n\t\tthis.insertEdgeEnds(ee0);\n\t\tvar ee1 = eeBuilder.computeEdgeEnds(this._arg[1].getEdgeIterator());\n\t\tthis.insertEdgeEnds(ee1);\n\t\tthis.labelNodeEdges();\n\t\tthis.labelIsolatedEdges(0, 1);\n\t\tthis.labelIsolatedEdges(1, 0);\n\t\tthis.updateIM(im);\n\t\treturn im;\n\t},\n\tlabelNodeEdges: function labelNodeEdges() {\n\t\tfor (var ni = this._nodes.iterator(); ni.hasNext();) {\n\t\t\tvar node = ni.next();\n\t\t\tnode.getEdges().computeLabelling(this._arg);\n\t\t}\n\t},\n\tcopyNodesAndLabels: function copyNodesAndLabels(argIndex) {\n\t\tfor (var i = this._arg[argIndex].getNodeIterator(); i.hasNext();) {\n\t\t\tvar graphNode = i.next();\n\t\t\tvar newNode = this._nodes.addNode(graphNode.getCoordinate());\n\t\t\tnewNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));\n\t\t}\n\t},\n\tlabelIntersectionNodes: function labelIntersectionNodes(argIndex) {\n\t\tfor (var i = this._arg[argIndex].getEdgeIterator(); i.hasNext();) {\n\t\t\tvar e = i.next();\n\t\t\tvar eLoc = e.getLabel().getLocation(argIndex);\n\t\t\tfor (var eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext();) {\n\t\t\t\tvar ei = eiIt.next();\n\t\t\t\tvar n = this._nodes.find(ei.coord);\n\t\t\t\tif (n.getLabel().isNull(argIndex)) {\n\t\t\t\t\tif (eLoc === Location.BOUNDARY) n.setLabelBoundary(argIndex);else n.setLabel(argIndex, Location.INTERIOR);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tlabelIsolatedNode: function labelIsolatedNode(n, targetIndex) {\n\t\tvar loc = this._ptLocator.locate(n.getCoordinate(), this._arg[targetIndex].getGeometry());\n\t\tn.getLabel().setAllLocations(targetIndex, loc);\n\t},\n\tcomputeIntersectionNodes: function computeIntersectionNodes(argIndex) {\n\t\tfor (var i = this._arg[argIndex].getEdgeIterator(); i.hasNext();) {\n\t\t\tvar e = i.next();\n\t\t\tvar eLoc = e.getLabel().getLocation(argIndex);\n\t\t\tfor (var eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext();) {\n\t\t\t\tvar ei = eiIt.next();\n\t\t\t\tvar n = this._nodes.addNode(ei.coord);\n\t\t\t\tif (eLoc === Location.BOUNDARY) n.setLabelBoundary(argIndex);else {\n\t\t\t\t\tif (n.getLabel().isNull(argIndex)) n.setLabel(argIndex, Location.INTERIOR);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tlabelIsolatedNodes: function labelIsolatedNodes() {\n\t\tfor (var ni = this._nodes.iterator(); ni.hasNext();) {\n\t\t\tvar n = ni.next();\n\t\t\tvar label = n.getLabel();\n\t\t\tAssert.isTrue(label.getGeometryCount() > 0, \"node with empty label found\");\n\t\t\tif (n.isIsolated()) {\n\t\t\t\tif (label.isNull(0)) this.labelIsolatedNode(n, 0);else this.labelIsolatedNode(n, 1);\n\t\t\t}\n\t\t}\n\t},\n\tupdateIM: function updateIM(im) {\n\t\tfor (var ei = this._isolatedEdges.iterator(); ei.hasNext();) {\n\t\t\tvar e = ei.next();\n\t\t\te.updateIM(im);\n\t\t}\n\t\tfor (var ni = this._nodes.iterator(); ni.hasNext();) {\n\t\t\tvar node = ni.next();\n\t\t\tnode.updateIM(im);\n\t\t\tnode.updateIMFromEdges(im);\n\t\t}\n\t},\n\tcomputeDisjointIM: function computeDisjointIM(im) {\n\t\tvar ga = this._arg[0].getGeometry();\n\t\tif (!ga.isEmpty()) {\n\t\t\tim.set(Location.INTERIOR, Location.EXTERIOR, ga.getDimension());\n\t\t\tim.set(Location.BOUNDARY, Location.EXTERIOR, ga.getBoundaryDimension());\n\t\t}\n\t\tvar gb = this._arg[1].getGeometry();\n\t\tif (!gb.isEmpty()) {\n\t\t\tim.set(Location.EXTERIOR, Location.INTERIOR, gb.getDimension());\n\t\t\tim.set(Location.EXTERIOR, Location.BOUNDARY, gb.getBoundaryDimension());\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn RelateComputer;\n\t}\n});\n\nfunction RectangleContains() {\n\tthis._rectEnv = null;\n\tvar rectangle = arguments[0];\n\tthis._rectEnv = rectangle.getEnvelopeInternal();\n}\nextend(RectangleContains.prototype, {\n\tisContainedInBoundary: function isContainedInBoundary(geom) {\n\t\tif (geom instanceof Polygon) return false;\n\t\tif (geom instanceof Point) return this.isPointContainedInBoundary(geom);\n\t\tif (geom instanceof LineString) return this.isLineStringContainedInBoundary(geom);\n\t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n\t\t\tvar comp = geom.getGeometryN(i);\n\t\t\tif (!this.isContainedInBoundary(comp)) return false;\n\t\t}\n\t\treturn true;\n\t},\n\tisLineSegmentContainedInBoundary: function isLineSegmentContainedInBoundary(p0, p1) {\n\t\tif (p0.equals(p1)) return this.isPointContainedInBoundary(p0);\n\t\tif (p0.x === p1.x) {\n\t\t\tif (p0.x === this._rectEnv.getMinX() || p0.x === this._rectEnv.getMaxX()) return true;\n\t\t} else if (p0.y === p1.y) {\n\t\t\tif (p0.y === this._rectEnv.getMinY() || p0.y === this._rectEnv.getMaxY()) return true;\n\t\t}\n\t\treturn false;\n\t},\n\tisLineStringContainedInBoundary: function isLineStringContainedInBoundary(line) {\n\t\tvar seq = line.getCoordinateSequence();\n\t\tvar p0 = new Coordinate();\n\t\tvar p1 = new Coordinate();\n\t\tfor (var i = 0; i < seq.size() - 1; i++) {\n\t\t\tseq.getCoordinate(i, p0);\n\t\t\tseq.getCoordinate(i + 1, p1);\n\t\t\tif (!this.isLineSegmentContainedInBoundary(p0, p1)) return false;\n\t\t}\n\t\treturn true;\n\t},\n\tisPointContainedInBoundary: function isPointContainedInBoundary() {\n\t\tif (arguments[0] instanceof Point) {\n\t\t\tvar point = arguments[0];\n\t\t\treturn this.isPointContainedInBoundary(point.getCoordinate());\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tvar pt = arguments[0];\n\t\t\treturn pt.x === this._rectEnv.getMinX() || pt.x === this._rectEnv.getMaxX() || pt.y === this._rectEnv.getMinY() || pt.y === this._rectEnv.getMaxY();\n\t\t}\n\t},\n\tcontains: function contains(geom) {\n\t\tif (!this._rectEnv.contains(geom.getEnvelopeInternal())) return false;\n\t\tif (this.isContainedInBoundary(geom)) return false;\n\t\treturn true;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn RectangleContains;\n\t}\n});\nRectangleContains.contains = function (rectangle, b) {\n\tvar rc = new RectangleContains(rectangle);\n\treturn rc.contains(b);\n};\n\nfunction RectangleLineIntersector() {\n\tthis._li = new RobustLineIntersector();\n\tthis._rectEnv = null;\n\tthis._diagUp0 = null;\n\tthis._diagUp1 = null;\n\tthis._diagDown0 = null;\n\tthis._diagDown1 = null;\n\tvar rectEnv = arguments[0];\n\tthis._rectEnv = rectEnv;\n\tthis._diagUp0 = new Coordinate(rectEnv.getMinX(), rectEnv.getMinY());\n\tthis._diagUp1 = new Coordinate(rectEnv.getMaxX(), rectEnv.getMaxY());\n\tthis._diagDown0 = new Coordinate(rectEnv.getMinX(), rectEnv.getMaxY());\n\tthis._diagDown1 = new Coordinate(rectEnv.getMaxX(), rectEnv.getMinY());\n}\nextend(RectangleLineIntersector.prototype, {\n\tintersects: function intersects(p0, p1) {\n\t\tvar segEnv = new Envelope(p0, p1);\n\t\tif (!this._rectEnv.intersects(segEnv)) return false;\n\t\tif (this._rectEnv.intersects(p0)) return true;\n\t\tif (this._rectEnv.intersects(p1)) return true;\n\t\tif (p0.compareTo(p1) > 0) {\n\t\t\tvar tmp = p0;\n\t\t\tp0 = p1;\n\t\t\tp1 = tmp;\n\t\t}\n\t\tvar isSegUpwards = false;\n\t\tif (p1.y > p0.y) isSegUpwards = true;\n\t\tif (isSegUpwards) {\n\t\t\tthis._li.computeIntersection(p0, p1, this._diagDown0, this._diagDown1);\n\t\t} else {\n\t\t\tthis._li.computeIntersection(p0, p1, this._diagUp0, this._diagUp1);\n\t\t}\n\t\tif (this._li.hasIntersection()) return true;\n\t\treturn false;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn RectangleLineIntersector;\n\t}\n});\n\nfunction ShortCircuitedGeometryVisitor() {\n\tthis._isDone = false;\n}\nextend(ShortCircuitedGeometryVisitor.prototype, {\n\tapplyTo: function applyTo(geom) {\n\t\tfor (var i = 0; i < geom.getNumGeometries() && !this._isDone; i++) {\n\t\t\tvar element = geom.getGeometryN(i);\n\t\t\tif (!(element instanceof GeometryCollection)) {\n\t\t\t\tthis.visit(element);\n\t\t\t\tif (this.isDone()) {\n\t\t\t\t\tthis._isDone = true;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t} else this.applyTo(element);\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn ShortCircuitedGeometryVisitor;\n\t}\n});\n\nfunction RectangleIntersects() {\n\tthis._rectangle = null;\n\tthis._rectEnv = null;\n\tvar rectangle = arguments[0];\n\tthis._rectangle = rectangle;\n\tthis._rectEnv = rectangle.getEnvelopeInternal();\n}\nextend(RectangleIntersects.prototype, {\n\tintersects: function intersects(geom) {\n\t\tif (!this._rectEnv.intersects(geom.getEnvelopeInternal())) return false;\n\t\tvar visitor = new EnvelopeIntersectsVisitor(this._rectEnv);\n\t\tvisitor.applyTo(geom);\n\t\tif (visitor.intersects()) return true;\n\t\tvar ecpVisitor = new GeometryContainsPointVisitor(this._rectangle);\n\t\tecpVisitor.applyTo(geom);\n\t\tif (ecpVisitor.containsPoint()) return true;\n\t\tvar riVisitor = new RectangleIntersectsSegmentVisitor(this._rectangle);\n\t\triVisitor.applyTo(geom);\n\t\tif (riVisitor.intersects()) return true;\n\t\treturn false;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn RectangleIntersects;\n\t}\n});\nRectangleIntersects.intersects = function (rectangle, b) {\n\tvar rp = new RectangleIntersects(rectangle);\n\treturn rp.intersects(b);\n};\nfunction EnvelopeIntersectsVisitor() {\n\tShortCircuitedGeometryVisitor.apply(this);\n\tthis._rectEnv = null;\n\tthis._intersects = false;\n\tvar rectEnv = arguments[0];\n\tthis._rectEnv = rectEnv;\n}\ninherits$1(EnvelopeIntersectsVisitor, ShortCircuitedGeometryVisitor);\nextend(EnvelopeIntersectsVisitor.prototype, {\n\tisDone: function isDone() {\n\t\treturn this._intersects === true;\n\t},\n\tvisit: function visit(element) {\n\t\tvar elementEnv = element.getEnvelopeInternal();\n\t\tif (!this._rectEnv.intersects(elementEnv)) {\n\t\t\treturn null;\n\t\t}\n\t\tif (this._rectEnv.contains(elementEnv)) {\n\t\t\tthis._intersects = true;\n\t\t\treturn null;\n\t\t}\n\t\tif (elementEnv.getMinX() >= this._rectEnv.getMinX() && elementEnv.getMaxX() <= this._rectEnv.getMaxX()) {\n\t\t\tthis._intersects = true;\n\t\t\treturn null;\n\t\t}\n\t\tif (elementEnv.getMinY() >= this._rectEnv.getMinY() && elementEnv.getMaxY() <= this._rectEnv.getMaxY()) {\n\t\t\tthis._intersects = true;\n\t\t\treturn null;\n\t\t}\n\t},\n\tintersects: function intersects() {\n\t\treturn this._intersects;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn EnvelopeIntersectsVisitor;\n\t}\n});\nfunction GeometryContainsPointVisitor() {\n\tShortCircuitedGeometryVisitor.apply(this);\n\tthis._rectSeq = null;\n\tthis._rectEnv = null;\n\tthis._containsPoint = false;\n\tvar rectangle = arguments[0];\n\tthis._rectSeq = rectangle.getExteriorRing().getCoordinateSequence();\n\tthis._rectEnv = rectangle.getEnvelopeInternal();\n}\ninherits$1(GeometryContainsPointVisitor, ShortCircuitedGeometryVisitor);\nextend(GeometryContainsPointVisitor.prototype, {\n\tisDone: function isDone() {\n\t\treturn this._containsPoint === true;\n\t},\n\tvisit: function visit(geom) {\n\t\tif (!(geom instanceof Polygon)) return null;\n\t\tvar elementEnv = geom.getEnvelopeInternal();\n\t\tif (!this._rectEnv.intersects(elementEnv)) return null;\n\t\tvar rectPt = new Coordinate();\n\t\tfor (var i = 0; i < 4; i++) {\n\t\t\tthis._rectSeq.getCoordinate(i, rectPt);\n\t\t\tif (!elementEnv.contains(rectPt)) continue;\n\t\t\tif (SimplePointInAreaLocator.containsPointInPolygon(rectPt, geom)) {\n\t\t\t\tthis._containsPoint = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t},\n\tcontainsPoint: function containsPoint() {\n\t\treturn this._containsPoint;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn GeometryContainsPointVisitor;\n\t}\n});\nfunction RectangleIntersectsSegmentVisitor() {\n\tShortCircuitedGeometryVisitor.apply(this);\n\tthis._rectEnv = null;\n\tthis._rectIntersector = null;\n\tthis._hasIntersection = false;\n\tthis._p0 = new Coordinate();\n\tthis._p1 = new Coordinate();\n\tvar rectangle = arguments[0];\n\tthis._rectEnv = rectangle.getEnvelopeInternal();\n\tthis._rectIntersector = new RectangleLineIntersector(this._rectEnv);\n}\ninherits$1(RectangleIntersectsSegmentVisitor, ShortCircuitedGeometryVisitor);\nextend(RectangleIntersectsSegmentVisitor.prototype, {\n\tintersects: function intersects() {\n\t\treturn this._hasIntersection;\n\t},\n\tisDone: function isDone() {\n\t\treturn this._hasIntersection === true;\n\t},\n\tvisit: function visit(geom) {\n\t\tvar elementEnv = geom.getEnvelopeInternal();\n\t\tif (!this._rectEnv.intersects(elementEnv)) return null;\n\t\tvar lines = LinearComponentExtracter.getLines(geom);\n\t\tthis.checkIntersectionWithLineStrings(lines);\n\t},\n\tcheckIntersectionWithLineStrings: function checkIntersectionWithLineStrings(lines) {\n\t\tfor (var i = lines.iterator(); i.hasNext();) {\n\t\t\tvar testLine = i.next();\n\t\t\tthis.checkIntersectionWithSegments(testLine);\n\t\t\tif (this._hasIntersection) return null;\n\t\t}\n\t},\n\tcheckIntersectionWithSegments: function checkIntersectionWithSegments(testLine) {\n\t\tvar seq1 = testLine.getCoordinateSequence();\n\t\tfor (var j = 1; j < seq1.size(); j++) {\n\t\t\tseq1.getCoordinate(j - 1, this._p0);\n\t\t\tseq1.getCoordinate(j, this._p1);\n\t\t\tif (this._rectIntersector.intersects(this._p0, this._p1)) {\n\t\t\t\tthis._hasIntersection = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn RectangleIntersectsSegmentVisitor;\n\t}\n});\n\nfunction RelateOp() {\n\tthis._relate = null;\n\tif (arguments.length === 2) {\n\t\tvar g0 = arguments[0],\n\t\t    g1 = arguments[1];\n\t\tGeometryGraphOperation.call(this, g0, g1);\n\t\tthis._relate = new RelateComputer(this._arg);\n\t} else if (arguments.length === 3) {\n\t\tvar g0 = arguments[0],\n\t\t    g1 = arguments[1],\n\t\t    boundaryNodeRule = arguments[2];\n\t\tGeometryGraphOperation.call(this, g0, g1, boundaryNodeRule);\n\t\tthis._relate = new RelateComputer(this._arg);\n\t}\n}\ninherits$1(RelateOp, GeometryGraphOperation);\nextend(RelateOp.prototype, {\n\tgetIntersectionMatrix: function getIntersectionMatrix() {\n\t\treturn this._relate.computeIM();\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn RelateOp;\n\t}\n});\nRelateOp.covers = function (g1, g2) {\n\tif (!g1.getEnvelopeInternal().covers(g2.getEnvelopeInternal())) return false;\n\tif (g1.isRectangle()) {\n\t\treturn true;\n\t}\n\treturn RelateOp.relate(g1, g2).isCovers();\n};\nRelateOp.intersects = function (g1, g2) {\n\tif (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;\n\tif (g1.isRectangle()) {\n\t\treturn RectangleIntersects.intersects(g1, g2);\n\t}\n\tif (g2.isRectangle()) {\n\t\treturn RectangleIntersects.intersects(g2, g1);\n\t}\n\treturn RelateOp.relate(g1, g2).isIntersects();\n};\nRelateOp.touches = function (g1, g2) {\n\tif (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;\n\treturn RelateOp.relate(g1, g2).isTouches(g1.getDimension(), g2.getDimension());\n};\nRelateOp.within = function (g1, g2) {\n\treturn g2.contains(g1);\n};\nRelateOp.coveredBy = function (g1, g2) {\n\treturn RelateOp.covers(g2, g1);\n};\nRelateOp.relate = function () {\n\tif (arguments.length === 2) {\n\t\tvar a = arguments[0],\n\t\t    b = arguments[1];\n\t\tvar relOp = new RelateOp(a, b);\n\t\tvar im = relOp.getIntersectionMatrix();\n\t\treturn im;\n\t} else if (arguments.length === 3) {\n\t\tif (typeof arguments[2] === \"string\" && arguments[0] instanceof Geometry && arguments[1] instanceof Geometry) {\n\t\t\tvar g1 = arguments[0],\n\t\t\t    g2 = arguments[1],\n\t\t\t    intersectionPattern = arguments[2];\n\t\t\treturn RelateOp.relateWithCheck(g1, g2).matches(intersectionPattern);\n\t\t} else if (hasInterface(arguments[2], BoundaryNodeRule) && arguments[0] instanceof Geometry && arguments[1] instanceof Geometry) {\n\t\t\tvar a = arguments[0],\n\t\t\t    b = arguments[1],\n\t\t\t    boundaryNodeRule = arguments[2];\n\t\t\tvar relOp = new RelateOp(a, b, boundaryNodeRule);\n\t\t\tvar im = relOp.getIntersectionMatrix();\n\t\t\treturn im;\n\t\t}\n\t}\n};\nRelateOp.overlaps = function (g1, g2) {\n\tif (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;\n\treturn RelateOp.relate(g1, g2).isOverlaps(g1.getDimension(), g2.getDimension());\n};\nRelateOp.disjoint = function (g1, g2) {\n\treturn !g1.intersects(g2);\n};\nRelateOp.relateWithCheck = function (g1, g2) {\n\tg1.checkNotGeometryCollection(g1);\n\tg1.checkNotGeometryCollection(g2);\n\treturn RelateOp.relate(g1, g2);\n};\nRelateOp.crosses = function (g1, g2) {\n\tif (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;\n\treturn RelateOp.relate(g1, g2).isCrosses(g1.getDimension(), g2.getDimension());\n};\nRelateOp.contains = function (g1, g2) {\n\tif (!g1.getEnvelopeInternal().contains(g2.getEnvelopeInternal())) return false;\n\tif (g1.isRectangle()) {\n\t\treturn RectangleContains.contains(g1, g2);\n\t}\n\treturn RelateOp.relate(g1, g2).isContains();\n};\n\nfunction GeometryCombiner() {\n\tthis._geomFactory = null;\n\tthis._skipEmpty = false;\n\tthis._inputGeoms = null;\n\tvar geoms = arguments[0];\n\tthis._geomFactory = GeometryCombiner.extractFactory(geoms);\n\tthis._inputGeoms = geoms;\n}\nextend(GeometryCombiner.prototype, {\n\textractElements: function extractElements(geom, elems) {\n\t\tif (geom === null) return null;\n\t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n\t\t\tvar elemGeom = geom.getGeometryN(i);\n\t\t\tif (this._skipEmpty && elemGeom.isEmpty()) continue;\n\t\t\telems.add(elemGeom);\n\t\t}\n\t},\n\tcombine: function combine() {\n\t\tvar elems = new ArrayList();\n\t\tfor (var i = this._inputGeoms.iterator(); i.hasNext();) {\n\t\t\tvar g = i.next();\n\t\t\tthis.extractElements(g, elems);\n\t\t}\n\t\tif (elems.size() === 0) {\n\t\t\tif (this._geomFactory !== null) {\n\t\t\t\treturn this._geomFactory.createGeometryCollection(null);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\treturn this._geomFactory.buildGeometry(elems);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn GeometryCombiner;\n\t}\n});\nGeometryCombiner.combine = function () {\n\tif (arguments.length === 1) {\n\t\tvar geoms = arguments[0];\n\t\tvar combiner = new GeometryCombiner(geoms);\n\t\treturn combiner.combine();\n\t} else if (arguments.length === 2) {\n\t\tvar g0 = arguments[0],\n\t\t    g1 = arguments[1];\n\t\tvar combiner = new GeometryCombiner(GeometryCombiner.createList(g0, g1));\n\t\treturn combiner.combine();\n\t} else if (arguments.length === 3) {\n\t\tvar g0 = arguments[0],\n\t\t    g1 = arguments[1],\n\t\t    g2 = arguments[2];\n\t\tvar combiner = new GeometryCombiner(GeometryCombiner.createList(g0, g1, g2));\n\t\treturn combiner.combine();\n\t}\n};\nGeometryCombiner.extractFactory = function (geoms) {\n\tif (geoms.isEmpty()) return null;\n\treturn geoms.iterator().next().getFactory();\n};\nGeometryCombiner.createList = function () {\n\tif (arguments.length === 2) {\n\t\tvar obj0 = arguments[0],\n\t\t    obj1 = arguments[1];\n\t\tvar list = new ArrayList();\n\t\tlist.add(obj0);\n\t\tlist.add(obj1);\n\t\treturn list;\n\t} else if (arguments.length === 3) {\n\t\tvar obj0 = arguments[0],\n\t\t    obj1 = arguments[1],\n\t\t    obj2 = arguments[2];\n\t\tvar list = new ArrayList();\n\t\tlist.add(obj0);\n\t\tlist.add(obj1);\n\t\tlist.add(obj2);\n\t\treturn list;\n\t}\n};\n\nfunction CascadedPolygonUnion() {\n\tthis._inputPolys = null;\n\tthis._geomFactory = null;\n\tvar polys = arguments[0];\n\tthis._inputPolys = polys;\n\tif (this._inputPolys === null) this._inputPolys = new ArrayList();\n}\nextend(CascadedPolygonUnion.prototype, {\n\treduceToGeometries: function reduceToGeometries(geomTree) {\n\t\tvar geoms = new ArrayList();\n\t\tfor (var i = geomTree.iterator(); i.hasNext();) {\n\t\t\tvar o = i.next();\n\t\t\tvar geom = null;\n\t\t\tif (hasInterface(o, List)) {\n\t\t\t\tgeom = this.unionTree(o);\n\t\t\t} else if (o instanceof Geometry) {\n\t\t\t\tgeom = o;\n\t\t\t}\n\t\t\tgeoms.add(geom);\n\t\t}\n\t\treturn geoms;\n\t},\n\textractByEnvelope: function extractByEnvelope(env, geom, disjointGeoms) {\n\t\tvar intersectingGeoms = new ArrayList();\n\t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n\t\t\tvar elem = geom.getGeometryN(i);\n\t\t\tif (elem.getEnvelopeInternal().intersects(env)) intersectingGeoms.add(elem);else disjointGeoms.add(elem);\n\t\t}\n\t\treturn this._geomFactory.buildGeometry(intersectingGeoms);\n\t},\n\tunionOptimized: function unionOptimized(g0, g1) {\n\t\tvar g0Env = g0.getEnvelopeInternal();\n\t\tvar g1Env = g1.getEnvelopeInternal();\n\t\tif (!g0Env.intersects(g1Env)) {\n\t\t\tvar combo = GeometryCombiner.combine(g0, g1);\n\t\t\treturn combo;\n\t\t}\n\t\tif (g0.getNumGeometries() <= 1 && g1.getNumGeometries() <= 1) return this.unionActual(g0, g1);\n\t\tvar commonEnv = g0Env.intersection(g1Env);\n\t\treturn this.unionUsingEnvelopeIntersection(g0, g1, commonEnv);\n\t},\n\tunion: function union() {\n\t\tif (this._inputPolys === null) throw new IllegalStateException(\"union() method cannot be called twice\");\n\t\tif (this._inputPolys.isEmpty()) return null;\n\t\tthis._geomFactory = this._inputPolys.iterator().next().getFactory();\n\t\tvar index = new STRtree(CascadedPolygonUnion.STRTREE_NODE_CAPACITY);\n\t\tfor (var i = this._inputPolys.iterator(); i.hasNext();) {\n\t\t\tvar item = i.next();\n\t\t\tindex.insert(item.getEnvelopeInternal(), item);\n\t\t}\n\t\tthis._inputPolys = null;\n\t\tvar itemTree = index.itemsTree();\n\t\tvar unionAll = this.unionTree(itemTree);\n\t\treturn unionAll;\n\t},\n\tbinaryUnion: function binaryUnion() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar geoms = arguments[0];\n\t\t\treturn this.binaryUnion(geoms, 0, geoms.size());\n\t\t} else if (arguments.length === 3) {\n\t\t\tvar geoms = arguments[0],\n\t\t\t    start = arguments[1],\n\t\t\t    end = arguments[2];\n\t\t\tif (end - start <= 1) {\n\t\t\t\tvar g0 = CascadedPolygonUnion.getGeometry(geoms, start);\n\t\t\t\treturn this.unionSafe(g0, null);\n\t\t\t} else if (end - start === 2) {\n\t\t\t\treturn this.unionSafe(CascadedPolygonUnion.getGeometry(geoms, start), CascadedPolygonUnion.getGeometry(geoms, start + 1));\n\t\t\t} else {\n\t\t\t\tvar mid = Math.trunc((end + start) / 2);\n\t\t\t\tvar g0 = this.binaryUnion(geoms, start, mid);\n\t\t\t\tvar g1 = this.binaryUnion(geoms, mid, end);\n\t\t\t\treturn this.unionSafe(g0, g1);\n\t\t\t}\n\t\t}\n\t},\n\trepeatedUnion: function repeatedUnion(geoms) {\n\t\tvar union = null;\n\t\tfor (var i = geoms.iterator(); i.hasNext();) {\n\t\t\tvar g = i.next();\n\t\t\tif (union === null) union = g.copy();else union = union.union(g);\n\t\t}\n\t\treturn union;\n\t},\n\tunionSafe: function unionSafe(g0, g1) {\n\t\tif (g0 === null && g1 === null) return null;\n\t\tif (g0 === null) return g1.copy();\n\t\tif (g1 === null) return g0.copy();\n\t\treturn this.unionOptimized(g0, g1);\n\t},\n\tunionActual: function unionActual(g0, g1) {\n\t\treturn CascadedPolygonUnion.restrictToPolygons(g0.union(g1));\n\t},\n\tunionTree: function unionTree(geomTree) {\n\t\tvar geoms = this.reduceToGeometries(geomTree);\n\t\tvar union = this.binaryUnion(geoms);\n\t\treturn union;\n\t},\n\tunionUsingEnvelopeIntersection: function unionUsingEnvelopeIntersection(g0, g1, common) {\n\t\tvar disjointPolys = new ArrayList();\n\t\tvar g0Int = this.extractByEnvelope(common, g0, disjointPolys);\n\t\tvar g1Int = this.extractByEnvelope(common, g1, disjointPolys);\n\t\tvar union = this.unionActual(g0Int, g1Int);\n\t\tdisjointPolys.add(union);\n\t\tvar overallUnion = GeometryCombiner.combine(disjointPolys);\n\t\treturn overallUnion;\n\t},\n\tbufferUnion: function bufferUnion() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar geoms = arguments[0];\n\t\t\tvar factory = geoms.get(0).getFactory();\n\t\t\tvar gColl = factory.buildGeometry(geoms);\n\t\t\tvar unionAll = gColl.buffer(0.0);\n\t\t\treturn unionAll;\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar g0 = arguments[0],\n\t\t\t    g1 = arguments[1];\n\t\t\tvar factory = g0.getFactory();\n\t\t\tvar gColl = factory.createGeometryCollection([g0, g1]);\n\t\t\tvar unionAll = gColl.buffer(0.0);\n\t\t\treturn unionAll;\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn CascadedPolygonUnion;\n\t}\n});\nCascadedPolygonUnion.restrictToPolygons = function (g) {\n\tif (hasInterface(g, Polygonal)) {\n\t\treturn g;\n\t}\n\tvar polygons = PolygonExtracter.getPolygons(g);\n\tif (polygons.size() === 1) return polygons.get(0);\n\treturn g.getFactory().createMultiPolygon(GeometryFactory.toPolygonArray(polygons));\n};\nCascadedPolygonUnion.getGeometry = function (list, index) {\n\tif (index >= list.size()) return null;\n\treturn list.get(index);\n};\nCascadedPolygonUnion.union = function (polys) {\n\tvar op = new CascadedPolygonUnion(polys);\n\treturn op.union();\n};\nCascadedPolygonUnion.STRTREE_NODE_CAPACITY = 4;\n\nfunction PointGeometryUnion() {\n\tthis._pointGeom = null;\n\tthis._otherGeom = null;\n\tthis._geomFact = null;\n\tvar pointGeom = arguments[0],\n\t    otherGeom = arguments[1];\n\tthis._pointGeom = pointGeom;\n\tthis._otherGeom = otherGeom;\n\tthis._geomFact = otherGeom.getFactory();\n}\nextend(PointGeometryUnion.prototype, {\n\tunion: function union() {\n\t\tvar locater = new PointLocator();\n\t\tvar exteriorCoords = new TreeSet();\n\t\tfor (var i = 0; i < this._pointGeom.getNumGeometries(); i++) {\n\t\t\tvar point = this._pointGeom.getGeometryN(i);\n\t\t\tvar coord = point.getCoordinate();\n\t\t\tvar loc = locater.locate(coord, this._otherGeom);\n\t\t\tif (loc === Location.EXTERIOR) exteriorCoords.add(coord);\n\t\t}\n\t\tif (exteriorCoords.size() === 0) return this._otherGeom;\n\t\tvar ptComp = null;\n\t\tvar coords = CoordinateArrays.toCoordinateArray(exteriorCoords);\n\t\tif (coords.length === 1) {\n\t\t\tptComp = this._geomFact.createPoint(coords[0]);\n\t\t} else {\n\t\t\tptComp = this._geomFact.createMultiPointFromCoords(coords);\n\t\t}\n\t\treturn GeometryCombiner.combine(ptComp, this._otherGeom);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn PointGeometryUnion;\n\t}\n});\nPointGeometryUnion.union = function (pointGeom, otherGeom) {\n\tvar unioner = new PointGeometryUnion(pointGeom, otherGeom);\n\treturn unioner.union();\n};\n\nfunction GeometryExtracter() {\n\tthis._sortIndex = -1;\n\tthis._comps = null;\n\tvar sortIndex = arguments[0],\n\t    comps = arguments[1];\n\tthis._sortIndex = sortIndex;\n\tthis._comps = comps;\n}\nextend(GeometryExtracter.prototype, {\n\tfilter: function filter(geom) {\n\t\tif (this._sortIndex === -1 || geom.getSortIndex() === this._sortIndex) this._comps.add(geom);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [GeometryFilter];\n\t},\n\tgetClass: function getClass() {\n\t\treturn GeometryExtracter;\n\t}\n});\nGeometryExtracter.extract = function () {\n\tif (arguments.length === 2) {\n\t\tvar geom = arguments[0],\n\t\t    sortIndex = arguments[1];\n\t\treturn GeometryExtracter.extract(geom, sortIndex, new ArrayList());\n\t} else if (arguments.length === 3) {\n\t\tvar geom = arguments[0],\n\t\t    sortIndex = arguments[1],\n\t\t    list = arguments[2];\n\t\tif (geom.getSortIndex() === sortIndex) {\n\t\t\tlist.add(geom);\n\t\t} else if (geom instanceof GeometryCollection) {\n\t\t\tgeom.apply(new GeometryExtracter(sortIndex, list));\n\t\t}\n\t\treturn list;\n\t}\n};\n\nfunction UnaryUnionOp() {\n\tthis._polygons = new ArrayList();\n\tthis._lines = new ArrayList();\n\tthis._points = new ArrayList();\n\tthis._geomFact = null;\n\tif (arguments.length === 1) {\n\t\tif (hasInterface(arguments[0], Collection)) {\n\t\t\tvar geoms = arguments[0];\n\t\t\tthis.extract(geoms);\n\t\t} else if (arguments[0] instanceof Geometry) {\n\t\t\tvar geom = arguments[0];\n\t\t\tthis.extract(geom);\n\t\t}\n\t} else if (arguments.length === 2) {\n\t\tvar geoms = arguments[0],\n\t\t    geomFact = arguments[1];\n\t\tthis._geomFact = geomFact;\n\t\tthis.extract(geoms);\n\t}\n}\nextend(UnaryUnionOp.prototype, {\n\tunionNoOpt: function unionNoOpt(g0) {\n\t\tvar empty = this._geomFact.createPoint();\n\t\treturn SnapIfNeededOverlayOp.overlayOp(g0, empty, OverlayOp.UNION);\n\t},\n\tunionWithNull: function unionWithNull(g0, g1) {\n\t\tif (g0 === null && g1 === null) return null;\n\t\tif (g1 === null) return g0;\n\t\tif (g0 === null) return g1;\n\t\treturn g0.union(g1);\n\t},\n\textract: function extract() {\n\t\tif (hasInterface(arguments[0], Collection)) {\n\t\t\tvar geoms = arguments[0];\n\t\t\tfor (var i = geoms.iterator(); i.hasNext();) {\n\t\t\t\tvar geom = i.next();\n\t\t\t\tthis.extract(geom);\n\t\t\t}\n\t\t} else if (arguments[0] instanceof Geometry) {\n\t\t\tvar geom = arguments[0];\n\t\t\tif (this._geomFact === null) this._geomFact = geom.getFactory();\n\t\t\tGeometryExtracter.extract(geom, Geometry.SORTINDEX_POLYGON, this._polygons);\n\t\t\tGeometryExtracter.extract(geom, Geometry.SORTINDEX_LINESTRING, this._lines);\n\t\t\tGeometryExtracter.extract(geom, Geometry.SORTINDEX_POINT, this._points);\n\t\t}\n\t},\n\tunion: function union() {\n\t\tif (this._geomFact === null) {\n\t\t\treturn null;\n\t\t}\n\t\tvar unionPoints = null;\n\t\tif (this._points.size() > 0) {\n\t\t\tvar ptGeom = this._geomFact.buildGeometry(this._points);\n\t\t\tunionPoints = this.unionNoOpt(ptGeom);\n\t\t}\n\t\tvar unionLines = null;\n\t\tif (this._lines.size() > 0) {\n\t\t\tvar lineGeom = this._geomFact.buildGeometry(this._lines);\n\t\t\tunionLines = this.unionNoOpt(lineGeom);\n\t\t}\n\t\tvar unionPolygons = null;\n\t\tif (this._polygons.size() > 0) {\n\t\t\tunionPolygons = CascadedPolygonUnion.union(this._polygons);\n\t\t}\n\t\tvar unionLA = this.unionWithNull(unionLines, unionPolygons);\n\t\tvar union = null;\n\t\tif (unionPoints === null) union = unionLA;else if (unionLA === null) union = unionPoints;else union = PointGeometryUnion.union(unionPoints, unionLA);\n\t\tif (union === null) return this._geomFact.createGeometryCollection();\n\t\treturn union;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn UnaryUnionOp;\n\t}\n});\nUnaryUnionOp.union = function () {\n\tif (arguments.length === 1) {\n\t\tif (hasInterface(arguments[0], Collection)) {\n\t\t\tvar geoms = arguments[0];\n\t\t\tvar op = new UnaryUnionOp(geoms);\n\t\t\treturn op.union();\n\t\t} else if (arguments[0] instanceof Geometry) {\n\t\t\tvar geom = arguments[0];\n\t\t\tvar op = new UnaryUnionOp(geom);\n\t\t\treturn op.union();\n\t\t}\n\t} else if (arguments.length === 2) {\n\t\tvar geoms = arguments[0],\n\t\t    geomFact = arguments[1];\n\t\tvar op = new UnaryUnionOp(geoms, geomFact);\n\t\treturn op.union();\n\t}\n};\n\nfunction UnionInteracting() {\n\tthis._geomFactory = null;\n\tthis._g0 = null;\n\tthis._g1 = null;\n\tthis._interacts0 = null;\n\tthis._interacts1 = null;\n\tvar g0 = arguments[0],\n\t    g1 = arguments[1];\n\tthis._g0 = g0;\n\tthis._g1 = g1;\n\tthis._geomFactory = g0.getFactory();\n\tthis._interacts0 = new Array(g0.getNumGeometries()).fill(null);\n\tthis._interacts1 = new Array(g1.getNumGeometries()).fill(null);\n}\nextend(UnionInteracting.prototype, {\n\textractElements: function extractElements(geom, interacts, isInteracting) {\n\t\tvar extractedGeoms = new ArrayList();\n\t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n\t\t\tvar elem = geom.getGeometryN(i);\n\t\t\tif (interacts[i] === isInteracting) extractedGeoms.add(elem);\n\t\t}\n\t\treturn this._geomFactory.buildGeometry(extractedGeoms);\n\t},\n\tcomputeInteracting: function computeInteracting() {\n\t\tif (arguments.length === 0) {\n\t\t\tfor (var i = 0; i < this._g0.getNumGeometries(); i++) {\n\t\t\t\tvar elem = this._g0.getGeometryN(i);\n\t\t\t\tthis._interacts0[i] = this.computeInteracting(elem);\n\t\t\t}\n\t\t} else if (arguments.length === 1) {\n\t\t\tvar elem0 = arguments[0];\n\t\t\tvar interactsWithAny = false;\n\t\t\tfor (var i = 0; i < this._g1.getNumGeometries(); i++) {\n\t\t\t\tvar elem1 = this._g1.getGeometryN(i);\n\t\t\t\tvar interacts = elem1.getEnvelopeInternal().intersects(elem0.getEnvelopeInternal());\n\t\t\t\tif (interacts) this._interacts1[i] = true;\n\t\t\t\tif (interacts) interactsWithAny = true;\n\t\t\t}\n\t\t\treturn interactsWithAny;\n\t\t}\n\t},\n\tunion: function union() {\n\t\tthis.computeInteracting();\n\t\tvar int0 = this.extractElements(this._g0, this._interacts0, true);\n\t\tvar int1 = this.extractElements(this._g1, this._interacts1, true);\n\t\tif (int0.isEmpty() || int1.isEmpty()) {\n\t\t\tSystem.out.println(\"found empty!\");\n\t\t}\n\t\tvar union = int0.union(int1);\n\t\tvar disjoint0 = this.extractElements(this._g0, this._interacts0, false);\n\t\tvar disjoint1 = this.extractElements(this._g1, this._interacts1, false);\n\t\tvar overallUnion = GeometryCombiner.combine(union, disjoint0, disjoint1);\n\t\treturn overallUnion;\n\t},\n\tbufferUnion: function bufferUnion(g0, g1) {\n\t\tvar factory = g0.getFactory();\n\t\tvar gColl = factory.createGeometryCollection([g0, g1]);\n\t\tvar unionAll = gColl.buffer(0.0);\n\t\treturn unionAll;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn UnionInteracting;\n\t}\n});\nUnionInteracting.union = function (g0, g1) {\n\tvar uue = new UnionInteracting(g0, g1);\n\treturn uue.union();\n};\n\nfunction UnionOp() {}\nextend(UnionOp.prototype, {\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn UnionOp;\n\t}\n});\nUnionOp.union = function (g, other) {\n\tif (g.isEmpty() || other.isEmpty()) {\n\t\tif (g.isEmpty() && other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.UNION, g, other, g.getFactory());\n\t\tif (g.isEmpty()) return other.copy();\n\t\tif (other.isEmpty()) return g.copy();\n\t}\n\tg.checkNotGeometryCollection(g);\n\tg.checkNotGeometryCollection(other);\n\treturn SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.UNION);\n};\n\nfunction PrecisionReducerCoordinateOperation() {\n\tGeometryEditor.CoordinateOperation.apply(this);\n\tthis._targetPM = null;\n\tthis._removeCollapsed = true;\n\tvar targetPM = arguments[0],\n\t    removeCollapsed = arguments[1];\n\tthis._targetPM = targetPM;\n\tthis._removeCollapsed = removeCollapsed;\n}\ninherits$1(PrecisionReducerCoordinateOperation, GeometryEditor.CoordinateOperation);\nextend(PrecisionReducerCoordinateOperation.prototype, {\n\teditCoordinates: function editCoordinates(coordinates, geom) {\n\t\tif (coordinates.length === 0) return null;\n\t\tvar reducedCoords = new Array(coordinates.length).fill(null);\n\t\tfor (var i = 0; i < coordinates.length; i++) {\n\t\t\tvar coord = new Coordinate(coordinates[i]);\n\t\t\tthis._targetPM.makePrecise(coord);\n\t\t\treducedCoords[i] = coord;\n\t\t}\n\t\tvar noRepeatedCoordList = new CoordinateList(reducedCoords, false);\n\t\tvar noRepeatedCoords = noRepeatedCoordList.toCoordinateArray();\n\t\tvar minLength = 0;\n\t\tif (geom instanceof LineString) minLength = 2;\n\t\tif (geom instanceof LinearRing) minLength = 4;\n\t\tvar collapsedCoords = reducedCoords;\n\t\tif (this._removeCollapsed) collapsedCoords = null;\n\t\tif (noRepeatedCoords.length < minLength) {\n\t\t\treturn collapsedCoords;\n\t\t}\n\t\treturn noRepeatedCoords;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn PrecisionReducerCoordinateOperation;\n\t}\n});\n\nfunction GeometryPrecisionReducer() {\n\tthis._targetPM = null;\n\tthis._removeCollapsed = true;\n\tthis._changePrecisionModel = false;\n\tthis._isPointwise = false;\n\tvar pm = arguments[0];\n\tthis._targetPM = pm;\n}\nextend(GeometryPrecisionReducer.prototype, {\n\tfixPolygonalTopology: function fixPolygonalTopology(geom) {\n\t\tvar geomToBuffer = geom;\n\t\tif (!this._changePrecisionModel) {\n\t\t\tgeomToBuffer = this.changePM(geom, this._targetPM);\n\t\t}\n\t\tvar bufGeom = geomToBuffer.buffer(0);\n\t\tvar finalGeom = bufGeom;\n\t\tif (!this._changePrecisionModel) {\n\t\t\tfinalGeom = this.changePM(bufGeom, geom.getPrecisionModel());\n\t\t}\n\t\treturn finalGeom;\n\t},\n\treducePointwise: function reducePointwise(geom) {\n\t\tvar geomEdit = null;\n\t\tif (this._changePrecisionModel) {\n\t\t\tvar newFactory = this.createFactory(geom.getFactory(), this._targetPM);\n\t\t\tgeomEdit = new GeometryEditor(newFactory);\n\t\t} else geomEdit = new GeometryEditor();\n\t\tvar finalRemoveCollapsed = this._removeCollapsed;\n\t\tif (geom.getDimension() >= 2) finalRemoveCollapsed = true;\n\t\tvar reduceGeom = geomEdit.edit(geom, new PrecisionReducerCoordinateOperation(this._targetPM, finalRemoveCollapsed));\n\t\treturn reduceGeom;\n\t},\n\tchangePM: function changePM(geom, newPM) {\n\t\tvar geomEditor = this.createEditor(geom.getFactory(), newPM);\n\t\treturn geomEditor.edit(geom, new GeometryEditor.NoOpGeometryOperation());\n\t},\n\tsetRemoveCollapsedComponents: function setRemoveCollapsedComponents(removeCollapsed) {\n\t\tthis._removeCollapsed = removeCollapsed;\n\t},\n\tcreateFactory: function createFactory(inputFactory, pm) {\n\t\tvar newFactory = new GeometryFactory(pm, inputFactory.getSRID(), inputFactory.getCoordinateSequenceFactory());\n\t\treturn newFactory;\n\t},\n\tsetChangePrecisionModel: function setChangePrecisionModel(changePrecisionModel) {\n\t\tthis._changePrecisionModel = changePrecisionModel;\n\t},\n\treduce: function reduce(geom) {\n\t\tvar reducePW = this.reducePointwise(geom);\n\t\tif (this._isPointwise) return reducePW;\n\t\tif (!hasInterface(reducePW, Polygonal)) return reducePW;\n\t\tif (reducePW.isValid()) return reducePW;\n\t\treturn this.fixPolygonalTopology(reducePW);\n\t},\n\tsetPointwise: function setPointwise(isPointwise) {\n\t\tthis._isPointwise = isPointwise;\n\t},\n\tcreateEditor: function createEditor(geomFactory, newPM) {\n\t\tif (geomFactory.getPrecisionModel() === newPM) return new GeometryEditor();\n\t\tvar newFactory = this.createFactory(geomFactory, newPM);\n\t\tvar geomEdit = new GeometryEditor(newFactory);\n\t\treturn geomEdit;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn GeometryPrecisionReducer;\n\t}\n});\nGeometryPrecisionReducer.reduce = function (g, precModel) {\n\tvar reducer = new GeometryPrecisionReducer(precModel);\n\treturn reducer.reduce(g);\n};\nGeometryPrecisionReducer.reducePointwise = function (g, precModel) {\n\tvar reducer = new GeometryPrecisionReducer(precModel);\n\treducer.setPointwise(true);\n\treturn reducer.reduce(g);\n};\n\nfunction DouglasPeuckerLineSimplifier() {\n\tthis._pts = null;\n\tthis._usePt = null;\n\tthis._distanceTolerance = null;\n\tthis._seg = new LineSegment();\n\tvar pts = arguments[0];\n\tthis._pts = pts;\n}\nextend(DouglasPeuckerLineSimplifier.prototype, {\n\tsimplifySection: function simplifySection(i, j) {\n\t\tif (i + 1 === j) {\n\t\t\treturn null;\n\t\t}\n\t\tthis._seg.p0 = this._pts[i];\n\t\tthis._seg.p1 = this._pts[j];\n\t\tvar maxDistance = -1.0;\n\t\tvar maxIndex = i;\n\t\tfor (var k = i + 1; k < j; k++) {\n\t\t\tvar distance = this._seg.distance(this._pts[k]);\n\t\t\tif (distance > maxDistance) {\n\t\t\t\tmaxDistance = distance;\n\t\t\t\tmaxIndex = k;\n\t\t\t}\n\t\t}\n\t\tif (maxDistance <= this._distanceTolerance) {\n\t\t\tfor (var k = i + 1; k < j; k++) {\n\t\t\t\tthis._usePt[k] = false;\n\t\t\t}\n\t\t} else {\n\t\t\tthis.simplifySection(i, maxIndex);\n\t\t\tthis.simplifySection(maxIndex, j);\n\t\t}\n\t},\n\tsetDistanceTolerance: function setDistanceTolerance(distanceTolerance) {\n\t\tthis._distanceTolerance = distanceTolerance;\n\t},\n\tsimplify: function simplify() {\n\t\tthis._usePt = new Array(this._pts.length).fill(null);\n\t\tfor (var i = 0; i < this._pts.length; i++) {\n\t\t\tthis._usePt[i] = true;\n\t\t}\n\t\tthis.simplifySection(0, this._pts.length - 1);\n\t\tvar coordList = new CoordinateList();\n\t\tfor (var i = 0; i < this._pts.length; i++) {\n\t\t\tif (this._usePt[i]) coordList.add(new Coordinate(this._pts[i]));\n\t\t}\n\t\treturn coordList.toCoordinateArray();\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn DouglasPeuckerLineSimplifier;\n\t}\n});\nDouglasPeuckerLineSimplifier.simplify = function (pts, distanceTolerance) {\n\tvar simp = new DouglasPeuckerLineSimplifier(pts);\n\tsimp.setDistanceTolerance(distanceTolerance);\n\treturn simp.simplify();\n};\n\nfunction DouglasPeuckerSimplifier() {\n\tthis._inputGeom = null;\n\tthis._distanceTolerance = null;\n\tthis._isEnsureValidTopology = true;\n\tvar inputGeom = arguments[0];\n\tthis._inputGeom = inputGeom;\n}\nextend(DouglasPeuckerSimplifier.prototype, {\n\tsetEnsureValid: function setEnsureValid(isEnsureValidTopology) {\n\t\tthis._isEnsureValidTopology = isEnsureValidTopology;\n\t},\n\tgetResultGeometry: function getResultGeometry() {\n\t\tif (this._inputGeom.isEmpty()) return this._inputGeom.copy();\n\t\treturn new DPTransformer(this._isEnsureValidTopology, this._distanceTolerance).transform(this._inputGeom);\n\t},\n\tsetDistanceTolerance: function setDistanceTolerance(distanceTolerance) {\n\t\tif (distanceTolerance < 0.0) throw new IllegalArgumentException(\"Tolerance must be non-negative\");\n\t\tthis._distanceTolerance = distanceTolerance;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn DouglasPeuckerSimplifier;\n\t}\n});\nDouglasPeuckerSimplifier.simplify = function (geom, distanceTolerance) {\n\tvar tss = new DouglasPeuckerSimplifier(geom);\n\ttss.setDistanceTolerance(distanceTolerance);\n\treturn tss.getResultGeometry();\n};\nfunction DPTransformer() {\n\tGeometryTransformer.apply(this);\n\tthis._isEnsureValidTopology = true;\n\tthis._distanceTolerance = null;\n\tvar isEnsureValidTopology = arguments[0],\n\t    distanceTolerance = arguments[1];\n\tthis._isEnsureValidTopology = isEnsureValidTopology;\n\tthis._distanceTolerance = distanceTolerance;\n}\ninherits$1(DPTransformer, GeometryTransformer);\nextend(DPTransformer.prototype, {\n\ttransformPolygon: function transformPolygon(geom, parent) {\n\t\tif (geom.isEmpty()) return null;\n\t\tvar rawGeom = GeometryTransformer.prototype.transformPolygon.call(this, geom, parent);\n\t\tif (parent instanceof MultiPolygon) {\n\t\t\treturn rawGeom;\n\t\t}\n\t\treturn this.createValidArea(rawGeom);\n\t},\n\tcreateValidArea: function createValidArea(rawAreaGeom) {\n\t\tif (this._isEnsureValidTopology) return rawAreaGeom.buffer(0.0);\n\t\treturn rawAreaGeom;\n\t},\n\ttransformCoordinates: function transformCoordinates(coords, parent) {\n\t\tvar inputPts = coords.toCoordinateArray();\n\t\tvar newPts = null;\n\t\tif (inputPts.length === 0) {\n\t\t\tnewPts = new Array(0).fill(null);\n\t\t} else {\n\t\t\tnewPts = DouglasPeuckerLineSimplifier.simplify(inputPts, this._distanceTolerance);\n\t\t}\n\t\treturn this._factory.getCoordinateSequenceFactory().create(newPts);\n\t},\n\ttransformMultiPolygon: function transformMultiPolygon(geom, parent) {\n\t\tvar rawGeom = GeometryTransformer.prototype.transformMultiPolygon.call(this, geom, parent);\n\t\treturn this.createValidArea(rawGeom);\n\t},\n\ttransformLinearRing: function transformLinearRing(geom, parent) {\n\t\tvar removeDegenerateRings = parent instanceof Polygon;\n\t\tvar simpResult = GeometryTransformer.prototype.transformLinearRing.call(this, geom, parent);\n\t\tif (removeDegenerateRings && !(simpResult instanceof LinearRing)) return null;\n\t\t\n\t\treturn simpResult;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn DPTransformer;\n\t}\n});\nDouglasPeuckerSimplifier.DPTransformer = DPTransformer;\n\nfunction TaggedLineSegment() {\n\tthis._parent = null;\n\tthis._index = null;\n\tif (arguments.length === 2) {\n\t\tvar p0 = arguments[0],\n\t\t    p1 = arguments[1];\n\t\tTaggedLineSegment.call(this, p0, p1, null, -1);\n\t} else if (arguments.length === 4) {\n\t\tvar p0 = arguments[0],\n\t\t    p1 = arguments[1],\n\t\t    parent = arguments[2],\n\t\t    index = arguments[3];\n\t\tLineSegment.call(this, p0, p1);\n\t\tthis._parent = parent;\n\t\tthis._index = index;\n\t}\n}\ninherits$1(TaggedLineSegment, LineSegment);\nextend(TaggedLineSegment.prototype, {\n\tgetIndex: function getIndex() {\n\t\treturn this._index;\n\t},\n\tgetParent: function getParent() {\n\t\treturn this._parent;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn TaggedLineSegment;\n\t}\n});\n\nfunction TaggedLineString() {\n\tthis._parentLine = null;\n\tthis._segs = null;\n\tthis._resultSegs = new ArrayList();\n\tthis._minimumSize = null;\n\tif (arguments.length === 1) {\n\t\tvar parentLine = arguments[0];\n\t\tTaggedLineString.call(this, parentLine, 2);\n\t} else if (arguments.length === 2) {\n\t\tvar parentLine = arguments[0],\n\t\t    minimumSize = arguments[1];\n\t\tthis._parentLine = parentLine;\n\t\tthis._minimumSize = minimumSize;\n\t\tthis.init();\n\t}\n}\nextend(TaggedLineString.prototype, {\n\taddToResult: function addToResult(seg) {\n\t\tthis._resultSegs.add(seg);\n\t},\n\tasLineString: function asLineString() {\n\t\treturn this._parentLine.getFactory().createLineString(TaggedLineString.extractCoordinates(this._resultSegs));\n\t},\n\tgetResultSize: function getResultSize() {\n\t\tvar resultSegsSize = this._resultSegs.size();\n\t\treturn resultSegsSize === 0 ? 0 : resultSegsSize + 1;\n\t},\n\tgetParent: function getParent() {\n\t\treturn this._parentLine;\n\t},\n\tgetSegment: function getSegment(i) {\n\t\treturn this._segs[i];\n\t},\n\tgetParentCoordinates: function getParentCoordinates() {\n\t\treturn this._parentLine.getCoordinates();\n\t},\n\tgetMinimumSize: function getMinimumSize() {\n\t\treturn this._minimumSize;\n\t},\n\tasLinearRing: function asLinearRing() {\n\t\treturn this._parentLine.getFactory().createLinearRing(TaggedLineString.extractCoordinates(this._resultSegs));\n\t},\n\tgetSegments: function getSegments() {\n\t\treturn this._segs;\n\t},\n\tinit: function init() {\n\t\tvar pts = this._parentLine.getCoordinates();\n\t\tthis._segs = new Array(pts.length - 1).fill(null);\n\t\tfor (var i = 0; i < pts.length - 1; i++) {\n\t\t\tvar seg = new TaggedLineSegment(pts[i], pts[i + 1], this._parentLine, i);\n\t\t\tthis._segs[i] = seg;\n\t\t}\n\t},\n\tgetResultCoordinates: function getResultCoordinates() {\n\t\treturn TaggedLineString.extractCoordinates(this._resultSegs);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn TaggedLineString;\n\t}\n});\nTaggedLineString.extractCoordinates = function (segs) {\n\tvar pts = new Array(segs.size() + 1).fill(null);\n\tvar seg = null;\n\tfor (var i = 0; i < segs.size(); i++) {\n\t\tseg = segs.get(i);\n\t\tpts[i] = seg.p0;\n\t}\n\tpts[pts.length - 1] = seg.p1;\n\treturn pts;\n};\n\nfunction LineSegmentIndex() {\n\tthis._index = new Quadtree();\n}\nextend(LineSegmentIndex.prototype, {\n\tremove: function remove(seg) {\n\t\tthis._index.remove(new Envelope(seg.p0, seg.p1), seg);\n\t},\n\tadd: function add() {\n\t\tif (arguments[0] instanceof TaggedLineString) {\n\t\t\tvar line = arguments[0];\n\t\t\tvar segs = line.getSegments();\n\t\t\tfor (var i = 0; i < segs.length; i++) {\n\t\t\t\tvar seg = segs[i];\n\t\t\t\tthis.add(seg);\n\t\t\t}\n\t\t} else if (arguments[0] instanceof LineSegment) {\n\t\t\tvar seg = arguments[0];\n\t\t\tthis._index.insert(new Envelope(seg.p0, seg.p1), seg);\n\t\t}\n\t},\n\tquery: function query(querySeg) {\n\t\tvar env = new Envelope(querySeg.p0, querySeg.p1);\n\t\tvar visitor = new LineSegmentVisitor(querySeg);\n\t\tthis._index.query(env, visitor);\n\t\tvar itemsFound = visitor.getItems();\n\t\treturn itemsFound;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn LineSegmentIndex;\n\t}\n});\nfunction LineSegmentVisitor() {\n\tthis._querySeg = null;\n\tthis._items = new ArrayList();\n\tvar querySeg = arguments[0];\n\tthis._querySeg = querySeg;\n}\nextend(LineSegmentVisitor.prototype, {\n\tvisitItem: function visitItem(item) {\n\t\tvar seg = item;\n\t\tif (Envelope.intersects(seg.p0, seg.p1, this._querySeg.p0, this._querySeg.p1)) this._items.add(item);\n\t},\n\tgetItems: function getItems() {\n\t\treturn this._items;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [ItemVisitor];\n\t},\n\tgetClass: function getClass() {\n\t\treturn LineSegmentVisitor;\n\t}\n});\n\nfunction TaggedLineStringSimplifier() {\n\tthis._li = new RobustLineIntersector();\n\tthis._inputIndex = new LineSegmentIndex();\n\tthis._outputIndex = new LineSegmentIndex();\n\tthis._line = null;\n\tthis._linePts = null;\n\tthis._distanceTolerance = 0.0;\n\tvar inputIndex = arguments[0],\n\t    outputIndex = arguments[1];\n\tthis._inputIndex = inputIndex;\n\tthis._outputIndex = outputIndex;\n}\nextend(TaggedLineStringSimplifier.prototype, {\n\tflatten: function flatten(start, end) {\n\t\tvar p0 = this._linePts[start];\n\t\tvar p1 = this._linePts[end];\n\t\tvar newSeg = new LineSegment(p0, p1);\n\t\tthis.remove(this._line, start, end);\n\t\tthis._outputIndex.add(newSeg);\n\t\treturn newSeg;\n\t},\n\thasBadIntersection: function hasBadIntersection(parentLine, sectionIndex, candidateSeg) {\n\t\tif (this.hasBadOutputIntersection(candidateSeg)) return true;\n\t\tif (this.hasBadInputIntersection(parentLine, sectionIndex, candidateSeg)) return true;\n\t\treturn false;\n\t},\n\tsetDistanceTolerance: function setDistanceTolerance(distanceTolerance) {\n\t\tthis._distanceTolerance = distanceTolerance;\n\t},\n\tsimplifySection: function simplifySection(i, j, depth) {\n\t\tdepth += 1;\n\t\tvar sectionIndex = new Array(2).fill(null);\n\t\tif (i + 1 === j) {\n\t\t\tvar newSeg = this._line.getSegment(i);\n\t\t\tthis._line.addToResult(newSeg);\n\t\t\treturn null;\n\t\t}\n\t\tvar isValidToSimplify = true;\n\t\tif (this._line.getResultSize() < this._line.getMinimumSize()) {\n\t\t\tvar worstCaseSize = depth + 1;\n\t\t\tif (worstCaseSize < this._line.getMinimumSize()) isValidToSimplify = false;\n\t\t}\n\t\tvar distance = new Array(1).fill(null);\n\t\tvar furthestPtIndex = this.findFurthestPoint(this._linePts, i, j, distance);\n\t\tif (distance[0] > this._distanceTolerance) isValidToSimplify = false;\n\t\tvar candidateSeg = new LineSegment();\n\t\tcandidateSeg.p0 = this._linePts[i];\n\t\tcandidateSeg.p1 = this._linePts[j];\n\t\tsectionIndex[0] = i;\n\t\tsectionIndex[1] = j;\n\t\tif (this.hasBadIntersection(this._line, sectionIndex, candidateSeg)) isValidToSimplify = false;\n\t\tif (isValidToSimplify) {\n\t\t\tvar newSeg = this.flatten(i, j);\n\t\t\tthis._line.addToResult(newSeg);\n\t\t\treturn null;\n\t\t}\n\t\tthis.simplifySection(i, furthestPtIndex, depth);\n\t\tthis.simplifySection(furthestPtIndex, j, depth);\n\t},\n\thasBadOutputIntersection: function hasBadOutputIntersection(candidateSeg) {\n\t\tvar querySegs = this._outputIndex.query(candidateSeg);\n\t\tfor (var i = querySegs.iterator(); i.hasNext();) {\n\t\t\tvar querySeg = i.next();\n\t\t\tif (this.hasInteriorIntersection(querySeg, candidateSeg)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tfindFurthestPoint: function findFurthestPoint(pts, i, j, maxDistance) {\n\t\tvar seg = new LineSegment();\n\t\tseg.p0 = pts[i];\n\t\tseg.p1 = pts[j];\n\t\tvar maxDist = -1.0;\n\t\tvar maxIndex = i;\n\t\tfor (var k = i + 1; k < j; k++) {\n\t\t\tvar midPt = pts[k];\n\t\t\tvar distance = seg.distance(midPt);\n\t\t\tif (distance > maxDist) {\n\t\t\t\tmaxDist = distance;\n\t\t\t\tmaxIndex = k;\n\t\t\t}\n\t\t}\n\t\tmaxDistance[0] = maxDist;\n\t\treturn maxIndex;\n\t},\n\tsimplify: function simplify(line) {\n\t\tthis._line = line;\n\t\tthis._linePts = line.getParentCoordinates();\n\t\tthis.simplifySection(0, this._linePts.length - 1, 0);\n\t},\n\tremove: function remove(line, start, end) {\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar seg = line.getSegment(i);\n\t\t\tthis._inputIndex.remove(seg);\n\t\t}\n\t},\n\thasInteriorIntersection: function hasInteriorIntersection(seg0, seg1) {\n\t\tthis._li.computeIntersection(seg0.p0, seg0.p1, seg1.p0, seg1.p1);\n\t\treturn this._li.isInteriorIntersection();\n\t},\n\thasBadInputIntersection: function hasBadInputIntersection(parentLine, sectionIndex, candidateSeg) {\n\t\tvar querySegs = this._inputIndex.query(candidateSeg);\n\t\tfor (var i = querySegs.iterator(); i.hasNext();) {\n\t\t\tvar querySeg = i.next();\n\t\t\tif (this.hasInteriorIntersection(querySeg, candidateSeg)) {\n\t\t\t\tif (TaggedLineStringSimplifier.isInLineSection(parentLine, sectionIndex, querySeg)) continue;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn TaggedLineStringSimplifier;\n\t}\n});\nTaggedLineStringSimplifier.isInLineSection = function (line, sectionIndex, seg) {\n\tif (seg.getParent() !== line.getParent()) return false;\n\tvar segIndex = seg.getIndex();\n\tif (segIndex >= sectionIndex[0] && segIndex < sectionIndex[1]) return true;\n\treturn false;\n};\n\nfunction TaggedLinesSimplifier() {\n\tthis._inputIndex = new LineSegmentIndex();\n\tthis._outputIndex = new LineSegmentIndex();\n\tthis._distanceTolerance = 0.0;\n}\nextend(TaggedLinesSimplifier.prototype, {\n\tsetDistanceTolerance: function setDistanceTolerance(distanceTolerance) {\n\t\tthis._distanceTolerance = distanceTolerance;\n\t},\n\tsimplify: function simplify(taggedLines) {\n\t\tfor (var i = taggedLines.iterator(); i.hasNext();) {\n\t\t\tthis._inputIndex.add(i.next());\n\t\t}\n\t\tfor (var i = taggedLines.iterator(); i.hasNext();) {\n\t\t\tvar tlss = new TaggedLineStringSimplifier(this._inputIndex, this._outputIndex);\n\t\t\ttlss.setDistanceTolerance(this._distanceTolerance);\n\t\t\ttlss.simplify(i.next());\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn TaggedLinesSimplifier;\n\t}\n});\n\nfunction TopologyPreservingSimplifier() {\n\tthis._inputGeom = null;\n\tthis._lineSimplifier = new TaggedLinesSimplifier();\n\tthis._linestringMap = null;\n\tvar inputGeom = arguments[0];\n\tthis._inputGeom = inputGeom;\n}\nextend(TopologyPreservingSimplifier.prototype, {\n\tgetResultGeometry: function getResultGeometry() {\n\t\tif (this._inputGeom.isEmpty()) return this._inputGeom.copy();\n\t\tthis._linestringMap = new HashMap();\n\t\tthis._inputGeom.apply(new LineStringMapBuilderFilter(this));\n\t\tthis._lineSimplifier.simplify(this._linestringMap.values());\n\t\tvar result = new LineStringTransformer(this._linestringMap).transform(this._inputGeom);\n\t\treturn result;\n\t},\n\tsetDistanceTolerance: function setDistanceTolerance(distanceTolerance) {\n\t\tif (distanceTolerance < 0.0) throw new IllegalArgumentException(\"Tolerance must be non-negative\");\n\t\tthis._lineSimplifier.setDistanceTolerance(distanceTolerance);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn TopologyPreservingSimplifier;\n\t}\n});\nTopologyPreservingSimplifier.simplify = function (geom, distanceTolerance) {\n\tvar tss = new TopologyPreservingSimplifier(geom);\n\ttss.setDistanceTolerance(distanceTolerance);\n\treturn tss.getResultGeometry();\n};\nfunction LineStringTransformer() {\n\tGeometryTransformer.apply(this);\n\tthis._linestringMap = null;\n\tvar linestringMap = arguments[0];\n\tthis._linestringMap = linestringMap;\n}\ninherits$1(LineStringTransformer, GeometryTransformer);\nextend(LineStringTransformer.prototype, {\n\ttransformCoordinates: function transformCoordinates(coords, parent) {\n\t\tif (coords.size() === 0) return null;\n\t\tif (parent instanceof LineString) {\n\t\t\tvar taggedLine = this._linestringMap.get(parent);\n\t\t\treturn this.createCoordinateSequence(taggedLine.getResultCoordinates());\n\t\t}\n\t\treturn GeometryTransformer.prototype.transformCoordinates.call(this, coords, parent);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn LineStringTransformer;\n\t}\n});\nfunction LineStringMapBuilderFilter() {\n\tthis.tps = null;\n\tvar tps = arguments[0];\n\tthis.tps = tps;\n}\nextend(LineStringMapBuilderFilter.prototype, {\n\tfilter: function filter(geom) {\n\t\tif (geom instanceof LineString) {\n\t\t\tvar line = geom;\n\t\t\tif (line.isEmpty()) return null;\n\t\t\tvar minSize = line.isClosed() ? 4 : 2;\n\t\t\tvar taggedLine = new TaggedLineString(line, minSize);\n\t\t\tthis.tps._linestringMap.put(line, taggedLine);\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [GeometryComponentFilter];\n\t},\n\tgetClass: function getClass() {\n\t\treturn LineStringMapBuilderFilter;\n\t}\n});\nTopologyPreservingSimplifier.LineStringTransformer = LineStringTransformer;\nTopologyPreservingSimplifier.LineStringMapBuilderFilter = LineStringMapBuilderFilter;\n\nfunction SplitSegment() {\n\tthis._seg = null;\n\tthis._segLen = null;\n\tthis._splitPt = null;\n\tthis._minimumLen = 0.0;\n\tvar seg = arguments[0];\n\tthis._seg = seg;\n\tthis._segLen = seg.getLength();\n}\nextend(SplitSegment.prototype, {\n\tsplitAt: function splitAt() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar pt = arguments[0];\n\t\t\tvar minFrac = this._minimumLen / this._segLen;\n\t\t\tif (pt.distance(this._seg.p0) < this._minimumLen) {\n\t\t\t\tthis._splitPt = this._seg.pointAlong(minFrac);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (pt.distance(this._seg.p1) < this._minimumLen) {\n\t\t\t\tthis._splitPt = SplitSegment.pointAlongReverse(this._seg, minFrac);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tthis._splitPt = pt;\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar length = arguments[0],\n\t\t\t    endPt = arguments[1];\n\t\t\tvar actualLen = this.getConstrainedLength(length);\n\t\t\tvar frac = actualLen / this._segLen;\n\t\t\tif (endPt.equals2D(this._seg.p0)) this._splitPt = this._seg.pointAlong(frac);else this._splitPt = SplitSegment.pointAlongReverse(this._seg, frac);\n\t\t}\n\t},\n\tsetMinimumLength: function setMinimumLength(minLen) {\n\t\tthis._minimumLen = minLen;\n\t},\n\tgetConstrainedLength: function getConstrainedLength(len) {\n\t\tif (len < this._minimumLen) return this._minimumLen;\n\t\treturn len;\n\t},\n\tgetSplitPoint: function getSplitPoint() {\n\t\treturn this._splitPt;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn SplitSegment;\n\t}\n});\nSplitSegment.pointAlongReverse = function (seg, segmentLengthFraction) {\n\tvar coord = new Coordinate();\n\tcoord.x = seg.p1.x - segmentLengthFraction * (seg.p1.x - seg.p0.x);\n\tcoord.y = seg.p1.y - segmentLengthFraction * (seg.p1.y - seg.p0.y);\n\treturn coord;\n};\n\nfunction ConstraintSplitPointFinder() {}\nextend(ConstraintSplitPointFinder.prototype, {\n\tfindSplitPoint: function findSplitPoint(seg, encroachPt) {},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn ConstraintSplitPointFinder;\n\t}\n});\n\nfunction NonEncroachingSplitPointFinder() {}\nextend(NonEncroachingSplitPointFinder.prototype, {\n\tfindSplitPoint: function findSplitPoint(seg, encroachPt) {\n\t\tvar lineSeg = seg.getLineSegment();\n\t\tvar segLen = lineSeg.getLength();\n\t\tvar midPtLen = segLen / 2;\n\t\tvar splitSeg = new SplitSegment(lineSeg);\n\t\tvar projPt = NonEncroachingSplitPointFinder.projectedSplitPoint(seg, encroachPt);\n\t\tvar nonEncroachDiam = projPt.distance(encroachPt) * 2 * 0.8;\n\t\tvar maxSplitLen = nonEncroachDiam;\n\t\tif (maxSplitLen > midPtLen) {\n\t\t\tmaxSplitLen = midPtLen;\n\t\t}\n\t\tsplitSeg.setMinimumLength(maxSplitLen);\n\t\tsplitSeg.splitAt(projPt);\n\t\treturn splitSeg.getSplitPoint();\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [ConstraintSplitPointFinder];\n\t},\n\tgetClass: function getClass() {\n\t\treturn NonEncroachingSplitPointFinder;\n\t}\n});\nNonEncroachingSplitPointFinder.projectedSplitPoint = function (seg, encroachPt) {\n\tvar lineSeg = seg.getLineSegment();\n\tvar projPt = lineSeg.project(encroachPt);\n\treturn projPt;\n};\n\nfunction TrianglePredicate() {}\nextend(TrianglePredicate.prototype, {\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn TrianglePredicate;\n\t}\n});\nTrianglePredicate.triArea = function (a, b, c) {\n\treturn (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n};\nTrianglePredicate.isInCircleDDNormalized = function (a, b, c, p) {\n\tvar adx = DD.valueOf(a.x).selfSubtract(p.x);\n\tvar ady = DD.valueOf(a.y).selfSubtract(p.y);\n\tvar bdx = DD.valueOf(b.x).selfSubtract(p.x);\n\tvar bdy = DD.valueOf(b.y).selfSubtract(p.y);\n\tvar cdx = DD.valueOf(c.x).selfSubtract(p.x);\n\tvar cdy = DD.valueOf(c.y).selfSubtract(p.y);\n\tvar abdet = adx.multiply(bdy).selfSubtract(bdx.multiply(ady));\n\tvar bcdet = bdx.multiply(cdy).selfSubtract(cdx.multiply(bdy));\n\tvar cadet = cdx.multiply(ady).selfSubtract(adx.multiply(cdy));\n\tvar alift = adx.multiply(adx).selfAdd(ady.multiply(ady));\n\tvar blift = bdx.multiply(bdx).selfAdd(bdy.multiply(bdy));\n\tvar clift = cdx.multiply(cdx).selfAdd(cdy.multiply(cdy));\n\tvar sum = alift.selfMultiply(bcdet).selfAdd(blift.selfMultiply(cadet)).selfAdd(clift.selfMultiply(abdet));\n\tvar isInCircle = sum.doubleValue() > 0;\n\treturn isInCircle;\n};\nTrianglePredicate.checkRobustInCircle = function (a, b, c, p) {\n\tvar nonRobustInCircle = TrianglePredicate.isInCircleNonRobust(a, b, c, p);\n\tvar isInCircleDD = TrianglePredicate.isInCircleDDSlow(a, b, c, p);\n\tvar isInCircleCC = TrianglePredicate.isInCircleCC(a, b, c, p);\n\tvar circumCentre = Triangle$1.circumcentre(a, b, c);\n\tSystem.out.println(\"p radius diff a = \" + Math.abs(p.distance(circumCentre) - a.distance(circumCentre)) / a.distance(circumCentre));\n\tif (nonRobustInCircle !== isInCircleDD || nonRobustInCircle !== isInCircleCC) {\n\t\tSystem.out.println(\"inCircle robustness failure (double result = \" + nonRobustInCircle + \", DD result = \" + isInCircleDD + \", CC result = \" + isInCircleCC + \")\");\n\t\tSystem.out.println(WKTWriter.toLineString(new CoordinateArraySequence([a, b, c, p])));\n\t\tSystem.out.println(\"Circumcentre = \" + WKTWriter.toPoint(circumCentre) + \" radius = \" + a.distance(circumCentre));\n\t\tSystem.out.println(\"p radius diff a = \" + Math.abs(p.distance(circumCentre) / a.distance(circumCentre) - 1));\n\t\tSystem.out.println(\"p radius diff b = \" + Math.abs(p.distance(circumCentre) / b.distance(circumCentre) - 1));\n\t\tSystem.out.println(\"p radius diff c = \" + Math.abs(p.distance(circumCentre) / c.distance(circumCentre) - 1));\n\t\tSystem.out.println();\n\t}\n};\nTrianglePredicate.isInCircleDDFast = function (a, b, c, p) {\n\tvar aTerm = DD.sqr(a.x).selfAdd(DD.sqr(a.y)).selfMultiply(TrianglePredicate.triAreaDDFast(b, c, p));\n\tvar bTerm = DD.sqr(b.x).selfAdd(DD.sqr(b.y)).selfMultiply(TrianglePredicate.triAreaDDFast(a, c, p));\n\tvar cTerm = DD.sqr(c.x).selfAdd(DD.sqr(c.y)).selfMultiply(TrianglePredicate.triAreaDDFast(a, b, p));\n\tvar pTerm = DD.sqr(p.x).selfAdd(DD.sqr(p.y)).selfMultiply(TrianglePredicate.triAreaDDFast(a, b, c));\n\tvar sum = aTerm.selfSubtract(bTerm).selfAdd(cTerm).selfSubtract(pTerm);\n\tvar isInCircle = sum.doubleValue() > 0;\n\treturn isInCircle;\n};\nTrianglePredicate.isInCircleCC = function (a, b, c, p) {\n\tvar cc = Triangle$1.circumcentre(a, b, c);\n\tvar ccRadius = a.distance(cc);\n\tvar pRadiusDiff = p.distance(cc) - ccRadius;\n\treturn pRadiusDiff <= 0;\n};\nTrianglePredicate.isInCircleNormalized = function (a, b, c, p) {\n\tvar adx = a.x - p.x;\n\tvar ady = a.y - p.y;\n\tvar bdx = b.x - p.x;\n\tvar bdy = b.y - p.y;\n\tvar cdx = c.x - p.x;\n\tvar cdy = c.y - p.y;\n\tvar abdet = adx * bdy - bdx * ady;\n\tvar bcdet = bdx * cdy - cdx * bdy;\n\tvar cadet = cdx * ady - adx * cdy;\n\tvar alift = adx * adx + ady * ady;\n\tvar blift = bdx * bdx + bdy * bdy;\n\tvar clift = cdx * cdx + cdy * cdy;\n\tvar disc = alift * bcdet + blift * cadet + clift * abdet;\n\treturn disc > 0;\n};\nTrianglePredicate.isInCircleDDSlow = function (a, b, c, p) {\n\tvar px = DD.valueOf(p.x);\n\tvar py = DD.valueOf(p.y);\n\tvar ax = DD.valueOf(a.x);\n\tvar ay = DD.valueOf(a.y);\n\tvar bx = DD.valueOf(b.x);\n\tvar by = DD.valueOf(b.y);\n\tvar cx = DD.valueOf(c.x);\n\tvar cy = DD.valueOf(c.y);\n\tvar aTerm = ax.multiply(ax).add(ay.multiply(ay)).multiply(TrianglePredicate.triAreaDDSlow(bx, by, cx, cy, px, py));\n\tvar bTerm = bx.multiply(bx).add(by.multiply(by)).multiply(TrianglePredicate.triAreaDDSlow(ax, ay, cx, cy, px, py));\n\tvar cTerm = cx.multiply(cx).add(cy.multiply(cy)).multiply(TrianglePredicate.triAreaDDSlow(ax, ay, bx, by, px, py));\n\tvar pTerm = px.multiply(px).add(py.multiply(py)).multiply(TrianglePredicate.triAreaDDSlow(ax, ay, bx, by, cx, cy));\n\tvar sum = aTerm.subtract(bTerm).add(cTerm).subtract(pTerm);\n\tvar isInCircle = sum.doubleValue() > 0;\n\treturn isInCircle;\n};\nTrianglePredicate.isInCircleNonRobust = function (a, b, c, p) {\n\tvar isInCircle = (a.x * a.x + a.y * a.y) * TrianglePredicate.triArea(b, c, p) - (b.x * b.x + b.y * b.y) * TrianglePredicate.triArea(a, c, p) + (c.x * c.x + c.y * c.y) * TrianglePredicate.triArea(a, b, p) - (p.x * p.x + p.y * p.y) * TrianglePredicate.triArea(a, b, c) > 0;\n\treturn isInCircle;\n};\nTrianglePredicate.isInCircleRobust = function (a, b, c, p) {\n\treturn TrianglePredicate.isInCircleNormalized(a, b, c, p);\n};\nTrianglePredicate.triAreaDDSlow = function (ax, ay, bx, by, cx, cy) {\n\treturn bx.subtract(ax).multiply(cy.subtract(ay)).subtract(by.subtract(ay).multiply(cx.subtract(ax)));\n};\nTrianglePredicate.triAreaDDFast = function (a, b, c) {\n\tvar t1 = DD.valueOf(b.x).selfSubtract(a.x).selfMultiply(DD.valueOf(c.y).selfSubtract(a.y));\n\tvar t2 = DD.valueOf(b.y).selfSubtract(a.y).selfMultiply(DD.valueOf(c.x).selfSubtract(a.x));\n\treturn t1.selfSubtract(t2);\n};\n\nfunction Vertex() {\n\tthis._p = null;\n\tif (arguments.length === 1) {\n\t\tvar _p = arguments[0];\n\t\tthis._p = new Coordinate(_p);\n\t} else if (arguments.length === 2) {\n\t\tvar _x = arguments[0],\n\t\t    _y = arguments[1];\n\t\tthis._p = new Coordinate(_x, _y);\n\t} else if (arguments.length === 3) {\n\t\tvar _x = arguments[0],\n\t\t    _y = arguments[1],\n\t\t    _z = arguments[2];\n\t\tthis._p = new Coordinate(_x, _y, _z);\n\t}\n}\nextend(Vertex.prototype, {\n\tcircleCenter: function circleCenter(b, c) {\n\t\tvar a = new Vertex(this.getX(), this.getY());\n\t\tvar cab = this.bisector(a, b);\n\t\tvar cbc = this.bisector(b, c);\n\t\tvar hcc = new HCoordinate(cab, cbc);\n\t\tvar cc = null;\n\t\ttry {\n\t\t\tcc = new Vertex(hcc.getX(), hcc.getY());\n\t\t} catch (nre) {\n\t\t\tif (nre instanceof NotRepresentableException) {\n\t\t\t\tSystem.err.println(\"a: \" + a + \"  b: \" + b + \"  c: \" + c);\n\t\t\t\tSystem.err.println(nre);\n\t\t\t} else throw nre;\n\t\t} finally {}\n\t\treturn cc;\n\t},\n\tdot: function dot(v) {\n\t\treturn this._p.x * v.getX() + this._p.y * v.getY();\n\t},\n\tmagn: function magn() {\n\t\treturn Math.sqrt(this._p.x * this._p.x + this._p.y * this._p.y);\n\t},\n\tgetZ: function getZ() {\n\t\treturn this._p.z;\n\t},\n\tbisector: function bisector(a, b) {\n\t\tvar dx = b.getX() - a.getX();\n\t\tvar dy = b.getY() - a.getY();\n\t\tvar l1 = new HCoordinate(a.getX() + dx / 2.0, a.getY() + dy / 2.0, 1.0);\n\t\tvar l2 = new HCoordinate(a.getX() - dy + dx / 2.0, a.getY() + dx + dy / 2.0, 1.0);\n\t\treturn new HCoordinate(l1, l2);\n\t},\n\tequals: function equals() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar _x = arguments[0];\n\t\t\tif (this._p.x === _x.getX() && this._p.y === _x.getY()) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar _x = arguments[0],\n\t\t\t    tolerance = arguments[1];\n\t\t\tif (this._p.distance(_x.getCoordinate()) < tolerance) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t},\n\tgetCoordinate: function getCoordinate() {\n\t\treturn this._p;\n\t},\n\tisInCircle: function isInCircle(a, b, c) {\n\t\treturn TrianglePredicate.isInCircleRobust(a._p, b._p, c._p, this._p);\n\t},\n\tinterpolateZValue: function interpolateZValue(v0, v1, v2) {\n\t\tvar x0 = v0.getX();\n\t\tvar y0 = v0.getY();\n\t\tvar a = v1.getX() - x0;\n\t\tvar b = v2.getX() - x0;\n\t\tvar c = v1.getY() - y0;\n\t\tvar d = v2.getY() - y0;\n\t\tvar det = a * d - b * c;\n\t\tvar dx = this.getX() - x0;\n\t\tvar dy = this.getY() - y0;\n\t\tvar t = (d * dx - b * dy) / det;\n\t\tvar u = (-c * dx + a * dy) / det;\n\t\tvar z = v0.getZ() + t * (v1.getZ() - v0.getZ()) + u * (v2.getZ() - v0.getZ());\n\t\treturn z;\n\t},\n\tmidPoint: function midPoint(a) {\n\t\tvar xm = (this._p.x + a.getX()) / 2.0;\n\t\tvar ym = (this._p.y + a.getY()) / 2.0;\n\t\tvar zm = (this._p.z + a.getZ()) / 2.0;\n\t\treturn new Vertex(xm, ym, zm);\n\t},\n\trightOf: function rightOf(e) {\n\t\treturn this.isCCW(e.dest(), e.orig());\n\t},\n\tisCCW: function isCCW(b, c) {\n\t\treturn (b._p.x - this._p.x) * (c._p.y - this._p.y) - (b._p.y - this._p.y) * (c._p.x - this._p.x) > 0;\n\t},\n\tgetX: function getX() {\n\t\treturn this._p.x;\n\t},\n\tcrossProduct: function crossProduct(v) {\n\t\treturn this._p.x * v.getY() - this._p.y * v.getX();\n\t},\n\tsetZ: function setZ(_z) {\n\t\tthis._p.z = _z;\n\t},\n\ttimes: function times(c) {\n\t\treturn new Vertex(c * this._p.x, c * this._p.y);\n\t},\n\tcross: function cross() {\n\t\treturn new Vertex(this._p.y, -this._p.x);\n\t},\n\tleftOf: function leftOf(e) {\n\t\treturn this.isCCW(e.orig(), e.dest());\n\t},\n\ttoString: function toString() {\n\t\treturn \"POINT (\" + this._p.x + \" \" + this._p.y + \")\";\n\t},\n\tsub: function sub(v) {\n\t\treturn new Vertex(this._p.x - v.getX(), this._p.y - v.getY());\n\t},\n\tgetY: function getY() {\n\t\treturn this._p.y;\n\t},\n\tclassify: function classify(p0, p1) {\n\t\tvar p2 = this;\n\t\tvar a = p1.sub(p0);\n\t\tvar b = p2.sub(p0);\n\t\tvar sa = a.crossProduct(b);\n\t\tif (sa > 0.0) return Vertex.LEFT;\n\t\tif (sa < 0.0) return Vertex.RIGHT;\n\t\tif (a.getX() * b.getX() < 0.0 || a.getY() * b.getY() < 0.0) return Vertex.BEHIND;\n\t\tif (a.magn() < b.magn()) return Vertex.BEYOND;\n\t\tif (p0.equals(p2)) return Vertex.ORIGIN;\n\t\tif (p1.equals(p2)) return Vertex.DESTINATION;\n\t\treturn Vertex.BETWEEN;\n\t},\n\tsum: function sum(v) {\n\t\treturn new Vertex(this._p.x + v.getX(), this._p.y + v.getY());\n\t},\n\tdistance: function distance(v1, v2) {\n\t\treturn Math.sqrt(Math.pow(v2.getX() - v1.getX(), 2.0) + Math.pow(v2.getY() - v1.getY(), 2.0));\n\t},\n\tcircumRadiusRatio: function circumRadiusRatio(b, c) {\n\t\tvar x = this.circleCenter(b, c);\n\t\tvar radius = this.distance(x, b);\n\t\tvar edgeLength = this.distance(this, b);\n\t\tvar el = this.distance(b, c);\n\t\tif (el < edgeLength) {\n\t\t\tedgeLength = el;\n\t\t}\n\t\tel = this.distance(c, this);\n\t\tif (el < edgeLength) {\n\t\t\tedgeLength = el;\n\t\t}\n\t\treturn radius / edgeLength;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Vertex;\n\t}\n});\nVertex.interpolateZ = function () {\n\tif (arguments.length === 3) {\n\t\tvar p = arguments[0],\n\t\t    p0 = arguments[1],\n\t\t    p1 = arguments[2];\n\t\tvar segLen = p0.distance(p1);\n\t\tvar ptLen = p.distance(p0);\n\t\tvar dz = p1.z - p0.z;\n\t\tvar pz = p0.z + dz * (ptLen / segLen);\n\t\treturn pz;\n\t} else if (arguments.length === 4) {\n\t\tvar p = arguments[0],\n\t\t    v0 = arguments[1],\n\t\t    v1 = arguments[2],\n\t\t    v2 = arguments[3];\n\t\tvar x0 = v0.x;\n\t\tvar y0 = v0.y;\n\t\tvar a = v1.x - x0;\n\t\tvar b = v2.x - x0;\n\t\tvar c = v1.y - y0;\n\t\tvar d = v2.y - y0;\n\t\tvar det = a * d - b * c;\n\t\tvar dx = p.x - x0;\n\t\tvar dy = p.y - y0;\n\t\tvar t = (d * dx - b * dy) / det;\n\t\tvar u = (-c * dx + a * dy) / det;\n\t\tvar z = v0.z + t * (v1.z - v0.z) + u * (v2.z - v0.z);\n\t\treturn z;\n\t}\n};\nVertex.LEFT = 0;\nVertex.RIGHT = 1;\nVertex.BEYOND = 2;\nVertex.BEHIND = 3;\nVertex.BETWEEN = 4;\nVertex.ORIGIN = 5;\nVertex.DESTINATION = 6;\n\nfunction ConstraintVertex() {\n\tthis._isOnConstraint = null;\n\tthis._constraint = null;\n\tvar p = arguments[0];\n\tVertex.call(this, p);\n}\ninherits$1(ConstraintVertex, Vertex);\nextend(ConstraintVertex.prototype, {\n\tgetConstraint: function getConstraint() {\n\t\treturn this._constraint;\n\t},\n\tsetOnConstraint: function setOnConstraint(isOnConstraint) {\n\t\tthis._isOnConstraint = isOnConstraint;\n\t},\n\tmerge: function merge(other) {\n\t\tif (other._isOnConstraint) {\n\t\t\tthis._isOnConstraint = true;\n\t\t\tthis._constraint = other._constraint;\n\t\t}\n\t},\n\tisOnConstraint: function isOnConstraint() {\n\t\treturn this._isOnConstraint;\n\t},\n\tsetConstraint: function setConstraint(constraint) {\n\t\tthis._isOnConstraint = true;\n\t\tthis._constraint = constraint;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn ConstraintVertex;\n\t}\n});\n\nfunction QuadEdge() {\n\tthis._rot = null;\n\tthis._vertex = null;\n\tthis._next = null;\n\tthis._data = null;\n}\nextend(QuadEdge.prototype, {\n\tequalsNonOriented: function equalsNonOriented(qe) {\n\t\tif (this.equalsOriented(qe)) return true;\n\t\tif (this.equalsOriented(qe.sym())) return true;\n\t\treturn false;\n\t},\n\ttoLineSegment: function toLineSegment() {\n\t\treturn new LineSegment(this._vertex.getCoordinate(), this.dest().getCoordinate());\n\t},\n\tdest: function dest() {\n\t\treturn this.sym().orig();\n\t},\n\toNext: function oNext() {\n\t\treturn this._next;\n\t},\n\tequalsOriented: function equalsOriented(qe) {\n\t\tif (this.orig().getCoordinate().equals2D(qe.orig().getCoordinate()) && this.dest().getCoordinate().equals2D(qe.dest().getCoordinate())) return true;\n\t\treturn false;\n\t},\n\tdNext: function dNext() {\n\t\treturn this.sym().oNext().sym();\n\t},\n\tlPrev: function lPrev() {\n\t\treturn this._next.sym();\n\t},\n\trPrev: function rPrev() {\n\t\treturn this.sym().oNext();\n\t},\n\trot: function rot() {\n\t\treturn this._rot;\n\t},\n\toPrev: function oPrev() {\n\t\treturn this._rot._next._rot;\n\t},\n\tsym: function sym() {\n\t\treturn this._rot._rot;\n\t},\n\tsetOrig: function setOrig(o) {\n\t\tthis._vertex = o;\n\t},\n\tlNext: function lNext() {\n\t\treturn this.invRot().oNext().rot();\n\t},\n\tgetLength: function getLength() {\n\t\treturn this.orig().getCoordinate().distance(this.dest().getCoordinate());\n\t},\n\tinvRot: function invRot() {\n\t\treturn this._rot.sym();\n\t},\n\tsetDest: function setDest(d) {\n\t\tthis.sym().setOrig(d);\n\t},\n\tsetData: function setData(data) {\n\t\tthis._data = data;\n\t},\n\tgetData: function getData() {\n\t\treturn this._data;\n\t},\n\tdelete: function _delete() {\n\t\tthis._rot = null;\n\t},\n\torig: function orig() {\n\t\treturn this._vertex;\n\t},\n\trNext: function rNext() {\n\t\treturn this._rot._next.invRot();\n\t},\n\ttoString: function toString() {\n\t\tvar p0 = this._vertex.getCoordinate();\n\t\tvar p1 = this.dest().getCoordinate();\n\t\treturn WKTWriter.toLineString(p0, p1);\n\t},\n\tisLive: function isLive() {\n\t\treturn this._rot !== null;\n\t},\n\tgetPrimary: function getPrimary() {\n\t\tif (this.orig().getCoordinate().compareTo(this.dest().getCoordinate()) <= 0) return this;else return this.sym();\n\t},\n\tdPrev: function dPrev() {\n\t\treturn this.invRot().oNext().invRot();\n\t},\n\tsetNext: function setNext(next) {\n\t\tthis._next = next;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn QuadEdge;\n\t}\n});\nQuadEdge.makeEdge = function (o, d) {\n\tvar q0 = new QuadEdge();\n\tvar q1 = new QuadEdge();\n\tvar q2 = new QuadEdge();\n\tvar q3 = new QuadEdge();\n\tq0._rot = q1;\n\tq1._rot = q2;\n\tq2._rot = q3;\n\tq3._rot = q0;\n\tq0.setNext(q0);\n\tq1.setNext(q3);\n\tq2.setNext(q2);\n\tq3.setNext(q1);\n\tvar base = q0;\n\tbase.setOrig(o);\n\tbase.setDest(d);\n\treturn base;\n};\nQuadEdge.swap = function (e) {\n\tvar a = e.oPrev();\n\tvar b = e.sym().oPrev();\n\tQuadEdge.splice(e, a);\n\tQuadEdge.splice(e.sym(), b);\n\tQuadEdge.splice(e, a.lNext());\n\tQuadEdge.splice(e.sym(), b.lNext());\n\te.setOrig(a.dest());\n\te.setDest(b.dest());\n};\nQuadEdge.splice = function (a, b) {\n\tvar alpha = a.oNext().rot();\n\tvar beta = b.oNext().rot();\n\tvar t1 = b.oNext();\n\tvar t2 = a.oNext();\n\tvar t3 = beta.oNext();\n\tvar t4 = alpha.oNext();\n\ta.setNext(t1);\n\tb.setNext(t2);\n\talpha.setNext(t3);\n\tbeta.setNext(t4);\n};\nQuadEdge.connect = function (a, b) {\n\tvar e = QuadEdge.makeEdge(a.dest(), b.orig());\n\tQuadEdge.splice(e, a.lNext());\n\tQuadEdge.splice(e.sym(), b);\n\treturn e;\n};\n\nfunction IncrementalDelaunayTriangulator() {\n\tthis._subdiv = null;\n\tthis._isUsingTolerance = false;\n\tvar subdiv = arguments[0];\n\tthis._subdiv = subdiv;\n\tthis._isUsingTolerance = subdiv.getTolerance() > 0.0;\n}\nextend(IncrementalDelaunayTriangulator.prototype, {\n\tinsertSite: function insertSite(v) {\n\t\tvar e = this._subdiv.locate(v);\n\t\tif (this._subdiv.isVertexOfEdge(e, v)) {\n\t\t\treturn e;\n\t\t} else if (this._subdiv.isOnEdge(e, v.getCoordinate())) {\n\t\t\te = e.oPrev();\n\t\t\tthis._subdiv.delete(e.oNext());\n\t\t}\n\t\tvar base = this._subdiv.makeEdge(e.orig(), v);\n\t\tQuadEdge.splice(base, e);\n\t\tvar startEdge = base;\n\t\tdo {\n\t\t\tbase = this._subdiv.connect(e, base.sym());\n\t\t\te = base.oPrev();\n\t\t} while (e.lNext() !== startEdge);\n\t\tdo {\n\t\t\tvar t = e.oPrev();\n\t\t\tif (t.dest().rightOf(e) && v.isInCircle(e.orig(), t.dest(), e.dest())) {\n\t\t\t\tQuadEdge.swap(e);\n\t\t\t\te = e.oPrev();\n\t\t\t} else if (e.oNext() === startEdge) {\n\t\t\t\treturn base;\n\t\t\t} else {\n\t\t\t\te = e.oNext().lPrev();\n\t\t\t}\n\t\t} while (true);\n\t},\n\tinsertSites: function insertSites(vertices) {\n\t\tfor (var i = vertices.iterator(); i.hasNext();) {\n\t\t\tvar v = i.next();\n\t\t\tthis.insertSite(v);\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn IncrementalDelaunayTriangulator;\n\t}\n});\n\nfunction QuadEdgeLocator() {}\nextend(QuadEdgeLocator.prototype, {\n\tlocate: function locate(v) {},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn QuadEdgeLocator;\n\t}\n});\n\nfunction LastFoundQuadEdgeLocator() {\n\tthis._subdiv = null;\n\tthis._lastEdge = null;\n\tvar subdiv = arguments[0];\n\tthis._subdiv = subdiv;\n\tthis.init();\n}\nextend(LastFoundQuadEdgeLocator.prototype, {\n\tinit: function init() {\n\t\tthis._lastEdge = this.findEdge();\n\t},\n\tlocate: function locate(v) {\n\t\tif (!this._lastEdge.isLive()) {\n\t\t\tthis.init();\n\t\t}\n\t\tvar e = this._subdiv.locateFromEdge(v, this._lastEdge);\n\t\tthis._lastEdge = e;\n\t\treturn e;\n\t},\n\tfindEdge: function findEdge() {\n\t\tvar edges = this._subdiv.getEdges();\n\t\treturn edges.iterator().next();\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [QuadEdgeLocator];\n\t},\n\tgetClass: function getClass() {\n\t\treturn LastFoundQuadEdgeLocator;\n\t}\n});\n\nfunction LocateFailureException() {\n\tthis._seg = null;\n\tif (arguments.length === 1) {\n\t\tif (typeof arguments[0] === \"string\") {\n\t\t\tvar msg = arguments[0];\n\t\t\tRuntimeException.call(this, msg);\n\t\t} else if (arguments[0] instanceof LineSegment) {\n\t\t\tvar seg = arguments[0];\n\t\t\tRuntimeException.call(this, \"Locate failed to converge (at edge: \" + seg + \").  Possible causes include invalid Subdivision topology or very close sites\");\n\t\t\tthis._seg = new LineSegment(seg);\n\t\t}\n\t} else if (arguments.length === 2) {\n\t\tvar msg = arguments[0],\n\t\t    seg = arguments[1];\n\t\tRuntimeException.call(this, LocateFailureException.msgWithSpatial(msg, seg));\n\t\tthis._seg = new LineSegment(seg);\n\t}\n}\ninherits$1(LocateFailureException, RuntimeException);\nextend(LocateFailureException.prototype, {\n\tgetSegment: function getSegment() {\n\t\treturn this._seg;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn LocateFailureException;\n\t}\n});\nLocateFailureException.msgWithSpatial = function (msg, seg) {\n\tif (seg !== null) return msg + \" [ \" + seg + \" ]\";\n\treturn msg;\n};\n\nfunction TriangleVisitor() {}\nextend(TriangleVisitor.prototype, {\n\tvisit: function visit(triEdges) {},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn TriangleVisitor;\n\t}\n});\n\nfunction QuadEdgeSubdivision() {\n\tthis._visitedKey = 0;\n\tthis._quadEdges = new ArrayList();\n\tthis._startingEdge = null;\n\tthis._tolerance = null;\n\tthis._edgeCoincidenceTolerance = null;\n\tthis._frameVertex = new Array(3).fill(null);\n\tthis._frameEnv = null;\n\tthis._locator = null;\n\tthis._seg = new LineSegment();\n\tthis._triEdges = new Array(3).fill(null);\n\tvar env = arguments[0],\n\t    tolerance = arguments[1];\n\tthis._tolerance = tolerance;\n\tthis._edgeCoincidenceTolerance = tolerance / QuadEdgeSubdivision.EDGE_COINCIDENCE_TOL_FACTOR;\n\tthis.createFrame(env);\n\tthis._startingEdge = this.initSubdiv();\n\tthis._locator = new LastFoundQuadEdgeLocator(this);\n}\nextend(QuadEdgeSubdivision.prototype, {\n\tgetTriangleVertices: function getTriangleVertices(includeFrame) {\n\t\tvar visitor = new TriangleVertexListVisitor();\n\t\tthis.visitTriangles(visitor, includeFrame);\n\t\treturn visitor.getTriangleVertices();\n\t},\n\tisFrameVertex: function isFrameVertex(v) {\n\t\tif (v.equals(this._frameVertex[0])) return true;\n\t\tif (v.equals(this._frameVertex[1])) return true;\n\t\tif (v.equals(this._frameVertex[2])) return true;\n\t\treturn false;\n\t},\n\tisVertexOfEdge: function isVertexOfEdge(e, v) {\n\t\tif (v.equals(e.orig(), this._tolerance) || v.equals(e.dest(), this._tolerance)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\tconnect: function connect(a, b) {\n\t\tvar q = QuadEdge.connect(a, b);\n\t\tthis._quadEdges.add(q);\n\t\treturn q;\n\t},\n\tgetVoronoiCellPolygon: function getVoronoiCellPolygon(qe, geomFact) {\n\t\tvar cellPts = new ArrayList();\n\t\tvar startQE = qe;\n\t\tdo {\n\t\t\tvar cc = qe.rot().orig().getCoordinate();\n\t\t\tcellPts.add(cc);\n\t\t\tqe = qe.oPrev();\n\t\t} while (qe !== startQE);\n\t\tvar coordList = new CoordinateList();\n\t\tcoordList.addAll(cellPts, false);\n\t\tcoordList.closeRing();\n\t\tif (coordList.size() < 4) {\n\t\t\tSystem.out.println(coordList);\n\t\t\tcoordList.add(coordList.get(coordList.size() - 1), true);\n\t\t}\n\t\tvar pts = coordList.toCoordinateArray();\n\t\tvar cellPoly = geomFact.createPolygon(geomFact.createLinearRing(pts), null);\n\t\tvar v = startQE.orig();\n\t\tcellPoly.setUserData(v.getCoordinate());\n\t\treturn cellPoly;\n\t},\n\tsetLocator: function setLocator(locator) {\n\t\tthis._locator = locator;\n\t},\n\tinitSubdiv: function initSubdiv() {\n\t\tvar ea = this.makeEdge(this._frameVertex[0], this._frameVertex[1]);\n\t\tvar eb = this.makeEdge(this._frameVertex[1], this._frameVertex[2]);\n\t\tQuadEdge.splice(ea.sym(), eb);\n\t\tvar ec = this.makeEdge(this._frameVertex[2], this._frameVertex[0]);\n\t\tQuadEdge.splice(eb.sym(), ec);\n\t\tQuadEdge.splice(ec.sym(), ea);\n\t\treturn ea;\n\t},\n\tisFrameBorderEdge: function isFrameBorderEdge(e) {\n\t\tvar leftTri = new Array(3).fill(null);\n\t\tQuadEdgeSubdivision.getTriangleEdges(e, leftTri);\n\t\tvar rightTri = new Array(3).fill(null);\n\t\tQuadEdgeSubdivision.getTriangleEdges(e.sym(), rightTri);\n\t\tvar vLeftTriOther = e.lNext().dest();\n\t\tif (this.isFrameVertex(vLeftTriOther)) return true;\n\t\tvar vRightTriOther = e.sym().lNext().dest();\n\t\tif (this.isFrameVertex(vRightTriOther)) return true;\n\t\treturn false;\n\t},\n\tmakeEdge: function makeEdge(o, d) {\n\t\tvar q = QuadEdge.makeEdge(o, d);\n\t\tthis._quadEdges.add(q);\n\t\treturn q;\n\t},\n\tvisitTriangles: function visitTriangles(triVisitor, includeFrame) {\n\t\tthis._visitedKey++;\n\t\tvar edgeStack = new Stack$2();\n\t\tedgeStack.push(this._startingEdge);\n\t\tvar visitedEdges = new HashSet();\n\t\twhile (!edgeStack.empty()) {\n\t\t\tvar edge = edgeStack.pop();\n\t\t\tif (!visitedEdges.contains(edge)) {\n\t\t\t\tvar triEdges = this.fetchTriangleToVisit(edge, edgeStack, includeFrame, visitedEdges);\n\t\t\t\tif (triEdges !== null) triVisitor.visit(triEdges);\n\t\t\t}\n\t\t}\n\t},\n\tisFrameEdge: function isFrameEdge(e) {\n\t\tif (this.isFrameVertex(e.orig()) || this.isFrameVertex(e.dest())) return true;\n\t\treturn false;\n\t},\n\tisOnEdge: function isOnEdge(e, p) {\n\t\tthis._seg.setCoordinates(e.orig().getCoordinate(), e.dest().getCoordinate());\n\t\tvar dist = this._seg.distance(p);\n\t\treturn dist < this._edgeCoincidenceTolerance;\n\t},\n\tgetEnvelope: function getEnvelope() {\n\t\treturn new Envelope(this._frameEnv);\n\t},\n\tcreateFrame: function createFrame(env) {\n\t\tvar deltaX = env.getWidth();\n\t\tvar deltaY = env.getHeight();\n\t\tvar offset = 0.0;\n\t\tif (deltaX > deltaY) {\n\t\t\toffset = deltaX * 10.0;\n\t\t} else {\n\t\t\toffset = deltaY * 10.0;\n\t\t}\n\t\tthis._frameVertex[0] = new Vertex((env.getMaxX() + env.getMinX()) / 2.0, env.getMaxY() + offset);\n\t\tthis._frameVertex[1] = new Vertex(env.getMinX() - offset, env.getMinY() - offset);\n\t\tthis._frameVertex[2] = new Vertex(env.getMaxX() + offset, env.getMinY() - offset);\n\t\tthis._frameEnv = new Envelope(this._frameVertex[0].getCoordinate(), this._frameVertex[1].getCoordinate());\n\t\tthis._frameEnv.expandToInclude(this._frameVertex[2].getCoordinate());\n\t},\n\tgetTriangleCoordinates: function getTriangleCoordinates(includeFrame) {\n\t\tvar visitor = new TriangleCoordinatesVisitor();\n\t\tthis.visitTriangles(visitor, includeFrame);\n\t\treturn visitor.getTriangles();\n\t},\n\tgetVertices: function getVertices(includeFrame) {\n\t\tvar vertices = new HashSet();\n\t\tfor (var i = this._quadEdges.iterator(); i.hasNext();) {\n\t\t\tvar qe = i.next();\n\t\t\tvar v = qe.orig();\n\t\t\tif (includeFrame || !this.isFrameVertex(v)) vertices.add(v);\n\t\t\tvar vd = qe.dest();\n\t\t\tif (includeFrame || !this.isFrameVertex(vd)) vertices.add(vd);\n\t\t}\n\t\treturn vertices;\n\t},\n\tfetchTriangleToVisit: function fetchTriangleToVisit(edge, edgeStack, includeFrame, visitedEdges) {\n\t\tvar curr = edge;\n\t\tvar edgeCount = 0;\n\t\tvar isFrame = false;\n\t\tdo {\n\t\t\tthis._triEdges[edgeCount] = curr;\n\t\t\tif (this.isFrameEdge(curr)) isFrame = true;\n\t\t\tvar sym = curr.sym();\n\t\t\tif (!visitedEdges.contains(sym)) edgeStack.push(sym);\n\t\t\tvisitedEdges.add(curr);\n\t\t\tedgeCount++;\n\t\t\tcurr = curr.lNext();\n\t\t} while (curr !== edge);\n\t\tif (isFrame && !includeFrame) return null;\n\t\treturn this._triEdges;\n\t},\n\tgetEdges: function getEdges() {\n\t\tif (arguments.length === 0) {\n\t\t\treturn this._quadEdges;\n\t\t} else if (arguments.length === 1) {\n\t\t\tvar geomFact = arguments[0];\n\t\t\tvar quadEdges = this.getPrimaryEdges(false);\n\t\t\tvar edges = new Array(quadEdges.size()).fill(null);\n\t\t\tvar i = 0;\n\t\t\tfor (var it = quadEdges.iterator(); it.hasNext();) {\n\t\t\t\tvar qe = it.next();\n\t\t\t\tedges[i++] = geomFact.createLineString([qe.orig().getCoordinate(), qe.dest().getCoordinate()]);\n\t\t\t}\n\t\t\treturn geomFact.createMultiLineString(edges);\n\t\t}\n\t},\n\tgetVertexUniqueEdges: function getVertexUniqueEdges(includeFrame) {\n\t\tvar edges = new ArrayList();\n\t\tvar visitedVertices = new HashSet();\n\t\tfor (var i = this._quadEdges.iterator(); i.hasNext();) {\n\t\t\tvar qe = i.next();\n\t\t\tvar v = qe.orig();\n\t\t\tif (!visitedVertices.contains(v)) {\n\t\t\t\tvisitedVertices.add(v);\n\t\t\t\tif (includeFrame || !this.isFrameVertex(v)) {\n\t\t\t\t\tedges.add(qe);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar qd = qe.sym();\n\t\t\tvar vd = qd.orig();\n\t\t\tif (!visitedVertices.contains(vd)) {\n\t\t\t\tvisitedVertices.add(vd);\n\t\t\t\tif (includeFrame || !this.isFrameVertex(vd)) {\n\t\t\t\t\tedges.add(qd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn edges;\n\t},\n\tgetTriangleEdges: function getTriangleEdges(includeFrame) {\n\t\tvar visitor = new TriangleEdgesListVisitor();\n\t\tthis.visitTriangles(visitor, includeFrame);\n\t\treturn visitor.getTriangleEdges();\n\t},\n\tgetPrimaryEdges: function getPrimaryEdges(includeFrame) {\n\t\tthis._visitedKey++;\n\t\tvar edges = new ArrayList();\n\t\tvar edgeStack = new Stack$2();\n\t\tedgeStack.push(this._startingEdge);\n\t\tvar visitedEdges = new HashSet();\n\t\twhile (!edgeStack.empty()) {\n\t\t\tvar edge = edgeStack.pop();\n\t\t\tif (!visitedEdges.contains(edge)) {\n\t\t\t\tvar priQE = edge.getPrimary();\n\t\t\t\tif (includeFrame || !this.isFrameEdge(priQE)) edges.add(priQE);\n\t\t\t\tedgeStack.push(edge.oNext());\n\t\t\t\tedgeStack.push(edge.sym().oNext());\n\t\t\t\tvisitedEdges.add(edge);\n\t\t\t\tvisitedEdges.add(edge.sym());\n\t\t\t}\n\t\t}\n\t\treturn edges;\n\t},\n\tdelete: function _delete(e) {\n\t\tQuadEdge.splice(e, e.oPrev());\n\t\tQuadEdge.splice(e.sym(), e.sym().oPrev());\n\t\tvar eSym = e.sym();\n\t\tvar eRot = e.rot();\n\t\tvar eRotSym = e.rot().sym();\n\t\tthis._quadEdges.remove(e);\n\t\tthis._quadEdges.remove(eSym);\n\t\tthis._quadEdges.remove(eRot);\n\t\tthis._quadEdges.remove(eRotSym);\n\t\te.delete();\n\t\teSym.delete();\n\t\teRot.delete();\n\t\teRotSym.delete();\n\t},\n\tlocateFromEdge: function locateFromEdge(v, startEdge) {\n\t\tvar iter = 0;\n\t\tvar maxIter = this._quadEdges.size();\n\t\tvar e = startEdge;\n\t\twhile (true) {\n\t\t\titer++;\n\t\t\tif (iter > maxIter) {\n\t\t\t\tthrow new LocateFailureException(e.toLineSegment());\n\t\t\t}\n\t\t\tif (v.equals(e.orig()) || v.equals(e.dest())) {\n\t\t\t\tbreak;\n\t\t\t} else if (v.rightOf(e)) {\n\t\t\t\te = e.sym();\n\t\t\t} else if (!v.rightOf(e.oNext())) {\n\t\t\t\te = e.oNext();\n\t\t\t} else if (!v.rightOf(e.dPrev())) {\n\t\t\t\te = e.dPrev();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn e;\n\t},\n\tgetTolerance: function getTolerance() {\n\t\treturn this._tolerance;\n\t},\n\tgetVoronoiCellPolygons: function getVoronoiCellPolygons(geomFact) {\n\t\tthis.visitTriangles(new TriangleCircumcentreVisitor(), true);\n\t\tvar cells = new ArrayList();\n\t\tvar edges = this.getVertexUniqueEdges(false);\n\t\tfor (var i = edges.iterator(); i.hasNext();) {\n\t\t\tvar qe = i.next();\n\t\t\tcells.add(this.getVoronoiCellPolygon(qe, geomFact));\n\t\t}\n\t\treturn cells;\n\t},\n\tgetVoronoiDiagram: function getVoronoiDiagram(geomFact) {\n\t\tvar vorCells = this.getVoronoiCellPolygons(geomFact);\n\t\treturn geomFact.createGeometryCollection(GeometryFactory.toGeometryArray(vorCells));\n\t},\n\tgetTriangles: function getTriangles(geomFact) {\n\t\tvar triPtsList = this.getTriangleCoordinates(false);\n\t\tvar tris = new Array(triPtsList.size()).fill(null);\n\t\tvar i = 0;\n\t\tfor (var it = triPtsList.iterator(); it.hasNext();) {\n\t\t\tvar triPt = it.next();\n\t\t\ttris[i++] = geomFact.createPolygon(geomFact.createLinearRing(triPt), null);\n\t\t}\n\t\treturn geomFact.createGeometryCollection(tris);\n\t},\n\tinsertSite: function insertSite(v) {\n\t\tvar e = this.locate(v);\n\t\tif (v.equals(e.orig(), this._tolerance) || v.equals(e.dest(), this._tolerance)) {\n\t\t\treturn e;\n\t\t}\n\t\tvar base = this.makeEdge(e.orig(), v);\n\t\tQuadEdge.splice(base, e);\n\t\tvar startEdge = base;\n\t\tdo {\n\t\t\tbase = this.connect(e, base.sym());\n\t\t\te = base.oPrev();\n\t\t} while (e.lNext() !== startEdge);\n\t\treturn startEdge;\n\t},\n\tlocate: function locate() {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Vertex) {\n\t\t\t\tvar v = arguments[0];\n\t\t\t\treturn this._locator.locate(v);\n\t\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\t\tvar p = arguments[0];\n\t\t\t\treturn this._locator.locate(new Vertex(p));\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar p0 = arguments[0],\n\t\t\t    p1 = arguments[1];\n\t\t\tvar e = this._locator.locate(new Vertex(p0));\n\t\t\tif (e === null) return null;\n\t\t\tvar base = e;\n\t\t\tif (e.dest().getCoordinate().equals2D(p0)) base = e.sym();\n\t\t\tvar locEdge = base;\n\t\t\tdo {\n\t\t\t\tif (locEdge.dest().getCoordinate().equals2D(p1)) return locEdge;\n\t\t\t\tlocEdge = locEdge.oNext();\n\t\t\t} while (locEdge !== base);\n\t\t\treturn null;\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn QuadEdgeSubdivision;\n\t}\n});\nQuadEdgeSubdivision.getTriangleEdges = function (startQE, triEdge) {\n\ttriEdge[0] = startQE;\n\ttriEdge[1] = triEdge[0].lNext();\n\ttriEdge[2] = triEdge[1].lNext();\n\tif (triEdge[2].lNext() !== triEdge[0]) throw new IllegalArgumentException(\"Edges do not form a triangle\");\n};\nfunction TriangleCircumcentreVisitor() {}\nextend(TriangleCircumcentreVisitor.prototype, {\n\tvisit: function visit(triEdges) {\n\t\tvar a = triEdges[0].orig().getCoordinate();\n\t\tvar b = triEdges[1].orig().getCoordinate();\n\t\tvar c = triEdges[2].orig().getCoordinate();\n\t\tvar cc = Triangle$1.circumcentre(a, b, c);\n\t\tvar ccVertex = new Vertex(cc);\n\t\tfor (var i = 0; i < 3; i++) {\n\t\t\ttriEdges[i].rot().setOrig(ccVertex);\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [TriangleVisitor];\n\t},\n\tgetClass: function getClass() {\n\t\treturn TriangleCircumcentreVisitor;\n\t}\n});\nfunction TriangleEdgesListVisitor() {\n\tthis._triList = new ArrayList();\n}\nextend(TriangleEdgesListVisitor.prototype, {\n\tgetTriangleEdges: function getTriangleEdges() {\n\t\treturn this._triList;\n\t},\n\tvisit: function visit(triEdges) {\n\t\tthis._triList.add(triEdges.clone());\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [TriangleVisitor];\n\t},\n\tgetClass: function getClass() {\n\t\treturn TriangleEdgesListVisitor;\n\t}\n});\nfunction TriangleVertexListVisitor() {\n\tthis._triList = new ArrayList();\n}\nextend(TriangleVertexListVisitor.prototype, {\n\tvisit: function visit(triEdges) {\n\t\tthis._triList.add([triEdges[0].orig(), triEdges[1].orig(), triEdges[2].orig()]);\n\t},\n\tgetTriangleVertices: function getTriangleVertices() {\n\t\treturn this._triList;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [TriangleVisitor];\n\t},\n\tgetClass: function getClass() {\n\t\treturn TriangleVertexListVisitor;\n\t}\n});\nfunction TriangleCoordinatesVisitor() {\n\tthis._coordList = new CoordinateList();\n\tthis._triCoords = new ArrayList();\n}\nextend(TriangleCoordinatesVisitor.prototype, {\n\tcheckTriangleSize: function checkTriangleSize(pts) {\n\t\tvar loc = \"\";\n\t\tif (pts.length >= 2) loc = WKTWriter.toLineString(pts[0], pts[1]);else {\n\t\t\tif (pts.length >= 1) loc = WKTWriter.toPoint(pts[0]);\n\t\t}\n\t},\n\tvisit: function visit(triEdges) {\n\t\tthis._coordList.clear();\n\t\tfor (var i = 0; i < 3; i++) {\n\t\t\tvar v = triEdges[i].orig();\n\t\t\tthis._coordList.add(v.getCoordinate());\n\t\t}\n\t\tif (this._coordList.size() > 0) {\n\t\t\tthis._coordList.closeRing();\n\t\t\tvar pts = this._coordList.toCoordinateArray();\n\t\t\tif (pts.length !== 4) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tthis._triCoords.add(pts);\n\t\t}\n\t},\n\tgetTriangles: function getTriangles() {\n\t\treturn this._triCoords;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [TriangleVisitor];\n\t},\n\tgetClass: function getClass() {\n\t\treturn TriangleCoordinatesVisitor;\n\t}\n});\nQuadEdgeSubdivision.TriangleCircumcentreVisitor = TriangleCircumcentreVisitor;\nQuadEdgeSubdivision.TriangleEdgesListVisitor = TriangleEdgesListVisitor;\nQuadEdgeSubdivision.TriangleVertexListVisitor = TriangleVertexListVisitor;\nQuadEdgeSubdivision.TriangleCoordinatesVisitor = TriangleCoordinatesVisitor;\nQuadEdgeSubdivision.EDGE_COINCIDENCE_TOL_FACTOR = 1000;\n\nfunction Segment() {\n\tthis._ls = null;\n\tthis._data = null;\n\tif (arguments.length === 2) {\n\t\tvar p0 = arguments[0],\n\t\t    p1 = arguments[1];\n\t\tthis._ls = new LineSegment(p0, p1);\n\t} else if (arguments.length === 3) {\n\t\tvar p0 = arguments[0],\n\t\t    p1 = arguments[1],\n\t\t    data = arguments[2];\n\t\tthis._ls = new LineSegment(p0, p1);\n\t\tthis._data = data;\n\t} else if (arguments.length === 6) {\n\t\tvar x1 = arguments[0],\n\t\t    y1 = arguments[1],\n\t\t    z1 = arguments[2],\n\t\t    x2 = arguments[3],\n\t\t    y2 = arguments[4],\n\t\t    z2 = arguments[5];\n\t\tSegment.call(this, new Coordinate(x1, y1, z1), new Coordinate(x2, y2, z2));\n\t} else if (arguments.length === 7) {\n\t\tvar x1 = arguments[0],\n\t\t    y1 = arguments[1],\n\t\t    z1 = arguments[2],\n\t\t    x2 = arguments[3],\n\t\t    y2 = arguments[4],\n\t\t    z2 = arguments[5],\n\t\t    data = arguments[6];\n\t\tSegment.call(this, new Coordinate(x1, y1, z1), new Coordinate(x2, y2, z2), data);\n\t}\n}\nextend(Segment.prototype, {\n\tgetLineSegment: function getLineSegment() {\n\t\treturn this._ls;\n\t},\n\tgetEndZ: function getEndZ() {\n\t\tvar p = this._ls.getCoordinate(1);\n\t\treturn p.z;\n\t},\n\tgetStartZ: function getStartZ() {\n\t\tvar p = this._ls.getCoordinate(0);\n\t\treturn p.z;\n\t},\n\tintersection: function intersection(s) {\n\t\treturn this._ls.intersection(s.getLineSegment());\n\t},\n\tgetStart: function getStart() {\n\t\treturn this._ls.getCoordinate(0);\n\t},\n\tgetEnd: function getEnd() {\n\t\treturn this._ls.getCoordinate(1);\n\t},\n\tgetEndY: function getEndY() {\n\t\tvar p = this._ls.getCoordinate(1);\n\t\treturn p.y;\n\t},\n\tgetStartX: function getStartX() {\n\t\tvar p = this._ls.getCoordinate(0);\n\t\treturn p.x;\n\t},\n\tequalsTopo: function equalsTopo(s) {\n\t\treturn this._ls.equalsTopo(s.getLineSegment());\n\t},\n\tgetStartY: function getStartY() {\n\t\tvar p = this._ls.getCoordinate(0);\n\t\treturn p.y;\n\t},\n\tsetData: function setData(data) {\n\t\tthis._data = data;\n\t},\n\tgetData: function getData() {\n\t\treturn this._data;\n\t},\n\tgetEndX: function getEndX() {\n\t\tvar p = this._ls.getCoordinate(1);\n\t\treturn p.x;\n\t},\n\ttoString: function toString() {\n\t\treturn this._ls.toString();\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn Segment;\n\t}\n});\n\nfunction KdNodeVisitor() {}\nextend(KdNodeVisitor.prototype, {\n\tvisit: function visit(node) {},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn KdNodeVisitor;\n\t}\n});\n\nfunction KdNode() {\n\tthis._p = null;\n\tthis._data = null;\n\tthis._left = null;\n\tthis._right = null;\n\tthis._count = null;\n\tif (arguments.length === 2) {\n\t\tvar p = arguments[0],\n\t\t    data = arguments[1];\n\t\tthis._p = new Coordinate(p);\n\t\tthis._left = null;\n\t\tthis._right = null;\n\t\tthis._count = 1;\n\t\tthis._data = data;\n\t} else if (arguments.length === 3) {\n\t\tvar _x = arguments[0],\n\t\t    _y = arguments[1],\n\t\t    data = arguments[2];\n\t\tthis._p = new Coordinate(_x, _y);\n\t\tthis._left = null;\n\t\tthis._right = null;\n\t\tthis._count = 1;\n\t\tthis._data = data;\n\t}\n}\nextend(KdNode.prototype, {\n\tisRepeated: function isRepeated() {\n\t\treturn this._count > 1;\n\t},\n\tgetRight: function getRight() {\n\t\treturn this._right;\n\t},\n\tgetCoordinate: function getCoordinate() {\n\t\treturn this._p;\n\t},\n\tsetLeft: function setLeft(_left) {\n\t\tthis._left = _left;\n\t},\n\tgetX: function getX() {\n\t\treturn this._p.x;\n\t},\n\tgetData: function getData() {\n\t\treturn this._data;\n\t},\n\tgetCount: function getCount() {\n\t\treturn this._count;\n\t},\n\tgetLeft: function getLeft() {\n\t\treturn this._left;\n\t},\n\tgetY: function getY() {\n\t\treturn this._p.y;\n\t},\n\tincrement: function increment() {\n\t\tthis._count = this._count + 1;\n\t},\n\tsetRight: function setRight(_right) {\n\t\tthis._right = _right;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn KdNode;\n\t}\n});\n\nfunction KdTree() {\n\tthis._root = null;\n\tthis._numberOfNodes = null;\n\tthis._tolerance = null;\n\tif (arguments.length === 0) {\n\t\tKdTree.call(this, 0.0);\n\t} else if (arguments.length === 1) {\n\t\tvar tolerance = arguments[0];\n\t\tthis._tolerance = tolerance;\n\t}\n}\nextend(KdTree.prototype, {\n\tinsert: function insert() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar p = arguments[0];\n\t\t\treturn this.insert(p, null);\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar p = arguments[0],\n\t\t\t    data = arguments[1];\n\t\t\tif (this._root === null) {\n\t\t\t\tthis._root = new KdNode(p, data);\n\t\t\t\treturn this._root;\n\t\t\t}\n\t\t\tif (this._tolerance > 0) {\n\t\t\t\tvar matchNode = this.findBestMatchNode(p);\n\t\t\t\tif (matchNode !== null) {\n\t\t\t\t\tmatchNode.increment();\n\t\t\t\t\treturn matchNode;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.insertExact(p, data);\n\t\t}\n\t},\n\tquery: function query() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar queryEnv = arguments[0];\n\t\t\tvar result = new ArrayList();\n\t\t\tthis.query(queryEnv, result);\n\t\t\treturn result;\n\t\t} else if (arguments.length === 2) {\n\t\t\tif (arguments[0] instanceof Envelope && hasInterface(arguments[1], List)) {\n\t\t\t\tvar queryEnv = arguments[0],\n\t\t\t\t    result = arguments[1];\n\t\t\t\tthis.queryNode(this._root, queryEnv, true, {\n\t\t\t\t\tinterfaces_: function interfaces_() {\n\t\t\t\t\t\treturn [KdNodeVisitor];\n\t\t\t\t\t},\n\t\t\t\t\tvisit: function visit(node) {\n\t\t\t\t\t\tresult.add(node);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else if (arguments[0] instanceof Envelope && hasInterface(arguments[1], KdNodeVisitor)) {\n\t\t\t\tvar queryEnv = arguments[0],\n\t\t\t\t    visitor = arguments[1];\n\t\t\t\tthis.queryNode(this._root, queryEnv, true, visitor);\n\t\t\t}\n\t\t}\n\t},\n\tqueryNode: function queryNode(currentNode, queryEnv, odd, visitor) {\n\t\tif (currentNode === null) return null;\n\t\tvar min = null;\n\t\tvar max = null;\n\t\tvar discriminant = null;\n\t\tif (odd) {\n\t\t\tmin = queryEnv.getMinX();\n\t\t\tmax = queryEnv.getMaxX();\n\t\t\tdiscriminant = currentNode.getX();\n\t\t} else {\n\t\t\tmin = queryEnv.getMinY();\n\t\t\tmax = queryEnv.getMaxY();\n\t\t\tdiscriminant = currentNode.getY();\n\t\t}\n\t\tvar searchLeft = min < discriminant;\n\t\tvar searchRight = discriminant <= max;\n\t\tif (searchLeft) {\n\t\t\tthis.queryNode(currentNode.getLeft(), queryEnv, !odd, visitor);\n\t\t}\n\t\tif (queryEnv.contains(currentNode.getCoordinate())) {\n\t\t\tvisitor.visit(currentNode);\n\t\t}\n\t\tif (searchRight) {\n\t\t\tthis.queryNode(currentNode.getRight(), queryEnv, !odd, visitor);\n\t\t}\n\t},\n\tfindBestMatchNode: function findBestMatchNode(p) {\n\t\tvar visitor = new BestMatchVisitor(p, this._tolerance);\n\t\tthis.query(visitor.queryEnvelope(), visitor);\n\t\treturn visitor.getNode();\n\t},\n\tisEmpty: function isEmpty() {\n\t\tif (this._root === null) return true;\n\t\treturn false;\n\t},\n\tinsertExact: function insertExact(p, data) {\n\t\tvar currentNode = this._root;\n\t\tvar leafNode = this._root;\n\t\tvar isOddLevel = true;\n\t\tvar isLessThan = true;\n\t\twhile (currentNode !== null) {\n\t\t\tif (currentNode !== null) {\n\t\t\t\tvar isInTolerance = p.distance(currentNode.getCoordinate()) <= this._tolerance;\n\t\t\t\tif (isInTolerance) {\n\t\t\t\t\tcurrentNode.increment();\n\t\t\t\t\treturn currentNode;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isOddLevel) {\n\t\t\t\tisLessThan = p.x < currentNode.getX();\n\t\t\t} else {\n\t\t\t\tisLessThan = p.y < currentNode.getY();\n\t\t\t}\n\t\t\tleafNode = currentNode;\n\t\t\tif (isLessThan) {\n\t\t\t\tcurrentNode = currentNode.getLeft();\n\t\t\t} else {\n\t\t\t\tcurrentNode = currentNode.getRight();\n\t\t\t}\n\t\t\tisOddLevel = !isOddLevel;\n\t\t}\n\t\tthis._numberOfNodes = this._numberOfNodes + 1;\n\t\tvar node = new KdNode(p, data);\n\t\tif (isLessThan) {\n\t\t\tleafNode.setLeft(node);\n\t\t} else {\n\t\t\tleafNode.setRight(node);\n\t\t}\n\t\treturn node;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn KdTree;\n\t}\n});\nKdTree.toCoordinates = function () {\n\tif (arguments.length === 1) {\n\t\tvar kdnodes = arguments[0];\n\t\treturn KdTree.toCoordinates(kdnodes, false);\n\t} else if (arguments.length === 2) {\n\t\tvar kdnodes = arguments[0],\n\t\t    includeRepeated = arguments[1];\n\t\tvar coord = new CoordinateList();\n\t\tfor (var it = kdnodes.iterator(); it.hasNext();) {\n\t\t\tvar node = it.next();\n\t\t\tvar count = includeRepeated ? node.getCount() : 1;\n\t\t\tfor (var i = 0; i < count; i++) {\n\t\t\t\tcoord.add(node.getCoordinate(), true);\n\t\t\t}\n\t\t}\n\t\treturn coord.toCoordinateArray();\n\t}\n};\nfunction BestMatchVisitor() {\n\tthis._tolerance = null;\n\tthis._matchNode = null;\n\tthis._matchDist = 0.0;\n\tthis._p = null;\n\tvar p = arguments[0],\n\t    tolerance = arguments[1];\n\tthis._p = p;\n\tthis._tolerance = tolerance;\n}\nextend(BestMatchVisitor.prototype, {\n\tvisit: function visit(node) {\n\t\tvar dist = this._p.distance(node.getCoordinate());\n\t\tvar isInTolerance = dist <= this._tolerance;\n\t\tif (!isInTolerance) return null;\n\t\tvar update = false;\n\t\tif (this._matchNode === null || dist < this._matchDist || this._matchNode !== null && dist === this._matchDist && node.getCoordinate().compareTo(this._matchNode.getCoordinate()) < 1) update = true;\n\t\tif (update) {\n\t\t\tthis._matchNode = node;\n\t\t\tthis._matchDist = dist;\n\t\t}\n\t},\n\tqueryEnvelope: function queryEnvelope() {\n\t\tvar queryEnv = new Envelope(this._p);\n\t\tqueryEnv.expandBy(this._tolerance);\n\t\treturn queryEnv;\n\t},\n\tgetNode: function getNode() {\n\t\treturn this._matchNode;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [KdNodeVisitor];\n\t},\n\tgetClass: function getClass() {\n\t\treturn BestMatchVisitor;\n\t}\n});\nKdTree.BestMatchVisitor = BestMatchVisitor;\n\nfunction ConformingDelaunayTriangulator() {\n\tthis._initialVertices = null;\n\tthis._segVertices = null;\n\tthis._segments = new ArrayList();\n\tthis._subdiv = null;\n\tthis._incDel = null;\n\tthis._convexHull = null;\n\tthis._splitFinder = new NonEncroachingSplitPointFinder();\n\tthis._kdt = null;\n\tthis._vertexFactory = null;\n\tthis._computeAreaEnv = null;\n\tthis._splitPt = null;\n\tthis._tolerance = null;\n\tvar initialVertices = arguments[0],\n\t    tolerance = arguments[1];\n\tthis._initialVertices = new ArrayList(initialVertices);\n\tthis._tolerance = tolerance;\n\tthis._kdt = new KdTree(tolerance);\n}\nextend(ConformingDelaunayTriangulator.prototype, {\n\tgetInitialVertices: function getInitialVertices() {\n\t\treturn this._initialVertices;\n\t},\n\tgetKDT: function getKDT() {\n\t\treturn this._kdt;\n\t},\n\tenforceConstraints: function enforceConstraints() {\n\t\tthis.addConstraintVertices();\n\t\tvar count = 0;\n\t\tvar splits = 0;\n\t\tdo {\n\t\t\tsplits = this.enforceGabriel(this._segments);\n\t\t\tcount++;\n\t\t} while (splits > 0 && count < ConformingDelaunayTriangulator.MAX_SPLIT_ITER);\n\t},\n\tinsertSites: function insertSites(vertices) {\n\t\tfor (var i = vertices.iterator(); i.hasNext();) {\n\t\t\tvar v = i.next();\n\t\t\tthis.insertSite(v);\n\t\t}\n\t},\n\tgetVertexFactory: function getVertexFactory() {\n\t\treturn this._vertexFactory;\n\t},\n\tgetPointArray: function getPointArray() {\n\t\tvar pts = new Array(this._initialVertices.size() + this._segVertices.size()).fill(null);\n\t\tvar index = 0;\n\t\tfor (var i = this._initialVertices.iterator(); i.hasNext();) {\n\t\t\tvar v = i.next();\n\t\t\tpts[index++] = v.getCoordinate();\n\t\t}\n\t\tfor (var i2 = this._segVertices.iterator(); i2.hasNext();) {\n\t\t\tvar v = i2.next();\n\t\t\tpts[index++] = v.getCoordinate();\n\t\t}\n\t\treturn pts;\n\t},\n\tsetConstraints: function setConstraints(segments, segVertices) {\n\t\tthis._segments = segments;\n\t\tthis._segVertices = segVertices;\n\t},\n\tcomputeConvexHull: function computeConvexHull() {\n\t\tvar fact = new GeometryFactory();\n\t\tvar coords = this.getPointArray();\n\t\tvar hull = new ConvexHull(coords, fact);\n\t\tthis._convexHull = hull.getConvexHull();\n\t},\n\taddConstraintVertices: function addConstraintVertices() {\n\t\tthis.computeConvexHull();\n\t\tthis.insertSites(this._segVertices);\n\t},\n\tfindNonGabrielPoint: function findNonGabrielPoint(seg) {\n\t\tvar p = seg.getStart();\n\t\tvar q = seg.getEnd();\n\t\tvar midPt = new Coordinate((p.x + q.x) / 2.0, (p.y + q.y) / 2.0);\n\t\tvar segRadius = p.distance(midPt);\n\t\tvar env = new Envelope(midPt);\n\t\tenv.expandBy(segRadius);\n\t\tvar result = this._kdt.query(env);\n\t\tvar closestNonGabriel = null;\n\t\tvar minDist = Double.MAX_VALUE;\n\t\tfor (var i = result.iterator(); i.hasNext();) {\n\t\t\tvar nextNode = i.next();\n\t\t\tvar testPt = nextNode.getCoordinate();\n\t\t\tif (testPt.equals2D(p) || testPt.equals2D(q)) continue;\n\t\t\tvar testRadius = midPt.distance(testPt);\n\t\t\tif (testRadius < segRadius) {\n\t\t\t\tvar testDist = testRadius;\n\t\t\t\tif (closestNonGabriel === null || testDist < minDist) {\n\t\t\t\t\tclosestNonGabriel = testPt;\n\t\t\t\t\tminDist = testDist;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn closestNonGabriel;\n\t},\n\tgetConstraintSegments: function getConstraintSegments() {\n\t\treturn this._segments;\n\t},\n\tsetSplitPointFinder: function setSplitPointFinder(splitFinder) {\n\t\tthis._splitFinder = splitFinder;\n\t},\n\tgetConvexHull: function getConvexHull() {\n\t\treturn this._convexHull;\n\t},\n\tgetTolerance: function getTolerance() {\n\t\treturn this._tolerance;\n\t},\n\tenforceGabriel: function enforceGabriel(segsToInsert) {\n\t\tvar newSegments = new ArrayList();\n\t\tvar splits = 0;\n\t\tvar segsToRemove = new ArrayList();\n\t\tfor (var i = segsToInsert.iterator(); i.hasNext();) {\n\t\t\tvar seg = i.next();\n\t\t\tvar encroachPt = this.findNonGabrielPoint(seg);\n\t\t\tif (encroachPt === null) continue;\n\t\t\tthis._splitPt = this._splitFinder.findSplitPoint(seg, encroachPt);\n\t\t\tvar splitVertex = this.createVertex(this._splitPt, seg);\n\t\t\tvar insertedVertex = this.insertSite(splitVertex);\n\t\t\tvar s1 = new Segment(seg.getStartX(), seg.getStartY(), seg.getStartZ(), splitVertex.getX(), splitVertex.getY(), splitVertex.getZ(), seg.getData());\n\t\t\tvar s2 = new Segment(splitVertex.getX(), splitVertex.getY(), splitVertex.getZ(), seg.getEndX(), seg.getEndY(), seg.getEndZ(), seg.getData());\n\t\t\tnewSegments.add(s1);\n\t\t\tnewSegments.add(s2);\n\t\t\tsegsToRemove.add(seg);\n\t\t\tsplits = splits + 1;\n\t\t}\n\t\tsegsToInsert.removeAll(segsToRemove);\n\t\tsegsToInsert.addAll(newSegments);\n\t\treturn splits;\n\t},\n\tcreateVertex: function createVertex() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar p = arguments[0];\n\t\t\tvar v = null;\n\t\t\tif (this._vertexFactory !== null) v = this._vertexFactory.createVertex(p, null);else v = new ConstraintVertex(p);\n\t\t\treturn v;\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar p = arguments[0],\n\t\t\t    seg = arguments[1];\n\t\t\tvar v = null;\n\t\t\tif (this._vertexFactory !== null) v = this._vertexFactory.createVertex(p, seg);else v = new ConstraintVertex(p);\n\t\t\tv.setOnConstraint(true);\n\t\t\treturn v;\n\t\t}\n\t},\n\tgetSubdivision: function getSubdivision() {\n\t\treturn this._subdiv;\n\t},\n\tcomputeBoundingBox: function computeBoundingBox() {\n\t\tvar vertexEnv = ConformingDelaunayTriangulator.computeVertexEnvelope(this._initialVertices);\n\t\tvar segEnv = ConformingDelaunayTriangulator.computeVertexEnvelope(this._segVertices);\n\t\tvar allPointsEnv = new Envelope(vertexEnv);\n\t\tallPointsEnv.expandToInclude(segEnv);\n\t\tvar deltaX = allPointsEnv.getWidth() * 0.2;\n\t\tvar deltaY = allPointsEnv.getHeight() * 0.2;\n\t\tvar delta = Math.max(deltaX, deltaY);\n\t\tthis._computeAreaEnv = new Envelope(allPointsEnv);\n\t\tthis._computeAreaEnv.expandBy(delta);\n\t},\n\tsetVertexFactory: function setVertexFactory(vertexFactory) {\n\t\tthis._vertexFactory = vertexFactory;\n\t},\n\tformInitialDelaunay: function formInitialDelaunay() {\n\t\tthis.computeBoundingBox();\n\t\tthis._subdiv = new QuadEdgeSubdivision(this._computeAreaEnv, this._tolerance);\n\t\tthis._subdiv.setLocator(new LastFoundQuadEdgeLocator(this._subdiv));\n\t\tthis._incDel = new IncrementalDelaunayTriangulator(this._subdiv);\n\t\tthis.insertSites(this._initialVertices);\n\t},\n\tinsertSite: function insertSite() {\n\t\tif (arguments[0] instanceof ConstraintVertex) {\n\t\t\tvar v = arguments[0];\n\t\t\tvar kdnode = this._kdt.insert(v.getCoordinate(), v);\n\t\t\tif (!kdnode.isRepeated()) {\n\t\t\t\tthis._incDel.insertSite(v);\n\t\t\t} else {\n\t\t\t\tvar snappedV = kdnode.getData();\n\t\t\t\tsnappedV.merge(v);\n\t\t\t\treturn snappedV;\n\t\t\t}\n\t\t\treturn v;\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tvar p = arguments[0];\n\t\t\tthis.insertSite(this.createVertex(p));\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn ConformingDelaunayTriangulator;\n\t}\n});\nConformingDelaunayTriangulator.computeVertexEnvelope = function (vertices) {\n\tvar env = new Envelope();\n\tfor (var i = vertices.iterator(); i.hasNext();) {\n\t\tvar v = i.next();\n\t\tenv.expandToInclude(v.getCoordinate());\n\t}\n\treturn env;\n};\nConformingDelaunayTriangulator.MAX_SPLIT_ITER = 99;\n\nfunction DelaunayTriangulationBuilder() {\n\tthis._siteCoords = null;\n\tthis._tolerance = 0.0;\n\tthis._subdiv = null;\n}\nextend(DelaunayTriangulationBuilder.prototype, {\n\tcreate: function create() {\n\t\tif (this._subdiv !== null) return null;\n\t\tvar siteEnv = DelaunayTriangulationBuilder.envelope(this._siteCoords);\n\t\tvar vertices = DelaunayTriangulationBuilder.toVertices(this._siteCoords);\n\t\tthis._subdiv = new QuadEdgeSubdivision(siteEnv, this._tolerance);\n\t\tvar triangulator = new IncrementalDelaunayTriangulator(this._subdiv);\n\t\ttriangulator.insertSites(vertices);\n\t},\n\tsetTolerance: function setTolerance(tolerance) {\n\t\tthis._tolerance = tolerance;\n\t},\n\tsetSites: function setSites() {\n\t\tif (arguments[0] instanceof Geometry) {\n\t\t\tvar geom = arguments[0];\n\t\t\tthis._siteCoords = DelaunayTriangulationBuilder.extractUniqueCoordinates(geom);\n\t\t} else if (hasInterface(arguments[0], Collection)) {\n\t\t\tvar coords = arguments[0];\n\t\t\tthis._siteCoords = DelaunayTriangulationBuilder.unique(CoordinateArrays.toCoordinateArray(coords));\n\t\t}\n\t},\n\tgetEdges: function getEdges(geomFact) {\n\t\tthis.create();\n\t\treturn this._subdiv.getEdges(geomFact);\n\t},\n\tgetSubdivision: function getSubdivision() {\n\t\tthis.create();\n\t\treturn this._subdiv;\n\t},\n\tgetTriangles: function getTriangles(geomFact) {\n\t\tthis.create();\n\t\treturn this._subdiv.getTriangles(geomFact);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn DelaunayTriangulationBuilder;\n\t}\n});\nDelaunayTriangulationBuilder.extractUniqueCoordinates = function (geom) {\n\tif (geom === null) return new CoordinateList();\n\tvar coords = geom.getCoordinates();\n\treturn DelaunayTriangulationBuilder.unique(coords);\n};\nDelaunayTriangulationBuilder.envelope = function (coords) {\n\tvar env = new Envelope();\n\tfor (var i = coords.iterator(); i.hasNext();) {\n\t\tvar coord = i.next();\n\t\tenv.expandToInclude(coord);\n\t}\n\treturn env;\n};\nDelaunayTriangulationBuilder.unique = function (coords) {\n\tvar coordsCopy = CoordinateArrays.copyDeep(coords);\n\tArrays.sort(coordsCopy);\n\tvar coordList = new CoordinateList(coordsCopy, false);\n\treturn coordList;\n};\nDelaunayTriangulationBuilder.toVertices = function (coords) {\n\tvar verts = new ArrayList();\n\tfor (var i = coords.iterator(); i.hasNext();) {\n\t\tvar coord = i.next();\n\t\tverts.add(new Vertex(coord));\n\t}\n\treturn verts;\n};\n\nfunction ConformingDelaunayTriangulationBuilder() {\n\tthis._siteCoords = null;\n\tthis._constraintLines = null;\n\tthis._tolerance = 0.0;\n\tthis._subdiv = null;\n\tthis._constraintVertexMap = new TreeMap();\n}\nextend(ConformingDelaunayTriangulationBuilder.prototype, {\n\tcreateSiteVertices: function createSiteVertices(coords) {\n\t\tvar verts = new ArrayList();\n\t\tfor (var i = coords.iterator(); i.hasNext();) {\n\t\t\tvar coord = i.next();\n\t\t\tif (this._constraintVertexMap.containsKey(coord)) continue;\n\t\t\tverts.add(new ConstraintVertex(coord));\n\t\t}\n\t\treturn verts;\n\t},\n\tcreate: function create() {\n\t\tif (this._subdiv !== null) return null;\n\t\tvar siteEnv = DelaunayTriangulationBuilder.envelope(this._siteCoords);\n\t\tvar segments = new ArrayList();\n\t\tif (this._constraintLines !== null) {\n\t\t\tsiteEnv.expandToInclude(this._constraintLines.getEnvelopeInternal());\n\t\t\tthis.createVertices(this._constraintLines);\n\t\t\tsegments = ConformingDelaunayTriangulationBuilder.createConstraintSegments(this._constraintLines);\n\t\t}\n\t\tvar sites = this.createSiteVertices(this._siteCoords);\n\t\tvar cdt = new ConformingDelaunayTriangulator(sites, this._tolerance);\n\t\tcdt.setConstraints(segments, new ArrayList(this._constraintVertexMap.values()));\n\t\tcdt.formInitialDelaunay();\n\t\tcdt.enforceConstraints();\n\t\tthis._subdiv = cdt.getSubdivision();\n\t},\n\tsetTolerance: function setTolerance(tolerance) {\n\t\tthis._tolerance = tolerance;\n\t},\n\tsetConstraints: function setConstraints(constraintLines) {\n\t\tthis._constraintLines = constraintLines;\n\t},\n\tsetSites: function setSites(geom) {\n\t\tthis._siteCoords = DelaunayTriangulationBuilder.extractUniqueCoordinates(geom);\n\t},\n\tgetEdges: function getEdges(geomFact) {\n\t\tthis.create();\n\t\treturn this._subdiv.getEdges(geomFact);\n\t},\n\tgetSubdivision: function getSubdivision() {\n\t\tthis.create();\n\t\treturn this._subdiv;\n\t},\n\tgetTriangles: function getTriangles(geomFact) {\n\t\tthis.create();\n\t\treturn this._subdiv.getTriangles(geomFact);\n\t},\n\tcreateVertices: function createVertices(geom) {\n\t\tvar coords = geom.getCoordinates();\n\t\tfor (var i = 0; i < coords.length; i++) {\n\t\t\tvar v = new ConstraintVertex(coords[i]);\n\t\t\tthis._constraintVertexMap.put(coords[i], v);\n\t\t}\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn ConformingDelaunayTriangulationBuilder;\n\t}\n});\nConformingDelaunayTriangulationBuilder.createConstraintSegments = function () {\n\tif (arguments.length === 1) {\n\t\tvar geom = arguments[0];\n\t\tvar lines = LinearComponentExtracter.getLines(geom);\n\t\tvar constraintSegs = new ArrayList();\n\t\tfor (var i = lines.iterator(); i.hasNext();) {\n\t\t\tvar line = i.next();\n\t\t\tConformingDelaunayTriangulationBuilder.createConstraintSegments(line, constraintSegs);\n\t\t}\n\t\treturn constraintSegs;\n\t} else if (arguments.length === 2) {\n\t\tvar line = arguments[0],\n\t\t    constraintSegs = arguments[1];\n\t\tvar coords = line.getCoordinates();\n\t\tfor (var i = 1; i < coords.length; i++) {\n\t\t\tconstraintSegs.add(new Segment(coords[i - 1], coords[i]));\n\t\t}\n\t}\n};\n\nfunction VoronoiDiagramBuilder() {\n\tthis._siteCoords = null;\n\tthis._tolerance = 0.0;\n\tthis._subdiv = null;\n\tthis._clipEnv = null;\n\tthis._diagramEnv = null;\n}\nextend(VoronoiDiagramBuilder.prototype, {\n\tcreate: function create() {\n\t\tif (this._subdiv !== null) return null;\n\t\tvar siteEnv = DelaunayTriangulationBuilder.envelope(this._siteCoords);\n\t\tthis._diagramEnv = siteEnv;\n\t\tvar expandBy = Math.max(this._diagramEnv.getWidth(), this._diagramEnv.getHeight());\n\t\tthis._diagramEnv.expandBy(expandBy);\n\t\tif (this._clipEnv !== null) this._diagramEnv.expandToInclude(this._clipEnv);\n\t\tvar vertices = DelaunayTriangulationBuilder.toVertices(this._siteCoords);\n\t\tthis._subdiv = new QuadEdgeSubdivision(siteEnv, this._tolerance);\n\t\tvar triangulator = new IncrementalDelaunayTriangulator(this._subdiv);\n\t\ttriangulator.insertSites(vertices);\n\t},\n\tgetDiagram: function getDiagram(geomFact) {\n\t\tthis.create();\n\t\tvar polys = this._subdiv.getVoronoiDiagram(geomFact);\n\t\treturn VoronoiDiagramBuilder.clipGeometryCollection(polys, this._diagramEnv);\n\t},\n\tsetTolerance: function setTolerance(tolerance) {\n\t\tthis._tolerance = tolerance;\n\t},\n\tsetSites: function setSites() {\n\t\tif (arguments[0] instanceof Geometry) {\n\t\t\tvar geom = arguments[0];\n\t\t\tthis._siteCoords = DelaunayTriangulationBuilder.extractUniqueCoordinates(geom);\n\t\t} else if (hasInterface(arguments[0], Collection)) {\n\t\t\tvar coords = arguments[0];\n\t\t\tthis._siteCoords = DelaunayTriangulationBuilder.unique(CoordinateArrays.toCoordinateArray(coords));\n\t\t}\n\t},\n\tsetClipEnvelope: function setClipEnvelope(clipEnv) {\n\t\tthis._clipEnv = clipEnv;\n\t},\n\tgetSubdivision: function getSubdivision() {\n\t\tthis.create();\n\t\treturn this._subdiv;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn VoronoiDiagramBuilder;\n\t}\n});\nVoronoiDiagramBuilder.clipGeometryCollection = function (geom, clipEnv) {\n\tvar clipPoly = geom.getFactory().toGeometry(clipEnv);\n\tvar clipped = new ArrayList();\n\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n\t\tvar g = geom.getGeometryN(i);\n\t\tvar result = null;\n\t\tif (clipEnv.contains(g.getEnvelopeInternal())) result = g;else if (clipEnv.intersects(g.getEnvelopeInternal())) {\n\t\t\tresult = clipPoly.intersection(g);\n\t\t\tresult.setUserData(g.getUserData());\n\t\t}\n\t\tif (result !== null && !result.isEmpty()) {\n\t\t\tclipped.add(result);\n\t\t}\n\t}\n\treturn geom.getFactory().createGeometryCollection(GeometryFactory.toGeometryArray(clipped));\n};\n\nfunction LinearLocation() {\n\tthis._componentIndex = 0;\n\tthis._segmentIndex = 0;\n\tthis._segmentFraction = 0.0;\n\tif (arguments.length === 0) {} else if (arguments.length === 1) {\n\t\tvar loc = arguments[0];\n\t\tthis._componentIndex = loc._componentIndex;\n\t\tthis._segmentIndex = loc._segmentIndex;\n\t\tthis._segmentFraction = loc._segmentFraction;\n\t} else if (arguments.length === 2) {\n\t\tvar segmentIndex = arguments[0],\n\t\t    segmentFraction = arguments[1];\n\t\tLinearLocation.call(this, 0, segmentIndex, segmentFraction);\n\t} else if (arguments.length === 3) {\n\t\tvar componentIndex = arguments[0],\n\t\t    segmentIndex = arguments[1],\n\t\t    segmentFraction = arguments[2];\n\t\tthis._componentIndex = componentIndex;\n\t\tthis._segmentIndex = segmentIndex;\n\t\tthis._segmentFraction = segmentFraction;\n\t\tthis.normalize();\n\t} else if (arguments.length === 4) {\n\t\tvar componentIndex = arguments[0],\n\t\t    segmentIndex = arguments[1],\n\t\t    segmentFraction = arguments[2],\n\t\t    doNormalize = arguments[3];\n\t\tthis._componentIndex = componentIndex;\n\t\tthis._segmentIndex = segmentIndex;\n\t\tthis._segmentFraction = segmentFraction;\n\t\tif (doNormalize) this.normalize();\n\t}\n}\nextend(LinearLocation.prototype, {\n\tgetSegmentIndex: function getSegmentIndex() {\n\t\treturn this._segmentIndex;\n\t},\n\tgetComponentIndex: function getComponentIndex() {\n\t\treturn this._componentIndex;\n\t},\n\tisEndpoint: function isEndpoint(linearGeom) {\n\t\tvar lineComp = linearGeom.getGeometryN(this._componentIndex);\n\t\tvar nseg = lineComp.getNumPoints() - 1;\n\t\treturn this._segmentIndex >= nseg || this._segmentIndex === nseg && this._segmentFraction >= 1.0;\n\t},\n\tisValid: function isValid(linearGeom) {\n\t\tif (this._componentIndex < 0 || this._componentIndex >= linearGeom.getNumGeometries()) return false;\n\t\tvar lineComp = linearGeom.getGeometryN(this._componentIndex);\n\t\tif (this._segmentIndex < 0 || this._segmentIndex > lineComp.getNumPoints()) return false;\n\t\tif (this._segmentIndex === lineComp.getNumPoints() && this._segmentFraction !== 0.0) return false;\n\t\tif (this._segmentFraction < 0.0 || this._segmentFraction > 1.0) return false;\n\t\treturn true;\n\t},\n\tnormalize: function normalize() {\n\t\tif (this._segmentFraction < 0.0) {\n\t\t\tthis._segmentFraction = 0.0;\n\t\t}\n\t\tif (this._segmentFraction > 1.0) {\n\t\t\tthis._segmentFraction = 1.0;\n\t\t}\n\t\tif (this._componentIndex < 0) {\n\t\t\tthis._componentIndex = 0;\n\t\t\tthis._segmentIndex = 0;\n\t\t\tthis._segmentFraction = 0.0;\n\t\t}\n\t\tif (this._segmentIndex < 0) {\n\t\t\tthis._segmentIndex = 0;\n\t\t\tthis._segmentFraction = 0.0;\n\t\t}\n\t\tif (this._segmentFraction === 1.0) {\n\t\t\tthis._segmentFraction = 0.0;\n\t\t\tthis._segmentIndex += 1;\n\t\t}\n\t},\n\ttoLowest: function toLowest(linearGeom) {\n\t\tvar lineComp = linearGeom.getGeometryN(this._componentIndex);\n\t\tvar nseg = lineComp.getNumPoints() - 1;\n\t\tif (this._segmentIndex < nseg) return this;\n\t\treturn new LinearLocation(this._componentIndex, nseg, 1.0, false);\n\t},\n\tgetCoordinate: function getCoordinate(linearGeom) {\n\t\tvar lineComp = linearGeom.getGeometryN(this._componentIndex);\n\t\tvar p0 = lineComp.getCoordinateN(this._segmentIndex);\n\t\tif (this._segmentIndex >= lineComp.getNumPoints() - 1) return p0;\n\t\tvar p1 = lineComp.getCoordinateN(this._segmentIndex + 1);\n\t\treturn LinearLocation.pointAlongSegmentByFraction(p0, p1, this._segmentFraction);\n\t},\n\tgetSegmentFraction: function getSegmentFraction() {\n\t\treturn this._segmentFraction;\n\t},\n\tgetSegment: function getSegment(linearGeom) {\n\t\tvar lineComp = linearGeom.getGeometryN(this._componentIndex);\n\t\tvar p0 = lineComp.getCoordinateN(this._segmentIndex);\n\t\tif (this._segmentIndex >= lineComp.getNumPoints() - 1) {\n\t\t\tvar prev = lineComp.getCoordinateN(lineComp.getNumPoints() - 2);\n\t\t\treturn new LineSegment(prev, p0);\n\t\t}\n\t\tvar p1 = lineComp.getCoordinateN(this._segmentIndex + 1);\n\t\treturn new LineSegment(p0, p1);\n\t},\n\tclamp: function clamp(linear) {\n\t\tif (this._componentIndex >= linear.getNumGeometries()) {\n\t\t\tthis.setToEnd(linear);\n\t\t\treturn null;\n\t\t}\n\t\tif (this._segmentIndex >= linear.getNumPoints()) {\n\t\t\tvar line = linear.getGeometryN(this._componentIndex);\n\t\t\tthis._segmentIndex = line.getNumPoints() - 1;\n\t\t\tthis._segmentFraction = 1.0;\n\t\t}\n\t},\n\tsetToEnd: function setToEnd(linear) {\n\t\tthis._componentIndex = linear.getNumGeometries() - 1;\n\t\tvar lastLine = linear.getGeometryN(this._componentIndex);\n\t\tthis._segmentIndex = lastLine.getNumPoints() - 1;\n\t\tthis._segmentFraction = 1.0;\n\t},\n\tcompareTo: function compareTo(o) {\n\t\tvar other = o;\n\t\tif (this._componentIndex < other._componentIndex) return -1;\n\t\tif (this._componentIndex > other._componentIndex) return 1;\n\t\tif (this._segmentIndex < other._segmentIndex) return -1;\n\t\tif (this._segmentIndex > other._segmentIndex) return 1;\n\t\tif (this._segmentFraction < other._segmentFraction) return -1;\n\t\tif (this._segmentFraction > other._segmentFraction) return 1;\n\t\treturn 0;\n\t},\n\tclone: function clone() {\n\t\treturn new LinearLocation(this._componentIndex, this._segmentIndex, this._segmentFraction);\n\t},\n\ttoString: function toString() {\n\t\treturn \"LinearLoc[\" + this._componentIndex + \", \" + this._segmentIndex + \", \" + this._segmentFraction + \"]\";\n\t},\n\tisOnSameSegment: function isOnSameSegment(loc) {\n\t\tif (this._componentIndex !== loc._componentIndex) return false;\n\t\tif (this._segmentIndex === loc._segmentIndex) return true;\n\t\tif (loc._segmentIndex - this._segmentIndex === 1 && loc._segmentFraction === 0.0) return true;\n\t\tif (this._segmentIndex - loc._segmentIndex === 1 && this._segmentFraction === 0.0) return true;\n\t\treturn false;\n\t},\n\tsnapToVertex: function snapToVertex(linearGeom, minDistance) {\n\t\tif (this._segmentFraction <= 0.0 || this._segmentFraction >= 1.0) return null;\n\t\tvar segLen = this.getSegmentLength(linearGeom);\n\t\tvar lenToStart = this._segmentFraction * segLen;\n\t\tvar lenToEnd = segLen - lenToStart;\n\t\tif (lenToStart <= lenToEnd && lenToStart < minDistance) {\n\t\t\tthis._segmentFraction = 0.0;\n\t\t} else if (lenToEnd <= lenToStart && lenToEnd < minDistance) {\n\t\t\tthis._segmentFraction = 1.0;\n\t\t}\n\t},\n\tcompareLocationValues: function compareLocationValues(componentIndex1, segmentIndex1, segmentFraction1) {\n\t\tif (this._componentIndex < componentIndex1) return -1;\n\t\tif (this._componentIndex > componentIndex1) return 1;\n\t\tif (this._segmentIndex < segmentIndex1) return -1;\n\t\tif (this._segmentIndex > segmentIndex1) return 1;\n\t\tif (this._segmentFraction < segmentFraction1) return -1;\n\t\tif (this._segmentFraction > segmentFraction1) return 1;\n\t\treturn 0;\n\t},\n\tgetSegmentLength: function getSegmentLength(linearGeom) {\n\t\tvar lineComp = linearGeom.getGeometryN(this._componentIndex);\n\t\tvar segIndex = this._segmentIndex;\n\t\tif (this._segmentIndex >= lineComp.getNumPoints() - 1) segIndex = lineComp.getNumPoints() - 2;\n\t\tvar p0 = lineComp.getCoordinateN(segIndex);\n\t\tvar p1 = lineComp.getCoordinateN(segIndex + 1);\n\t\treturn p0.distance(p1);\n\t},\n\tisVertex: function isVertex() {\n\t\treturn this._segmentFraction <= 0.0 || this._segmentFraction >= 1.0;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [Comparable];\n\t},\n\tgetClass: function getClass() {\n\t\treturn LinearLocation;\n\t}\n});\nLinearLocation.getEndLocation = function (linear) {\n\tvar loc = new LinearLocation();\n\tloc.setToEnd(linear);\n\treturn loc;\n};\nLinearLocation.pointAlongSegmentByFraction = function (p0, p1, frac) {\n\tif (frac <= 0.0) return p0;\n\tif (frac >= 1.0) return p1;\n\tvar x = (p1.x - p0.x) * frac + p0.x;\n\tvar y = (p1.y - p0.y) * frac + p0.y;\n\tvar z = (p1.z - p0.z) * frac + p0.z;\n\treturn new Coordinate(x, y, z);\n};\nLinearLocation.compareLocationValues = function (componentIndex0, segmentIndex0, segmentFraction0, componentIndex1, segmentIndex1, segmentFraction1) {\n\tif (componentIndex0 < componentIndex1) return -1;\n\tif (componentIndex0 > componentIndex1) return 1;\n\tif (segmentIndex0 < segmentIndex1) return -1;\n\tif (segmentIndex0 > segmentIndex1) return 1;\n\tif (segmentFraction0 < segmentFraction1) return -1;\n\tif (segmentFraction0 > segmentFraction1) return 1;\n\treturn 0;\n};\n\nfunction LinearIterator() {\n\tthis._linearGeom = null;\n\tthis._numLines = null;\n\tthis._currentLine = null;\n\tthis._componentIndex = 0;\n\tthis._vertexIndex = 0;\n\tif (arguments.length === 1) {\n\t\tvar linear = arguments[0];\n\t\tLinearIterator.call(this, linear, 0, 0);\n\t} else if (arguments.length === 2) {\n\t\tvar linear = arguments[0],\n\t\t    start = arguments[1];\n\t\tLinearIterator.call(this, linear, start.getComponentIndex(), LinearIterator.segmentEndVertexIndex(start));\n\t} else if (arguments.length === 3) {\n\t\tvar linearGeom = arguments[0],\n\t\t    componentIndex = arguments[1],\n\t\t    vertexIndex = arguments[2];\n\t\tif (!hasInterface(linearGeom, Lineal)) throw new IllegalArgumentException(\"Lineal geometry is required\");\n\t\tthis._linearGeom = linearGeom;\n\t\tthis._numLines = linearGeom.getNumGeometries();\n\t\tthis._componentIndex = componentIndex;\n\t\tthis._vertexIndex = vertexIndex;\n\t\tthis.loadCurrentLine();\n\t}\n}\nextend(LinearIterator.prototype, {\n\tgetComponentIndex: function getComponentIndex() {\n\t\treturn this._componentIndex;\n\t},\n\tgetLine: function getLine() {\n\t\treturn this._currentLine;\n\t},\n\tgetVertexIndex: function getVertexIndex() {\n\t\treturn this._vertexIndex;\n\t},\n\tgetSegmentEnd: function getSegmentEnd() {\n\t\tif (this._vertexIndex < this.getLine().getNumPoints() - 1) return this._currentLine.getCoordinateN(this._vertexIndex + 1);\n\t\treturn null;\n\t},\n\tnext: function next() {\n\t\tif (!this.hasNext()) return null;\n\t\tthis._vertexIndex++;\n\t\tif (this._vertexIndex >= this._currentLine.getNumPoints()) {\n\t\t\tthis._componentIndex++;\n\t\t\tthis.loadCurrentLine();\n\t\t\tthis._vertexIndex = 0;\n\t\t}\n\t},\n\tloadCurrentLine: function loadCurrentLine() {\n\t\tif (this._componentIndex >= this._numLines) {\n\t\t\tthis._currentLine = null;\n\t\t\treturn null;\n\t\t}\n\t\tthis._currentLine = this._linearGeom.getGeometryN(this._componentIndex);\n\t},\n\tgetSegmentStart: function getSegmentStart() {\n\t\treturn this._currentLine.getCoordinateN(this._vertexIndex);\n\t},\n\tisEndOfLine: function isEndOfLine() {\n\t\tif (this._componentIndex >= this._numLines) return false;\n\t\tif (this._vertexIndex < this._currentLine.getNumPoints() - 1) return false;\n\t\treturn true;\n\t},\n\thasNext: function hasNext() {\n\t\tif (this._componentIndex >= this._numLines) return false;\n\t\tif (this._componentIndex === this._numLines - 1 && this._vertexIndex >= this._currentLine.getNumPoints()) return false;\n\t\treturn true;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn LinearIterator;\n\t}\n});\nLinearIterator.segmentEndVertexIndex = function (loc) {\n\tif (loc.getSegmentFraction() > 0.0) return loc.getSegmentIndex() + 1;\n\treturn loc.getSegmentIndex();\n};\n\nfunction LocationIndexOfPoint() {\n\tthis._linearGeom = null;\n\tvar linearGeom = arguments[0];\n\tthis._linearGeom = linearGeom;\n}\nextend(LocationIndexOfPoint.prototype, {\n\tindexOf: function indexOf(inputPt) {\n\t\treturn this.indexOfFromStart(inputPt, null);\n\t},\n\tindexOfFromStart: function indexOfFromStart(inputPt, minIndex) {\n\t\tvar minDistance = Double.MAX_VALUE;\n\t\tvar minComponentIndex = 0;\n\t\tvar minSegmentIndex = 0;\n\t\tvar minFrac = -1.0;\n\t\tvar seg = new LineSegment();\n\t\tfor (var it = new LinearIterator(this._linearGeom); it.hasNext(); it.next()) {\n\t\t\tif (!it.isEndOfLine()) {\n\t\t\t\tseg.p0 = it.getSegmentStart();\n\t\t\t\tseg.p1 = it.getSegmentEnd();\n\t\t\t\tvar segDistance = seg.distance(inputPt);\n\t\t\t\tvar segFrac = seg.segmentFraction(inputPt);\n\t\t\t\tvar candidateComponentIndex = it.getComponentIndex();\n\t\t\t\tvar candidateSegmentIndex = it.getVertexIndex();\n\t\t\t\tif (segDistance < minDistance) {\n\t\t\t\t\tif (minIndex === null || minIndex.compareLocationValues(candidateComponentIndex, candidateSegmentIndex, segFrac) < 0) {\n\t\t\t\t\t\tminComponentIndex = candidateComponentIndex;\n\t\t\t\t\t\tminSegmentIndex = candidateSegmentIndex;\n\t\t\t\t\t\tminFrac = segFrac;\n\t\t\t\t\t\tminDistance = segDistance;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (minDistance === Double.MAX_VALUE) {\n\t\t\treturn new LinearLocation(minIndex);\n\t\t}\n\t\tvar loc = new LinearLocation(minComponentIndex, minSegmentIndex, minFrac);\n\t\treturn loc;\n\t},\n\tindexOfAfter: function indexOfAfter(inputPt, minIndex) {\n\t\tif (minIndex === null) return this.indexOf(inputPt);\n\t\tvar endLoc = LinearLocation.getEndLocation(this._linearGeom);\n\t\tif (endLoc.compareTo(minIndex) <= 0) return endLoc;\n\t\tvar closestAfter = this.indexOfFromStart(inputPt, minIndex);\n\t\tAssert.isTrue(closestAfter.compareTo(minIndex) >= 0, \"computed location is before specified minimum location\");\n\t\treturn closestAfter;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn LocationIndexOfPoint;\n\t}\n});\nLocationIndexOfPoint.indexOf = function (linearGeom, inputPt) {\n\tvar locater = new LocationIndexOfPoint(linearGeom);\n\treturn locater.indexOf(inputPt);\n};\nLocationIndexOfPoint.indexOfAfter = function (linearGeom, inputPt, minIndex) {\n\tvar locater = new LocationIndexOfPoint(linearGeom);\n\treturn locater.indexOfAfter(inputPt, minIndex);\n};\n\nfunction LocationIndexOfLine() {\n\tthis._linearGeom = null;\n\tvar linearGeom = arguments[0];\n\tthis._linearGeom = linearGeom;\n}\nextend(LocationIndexOfLine.prototype, {\n\tindicesOf: function indicesOf(subLine) {\n\t\tvar startPt = subLine.getGeometryN(0).getCoordinateN(0);\n\t\tvar lastLine = subLine.getGeometryN(subLine.getNumGeometries() - 1);\n\t\tvar endPt = lastLine.getCoordinateN(lastLine.getNumPoints() - 1);\n\t\tvar locPt = new LocationIndexOfPoint(this._linearGeom);\n\t\tvar subLineLoc = new Array(2).fill(null);\n\t\tsubLineLoc[0] = locPt.indexOf(startPt);\n\t\tif (subLine.getLength() === 0.0) {\n\t\t\tsubLineLoc[1] = subLineLoc[0].clone();\n\t\t} else {\n\t\t\tsubLineLoc[1] = locPt.indexOfAfter(endPt, subLineLoc[0]);\n\t\t}\n\t\treturn subLineLoc;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn LocationIndexOfLine;\n\t}\n});\nLocationIndexOfLine.indicesOf = function (linearGeom, subLine) {\n\tvar locater = new LocationIndexOfLine(linearGeom);\n\treturn locater.indicesOf(subLine);\n};\n\nfunction LinearGeometryBuilder() {\n\tthis._geomFact = null;\n\tthis._lines = new ArrayList();\n\tthis._coordList = null;\n\tthis._ignoreInvalidLines = false;\n\tthis._fixInvalidLines = false;\n\tthis._lastPt = null;\n\tvar geomFact = arguments[0];\n\tthis._geomFact = geomFact;\n}\nextend(LinearGeometryBuilder.prototype, {\n\tgetGeometry: function getGeometry() {\n\t\tthis.endLine();\n\t\treturn this._geomFact.buildGeometry(this._lines);\n\t},\n\tgetLastCoordinate: function getLastCoordinate() {\n\t\treturn this._lastPt;\n\t},\n\tendLine: function endLine() {\n\t\tif (this._coordList === null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (this._ignoreInvalidLines && this._coordList.size() < 2) {\n\t\t\tthis._coordList = null;\n\t\t\treturn null;\n\t\t}\n\t\tvar rawPts = this._coordList.toCoordinateArray();\n\t\tvar pts = rawPts;\n\t\tif (this._fixInvalidLines) pts = this.validCoordinateSequence(rawPts);\n\t\tthis._coordList = null;\n\t\tvar line = null;\n\t\ttry {\n\t\t\tline = this._geomFact.createLineString(pts);\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof IllegalArgumentException) {\n\t\t\t\tif (!this._ignoreInvalidLines) throw ex;\n\t\t\t} else throw ex;\n\t\t} finally {}\n\t\tif (line !== null) this._lines.add(line);\n\t},\n\tsetFixInvalidLines: function setFixInvalidLines(fixInvalidLines) {\n\t\tthis._fixInvalidLines = fixInvalidLines;\n\t},\n\tadd: function add() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar pt = arguments[0];\n\t\t\tthis.add(pt, true);\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar pt = arguments[0],\n\t\t\t    allowRepeatedPoints = arguments[1];\n\t\t\tif (this._coordList === null) this._coordList = new CoordinateList();\n\t\t\tthis._coordList.add(pt, allowRepeatedPoints);\n\t\t\tthis._lastPt = pt;\n\t\t}\n\t},\n\tsetIgnoreInvalidLines: function setIgnoreInvalidLines(ignoreInvalidLines) {\n\t\tthis._ignoreInvalidLines = ignoreInvalidLines;\n\t},\n\tvalidCoordinateSequence: function validCoordinateSequence(pts) {\n\t\tif (pts.length >= 2) return pts;\n\t\tvar validPts = [pts[0], pts[0]];\n\t\treturn validPts;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn LinearGeometryBuilder;\n\t}\n});\n\nfunction ExtractLineByLocation() {\n\tthis._line = null;\n\tvar line = arguments[0];\n\tthis._line = line;\n}\nextend(ExtractLineByLocation.prototype, {\n\tcomputeLinear: function computeLinear(start, end) {\n\t\tvar builder = new LinearGeometryBuilder(this._line.getFactory());\n\t\tbuilder.setFixInvalidLines(true);\n\t\tif (!start.isVertex()) builder.add(start.getCoordinate(this._line));\n\t\tfor (var it = new LinearIterator(this._line, start); it.hasNext(); it.next()) {\n\t\t\tif (end.compareLocationValues(it.getComponentIndex(), it.getVertexIndex(), 0.0) < 0) break;\n\t\t\tvar pt = it.getSegmentStart();\n\t\t\tbuilder.add(pt);\n\t\t\tif (it.isEndOfLine()) builder.endLine();\n\t\t}\n\t\tif (!end.isVertex()) builder.add(end.getCoordinate(this._line));\n\t\treturn builder.getGeometry();\n\t},\n\tcomputeLine: function computeLine(start, end) {\n\t\tvar coordinates = this._line.getCoordinates();\n\t\tvar newCoordinates = new CoordinateList();\n\t\tvar startSegmentIndex = start.getSegmentIndex();\n\t\tif (start.getSegmentFraction() > 0.0) startSegmentIndex += 1;\n\t\tvar lastSegmentIndex = end.getSegmentIndex();\n\t\tif (end.getSegmentFraction() === 1.0) lastSegmentIndex += 1;\n\t\tif (lastSegmentIndex >= coordinates.length) lastSegmentIndex = coordinates.length - 1;\n\t\tif (!start.isVertex()) newCoordinates.add(start.getCoordinate(this._line));\n\t\tfor (var i = startSegmentIndex; i <= lastSegmentIndex; i++) {\n\t\t\tnewCoordinates.add(coordinates[i]);\n\t\t}\n\t\tif (!end.isVertex()) newCoordinates.add(end.getCoordinate(this._line));\n\t\tif (newCoordinates.size() <= 0) newCoordinates.add(start.getCoordinate(this._line));\n\t\tvar newCoordinateArray = newCoordinates.toCoordinateArray();\n\t\tif (newCoordinateArray.length <= 1) {\n\t\t\tnewCoordinateArray = [newCoordinateArray[0], newCoordinateArray[0]];\n\t\t}\n\t\treturn this._line.getFactory().createLineString(newCoordinateArray);\n\t},\n\textract: function extract(start, end) {\n\t\tif (end.compareTo(start) < 0) {\n\t\t\treturn this.reverse(this.computeLinear(end, start));\n\t\t}\n\t\treturn this.computeLinear(start, end);\n\t},\n\treverse: function reverse(linear) {\n\t\tif (linear instanceof LineString) return linear.reverse();\n\t\tif (linear instanceof MultiLineString) return linear.reverse();\n\t\tAssert.shouldNeverReachHere(\"non-linear geometry encountered\");\n\t\treturn null;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn ExtractLineByLocation;\n\t}\n});\nExtractLineByLocation.extract = function (line, start, end) {\n\tvar ls = new ExtractLineByLocation(line);\n\treturn ls.extract(start, end);\n};\n\nfunction LocationIndexedLine() {\n\tthis._linearGeom = null;\n\tvar linearGeom = arguments[0];\n\tthis._linearGeom = linearGeom;\n\tthis.checkGeometryType();\n}\nextend(LocationIndexedLine.prototype, {\n\tclampIndex: function clampIndex(index) {\n\t\tvar loc = index.clone();\n\t\tloc.clamp(this._linearGeom);\n\t\treturn loc;\n\t},\n\tproject: function project(pt) {\n\t\treturn LocationIndexOfPoint.indexOf(this._linearGeom, pt);\n\t},\n\tcheckGeometryType: function checkGeometryType() {\n\t\tif (!(this._linearGeom instanceof LineString || this._linearGeom instanceof MultiLineString)) throw new IllegalArgumentException(\"Input geometry must be linear\");\n\t},\n\textractPoint: function extractPoint() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar index = arguments[0];\n\t\t\treturn index.getCoordinate(this._linearGeom);\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar index = arguments[0],\n\t\t\t    offsetDistance = arguments[1];\n\t\t\tvar indexLow = index.toLowest(this._linearGeom);\n\t\t\treturn indexLow.getSegment(this._linearGeom).pointAlongOffset(indexLow.getSegmentFraction(), offsetDistance);\n\t\t}\n\t},\n\tisValidIndex: function isValidIndex(index) {\n\t\treturn index.isValid(this._linearGeom);\n\t},\n\tgetEndIndex: function getEndIndex() {\n\t\treturn LinearLocation.getEndLocation(this._linearGeom);\n\t},\n\tgetStartIndex: function getStartIndex() {\n\t\treturn new LinearLocation();\n\t},\n\tindexOfAfter: function indexOfAfter(pt, minIndex) {\n\t\treturn LocationIndexOfPoint.indexOfAfter(this._linearGeom, pt, minIndex);\n\t},\n\textractLine: function extractLine(startIndex, endIndex) {\n\t\treturn ExtractLineByLocation.extract(this._linearGeom, startIndex, endIndex);\n\t},\n\tindexOf: function indexOf(pt) {\n\t\treturn LocationIndexOfPoint.indexOf(this._linearGeom, pt);\n\t},\n\tindicesOf: function indicesOf(subLine) {\n\t\treturn LocationIndexOfLine.indicesOf(this._linearGeom, subLine);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn LocationIndexedLine;\n\t}\n});\n\nfunction LengthIndexOfPoint() {\n\tthis._linearGeom = null;\n\tvar linearGeom = arguments[0];\n\tthis._linearGeom = linearGeom;\n}\nextend(LengthIndexOfPoint.prototype, {\n\tindexOf: function indexOf(inputPt) {\n\t\treturn this.indexOfFromStart(inputPt, -1.0);\n\t},\n\tindexOfFromStart: function indexOfFromStart(inputPt, minIndex) {\n\t\tvar minDistance = Double.MAX_VALUE;\n\t\tvar ptMeasure = minIndex;\n\t\tvar segmentStartMeasure = 0.0;\n\t\tvar seg = new LineSegment();\n\t\tvar it = new LinearIterator(this._linearGeom);\n\t\twhile (it.hasNext()) {\n\t\t\tif (!it.isEndOfLine()) {\n\t\t\t\tseg.p0 = it.getSegmentStart();\n\t\t\t\tseg.p1 = it.getSegmentEnd();\n\t\t\t\tvar segDistance = seg.distance(inputPt);\n\t\t\t\tvar segMeasureToPt = this.segmentNearestMeasure(seg, inputPt, segmentStartMeasure);\n\t\t\t\tif (segDistance < minDistance && segMeasureToPt > minIndex) {\n\t\t\t\t\tptMeasure = segMeasureToPt;\n\t\t\t\t\tminDistance = segDistance;\n\t\t\t\t}\n\t\t\t\tsegmentStartMeasure += seg.getLength();\n\t\t\t}\n\t\t\tit.next();\n\t\t}\n\t\treturn ptMeasure;\n\t},\n\tindexOfAfter: function indexOfAfter(inputPt, minIndex) {\n\t\tif (minIndex < 0.0) return this.indexOf(inputPt);\n\t\tvar endIndex = this._linearGeom.getLength();\n\t\tif (endIndex < minIndex) return endIndex;\n\t\tvar closestAfter = this.indexOfFromStart(inputPt, minIndex);\n\t\tAssert.isTrue(closestAfter >= minIndex, \"computed index is before specified minimum index\");\n\t\treturn closestAfter;\n\t},\n\tsegmentNearestMeasure: function segmentNearestMeasure(seg, inputPt, segmentStartMeasure) {\n\t\tvar projFactor = seg.projectionFactor(inputPt);\n\t\tif (projFactor <= 0.0) return segmentStartMeasure;\n\t\tif (projFactor <= 1.0) return segmentStartMeasure + projFactor * seg.getLength();\n\t\treturn segmentStartMeasure + seg.getLength();\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn LengthIndexOfPoint;\n\t}\n});\nLengthIndexOfPoint.indexOf = function (linearGeom, inputPt) {\n\tvar locater = new LengthIndexOfPoint(linearGeom);\n\treturn locater.indexOf(inputPt);\n};\nLengthIndexOfPoint.indexOfAfter = function (linearGeom, inputPt, minIndex) {\n\tvar locater = new LengthIndexOfPoint(linearGeom);\n\treturn locater.indexOfAfter(inputPt, minIndex);\n};\n\nfunction LengthLocationMap() {\n\tthis._linearGeom = null;\n\tvar linearGeom = arguments[0];\n\tthis._linearGeom = linearGeom;\n}\nextend(LengthLocationMap.prototype, {\n\tgetLength: function getLength(loc) {\n\t\tvar totalLength = 0.0;\n\t\tvar it = new LinearIterator(this._linearGeom);\n\t\twhile (it.hasNext()) {\n\t\t\tif (!it.isEndOfLine()) {\n\t\t\t\tvar p0 = it.getSegmentStart();\n\t\t\t\tvar p1 = it.getSegmentEnd();\n\t\t\t\tvar segLen = p1.distance(p0);\n\t\t\t\tif (loc.getComponentIndex() === it.getComponentIndex() && loc.getSegmentIndex() === it.getVertexIndex()) {\n\t\t\t\t\treturn totalLength + segLen * loc.getSegmentFraction();\n\t\t\t\t}\n\t\t\t\ttotalLength += segLen;\n\t\t\t}\n\t\t\tit.next();\n\t\t}\n\t\treturn totalLength;\n\t},\n\tresolveHigher: function resolveHigher(loc) {\n\t\tif (!loc.isEndpoint(this._linearGeom)) return loc;\n\t\tvar compIndex = loc.getComponentIndex();\n\t\tif (compIndex >= this._linearGeom.getNumGeometries() - 1) return loc;\n\t\tdo {\n\t\t\tcompIndex++;\n\t\t} while (compIndex < this._linearGeom.getNumGeometries() - 1 && this._linearGeom.getGeometryN(compIndex).getLength() === 0);\n\t\treturn new LinearLocation(compIndex, 0, 0.0);\n\t},\n\tgetLocation: function getLocation() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar length = arguments[0];\n\t\t\treturn this.getLocation(length, true);\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar length = arguments[0],\n\t\t\t    resolveLower = arguments[1];\n\t\t\tvar forwardLength = length;\n\t\t\tif (length < 0.0) {\n\t\t\t\tvar lineLen = this._linearGeom.getLength();\n\t\t\t\tforwardLength = lineLen + length;\n\t\t\t}\n\t\t\tvar loc = this.getLocationForward(forwardLength);\n\t\t\tif (resolveLower) {\n\t\t\t\treturn loc;\n\t\t\t}\n\t\t\treturn this.resolveHigher(loc);\n\t\t}\n\t},\n\tgetLocationForward: function getLocationForward(length) {\n\t\tif (length <= 0.0) return new LinearLocation();\n\t\tvar totalLength = 0.0;\n\t\tvar it = new LinearIterator(this._linearGeom);\n\t\twhile (it.hasNext()) {\n\t\t\tif (it.isEndOfLine()) {\n\t\t\t\tif (totalLength === length) {\n\t\t\t\t\tvar compIndex = it.getComponentIndex();\n\t\t\t\t\tvar segIndex = it.getVertexIndex();\n\t\t\t\t\treturn new LinearLocation(compIndex, segIndex, 0.0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar p0 = it.getSegmentStart();\n\t\t\t\tvar p1 = it.getSegmentEnd();\n\t\t\t\tvar segLen = p1.distance(p0);\n\t\t\t\tif (totalLength + segLen > length) {\n\t\t\t\t\tvar frac = (length - totalLength) / segLen;\n\t\t\t\t\tvar compIndex = it.getComponentIndex();\n\t\t\t\t\tvar segIndex = it.getVertexIndex();\n\t\t\t\t\treturn new LinearLocation(compIndex, segIndex, frac);\n\t\t\t\t}\n\t\t\t\ttotalLength += segLen;\n\t\t\t}\n\t\t\tit.next();\n\t\t}\n\t\treturn LinearLocation.getEndLocation(this._linearGeom);\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn LengthLocationMap;\n\t}\n});\nLengthLocationMap.getLength = function (linearGeom, loc) {\n\tvar locater = new LengthLocationMap(linearGeom);\n\treturn locater.getLength(loc);\n};\nLengthLocationMap.getLocation = function () {\n\tif (arguments.length === 2) {\n\t\tvar linearGeom = arguments[0],\n\t\t    length = arguments[1];\n\t\tvar locater = new LengthLocationMap(linearGeom);\n\t\treturn locater.getLocation(length);\n\t} else if (arguments.length === 3) {\n\t\tvar linearGeom = arguments[0],\n\t\t    length = arguments[1],\n\t\t    resolveLower = arguments[2];\n\t\tvar locater = new LengthLocationMap(linearGeom);\n\t\treturn locater.getLocation(length, resolveLower);\n\t}\n};\n\nfunction LengthIndexedLine() {\n\tthis._linearGeom = null;\n\tvar linearGeom = arguments[0];\n\tthis._linearGeom = linearGeom;\n}\nextend(LengthIndexedLine.prototype, {\n\tclampIndex: function clampIndex(index) {\n\t\tvar posIndex = this.positiveIndex(index);\n\t\tvar startIndex = this.getStartIndex();\n\t\tif (posIndex < startIndex) return startIndex;\n\t\tvar endIndex = this.getEndIndex();\n\t\tif (posIndex > endIndex) return endIndex;\n\t\treturn posIndex;\n\t},\n\tlocationOf: function locationOf() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar index = arguments[0];\n\t\t\treturn LengthLocationMap.getLocation(this._linearGeom, index);\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar index = arguments[0],\n\t\t\t    resolveLower = arguments[1];\n\t\t\treturn LengthLocationMap.getLocation(this._linearGeom, index, resolveLower);\n\t\t}\n\t},\n\tproject: function project(pt) {\n\t\treturn LengthIndexOfPoint.indexOf(this._linearGeom, pt);\n\t},\n\tpositiveIndex: function positiveIndex(index) {\n\t\tif (index >= 0.0) return index;\n\t\treturn this._linearGeom.getLength() + index;\n\t},\n\textractPoint: function extractPoint() {\n\t\tif (arguments.length === 1) {\n\t\t\tvar index = arguments[0];\n\t\t\tvar loc = LengthLocationMap.getLocation(this._linearGeom, index);\n\t\t\treturn loc.getCoordinate(this._linearGeom);\n\t\t} else if (arguments.length === 2) {\n\t\t\tvar index = arguments[0],\n\t\t\t    offsetDistance = arguments[1];\n\t\t\tvar loc = LengthLocationMap.getLocation(this._linearGeom, index);\n\t\t\tvar locLow = loc.toLowest(this._linearGeom);\n\t\t\treturn locLow.getSegment(this._linearGeom).pointAlongOffset(locLow.getSegmentFraction(), offsetDistance);\n\t\t}\n\t},\n\tisValidIndex: function isValidIndex(index) {\n\t\treturn index >= this.getStartIndex() && index <= this.getEndIndex();\n\t},\n\tgetEndIndex: function getEndIndex() {\n\t\treturn this._linearGeom.getLength();\n\t},\n\tgetStartIndex: function getStartIndex() {\n\t\treturn 0.0;\n\t},\n\tindexOfAfter: function indexOfAfter(pt, minIndex) {\n\t\treturn LengthIndexOfPoint.indexOfAfter(this._linearGeom, pt, minIndex);\n\t},\n\textractLine: function extractLine(startIndex, endIndex) {\n\t\tvar lil = new LocationIndexedLine(this._linearGeom);\n\t\tvar startIndex2 = this.clampIndex(startIndex);\n\t\tvar endIndex2 = this.clampIndex(endIndex);\n\t\tvar resolveStartLower = startIndex2 === endIndex2;\n\t\tvar startLoc = this.locationOf(startIndex2, resolveStartLower);\n\t\tvar endLoc = this.locationOf(endIndex2);\n\t\treturn ExtractLineByLocation.extract(this._linearGeom, startLoc, endLoc);\n\t},\n\tindexOf: function indexOf(pt) {\n\t\treturn LengthIndexOfPoint.indexOf(this._linearGeom, pt);\n\t},\n\tindicesOf: function indicesOf(subLine) {\n\t\tvar locIndex = LocationIndexOfLine.indicesOf(this._linearGeom, subLine);\n\t\tvar index = [LengthLocationMap.getLength(this._linearGeom, locIndex[0]), LengthLocationMap.getLength(this._linearGeom, locIndex[1])];\n\t\treturn index;\n\t},\n\tinterfaces_: function interfaces_() {\n\t\treturn [];\n\t},\n\tgetClass: function getClass() {\n\t\treturn LengthIndexedLine;\n\t}\n});\n\n/**\n * Takes two or more {@link Polygon|polygons} and returns a combined polygon. If the input polygons are not contiguous, this function returns a {@link MultiPolygon} feature.\n *\n * @name union\n * @param {...Feature<Polygon>} A polygon to combine\n * @returns {Feature<(Polygon|MultiPolygon)>} a combined {@link Polygon} or {@link MultiPolygon} feature\n * @example\n * var poly1 = turf.polygon([[\n *     [-82.574787, 35.594087],\n *     [-82.574787, 35.615581],\n *     [-82.545261, 35.615581],\n *     [-82.545261, 35.594087],\n *     [-82.574787, 35.594087]\n * ]], {\"fill\": \"#0f0\"});\n * var poly2 = turf.polygon([[\n *     [-82.560024, 35.585153],\n *     [-82.560024, 35.602602],\n *     [-82.52964, 35.602602],\n *     [-82.52964, 35.585153],\n *     [-82.560024, 35.585153]\n * ]], {\"fill\": \"#00f\"});\n *\n * var union = turf.union(poly1, poly2);\n *\n * //addToMap\n * var addToMap = [poly1, poly2, union];\n */\nfunction union$1() {\n    var reader = new GeoJSONReader();\n    var result = reader.read(JSON.stringify(arguments[0].geometry));\n\n    for (var i = 1; i < arguments.length; i++) {\n        result = UnionOp.union(result, reader.read(JSON.stringify(arguments[i].geometry)));\n    }\n\n    var writer = new GeoJSONWriter();\n    result = writer.write(result);\n\n    return {\n        type: 'Feature',\n        geometry: result,\n        properties: arguments[0].properties\n    };\n}\n\n/**\n * Superpone dos Feature.<Polygon>\n * @param  {google.maps.Polygon|Array.<google.maps.LatLng>|Feature.Polygon} poly1 object to transform into a Feature.Polygon\n * @param  {google.maps.Polygon|Array.<google.maps.LatLng>|Feature.Polygon} poly1 object to transform into a Feature.Polygon\n * @return {Feature.<Polygon>|Feature.<MultiPolygon>}  result of the union. If inputs are disjoint, returns a Feature.Multipolygon\n */\nfunction union(poly1, poly2) {\n  var featurePolygon1 = polygonToFeaturePolygon(poly1),\n      featurePolygon2 = polygonToFeaturePolygon(poly2),\n      FeatureUnion = union$1(featurePolygon1, featurePolygon2);\n  return FeatureUnion;\n}\n\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @name bbox\n * @param {FeatureCollection|Feature<any>} geojson input features\n * @returns {Array<number>} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction bbox$1(geojson) {\n    var BBox = [Infinity, Infinity, -Infinity, -Infinity];\n    coordEach(geojson, function (coord) {\n        if (BBox[0] > coord[0]) BBox[0] = coord[0];\n        if (BBox[1] > coord[1]) BBox[1] = coord[1];\n        if (BBox[2] < coord[0]) BBox[2] = coord[0];\n        if (BBox[3] < coord[1]) BBox[3] = coord[1];\n    });\n    return BBox;\n}\n\n/**\n * Takes a {@link Feature} or {@link FeatureCollection} and returns the absolute center point of all features.\n *\n * @name center\n * @param {GeoJSON} geojson GeoJSON to be centered\n * @param {Object} [properties={}] an Object that is used as the {@link Feature}'s properties\n * @returns {Feature<Point>} a Point feature at the absolute center point of all input features\n * @example\n * var features = turf.featureCollection([\n *   turf.point( [-97.522259, 35.4691]),\n *   turf.point( [-97.502754, 35.463455]),\n *   turf.point( [-97.508269, 35.463245])\n * ]);\n *\n * var center = turf.center(features);\n *\n * //addToMap\n * var addToMap = [features, center]\n * center.properties['marker-size'] = 'large';\n * center.properties['marker-color'] = '#000';\n */\nfunction center(geojson, properties) {\n  var ext = bbox$1(geojson);\n  var x = (ext[0] + ext[2]) / 2;\n  var y = (ext[1] + ext[3]) / 2;\n  return point([x, y], properties);\n}\n\n/**\n * Converts a WGS84 GeoJSON object into Mercator (EPSG:900913) projection\n *\n * @name toMercator\n * @param {GeoJSON|Position} geojson WGS84 GeoJSON object\n * @param {Object} [options] Optional parameters\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {GeoJSON} true/false\n * @example\n * var pt = turf.point([-71,41]);\n * var converted = turf.toMercator(pt);\n *\n * //addToMap\n * var addToMap = [pt, converted];\n */\nfunction toMercator(geojson, options) {\n    return convert(geojson, 'mercator', options);\n}\n\n/**\n * Converts a Mercator (EPSG:900913) GeoJSON object into WGS84 projection\n *\n * @name toWgs84\n * @param {GeoJSON|Position} geojson Mercator GeoJSON object\n * @param {Object} [options] Optional parameters\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {GeoJSON} true/false\n * @example\n * var pt = turf.point([-7903683.846322424, 5012341.663847514]);\n * var converted = turf.toWgs84(pt);\n *\n * //addToMap\n * var addToMap = [pt, converted];\n */\nfunction toWgs84(geojson, options) {\n    return convert(geojson, 'wgs84', options);\n}\n\n/**\n * Converts a GeoJSON coordinates to the defined `projection`\n *\n * @private\n * @param {GeoJSON} geojson GeoJSON Feature or Geometry\n * @param {string} projection defines the projection system to convert the coordinates to\n * @param {Object} [options] Optional parameters\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {GeoJSON} true/false\n */\nfunction convert(geojson, projection, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject$2(options)) throw new Error('options is invalid');\n    var mutate = options.mutate;\n\n    // Validation\n    if (!geojson) throw new Error('geojson is required');\n\n    // Handle Position\n    if (Array.isArray(geojson) && isNumber(geojson[0])) geojson = projection === 'mercator' ? convertToMercator(geojson) : convertToWgs84(geojson);\n\n    // Handle GeoJSON\n    else {\n            // Handle possible data mutation\n            if (mutate !== true) geojson = clone(geojson);\n\n            coordEach(geojson, function (coord) {\n                var newCoord = projection === 'mercator' ? convertToMercator(coord) : convertToWgs84(coord);\n                coord[0] = newCoord[0];\n                coord[1] = newCoord[1];\n            });\n        }\n    return geojson;\n}\n\n/**\n * Convert lon/lat values to 900913 x/y.\n * (from https://github.com/mapbox/sphericalmercator)\n *\n * @private\n * @param {Array<number>} lonLat WGS84 point\n * @returns {Array<number>} Mercator [x, y] point\n */\nfunction convertToMercator(lonLat) {\n    var D2R = Math.PI / 180,\n\n    // 900913 properties\n    A = 6378137.0,\n        MAXEXTENT = 20037508.342789244;\n\n    // compensate longitudes passing the 180th meridian\n    // from https://github.com/proj4js/proj4js/blob/master/lib/common/adjust_lon.js\n    var adjusted = Math.abs(lonLat[0]) <= 180 ? lonLat[0] : lonLat[0] - sign(lonLat[0]) * 360;\n    var xy = [A * adjusted * D2R, A * Math.log(Math.tan(Math.PI * 0.25 + 0.5 * lonLat[1] * D2R))];\n\n    // if xy value is beyond maxextent (e.g. poles), return maxextent\n    if (xy[0] > MAXEXTENT) xy[0] = MAXEXTENT;\n    if (xy[0] < -MAXEXTENT) xy[0] = -MAXEXTENT;\n    if (xy[1] > MAXEXTENT) xy[1] = MAXEXTENT;\n    if (xy[1] < -MAXEXTENT) xy[1] = -MAXEXTENT;\n\n    return xy;\n}\n\n/**\n * Convert 900913 x/y values to lon/lat.\n * (from https://github.com/mapbox/sphericalmercator)\n *\n * @private\n * @param {Array<number>} xy Mercator [x, y] point\n * @returns {Array<number>} WGS84 [lon, lat] point\n */\nfunction convertToWgs84(xy) {\n    // 900913 properties.\n    var R2D = 180 / Math.PI;\n    var A = 6378137.0;\n\n    return [xy[0] * R2D / A, (Math.PI * 0.5 - 2.0 * Math.atan(Math.exp(-xy[1] / A))) * R2D];\n}\n\n/**\n * Returns the sign of the input, or zero\n *\n * @private\n * @param {number} x input\n * @returns {number} -1|0|1 output\n */\nfunction sign(x) {\n    return x < 0 ? -1 : x > 0 ? 1 : 0;\n}\n\n// Adds floating point numbers with twice the normal precision.\n// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and\n// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)\n// 305–363 (1997).\n// Code adapted from GeographicLib by Charles F. F. Karney,\n// http://geographiclib.sourceforge.net/\n\nvar adder = function () {\n  return new Adder();\n};\n\nfunction Adder() {\n  this.reset();\n}\n\nAdder.prototype = {\n  constructor: Adder,\n  reset: function reset() {\n    this.s = // rounded value\n    this.t = 0; // exact error\n  },\n  add: function add(y) {\n    _add(temp, y, this.t);\n    _add(this, temp.s, this.s);\n    if (this.s) this.t += temp.t;else this.s = temp.t;\n  },\n  valueOf: function valueOf() {\n    return this.s;\n  }\n};\n\nvar temp = new Adder();\n\nfunction _add(adder, a, b) {\n  var x = adder.s = a + b,\n      bv = x - a,\n      av = x - bv;\n  adder.t = a - av + (b - bv);\n}\n\nvar epsilon = 1e-6;\n\nvar pi = Math.PI;\nvar halfPi = pi / 2;\nvar quarterPi = pi / 4;\nvar tau = pi * 2;\n\nvar degrees = 180 / pi;\nvar radians = pi / 180;\n\nvar abs = Math.abs;\nvar atan = Math.atan;\nvar atan2 = Math.atan2;\nvar cos = Math.cos;\n\nvar exp = Math.exp;\n\nvar log = Math.log;\n\nvar sin = Math.sin;\n\nvar sqrt = Math.sqrt;\nvar tan = Math.tan;\n\nfunction acos(x) {\n  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);\n}\n\nfunction asin(x) {\n  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);\n}\n\nfunction noop() {}\n\nfunction streamGeometry(geometry, stream) {\n  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {\n    streamGeometryType[geometry.type](geometry, stream);\n  }\n}\n\nvar streamObjectType = {\n  Feature: function Feature(object, stream) {\n    streamGeometry(object.geometry, stream);\n  },\n  FeatureCollection: function FeatureCollection(object, stream) {\n    var features = object.features,\n        i = -1,\n        n = features.length;\n    while (++i < n) {\n      streamGeometry(features[i].geometry, stream);\n    }\n  }\n};\n\nvar streamGeometryType = {\n  Sphere: function Sphere(object, stream) {\n    stream.sphere();\n  },\n  Point: function Point(object, stream) {\n    object = object.coordinates;\n    stream.point(object[0], object[1], object[2]);\n  },\n  MultiPoint: function MultiPoint(object, stream) {\n    var coordinates = object.coordinates,\n        i = -1,\n        n = coordinates.length;\n    while (++i < n) {\n      object = coordinates[i], stream.point(object[0], object[1], object[2]);\n    }\n  },\n  LineString: function LineString(object, stream) {\n    streamLine(object.coordinates, stream, 0);\n  },\n  MultiLineString: function MultiLineString(object, stream) {\n    var coordinates = object.coordinates,\n        i = -1,\n        n = coordinates.length;\n    while (++i < n) {\n      streamLine(coordinates[i], stream, 0);\n    }\n  },\n  Polygon: function Polygon(object, stream) {\n    streamPolygon(object.coordinates, stream);\n  },\n  MultiPolygon: function MultiPolygon(object, stream) {\n    var coordinates = object.coordinates,\n        i = -1,\n        n = coordinates.length;\n    while (++i < n) {\n      streamPolygon(coordinates[i], stream);\n    }\n  },\n  GeometryCollection: function GeometryCollection(object, stream) {\n    var geometries = object.geometries,\n        i = -1,\n        n = geometries.length;\n    while (++i < n) {\n      streamGeometry(geometries[i], stream);\n    }\n  }\n};\n\nfunction streamLine(coordinates, stream, closed) {\n  var i = -1,\n      n = coordinates.length - closed,\n      coordinate;\n  stream.lineStart();\n  while (++i < n) {\n    coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);\n  }stream.lineEnd();\n}\n\nfunction streamPolygon(coordinates, stream) {\n  var i = -1,\n      n = coordinates.length;\n  stream.polygonStart();\n  while (++i < n) {\n    streamLine(coordinates[i], stream, 1);\n  }stream.polygonEnd();\n}\n\nvar geoStream = function (object, stream) {\n  if (object && streamObjectType.hasOwnProperty(object.type)) {\n    streamObjectType[object.type](object, stream);\n  } else {\n    streamGeometry(object, stream);\n  }\n};\n\nvar areaRingSum = adder();\n\nvar areaSum = adder();\n\nfunction spherical(cartesian) {\n  return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];\n}\n\nfunction cartesian(spherical) {\n  var lambda = spherical[0],\n      phi = spherical[1],\n      cosPhi = cos(phi);\n  return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];\n}\n\nfunction cartesianDot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n\nfunction cartesianCross(a, b) {\n  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];\n}\n\n// TODO return a\nfunction cartesianAddInPlace(a, b) {\n  a[0] += b[0], a[1] += b[1], a[2] += b[2];\n}\n\nfunction cartesianScale(vector, k) {\n  return [vector[0] * k, vector[1] * k, vector[2] * k];\n}\n\n// TODO return d\nfunction cartesianNormalizeInPlace(d) {\n  var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);\n  d[0] /= l, d[1] /= l, d[2] /= l;\n}\n\nvar deltaSum = adder();\n\nvar compose = function (a, b) {\n\n  function compose(x, y) {\n    return x = a(x, y), b(x[0], x[1]);\n  }\n\n  if (a.invert && b.invert) compose.invert = function (x, y) {\n    return x = b.invert(x, y), x && a.invert(x[0], x[1]);\n  };\n\n  return compose;\n};\n\nfunction rotationIdentity(lambda, phi) {\n  return [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];\n}\n\nrotationIdentity.invert = rotationIdentity;\n\nfunction rotateRadians(deltaLambda, deltaPhi, deltaGamma) {\n  return (deltaLambda %= tau) ? deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;\n}\n\nfunction forwardRotationLambda(deltaLambda) {\n  return function (lambda, phi) {\n    return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];\n  };\n}\n\nfunction rotationLambda(deltaLambda) {\n  var rotation = forwardRotationLambda(deltaLambda);\n  rotation.invert = forwardRotationLambda(-deltaLambda);\n  return rotation;\n}\n\nfunction rotationPhiGamma(deltaPhi, deltaGamma) {\n  var cosDeltaPhi = cos(deltaPhi),\n      sinDeltaPhi = sin(deltaPhi),\n      cosDeltaGamma = cos(deltaGamma),\n      sinDeltaGamma = sin(deltaGamma);\n\n  function rotation(lambda, phi) {\n    var cosPhi = cos(phi),\n        x = cos(lambda) * cosPhi,\n        y = sin(lambda) * cosPhi,\n        z = sin(phi),\n        k = z * cosDeltaPhi + x * sinDeltaPhi;\n    return [atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi), asin(k * cosDeltaGamma + y * sinDeltaGamma)];\n  }\n\n  rotation.invert = function (lambda, phi) {\n    var cosPhi = cos(phi),\n        x = cos(lambda) * cosPhi,\n        y = sin(lambda) * cosPhi,\n        z = sin(phi),\n        k = z * cosDeltaGamma - y * sinDeltaGamma;\n    return [atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi), asin(k * cosDeltaPhi - x * sinDeltaPhi)];\n  };\n\n  return rotation;\n}\n\nvar rotation = function (rotate) {\n  rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);\n\n  function forward(coordinates) {\n    coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);\n    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;\n  }\n\n  forward.invert = function (coordinates) {\n    coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);\n    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;\n  };\n\n  return forward;\n};\n\n// Generates a circle centered at [0°, 0°], with a given radius and precision.\nfunction circleStream(stream, radius, delta, direction, t0, t1) {\n  if (!delta) return;\n  var cosRadius = cos(radius),\n      sinRadius = sin(radius),\n      step = direction * delta;\n  if (t0 == null) {\n    t0 = radius + direction * tau;\n    t1 = radius - step / 2;\n  } else {\n    t0 = circleRadius(cosRadius, t0);\n    t1 = circleRadius(cosRadius, t1);\n    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau;\n  }\n  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {\n    point = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);\n    stream.point(point[0], point[1]);\n  }\n}\n\n// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].\nfunction circleRadius(cosRadius, point) {\n  point = cartesian(point), point[0] -= cosRadius;\n  cartesianNormalizeInPlace(point);\n  var radius = acos(-point[1]);\n  return ((-point[2] < 0 ? -radius : radius) + tau - epsilon) % tau;\n}\n\nvar clipBuffer = function () {\n  var lines = [],\n      line;\n  return {\n    point: function point(x, y) {\n      line.push([x, y]);\n    },\n    lineStart: function lineStart() {\n      lines.push(line = []);\n    },\n    lineEnd: noop,\n    rejoin: function rejoin() {\n      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));\n    },\n    result: function result() {\n      var result = lines;\n      lines = [];\n      line = null;\n      return result;\n    }\n  };\n};\n\nvar clipLine = function (a, b, x0, y0, x1, y1) {\n  var ax = a[0],\n      ay = a[1],\n      bx = b[0],\n      by = b[1],\n      t0 = 0,\n      t1 = 1,\n      dx = bx - ax,\n      dy = by - ay,\n      r;\n\n  r = x0 - ax;\n  if (!dx && r > 0) return;\n  r /= dx;\n  if (dx < 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  } else if (dx > 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  }\n\n  r = x1 - ax;\n  if (!dx && r < 0) return;\n  r /= dx;\n  if (dx < 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  } else if (dx > 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  }\n\n  r = y0 - ay;\n  if (!dy && r > 0) return;\n  r /= dy;\n  if (dy < 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  } else if (dy > 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  }\n\n  r = y1 - ay;\n  if (!dy && r < 0) return;\n  r /= dy;\n  if (dy < 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  } else if (dy > 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  }\n\n  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;\n  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;\n  return true;\n};\n\nvar pointEqual = function (a, b) {\n  return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;\n};\n\nfunction Intersection(point, points, other, entry) {\n  this.x = point;\n  this.z = points;\n  this.o = other; // another intersection\n  this.e = entry; // is an entry?\n  this.v = false; // visited\n  this.n = this.p = null; // next & previous\n}\n\n// A generalized polygon clipping algorithm: given a polygon that has been cut\n// into its visible line segments, and rejoins the segments by interpolating\n// along the clip edge.\nvar clipPolygon = function (segments, compareIntersection, startInside, interpolate, stream) {\n  var subject = [],\n      clip = [],\n      i,\n      n;\n\n  segments.forEach(function (segment) {\n    if ((n = segment.length - 1) <= 0) return;\n    var n,\n        p0 = segment[0],\n        p1 = segment[n],\n        x;\n\n    // If the first and last points of a segment are coincident, then treat as a\n    // closed ring. TODO if all rings are closed, then the winding order of the\n    // exterior ring should be checked.\n    if (pointEqual(p0, p1)) {\n      stream.lineStart();\n      for (i = 0; i < n; ++i) {\n        stream.point((p0 = segment[i])[0], p0[1]);\n      }stream.lineEnd();\n      return;\n    }\n\n    subject.push(x = new Intersection(p0, segment, null, true));\n    clip.push(x.o = new Intersection(p0, null, x, false));\n    subject.push(x = new Intersection(p1, segment, null, false));\n    clip.push(x.o = new Intersection(p1, null, x, true));\n  });\n\n  if (!subject.length) return;\n\n  clip.sort(compareIntersection);\n  link(subject);\n  link(clip);\n\n  for (i = 0, n = clip.length; i < n; ++i) {\n    clip[i].e = startInside = !startInside;\n  }\n\n  var start = subject[0],\n      points,\n      point;\n\n  while (1) {\n    // Find first unvisited intersection.\n    var current = start,\n        isSubject = true;\n    while (current.v) {\n      if ((current = current.n) === start) return;\n    }points = current.z;\n    stream.lineStart();\n    do {\n      current.v = current.o.v = true;\n      if (current.e) {\n        if (isSubject) {\n          for (i = 0, n = points.length; i < n; ++i) {\n            stream.point((point = points[i])[0], point[1]);\n          }\n        } else {\n          interpolate(current.x, current.n.x, 1, stream);\n        }\n        current = current.n;\n      } else {\n        if (isSubject) {\n          points = current.p.z;\n          for (i = points.length - 1; i >= 0; --i) {\n            stream.point((point = points[i])[0], point[1]);\n          }\n        } else {\n          interpolate(current.x, current.p.x, -1, stream);\n        }\n        current = current.p;\n      }\n      current = current.o;\n      points = current.z;\n      isSubject = !isSubject;\n    } while (!current.v);\n    stream.lineEnd();\n  }\n};\n\nfunction link(array) {\n  if (!(n = array.length)) return;\n  var n,\n      i = 0,\n      a = array[0],\n      b;\n  while (++i < n) {\n    a.n = b = array[i];\n    b.p = a;\n    a = b;\n  }\n  a.n = b = array[0];\n  b.p = a;\n}\n\nvar ascending = function (a, b) {\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n};\n\nvar bisector = function (compare) {\n  if (compare.length === 1) compare = ascendingComparator(compare);\n  return {\n    left: function left(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (compare(a[mid], x) < 0) lo = mid + 1;else hi = mid;\n      }\n      return lo;\n    },\n    right: function right(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (compare(a[mid], x) > 0) hi = mid;else lo = mid + 1;\n      }\n      return lo;\n    }\n  };\n};\n\nfunction ascendingComparator(f) {\n  return function (d, x) {\n    return ascending(f(d), x);\n  };\n}\n\nvar ascendingBisect = bisector(ascending);\n\nvar merge$1 = function (arrays) {\n  var n = arrays.length,\n      m,\n      i = -1,\n      j = 0,\n      merged,\n      array;\n\n  while (++i < n) {\n    j += arrays[i].length;\n  }merged = new Array(j);\n\n  while (--n >= 0) {\n    array = arrays[n];\n    m = array.length;\n    while (--m >= 0) {\n      merged[--j] = array[m];\n    }\n  }\n\n  return merged;\n};\n\nvar clipMax = 1e9;\nvar clipMin = -clipMax;\n\n// TODO Use d3-polygon’s polygonContains here for the ring check?\n// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?\n\nfunction clipExtent(x0, y0, x1, y1) {\n\n  function visible(x, y) {\n    return x0 <= x && x <= x1 && y0 <= y && y <= y1;\n  }\n\n  function interpolate(from, to, direction, stream) {\n    var a = 0,\n        a1 = 0;\n    if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {\n      do {\n        stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);\n      } while ((a = (a + direction + 4) % 4) !== a1);\n    } else {\n      stream.point(to[0], to[1]);\n    }\n  }\n\n  function corner(p, direction) {\n    return abs(p[0] - x0) < epsilon ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < epsilon ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < epsilon ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon\n  }\n\n  function compareIntersection(a, b) {\n    return comparePoint(a.x, b.x);\n  }\n\n  function comparePoint(a, b) {\n    var ca = corner(a, 1),\n        cb = corner(b, 1);\n    return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];\n  }\n\n  return function (stream) {\n    var activeStream = stream,\n        bufferStream = clipBuffer(),\n        segments,\n        polygon,\n        ring,\n        x__,\n        y__,\n        v__,\n        // first point\n    x_,\n        y_,\n        v_,\n        // previous point\n    first,\n        clean;\n\n    var clipStream = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: polygonStart,\n      polygonEnd: polygonEnd\n    };\n\n    function point(x, y) {\n      if (visible(x, y)) activeStream.point(x, y);\n    }\n\n    function polygonInside() {\n      var winding = 0;\n\n      for (var i = 0, n = polygon.length; i < n; ++i) {\n        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {\n          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];\n          if (a1 <= y1) {\n            if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding;\n          } else {\n            if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding;\n          }\n        }\n      }\n\n      return winding;\n    }\n\n    // Buffer geometry within a polygon and then clip it en masse.\n    function polygonStart() {\n      activeStream = bufferStream, segments = [], polygon = [], clean = true;\n    }\n\n    function polygonEnd() {\n      var startInside = polygonInside(),\n          cleanInside = clean && startInside,\n          visible = (segments = merge$1(segments)).length;\n      if (cleanInside || visible) {\n        stream.polygonStart();\n        if (cleanInside) {\n          stream.lineStart();\n          interpolate(null, null, 1, stream);\n          stream.lineEnd();\n        }\n        if (visible) {\n          clipPolygon(segments, compareIntersection, startInside, interpolate, stream);\n        }\n        stream.polygonEnd();\n      }\n      activeStream = stream, segments = polygon = ring = null;\n    }\n\n    function lineStart() {\n      clipStream.point = linePoint;\n      if (polygon) polygon.push(ring = []);\n      first = true;\n      v_ = false;\n      x_ = y_ = NaN;\n    }\n\n    // TODO rather than special-case polygons, simply handle them separately.\n    // Ideally, coincident intersection points should be jittered to avoid\n    // clipping issues.\n    function lineEnd() {\n      if (segments) {\n        linePoint(x__, y__);\n        if (v__ && v_) bufferStream.rejoin();\n        segments.push(bufferStream.result());\n      }\n      clipStream.point = point;\n      if (v_) activeStream.lineEnd();\n    }\n\n    function linePoint(x, y) {\n      var v = visible(x, y);\n      if (polygon) ring.push([x, y]);\n      if (first) {\n        x__ = x, y__ = y, v__ = v;\n        first = false;\n        if (v) {\n          activeStream.lineStart();\n          activeStream.point(x, y);\n        }\n      } else {\n        if (v && v_) activeStream.point(x, y);else {\n          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],\n              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];\n          if (clipLine(a, b, x0, y0, x1, y1)) {\n            if (!v_) {\n              activeStream.lineStart();\n              activeStream.point(a[0], a[1]);\n            }\n            activeStream.point(b[0], b[1]);\n            if (!v) activeStream.lineEnd();\n            clean = false;\n          } else if (v) {\n            activeStream.lineStart();\n            activeStream.point(x, y);\n            clean = false;\n          }\n        }\n      }\n      x_ = x, y_ = y, v_ = v;\n    }\n\n    return clipStream;\n  };\n}\n\nvar sum$1 = adder();\n\nvar polygonContains = function (polygon, point) {\n  var lambda = point[0],\n      phi = point[1],\n      normal = [sin(lambda), -cos(lambda), 0],\n      angle = 0,\n      winding = 0;\n\n  sum$1.reset();\n\n  for (var i = 0, n = polygon.length; i < n; ++i) {\n    if (!(m = (ring = polygon[i]).length)) continue;\n    var ring,\n        m,\n        point0 = ring[m - 1],\n        lambda0 = point0[0],\n        phi0 = point0[1] / 2 + quarterPi,\n        sinPhi0 = sin(phi0),\n        cosPhi0 = cos(phi0);\n\n    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {\n      var point1 = ring[j],\n          lambda1 = point1[0],\n          phi1 = point1[1] / 2 + quarterPi,\n          sinPhi1 = sin(phi1),\n          cosPhi1 = cos(phi1),\n          delta = lambda1 - lambda0,\n          sign = delta >= 0 ? 1 : -1,\n          absDelta = sign * delta,\n          antimeridian = absDelta > pi,\n          k = sinPhi0 * sinPhi1;\n\n      sum$1.add(atan2(k * sign * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta)));\n      angle += antimeridian ? delta + sign * tau : delta;\n\n      // Are the longitudes either side of the point’s meridian (lambda),\n      // and are the latitudes smaller than the parallel (phi)?\n      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {\n        var arc = cartesianCross(cartesian(point0), cartesian(point1));\n        cartesianNormalizeInPlace(arc);\n        var intersection = cartesianCross(normal, arc);\n        cartesianNormalizeInPlace(intersection);\n        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);\n        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {\n          winding += antimeridian ^ delta >= 0 ? 1 : -1;\n        }\n      }\n    }\n  }\n\n  // First, determine whether the South pole is inside or outside:\n  //\n  // It is inside if:\n  // * the polygon winds around it in a clockwise direction.\n  // * the polygon does not (cumulatively) wind around it, but has a negative\n  //   (counter-clockwise) area.\n  //\n  // Second, count the (signed) number of times a segment crosses a lambda\n  // from the point to the South pole.  If it is zero, then the point is the\n  // same side as the South pole.\n\n  return (angle < -epsilon || angle < epsilon && sum$1 < -epsilon) ^ winding & 1;\n};\n\nvar lengthSum = adder();\n\nvar identity$4 = function (x) {\n  return x;\n};\n\nvar areaSum$1 = adder();\nvar areaRingSum$1 = adder();\n\nvar x0$2 = Infinity;\nvar y0$2 = x0$2;\nvar x1 = -x0$2;\nvar y1 = x1;\n\nvar boundsStream$1 = {\n  point: boundsPoint$1,\n  lineStart: noop,\n  lineEnd: noop,\n  polygonStart: noop,\n  polygonEnd: noop,\n  result: function result() {\n    var bounds = [[x0$2, y0$2], [x1, y1]];\n    x1 = y1 = -(y0$2 = x0$2 = Infinity);\n    return bounds;\n  }\n};\n\nfunction boundsPoint$1(x, y) {\n  if (x < x0$2) x0$2 = x;\n  if (x > x1) x1 = x;\n  if (y < y0$2) y0$2 = y;\n  if (y > y1) y1 = y;\n}\n\nvar lengthSum$1 = adder();\n\nvar clip = function (pointVisible, clipLine, interpolate, start) {\n  return function (rotate, sink) {\n    var line = clipLine(sink),\n        rotatedStart = rotate.invert(start[0], start[1]),\n        ringBuffer = clipBuffer(),\n        ringSink = clipLine(ringBuffer),\n        polygonStarted = false,\n        polygon,\n        segments,\n        ring;\n\n    var clip = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: function polygonStart() {\n        clip.point = pointRing;\n        clip.lineStart = ringStart;\n        clip.lineEnd = ringEnd;\n        segments = [];\n        polygon = [];\n      },\n      polygonEnd: function polygonEnd() {\n        clip.point = point;\n        clip.lineStart = lineStart;\n        clip.lineEnd = lineEnd;\n        segments = merge$1(segments);\n        var startInside = polygonContains(polygon, rotatedStart);\n        if (segments.length) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          clipPolygon(segments, compareIntersection, startInside, interpolate, sink);\n        } else if (startInside) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          interpolate(null, null, 1, sink);\n          sink.lineEnd();\n        }\n        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;\n        segments = polygon = null;\n      },\n      sphere: function sphere() {\n        sink.polygonStart();\n        sink.lineStart();\n        interpolate(null, null, 1, sink);\n        sink.lineEnd();\n        sink.polygonEnd();\n      }\n    };\n\n    function point(lambda, phi) {\n      var point = rotate(lambda, phi);\n      if (pointVisible(lambda = point[0], phi = point[1])) sink.point(lambda, phi);\n    }\n\n    function pointLine(lambda, phi) {\n      var point = rotate(lambda, phi);\n      line.point(point[0], point[1]);\n    }\n\n    function lineStart() {\n      clip.point = pointLine;\n      line.lineStart();\n    }\n\n    function lineEnd() {\n      clip.point = point;\n      line.lineEnd();\n    }\n\n    function pointRing(lambda, phi) {\n      ring.push([lambda, phi]);\n      var point = rotate(lambda, phi);\n      ringSink.point(point[0], point[1]);\n    }\n\n    function ringStart() {\n      ringSink.lineStart();\n      ring = [];\n    }\n\n    function ringEnd() {\n      pointRing(ring[0][0], ring[0][1]);\n      ringSink.lineEnd();\n\n      var clean = ringSink.clean(),\n          ringSegments = ringBuffer.result(),\n          i,\n          n = ringSegments.length,\n          m,\n          segment,\n          point;\n\n      ring.pop();\n      polygon.push(ring);\n      ring = null;\n\n      if (!n) return;\n\n      // No intersections.\n      if (clean & 1) {\n        segment = ringSegments[0];\n        if ((m = segment.length - 1) > 0) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          for (i = 0; i < m; ++i) {\n            sink.point((point = segment[i])[0], point[1]);\n          }sink.lineEnd();\n        }\n        return;\n      }\n\n      // Rejoin connected segments.\n      // TODO reuse ringBuffer.rejoin()?\n      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n\n      segments.push(ringSegments.filter(validSegment));\n    }\n\n    return clip;\n  };\n};\n\nfunction validSegment(segment) {\n  return segment.length > 1;\n}\n\n// Intersections are sorted along the clip edge. For both antimeridian cutting\n// and circle clipping, the same comparison is used.\nfunction compareIntersection(a, b) {\n  return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);\n}\n\nvar clipAntimeridian = clip(function () {\n  return true;\n}, clipAntimeridianLine, clipAntimeridianInterpolate, [-pi, -halfPi]);\n\n// Takes a line and cuts into visible segments. Return values: 0 - there were\n// intersections or the line was empty; 1 - no intersections; 2 - there were\n// intersections, and the first and last segments should be rejoined.\nfunction clipAntimeridianLine(stream) {\n  var lambda0 = NaN,\n      phi0 = NaN,\n      sign0 = NaN,\n      _clean; // no intersections\n\n  return {\n    lineStart: function lineStart() {\n      stream.lineStart();\n      _clean = 1;\n    },\n    point: function point(lambda1, phi1) {\n      var sign1 = lambda1 > 0 ? pi : -pi,\n          delta = abs(lambda1 - lambda0);\n      if (abs(delta - pi) < epsilon) {\n        // line crosses a pole\n        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);\n        stream.point(sign0, phi0);\n        stream.lineEnd();\n        stream.lineStart();\n        stream.point(sign1, phi0);\n        stream.point(lambda1, phi0);\n        _clean = 0;\n      } else if (sign0 !== sign1 && delta >= pi) {\n        // line crosses antimeridian\n        if (abs(lambda0 - sign0) < epsilon) lambda0 -= sign0 * epsilon; // handle degeneracies\n        if (abs(lambda1 - sign1) < epsilon) lambda1 -= sign1 * epsilon;\n        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);\n        stream.point(sign0, phi0);\n        stream.lineEnd();\n        stream.lineStart();\n        stream.point(sign1, phi0);\n        _clean = 0;\n      }\n      stream.point(lambda0 = lambda1, phi0 = phi1);\n      sign0 = sign1;\n    },\n    lineEnd: function lineEnd() {\n      stream.lineEnd();\n      lambda0 = phi0 = NaN;\n    },\n    clean: function clean() {\n      return 2 - _clean; // if intersections, rejoin first and last segments\n    }\n  };\n}\n\nfunction clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {\n  var cosPhi0,\n      cosPhi1,\n      sinLambda0Lambda1 = sin(lambda0 - lambda1);\n  return abs(sinLambda0Lambda1) > epsilon ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1) - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;\n}\n\nfunction clipAntimeridianInterpolate(from, to, direction, stream) {\n  var phi;\n  if (from == null) {\n    phi = direction * halfPi;\n    stream.point(-pi, phi);\n    stream.point(0, phi);\n    stream.point(pi, phi);\n    stream.point(pi, 0);\n    stream.point(pi, -phi);\n    stream.point(0, -phi);\n    stream.point(-pi, -phi);\n    stream.point(-pi, 0);\n    stream.point(-pi, phi);\n  } else if (abs(from[0] - to[0]) > epsilon) {\n    var lambda = from[0] < to[0] ? pi : -pi;\n    phi = direction * lambda / 2;\n    stream.point(-lambda, phi);\n    stream.point(0, phi);\n    stream.point(lambda, phi);\n  } else {\n    stream.point(to[0], to[1]);\n  }\n}\n\nvar clipCircle = function (radius, delta) {\n  var cr = cos(radius),\n      smallRadius = cr > 0,\n      notHemisphere = abs(cr) > epsilon; // TODO optimise for this common case\n\n  function interpolate(from, to, direction, stream) {\n    circleStream(stream, radius, delta, direction, from, to);\n  }\n\n  function visible(lambda, phi) {\n    return cos(lambda) * cos(phi) > cr;\n  }\n\n  // Takes a line and cuts into visible segments. Return values used for polygon\n  // clipping: 0 - there were intersections or the line was empty; 1 - no\n  // intersections 2 - there were intersections, and the first and last segments\n  // should be rejoined.\n  function clipLine(stream) {\n    var point0, // previous point\n    c0, // code for previous point\n    v0, // visibility of previous point\n    v00, // visibility of first point\n    _clean; // no intersections\n    return {\n      lineStart: function lineStart() {\n        v00 = v0 = false;\n        _clean = 1;\n      },\n      point: function point(lambda, phi) {\n        var point1 = [lambda, phi],\n            point2,\n            v = visible(lambda, phi),\n            c = smallRadius ? v ? 0 : code(lambda, phi) : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;\n        if (!point0 && (v00 = v0 = v)) stream.lineStart();\n        // Handle degeneracies.\n        // TODO ignore if not clipping polygons.\n        if (v !== v0) {\n          point2 = intersect(point0, point1);\n          if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {\n            point1[0] += epsilon;\n            point1[1] += epsilon;\n            v = visible(point1[0], point1[1]);\n          }\n        }\n        if (v !== v0) {\n          _clean = 0;\n          if (v) {\n            // outside going in\n            stream.lineStart();\n            point2 = intersect(point1, point0);\n            stream.point(point2[0], point2[1]);\n          } else {\n            // inside going out\n            point2 = intersect(point0, point1);\n            stream.point(point2[0], point2[1]);\n            stream.lineEnd();\n          }\n          point0 = point2;\n        } else if (notHemisphere && point0 && smallRadius ^ v) {\n          var t;\n          // If the codes for two points are different, or are both zero,\n          // and there this segment intersects with the small circle.\n          if (!(c & c0) && (t = intersect(point1, point0, true))) {\n            _clean = 0;\n            if (smallRadius) {\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1]);\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n            } else {\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1]);\n            }\n          }\n        }\n        if (v && (!point0 || !pointEqual(point0, point1))) {\n          stream.point(point1[0], point1[1]);\n        }\n        point0 = point1, v0 = v, c0 = c;\n      },\n      lineEnd: function lineEnd() {\n        if (v0) stream.lineEnd();\n        point0 = null;\n      },\n      // Rejoin first and last segments if there were intersections and the first\n      // and last points were visible.\n      clean: function clean() {\n        return _clean | (v00 && v0) << 1;\n      }\n    };\n  }\n\n  // Intersects the great circle between a and b with the clip circle.\n  function intersect(a, b, two) {\n    var pa = cartesian(a),\n        pb = cartesian(b);\n\n    // We have two planes, n1.p = d1 and n2.p = d2.\n    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).\n    var n1 = [1, 0, 0],\n        // normal\n    n2 = cartesianCross(pa, pb),\n        n2n2 = cartesianDot(n2, n2),\n        n1n2 = n2[0],\n        // cartesianDot(n1, n2),\n    determinant = n2n2 - n1n2 * n1n2;\n\n    // Two polar points.\n    if (!determinant) return !two && a;\n\n    var c1 = cr * n2n2 / determinant,\n        c2 = -cr * n1n2 / determinant,\n        n1xn2 = cartesianCross(n1, n2),\n        A = cartesianScale(n1, c1),\n        B = cartesianScale(n2, c2);\n    cartesianAddInPlace(A, B);\n\n    // Solve |p(t)|^2 = 1.\n    var u = n1xn2,\n        w = cartesianDot(A, u),\n        uu = cartesianDot(u, u),\n        t2 = w * w - uu * (cartesianDot(A, A) - 1);\n\n    if (t2 < 0) return;\n\n    var t = sqrt(t2),\n        q = cartesianScale(u, (-w - t) / uu);\n    cartesianAddInPlace(q, A);\n    q = spherical(q);\n\n    if (!two) return q;\n\n    // Two intersection points.\n    var lambda0 = a[0],\n        lambda1 = b[0],\n        phi0 = a[1],\n        phi1 = b[1],\n        z;\n\n    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;\n\n    var delta = lambda1 - lambda0,\n        polar = abs(delta - pi) < epsilon,\n        meridian = polar || delta < epsilon;\n\n    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;\n\n    // Check that the first point is between a and b.\n    if (meridian ? polar ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {\n      var q1 = cartesianScale(u, (-w + t) / uu);\n      cartesianAddInPlace(q1, A);\n      return [q, spherical(q1)];\n    }\n  }\n\n  // Generates a 4-bit vector representing the location of a point relative to\n  // the small circle's bounding box.\n  function code(lambda, phi) {\n    var r = smallRadius ? radius : pi - radius,\n        code = 0;\n    if (lambda < -r) code |= 1; // left\n    else if (lambda > r) code |= 2; // right\n    if (phi < -r) code |= 4; // below\n    else if (phi > r) code |= 8; // above\n    return code;\n  }\n\n  return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);\n};\n\nfunction transformer(methods) {\n  return function (stream) {\n    var s = new TransformStream();\n    for (var key in methods) {\n      s[key] = methods[key];\n    }s.stream = stream;\n    return s;\n  };\n}\n\nfunction TransformStream() {}\n\nTransformStream.prototype = {\n  constructor: TransformStream,\n  point: function point(x, y) {\n    this.stream.point(x, y);\n  },\n  sphere: function sphere() {\n    this.stream.sphere();\n  },\n  lineStart: function lineStart() {\n    this.stream.lineStart();\n  },\n  lineEnd: function lineEnd() {\n    this.stream.lineEnd();\n  },\n  polygonStart: function polygonStart() {\n    this.stream.polygonStart();\n  },\n  polygonEnd: function polygonEnd() {\n    this.stream.polygonEnd();\n  }\n};\n\nfunction fitExtent(projection, extent, object) {\n    var w = extent[1][0] - extent[0][0],\n        h = extent[1][1] - extent[0][1],\n        clip = projection.clipExtent && projection.clipExtent();\n\n    projection.scale(150).translate([0, 0]);\n\n    if (clip != null) projection.clipExtent(null);\n\n    geoStream(object, projection.stream(boundsStream$1));\n\n    var b = boundsStream$1.result(),\n        k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),\n        x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,\n        y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;\n\n    if (clip != null) projection.clipExtent(clip);\n\n    return projection.scale(k * 150).translate([x, y]);\n}\n\nfunction fitSize(projection, size, object) {\n    return fitExtent(projection, [[0, 0], size], object);\n}\n\nvar maxDepth = 16;\nvar cosMinDistance = cos(30 * radians); // cos(minimum angular distance)\n\nvar resample = function (project, delta2) {\n  return +delta2 ? resample$1(project, delta2) : resampleNone(project);\n};\n\nfunction resampleNone(project) {\n  return transformer({\n    point: function point(x, y) {\n      x = project(x, y);\n      this.stream.point(x[0], x[1]);\n    }\n  });\n}\n\nfunction resample$1(project, delta2) {\n\n  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {\n    var dx = x1 - x0,\n        dy = y1 - y0,\n        d2 = dx * dx + dy * dy;\n    if (d2 > 4 * delta2 && depth--) {\n      var a = a0 + a1,\n          b = b0 + b1,\n          c = c0 + c1,\n          m = sqrt(a * a + b * b + c * c),\n          phi2 = asin(c /= m),\n          lambda2 = abs(abs(c) - 1) < epsilon || abs(lambda0 - lambda1) < epsilon ? (lambda0 + lambda1) / 2 : atan2(b, a),\n          p = project(lambda2, phi2),\n          x2 = p[0],\n          y2 = p[1],\n          dx2 = x2 - x0,\n          dy2 = y2 - y0,\n          dz = dy * dx2 - dx * dy2;\n      if (dz * dz / d2 > delta2 // perpendicular projected distance\n      || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end\n      || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {\n        // angular distance\n        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);\n        stream.point(x2, y2);\n        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);\n      }\n    }\n  }\n  return function (stream) {\n    var lambda00, x00, y00, a00, b00, c00, // first point\n    lambda0, x0, y0, a0, b0, c0; // previous point\n\n    var resampleStream = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: function polygonStart() {\n        stream.polygonStart();resampleStream.lineStart = ringStart;\n      },\n      polygonEnd: function polygonEnd() {\n        stream.polygonEnd();resampleStream.lineStart = lineStart;\n      }\n    };\n\n    function point(x, y) {\n      x = project(x, y);\n      stream.point(x[0], x[1]);\n    }\n\n    function lineStart() {\n      x0 = NaN;\n      resampleStream.point = linePoint;\n      stream.lineStart();\n    }\n\n    function linePoint(lambda, phi) {\n      var c = cartesian([lambda, phi]),\n          p = project(lambda, phi);\n      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);\n      stream.point(x0, y0);\n    }\n\n    function lineEnd() {\n      resampleStream.point = point;\n      stream.lineEnd();\n    }\n\n    function ringStart() {\n      lineStart();\n      resampleStream.point = ringPoint;\n      resampleStream.lineEnd = ringEnd;\n    }\n\n    function ringPoint(lambda, phi) {\n      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;\n      resampleStream.point = linePoint;\n    }\n\n    function ringEnd() {\n      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);\n      resampleStream.lineEnd = lineEnd;\n      lineEnd();\n    }\n\n    return resampleStream;\n  };\n}\n\nvar transformRadians = transformer({\n  point: function point(x, y) {\n    this.stream.point(x * radians, y * radians);\n  }\n});\n\nfunction projection(project) {\n  return projectionMutator(function () {\n    return project;\n  })();\n}\n\nfunction projectionMutator(projectAt) {\n  var project,\n      k = 150,\n      // scale\n  x = 480,\n      y = 250,\n      // translate\n  dx,\n      dy,\n      lambda = 0,\n      phi = 0,\n      // center\n  deltaLambda = 0,\n      deltaPhi = 0,\n      deltaGamma = 0,\n      rotate,\n      projectRotate,\n      // rotate\n  theta = null,\n      preclip = clipAntimeridian,\n      // clip angle\n  x0 = null,\n      y0,\n      x1,\n      y1,\n      postclip = identity$4,\n      // clip extent\n  delta2 = 0.5,\n      projectResample = resample(projectTransform, delta2),\n      // precision\n  cache,\n      cacheStream;\n\n  function projection(point) {\n    point = projectRotate(point[0] * radians, point[1] * radians);\n    return [point[0] * k + dx, dy - point[1] * k];\n  }\n\n  function invert(point) {\n    point = projectRotate.invert((point[0] - dx) / k, (dy - point[1]) / k);\n    return point && [point[0] * degrees, point[1] * degrees];\n  }\n\n  function projectTransform(x, y) {\n    return x = project(x, y), [x[0] * k + dx, dy - x[1] * k];\n  }\n\n  projection.stream = function (stream) {\n    return cache && cacheStream === stream ? cache : cache = transformRadians(preclip(rotate, projectResample(postclip(cacheStream = stream))));\n  };\n\n  projection.clipAngle = function (_) {\n    return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians, 6 * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;\n  };\n\n  projection.clipExtent = function (_) {\n    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$4) : clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n  };\n\n  projection.scale = function (_) {\n    return arguments.length ? (k = +_, recenter()) : k;\n  };\n\n  projection.translate = function (_) {\n    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];\n  };\n\n  projection.center = function (_) {\n    return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];\n  };\n\n  projection.rotate = function (_) {\n    return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];\n  };\n\n  projection.precision = function (_) {\n    return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);\n  };\n\n  projection.fitExtent = function (extent$$1, object) {\n    return fitExtent(projection, extent$$1, object);\n  };\n\n  projection.fitSize = function (size, object) {\n    return fitSize(projection, size, object);\n  };\n\n  function recenter() {\n    projectRotate = compose(rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma), project);\n    var center = project(lambda, phi);\n    dx = x - center[0] * k;\n    dy = y + center[1] * k;\n    return reset();\n  }\n\n  function reset() {\n    cache = cacheStream = null;\n    return projection;\n  }\n\n  return function () {\n    project = projectAt.apply(this, arguments);\n    projection.invert = project.invert && invert;\n    return recenter();\n  };\n}\n\nfunction mercatorRaw(lambda, phi) {\n  return [lambda, log(tan((halfPi + phi) / 2))];\n}\n\nmercatorRaw.invert = function (x, y) {\n  return [x, 2 * atan(exp(y)) - halfPi];\n};\n\nfunction mercatorProjection(project) {\n  var m = projection(project),\n      center = m.center,\n      scale = m.scale,\n      translate = m.translate,\n      clipExtent = m.clipExtent,\n      x0 = null,\n      y0,\n      x1,\n      y1; // clip extent\n\n  m.scale = function (_) {\n    return arguments.length ? (scale(_), reclip()) : scale();\n  };\n\n  m.translate = function (_) {\n    return arguments.length ? (translate(_), reclip()) : translate();\n  };\n\n  m.center = function (_) {\n    return arguments.length ? (center(_), reclip()) : center();\n  };\n\n  m.clipExtent = function (_) {\n    return arguments.length ? (_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n  };\n\n  function reclip() {\n    var k = pi * scale(),\n        t = m(rotation(m.rotate()).invert([0, 0]));\n    return clipExtent(x0 == null ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]] : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);\n  }\n\n  return reclip();\n}\n\nfunction transverseMercatorRaw(lambda, phi) {\n  return [log(tan((halfPi + phi) / 2)), -lambda];\n}\n\ntransverseMercatorRaw.invert = function (x, y) {\n  return [-y, 2 * atan(exp(x)) - halfPi];\n};\n\nvar geoTransverseMercator = function () {\n  var m = mercatorProjection(transverseMercatorRaw),\n      center = m.center,\n      rotate = m.rotate;\n\n  m.center = function (_) {\n    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);\n  };\n\n  m.rotate = function (_) {\n    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);\n  };\n\n  return rotate([0, 0, 90]).scale(159.155);\n};\n\n/**\n * Calculates a buffer for input features for a given radius. Units supported are miles, kilometers, and degrees.\n *\n * When using a negative radius, the resulting geometry may be invalid if\n * it's too small compared to the radius magnitude. If the input is a\n * FeatureCollection, only valid members will be returned in the output\n * FeatureCollection - i.e., the output collection may have fewer members than\n * the input, or even be empty.\n *\n * @name buffer\n * @param {FeatureCollection|Geometry|Feature<any>} geojson input to be buffered\n * @param {number} radius distance to draw the buffer (negative values are allowed)\n * @param {Object} [options] Optional parameters\n * @param {string} [options.units=\"kilometers\"] any of the options supported by turf units\n * @param {number} [options.steps=64] number of steps\n * @returns {FeatureCollection|Feature<Polygon|MultiPolygon>|undefined} buffered features\n * @example\n * var point = turf.point([-90.548630, 14.616599]);\n * var buffered = turf.buffer(point, 500, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [point, buffered]\n */\nfunction buffer$1(geojson, radius, options) {\n    // Optional params\n    options = options || {};\n    var units = options.units;\n    var steps = options.steps || 64;\n\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n    if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object') throw new Error('options must be an object');\n    if (typeof steps !== 'number') throw new Error('steps must be an number');\n\n    // Allow negative buffers (\"erosion\") or zero-sized buffers (\"repair geometry\")\n    if (radius === undefined) throw new Error('radius is required');\n    if (steps <= 0) throw new Error('steps must be greater than 0');\n\n    // default params\n    steps = steps || 64;\n    units = units || 'kilometers';\n\n    var results = [];\n    switch (geojson.type) {\n        case 'GeometryCollection':\n            geomEach(geojson, function (geometry$$1) {\n                var buffered = bufferFeature(geometry$$1, radius, units, steps);\n                if (buffered) results.push(buffered);\n            });\n            return featureCollection(results);\n        case 'FeatureCollection':\n            featureEach(geojson, function (feature$$1) {\n                var multiBuffered = bufferFeature(feature$$1, radius, units, steps);\n                if (multiBuffered) {\n                    featureEach(multiBuffered, function (buffered) {\n                        if (buffered) results.push(buffered);\n                    });\n                }\n            });\n            return featureCollection(results);\n    }\n    return bufferFeature(geojson, radius, units, steps);\n}\n\n/**\n * Buffer single Feature/Geometry\n *\n * @private\n * @param {Feature<any>} geojson input to be buffered\n * @param {number} radius distance to draw the buffer\n * @param {string} [units='kilometers'] any of the options supported by turf units\n * @param {number} [steps=64] number of steps\n * @returns {Feature<Polygon|MultiPolygon>} buffered feature\n */\nfunction bufferFeature(geojson, radius, units, steps) {\n    var properties = geojson.properties || {};\n    var geometry$$1 = geojson.type === 'Feature' ? geojson.geometry : geojson;\n\n    // Geometry Types faster than jsts\n    if (geometry$$1.type === 'GeometryCollection') {\n        var results = [];\n        geomEach(geojson, function (geometry$$1) {\n            var buffered = bufferFeature(geometry$$1, radius, units, steps);\n            if (buffered) results.push(buffered);\n        });\n        return featureCollection(results);\n    }\n\n    // Project GeoJSON to Transverse Mercator projection (convert to Meters)\n    var projected;\n    var bbox = bbox$1(geojson);\n    var needsTransverseMercator = bbox[1] > 50 && bbox[3] > 50;\n\n    if (needsTransverseMercator) {\n        projected = {\n            type: geometry$$1.type,\n            coordinates: projectCoords(geometry$$1.coordinates, defineProjection(geometry$$1))\n        };\n    } else {\n        projected = toMercator(geometry$$1);\n    }\n\n    // JSTS buffer operation\n    var reader = new GeoJSONReader();\n    var geom = reader.read(projected);\n    var distance = radiansToLength(lengthToRadians(radius, units), 'meters');\n    var buffered = BufferOp.bufferOp(geom, distance);\n    var writer = new GeoJSONWriter();\n    buffered = writer.write(buffered);\n\n    // Detect if empty geometries\n    if (coordsIsNaN(buffered.coordinates)) return undefined;\n\n    // Unproject coordinates (convert to Degrees)\n    var result;\n    if (needsTransverseMercator) {\n        result = {\n            type: buffered.type,\n            coordinates: unprojectCoords(buffered.coordinates, defineProjection(geometry$$1))\n        };\n    } else {\n        result = toWgs84(buffered);\n    }\n\n    return result.geometry ? result : feature(result, properties);\n}\n\n/**\n * Coordinates isNaN\n *\n * @private\n * @param {Array<any>} coords GeoJSON Coordinates\n * @returns {boolean} if NaN exists\n */\nfunction coordsIsNaN(coords) {\n    if (Array.isArray(coords[0])) return coordsIsNaN(coords[0]);\n    return isNaN(coords[0]);\n}\n\n/**\n * Project coordinates to projection\n *\n * @private\n * @param {Array<any>} coords to project\n * @param {GeoProjection} proj D3 Geo Projection\n * @returns {Array<any>} projected coordinates\n */\nfunction projectCoords(coords, proj) {\n    if (_typeof(coords[0]) !== 'object') return proj(coords);\n    return coords.map(function (coord) {\n        return projectCoords(coord, proj);\n    });\n}\n\n/**\n * Un-Project coordinates to projection\n *\n * @private\n * @param {Array<any>} coords to un-project\n * @param {GeoProjection} proj D3 Geo Projection\n * @returns {Array<any>} un-projected coordinates\n */\nfunction unprojectCoords(coords, proj) {\n    if (_typeof(coords[0]) !== 'object') return proj.invert(coords);\n    return coords.map(function (coord) {\n        return unprojectCoords(coord, proj);\n    });\n}\n\n/**\n * Define Transverse Mercator projection\n *\n * @private\n * @param {Geometry|Feature<any>} geojson Base projection on center of GeoJSON\n * @returns {GeoProjection} D3 Geo Transverse Mercator Projection\n */\nfunction defineProjection(geojson) {\n    var coords = center(geojson).geometry.coordinates.reverse();\n    var rotate = coords.map(function (coord) {\n        return -coord;\n    });\n    return geoTransverseMercator().center(coords).rotate(rotate).scale(earthRadius);\n}\n\n/**\n * Calculates a buffer for input features for a given radius. Units supported are miles, kilometers, and degrees.\n * @param  {google.maps.Polygon|google.maps.Polyline|google.maps.Marker|google.maps.LatLng|Array.<google.maps.LatLng>|Feature.<Polygon|Linestring|Point>} object input object\n * @param  {String} output  either 'geometry','object' (google.maps) or 'feature', case insensitive, defaults to 'feature'\n * @param  {Number} distance    [description]\n * @param  {String} units       'meters' or 'miles' etc\n * @return {Feature|Feature.<Geometry>}  A GeoJson Feature or its geometry, according to output parameter\n */\nfunction createbuffer(object, output, distance, units, comment, steps) {\n    units = units || 'meters';\n    output = (output || 'feature').toLowerCase();\n\n    var Feature;\n    if (object instanceof google.maps.Polyline || object instanceof google.maps.Polygon || object instanceof google.maps.Marker || object instanceof google.maps.LatLng) {\n        var geometry = Wicket$1().fromObject(object).toJson();\n        Feature = {\n            type: \"Feature\",\n            properties: {},\n            geometry: geometry\n        };\n    } else if (object.type && object.type === 'Feature' && object.geometry) {\n        Feature = object;\n    } else {\n        Feature = polygonToFeaturePolygon(object);\n    }\n\n    var buffered = buffer$1(Feature, distance, {\n        units: units,\n        steps: steps\n    });\n\n    if (buffered.type === 'FeatureCollection') {\n        buffered = buffered.features[0];\n    }\n\n    if (output === 'geometry') {\n        return buffered.geometry;\n    } else if (output === 'object') {\n        return Wicket$1().fromJson(buffered.geometry).toObject();\n    } else {\n        return buffered;\n    }\n}\n\n// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n\n/**\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point resides inside the polygon. The polygon can\n * be convex or concave. The function accounts for holes.\n *\n * @name booleanPointInPolygon\n * @param {Feature<Point>} point input point\n * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if the point is inside the polygon otherwise false.\n * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt = turf.point([-77, 44]);\n * var poly = turf.polygon([[\n *   [-81, 41],\n *   [-81, 47],\n *   [-72, 47],\n *   [-72, 41],\n *   [-81, 41]\n * ]]);\n *\n * turf.booleanPointInPolygon(pt, poly);\n * //= true\n */\nfunction booleanPointInPolygon(point, polygon, options) {\n    // Optional parameters\n    options = options || {};\n    if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object') throw new Error('options is invalid');\n    var ignoreBoundary = options.ignoreBoundary;\n\n    // validation\n    if (!point) throw new Error('point is required');\n    if (!polygon) throw new Error('polygon is required');\n\n    var pt = getCoord(point);\n    var polys = getCoords(polygon);\n    var type = polygon.geometry ? polygon.geometry.type : polygon.type;\n    var bbox = polygon.bbox;\n\n    // Quick elimination if point is not inside bbox\n    if (bbox && inBBox(pt, bbox) === false) return false;\n\n    // normalize to multipolygon\n    if (type === 'Polygon') polys = [polys];\n\n    for (var i = 0, insidePoly = false; i < polys.length && !insidePoly; i++) {\n        // check if it is in the outer ring first\n        if (inRing(pt, polys[i][0], ignoreBoundary)) {\n            var inHole = false;\n            var k = 1;\n            // check for the point in any of the holes\n            while (k < polys[i].length && !inHole) {\n                if (inRing(pt, polys[i][k], !ignoreBoundary)) {\n                    inHole = true;\n                }\n                k++;\n            }\n            if (!inHole) insidePoly = true;\n        }\n    }\n    return insidePoly;\n}\n\n/**\n * inRing\n *\n * @private\n * @param {Array<number>} pt [x,y]\n * @param {Array<Array<number>>} ring [[x,y], [x,y],..]\n * @param {boolean} ignoreBoundary ignoreBoundary\n * @returns {boolean} inRing\n */\nfunction inRing(pt, ring, ignoreBoundary) {\n    var isInside = false;\n    if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) ring = ring.slice(0, ring.length - 1);\n\n    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        var xi = ring[i][0],\n            yi = ring[i][1];\n        var xj = ring[j][0],\n            yj = ring[j][1];\n        var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 && (xi - pt[0]) * (xj - pt[0]) <= 0 && (yi - pt[1]) * (yj - pt[1]) <= 0;\n        if (onBoundary) return !ignoreBoundary;\n        var intersect = yi > pt[1] !== yj > pt[1] && pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi;\n        if (intersect) isInside = !isInside;\n    }\n    return isInside;\n}\n\n/**\n * inBBox\n *\n * @private\n * @param {Array<number>} pt point [x,y]\n * @param {Array<number>} bbox BBox [west, south, east, north]\n * @returns {boolean} true/false if point is inside BBox\n */\nfunction inBBox(pt, bbox) {\n    return bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1];\n}\n\n/**\n * Filters an array of points returning those who falls inside a given {@link Polygon}\n * @param {Array<google.maps.Marker>} sourceArray array of {@link google.maps.Marker}\n * @param {Polygon|Multipolygon} geojsonPolygon  the polygon thay may contain the points\n * @return {{pointsInside:Array<google.maps.Marker>, pointsOutside:Array<google.maps.Marker>}} an object with the points that fall inside and outside the polygon\n */\nfunction pointInPolygon(sourceArray, geojsonPolygon) {\n\tvar pointsInside = [];\n\tvar pointsOutside = [];\n\n\tif (geojsonPolygon.type !== 'Feature') {\n\t\tgeojsonPolygon = {\n\t\t\t\"type\": \"Feature\",\n\t\t\t\"properties\": {},\n\t\t\t\"geometry\": geojsonPolygon\n\t\t};\n\t}\n\tif (geojsonPolygon.geometry.type === 'Polygon' || geojsonPolygon.geometry.type === 'Multipolygon') {\n\t\tforEach(sourceArray, function (item) {\n\n\t\t\tvar Point = markerToFeaturePoint(item);\n\t\t\t//console.zlog('Point is', Point);\n\t\t\tif (booleanPointInPolygon(Point, geojsonPolygon)) {\n\t\t\t\tpointsInside.push(item);\n\t\t\t} else {\n\t\t\t\tpointsOutside.push(item);\n\t\t\t}\n\t\t});\n\t}\n\n\treturn {\n\t\tpointsInside: pointsInside,\n\t\tpointsOutside: pointsOutside\n\t};\n}\n\n/**\n * Takes a {@link LineString|linestring}, {@link MultiLineString|multi-linestring}, {@link MultiPolygon|multi-polygon}, or {@link Polygon|polygon} and returns {@link Point|points} at all self-intersections.\n *\n * @name kinks\n * @param {Feature<LineString|MultiLineString|MultiPolygon|Polygon>} featureIn input feature\n * @returns {FeatureCollection<Point>} self-intersections\n * @example\n * var poly = turf.polygon([[\n *   [-12.034835, 8.901183],\n *   [-12.060413, 8.899826],\n *   [-12.03638, 8.873199],\n *   [-12.059383, 8.871418],\n *   [-12.034835, 8.901183]\n * ]]);\n *\n * var kinks = turf.kinks(poly);\n *\n * //addToMap\n * var addToMap = [poly, kinks]\n */\nfunction kinks$1(featureIn) {\n    var coordinates;\n    var feature$$1;\n    var results = {\n        type: 'FeatureCollection',\n        features: []\n    };\n    if (featureIn.type === 'Feature') {\n        feature$$1 = featureIn.geometry;\n    } else {\n        feature$$1 = featureIn;\n    }\n    if (feature$$1.type === 'LineString') {\n        coordinates = [feature$$1.coordinates];\n    } else if (feature$$1.type === 'MultiLineString') {\n        coordinates = feature$$1.coordinates;\n    } else if (feature$$1.type === 'MultiPolygon') {\n        coordinates = [].concat.apply([], feature$$1.coordinates);\n    } else if (feature$$1.type === 'Polygon') {\n        coordinates = feature$$1.coordinates;\n    } else {\n        throw new Error('Input must be a LineString, MultiLineString, ' + 'Polygon, or MultiPolygon Feature or Geometry');\n    }\n    coordinates.forEach(function (line1) {\n        coordinates.forEach(function (line2) {\n            for (var i = 0; i < line1.length - 1; i++) {\n                // start iteration at i, intersections for k < i have already been checked in previous outer loop iterations\n                for (var k = i; k < line2.length - 1; k++) {\n                    if (line1 === line2) {\n                        // segments are adjacent and always share a vertex, not a kink\n                        if (Math.abs(i - k) === 1) {\n                            continue;\n                        }\n                        // first and last segment in a closed lineString or ring always share a vertex, not a kink\n                        if (\n                        // segments are first and last segment of lineString\n                        i === 0 && k === line1.length - 2 &&\n                        // lineString is closed\n                        line1[i][0] === line1[line1.length - 1][0] && line1[i][1] === line1[line1.length - 1][1]) {\n                            continue;\n                        }\n                    }\n\n                    var intersection = lineIntersects(line1[i][0], line1[i][1], line1[i + 1][0], line1[i + 1][1], line2[k][0], line2[k][1], line2[k + 1][0], line2[k + 1][1]);\n                    if (intersection) {\n                        results.features.push(point([intersection[0], intersection[1]]));\n                    }\n                }\n            }\n        });\n    });\n    return results;\n}\n\n// modified from http://jsfiddle.net/justin_c_rounds/Gd2S2/light/\nfunction lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {\n    // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point\n    var denominator,\n        a,\n        b,\n        numerator1,\n        numerator2,\n        result = {\n        x: null,\n        y: null,\n        onLine1: false,\n        onLine2: false\n    };\n    denominator = (line2EndY - line2StartY) * (line1EndX - line1StartX) - (line2EndX - line2StartX) * (line1EndY - line1StartY);\n    if (denominator === 0) {\n        if (result.x !== null && result.y !== null) {\n            return result;\n        } else {\n            return false;\n        }\n    }\n    a = line1StartY - line2StartY;\n    b = line1StartX - line2StartX;\n    numerator1 = (line2EndX - line2StartX) * a - (line2EndY - line2StartY) * b;\n    numerator2 = (line1EndX - line1StartX) * a - (line1EndY - line1StartY) * b;\n    a = numerator1 / denominator;\n    b = numerator2 / denominator;\n\n    // if we cast these lines infinitely in both directions, they intersect here:\n    result.x = line1StartX + a * (line1EndX - line1StartX);\n    result.y = line1StartY + a * (line1EndY - line1StartY);\n\n    // if line1 is a segment and line2 is infinite, they intersect if:\n    if (a >= 0 && a <= 1) {\n        result.onLine1 = true;\n    }\n    // if line2 is a segment and line1 is infinite, they intersect if:\n    if (b >= 0 && b <= 1) {\n        result.onLine2 = true;\n    }\n    // if line1 and line2 are segments, they intersect if both of the above are true\n    if (result.onLine1 && result.onLine2) {\n        return [result.x, result.y];\n    } else {\n        return false;\n    }\n}\n\n/**\n * Takes an array of points, google.maps.Polygon or Feature<Polygon> and returns {@link Point|points} at all self-intersections.\n *\n * @name kinks\n * @param  {google.maps.Polyline|google.maps.Polygon|Array.<google.maps.LatLng>|Feature<Polygon>} object array of points, google.maps.Polygon or Feature<Polygon>\n * @returns {FeatureCollection<Point>} self-intersections\n *\n */\nfunction kinks(object) {\n  var Feature;\n  if (object instanceof google.maps.Polyline || object instanceof google.maps.Polygon) {\n    var geometry = Wicket().fromObject(object).toJson();\n    Feature = {\n      type: \"Feature\",\n      properties: {},\n      geometry: geometry\n    };\n  } else if (object.type && object.type === 'Feature' && object.geometry) {\n    Feature = object;\n  } else {\n    Feature = polygonToFeaturePolygon(object);\n  }\n\n  return kinks$1(Feature);\n}\n\nvar quickselect = partialSort;\n\n// Floyd-Rivest selection algorithm:\n// Rearrange items so that all items in the [left, k] range are smaller than all items in (k, right];\n// The k-th element will have the (k - left + 1)th smallest value in [left, right]\n\nfunction partialSort(arr, k, left, right, compare) {\n    left = left || 0;\n    right = right || arr.length - 1;\n    compare = compare || defaultCompare;\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            partialSort(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) {\n                i++;\n            }while (compare(arr[j], t) > 0) {\n                j--;\n            }\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nvar rbush_1 = rbush;\n\nfunction rbush(maxEntries, format) {\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n    if (format) {\n        this._initFormat(format);\n    }\n\n    this.clear();\n}\n\nrbush.prototype = {\n\n    all: function all() {\n        return this._all(this.data, []);\n    },\n\n    search: function search(bbox) {\n\n        var node = this.data,\n            result = [],\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return result;\n\n        var nodesToSearch = [],\n            i,\n            len,\n            child,\n            childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);else if (contains$1(bbox, childBBox)) this._all(child, result);else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    },\n\n    collides: function collides(bbox) {\n\n        var node = this.data,\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return false;\n\n        var nodesToSearch = [],\n            i,\n            len,\n            child,\n            childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains$1(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    },\n\n    load: function load(data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from stratch using OMT algorithm\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                var tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    },\n\n    insert: function insert(item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    },\n\n    clear: function clear() {\n        this.data = createNode([]);\n        return this;\n    },\n\n    remove: function remove(item, equalsFn) {\n        if (!item) return this;\n\n        var node = this.data,\n            bbox = this.toBBox(item),\n            path = [],\n            indexes = [],\n            i,\n            parent,\n            index,\n            goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) {\n                // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) {\n                // check current node\n                index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains$1(node, bbox)) {\n                // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n            } else if (parent) {\n                // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n            } else node = null; // nothing found\n        }\n\n        return this;\n    },\n\n    toBBox: function toBBox(item) {\n        return item;\n    },\n\n    compareMinX: compareNodeMinX,\n    compareMinY: compareNodeMinY,\n\n    toJSON: function toJSON() {\n        return this.data;\n    },\n\n    fromJSON: function fromJSON(data) {\n        this.data = data;\n        return this;\n    },\n\n    _all: function _all(node, result) {\n        var nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push.apply(result, node.children);else nodesToSearch.push.apply(nodesToSearch, node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n\n    _build: function _build(items, left, right, height) {\n\n        var N = right - left + 1,\n            M = this._maxEntries,\n            node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        var N2 = Math.ceil(N / M),\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\n            i,\n            j,\n            right2,\n            right3;\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (i = left; i <= right; i += N1) {\n\n            right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (j = i; j <= right2; j += N2) {\n\n                right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    },\n\n    _chooseSubtree: function _chooseSubtree(bbox, node, level, path) {\n\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            minArea = minEnlargement = Infinity;\n\n            for (i = 0, len = node.children.length; i < len; i++) {\n                child = node.children[i];\n                area = bboxArea(child);\n                enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    },\n\n    _insert: function _insert(item, level, isNode) {\n\n        var toBBox = this.toBBox,\n            bbox = isNode ? item : toBBox(item),\n            insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend$1(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n\n    // split overflowed node into two\n    _split: function _split(insertPath, level) {\n\n        var node = insertPath[level],\n            M = node.children.length,\n            m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);else this._splitRoot(node, newNode);\n    },\n\n    _splitRoot: function _splitRoot(node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    },\n\n    _chooseSplitIndex: function _chooseSplitIndex(node, m, M) {\n\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n\n        minOverlap = minArea = Infinity;\n\n        for (i = m; i <= M - m; i++) {\n            bbox1 = distBBox(node, 0, i, this.toBBox);\n            bbox2 = distBBox(node, i, M, this.toBBox);\n\n            overlap = intersectionArea(bbox1, bbox2);\n            area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index;\n    },\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function _chooseSplitAxis(node, m, M) {\n\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function _allDistMargin(node, m, M, compare) {\n\n        node.children.sort(compare);\n\n        var toBBox = this.toBBox,\n            leftBBox = distBBox(node, 0, m, toBBox),\n            rightBBox = distBBox(node, M - m, M, toBBox),\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n            i,\n            child;\n\n        for (i = m; i < M - m; i++) {\n            child = node.children[i];\n            extend$1(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (i = M - m - 1; i >= m; i--) {\n            child = node.children[i];\n            extend$1(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    },\n\n    _adjustParentBBoxes: function _adjustParentBBoxes(bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (var i = level; i >= 0; i--) {\n            extend$1(path[i], bbox);\n        }\n    },\n\n    _condense: function _condense(path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n                } else this.clear();\n            } else calcBBox(path[i], this.toBBox);\n        }\n    },\n\n    _initFormat: function _initFormat(format) {\n        // data format (minX, minY, maxX, maxY accessors)\n\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n\n        var compareArr = ['return a', ' - b', ';'];\n\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n\n        this.toBBox = new Function('a', 'return {minX: a' + format[0] + ', minY: a' + format[1] + ', maxX: a' + format[2] + ', maxY: a' + format[3] + '};');\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k, child; i < p; i++) {\n        child = node.children[i];\n        extend$1(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend$1(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) {\n    return a.minX - b.minX;\n}\nfunction compareNodeMinY(a, b) {\n    return a.minY - b.minY;\n}\n\nfunction bboxArea(a) {\n    return (a.maxX - a.minX) * (a.maxY - a.minY);\n}\nfunction bboxMargin(a) {\n    return a.maxX - a.minX + (a.maxY - a.minY);\n}\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX),\n        minY = Math.max(a.minY, b.minY),\n        maxX = Math.min(a.maxX, b.maxX),\n        maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);\n}\n\nfunction contains$1(a, b) {\n    return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right],\n        mid;\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n\n// Find self-intersections in geojson polygon (possibly with interior rings)\nvar isects = function (feature, filterFn, useSpatialIndex) {\n    if (feature.geometry.type !== 'Polygon') throw new Error('The input feature must be a Polygon');\n    if (useSpatialIndex === undefined) useSpatialIndex = 1;\n\n    var coord = feature.geometry.coordinates;\n\n    var output = [];\n    var seen = {};\n\n    if (useSpatialIndex) {\n        var allEdgesAsRbushTreeItems = [];\n        for (var ring0 = 0; ring0 < coord.length; ring0++) {\n            for (var edge0 = 0; edge0 < coord[ring0].length - 1; edge0++) {\n                allEdgesAsRbushTreeItems.push(rbushTreeItem(ring0, edge0));\n            }\n        }\n        var tree = rbush_1();\n        tree.load(allEdgesAsRbushTreeItems);\n    }\n\n    for (var ringA = 0; ringA < coord.length; ringA++) {\n        for (var edgeA = 0; edgeA < coord[ringA].length - 1; edgeA++) {\n            if (useSpatialIndex) {\n                var bboxOverlaps = tree.search(rbushTreeItem(ringA, edgeA));\n                bboxOverlaps.forEach(function (bboxIsect) {\n                    var ring1 = bboxIsect.ring;\n                    var edge1 = bboxIsect.edge;\n                    ifIsectAddToOutput(ringA, edgeA, ring1, edge1);\n                });\n            } else {\n                for (var ring1 = 0; ring1 < coord.length; ring1++) {\n                    for (var edge1 = 0; edge1 < coord[ring1].length - 1; edge1++) {\n                        // TODO: speedup possible if only interested in unique: start last two loops at ringA and edgeA+1\n                        ifIsectAddToOutput(ringA, edgeA, ring1, edge1);\n                    }\n                }\n            }\n        }\n    }\n\n    if (!filterFn) output = {\n        type: 'Feature',\n        geometry: {\n            type: 'MultiPoint',\n            coordinates: output\n        }\n    };\n    return output;\n\n    // Function to check if two edges intersect and add the intersection to the output\n    function ifIsectAddToOutput(ring0, edge0, ring1, edge1) {\n        var start0 = coord[ring0][edge0];\n        var end0 = coord[ring0][edge0 + 1];\n        var start1 = coord[ring1][edge1];\n        var end1 = coord[ring1][edge1 + 1];\n\n        var isect = intersect(start0, end0, start1, end1);\n\n        if (isect === null) return; // discard parallels and coincidence\n        var frac0;\n        var frac1;\n        if (end0[0] !== start0[0]) {\n            frac0 = (isect[0] - start0[0]) / (end0[0] - start0[0]);\n        } else {\n            frac0 = (isect[1] - start0[1]) / (end0[1] - start0[1]);\n        }\n        if (end1[0] !== start1[0]) {\n            frac1 = (isect[0] - start1[0]) / (end1[0] - start1[0]);\n        } else {\n            frac1 = (isect[1] - start1[1]) / (end1[1] - start1[1]);\n        }\n        if (frac0 >= 1 || frac0 <= 0 || frac1 >= 1 || frac1 <= 0) return; // require segment intersection\n\n        var key = isect;\n        var unique = !seen[key];\n        if (unique) {\n            seen[key] = true;\n        }\n\n        if (filterFn) {\n            output.push(filterFn(isect, ring0, edge0, start0, end0, frac0, ring1, edge1, start1, end1, frac1, unique));\n        } else {\n            output.push(isect);\n        }\n    }\n\n    // Function to return a rbush tree item given an ring and edge number\n    function rbushTreeItem(ring, edge) {\n\n        var start = coord[ring][edge];\n        var end = coord[ring][edge + 1];\n        var minX;\n        var maxX;\n        var minY;\n        var maxY;\n        if (start[0] < end[0]) {\n            minX = start[0];\n            maxX = end[0];\n        } else {\n            minX = end[0];\n            maxX = start[0];\n        }\n        if (start[1] < end[1]) {\n            minY = start[1];\n            maxY = end[1];\n        } else {\n            minY = end[1];\n            maxY = start[1];\n        }\n        return {\n            minX: minX,\n            minY: minY,\n            maxX: maxX,\n            maxY: maxY,\n            ring: ring,\n            edge: edge\n        };\n    }\n};\n\n// Function to compute where two lines (not segments) intersect. From https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection\nfunction intersect(start0, end0, start1, end1) {\n    if (equalArrays$3(start0, start1) || equalArrays$3(start0, end1) || equalArrays$3(end0, start1) || equalArrays$3(end1, start1)) return null;\n    var x0 = start0[0],\n        y0 = start0[1],\n        x1 = end0[0],\n        y1 = end0[1],\n        x2 = start1[0],\n        y2 = start1[1],\n        x3 = end1[0],\n        y3 = end1[1];\n    var denom = (x0 - x1) * (y2 - y3) - (y0 - y1) * (x2 - x3);\n    if (denom === 0) return null;\n    var x4 = ((x0 * y1 - y0 * x1) * (x2 - x3) - (x0 - x1) * (x2 * y3 - y2 * x3)) / denom;\n    var y4 = ((x0 * y1 - y0 * x1) * (y2 - y3) - (y0 - y1) * (x2 * y3 - y2 * x3)) / denom;\n    return [x4, y4];\n}\n\n// Function to compare Arrays of numbers. From http://stackoverflow.com/questions/7837456/how-to-compare-arrays-in-javascript\nfunction equalArrays$3(array1, array2) {\n    // if the other array is a falsy value, return\n    if (!array1 || !array2) return false;\n\n    // compare lengths - can save a lot of time\n    if (array1.length !== array2.length) return false;\n\n    for (var i = 0, l = array1.length; i < l; i++) {\n        // Check if we have nested arrays\n        if (array1[i] instanceof Array && array2[i] instanceof Array) {\n            // recurse into the nested arrays\n            if (!equalArrays$3(array1[i], array2[i])) return false;\n        } else if (array1[i] !== array2[i]) {\n            // Warning - two different object instances will never be equal: {x:20} !== {x:20}\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * Takes one or more features and returns their area in square meters.\n *\n * @name area\n * @param {GeoJSON} geojson input GeoJSON feature(s)\n * @returns {number} area in square meters\n * @example\n * var polygon = turf.polygon([[[125, -15], [113, -22], [154, -27], [144, -15], [125, -15]]]);\n *\n * var area = turf.area(polygon);\n *\n * //addToMap\n * var addToMap = [polygon]\n * polygon.properties.area = area\n */\nfunction area$1(geojson) {\n    return geomReduce(geojson, function (value, geom) {\n        return value + calculateArea(geom);\n    }, 0);\n}\n\nvar RADIUS = 6378137;\n// var FLATTENING_DENOM = 298.257223563;\n// var FLATTENING = 1 / FLATTENING_DENOM;\n// var POLAR_RADIUS = RADIUS * (1 - FLATTENING);\n\n/**\n * Calculate Area\n *\n * @private\n * @param {GeoJSON} geojson GeoJSON\n * @returns {number} area\n */\nfunction calculateArea(geojson) {\n    var area = 0,\n        i;\n    switch (geojson.type) {\n        case 'Polygon':\n            return polygonArea(geojson.coordinates);\n        case 'MultiPolygon':\n            for (i = 0; i < geojson.coordinates.length; i++) {\n                area += polygonArea(geojson.coordinates[i]);\n            }\n            return area;\n        case 'Point':\n        case 'MultiPoint':\n        case 'LineString':\n        case 'MultiLineString':\n            return 0;\n        case 'GeometryCollection':\n            for (i = 0; i < geojson.geometries.length; i++) {\n                area += calculateArea(geojson.geometries[i]);\n            }\n            return area;\n    }\n}\n\nfunction polygonArea(coords) {\n    var area = 0;\n    if (coords && coords.length > 0) {\n        area += Math.abs(ringArea(coords[0]));\n        for (var i = 1; i < coords.length; i++) {\n            area -= Math.abs(ringArea(coords[i]));\n        }\n    }\n    return area;\n}\n\n/**\n * @private\n * Calculate the approximate area of the polygon were it projected onto the earth.\n * Note that this area will be positive if ring is oriented clockwise, otherwise it will be negative.\n *\n * Reference:\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n * Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409\n *\n * @param {Array<Array<number>>} coords Ring Coordinates\n * @returns {number} The approximate signed geodesic area of the polygon in square meters.\n */\nfunction ringArea(coords) {\n    var p1;\n    var p2;\n    var p3;\n    var lowerIndex;\n    var middleIndex;\n    var upperIndex;\n    var i;\n    var area = 0;\n    var coordsLength = coords.length;\n\n    if (coordsLength > 2) {\n        for (i = 0; i < coordsLength; i++) {\n            if (i === coordsLength - 2) {\n                // i = N-2\n                lowerIndex = coordsLength - 2;\n                middleIndex = coordsLength - 1;\n                upperIndex = 0;\n            } else if (i === coordsLength - 1) {\n                // i = N-1\n                lowerIndex = coordsLength - 1;\n                middleIndex = 0;\n                upperIndex = 1;\n            } else {\n                // i = 0 to N-3\n                lowerIndex = i;\n                middleIndex = i + 1;\n                upperIndex = i + 2;\n            }\n            p1 = coords[lowerIndex];\n            p2 = coords[middleIndex];\n            p3 = coords[upperIndex];\n            area += (rad(p3[0]) - rad(p1[0])) * Math.sin(rad(p2[1]));\n        }\n\n        area = area * RADIUS * RADIUS / 2;\n    }\n\n    return area;\n}\n\nfunction rad(_) {\n    return _ * Math.PI / 180;\n}\n\n/**\n * Takes a complex (i.e. self-intersecting) geojson polygon, and breaks it down into its composite simple, non-self-intersecting one-ring polygons.\n *\n * @module simplepolygon\n * @param {Feature} feature Input polygon. This polygon may be unconform the {@link https://en.wikipedia.org/wiki/Simple_Features|Simple Features standard} in the sense that it's inner and outer rings may cross-intersect or self-intersect, that the outer ring must not contain the optional inner rings and that the winding number must not be positive for the outer and negative for the inner rings.\n * @return {FeatureCollection} Feature collection containing the simple, non-self-intersecting one-ring polygon features that the complex polygon is composed of. These simple polygons have properties such as their parent polygon, winding number and net winding number.\n *\n * @example\n * var poly = {\n *   \"type\": \"Feature\",\n *   \"geometry\": {\n *     \"type\": \"Polygon\",\n *     \"coordinates\": [[[0,0],[2,0],[0,2],[2,2],[0,0]]]\n *   }\n * };\n *\n * var result = simplepolygon(poly);\n *\n * // =result\n * // which will be a featureCollection of two polygons, one with coordinates [[[0,0],[2,0],[1,1],[0,0]]], parent -1, winding 1 and net winding 1, and one with coordinates [[[1,1],[0,2],[2,2],[1,1]]], parent -1, winding -1 and net winding -1\n */\nvar simplepolygon = function (feature$$1) {\n    // Check input\n    if (feature$$1.type != 'Feature') throw new Error('The input must a geojson object of type Feature');\n    if (feature$$1.geometry === undefined || feature$$1.geometry == null) throw new Error('The input must a geojson object with a non-empty geometry');\n    if (feature$$1.geometry.type != 'Polygon') throw new Error('The input must be a geojson Polygon');\n\n    // Process input\n    var numRings = feature$$1.geometry.coordinates.length;\n    var vertices = [];\n    for (var i = 0; i < numRings; i++) {\n        var ring = feature$$1.geometry.coordinates[i];\n        if (!equalArrays$2(ring[0], ring[ring.length - 1])) {\n            ring.push(ring[0]); // Close input ring if it is not\n        }\n        vertices.push.apply(vertices, ring.slice(0, ring.length - 1));\n    }\n    if (!isUnique(vertices)) throw new Error('The input polygon may not have duplicate vertices (except for the first and last vertex of each ring)');\n    var numvertices = vertices.length; // number of input ring vertices, with the last closing vertices not counted\n\n    // Compute self-intersections\n    var selfIsectsData = isects(feature$$1, function filterFn(isect, ring0, edge0, start0, end0, frac0, ring1, edge1, start1, end1, frac1, unique) {\n        return [isect, ring0, edge0, start0, end0, frac0, ring1, edge1, start1, end1, frac1, unique];\n    });\n    var numSelfIsect = selfIsectsData.length;\n\n    // If no self-intersections are found, the input rings are the output rings. Hence, we must only compute their winding numbers, net winding numbers and (since ohers rings could lie outside the first ring) parents.\n    if (numSelfIsect == 0) {\n        var outputFeatureArray = [];\n        for (var i = 0; i < numRings; i++) {\n            outputFeatureArray.push(polygon([feature$$1.geometry.coordinates[i]], {\n                parent: -1,\n                winding: windingOfRing(feature$$1.geometry.coordinates[i])\n            }));\n        }\n        var output = featureCollection(outputFeatureArray);\n        determineParents();\n        setNetWinding();\n\n        return output;\n    }\n\n    // If self-intersections are found, we will compute the output rings with the help of two intermediate variables\n    // First, we build the pseudo vertex list and intersection list\n    // The Pseudo vertex list is an array with for each ring an array with for each edge an array containing the pseudo-vertices (as made by their constructor) that have this ring and edge as ringAndEdgeIn, sorted for each edge by their fractional distance on this edge. It's length hence equals numRings.\n    var pseudoVtxListByRingAndEdge = [];\n    // The intersection list is an array containing intersections (as made by their constructor). First all numvertices ring-vertex-intersections, then all self-intersections (intra- and inter-ring). The order of the latter is not important but is permanent once given.\n    var isectList = [];\n    // Adding ring-pseudo-vertices to pseudoVtxListByRingAndEdge and ring-vertex-intersections to isectList\n    for (var i = 0; i < numRings; i++) {\n        pseudoVtxListByRingAndEdge.push([]);\n        for (var j = 0; j < feature$$1.geometry.coordinates[i].length - 1; j++) {\n            // Each edge will feature one ring-pseudo-vertex in its array, on the last position. i.e. edge j features the ring-pseudo-vertex of the ring vertex j+1, which has ringAndEdgeIn = [i,j], on the last position.\n            pseudoVtxListByRingAndEdge[i].push([new PseudoVtx(feature$$1.geometry.coordinates[i][(j + 1).modulo(feature$$1.geometry.coordinates[i].length - 1)], 1, [i, j], [i, (j + 1).modulo(feature$$1.geometry.coordinates[i].length - 1)], undefined)]);\n            // The first numvertices elements in isectList correspond to the ring-vertex-intersections\n            isectList.push(new Isect(feature$$1.geometry.coordinates[i][j], [i, (j - 1).modulo(feature$$1.geometry.coordinates[i].length - 1)], [i, j], undefined, undefined, false, true));\n        }\n    }\n    // Adding intersection-pseudo-vertices to pseudoVtxListByRingAndEdge and self-intersections to isectList\n    for (var i = 0; i < numSelfIsect; i++) {\n        // Adding intersection-pseudo-vertices made using selfIsectsData to pseudoVtxListByRingAndEdge's array corresponding to the incomming ring and edge\n        pseudoVtxListByRingAndEdge[selfIsectsData[i][1]][selfIsectsData[i][2]].push(new PseudoVtx(selfIsectsData[i][0], selfIsectsData[i][5], [selfIsectsData[i][1], selfIsectsData[i][2]], [selfIsectsData[i][6], selfIsectsData[i][7]], undefined));\n        // selfIsectsData contains double mentions of each intersection, but we only want to add them once to isectList\n        if (selfIsectsData[i][11]) isectList.push(new Isect(selfIsectsData[i][0], [selfIsectsData[i][1], selfIsectsData[i][2]], [selfIsectsData[i][6], selfIsectsData[i][7]], undefined, undefined, true, true));\n    }\n    var numIsect = isectList.length;\n    // Sort edge arrays of pseudoVtxListByRingAndEdge by the fractional distance 'param'\n    for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {\n        for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {\n            pseudoVtxListByRingAndEdge[i][j].sort(function (a, b) {\n                return a.param < b.param ? -1 : 1;\n            });\n        }\n    }\n\n    // Make a spatial index of intersections, in preperation for the following two steps\n    var allIsectsAsIsectRbushTreeItem = [];\n    for (var i = 0; i < numIsect; i++) {\n        allIsectsAsIsectRbushTreeItem.push({\n            minX: isectList[i].coord[0],\n            minY: isectList[i].coord[1],\n            maxX: isectList[i].coord[0],\n            maxY: isectList[i].coord[1],\n            index: i\n        }); // could pass isect: isectList[i], but not necessary\n    }\n    var isectRbushTree = rbush_1();\n    isectRbushTree.load(allIsectsAsIsectRbushTreeItem);\n\n    // Now we will teach each intersection in isectList which is the next intersection along both it's [ring, edge]'s, in two steps.\n    // First, we find the next intersection for each pseudo-vertex in pseudoVtxListByRingAndEdge:\n    // For each pseudovertex in pseudoVtxListByRingAndEdge (3 loops) look at the next pseudovertex on that edge and find the corresponding intersection by comparing coordinates\n    for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {\n        for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {\n            for (var k = 0; k < pseudoVtxListByRingAndEdge[i][j].length; k++) {\n                var coordToFind;\n                if (k == pseudoVtxListByRingAndEdge[i][j].length - 1) {\n                    // If it's the last pseudoVertex on that edge, then the next pseudoVertex is the first one on the next edge of that ring.\n                    coordToFind = pseudoVtxListByRingAndEdge[i][(j + 1).modulo(feature$$1.geometry.coordinates[i].length - 1)][0].coord;\n                } else {\n                    coordToFind = pseudoVtxListByRingAndEdge[i][j][k + 1].coord;\n                }\n                var IsectRbushTreeItemFound = isectRbushTree.search({\n                    minX: coordToFind[0],\n                    minY: coordToFind[1],\n                    maxX: coordToFind[0],\n                    maxY: coordToFind[1]\n                })[0]; // We can take [0] of the result, because there is only one isect correponding to a pseudo-vertex\n                pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn = IsectRbushTreeItemFound.index;\n            }\n        }\n    }\n\n    // Second, we port this knowledge of the next intersection over to the intersections in isectList, by finding the intersection corresponding to each pseudo-vertex and copying the pseudo-vertex' knownledge of the next-intersection over to the intersection\n    for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {\n        for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {\n            for (var k = 0; k < pseudoVtxListByRingAndEdge[i][j].length; k++) {\n                var coordToFind = pseudoVtxListByRingAndEdge[i][j][k].coord;\n                var IsectRbushTreeItemFound = isectRbushTree.search({\n                    minX: coordToFind[0],\n                    minY: coordToFind[1],\n                    maxX: coordToFind[0],\n                    maxY: coordToFind[1]\n                })[0]; // We can take [0] of the result, because there is only one isect correponding to a pseudo-vertex\n                var l = IsectRbushTreeItemFound.index;\n                if (l < numvertices) {\n                    // Special treatment at ring-vertices: we correct the misnaming that happened in the previous block, since ringAndEdgeOut = ringAndEdge2 for ring vertices.\n                    isectList[l].nxtIsectAlongRingAndEdge2 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;\n                } else {\n                    // Port the knowledge of the next intersection from the pseudo-vertices to the intersections, depending on how the edges are labeled in the pseudo-vertex and intersection.\n                    if (equalArrays$2(isectList[l].ringAndEdge1, pseudoVtxListByRingAndEdge[i][j][k].ringAndEdgeIn)) {\n                        isectList[l].nxtIsectAlongRingAndEdge1 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;\n                    } else {\n                        isectList[l].nxtIsectAlongRingAndEdge2 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;\n                    }\n                }\n            }\n        }\n    }\n    // This explains why, eventhough when we will walk away from an intersection, we will walk way from the corresponding pseudo-vertex along edgeOut, pseudo-vertices have the property 'nxtIsectAlongEdgeIn' in stead of some propery 'nxtPseudoVtxAlongEdgeOut'. This is because this property (which is easy to find out) is used in the above for nxtIsectAlongRingAndEdge1 and nxtIsectAlongRingAndEdge2!\n\n    // Before we start walking over the intersections to build the output rings, we prepare a queue that stores information on intersections we still have to deal with, and put at least one intersection in it.\n    // This queue will contain information on intersections where we can start walking from once the current walk is finished, and its parent output ring (the smallest output ring it lies within, -1 if no parent or parent unknown yet) and its winding number (which we can already determine).\n    var queue = [];\n    // For each output ring, add the ring-vertex-intersection with the smalles x-value (i.e. the left-most) as a start intersection. By choosing such an extremal intersections, we are sure to start at an intersection that is a convex vertex of its output ring. By adding them all to the queue, we are sure that no rings will be forgotten. If due to ring-intersections such an intersection will be encountered while walking, it will be removed from the queue.\n    var i = 0;\n    for (var j = 0; j < numRings; j++) {\n        var leftIsect = i;\n        for (var k = 0; k < feature$$1.geometry.coordinates[j].length - 1; k++) {\n            if (isectList[i].coord[0] < isectList[leftIsect].coord[0]) {\n                leftIsect = i;\n            }\n            i++;\n        }\n        // Compute winding at this left-most ring-vertex-intersection. We thus this by using our knowledge that this extremal vertex must be a convex vertex.\n        // We first find the intersection before and after it, and then use them to determine the winding number of the corresponding output ring, since we know that an extremal vertex of a simple, non-self-intersecting ring is always convex, so the only reason it would not be is because the winding number we use to compute it is wrong\n        var isectAfterLeftIsect = isectList[leftIsect].nxtIsectAlongRingAndEdge2;\n        for (var k = 0; k < isectList.length; k++) {\n            if (isectList[k].nxtIsectAlongRingAndEdge1 == leftIsect || isectList[k].nxtIsectAlongRingAndEdge2 == leftIsect) {\n                var isectBeforeLeftIsect = k;\n                break;\n            }\n        }\n        var windingAtIsect = isConvex([isectList[isectBeforeLeftIsect].coord, isectList[leftIsect].coord, isectList[isectAfterLeftIsect].coord], true) ? 1 : -1;\n\n        queue.push({\n            isect: leftIsect,\n            parent: -1,\n            winding: windingAtIsect\n        });\n    }\n    // Sort the queue by the same criterion used to find the leftIsect: the left-most leftIsect must be last in the queue, such that it will be popped first, such that we will work from out to in regarding input rings. This assumtion is used when predicting the winding number and parent of a new queue member.\n    queue.sort(function (a, b) {\n        return isectList[a.isect].coord > isectList[b.isect].coord ? -1 : 1;\n    });\n\n    // Initialise output\n    var outputFeatureArray = [];\n\n    // While the queue is not empty, take the last object (i.e. its intersection) out and start making an output ring by walking in the direction that has not been walked away over yet.\n    while (queue.length > 0) {\n        // Get the last object out of the queue\n        var popped = queue.pop();\n        var startIsect = popped.isect;\n        var currentOutputRingParent = popped.parent;\n        var currentOutputRingWinding = popped.winding;\n        // Make new output ring and add vertex from starting intersection\n        var currentOutputRing = outputFeatureArray.length;\n        var currentOutputRingCoords = [isectList[startIsect].coord];\n        // Set up the variables used while walking over intersections: 'currentIsect', 'nxtIsect' and 'walkingRingAndEdge'\n        var currentIsect = startIsect;\n        if (isectList[startIsect].ringAndEdge1Walkable) {\n            var walkingRingAndEdge = isectList[startIsect].ringAndEdge1;\n            var nxtIsect = isectList[startIsect].nxtIsectAlongRingAndEdge1;\n        } else {\n            var walkingRingAndEdge = isectList[startIsect].ringAndEdge2;\n            var nxtIsect = isectList[startIsect].nxtIsectAlongRingAndEdge2;\n        }\n        // While we have not arrived back at the same intersection, keep walking\n        while (!equalArrays$2(isectList[startIsect].coord, isectList[nxtIsect].coord)) {\n            currentOutputRingCoords.push(isectList[nxtIsect].coord);\n            // If the next intersection is queued, we can remove it, because we will go there now.\n            var nxtIsectInQueue = undefined;\n            for (var i = 0; i < queue.length; i++) {\n                if (queue[i].isect == nxtIsect) {\n                    nxtIsectInQueue = i;\n                    break;\n                }\n            }\n            if (nxtIsectInQueue != undefined) {\n                queue.splice(nxtIsectInQueue, 1);\n            }\n            // Arriving at this new intersection, we know which will be our next walking ring and edge (if we came from 1 we will walk away from 2 and vice versa),\n            // So we can set it as our new walking ring and intersection and remember that we (will) have walked over it\n            // If we have never walked away from this new intersection along the other ring and edge then we will soon do, add the intersection (and the parent wand winding number) to the queue\n            // (We can predict the winding number and parent as follows: if the edge is convex, the other output ring started from there will have the alternate winding and lie outside of the current one, and thus have the same parent ring as the current ring. Otherwise, it will have the same winding number and lie inside of the current ring. We are, however, only sure of this of an output ring started from there does not enclose the current ring. This is why the initial queue's intersections must be sorted such that outer ones come out first.)\n            // We then update the other two walking variables.\n            if (equalArrays$2(walkingRingAndEdge, isectList[nxtIsect].ringAndEdge1)) {\n                walkingRingAndEdge = isectList[nxtIsect].ringAndEdge2;\n                isectList[nxtIsect].ringAndEdge2Walkable = false;\n                if (isectList[nxtIsect].ringAndEdge1Walkable) {\n                    var pushing = {\n                        isect: nxtIsect\n                    };\n                    if (isConvex([isectList[currentIsect].coord, isectList[nxtIsect].coord, isectList[isectList[nxtIsect].nxtIsectAlongRingAndEdge2].coord], currentOutputRingWinding == 1)) {\n                        pushing.parent = currentOutputRingParent;\n                        pushing.winding = -currentOutputRingWinding;\n                    } else {\n                        pushing.parent = currentOutputRing;\n                        pushing.winding = currentOutputRingWinding;\n                    }\n                    queue.push(pushing);\n                }\n                currentIsect = nxtIsect;\n                nxtIsect = isectList[nxtIsect].nxtIsectAlongRingAndEdge2;\n            } else {\n                walkingRingAndEdge = isectList[nxtIsect].ringAndEdge1;\n                isectList[nxtIsect].ringAndEdge1Walkable = false;\n                if (isectList[nxtIsect].ringAndEdge2Walkable) {\n                    var pushing = {\n                        isect: nxtIsect\n                    };\n                    if (isConvex([isectList[currentIsect].coord, isectList[nxtIsect].coord, isectList[isectList[nxtIsect].nxtIsectAlongRingAndEdge1].coord], currentOutputRingWinding == 1)) {\n                        pushing.parent = currentOutputRingParent;\n                        pushing.winding = -currentOutputRingWinding;\n                    } else {\n                        pushing.parent = currentOutputRing;\n                        pushing.winding = currentOutputRingWinding;\n                    }\n                    queue.push(pushing);\n                }\n                currentIsect = nxtIsect;\n                nxtIsect = isectList[nxtIsect].nxtIsectAlongRingAndEdge1;\n            }\n        }\n        // Close output ring\n        currentOutputRingCoords.push(isectList[nxtIsect].coord);\n        // Push output ring to output\n        outputFeatureArray.push(polygon([currentOutputRingCoords], {\n            index: currentOutputRing,\n            parent: currentOutputRingParent,\n            winding: currentOutputRingWinding,\n            netWinding: undefined\n        }));\n    }\n\n    var output = featureCollection(outputFeatureArray);\n\n    determineParents();\n\n    setNetWinding();\n\n    // These functions are also used if no intersections are found\n    function determineParents() {\n        var featuresWithoutParent = [];\n        for (var i = 0; i < output.features.length; i++) {\n            if (output.features[i].properties.parent == -1) featuresWithoutParent.push(i);\n        }\n        if (featuresWithoutParent.length > 1) {\n            for (var i = 0; i < featuresWithoutParent.length; i++) {\n                var parent = -1;\n                var parentArea = Infinity;\n                for (var j = 0; j < output.features.length; j++) {\n                    if (featuresWithoutParent[i] == j) continue;\n                    if (booleanPointInPolygon(output.features[featuresWithoutParent[i]].geometry.coordinates[0][0], output.features[j], {\n                        ignoreBoundary: true\n                    })) {\n                        if (area$1(output.features[j]) < parentArea) {\n                            parent = j;\n                        }\n                    }\n                }\n                output.features[featuresWithoutParent[i]].properties.parent = parent;\n            }\n        }\n    }\n\n    function setNetWinding() {\n        for (var i = 0; i < output.features.length; i++) {\n            if (output.features[i].properties.parent == -1) {\n                var netWinding = output.features[i].properties.winding;\n                output.features[i].properties.netWinding = netWinding;\n                setNetWindingOfChildren(i, netWinding);\n            }\n        }\n    }\n\n    function setNetWindingOfChildren(parent, ParentNetWinding) {\n        for (var i = 0; i < output.features.length; i++) {\n            if (output.features[i].properties.parent == parent) {\n                var netWinding = ParentNetWinding + output.features[i].properties.winding;\n                output.features[i].properties.netWinding = netWinding;\n                setNetWindingOfChildren(i, netWinding);\n            }\n        }\n    }\n\n    return output;\n};\n\n// Constructor for (ring- or intersection-) pseudo-vertices.\nvar PseudoVtx = function PseudoVtx(coord, param, ringAndEdgeIn, ringAndEdgeOut, nxtIsectAlongEdgeIn) {\n    this.coord = coord; // [x,y] of this pseudo-vertex\n    this.param = param; // fractional distance of this intersection on incomming edge\n    this.ringAndEdgeIn = ringAndEdgeIn; // [ring index, edge index] of incomming edge\n    this.ringAndEdgeOut = ringAndEdgeOut; // [ring index, edge index] of outgoing edge\n    this.nxtIsectAlongEdgeIn = nxtIsectAlongEdgeIn; // The next intersection when following the incomming edge (so not when following ringAndEdgeOut!)\n};\n\n// Constructor for an intersection. There are two intersection-pseudo-vertices per self-intersection and one ring-pseudo-vertex per ring-vertex-intersection. Their labels 1 and 2 are not assigned a particular meaning but are permanent once given.\nvar Isect = function Isect(coord, ringAndEdge1, ringAndEdge2, nxtIsectAlongRingAndEdge1, nxtIsectAlongRingAndEdge2, ringAndEdge1Walkable, ringAndEdge2Walkable) {\n    this.coord = coord; // [x,y] of this intersection\n    this.ringAndEdge1 = ringAndEdge1; // first edge of this intersection\n    this.ringAndEdge2 = ringAndEdge2; // second edge of this intersection\n    this.nxtIsectAlongRingAndEdge1 = nxtIsectAlongRingAndEdge1; // the next intersection when following ringAndEdge1\n    this.nxtIsectAlongRingAndEdge2 = nxtIsectAlongRingAndEdge2; // the next intersection when following ringAndEdge2\n    this.ringAndEdge1Walkable = ringAndEdge1Walkable; // May we (still) walk away from this intersection over ringAndEdge1?\n    this.ringAndEdge2Walkable = ringAndEdge2Walkable; // May we (still) walk away from this intersection over ringAndEdge2?\n};\n\n// Function to determine if three consecutive points of a simple, non-self-intersecting ring make up a convex vertex, assuming the ring is right- or lefthanded\nfunction isConvex(pts, righthanded) {\n    // 'pts' is an [x,y] pair\n    // 'righthanded' is a boolean\n    if (typeof righthanded === 'undefined') righthanded = true;\n    if (pts.length != 3) throw new Error('This function requires an array of three points [x,y]');\n    var d = (pts[1][0] - pts[0][0]) * (pts[2][1] - pts[0][1]) - (pts[1][1] - pts[0][1]) * (pts[2][0] - pts[0][0]);\n    return d >= 0 == righthanded;\n}\n\n// Function to compute winding of simple, non-self-intersecting ring\nfunction windingOfRing(ring) {\n    // 'ring' is an array of [x,y] pairs with the last equal to the first\n    // Compute the winding number based on the vertex with the smallest x-value, it precessor and successor. An extremal vertex of a simple, non-self-intersecting ring is always convex, so the only reason it is not is because the winding number we use to compute it is wrong\n    var leftVtx = 0;\n    for (var i = 0; i < ring.length - 1; i++) {\n        if (ring[i][0] < ring[leftVtx][0]) leftVtx = i;\n    }\n    if (isConvex([ring[(leftVtx - 1).modulo(ring.length - 1)], ring[leftVtx], ring[(leftVtx + 1).modulo(ring.length - 1)]], true)) {\n        var winding = 1;\n    } else {\n        var winding = -1;\n    }\n    return winding;\n}\n\n// Function to compare Arrays of numbers. From http://stackoverflow.com/questions/7837456/how-to-compare-arrays-in-javascript\nfunction equalArrays$2(array1, array2) {\n    // if the other array is a falsy value, return\n    if (!array1 || !array2) return false;\n\n    // compare lengths - can save a lot of time\n    if (array1.length != array2.length) return false;\n\n    for (var i = 0, l = array1.length; i < l; i++) {\n        // Check if we have nested arrays\n        if (array1[i] instanceof Array && array2[i] instanceof Array) {\n            // recurse into the nested arrays\n            if (!equalArrays$2(array1[i], array2[i])) return false;\n        } else if (array1[i] != array2[i]) {\n            // Warning - two different object instances will never be equal: {x:20} != {x:20}\n            return false;\n        }\n    }\n    return true;\n}\n\n// Fix Javascript modulo for negative number. From http://stackoverflow.com/questions/4467539/javascript-modulo-not-behaving\nNumber.prototype.modulo = function (n) {\n    return (this % n + n) % n;\n};\n\n// Function to check if array is unique (i.e. all unique elements, i.e. no duplicate elements)\nfunction isUnique(array) {\n    var u = {};\n    var isUnique = 1;\n    for (var i = 0, l = array.length; i < l; ++i) {\n        if (u.hasOwnProperty(array[i])) {\n            isUnique = 0;\n            break;\n        }\n        u[array[i]] = 1;\n    }\n    return isUnique;\n}\n\n/**\n * Takes a kinked polygon and returns a feature collection of polygons that have no kinks.\n * Uses [simplepolygon](https://github.com/mclaeysb/simplepolygon) internally.\n *\n * @name unkinkPolygon\n * @param {FeatureCollection|Feature<Polygon|MultiPolygon>} geojson GeoJSON Polygon or MultiPolygon\n * @returns {FeatureCollection<Polygon>} Unkinked polygons\n * @example\n * var poly = turf.polygon([[[0, 0], [2, 0], [0, 2], [2, 2], [0, 0]]]);\n *\n * var result = turf.unkinkPolygon(poly);\n *\n * //addToMap\n * var addToMap = [poly, result]\n */\nfunction unkinkPolygon(geojson) {\n    var features = [];\n    flattenEach(geojson, function (feature$$1) {\n        if (feature$$1.geometry.type !== 'Polygon') return;\n        featureEach(simplepolygon(feature$$1), function (poly) {\n            features.push(polygon(poly.geometry.coordinates, feature$$1.properties));\n        });\n    });\n    return featureCollection(features);\n}\n\n/**\n * Takes a kinked polygon and returns a feature collection of polygons that have no kinks. \n * @param  {google.maps.Polygon|Array.<google.maps.LatLng>|Feature<Polygon>} object array of points, a google.maps.Polygon or Feature<Polygon>\n * @return {FeatureCollection<Polygon>}  Unkinked polygons\n */\nfunction unkink(object) {\n\n  var polygonFeature = polygonToFeaturePolygon(object);\n  console.log(polygonFeature);\n\n  return unkinkPolygon(polygonFeature);\n}\n\n/**\n * The base implementation of `_.filter` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction baseFilter(collection, predicate) {\n  var result = [];\n  baseEach(collection, function (value, index, collection) {\n    if (predicate(value, index, collection)) {\n      result.push(value);\n    }\n  });\n  return result;\n}\n\n/**\n * Iterates over elements of `collection`, returning an array of all elements\n * `predicate` returns truthy for. The predicate is invoked with three\n * arguments: (value, index|key, collection).\n *\n * **Note:** Unlike `_.remove`, this method returns a new array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n * @see _.reject\n * @example\n *\n * var users = [\n *   { 'user': 'barney', 'age': 36, 'active': true },\n *   { 'user': 'fred',   'age': 40, 'active': false }\n * ];\n *\n * _.filter(users, function(o) { return !o.active; });\n * // => objects for ['fred']\n *\n * // The `_.matches` iteratee shorthand.\n * _.filter(users, { 'age': 36, 'active': true });\n * // => objects for ['barney']\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.filter(users, ['active', false]);\n * // => objects for ['fred']\n *\n * // The `_.property` iteratee shorthand.\n * _.filter(users, 'active');\n * // => objects for ['barney']\n */\nfunction filter(collection, predicate) {\n  var func = isArray(collection) ? arrayFilter : baseFilter;\n  return func(collection, baseIteratee(predicate, 3));\n}\n\n/**\n * The base implementation of methods like `_.max` and `_.min` which accepts a\n * `comparator` to determine the extremum value.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The iteratee invoked per iteration.\n * @param {Function} comparator The comparator used to compare values.\n * @returns {*} Returns the extremum value.\n */\nfunction baseExtremum(array, iteratee, comparator) {\n  var index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    var value = array[index],\n        current = iteratee(value);\n\n    if (current != null && (computed === undefined ? current === current && !isSymbol(current) : comparator(current, computed))) {\n      var computed = current,\n          result = value;\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.gt` which doesn't coerce arguments.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if `value` is greater than `other`,\n *  else `false`.\n */\nfunction baseGt(value, other) {\n  return value > other;\n}\n\n/**\n * Computes the maximum value of `array`. If `array` is empty or falsey,\n * `undefined` is returned.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Math\n * @param {Array} array The array to iterate over.\n * @returns {*} Returns the maximum value.\n * @example\n *\n * _.max([4, 2, 8, 6]);\n * // => 8\n *\n * _.max([]);\n * // => undefined\n */\nfunction max$1(array) {\n  return array && array.length ? baseExtremum(array, identity, baseGt) : undefined;\n}\n\n/**\n * The base implementation of `_.lt` which doesn't coerce arguments.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if `value` is less than `other`,\n *  else `false`.\n */\nfunction baseLt(value, other) {\n  return value < other;\n}\n\n/**\n * Computes the minimum value of `array`. If `array` is empty or falsey,\n * `undefined` is returned.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Math\n * @param {Array} array The array to iterate over.\n * @returns {*} Returns the minimum value.\n * @example\n *\n * _.min([4, 2, 8, 6]);\n * // => 2\n *\n * _.min([]);\n * // => undefined\n */\nfunction min$1(array) {\n  return array && array.length ? baseExtremum(array, identity, baseLt) : undefined;\n}\n\nfunction quickselect$3(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare$1);\n}\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap$1(arr, left, k);\n        if (compare(arr[right], t) > 0) swap$1(arr, left, right);\n\n        while (i < j) {\n            swap$1(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) {\n                i++;\n            }while (compare(arr[j], t) > 0) {\n                j--;\n            }\n        }\n\n        if (compare(arr[left], t) === 0) swap$1(arr, left, j);else {\n            j++;\n            swap$1(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap$1(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare$1(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nfunction rbush$3(maxEntries, format) {\n    if (!(this instanceof rbush$3)) return new rbush$3(maxEntries, format);\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n    if (format) {\n        this._initFormat(format);\n    }\n\n    this.clear();\n}\n\nrbush$3.prototype = {\n\n    all: function all() {\n        return this._all(this.data, []);\n    },\n\n    search: function search(bbox) {\n\n        var node = this.data,\n            result = [],\n            toBBox = this.toBBox;\n\n        if (!intersects$2(bbox, node)) return result;\n\n        var nodesToSearch = [],\n            i,\n            len,\n            child,\n            childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects$2(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);else if (contains$2(bbox, childBBox)) this._all(child, result);else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    },\n\n    collides: function collides(bbox) {\n\n        var node = this.data,\n            toBBox = this.toBBox;\n\n        if (!intersects$2(bbox, node)) return false;\n\n        var nodesToSearch = [],\n            i,\n            len,\n            child,\n            childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects$2(bbox, childBBox)) {\n                    if (node.leaf || contains$2(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    },\n\n    load: function load(data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                var tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    },\n\n    insert: function insert(item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    },\n\n    clear: function clear() {\n        this.data = createNode$1([]);\n        return this;\n    },\n\n    remove: function remove(item, equalsFn) {\n        if (!item) return this;\n\n        var node = this.data,\n            bbox = this.toBBox(item),\n            path = [],\n            indexes = [],\n            i,\n            parent,\n            index,\n            goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) {\n                // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) {\n                // check current node\n                index = findItem$1(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains$2(node, bbox)) {\n                // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n            } else if (parent) {\n                // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n            } else node = null; // nothing found\n        }\n\n        return this;\n    },\n\n    toBBox: function toBBox(item) {\n        return item;\n    },\n\n    compareMinX: compareNodeMinX$1,\n    compareMinY: compareNodeMinY$1,\n\n    toJSON: function toJSON() {\n        return this.data;\n    },\n\n    fromJSON: function fromJSON(data) {\n        this.data = data;\n        return this;\n    },\n\n    _all: function _all(node, result) {\n        var nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push.apply(result, node.children);else nodesToSearch.push.apply(nodesToSearch, node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n\n    _build: function _build(items, left, right, height) {\n\n        var N = right - left + 1,\n            M = this._maxEntries,\n            node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode$1(items.slice(left, right + 1));\n            calcBBox$1(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode$1([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        var N2 = Math.ceil(N / M),\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\n            i,\n            j,\n            right2,\n            right3;\n\n        multiSelect$1(items, left, right, N1, this.compareMinX);\n\n        for (i = left; i <= right; i += N1) {\n\n            right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect$1(items, i, right2, N2, this.compareMinY);\n\n            for (j = i; j <= right2; j += N2) {\n\n                right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox$1(node, this.toBBox);\n\n        return node;\n    },\n\n    _chooseSubtree: function _chooseSubtree(bbox, node, level, path) {\n\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            minArea = minEnlargement = Infinity;\n\n            for (i = 0, len = node.children.length; i < len; i++) {\n                child = node.children[i];\n                area = bboxArea$1(child);\n                enlargement = enlargedArea$1(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    },\n\n    _insert: function _insert(item, level, isNode) {\n\n        var toBBox = this.toBBox,\n            bbox = isNode ? item : toBBox(item),\n            insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend$2(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n\n    // split overflowed node into two\n    _split: function _split(insertPath, level) {\n\n        var node = insertPath[level],\n            M = node.children.length,\n            m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n\n        var newNode = createNode$1(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox$1(node, this.toBBox);\n        calcBBox$1(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);else this._splitRoot(node, newNode);\n    },\n\n    _splitRoot: function _splitRoot(node, newNode) {\n        // split root node\n        this.data = createNode$1([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox$1(this.data, this.toBBox);\n    },\n\n    _chooseSplitIndex: function _chooseSplitIndex(node, m, M) {\n\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n\n        minOverlap = minArea = Infinity;\n\n        for (i = m; i <= M - m; i++) {\n            bbox1 = distBBox$1(node, 0, i, this.toBBox);\n            bbox2 = distBBox$1(node, i, M, this.toBBox);\n\n            overlap = intersectionArea$1(bbox1, bbox2);\n            area = bboxArea$1(bbox1) + bboxArea$1(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index;\n    },\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function _chooseSplitAxis(node, m, M) {\n\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX$1,\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY$1,\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function _allDistMargin(node, m, M, compare) {\n\n        node.children.sort(compare);\n\n        var toBBox = this.toBBox,\n            leftBBox = distBBox$1(node, 0, m, toBBox),\n            rightBBox = distBBox$1(node, M - m, M, toBBox),\n            margin = bboxMargin$1(leftBBox) + bboxMargin$1(rightBBox),\n            i,\n            child;\n\n        for (i = m; i < M - m; i++) {\n            child = node.children[i];\n            extend$2(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin$1(leftBBox);\n        }\n\n        for (i = M - m - 1; i >= m; i--) {\n            child = node.children[i];\n            extend$2(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin$1(rightBBox);\n        }\n\n        return margin;\n    },\n\n    _adjustParentBBoxes: function _adjustParentBBoxes(bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (var i = level; i >= 0; i--) {\n            extend$2(path[i], bbox);\n        }\n    },\n\n    _condense: function _condense(path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n                } else this.clear();\n            } else calcBBox$1(path[i], this.toBBox);\n        }\n    },\n\n    _initFormat: function _initFormat(format) {\n        // data format (minX, minY, maxX, maxY accessors)\n\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n\n        var compareArr = ['return a', ' - b', ';'];\n\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n\n        this.toBBox = new Function('a', 'return {minX: a' + format[0] + ', minY: a' + format[1] + ', maxX: a' + format[2] + ', maxY: a' + format[3] + '};');\n    }\n};\n\nfunction findItem$1(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox$1(node, toBBox) {\n    distBBox$1(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox$1(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode$1(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k, child; i < p; i++) {\n        child = node.children[i];\n        extend$2(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend$2(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX$1(a, b) {\n    return a.minX - b.minX;\n}\nfunction compareNodeMinY$1(a, b) {\n    return a.minY - b.minY;\n}\n\nfunction bboxArea$1(a) {\n    return (a.maxX - a.minX) * (a.maxY - a.minY);\n}\nfunction bboxMargin$1(a) {\n    return a.maxX - a.minX + (a.maxY - a.minY);\n}\n\nfunction enlargedArea$1(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea$1(a, b) {\n    var minX = Math.max(a.minX, b.minX),\n        minY = Math.max(a.minY, b.minY),\n        maxX = Math.min(a.maxX, b.maxX),\n        maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);\n}\n\nfunction contains$2(a, b) {\n    return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;\n}\n\nfunction intersects$2(a, b) {\n    return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;\n}\n\nfunction createNode$1(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect$1(arr, left, right, n, compare) {\n    var stack = [left, right],\n        mid;\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect$3(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n\n/**\n * GeoJSON implementation of [RBush](https://github.com/mourner/rbush#rbush) spatial index.\n *\n * @name rbush\n * @param {number} [maxEntries=9] defines the maximum number of entries in a tree node. 9 (used by default) is a\n * reasonable choice for most applications. Higher value means faster insertion and slower search, and vice versa.\n * @returns {RBush} GeoJSON RBush\n * @example\n * import geojsonRbush from 'geojson-rbush';\n * var tree = geojsonRbush();\n */\nfunction geojsonRbush(maxEntries) {\n    var tree = rbush$3(maxEntries);\n    /**\n     * [insert](https://github.com/mourner/rbush#data-format)\n     *\n     * @param {Feature<any>} feature insert single GeoJSON Feature\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var polygon = {\n     *   \"type\": \"Feature\",\n     *   \"properties\": {},\n     *   \"geometry\": {\n     *     \"type\": \"Polygon\",\n     *     \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *   }\n     * }\n     * tree.insert(polygon)\n     */\n    tree.insert = function (feature) {\n        if (Array.isArray(feature)) {\n            var bbox = feature;\n            feature = bboxPolygon(bbox);\n            feature.bbox = bbox;\n        } else {\n            feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n        }\n        return rbush$3.prototype.insert.call(this, feature);\n    };\n\n    /**\n     * [load](https://github.com/mourner/rbush#bulk-inserting-data)\n     *\n     * @param {BBox[]|FeatureCollection<any>} features load entire GeoJSON FeatureCollection\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var polygons = {\n     *   \"type\": \"FeatureCollection\",\n     *   \"features\": [\n     *     {\n     *       \"type\": \"Feature\",\n     *       \"properties\": {},\n     *       \"geometry\": {\n     *         \"type\": \"Polygon\",\n     *         \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *       }\n     *     },\n     *     {\n     *       \"type\": \"Feature\",\n     *       \"properties\": {},\n     *       \"geometry\": {\n     *         \"type\": \"Polygon\",\n     *         \"coordinates\": [[[-93, 32], [-83, 32], [-83, 39], [-93, 39], [-93, 32]]]\n     *       }\n     *     }\n     *   ]\n     * }\n     * tree.load(polygons)\n     */\n    tree.load = function (features) {\n        var load = [];\n        // Load an Array of BBox\n        if (Array.isArray(features)) {\n            features.forEach(function (bbox) {\n                var feature = bboxPolygon(bbox);\n                feature.bbox = bbox;\n                load.push(feature);\n            });\n        } else {\n            // Load FeatureCollection\n            featureEach(features, function (feature) {\n                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n                load.push(feature);\n            });\n        }\n        return rbush$3.prototype.load.call(this, load);\n    };\n\n    /**\n     * [remove](https://github.com/mourner/rbush#removing-data)\n     *\n     * @param {BBox|Feature<any>} feature remove single GeoJSON Feature\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var polygon = {\n     *   \"type\": \"Feature\",\n     *   \"properties\": {},\n     *   \"geometry\": {\n     *     \"type\": \"Polygon\",\n     *     \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *   }\n     * }\n     * tree.remove(polygon)\n     */\n    tree.remove = function (feature) {\n        if (Array.isArray(feature)) {\n            var bbox = feature;\n            feature = bboxPolygon(bbox);\n            feature.bbox = bbox;\n        }\n        return rbush$3.prototype.remove.call(this, feature);\n    };\n\n    /**\n     * [clear](https://github.com/mourner/rbush#removing-data)\n     *\n     * @returns {RBush} GeoJSON Rbush\n     * @example\n     * tree.clear()\n     */\n    tree.clear = function () {\n        return rbush$3.prototype.clear.call(this);\n    };\n\n    /**\n     * [search](https://github.com/mourner/rbush#search)\n     *\n     * @param {BBox|FeatureCollection|Feature<any>} geojson search with GeoJSON\n     * @returns {FeatureCollection<any>} all features that intersects with the given GeoJSON.\n     * @example\n     * var polygon = {\n     *   \"type\": \"Feature\",\n     *   \"properties\": {},\n     *   \"geometry\": {\n     *     \"type\": \"Polygon\",\n     *     \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *   }\n     * }\n     * tree.search(polygon)\n     */\n    tree.search = function (geojson) {\n        var features = rbush$3.prototype.search.call(this, this.toBBox(geojson));\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    };\n\n    /**\n     * [collides](https://github.com/mourner/rbush#collisions)\n     *\n     * @param {BBox|FeatureCollection|Feature<any>} geojson collides with GeoJSON\n     * @returns {boolean} true if there are any items intersecting the given GeoJSON, otherwise false.\n     * @example\n     * var polygon = {\n     *   \"type\": \"Feature\",\n     *   \"properties\": {},\n     *   \"geometry\": {\n     *     \"type\": \"Polygon\",\n     *     \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *   }\n     * }\n     * tree.collides(polygon)\n     */\n    tree.collides = function (geojson) {\n        return rbush$3.prototype.collides.call(this, this.toBBox(geojson));\n    };\n\n    /**\n     * [all](https://github.com/mourner/rbush#search)\n     *\n     * @returns {FeatureCollection<any>} all the features in RBush\n     * @example\n     * tree.all()\n     * //=FeatureCollection\n     */\n    tree.all = function () {\n        var features = rbush$3.prototype.all.call(this);\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    };\n\n    /**\n     * [toJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @returns {any} export data as JSON object\n     * @example\n     * var exported = tree.toJSON()\n     * //=JSON object\n     */\n    tree.toJSON = function () {\n        return rbush$3.prototype.toJSON.call(this);\n    };\n\n    /**\n     * [fromJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @param {any} json import previously exported data\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var exported = {\n     *   \"children\": [\n     *     {\n     *       \"type\": \"Feature\",\n     *       \"geometry\": {\n     *         \"type\": \"Point\",\n     *         \"coordinates\": [110, 50]\n     *       },\n     *       \"properties\": {},\n     *       \"bbox\": [110, 50, 110, 50]\n     *     }\n     *   ],\n     *   \"height\": 1,\n     *   \"leaf\": true,\n     *   \"minX\": 110,\n     *   \"minY\": 50,\n     *   \"maxX\": 110,\n     *   \"maxY\": 50\n     * }\n     * tree.fromJSON(exported)\n     */\n    tree.fromJSON = function (json) {\n        return rbush$3.prototype.fromJSON.call(this, json);\n    };\n\n    /**\n     * Converts GeoJSON to {minX, minY, maxX, maxY} schema\n     *\n     * @private\n     * @param {BBox|FeatureCollectio|Feature<any>} geojson feature(s) to retrieve BBox from\n     * @returns {Object} converted to {minX, minY, maxX, maxY}\n     */\n    tree.toBBox = function (geojson) {\n        var bbox;\n        if (geojson.bbox) bbox = geojson.bbox;else if (Array.isArray(geojson) && geojson.length === 4) bbox = geojson;else bbox = turfBBox(geojson);\n\n        return {\n            minX: bbox[0],\n            minY: bbox[1],\n            maxX: bbox[2],\n            maxY: bbox[3]\n        };\n    };\n    return tree;\n}\n\n/**\n * Takes a bbox and returns an equivalent {@link Polygon|polygon}.\n *\n * @private\n * @name bboxPolygon\n * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order\n * @returns {Feature<Polygon>} a Polygon representation of the bounding box\n * @example\n * var bbox = [0, 0, 10, 10];\n *\n * var poly = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [poly]\n */\nfunction bboxPolygon(bbox) {\n    var lowLeft = [bbox[0], bbox[1]];\n    var topLeft = [bbox[0], bbox[3]];\n    var topRight = [bbox[2], bbox[3]];\n    var lowRight = [bbox[2], bbox[1]];\n    var coordinates = [[lowLeft, lowRight, topRight, topLeft, lowLeft]];\n\n    return {\n        type: 'Feature',\n        bbox: bbox,\n        properties: {},\n        geometry: {\n            type: 'Polygon',\n            coordinates: coordinates\n        }\n    };\n}\n\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @private\n * @name bbox\n * @param {FeatureCollection|Feature<any>} geojson input features\n * @returns {Array<number>} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction turfBBox(geojson) {\n    var bbox = [Infinity, Infinity, -Infinity, -Infinity];\n    coordEach(geojson, function (coord) {\n        if (bbox[0] > coord[0]) bbox[0] = coord[0];\n        if (bbox[1] > coord[1]) bbox[1] = coord[1];\n        if (bbox[2] < coord[0]) bbox[2] = coord[0];\n        if (bbox[3] < coord[1]) bbox[3] = coord[1];\n    });\n    return bbox;\n}\n\n/**\n * Creates a {@link FeatureCollection} of 2-vertex {@link LineString} segments from a {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon}.\n *\n * @name lineSegment\n * @param {Geometry|FeatureCollection|Feature<LineString|MultiLineString|MultiPolygon|Polygon>} geojson GeoJSON Polygon or LineString\n * @returns {FeatureCollection<LineString>} 2-vertex line segments\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n * var segments = turf.lineSegment(polygon);\n *\n * //addToMap\n * var addToMap = [polygon, segments]\n */\nfunction lineSegment(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n\n    var results = [];\n    flattenEach(geojson, function (feature$$1) {\n        lineSegmentFeature(feature$$1, results);\n    });\n    return featureCollection(results);\n}\n\n/**\n * Line Segment\n *\n * @private\n * @param {Feature<LineString|Polygon>} geojson Line or polygon feature\n * @param {Array} results push to results\n * @returns {void}\n */\nfunction lineSegmentFeature(geojson, results) {\n    var coords = [];\n    var geometry$$1 = geojson.geometry;\n    switch (geometry$$1.type) {\n        case 'Polygon':\n            coords = getCoords(geometry$$1);\n            break;\n        case 'LineString':\n            coords = [getCoords(geometry$$1)];\n    }\n    coords.forEach(function (coord) {\n        var segments = createSegments(coord, geojson.properties);\n        segments.forEach(function (segment) {\n            segment.id = results.length;\n            results.push(segment);\n        });\n    });\n}\n\n/**\n * Create Segments from LineString coordinates\n *\n * @private\n * @param {LineString} coords LineString coordinates\n * @param {*} properties GeoJSON properties\n * @returns {Array<Feature<LineString>>} line segments\n */\nfunction createSegments(coords, properties) {\n    var segments = [];\n    coords.reduce(function (previousCoords, currentCoords) {\n        var segment = lineString([previousCoords, currentCoords], properties);\n        segment.bbox = bbox$3(previousCoords, currentCoords);\n        segments.push(segment);\n        return currentCoords;\n    });\n    return segments;\n}\n\n/**\n * Create BBox between two coordinates (faster than @turf/bbox)\n *\n * @private\n * @param {Array<number>} coords1 Point coordinate\n * @param {Array<number>} coords2 Point coordinate\n * @returns {BBox} [west, south, east, north]\n */\nfunction bbox$3(coords1, coords2) {\n    var x1 = coords1[0];\n    var y1 = coords1[1];\n    var x2 = coords2[0];\n    var y2 = coords2[1];\n    var west = x1 < x2 ? x1 : x2;\n    var south = y1 < y2 ? y1 : y2;\n    var east = x1 > x2 ? x1 : x2;\n    var north = y1 > y2 ? y1 : y2;\n    return [west, south, east, north];\n}\n\n/**\n * Takes any LineString or Polygon GeoJSON and returns the intersecting point(s).\n *\n * @name lineIntersect\n * @param {Geometry|FeatureCollection|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line1 any LineString or Polygon\n * @param {Geometry|FeatureCollection|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line2 any LineString or Polygon\n * @returns {FeatureCollection<Point>} point(s) that intersect both\n * @example\n * var line1 = turf.lineString([[126, -11], [129, -21]]);\n * var line2 = turf.lineString([[123, -18], [131, -14]]);\n * var intersects = turf.lineIntersect(line1, line2);\n *\n * //addToMap\n * var addToMap = [line1, line2, intersects]\n */\nfunction lineIntersect(line1, line2) {\n    var unique = {};\n    var results = [];\n\n    // First, normalize geometries to features\n    // Then, handle simple 2-vertex segments\n    if (line1.type === 'LineString') line1 = feature(line1);\n    if (line2.type === 'LineString') line2 = feature(line2);\n    if (line1.type === 'Feature' && line2.type === 'Feature' && line1.geometry.type === 'LineString' && line2.geometry.type === 'LineString' && line1.geometry.coordinates.length === 2 && line2.geometry.coordinates.length === 2) {\n        var intersect = intersects$1(line1, line2);\n        if (intersect) results.push(intersect);\n        return featureCollection(results);\n    }\n\n    // Handles complex GeoJSON Geometries\n    var tree = geojsonRbush();\n    tree.load(lineSegment(line2));\n    featureEach(lineSegment(line1), function (segment) {\n        featureEach(tree.search(segment), function (match) {\n            var intersect = intersects$1(segment, match);\n            if (intersect) {\n                // prevent duplicate points https://github.com/Turfjs/turf/issues/688\n                var key = getCoords(intersect).join(',');\n                if (!unique[key]) {\n                    unique[key] = true;\n                    results.push(intersect);\n                }\n            }\n        });\n    });\n    return featureCollection(results);\n}\n\n/**\n * Find a point that intersects LineStrings with two coordinates each\n *\n * @private\n * @param {Feature<LineString>} line1 GeoJSON LineString (Must only contain 2 coordinates)\n * @param {Feature<LineString>} line2 GeoJSON LineString (Must only contain 2 coordinates)\n * @returns {Feature<Point>} intersecting GeoJSON Point\n */\nfunction intersects$1(line1, line2) {\n    var coords1 = getCoords(line1);\n    var coords2 = getCoords(line2);\n    if (coords1.length !== 2) {\n        throw new Error('<intersects> line1 must only contain 2 coordinates');\n    }\n    if (coords2.length !== 2) {\n        throw new Error('<intersects> line2 must only contain 2 coordinates');\n    }\n    var x1 = coords1[0][0];\n    var y1 = coords1[0][1];\n    var x2 = coords1[1][0];\n    var y2 = coords1[1][1];\n    var x3 = coords2[0][0];\n    var y3 = coords2[0][1];\n    var x4 = coords2[1][0];\n    var y4 = coords2[1][1];\n    var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n    var numeA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n    var numeB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n\n    if (denom === 0) {\n        if (numeA === 0 && numeB === 0) {\n            return null;\n        }\n        return null;\n    }\n\n    var uA = numeA / denom;\n    var uB = numeB / denom;\n\n    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\n        var x = x1 + uA * (x2 - x1);\n        var y = y1 + uA * (y2 - y1);\n        return point([x, y]);\n    }\n    return null;\n}\n\n/**\n * Takes a {@link Point} and a {@link LineString} and calculates the closest Point on the (Multi)LineString.\n *\n * @name nearestPointOnLine\n * @param {Geometry|Feature<LineString|MultiLineString>} lines lines to snap to\n * @param {Geometry|Feature<Point>|number[]} pt point to snap from\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {Feature<Point>} closest point on the `line` to `point`. The properties object will contain three values: `index`: closest point was found on nth line part, `dist`: distance between pt and the closest point, `location`: distance along the line between start and the closest point.\n * @example\n * var line = turf.lineString([\n *     [-77.031669, 38.878605],\n *     [-77.029609, 38.881946],\n *     [-77.020339, 38.884084],\n *     [-77.025661, 38.885821],\n *     [-77.021884, 38.889563],\n *     [-77.019824, 38.892368]\n * ]);\n * var pt = turf.point([-77.037076, 38.884017]);\n *\n * var snapped = turf.nearestPointOnLine(line, pt, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [line, pt, snapped];\n * snapped.properties['marker-color'] = '#00f';\n */\nfunction nearestPointOnLine(lines, pt, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject$2(options)) throw new Error('options is invalid');\n\n    // validation\n    var type = lines.geometry ? lines.geometry.type : lines.type;\n    if (type !== 'LineString' && type !== 'MultiLineString') {\n        throw new Error('lines must be LineString or MultiLineString');\n    }\n\n    var closestPt = point([Infinity, Infinity], {\n        dist: Infinity\n    });\n\n    var length = 0.0;\n    flattenEach(lines, function (line) {\n        var coords = getCoords(line);\n\n        for (var i = 0; i < coords.length - 1; i++) {\n            //start\n            var start = point(coords[i]);\n            start.properties.dist = distance(pt, start, options);\n            //stop\n            var stop = point(coords[i + 1]);\n            stop.properties.dist = distance(pt, stop, options);\n            // sectionLength\n            var sectionLength = distance(start, stop, options);\n            //perpendicular\n            var heightDistance = Math.max(start.properties.dist, stop.properties.dist);\n            var direction = bearing(start, stop);\n            var perpendicularPt1 = destination(pt, heightDistance, direction + 90, options);\n            var perpendicularPt2 = destination(pt, heightDistance, direction - 90, options);\n            var intersect = lineIntersect(lineString([perpendicularPt1.geometry.coordinates, perpendicularPt2.geometry.coordinates]), lineString([start.geometry.coordinates, stop.geometry.coordinates]));\n            var intersectPt = null;\n            if (intersect.features.length > 0) {\n                intersectPt = intersect.features[0];\n                intersectPt.properties.dist = distance(pt, intersectPt, options);\n                intersectPt.properties.location = length + distance(start, intersectPt, options);\n            }\n\n            if (start.properties.dist < closestPt.properties.dist) {\n                closestPt = start;\n                closestPt.properties.index = i;\n                closestPt.properties.location = length;\n            }\n            if (stop.properties.dist < closestPt.properties.dist) {\n                closestPt = stop;\n                closestPt.properties.index = i + 1;\n                closestPt.properties.location = length + sectionLength;\n            }\n            if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {\n                closestPt = intersectPt;\n                closestPt.properties.index = i;\n            }\n            // update length\n            length += sectionLength;\n        }\n    });\n\n    return closestPt;\n}\n\n/**\n * Takes a {@link LineString|line}, a start {@link Point}, and a stop point\n * and returns a subsection of the line in-between those points.\n * The start & stop points don't need to fall exactly on the line.\n *\n * This can be useful for extracting only the part of a route between waypoints.\n *\n * @name lineSlice\n * @param {Feature<Point>} startPt starting point\n * @param {Feature<Point>} stopPt stopping point\n * @param {Feature<LineString>|LineString} line line to slice\n * @returns {Feature<LineString>} sliced line\n * @example\n * var line = turf.lineString([\n *     [-77.031669, 38.878605],\n *     [-77.029609, 38.881946],\n *     [-77.020339, 38.884084],\n *     [-77.025661, 38.885821],\n *     [-77.021884, 38.889563],\n *     [-77.019824, 38.892368]\n * ]);\n * var start = turf.point([-77.029609, 38.881946]);\n * var stop = turf.point([-77.021884, 38.889563]);\n *\n * var sliced = turf.lineSlice(start, stop, line);\n *\n * //addToMap\n * var addToMap = [start, stop, line]\n */\nfunction lineSlice(startPt, stopPt, line) {\n    var coords;\n    if (line.type === 'Feature') {\n        coords = line.geometry.coordinates;\n    } else if (line.type === 'LineString') {\n        coords = line.coordinates;\n    } else {\n        throw new Error('input must be a LineString Feature or Geometry');\n    }\n\n    var startVertex = nearestPointOnLine(line, startPt);\n    var stopVertex = nearestPointOnLine(line, stopPt);\n    var ends;\n    if (startVertex.properties.index <= stopVertex.properties.index) {\n        ends = [startVertex, stopVertex];\n    } else {\n        ends = [stopVertex, startVertex];\n    }\n    var clipCoords = [ends[0].geometry.coordinates];\n    for (var i = ends[0].properties.index + 1; i < ends[1].properties.index + 1; i++) {\n        clipCoords.push(coords[i]);\n    }\n    clipCoords.push(ends[1].geometry.coordinates);\n    return lineString(clipCoords, line.properties);\n}\n\n/**\n * Performs a deep comparison between two values to determine if they are\n * equivalent.\n *\n * **Note:** This method supports comparing arrays, array buffers, booleans,\n * date objects, error objects, maps, numbers, `Object` objects, regexes,\n * sets, strings, symbols, and typed arrays. `Object` objects are compared\n * by their own, not inherited, enumerable properties. Functions and DOM\n * nodes are compared by strict equality, i.e. `===`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.isEqual(object, other);\n * // => true\n *\n * object === other;\n * // => false\n */\nfunction isEqual(value, other) {\n  return baseIsEqual(value, other);\n}\n\n/**\n * Takes two coordinates and returns the distance between them, in degrees\n * @param  {Array<number>} coord1 An array indicating a coordinate [lng, lat]\n * @param  {Array<number>} coord2 An array indicating a coordinate [lng, lat]\n * @return {number}        the distance between the points, in degrees \n */\nfunction diffCoords(coord1, coord2) {\n\tvar vector = [Math.abs(coord1[0] - coord2[0]), Math.abs(coord1[1] - coord2[1])];\n\treturn Math.sqrt(Math.pow(vector[0], 2) + Math.pow(vector[1], 2));\n}\n\n/**\n * Determina si dos lineas se intersectan\n * @param  {Array.<number>} line1Start [description]\n * @param  {Array.<number>} line1End   [description]\n * @param  {Array.<number>} line2Start [description]\n * @param  {Array.<number>} line2End   [description]\n * @param {boolean} useOldMethod if true, use old method instead of turf_line_intersect \n * @return {Array}             [description]\n */\nfunction lineIntersects$1(line1Start, line1End, line2Start, line2End, useOldMethod) {\n\n\tif (!useOldMethod) {\n\t\tvar line1 = lineString([line1Start, line1End]),\n\t\t    line2 = lineString([line2Start, line2End]),\n\t\t    intersectionFC = lineIntersect(line1, line2);\n\n\t\tif (intersectionFC.features.length) {\n\t\t\tvar intersection = intersectionFC.features[0].geometry.coordinates;\n\t\t\tintersection[0] = Math.round(intersection[0] * 100000000) / 100000000;\n\t\t\tintersection[1] = Math.round(intersection[1] * 100000000) / 100000000;\n\t\t\treturn intersection;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\tvar line1StartX = line1Start[0],\n\t    line1StartY = line1Start[1],\n\t    line1EndX = line1End[0],\n\t    line1EndY = line1End[1],\n\t    line2StartX = line2Start[0],\n\t    line2StartY = line2Start[1],\n\t    line2EndX = line2End[0],\n\t    line2EndY = line2End[1];\n\t// if the lines intersect, the result contains the x and y of the intersection\n\t// (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point\n\tvar denominator,\n\t    a,\n\t    b,\n\t    numerator1,\n\t    numerator2,\n\t    result = {\n\t\tx: null,\n\t\ty: null,\n\t\tonLine1: false,\n\t\tonLine2: false\n\t};\n\tdenominator = (line2EndY - line2StartY) * (line1EndX - line1StartX) - (line2EndX - line2StartX) * (line1EndY - line1StartY);\n\tif (denominator === 0) {\n\t\tif (result.x !== null && result.y !== null) {\n\t\t\treturn result;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\ta = line1StartY - line2StartY;\n\tb = line1StartX - line2StartX;\n\tnumerator1 = (line2EndX - line2StartX) * a - (line2EndY - line2StartY) * b;\n\tnumerator2 = (line1EndX - line1StartX) * a - (line1EndY - line1StartY) * b;\n\ta = numerator1 / denominator;\n\tb = numerator2 / denominator;\n\n\t// if we cast these lines infinitely in both directions, they intersect here:\n\tresult.x = line1StartX + a * (line1EndX - line1StartX);\n\tresult.y = line1StartY + a * (line1EndY - line1StartY);\n\n\t// if line1 is a segment and line2 is infinite, they intersect if:\n\tif (a >= 0 && a <= 1) {\n\t\tresult.onLine1 = true;\n\t}\n\t// if line2 is a segment and line1 is infinite, they intersect if:\n\tif (b >= 0 && b <= 1) {\n\t\tresult.onLine2 = true;\n\t}\n\t// if line1 and line2 are segments, they intersect if both of the above are true\n\tif (result.onLine1 && result.onLine2) {\n\t\tresult.x = Math.round(result.x * 100000000) / 100000000;\n\t\tresult.y = Math.round(result.y * 100000000) / 100000000;\n\n\t\treturn [result.x, result.y];\n\t} else {\n\t\treturn false;\n\t}\n}\n\n/**\n * Takes two rings and finds their instersection points. If the rings are the same, the second ring is iterated skipping points already checked in the first one\n * @param  {Array.Array<number>} ring1 Array of coordinates [lng, lat]\n * @param  {Array.Array<number>} ring1 Array of coordinates [lng, lat]\n * @param {boolean} useOldMethod if true, use old method instead of turf_line_intersect \n * @return {Object}       an object containing\n */\nfunction traverseRings(ring1, ring2, useOldMethod) {\n\tvar intersections = featureCollection([]);\n\n\tvar samering = false;\n\tif (isEqual(ring1, ring2)) {\n\t\tsamering = true;\n\t}\n\tfor (var i = 0; i < ring1.length - 1; i++) {\n\t\tvar startK = samering ? i : 0;\n\t\tfor (var k = startK; k < ring2.length - 1; k++) {\n\t\t\t// don't check adjacent sides of a given ring, since of course they intersect in a vertex.\n\t\t\tif (ring1 === ring2 && (Math.abs(i - k) === 1 || Math.abs(i - k) === ring1.length - 2)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar intersection = lineIntersects$1(ring1[i], ring1[i + 1], ring2[k], ring2[k + 1], useOldMethod);\n\t\t\tif (!intersection) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// si son lineas consecutivas no quiero detectar el límite entre ambas\n\t\t\tif ((diffCoords(intersection, ring1[0]) < 0.000005 || diffCoords(intersection, ring1[ring1.length - 1]) < 0.000005) && (diffCoords(intersection, ring2[0]) < 0.000005 || diffCoords(intersection, ring2[ring2.length - 1]) < 0.000005)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//debug('intersection at',\n\t\t\t// intersection,\n\t\t\t//diffCoords(intersection, ring2[0]),\n\t\t\t//diffCoords(intersection, ring1[ring1.length - 1]));\n\t\t\tvar FeatureIntersection = point([intersection[0], intersection[1]]);\n\t\t\tFeatureIntersection.properties = {\n\t\t\t\tposition1: i,\n\t\t\t\tposition2: k\n\t\t\t};\n\t\t\tintersections.features.push(FeatureIntersection);\n\t\t}\n\t}\n\treturn intersections;\n}\n\n/**\n * Finds the {@link Point|points} where two {@link LineString|linestrings} intersect each other\n * @param  {Array.<google.maps.LatLng>} arrayLatLng1 array de posiciones {@link google.maps.LatLng}\n * @param  {Array.<google.maps.LatLng>} arrayLatLng2 array de posiciones {@link google.maps.LatLng}\n * @param {boolean} useOldMethod if true,use old method instead of turf_line_intersect \n * @return {Array}        an array with [line1 trimmed at intersection,line2 trimmed at intersection,intersection ] \n */\nfunction trimPaths(arrayLatLng1, arrayLatLng2, useOldMethod) {\n\n\tvar ring1 = toCoords(arrayLatLng1); // googleGeom1.geometry.coordinates;\n\tvar ring2 = toCoords(arrayLatLng2); // googleGeom2.geometry.coordinates;\n\n\n\tvar intersections = traverseRings(ring1, ring2, useOldMethod);\n\n\tif (intersections.features.length > 0) {\n\n\t\tvar line1 = lineString(ring1);\n\t\tvar line2 = lineString(ring2);\n\t\tvar line1Start = point(ring1[0]);\n\t\tvar line2End = point(ring2.slice(-1)[0]);\n\t\tvar sliced1, sliced2;\n\n\t\t// The first segment of the first ring with a kink\n\t\tvar first_segment_with_kinks = min$1(intersections.features, function (kink) {\n\t\t\treturn kink.properties.position1;\n\t\t});\n\t\t//console.log('first_segment_with_kinks', JSON.stringify(first_segment_with_kinks));\n\n\t\t// All the intersections which belong to the first segment with a kink of the first ring\n\t\tvar kinks_in_first_segment = filter(intersections.features, function (kink) {\n\t\t\treturn kink.properties.position1 === first_segment_with_kinks.properties.position1;\n\t\t});\n\n\t\t// Among the kinks in the first segment, which one happens further along the ring2\n\t\tvar chosenIntersection = max$1(kinks_in_first_segment, function (kink) {\n\t\t\treturn kink.properties.position2;\n\t\t});\n\n\t\tvar intersectLatLng = toLatLngs([chosenIntersection.geometry.coordinates])[0];\n\n\t\t// if the first intersection happens in the first segment of line1\n\t\t// then we don't slice it\n\t\tif (chosenIntersection.properties.position1 === 0) {\n\t\t\tsliced1 = line1;\n\t\t} else {\n\t\t\tsliced1 = lineSlice(line1Start, chosenIntersection, line1);\n\t\t}\n\n\t\t// if the first intersection happens after the last segment of line2\n\t\t// then we don't slice it\n\t\tif (chosenIntersection.properties.position2 >= ring2.length - 1) {\n\t\t\tsliced2 = line2;\n\t\t} else {\n\t\t\tsliced2 = lineSlice(chosenIntersection, line2End, line2);\n\t\t}\n\n\t\treturn [toLatLngs(sliced1.geometry.coordinates), toLatLngs(sliced2.geometry.coordinates), intersectLatLng];\n\t}\n\treturn [];\n}\n\n/**\n * This module acts as a bridge between google.maps and Turf, \n * By converting google maps overlays such as\n * {@link google.maps.Polygon}\n * {@link google.maps.Polyline}\n * {@link google.maps.Point}\n *\n * to their proper geojson representation.\n *\n * This in turn allows to perform Turf operations that google.maps doesn't natively support\n * \n * @name turfHelper\n * @module turfHelper\n */\nvar ig_turfhelper = {\n    along: along,\n    arrayToFeaturePoints: arrayToFeaturePoints,\n    createbuffer: createbuffer,\n    pointInPolygon: pointInPolygon,\n    polygonToFeaturePolygon: polygonToFeaturePolygon,\n    polylineToFeatureLinestring: polylineToFeatureLinestring,\n    simplifyFeature: simplifyFeature,\n    simplifyPointArray: simplifyPointArray,\n    toLatLngs: toLatLngs,\n    toCoords: toCoords,\n    trimPaths: trimPaths,\n    union: union,\n    kinks: kinks,\n    unkink: unkink,\n    concave: concave\n};\n\nexports.along = along;\nexports.arrayToFeaturePoints = arrayToFeaturePoints;\nexports.createbuffer = createbuffer;\nexports.pointInPolygon = pointInPolygon;\nexports.polygonToFeaturePolygon = polygonToFeaturePolygon;\nexports.polylineToFeatureLinestring = polylineToFeatureLinestring;\nexports.simplifyFeature = simplifyFeature;\nexports.simplifyPointArray = simplifyPointArray;\nexports.toLatLngs = toLatLngs;\nexports.toCoords = toCoords;\nexports.trimPaths = trimPaths;\nexports.kinks = kinks;\nexports.unkink = unkink;\nexports.union = union;\nexports.concave = concave;\nexports['default'] = ig_turfhelper;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"],"names":["global","factory","exports","define","amd","turfHelper","this","Wkt","array","iteratee","length","result","Array","index","value","other","key","eq","entries","clear","set","entry","undefined","undefinedTag","nullTag","symToStringTag","hasOwnProperty$1","call","symToStringTag$1","tag","e","nativeObjectToString","unmasked","isOwn","getRawTag","objectToString","_typeof","type","isObject","baseGetTag","funcTag","genTag","asyncTag","proxyTag","func","maskSrcKey","isMasked","isFunction","reIsNative","reIsHostCtor","test","toSource","object","getValue","map","__data__","data","size","values","add","predicate","cache","has","bitmask","customizer","equalFunc","stack","COMPARE_PARTIAL_FLAG$2","arrLength","othLength","isPartial","get","stacked","seen","COMPARE_UNORDERED_FLAG$1","othValue","arrValue","compared","arraySome","othIndex","cacheHas","push","forEach","resIndex","argsTag$1","MAX_SAFE_INTEGER","reIsUint","MAX_SAFE_INTEGER$1","inherited","isArray","isArg","isArr","isArguments","isBuff","isBuffer","isType","isTypedArray","skipIndexes","n","baseTimes","String","hasOwnProperty$6","isIndex","constructor","Ctor","prototype","objectProto$11","isPrototype","hasOwnProperty$8","isLength","arrayLikeKeys","baseKeys","keysFunc","symbolsFunc","offset","arrayPush","keys","getSymbols","othIsArr","objTag","objIsArr","arrayTag","getTag$1","othTag","argsTag","objectTag","othIsObj","isSameTag","objIsObj","equalArrays","byteLength","byteOffset","buffer","name","message","mapToArray","COMPARE_PARTIAL_FLAG$3","convert","setToArray","COMPARE_UNORDERED_FLAG$2","symbolValueOf","equalByTag","COMPARE_PARTIAL_FLAG$1","hasOwnProperty$4","othIsWrapped","objIsWrapped","othUnwrapped","objUnwrapped","COMPARE_PARTIAL_FLAG$4","objProps","getAllKeys","objLength","hasOwnProperty$5","objValue","skipCtor","othCtor","objCtor","isObjectLike","baseIsEqual","srcValue","source","isStrictComparable","getMatchData","matchData","noCustomizer","Object","COMPARE_PARTIAL_FLAG","COMPARE_UNORDERED_FLAG","baseIsMatch","symbolTag$1","isSymbol","reIsDeepProp","resolver","FUNC_ERROR_TEXT","arguments","apply","args","memoized","memoize","Cache","MapCache","baseToString","symbolToString","INFINITY","stringToPath","toString","INFINITY$1","path","castPath","toKey","hasFunc","hasPath","baseHasIn","isKey","defaultValue","baseGet","get$1","hasIn","COMPARE_PARTIAL_FLAG$5","COMPARE_UNORDERED_FLAG$3","baseProperty","basePropertyDeep","baseMatchesProperty","baseMatches","collection","arrayMap","isArrayLike","baseEach","baseIteratee","identity","castFunction","position","maps","LatLng","lat","lng","coordinates","toLatLng","google","arrayLatLng","closeRing","toCoord$1","ring","pop","last_coord","geometry","properties","bbox","id","indexOf","feat","isNumber","i","j","features","fc","radians","units","factors","factor","distance","Math","PI","degrees","num","isNaN","input","LatLngArray","toCoords","objeto","vertices","Polyline","getPath","getArray","polygonFeature","Polygon","arrayToFeaturePolygon","latLngArray","latLng","FeatureCollection","Feature","points","z","sort","byX","b","c","A","B","G","xmin","x","xmax","ymin","y","ymax","dy","dmax","dx","xmid","ymid","open","__sentinel","closed","edges","r","splice","a","dedup","abs","triangulate","p","point$$1","isPointZ","triangle","C","D","E","F","m","outer","geojson","cloned","feature","cloneProperties","cloneGeometry","item","geom","geometries","deepSlice","coords","slice","coord","obj","getCoords","containsNumber","callback","excludeWrapCoord","geometryIndex","k","l","geometry$$1","stopG","geometryMaybeCollection","isGeometryCollection","wrapShrink","coordIndex","isFeatureCollection","isFeature","stop","featureIndex","geomType","featureSubIndex","coordEach","g","featureProperties","featureBBox","featureId","geomEach","coordinate","initialValue","flattenEach","feature$$1","lineIndex","lineString","lineEach","currentLine","previousValue","options","isObject$2","mutate","getType","clone","lineReduce","previousLine","coordId","coords1","coords2","s1","e2","concat","s2","e1","reverse","mergeLineStrings","merged","lastLine","line","topology","o","arcs","transformPoint","arc","point","polygon","transform","objects","extract","polygonsByArc","polygons","area","groups","_","neighbors","group","stitch","ki","t","start","end","mid","geomifyFeature","output","geomifyGeometry","arcA","arcB","ja","ib","jb","ia","geoms","geometryCollection","topo","types","getHomogenousType","from","to","getCoord","degreesToRadians","coordinates2","coordinates1","pow","sin","dLat","dLon","cos","lat1","lat2","atan2","sqrt","maxEdge","Infinity","tin","featureEach","pt","join","existing","hasOwnProperty","cleaned","removeDuplicates","tinPolys","filter","pt1","pt2","pt3","dist2","dist3","dissolve","dissolved","arrayToFeaturePoints","equals","nextPoint","newPoints","secondToLast","prevPoint","startY","endY","endX","startX","dyl","dxl","isPointOnLineSegment","tolerance","highQuality","newCoords","cleanLine","polyPoints","cleanCoords","simplifyLine","lines","simplifyPolygon","rings","simplifyGeom","pts","simplify$1","checkValidity","simpleRing","coordArray","simplify","toLowerCase","Wicket$1","fromObject","toJson","polygonToFeaturePolygon","simplifiedgeom","warn","fromJson","toObject","final","bearing","bear","lon2","lon1","origin","lengthToRadians","asin","latitude1","bearing_rad","radiansToDegrees","longitude1","latitude2","distance$$1","travelled","overshot","destination","direction","Error","RuntimeException","Coordinate","NULL_ORDINATE","_dimensionsToTest","DimensionalComparator","dimensionsToTest","array_","addAll","ArrayList","ensureCapacity","allowRepeated","_minx","_maxx","_miny","_maxy","init","env","p2","p1","x2","y1","y2","x1","Exception","str","_hi","_lo","dd","DD","parse","lo","hi","w","_y","_x","_w","q1","q2","py","qw","qy","pw","qx","px","_envelope","_factory","_SRID","_userData","getSRID","BLACK","color","parent","left","right","root_","size_","_geometries","Geometry","hasNullElements","GeometryCollection","lineStrings","_geom","_geomFact","_bnRule","_endpointMap","BoundaryOp","BoundaryNodeRule","MOD2_BOUNDARY_RULE","bnRule","getFactory","count","_points","_coordinates","_shell","_holes","holes","shell","createLinearRing","isEmpty","hasNonEmptyElements","LinearRing","getCoordinateSequenceFactory","create","hasInterface","CoordinateSequence","LineString","validateConstruction","_isUserDataCopied","_dimension","CoordinateArraySequence","Number","isInteger","fill","coordSeq","getDimension","getCoordinateCopy","dimension","itp","array2","next","done","v","_values","map_","_modelType","_scale","PrecisionModel","FLOATING","modelType","FIXED","setScale","scale","pm","_name","Type","nameToTypeMap","put","_precisionModel","_coordinateSequenceFactory","GeometryFactory","CoordinateSequenceFactory","coordinateSequenceFactory","precisionModel","getDefaultCoordinateSequenceFactory","SRID","geometryFactory","parser","_result","_inputLines","_intPt","_intLineIndex","_isProper","_pa","_pb","LineIntersector","_p","_crossingCount","_isPointOnSegment","p0","LineSegment","ls","y0","x0","_matrix","setAll","Dimension","FALSE","IntersectionMatrix","elements","Location","INTERIOR","BOUNDARY","EXTERIOR","_areaBasePt","_triangleCent3","_areasum2","_cg3","_lineCentSum","_totalLength","_ptCount","_ptCentSum","treeSet","list","_geomFactory","_inputPts","ConvexHull","extractCoordinates","geomFactory","UniqueCoordinateArrayFilter","filterCoordinates","_origin","_inputGeom","_pruneEmptyGeometry","_preserveGeometryCollectionType","_preserveCollections","_preserveType","_snapTolerance","_srcPts","_seg","_allowSnappingToSourceVertices","_isClosed","snapTolerance","LineStringSnapper","srcLine","getCoordinates","srcPts","isClosed","_srcGeom","srcGeom","GeometryTransformer","_snapPts","_isSelfSnap","snapPts","isSelfSnap","_isFirst","_commonMantissaBitsCount","_commonBits","_commonSignExp","_commonCoord","_ccFilter","_commonBitsX","_commonBitsY","trans","_parent","_atStart","_max","_index","_subcollectionIterator","getNumGeometries","_boundaryRule","OGC_SFS_BOUNDARY_RULE","_isIn","_numBoundaries","boundaryRule","_pts","_data","_bounds","_item","bounds","_size","_items","_childBoundables","_level","level","_boundable1","_boundable2","_distance","_itemDistance","boundable2","itemDistance","boundable1","_root","_built","_itemBoundables","_nodeCapacity","AbstractSTRtree","DEFAULT_NODE_CAPACITY","Assert","isTrue","nodeCapacity","STRtree","AbstractNode","_segString","segmentIndex","_segmentOctant","_isInterior","segmentOctant","segString","equals2D","getCoordinate","_nodeMap","_edge","edge","_nodeList","_nodeIt","_currNode","_nextNode","_currSegIndex","nodeList","getEdge","iterator","readNextNode","tempEnv1","tempEnv2","_overlapSeg1","_overlapSeg2","_start","_end","_env","_context","_id","context","_segInt","setSegmentIntersector","segInt","_monoChains","_idCounter","_nodedSegStrings","_nOverlaps","SinglePassNoder","si","MonotoneChainOverlapAction","_si","msg","TopologyException","msgWithCoord","_findAllIntersections","_isCheckEndSegmentsOnly","_li","_interiorIntersection","_intSegments","_intersections","_intersectionCount","_keepIntersections","li","_segStrings","_isValid","segStrings","_nv","EdgeNodingValidator","toSegmentStrings","_mapOp","mapOp","location","Position","ON","on","gl","LEFT","RIGHT","elt","onLoc","lbl","NONE","geomIndex","setLocation","leftLoc","rightLoc","setLocations","_startDe","_maxNodeDegree","_edges","_label","_ring","_isHole","_geometryFactory","computePoints","computeRing","EdgeRing","_isInResult","_isCovered","_isCoveredSet","_isVisited","label","GraphComponent","_coord","nodeMap","nodeFact","_node","_p0","_p1","_dx","_dy","_quadrant","EdgeEnd","_isForward","_sym","_next","_nextMin","_edgeRing","_minEdgeRing","_depth","isForward","getNumPoints","computeDirectedLabel","_nodes","_edgeEndList","_shellList","_op","_ptLocator","_lineEdgesList","_resultLineList","ptLocator","op","_resultPointList","_edgeMap","_edgeList","_ptInAreaLocation","EdgeEndStar","_resultAreaEdgeList","_SCANNING_FOR_INCOMING","_LINKING_TO_OUTGOING","NodeFactory","mce","chainIndex","_xValue","_eventType","_insertEvent","_deleteEventIndex","_obj","insertEvent","SweepLineEvent","DELETE","INSERT","_hasIntersection","_hasProper","_hasProperInterior","_properIntersectionPoint","_includeProper","_recordIsolated","_isSelfIntersection","_numIntersections","numTests","_bdyNodes","_isDone","_isDoneWhenProperInt","includeProper","recordIsolated","EdgeSetIntersector","events","nOverlaps","_min","Double","POSITIVE_INFINITY","NEGATIVE_INFINITY","IntervalRTreeNode$1","max","min","_node1","_node2","n2","n1","buildExtent","_leaves","_lines","_isForcedToLineString","isForcedToLineString","Polygonal","_counter","counter","dist","startIndex","env1","env2","mcb","getChainStartIndices","Depth","NULL_VALUE","eiList","_mce","_isIsolated","_depthDelta","Edge","PlanarGraph","_parentGeom","_lineEdgeMap","_boundaryNodeRule","_useBoundaryDeterminationRule","_argIndex","_boundaryNodes","_hasTooFewPoints","_invalidPoint","_areaPtLocator","parentGeom","GeometryGraph","argIndex","boundaryNodeRule","_resultPrecisionModel","_arg","setComputationPrecision","g0","getPrecisionModel","g1","GeometryGraphOperation","compareTo","_orientation","OrientedCoordinateArray","orientation","_ocaMap","_resultGeom","_graph","_resultPolyList","_cbr","g2","computeSnapTolerance","_interiorPoint","_maxWidth","_poly","_centreY","_hiY","MAX_VALUE","_loY","poly","getEnvelopeInternal","getMaxY","getMinY","InteriorPointArea","avg","_centroid","_minDistance","getCentroid","addInterior","addEndpoints","selectedSegment","_subnode","interval","_pt","_interval","computeKey","NodeBase","_centre","getMin","getMax","_minExtent","_tree","_crossings","buildIndex","MonotoneChainSelectAction","mcp","_input","_extremalPts","_radius","_isConvex","_convexHullPts","_minBaseSeg","_minWidthPt","_minPtIndex","_minWidth","MinimumDiameter","inputGeom","isConvex","_distanceTolerance","distanceTolerance","_orig","orig","_isMarked","HalfEdge","_vertexMap","_isStart","MarkHalfEdge","EdgeGraph","_nodeEdgeStack","_ringStartEdge","itemEnv","NodeBase$1","_centrex","_centrey","getMinX","getMaxX","_noder","_scaleFactor","_offsetX","_offsetY","_isScaled","scaleFactor","ScaledNoder","noder","isIntegerPrecision","_isClosedEndpointsInInterior","_nonSimpleLocation","isInBoundary","degree","_quadrantSegments","BufferParameters","DEFAULT_QUADRANT_SEGMENTS","_endCapStyle","CAP_ROUND","_joinStyle","JOIN_ROUND","_mitreLimit","DEFAULT_MITRE_LIMIT","_isSingleSided","_simplifyFactor","DEFAULT_SIMPLIFY_FACTOR","setQuadrantSegments","quadrantSegments","endCapStyle","setEndCapStyle","joinStyle","mitreLimit","setJoinStyle","setMitreLimit","_minIndex","_minCoord","_minDe","_orientedDe","_finder","_dirEdgeList","_rightMostCoord","_inputLine","_distanceTol","_isDeleted","_angleOrientation","CGAlgorithms","COUNTERCLOCKWISE","inputLine","_ptList","_minimimVertexDistance","_maxCurveSegmentError","_filletAngleQuantum","_closingSegLengthFactor","_segList","_bufParams","_s0","_s1","_s2","_seg0","_seg1","_offset0","_offset1","_side","_hasNarrowConcaveAngle","bufParams","getQuadrantSegments","getJoinStyle","OffsetSegmentGenerator","MAX_CLOSING_SEG_LEN_FACTOR","_subgraphs","_cga","subgraphs","_upwardSeg","_leftDepth","depth","seg","_curveBuilder","_curveList","curveBuilder","_hasInterior","numIntersections","numInteriorIntersections","numProperIntersections","_workingPrecisionModel","_workingNoder","_originalPt","_ptScaled","_p0Scaled","_p1Scaled","_corner","_safeEnv","initCorners","_hotPixel","_parentEdge","_hotPixelVertexIndex","_isNodeAdded","parentEdge","hotPixelVertexIndex","hotPixel","_interiorIntersections","_pm","_pointSnapper","setPrecisionModel","getScale","_argGeom","_resultGeometry","_saveException","_comps","comps","_component","_segIndex","GeometryLocation","component","INSIDE_AREA","segIndex","_locations","locations","_terminateDistance","_minDistanceLocation","DistanceOp","terminateDistance","_directedEdges","GraphComponent$1","_from","_to","_edgeDirection","_angle","directionPt","edgeDirection","Quadrant","quadrant","DirectedEdge$1","_dirEdge","de1","setDirectedEdges","de0","_outEdges","_sorted","_deStar","Node$3","deStar","Edge$1","_line","_dirEdges","PlanarGraph$1","_mergedLineStrings","_edgeStrings","_geomGraph","_disconnectedRingcoord","geomGraph","_edgeEnds","EdgeEndBundle","getDirectedCoordinate","getLabel","insert","Node","_nodeGraph","_rings","_totalEnv","_nestedPt","graph","_errorType","TopologyValidationError","errorType","copy","_parentGeometry","_isSelfTouchingRingFormingHoleValid","_validErr","parentGeometry","_deList","_lowestEdge","_ringPts","_isProcessed","_isIncludedSet","_isIncluded","_lineStringAdder","_dangles","_cutEdges","_invalidRingLines","_holeList","_polyList","_isCheckingRingsValid","_extractOnlyPolygonal","Polygonizer","extractOnlyPolygonal","_im","_isolatedEdges","arg","_rectEnv","rectangle","_diagUp0","_diagUp1","_diagDown0","_diagDown1","rectEnv","_rectangle","ShortCircuitedGeometryVisitor","_intersects","_rectSeq","_containsPoint","getExteriorRing","getCoordinateSequence","_rectIntersector","_relate","_skipEmpty","_inputGeoms","GeometryCombiner","extractFactory","_inputPolys","polys","_pointGeom","_otherGeom","otherGeom","pointGeom","_sortIndex","sortIndex","_polygons","Collection","geomFact","_g0","_g1","_interacts0","_interacts1","GeometryEditor","CoordinateOperation","_targetPM","_removeCollapsed","removeCollapsed","targetPM","_changePrecisionModel","_isPointwise","_usePt","_isEnsureValidTopology","isEnsureValidTopology","TaggedLineSegment","_parentLine","_segs","_resultSegs","_minimumSize","TaggedLineString","parentLine","minimumSize","_querySeg","querySeg","_inputIndex","_outputIndex","_linePts","outputIndex","inputIndex","_lineSimplifier","_linestringMap","linestringMap","tps","_segLen","_splitPt","_minimumLen","getLength","_z","_isOnConstraint","_constraint","Vertex","_rot","_vertex","_subdiv","_isUsingTolerance","subdiv","getTolerance","_lastEdge","LocateFailureException","msgWithSpatial","_visitedKey","_quadEdges","_startingEdge","_tolerance","_edgeCoincidenceTolerance","_frameVertex","_frameEnv","_locator","_triEdges","QuadEdgeSubdivision","EDGE_COINCIDENCE_TOL_FACTOR","createFrame","initSubdiv","_triList","_coordList","_triCoords","_ls","z1","z2","Segment","_left","_right","_count","_numberOfNodes","KdTree","_matchNode","_matchDist","_initialVertices","_segVertices","_segments","_incDel","_convexHull","_splitFinder","_kdt","_vertexFactory","_computeAreaEnv","initialVertices","_siteCoords","_constraintLines","_constraintVertexMap","_clipEnv","_diagramEnv","_componentIndex","_segmentIndex","_segmentFraction","loc","segmentFraction","LinearLocation","componentIndex","normalize","doNormalize","_linearGeom","_numLines","_currentLine","_vertexIndex","LinearIterator","linear","getComponentIndex","segmentEndVertexIndex","vertexIndex","linearGeom","Lineal","loadCurrentLine","_ignoreInvalidLines","_fixInvalidLines","_lastPt","checkGeometryType","poly1","poly2","reader","read","JSON","stringify","UnionOp","union","write","union$1","BBox","projection","convertToMercator","convertToWgs84","newCoord","lonLat","MAXEXTENT","sign","D2R","log","tan","xy","R2D","atan","exp","reset","adder","s","bv","av","halfPi","stream","streamGeometryType","lineStart","lineEnd","polygonStart","streamLine","polygonEnd","cartesian","spherical","phi","cosPhi","lambda","vector","d","pi","tau","deltaLambda","deltaPhi","deltaGamma","compose","rotationLambda","rotationPhiGamma","rotationIdentity","forwardRotationLambda","rotation","invert","cosDeltaPhi","sinDeltaPhi","cosDeltaGamma","sinDeltaGamma","cosRadius","cartesianNormalizeInPlace","acos","radius","epsilon","a1","corner","comparePoint","cb","ca","visible","activeStream","first","x__","y__","v__","v_","x_","clipMin","clipMax","y_","clipLine","clean","segments","bufferStream","clipBuffer","clipStream","linePoint","NaN","rejoin","a0","b0","b1","winding","polygonInside","cleanInside","startInside","merge$1","interpolate","clipPolygon","compareIntersection","segment","methods","extent","h","clip","clipExtent","translate","geoStream","boundsStream$1","project","projectAt","projectRotate","rotate","rotateRadians","center","cacheStream","theta","preclip","clipAntimeridian","postclip","identity$4","delta2","projectResample","resample","projectTransform","transformRadians","clipAngle","clipCircle","recenter","precision","fitExtent","extent$$1","fitSize","steps","bufferFeature","buffered","results","bbox$1","projected","needsTransverseMercator","projectCoords","defineProjection","toMercator","radiansToLength","BufferOp","bufferOp","coordsIsNaN","unprojectCoords","toWgs84","proj","ext","earthRadius","comment","Marker","multiBuffered","buffer$1","ignoreBoundary","inBBox","insidePoly","inRing","inHole","yi","yj","xi","xj","isInside","sourceArray","geojsonPolygon","booleanPointInPolygon","marker","getPosition","markerToFeaturePoint","pointsInside","pointsOutside","Wicket","featureIn","line1","line2","line1StartX","line1StartY","line1EndX","line1EndY","line2StartX","line2StartY","line2EndX","line2EndY","numerator1","numerator2","onLine1","onLine2","denominator","lineIntersects","intersection","arr","compare","partialSort","floor","sd","swap","tmp","maxEntries","format","_maxEntries","_minEntries","ceil","_initFormat","node","toBBox","distBBox","children","destNode","createNode","minX","minY","maxX","maxY","child","extend$1","leaf","height","quickselect","array1","equalArrays$3","currentGeometry","currentIndex","currentProperties","calculateArea","polygonArea","ringArea","coordsLength","lowerIndex","middleIndex","upperIndex","rad","RADIUS","righthanded","equalArrays$2","console","simplepolygon","arrayFilter","comparator","current","computed","quickselectStep","swap$1","distBBox$1","createNode$1","extend$2","quickselect$3","lowLeft","topRight","topLeft","reduce","previousCoords","currentCoords","bbox$3","createSegments","lineSegmentFeature","intersects$1","intersect","rbush$3","tree","bboxPolygon","turfBBox","load","remove","search","collides","all","toJSON","fromJSON","json","geojsonRbush","lineSegment","match","unique","y4","y3","x4","x3","denom","numeA","numeB","uA","uB","heightDistance","lineIntersect","perpendicularPt1","perpendicularPt2","intersectPt","closestPt","sectionLength","startPt","stopPt","nearestPointOnLine","ends","startVertex","stopVertex","clipCoords","coord1","coord2","line1Start","line1End","line2Start","line2End","useOldMethod","intersectionFC","round","ring1","ring2","featureCollection","isEqual","samering","lineIntersects$1","diffCoords","FeatureIntersection","position1","position2","intersections","arrayLatLng1","arrayLatLng2","traverseRings","sliced2","baseExtremum","baseLt","min$1","baseGt","max$1","kink","first_segment_with_kinks","toLatLngs","chosenIntersection","sliced1","lineSlice","intersectLatLng","babelHelpers.typeof","Symbol","_wrapped","beginsWith","sub","substring","endsWith","delimiter","trim","initializer","wrapVertices","regExes","typeStr","spaces","numeric","comma","parenComma","doubleParenComma","trimParens","ogcTypes","crudeJson","components","isCollection","sameCoords","deconstruct","isRectangle","config","construct","iring","oring","cs","exec","toUpperCase","merge","wkt","prefix","matches","base","ingest","pieces","_point","multipoint","_multipoint","parts","linestring","_linestring","multilinestring","_multilinestring","_polygon","multipolygon","_multipolygon","box","_box","geometrycollection","split","parseFloat","multipoints","replace","subcomponents","x_cord","y_cord","optimized","editable","LatLngBounds","Rectangle","verts","paths","reverseInnerPolygons","extend","multiFlag","response","vertex","linestrings","computeSignedArea","Point","getAt","getPaths","areas","lastIndexOf","unshift","Circle","getCenter","getRadius","rlat","d2r","rlng","getSouthWest","getNorthEast","getBounds","Data","getGeometry","MultiPoint","MultiLineString","MultiPolygon","ListCache","assocIndexOf","self","freeGlobal","freeSelf","Function","root","objectProto$1","_Symbol","toStringTag","coreJsData","IE_PROTO","uid","funcProto","objectProto","RegExp","funcToString","getNative","Hash","nativeCreate","HASH_UNDEFINED","hasOwnProperty$3","HASH_UNDEFINED$1","hash","Map$1","string","getMapData","Stack","pairs","LARGE_ARRAY_SIZE","SetCache","HASH_UNDEFINED$2","Uint8Array","symbolProto","valueOf","propertyIsEnumerable","getOwnPropertySymbols","nativeGetSymbols","symbol","objectProto$9","baseIsArguments","hasOwnProperty$7","propertyIsEnumerable$1","nodeType","freeExports","module","freeModule","Buffer","typedArrayTags","freeExports$1","freeModule$1","process","freeProcess","binding","nodeUtil","nodeIsTypedArray","baseUnary","overArg","DataView","Promise$1","Set","WeakMap","getTag","resolve","ctorString","MAX_MEMOIZE_SIZE","memoizeCapped","reLeadingDot","rePropName","number","quote","reEscapeChar","symbolProto$1","fromRight","iterable","props","createBaseFor","eachFunc","createBaseEach","baseFor","rsCombo","rsNonAstral","rsRegional","rsSurrPair","rsAstral","meters","metres","millimeters","millimetres","centimeters","centimetres","kilometers","kilometres","miles","nauticalmiles","inches","yards","feet","debug","bind","kx","ky","fragmentByEnd","fragmentByStart","f","stitchedArcs","fragments","emptyIndex","dp","fg","gf","flush","mergeArcs","equal","keyType","keyEmpty","valueType","LN2","valstore","mask","keystore","matchKey","collisions","maybeSet","missingValue","pointA","pointB","floats","uints","previousIndex","nextIndex","visitedByIndex","leftByIndex","leftIndex","rightByIndex","rightIndex","junctionCount","junctionByIndex","indexes","hashmap","hashIndex","equalIndex","Int32Array","indexByPoint","sequence","ringStart","ringEnd","empty","store","hashset","hashPoint","equalPoint","junctionByPoint","lineMid","junctions","0","1","ringMid","ringFixed","reverse$1","rotateArray","endPoint","startArcs","startArc","endArcs","endArc","arcsByEnd","startPoint","equalLine","reverseEqualLine","findMinimumOffset","kb","ka","minimum","minimumPoint","arcCount","dedupLine","equalRing","reverseEqualRing","dedupRing","quantization","indexGeometryType","indexByArc","indexArcs","boundGeometryType","boundPoint","boundLine","boundGeometry","boundMultiLine","inputs","outputs","geomifyObject","geometry$1","quantizeRing","quantizeGeometryType","quantizeGeometry","quantizePoint","quantizeLine","quantizePolygon","prequantize","dedup$1","cut","extractGeometryType","extractRing","extractGeometry","extractLine","extractMultiRing","hashArc","equalArc","indexGeometry","indexMultiArcs","delta","fn","createCommonjsModule","highestQuality","sqTolerance","len","getSqDist","simplifyRadialDist","maxSqDist","sqDist","markers","last","getSqSegDist","simplifyDouglasPeucker","target","NumberUtil","interfaces_","getClass","equalsWithTolerance","doubleToLongBits","longBitsToDouble","isInfinite","isFinite","inherits$1","AssertionFailedException","shouldNeverReachHere","assertion","actualValue","expectedValue","setOrdinate","ordinateIndex","X","Y","Z","getOrdinate","equals3D","equalInZ","distance3D","dz","hashCode","setCoordinate","Comparable","Clonable","Serializable","trunc","o1","o2","c1","c2","compX","compY","Comparator","serialVersionUID","Iterator","hasNext","toArray","IndexOutOfBoundsException$1","List","NoSuchElementException","OperationNotSupported","element","found","arrayList","arrayList_","position_","Iterator_","CoordinateList","coll","isChanged","toCoordinateArray","coordArrayType","inc","Envelope","getArea","getWidth","getHeight","isNull","otherEnvelope","intersects","intMinX","intMinY","covers","expandToInclude","minExtent","transX","transY","setToNull","maxExtent","expandBy","deltaY","deltaX","contains","centre","q","minp","maxq","maxp","minq","NotRepresentableException","toLocationSymbol","locationValue","MathUtil","log10","ln","LOG_10","v1","v2","v3","v4","clamp","wrap","average","StringBuffer","append","setCharAt","substr","Integer","intValue","Character","isWhitespace","le","extractSignificantDigits","insertDecimalPoint","magnitude","TEN","mag","divide","gt","lt","ONE","multiply","MAX_PRINT_DIGITS","numDigits","decimalPointPos","buf","digit","rebiasBy10","digitChar","subtract","selfAdd","remMag","continueExtractingDigits","sqr","doubleValue","negate","isZero","selfSubtract","getSpecialNumberString","selfDivide","ylo","tc","hy","ty","U","u","yhi","SPLIT","hc","dump","createNaN","ge","selfMultiply","reciprocal","fhi","flo","rint","setValue","isNegative","ax","axdd","d2","S","H","T","zhi","zlo","tx","hx","selfSqr","ex","toStandardNotation","toSciNotation","specialStr","sigDigits","charAt","stringOfChar","numZeroes","SCI_NOT_ZERO","SCI_NOT_EXPONENT_CHAR","digits","trailingDigits","digitsWithDecimal","expStr","isPositive","signum","strlen","signCh","isDigit","ch","val","parseInt","numBeforeDec","numDecPlaces","val2","xAbs","xLog10","xMag","TWO_PI","PI_2","EPS","CGAlgorithmsDD","orientationIndex","orientationIndexFilter","dy2","dy1","dx2","signOfDet2x2","denom1","denom2","numx1","numx2","fracP","numy1","numy2","fracQ","pa","pb","pc","detleft","detright","det","detsum","DP_SAFE_EPSILON","errbound","getX","expandEnvelope","getY","M","System","arraycopy","src","srcPos","dest","destPos","getProperty","line.separator","HCoordinate","xInt","yInt","GeometryComponentFilter","getSortIndex","SORTINDEX_GEOMETRYCOLLECTION","getGeometryN","equalsTopo","equalsExact","geometryChanged","geometryChangedFilter","geometryChangedAction","equalsNorm","norm","compareToSameClass","comp","getUserData","getEnvelope","toGeometry","checkNotGeometryCollection","computeEnvelopeInternal","setSRID","setUserData","userData","aElement","bElement","comparison","isGeometryCollectionOrDerived","SORTINDEX_MULTIPOINT","SORTINDEX_MULTILINESTRING","SORTINDEX_MULTIPOLYGON","SORTINDEX_POINT","SORTINDEX_LINESTRING","SORTINDEX_LINEARRING","SORTINDEX_POLYGON","CoordinateFilter","boundaryCount","Mod2BoundaryNodeRule","EndPointBoundaryNodeRule","MultiValentEndPointBoundaryNodeRule","MonoValentEndPointBoundaryNodeRule","ENDPOINT_BOUNDARY_RULE","MULTIVALENT_ENDPOINT_BOUNDARY_RULE","MONOVALENT_ENDPOINT_BOUNDARY_RULE","CoordinateArrays","isRing","ptNotInList","testPts","testPt","scroll","firstCoordinate","newCoordinates","coordinateComparator","coordList","hasRepeatedPoints","removeRepeatedPoints","removeNull","nonNull","copyDeep","srcStart","destStart","isEqualReversed","pts1","pts2","envelope","atLeastNCoordinatesOrNothing","increasingDirection","minCoordinate","minCoord","npts","extractPts","iPts","ForwardComparator","BidirectionalComparator","OLDcompare","dir1","dir2","i1","i2","comparePt","Map$3","entrySet","SortedMap","Set$2","HashSet","util","hashSet","hashSet_","Iterator_$1","TreeMap","cmp","getKey","fixAfterInsertion","parentOf","leftOf","colorOf","rightOf","setColor","rotateLeft","rotateRight","getFirstEntry","successor","SortedSet","TreeSet","treeSet_","Iterator_$2","Arrays","asList","toDimensionSymbol","dimensionValue","SYM_FALSE","TRUE","SYM_TRUE","DONTCARE","SYM_DONTCARE","P","SYM_P","L","SYM_L","SYM_A","toDimensionValue","dimensionSymbol","GeometryFilter","CoordinateSequenceFilter","seq","isDone","isGeometryChanged","childCoordinates","isEquivalentClass","otherCollection","getBoundaryDimension","sum","numPoints","revGeoms","createGeometryCollection","theseElements","otherElements","gc","thisGeom","holeComp","getBoundary","getGeometryType","nLines","revLines","createMultiLineString","boundaryMultiLineString","mLine","getEmptyMultiPoint","computeBoundaryCoordinates","bdyPts","createPoint","createMultiPointFromCoords","boundaryLineString","getStartPoint","createMultiPoint","getEndPoint","addEndpoint","getCoordinateN","it","valence","Counter","StringUtil","chars","getStackTrace","os","printStackTrace","ps","stackTrace","lineNumberReader","readLine","NEWLINE","separator","tmpString","pos","tokenList","token","separatorlen","res","SIMPLE_ORDINATE_FORMAT","CoordinateSequences","copyCoord","dim","minDim","cs1","cs2","cs1Size","fact","newseq","ensureValidRing","createClosedRing","isSimple","otherLineString","getPointN","computeLength","createLineString","isCoordinate","Puntal","shellCoordinates","signedArea","getNumInteriorRing","prevX","prevY","otherPolygon","thisShell","otherPolygonShell","clockwise","uniqueCoordinates","isCCW","convexHull","otherShell","shellComp","nHole1","nHole2","getInteriorRingN","thisHole","otherHole","isValid","MINIMUM_VALID_SIZE","createMultiPolygon","allRings","allRingsArray","setCopyUserData","isUserDataCopied","edit","operation","editInternal","editGeometryCollection","editPolygon","getName","collectionForType","newPolygon","createPolygon","hole","GeometryEditorOperation","NoOpGeometryOperation","editCoordinates","CoordinateSequenceOperation","cloneCoordinates","strBuf","CoordinateArraySequenceFactory","readResolve","instance","instanceObject","defineProperty","proto","objectOnly","_keys","_itp","defineProperty$1","sharedSize","createCollection","delete","is","Map","MapPolyfill","HashMap","otherPrecisionModel","getMaximumSignificantDigits","otherSigDigits","isFloating","FLOATING_SINGLE","description","makePrecise","maxSigDigits","mostPrecise","pm1","pm2","maximumPreciseValue","buildGeometry","geomList","geomClass","partClass","isHeterogeneous","hasGeometryCollection","toGeometryArray","geom0","toPolygonArray","toLineStringArray","toPointArray","createGeometry","ptSeq","toMultiPolygonArray","multiPolygons","multiPolygonArray","geometryArray","toMultiLineStringArray","multiLineStrings","multiLineStringArray","lineStringArray","toMultiPointArray","multiPoints","multiPointArray","toLinearRingArray","linearRings","linearRingArray","pointArray","polygonArray","createPointFromInternalCoord","exemplar","emptyTypeStr","WKTParser","extract$1","wktType","_coordinate","linearring","_linearring","wktArray","WKTWriter","toLineString","getIndexAlongSegment","intIndex","computeIntLineIndex","getTopologySummary","isEndPoint","catBuf","isCollinear","computeIntersection","p3","p4","computeIntersect","getIntersectionNum","getEdgeDistance","isProper","hasIntersection","isInteriorIntersection","inputLineIndex","getIntersection","NO_INTERSECTION","computeEdgeDistance","COLLINEAR_INTERSECTION","getEndpoint","ptIndex","isIntersection","getIntersectionAlongSegment","pdx","pdy","nonRobustComputeEdgeDistance","DONT_INTERSECT","DO_INTERSECT","COLLINEAR","POINT_INTERSECTION","RobustLineIntersector","isInSegmentEnvelopes","intPt","normalizeToMinimum","n3","n4","normPt","smallestInAbsValue","safeHCoordinateIntersection","nearestEndpoint","intersectionWithNormalization","xabs","checkDD","intPtDD","out","println","isIn","normalizeToEnvCentre","computeCollinearIntersection","p1q1p2","p1q2p2","q1p1q2","q1p2q2","n00","n01","n10","n11","minX0","minX1","maxX0","maxX1","minY0","minY1","maxY0","maxY1","intMidX","intMidY","Pq1","Pq2","Qp1","Qp2","distancePointLine","minDist","nearestPt","RobustDeterminant","dx1","RayCrossingCounter","countSegment","minx","maxx","xIntSign","isPointInPolygon","getLocation","isOnSegment","locatePointInRing","distanceLineLine","noIntersection","r_num","isPointInRing","nPts","hiPt","hiIndex","iPrev","iNext","prev","computeOrientation","disc","distancePointLinePerpendicular","len2","minDistance","isOnLine","lineIntersector","CLOCKWISE","STRAIGHT","orient0","orient1","isVertical","projectionFactor","pf0","pf1","newp0","newp1","angle","distancePerpendicular","midPoint","closestPoints","closestPoint","close00","close01","close10","close11","comp0","temp","lineIntersection","pointAlongOffset","segmentLengthFraction","offsetDistance","ux","uy","segx","segy","setCoordinates","inputPt","segFrac","isHorizontal","pointAlong","java","lang","bits0","bits1","isIntersects","isDisjoint","isCovers","isCoveredBy","dimensionSymbols","row","col","column","isContains","setAtLeast","minimumDimensionSymbols","minimumDimensionValue","setAtLeastIfValid","isWithin","isTouches","dimensionOfGeometryA","dimensionOfGeometryB","isOverlaps","isEquals","ai","bi","transpose","requiredDimensionSymbols","im","isCrosses","requiredDimensionSymbol","actualDimensionValue","actualDimensionSymbols","Centroid","addPoint","setBasePoint","basePt","addLineSegments","segmentLen","lineLen","midx","midy","addHole","addTriangle","isPositiveArea","cent","addShell","centroid3","area2","EmptyStackException","Stack$2","peek","preSort","computeOctRing","inputPts","computeOctPts","octPts","lineOrPolygon","cleanRing","linearRing","original","currentCoordinate","nextCoordinate","previousDistinctCoordinate","isBetween","cleanedRing","cleanedRingCoordinates","c3","polyPts","reducedSet","reducedPts","padArray3","getConvexHull","grahamScan","sortedPts","cHS","cH","pad","RadialComparator","polarCompare","orient","dxp","dyp","dxq","dyq","oq","transformCoordinates","transformPolygon","transformLinearRing","isAllValidLinearRings","createCoordinateSequence","getInputGeometry","transformMultiLineString","transformLineString","transformGeom","transGeomList","transformMultiPoint","transformMultiPolygon","transformGeometryCollection","seqSize","snapVertices","srcCoords","findSnapForVertex","srcPt","snapVert","snapTo","snapSegments","distinctPtCount","findSegmentIndexToSnap","snapPt","snapIndex","setAllowSnappingToSourceVertices","allowSnappingToSourceVertices","GeometrySnapper","snapGeom","extractTargetCoordinates","snapToSelf","cleanResult","snappedGeom","ringPts","computeMinimumSegmentLength","ptSet","segLen","minSegLen","snap","snapper0","snapper1","computeOverlaySnapTolerance","computeSizeBasedSnapTolerance","fixedSnapTol","SNAP_PRECISION_FACTOR","SnapTransformer","snapLine","snapper","newPts","CommonBits","getCommon","numBits","signExpBits","numCommonMostSigMantissaBits","zeroLowerBits","bits","Long","toBinaryString","padStr","bitStr","getBit","nBits","num1","num2","CommonBitsRemover","addCommonBits","removeCommonBits","invCoord","getCommonCoordinate","CommonCoordinateFilter","Translater","xp","yp","GeometryCollectionIterator","isAtomic","PointLocator","locateInternal","locateInPolygonRing","shellLoc","holeLoc","locate","updateLocationInfo","computeLocation","ml","mpoly","geomi","Octant","octant","adx","ady","SegmentString","setData","getData","BasicSegmentString","getSegmentOctant","Boundable","ItemBoundable","getItem","PriorityQueue","poll","reorder","ItemVisitor","visitItem","SpatialIndex","query","getLevel","getChildBoundables","addChildBoundable","childBoundable","computeBounds","reverseOrder","Collections","alen","singletonList","BoundablePair","expandToQueue","priQ","isComposite","isComp1","isComp2","expand","isLeaves","nd","bndComposite","bndOther","bp","getDistance","getBoundable","getNodeCapacity","lastNode","nodes","build","removeItem","childToRemove","itemsTree","valuesTree","valuesTreeForChild","valuesTreeForNode","boundablesAtLevel","boundables","top","boundable","getIntersectsOp","searchBounds","visitor","childBoundables","createHigherLevels","getRoot","childToPrune","boundablesOfALevel","createParentBoundables","parentBoundables","childDepth","maxChildDepth","newLevel","sortedChildBoundables","getComparator","compareDoubles","IntersectsOp","ItemDistance","item1","item2","createParentBoundablesFromVerticalSlices","verticalSlices","createParentBoundablesFromVerticalSlice","intersectsOp","sliceCount","slices","boundablesAddedToSlice","sliceCapacity","searchEnv","yComparator","xComparator","minLeafCount","nearestNeighbour","itemDist","initBndPair","distanceLowerBound","bndPair","currentDistance","minPair","bnd","centreX","centreY","STRtreeNode","aBounds","bBounds","SegmentPointComparator","relativeSign","compareValue","xSign","ySign","compareSign0","compareSign1","SegmentNode","print","maxSegmentIndex","isInterior","SegmentNodeList","getSplitCoordinates","addEdgeCoordinates","eiPrev","ei","addCollapsedNodes","findCollapsesFromInsertedNodes","collapsedVertexIndexes","findCollapsesFromExistingVertices","ei0","ei1","lastSegStartPt","useIntPt1","addSplitEdges","edgeList","createSplitEdge","newEdge","findCollapseIndex","collapsedVertexIndex","numVerticesBetween","maxSegIndex","ipt","eiNew","checkSplitEdgesCorrectness","splitEdges","pt0","edgePts","splitnPts","ptn","NodeVertexIterator","NodableSegmentString","addIntersection","NodedSegmentString","safeOctant","addIntersectionNode","getNodeList","normalizedSegmentIndex","nextSegIndex","nextPt","addIntersections","getNodedSubstrings","resultEdgelist","overlap","start1","mc2","start2","mc1","getLineSegment","MonotoneChain","computeSelect","start0","end0","mcs","select","computeOverlaps","mc","mco","computeOverlapsInternal","setId","getEndIndex","getStartIndex","getContext","getId","end1","p00","p01","p10","p11","mid0","mid1","isNorthern","quad","NE","NW","isOpposite","quad1","quad2","commonHalfPlane","isInHalfPlane","halfPlane","SE","SW","MonotoneChainBuilder","startIndexList","findChainEnd","toIntArray","safeStart","chainQuad","getChains","mcList","Noder","computeNodes","MCIndexNoder","getMonotoneChains","getIndex","segStr","inputSegStrings","intersectChains","queryChain","testChain","overlapAction","SegmentOverlapAction","processIntersections","ss1","ss2","SegmentIntersector","e0","segIndex0","segIndex1","InteriorIntersectionFinder","getInteriorIntersection","setCheckEndSegmentsOnly","isCheckEndSegmentsOnly","getIntersectionSegments","getIntersections","setFindAllIntersections","findAllIntersections","setKeepIntersections","keepIntersections","isEndSegment","createAllIntersectionsFinder","finder","createAnyIntersectionFinder","createIntersectionCounter","FastNodingValidator","execute","checkInteriorIntersections","checkValid","getErrorMessage","intSegs","computeIntersections","nv","GeometryCollectionMapper","mapped","opposite","TopologyLocation","setAllLocations","locValue","setAllLocationsIfNull","isLine","newLoc","getLocations","flip","posIndex","isArea","isAnyNull","locIndex","isEqualOnSide","allPositionsEqual","Label","getGeometryCount","side","toLine","toLineLabel","lineLabel","isIsolated","de","getEdgeRing","mergeLabel","addPoints","isFirstEdge","setEdgeRing","getNext","getLinearRing","computeMaxNodeDegree","getNode","getEdges","getOutgoingDegree","isHole","setInResult","containsPoint","isShell","getMaxNodeDegree","getShell","deLabel","setShell","toPolygon","holeLR","MinimalEdgeRing","er","setMinEdgeRing","getNextMin","MaximalEdgeRing","buildMinimalRings","getMinEdgeRing","minEdgeRings","minEr","linkDirectedEdgesForMinimalEdgeRings","linkMinimalDirectedEdges","setVisited","isVisited","isInResult","isCovered","isCoveredSet","setLabel","setCovered","updateIM","computeIM","isIncidentEdgeInResult","computeMergedLocation","label2","eltIndex","nLoc","onLocation","setNode","setLabelBoundary","NodeMap","find","addNode","getBoundaryNodes","bdyNodes","compareDirection","getDy","className","lastDotPos","getDx","getQuadrant","computeLabel","DirectedEdge","getDepth","setDepth","depthVal","isInteriorAreaEdge","setNextMin","nextMin","getDepthDelta","minEdgeRing","isLineEdge","isExteriorIfArea0","isExteriorIfArea1","edgeRing","depthDelta","getSym","printEdge","printReverse","setSym","setVisitedEdge","setEdgeDepths","directionFactor","oppositePos","oppositeDepth","setNext","depthFactor","currLocation","nextLocation","printEdges","getNodeIterator","linkResultDirectedEdges","nodeit","debugPrintln","isBoundaryNode","linkAllDirectedEdges","matchInSameDirection","ep0","ep1","getEdgeEnds","debugPrint","getEdgeIterator","findEdgeInSameDirection","eCoord","insertEdge","findEdgeEnd","ee","addEdges","edgesToAdd","de2","getNodes","findEdge","PolygonBuilder","sortShellsAndHoles","edgeRings","shellList","freeHoleList","computePolygons","resultPolyList","placeFreeHoles","findEdgeRingContaining","buildMinimalEdgeRings","maxEdgeRings","findShell","placePolygonHoles","buildMaximalEdgeRings","dirEdges","getPolygons","testEr","testRing","tryShell","tryRing","minShell","minEnv","tryEnv","testEnv","isContained","shellCount","LineBuilder","collectLines","opCode","getGraph","collectLineEdge","collectBoundaryTouchEdge","labelIsolatedLine","targetIndex","getArgGeometry","findCoveredLineEdges","buildLines","OverlayOp","isResultOfOp","isCoveredByA","labelIsolatedLines","edgesList","INTERSECTION","PointBuilder","filterCoveredNodeToPoint","isCoveredByLA","extractNonCoveredResultNodes","getDegree","PointOnGeometryLocator","SimplePointInAreaLocator","containsPointInPolygon","getNextCW","iNextCW","propagateSideLabels","startLoc","currLoc","isAreaLabelsConsistent","computeEdgeEndLabels","getBoundaryNodeRule","checkAreaLabelsConsistent","lastEdgeIndex","findIndex","eSearch","computeLabelling","hasDimensionalCollapseEdge","insertEdgeEnd","DirectedEdgeStar","getResultAreaEdges","nextOut","firstOut","state","nextIn","incoming","getRightmostEdge","deLast","quad0","updateLabelling","nodeLabel","firstIn","prevOut","computeDepths","edgeIndex","startDepth","nextDepth","targetLastDepth","endIndex","nextDe","currDepth","mergeSymLabels","eLabel","eLoc","OverlayNodeFactory","MonotoneChain$1","computeIntersectsForChain","isDelete","setDeleteEventIndex","deleteEventIndex","getObject","pe","getInsertEvent","isInsert","isSameLabel","ev","getDeleteEventIndex","SegmentIntersector$1","isTrivialIntersection","isAdjacentSegments","getProperIntersectionPoint","setIsDoneIfProperInt","isDoneWhenProperInt","hasProperInteriorIntersection","isBoundaryPointInternal","hasProperIntersection","isBoundaryPoint","setBoundaryNodes","bdyNodes0","bdyNodes1","setIsolated","SimpleMCSweepLineIntersector","prepareEvents","processOverlaps","edges1","edges0","addEdge","edgeSet","getMonotoneChainEdge","getStartIndexes","ev0","ev1","mc0","queryMin","queryMax","NodeComparator","mid2","IntervalRTreeLeafNode","IntervalRTreeBranchNode","SortedPackedIntervalRTree","buildTree","buildLevel","buildRoot","printNode","LinearComponentExtracter","setForceToLineString","getLines","forceToLineString","ArrayListVisitor","getItems","IndexedPointInAreaLocator","rcc","SegmentVisitor","IntervalIndexedGeometry","addLine","EdgeIntersection","getSegmentIndex","EdgeIntersectionList","MonotoneChainIndexer","MonotoneChainEdge","chainIndex1","chainIndex0","computeIntersects","depthValue","minDepth","newValue","getDelta","depthAtLocation","getCollapsedEdge","setName","isEqualForward","iRev","isEqualReverse","isCollapsed","getMaximumSegmentIndex","isPointwiseEqual","setDepthDelta","getEdgeIntersectionList","insertBoundaryPoint","determineBoundary","computeSelfNodes","computeRingSelfNodes","isDoneIfProperInt","createEdgeSetIntersector","isRings","esi","computeAllSegments","addSelfIntersectionNodes","computeSplitEdges","edgelist","computeEdgeIntersections","hasTooFewPoints","insertPoint","addPolygon","addPolygonRing","addLineString","getInvalidPoint","getBoundaryPoints","addSelfIntersectionNode","lr","cwLeft","cwRight","eiIt","addCollection","compareOriented","oca","orientation1","orientation2","compPt","limit1","limit2","done1","done2","EdgeList","edgeColl","findEdgeIndex","findEqualEdge","insertUniqueEdge","existingEdge","labelToMerge","existingLabel","cancelDuplicateResultEdges","sym","computeGeometry","resultPointList","resultLineList","opcode","createEmptyResult","replaceCollapsedEdges","newEdges","updateNodeLabelling","getResultGeometry","overlayOpCode","computeOverlay","insertUniqueEdges","copyPoints","baseSplitEdges","computeLabelsFromDepths","labelIncompleteNodes","findResultAreaEdges","polyBuilder","lineBuilder","pointBuilder","labelIncompleteNode","graphNode","ni","overlayOp","geom1","MapOp","symDifference","SYMDIFFERENCE","resultDimension","dim0","dim1","UNION","DIFFERENCE","difference","loc0","loc1","SnapOverlayOp","selfSnap","remGeom","prepareResult","prepGeom","SnapIfNeededOverlayOp","isSuccess","savedException","horizontalBisector","bisector","width","widestGeometry","widestIntersection","getInteriorPoint","SafeBisectorFinder","getBisectorY","bisectY","updateInterval","InteriorPointLine","InteriorPointPoint","hasChildren","isPrunable","hasItems","addAllItems","items","subSize","addAllItemsFromOverlapping","resultItems","isSearchMatch","itemInterval","sqd","maxSubDepth","nodeSize","getSubnodeIndex","subnodeIndex","Interval","overlaps","DoubleBits","exponent","NumW","Qty","32","64","Bin","Sign","Expo","ExW","Mant","powerOf2","Key","getInterval","computeLevel","computeInterval","getPoint","Node$1","searchInterval","createSubnode","childNode","getSubnode","createExpanded","addInterval","expandInt","largerNode","IntervalSize","isZeroWidth","maxAbs","MIN_BINARY_EXPONENT","Root","insertContained","Bintree","collectStats","ensureExtent","insertInterval","foundItems","del","PointInRing","MCPointInRing","testLineSegment","mcEnv","testMonotoneChain","rayEnv","mcSelecter","segs","MCSelecter","Angle","toDegrees","PI_TIMES_2","isAcute","dx0","dy0","isObtuse","interiorAngle","angleNext","anglePrev","normalizePositive","angleBetween","tip1","tail","tip2","diff","a2","ang1","ang2","delAngle","toRadians","angleDegrees","getTurn","crossproduct","angleBetweenOriented","angDel","PI_OVER_2","PI_OVER_4","Triangle$1","interpolateZ","longestSideLength","circumcentre","area3D","centroid","inCentre","m00","m01","m10","m11","v0","lenAB","lenBC","maxLen","lenCA","cx","cy","ay","bx","by","perpendicularBisector","angleBisector","len0","frac","vz","uz","vy","vx","crossx","crossy","crossz","absSq","len1","circum","MinimumBoundingCircle","compute","getDiameter","getExtremalPoints","computeCirclePoints","hullPts","lowestPoint","pointWitMinAngleWithX","pointWithMinAngleWithSegment","Q","R","computeCentre","getFarthestPoints","getCircle","getCentre","minSin","minAngPt","ang","minAng","getWidthCoordinate","computeMinimumDiameter","getSupportingSegment","computeWidthConvex","convexGeom","computeConvexRingMinDiameter","currMaxIndex","findMaxPerpDistance","maxPerpDistance","maxIndex","nextPerpDistance","getMinimumRectangle","computeC","paraC","maxPara","minPara","perpC","maxPerp","minPerp","computeSegmentForLine","maxParaLine","maxPerpLine","minParaLine","minPerpLine","getMinimumDiameter","Densifier","setDistanceTolerance","densifyPoints","precModel","densifiedSegCount","densifiedSegLen","segFract","densify","densifier","DensifyTransformer","createValidArea","roughGeom","roughAreaGeom","oNext","insertAfter","ePrev","ecmp","save","compareAngularDirection","quadrant2","prevNode","mark","setMark","isMarked","setMarkBoth","markBoth","eAdj","eAdjDest","createEdge","isValidEdge","eSame","getVertexEdges","DissolveHalfEdge","setStart","isStart","DissolveEdgeGraph","LineDissolver","updateRingStartEdge","getResult","computeResult","eNode","stackEdges","buildRing","eStartRing","eNext","buildLine","eStart","doneStart","getNodeCount","visitItems","visit","centrex","centrey","Key$1","computeQuadLevel","quadSize","Node$2","miny","maxy","insertNode","addEnv","expandEnv","Root$1","isZeroX","isZeroY","Quadtree","insertEnv","queryAll","posEnv","delX","delY","GeoJSONParser","parse$1","geometryTypes","extract$2","geoJson","shellGeoJson","holeGeoJson","GeoJSONReader","reducePrecision","GeoJSONWriter","olReference","ol","convertFromPoint","convertFromLineString","convertFromLinearRing","convertFromPolygon","convertFromMultiPoint","convertFromMultiLineString","convertFromMultiPolygon","convertFromCollection","getLinearRings","multiPoint","getPoints","multiLineString","getLineStrings","multiPolygon","getGeometries","convertToPoint","convertToLineString","convertToLinearRing","convertToPolygon","convertToMultiPoint","convertToMultiLineString","convertToMultiPolygon","convertToCollection","p2c","rescale","ss","nodedSegmentStrings","roundPts","splitSS","intSegStrings","IsSimpleOp","isSimpleMultiPoint","mp","isSimplePolygonal","isSimpleLinearGeometry","hasClosedEndpointIntersection","endPoints","eiInfo","getNonSimpleLocation","hasNonEndpointIntersection","computeSimple","isSimpleGeometryCollection","EndpointInfo","getEndCapStyle","isSingleSided","quadSegs","JOIN_BEVEL","JOIN_MITRE","setSimplifyFactor","simplifyFactor","getSimplifyFactor","getMitreLimit","setSingleSided","bufferDistanceError","alpha","CAP_FLAT","CAP_SQUARE","RightmostEdgeFinder","getRightmostSide","getRightmostSideOfSegment","checkForRightmostCoordinate","findRightmostEdgeAtVertex","pNext","pPrev","usePrev","findRightmostEdgeAtNode","star","dirEdgeList","LinkedList","addLast","removeFirst","shift","BufferSubgraph","clearVisitedEdges","getRightmostCoordinate","computeNodeDepth","startEdge","copySymDepths","computeDepth","outsideDepth","addReachable","findResultEdges","nodeQueue","startNode","nodesVisited","adjNode","edgeEnv","nodeStack","symNode","getDirectedEdges","BufferInputLineSimplifier","isDeletable","i0","distanceTol","isConcave","isShallow","isShallowSampled","deleteShallowConcavities","findNextNonDeletedIndex","midIndex","lastIndex","isMiddleVertexDeleted","isShallowConcavity","NUM_PTS_TO_CHECK","collapseLine","INIT","KEEP","OffsetSegmentString","COORDINATE_ARRAY_TYPE","addPt","bufPt","isRedundant","addPts","lastPt","setMinimumVertexDistance","minimimVertexDistance","addNextSegment","addStartPoint","computeOffsetSegment","addCollinear","outsideTurn","addOutsideTurn","addInsideTurn","addLineEndCap","offsetL","offsetR","addFilletArc","squareCapSideOffset","squareCapLOffset","squareCapROffset","addMitreJoin","offset0","offset1","isMitreWithinLimit","addLimitedMitreJoin","addFilletCorner","startAngle","endAngle","OFFSET_SEGMENT_SEPARATION_FACTOR","addBevelJoin","createSquare","addSegments","addFirstSegment","addLastSegment","initSideSegments","ang0","angDiffHalf","midAng","mitreDist","mitreMidAng","mitreMidLine","bevelHalfLen","bevelEndLeft","bevelEndRight","sideSign","totalAngle","nSegs","currAngleInc","currAngle","INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR","createCircle","CURVE_VERTEX_SNAP_DISTANCE_FACTOR","hasNarrowConcaveAngle","OffsetCurveBuilder","getOffsetCurve","getSegGen","posDistance","computePointCurve","segGen","computeOffsetCurve","isRightSide","curvePts","computeSingleSidedBufferCurve","simplifyTolerance","distTol","simp2","simp1","computeRingBufferCurve","simp","computeLineBufferCurve","getLineCurve","getBufferParameters","bufDistance","getRingCurve","copyCoordinates","SubgraphDepthLocater","findStabbedSegments","bsg","stabbingRayLeftPt","stabbedSegments","dirEdge","ds","DepthSegment","orientIndex","compareX","seg0","seg1","compare0","OffsetCurveSetBuilder","addCurve","curve","offsetSide","isErodedCompletely","shellCoord","holeCoord","isTriangleErodedCompletely","triangleCoord","bufferDistance","tri","getCurves","cwLeftLoc","cwRightLoc","ringCoord","envMinDimension","IntersectionAdder","getLineIntersector","hasInteriorIntersection","BufferBuilder","setWorkingPrecisionModel","mergeDelta","newDelta","buildSubgraphs","subgraphList","subgraph","processedGraphs","createSubgraphs","createEmptyResultGeometry","getNoder","bufferSegStrList","computeNodedEdges","oldLabel","setNoder","lLoc","rLoc","convertSegStrings","NodingValidator","checkEndPtVertexIntersections","ss0","pts0","checkCollapses","checkCollapse","HotPixel","intersectsScaled","segMinx","segMaxx","segMiny","segMaxy","isOutsidePixelEnv","intersectsToleranceSquare","copyScaled","pScaled","getSafeEnvelope","SAFE_ENV_EXPANSION_FACTOR","safeTolerance","intersectsPixelClosure","intersectsLeft","intersectsBottom","addSnappedNode","MCIndexPointSnapper","pixelEnv","hotPixelSnapAction","isNodeAdded","HotPixelSnapAction","InteriorIntersectionFinderAdder","getInteriorIntersections","MCIndexSnapRounder","checkCorrectness","inputSegmentStrings","snapRound","findInteriorIntersections","computeIntersectionSnaps","computeVertexSnaps","intFinderAdder","edge0","bufferFixedPrecision","fixedPM","bufBuilder","bufferReducedPrecision","MAX_PRECISION_DIGITS","precDigits","precisionScaleFactor","precisionDigits","bufferOriginalPrecision","argPM","bufOp","maxPrecisionDigits","bufEnvMax","minUnitLog10","CAP_BUTT","PolygonExtracter","isInsideArea","getGeometryComponent","PointExtracter","ConnectedElementLocationFilter","computeContainmentDistance","locPtPoly","polyGeomIndex","locationsIndex","insideLocs","locs","ptLoc","computeMinDistanceLinesPoints","locGeom","computeMinDistance","computeFacetDistance","computeMinDistanceLines","lines0","lines1","updateMinDistance","computeMinDistancePoints","nearestLocations","nearestPoints","coord0","segClosestPoint","line0","points0","points1","isWithinDistance","EdgeString","directedEdge","getEdgeDirection","forwardDirectedEdges","reverseDirectedEdges","coordinateList","getLine","setMarked","setContext","getComponentWithVisitedState","visitedState","visited","marked","isRemoved","getDirectionPt","getAngle","getFromNode","setEdge","getToNode","toEdges","LineMergeDirectedEdge","getOutEdges","addOutEdge","getDirEdge","fromNode","getOppositeNode","DirectedEdgeStar$1","getNextEdge","sortEdges","getNextCWEdge","modi","getEdgesBetween","node0","node1","commonEdges","retainAll","LineMergeEdge","NodeMap$1","findNodesOfDegree","nodeIterator","nodesFound","dirEdgeIterator","edgeIterator","findNode","LineMergeGraph","startCoordinate","endCoordinate","endNode","directedEdge0","directedEdge1","LineMerger","buildEdgeStringsForUnprocessedNodes","buildEdgeStringsStartingAt","buildEdgeStringsForNonDegree2Nodes","buildEdgeStringsForObviousStartNodes","getMergedLineStrings","buildEdgeStringStartingWith","buildEdgeStringsForIsolatedLoops","edgeString","PolygonizeDirectedEdge","isInRing","setRing","getRing","PolygonizeEdge","ConnectedInteriorTester","visitInteriorRing","findDifferentPoint","intDe","visitLinkedDirectedEdges","visitShellInteriors","setInteriorEdgesInResult","startDe","buildEdgeRings","hasUnvisitedShellEdge","isInteriorsConnected","EdgeEndBuilder","createEdgeEndForNext","eiCurr","eiNext","createEdgeEndForPrev","computeEdgeEnds","computeLabelOn","foundInterior","computeLabelSide","computeLabelSides","EdgeEndBundleStar","eb","RelateNode","updateIMFromEdges","RelateNodeFactory","RelateNodeGraph","insertEdgeEnds","copyNodesAndLabels","nodeIt","computeIntersectionNodes","eeList","edgeIt","ConsistentAreaTester","isNodeEdgeAreaLabelsConsistent","hasDuplicateRings","eeb","isNodeConsistentArea","intersector","IndexedNestedRingTester","getNestedPoint","isNonNested","innerRing","searchRing","IsValidOp","findPtNotNode","innerRingPts","innerRingPt","searchRingPts","getErrorType","getMessage","errMsg","locStr","ERROR","REPEATED_POINT","HOLE_OUTSIDE_SHELL","NESTED_HOLES","DISCONNECTED_INTERIOR","SELF_INTERSECTION","RING_SELF_INTERSECTION","NESTED_SHELLS","DUPLICATE_RINGS","TOO_FEW_POINTS","INVALID_COORDINATE","RING_NOT_CLOSED","checkInvalidCoordinates","checkHolesNotNested","nestedTester","innerHole","checkConsistentArea","cat","checkShellInsideHole","shellPts","shellPt","holePts","holePt","checkNoSelfIntersectingRings","checkNoSelfIntersectingRing","checkConnectedInteriors","cit","isFirst","nodeSet","checkHolesInShell","pir","checkTooFewPoints","getValidationError","checkClosedRing","checkClosedRings","checkShellsNotNested","setSelfTouchingRingFormingHoleValid","checkShellNotNested","polyShell","badNestedPt","testCoords","EdgeRing$1","isIncluded","isIncludedSet","startDE","isOuterHole","hasShell","getPolygon","isProcessed","holeER","setIncluded","getOuterHole","adjRing","computeHole","isOuterShell","getLineString","updateIncluded","adjShell","setProcessed","findDirEdgesInRing","tryShellRing","tryShellEnv","minShellEnv","EnvelopeComparator","obj0","obj1","r1","PolygonizeGraph","findEdgeRing","computeDepthParity","computeNextCWEdges","iNode","linePts","endPt","nStart","nEnd","deleteCutEdges","findLabeledEdgeRings","cutLines","getEdgeRings","convertMaximalToMinimalEdgeRings","maximalRings","edgeRingList","ringEdges","findIntersectionNodes","intNodes","computeNextCCWEdges","deleteDangles","nodesToRemove","deleteAllEdges","dangleLines","getDegreeNonDeleted","toNode","edgeRingStarts","currLabel","outDE","prevDE","inDE","prevInDE","firstOutDE","polygonize","getInvalidRingLines","findValidRings","validEdgeRingList","invalidRingList","findShellsAndHoles","assignHolesToShells","findDisjointShells","includeAll","extractPolygons","getDangles","getCutEdges","setCheckRingsValid","isCheckingRingsValid","findOuterShells","outerHoleER","polyList","holeList","assignHoleToShell","isMoreToScan","LineStringAdder","RelateComputer","computeProperIntersectionIM","dimA","dimB","hasProper","hasProperInterior","labelIsolatedEdges","thisIndex","labelIsolatedEdge","computeDisjointIM","labelIsolatedNodes","eeBuilder","ee0","ee1","labelNodeEdges","labelIntersectionNodes","labelIsolatedNode","ga","gb","RectangleContains","isContainedInBoundary","isPointContainedInBoundary","isLineStringContainedInBoundary","isLineSegmentContainedInBoundary","RectangleLineIntersector","segEnv","isSegUpwards","applyTo","RectangleIntersects","ecpVisitor","riVisitor","EnvelopeIntersectsVisitor","elementEnv","GeometryContainsPointVisitor","rectPt","RectangleIntersectsSegmentVisitor","checkIntersectionWithLineStrings","checkIntersectionWithSegments","testLine","seq1","RelateOp","getIntersectionMatrix","relate","touches","within","coveredBy","intersectionPattern","relateWithCheck","relOp","disjoint","crosses","extractElements","elems","elemGeom","combine","createList","obj2","CascadedPolygonUnion","reduceToGeometries","geomTree","unionTree","extractByEnvelope","disjointGeoms","elem","intersectingGeoms","unionOptimized","g0Env","g1Env","unionActual","unionUsingEnvelopeIntersection","commonEnv","STRTREE_NODE_CAPACITY","itemTree","binaryUnion","unionSafe","repeatedUnion","restrictToPolygons","common","disjointPolys","g0Int","g1Int","bufferUnion","gColl","PointGeometryUnion","locater","exteriorCoords","ptComp","GeometryExtracter","UnaryUnionOp","unionNoOpt","unionWithNull","unionPoints","ptGeom","unionLines","lineGeom","unionPolygons","unionLA","UnionInteracting","interacts","isInteracting","extractedGeoms","computeInteracting","elem0","interactsWithAny","int0","int1","disjoint0","disjoint1","PrecisionReducerCoordinateOperation","reducedCoords","minLength","collapsedCoords","noRepeatedCoords","GeometryPrecisionReducer","fixPolygonalTopology","geomToBuffer","changePM","bufGeom","finalGeom","reducePointwise","geomEdit","createFactory","finalRemoveCollapsed","newPM","createEditor","setRemoveCollapsedComponents","inputFactory","setChangePrecisionModel","changePrecisionModel","reducePW","setPointwise","isPointwise","reducer","DouglasPeuckerLineSimplifier","simplifySection","maxDistance","DouglasPeuckerSimplifier","setEnsureValid","tss","DPTransformer","rawGeom","rawAreaGeom","removeDegenerateRings","simpResult","getParent","addToResult","asLineString","getResultSize","resultSegsSize","getSegment","getParentCoordinates","getMinimumSize","asLinearRing","getSegments","getResultCoordinates","LineSegmentIndex","LineSegmentVisitor","TaggedLineStringSimplifier","flatten","newSeg","hasBadIntersection","sectionIndex","candidateSeg","hasBadOutputIntersection","hasBadInputIntersection","isValidToSimplify","findFurthestPoint","furthestPtIndex","midPt","maxDist","isInLineSection","TaggedLinesSimplifier","taggedLines","tlss","TopologyPreservingSimplifier","LineStringTransformer","taggedLine","LineStringMapBuilderFilter","SplitSegment","splitAt","minFrac","pointAlongReverse","getConstrainedLength","setMinimumLength","minLen","getSplitPoint","ConstraintSplitPointFinder","findSplitPoint","encroachPt","NonEncroachingSplitPointFinder","lineSeg","projectedSplitPoint","projPt","maxSplitLen","midPtLen","splitSeg","TrianglePredicate","triArea","isInCircleDDNormalized","bdy","bdx","cdy","cdx","alift","bcdet","blift","cadet","clift","abdet","checkRobustInCircle","isInCircleNonRobust","isInCircleDDSlow","isInCircleCC","circumCentre","nonRobustInCircle","isInCircleDD","toPoint","isInCircleDDFast","triAreaDDFast","aTerm","bTerm","cTerm","pTerm","cc","ccRadius","isInCircleNormalized","triAreaDDSlow","isInCircleRobust","t2","circleCenter","hcc","nre","err","dot","magn","getZ","isInCircle","interpolateZValue","crossProduct","setZ","times","cross","classify","sa","BEHIND","BEYOND","ORIGIN","DESTINATION","BETWEEN","circumRadiusRatio","el","edgeLength","ptLen","ConstraintVertex","getConstraint","setOnConstraint","isOnConstraint","setConstraint","constraint","QuadEdge","equalsNonOriented","qe","equalsOriented","toLineSegment","dNext","lPrev","rPrev","rot","oPrev","setOrig","lNext","invRot","setDest","rNext","isLive","getPrimary","dPrev","makeEdge","q0","q3","beta","t1","t3","t4","connect","IncrementalDelaunayTriangulator","insertSite","isVertexOfEdge","isOnEdge","insertSites","QuadEdgeLocator","LastFoundQuadEdgeLocator","locateFromEdge","TriangleVisitor","triEdges","getTriangleVertices","includeFrame","visitTriangles","isFrameVertex","getVoronoiCellPolygon","cellPts","startQE","cellPoly","setLocator","locator","ea","ec","isFrameBorderEdge","getTriangleEdges","leftTri","rightTri","vLeftTriOther","vRightTriOther","triVisitor","edgeStack","visitedEdges","fetchTriangleToVisit","isFrameEdge","getTriangleCoordinates","getTriangles","getVertices","vd","edgeCount","curr","isFrame","getPrimaryEdges","quadEdges","getVertexUniqueEdges","visitedVertices","qd","priQE","eSym","eRot","eRotSym","iter","maxIter","getVoronoiCellPolygons","cells","getVoronoiDiagram","vorCells","triPtsList","tris","triPt","locEdge","triEdge","TriangleCircumcentreVisitor","ccVertex","TriangleEdgesListVisitor","TriangleVertexListVisitor","TriangleCoordinatesVisitor","checkTriangleSize","getEndZ","getStartZ","getStart","getEnd","getEndY","getStartX","getStartY","getEndX","KdNodeVisitor","KdNode","isRepeated","getRight","setLeft","getCount","getLeft","increment","setRight","findBestMatchNode","matchNode","insertExact","queryEnv","queryNode","currentNode","odd","discriminant","searchRight","queryEnvelope","leafNode","isLessThan","isOddLevel","toCoordinates","kdnodes","includeRepeated","BestMatchVisitor","update","ConformingDelaunayTriangulator","getInitialVertices","getKDT","enforceConstraints","addConstraintVertices","splits","enforceGabriel","MAX_SPLIT_ITER","getVertexFactory","getPointArray","setConstraints","segVertices","computeConvexHull","hull","findNonGabrielPoint","segRadius","testRadius","closestNonGabriel","getConstraintSegments","setSplitPointFinder","splitFinder","segsToInsert","createVertex","splitVertex","newSegments","segsToRemove","removeAll","getSubdivision","computeBoundingBox","computeVertexEnvelope","vertexEnv","allPointsEnv","setVertexFactory","vertexFactory","formInitialDelaunay","kdnode","snappedV","DelaunayTriangulationBuilder","toVertices","siteEnv","setTolerance","setSites","extractUniqueCoordinates","coordsCopy","ConformingDelaunayTriangulationBuilder","createSiteVertices","containsKey","createVertices","createConstraintSegments","cdt","constraintLines","constraintSegs","VoronoiDiagramBuilder","getDiagram","clipGeometryCollection","setClipEnvelope","clipEnv","clipPoly","clipped","isEndpoint","nseg","lineComp","toLowest","pointAlongSegmentByFraction","getSegmentFraction","setToEnd","isOnSameSegment","snapToVertex","getSegmentLength","lenToStart","lenToEnd","compareLocationValues","componentIndex1","segmentIndex1","segmentFraction1","isVertex","getEndLocation","componentIndex0","segmentIndex0","segmentFraction0","getVertexIndex","getSegmentEnd","getSegmentStart","isEndOfLine","LocationIndexOfPoint","indexOfFromStart","minIndex","segDistance","candidateComponentIndex","candidateSegmentIndex","minComponentIndex","minSegmentIndex","indexOfAfter","endLoc","closestAfter","LocationIndexOfLine","indicesOf","subLine","subLineLoc","locPt","LinearGeometryBuilder","endLine","getLastCoordinate","rawPts","validCoordinateSequence","setFixInvalidLines","fixInvalidLines","allowRepeatedPoints","setIgnoreInvalidLines","ignoreInvalidLines","ExtractLineByLocation","computeLinear","builder","computeLine","startSegmentIndex","lastSegmentIndex","newCoordinateArray","LocationIndexedLine","clampIndex","extractPoint","indexLow","isValidIndex","LengthIndexOfPoint","segmentNearestMeasure","segmentStartMeasure","segMeasureToPt","ptMeasure","projFactor","LengthLocationMap","totalLength","resolveHigher","compIndex","resolveLower","forwardLength","getLocationForward","LengthIndexedLine","positiveIndex","locationOf","locLow","startIndex2","endIndex2","resolveStartLower","Adder","_add","streamGeometry","Sphere","sphere","streamPolygon","streamObjectType","forward","noop","t0","pointEqual","subject","link","isSubject","ascendingComparator","ascending","arrays","x0$2","y0$2","pointVisible","sink","pointLine","ringSink","pointRing","ringSegments","ringBuffer","polygonStarted","validSegment","rotatedStart","normal","sum$1","point0","lambda0","phi0","quarterPi","sinPhi0","cosPhi0","lambda1","sinPhi1","cosPhi1","point1","phi1","absDelta","antimeridian","cartesianCross","phiArc","polygonContains","_clean","sign0","sign1","sinLambda0Lambda1","clipAntimeridianIntersect","cr","two","n2n2","cartesianDot","n1n2","determinant","n1xn2","cartesianScale","cartesianAddInPlace","uu","polar","smallRadius","code","notHemisphere","c0","v00","point2","sinRadius","step","circleRadius","circleStream","TransformStream","phi2","lambda2","cosMinDistance","resampleLineTo","resampleStream","maxDepth","ringPoint","lambda00","x00","y00","a00","b00","c00","resample$1","resampleNone","transformer","mercatorRaw","transverseMercatorRaw","reclip","mercatorProjection","rbush","_all","childBBox","contains$1","nodesToSearch","_build","_splitRoot","tmpNode","_insert","equalsFn","goingUp","findItem","_condense","compareMinX","compareNodeMinX","compareMinY","compareNodeMinY","N","calcBBox","right2","right3","N1","N2","multiSelect","_chooseSubtree","targetNode","enlargement","minArea","minEnlargement","bboxArea","enlargedArea","isNode","insertPath","_split","_adjustParentBBoxes","_chooseSplitAxis","_chooseSplitIndex","splitIndex","newNode","bbox1","bbox2","minOverlap","intersectionArea","_allDistMargin","leftBBox","rightBBox","margin","bboxMargin","siblings","compareArr","filterFn","useSpatialIndex","ring0","edge1","isect","frac0","frac1","allEdgesAsRbushTreeItems","rbushTreeItem","rbush_1","ringA","edgeA","bboxIsect","ifIsectAddToOutput","featuresWithoutParent","area$1","netWinding","setNetWindingOfChildren","ParentNetWinding","numRings","isUnique","isects","selfIsectsData","numSelfIsect","outputFeatureArray","leftVtx","modulo","windingOfRing","determineParents","setNetWinding","pseudoVtxListByRingAndEdge","isectList","param","numIsect","allIsectsAsIsectRbushTreeItem","isectRbushTree","coordToFind","nxtIsectAlongEdgeIn","IsectRbushTreeItemFound","numvertices","nxtIsectAlongRingAndEdge2","ringAndEdge1","ringAndEdgeIn","nxtIsectAlongRingAndEdge1","leftIsect","isectBeforeLeftIsect","isectAfterLeftIsect","queue","windingAtIsect","popped","startIsect","ringAndEdge1Walkable","ringAndEdge2","nxtIsect","currentOutputRingCoords","nxtIsectInQueue","walkingRingAndEdge","ringAndEdge2Walkable","currentIsect","currentOutputRingWinding","pushing","currentOutputRingParent","currentOutputRing","ringAndEdgeOut","intersects$2","contains$2","findItem$1","compareNodeMinX$1","compareNodeMinY$1","calcBBox$1","multiSelect$1","bboxArea$1","enlargedArea$1","intersectionArea$1","bboxMargin$1","along","createbuffer","pointInPolygon","polylineToFeatureLinestring","simplifyFeature","simplifyPointArray","trimPaths","kinks","unkink","concave","ig_turfhelper"],"mappings":"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"}