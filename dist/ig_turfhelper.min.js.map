{"version":3,"file":"ig_turfhelper.min.js","sources":["ig_turfhelper.js"],"sourcesContent":["\n/*\n * turf-google-maps\n * version 0.9.2\n * MIT Licensed\n * Felipe Figueroa (amenadiel@gmail.com)\n * https://github.com/HuasoFoundries/turf-google-maps\n */\n \n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.turfHelper = {})));\n}(this, (function (exports) { 'use strict';\n\n  var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  };\n\n  /** @license\n   *\n   *  Copyright (C) 2012 K. Arthur Endsley (kaendsle@mtu.edu)\n   *  Michigan Tech Research Institute (MTRI)\n   *  3600 Green Court, Suite 100, Ann Arbor, MI, 48105\n   *\n   *  This program is free software: you can redistribute it and/or modify\n   *  it under the terms of the GNU General Public License as published by\n   *  the Free Software Foundation, either version 3 of the License, or\n   *  (at your option) any later version.\n   *\n   *  This program is distributed in the hope that it will be useful,\n   *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n   *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   *  GNU General Public License for more details.\n   *\n   *  You should have received a copy of the GNU General Public License\n   *  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n   *\n   */\n  var beginsWith, endsWith;\n  var Wkt = function Wkt(obj) {\n      if (obj instanceof Wkt) return obj;\n      if (!(this instanceof Wkt)) return new Wkt(obj);\n      this._wrapped = obj;\n  };\n  beginsWith = function beginsWith(str, sub) {\n      return str.substring(0, sub.length) === sub;\n  };\n  endsWith = function endsWith(str, sub) {\n      return str.substring(str.length - sub.length) === sub;\n  };\n  Wkt.delimiter = ' ';\n  Wkt.isArray = function (obj) {\n      return !!(obj && obj.constructor === Array);\n  };\n  Wkt.trim = function (str, sub) {\n      sub = sub || ' ';\n      while (beginsWith(str, sub)) {\n          str = str.substring(1);\n      }\n      while (endsWith(str, sub)) {\n          str = str.substring(0, str.length - 1);\n      }\n      return str;\n  };\n  Wkt.Wkt = function (initializer) {\n      this.delimiter = Wkt.delimiter || ' ';\n      this.wrapVertices = true;\n      this.regExes = {\n          'typeStr': /^\\s*(\\w+)\\s*\\(\\s*(.*)\\s*\\)\\s*$/,\n          'spaces': /\\s+|\\+/,\n          'numeric': /-*\\d+(\\.*\\d+)?/,\n          'comma': /\\s*,\\s*/,\n          'parenComma': /\\)\\s*,\\s*\\(/,\n          'coord': /-*\\d+\\.*\\d+ -*\\d+\\.*\\d+/,\n          'doubleParenComma': /\\)\\s*\\)\\s*,\\s*\\(\\s*\\(/,\n          'trimParens': /^\\s*\\(?(.*?)\\)?\\s*$/,\n          'ogcTypes': /^(multi)?(point|line|polygon|box)?(string)?$/i,\n          'crudeJson': /^{.*\"(type|coordinates|geometries|features)\":.*}$/\n      };\n      this.components = undefined;\n      if (initializer && typeof initializer === 'string') {\n          this.read(initializer);\n      } else if (initializer && (typeof initializer === 'undefined' ? 'undefined' : _typeof(initializer)) !== undefined) {\n          this.fromObject(initializer);\n      }\n  };\n  Wkt.Wkt.prototype.isCollection = function () {\n      switch (this.type.slice(0, 5)) {\n          case 'multi':\n              return true;\n          case 'polyg':\n              return true;\n          default:\n              return false;\n      }\n  };\n  Wkt.Wkt.prototype.sameCoords = function (a, b) {\n      return a.x === b.x && a.y === b.y;\n  };\n  Wkt.Wkt.prototype.fromObject = function (obj) {\n      var result;\n      if (obj.hasOwnProperty('type') && obj.hasOwnProperty('coordinates')) {\n          result = this.fromJson(obj);\n      } else {\n          result = this.deconstruct.call(this, obj);\n      }\n      this.components = result.components;\n      this.isRectangle = result.isRectangle || false;\n      this.type = result.type;\n      return this;\n  };\n  Wkt.Wkt.prototype.toObject = function (config) {\n      var obj = this.construct[this.type].call(this, config);\n      if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && !Wkt.isArray(obj)) {\n          obj.properties = this.properties;\n      }\n      return obj;\n  };\n  Wkt.Wkt.prototype.toString = function (config) {\n      return this.write();\n  };\n  Wkt.Wkt.prototype.fromJson = function (obj) {\n      var i, j, k, coords, iring, oring;\n      this.type = obj.type.toLowerCase();\n      this.components = [];\n      if (obj.hasOwnProperty('geometry')) {\n          this.fromJson(obj.geometry);\n          this.properties = obj.properties;\n          return this;\n      }\n      coords = obj.coordinates;\n      if (!Wkt.isArray(coords[0])) {\n          this.components.push({\n              x: coords[0],\n              y: coords[1]\n          });\n      } else {\n          for (i in coords) {\n              if (coords.hasOwnProperty(i)) {\n                  if (!Wkt.isArray(coords[i][0])) {\n                      if (this.type === 'multipoint') {\n                          this.components.push([{\n                              x: coords[i][0],\n                              y: coords[i][1]\n                          }]);\n                      } else {\n                          this.components.push({\n                              x: coords[i][0],\n                              y: coords[i][1]\n                          });\n                      }\n                  } else {\n                      oring = [];\n                      for (j in coords[i]) {\n                          if (coords[i].hasOwnProperty(j)) {\n                              if (!Wkt.isArray(coords[i][j][0])) {\n                                  oring.push({\n                                      x: coords[i][j][0],\n                                      y: coords[i][j][1]\n                                  });\n                              } else {\n                                  iring = [];\n                                  for (k in coords[i][j]) {\n                                      if (coords[i][j].hasOwnProperty(k)) {\n                                          iring.push({\n                                              x: coords[i][j][k][0],\n                                              y: coords[i][j][k][1]\n                                          });\n                                      }\n                                  }\n                                  oring.push(iring);\n                              }\n                          }\n                      }\n                      this.components.push(oring);\n                  }\n              }\n          }\n      }\n      return this;\n  };\n  Wkt.Wkt.prototype.toJson = function () {\n      var cs, json, i, j, k, ring, rings;\n      cs = this.components;\n      json = {\n          coordinates: [],\n          type: function () {\n              var i, type, s;\n              type = this.regExes.ogcTypes.exec(this.type).slice(1);\n              s = [];\n              for (i in type) {\n                  if (type.hasOwnProperty(i)) {\n                      if (type[i] !== undefined) {\n                          s.push(type[i].toLowerCase().slice(0, 1).toUpperCase() + type[i].toLowerCase().slice(1));\n                      }\n                  }\n              }\n              return s;\n          }.call(this).join('')\n      };if (this.type.toLowerCase() === 'box') {\n          json.type = 'Polygon';\n          json.bbox = [];\n          for (i in cs) {\n              if (cs.hasOwnProperty(i)) {\n                  json.bbox = json.bbox.concat([cs[i].x, cs[i].y]);\n              }\n          }\n          json.coordinates = [[[cs[0].x, cs[0].y], [cs[0].x, cs[1].y], [cs[1].x, cs[1].y], [cs[1].x, cs[0].y], [cs[0].x, cs[0].y]]];\n          return json;\n      }\n      for (i in cs) {\n          if (cs.hasOwnProperty(i)) {\n              if (Wkt.isArray(cs[i])) {\n                  rings = [];\n                  for (j in cs[i]) {\n                      if (cs[i].hasOwnProperty(j)) {\n                          if (Wkt.isArray(cs[i][j])) {\n                              ring = [];\n                              for (k in cs[i][j]) {\n                                  if (cs[i][j].hasOwnProperty(k)) {\n                                      ring.push([cs[i][j][k].x, cs[i][j][k].y]);\n                                  }\n                              }\n                              rings.push(ring);\n                          } else {\n                              if (cs[i].length > 1) {\n                                  rings.push([cs[i][j].x, cs[i][j].y]);\n                              } else {\n                                  rings = rings.concat([cs[i][j].x, cs[i][j].y]);\n                              }\n                          }\n                      }\n                  }\n                  json.coordinates.push(rings);\n              } else {\n                  if (cs.length > 1) {\n                      json.coordinates.push([cs[i].x, cs[i].y]);\n                  } else {\n                      json.coordinates = json.coordinates.concat([cs[i].x, cs[i].y]);\n                  }\n              }\n          }\n      }\n      return json;\n  };\n  Wkt.Wkt.prototype.merge = function (wkt) {\n      var prefix = this.type.slice(0, 5);\n      if (this.type !== wkt.type) {\n          if (this.type.slice(5, this.type.length) !== wkt.type) {\n              throw TypeError('The input geometry types must agree or the calling Wkt.Wkt instance must be a multigeometry of the other');\n          }\n      }\n      switch (prefix) {\n          case 'point':\n              this.components = [this.components.concat(wkt.components)];\n              break;\n          case 'multi':\n              this.components = this.components.concat(wkt.type.slice(0, 5) === 'multi' ? wkt.components : [wkt.components]);\n              break;\n          default:\n              this.components = [this.components, wkt.components];\n              break;\n      }\n      if (prefix !== 'multi') {\n          this.type = 'multi' + this.type;\n      }\n      return this;\n  };\n  Wkt.Wkt.prototype.read = function (str) {\n      var matches;\n      matches = this.regExes.typeStr.exec(str);\n      if (matches) {\n          this.type = matches[1].toLowerCase();\n          this.base = matches[2];\n          if (this.ingest[this.type]) {\n              this.components = this.ingest[this.type].apply(this, [this.base]);\n          }\n      } else {\n          if (this.regExes.crudeJson.test(str)) {\n              if ((typeof JSON === 'undefined' ? 'undefined' : _typeof(JSON)) === 'object' && typeof JSON.parse === 'function') {\n                  this.fromJson(JSON.parse(str));\n              } else {\n                  console.log('JSON.parse() is not available; cannot parse GeoJSON strings');\n                  throw {\n                      name: 'JSONError',\n                      message: 'JSON.parse() is not available; cannot parse GeoJSON strings'\n                  };\n              }\n          } else {\n              console.log('Invalid WKT string provided to read() ', str);\n              throw {\n                  name: 'WKTError',\n                  message: 'Invalid WKT string provided to read()'\n              };\n          }\n      }\n      return this;\n  };\n  Wkt.Wkt.prototype.write = function (components) {\n      var i, pieces, data;\n      components = components || this.components;\n      pieces = [];\n      pieces.push(this.type.toUpperCase() + '(');\n      for (i = 0; i < components.length; i += 1) {\n          if (this.isCollection() && i > 0) {\n              pieces.push(',');\n          }\n          if (!this.extract[this.type]) {\n              return null;\n          }\n          data = this.extract[this.type].apply(this, [components[i]]);\n          if (this.isCollection() && this.type !== 'multipoint') {\n              pieces.push('(' + data + ')');\n          } else {\n              pieces.push(data);\n              if (i !== components.length - 1 && this.type !== 'multipoint') {\n                  pieces.push(',');\n              }\n          }\n      }\n      pieces.push(')');\n      return pieces.join('');\n  };\n  Wkt.Wkt.prototype.extract = {\n      point: function point(_point) {\n          return String(_point.x) + this.delimiter + String(_point.y);\n      },\n      multipoint: function multipoint(_multipoint) {\n          var i,\n              parts = [],\n              s;\n          for (i = 0; i < _multipoint.length; i += 1) {\n              s = this.extract.point.apply(this, [_multipoint[i]]);\n              if (this.wrapVertices) {\n                  s = '(' + s + ')';\n              }\n              parts.push(s);\n          }\n          return parts.join(',');\n      },\n      linestring: function linestring(_linestring) {\n          return this.extract.point.apply(this, [_linestring]);\n      },\n      multilinestring: function multilinestring(_multilinestring) {\n          var i,\n              parts = [];\n          if (_multilinestring.length) {\n              for (i = 0; i < _multilinestring.length; i += 1) {\n                  parts.push(this.extract.linestring.apply(this, [_multilinestring[i]]));\n              }\n          } else {\n              parts.push(this.extract.point.apply(this, [_multilinestring]));\n          }\n          return parts.join(',');\n      },\n      polygon: function polygon(_polygon) {\n          return this.extract.multilinestring.apply(this, [_polygon]);\n      },\n      multipolygon: function multipolygon(_multipolygon) {\n          var i,\n              parts = [];\n          for (i = 0; i < _multipolygon.length; i += 1) {\n              parts.push('(' + this.extract.polygon.apply(this, [_multipolygon[i]]) + ')');\n          }\n          return parts.join(',');\n      },\n      box: function box(_box) {\n          return this.extract.linestring.apply(this, [_box]);\n      },\n      geometrycollection: function geometrycollection(str) {\n          console.log('The geometrycollection WKT type is not yet supported.');\n      }\n  };\n  Wkt.Wkt.prototype.ingest = {\n      point: function point(str) {\n          var coords = Wkt.trim(str).split(this.regExes.spaces);\n          return [{\n              x: parseFloat(this.regExes.numeric.exec(coords[0])[0]),\n              y: parseFloat(this.regExes.numeric.exec(coords[1])[0])\n          }];\n      },\n      multipoint: function multipoint(str) {\n          var i, components, points;\n          components = [];\n          points = Wkt.trim(str).split(this.regExes.comma);\n          for (i = 0; i < points.length; i += 1) {\n              components.push(this.ingest.point.apply(this, [points[i]]));\n          }\n          return components;\n      },\n      linestring: function linestring(str) {\n          var i, multipoints, components;\n          multipoints = this.ingest.multipoint.apply(this, [str]);\n          components = [];\n          for (i = 0; i < multipoints.length; i += 1) {\n              components = components.concat(multipoints[i]);\n          }\n          return components;\n      },\n      multilinestring: function multilinestring(str) {\n          var i, components, line, lines;\n          components = [];\n          lines = Wkt.trim(str).split(this.regExes.doubleParenComma);\n          if (lines.length === 1) {\n              lines = Wkt.trim(str).split(this.regExes.parenComma);\n          }\n          for (i = 0; i < lines.length; i += 1) {\n              line = lines[i].replace(this.regExes.trimParens, '$1');\n              components.push(this.ingest.linestring.apply(this, [line]));\n          }\n          return components;\n      },\n      polygon: function polygon(str) {\n          var i, j, components, subcomponents, ring, rings;\n          rings = Wkt.trim(str).split(this.regExes.parenComma);\n          components = [];\n          for (i = 0; i < rings.length; i += 1) {\n              ring = rings[i].replace(this.regExes.trimParens, '$1').split(this.regExes.comma);\n              subcomponents = [];\n              for (j = 0; j < ring.length; j += 1) {\n                  var split = ring[j].split(this.regExes.spaces);\n                  if (split.length > 2) {\n                      split = split.filter(function (n) {\n                          return n != \"\";\n                      });\n                  }\n                  if (split.length === 2) {\n                      var x_cord = split[0];\n                      var y_cord = split[1];\n                      subcomponents.push({\n                          x: parseFloat(x_cord),\n                          y: parseFloat(y_cord)\n                      });\n                  }\n              }\n              components.push(subcomponents);\n          }\n          return components;\n      },\n      box: function box(str) {\n          var i, multipoints, components;\n          multipoints = this.ingest.multipoint.apply(this, [str]);\n          components = [];\n          for (i = 0; i < multipoints.length; i += 1) {\n              components = components.concat(multipoints[i]);\n          }\n          return components;\n      },\n      multipolygon: function multipolygon(str) {\n          var i, components, polygon, polygons;\n          components = [];\n          polygons = Wkt.trim(str).split(this.regExes.doubleParenComma);\n          for (i = 0; i < polygons.length; i += 1) {\n              polygon = polygons[i].replace(this.regExes.trimParens, '$1');\n              components.push(this.ingest.polygon.apply(this, [polygon]));\n          }\n          return components;\n      },\n      geometrycollection: function geometrycollection(str) {\n          console.log('The geometrycollection WKT type is not yet supported.');\n      }\n  };\n  Wkt.Wkt.prototype.isRectangle = false;\n  Wkt.Wkt.prototype.construct = {\n      point: function point(config, component) {\n          var c = component || this.components;\n          config = config || {\n              optimized: true\n          };\n          config.position = new google.maps.LatLng(c[0].y, c[0].x);\n          return new google.maps.Marker(config);\n      },\n      multipoint: function multipoint(config) {\n          var i, c, arr;\n          c = this.components;\n          config = config || {};\n          arr = [];\n          for (i = 0; i < c.length; i += 1) {\n              arr.push(this.construct.point(config, c[i]));\n          }\n          return arr;\n      },\n      linestring: function linestring(config, component) {\n          var i, c;\n          c = component || this.components;\n          config = config || {\n              editable: false\n          };\n          config.path = [];\n          for (i = 0; i < c.length; i += 1) {\n              config.path.push(new google.maps.LatLng(c[i].y, c[i].x));\n          }\n          return new google.maps.Polyline(config);\n      },\n      multilinestring: function multilinestring(config) {\n          var i, c, arr;\n          c = this.components;\n          config = config || {\n              editable: false\n          };\n          config.path = [];\n          arr = [];\n          for (i = 0; i < c.length; i += 1) {\n              arr.push(this.construct.linestring(config, c[i]));\n          }\n          return arr;\n      },\n      box: function box(config, component) {\n          var c = component || this.components;\n          config = config || {};\n          config.bounds = new google.maps.LatLngBounds(new google.maps.LatLng(c[0].y, c[0].x), new google.maps.LatLng(c[1].y, c[1].x));\n          return new google.maps.Rectangle(config);\n      },\n      polygon: function polygon(config, component) {\n          var j, k, c, rings, verts;\n          c = component || this.components;\n          config = config || {\n              editable: false\n          };\n          config.paths = [];\n          rings = [];\n          for (j = 0; j < c.length; j += 1) {\n              verts = [];\n              for (k = 0; k < c[j].length - 1; k += 1) {\n                  verts.push(new google.maps.LatLng(c[j][k].y, c[j][k].x));\n              }\n              if (j !== 0) {\n                  if (config.reverseInnerPolygons === null || config.reverseInnerPolygons) {\n                      verts.reverse();\n                  }\n              }\n              rings.push(verts);\n          }\n          config.paths = config.paths.concat(rings);\n          if (this.isRectangle) {\n              return function () {\n                  var bounds, v;\n                  bounds = new google.maps.LatLngBounds();\n                  for (v in rings[0]) {\n                      if (rings[0].hasOwnProperty(v)) {\n                          bounds.extend(rings[0][v]);\n                      }\n                  }\n                  return new google.maps.Rectangle({\n                      bounds: bounds\n                  });\n              }();\n          } else {\n              return new google.maps.Polygon(config);\n          }\n      },\n      multipolygon: function multipolygon(config) {\n          var i, c, arr;\n          c = this.components;\n          config = config || {\n              editable: false\n          };\n          config.path = [];\n          arr = [];\n          for (i = 0; i < c.length; i += 1) {\n              arr.push(this.construct.polygon(config, c[i]));\n          }\n          return arr;\n      }\n  };\n  Wkt.Wkt.prototype.deconstruct = function (obj, multiFlag) {\n      var features, i, j, verts, rings, sign, tmp, response, lat, lng, vertex, ring;\n      var polygons, polygon, k, linestring, linestrings;\n      if (google.maps.geometry) {\n          sign = google.maps.geometry.spherical.computeSignedArea;\n      }\n      if (obj.constructor === google.maps.LatLng) {\n          response = {\n              type: 'point',\n              components: [{\n                  x: obj.lng(),\n                  y: obj.lat()\n              }]\n          };\n          return response;\n      }\n      if (obj.constructor === google.maps.Point) {\n          response = {\n              type: 'point',\n              components: [{\n                  x: obj.x,\n                  y: obj.y\n              }]\n          };\n          return response;\n      }\n      if (obj.constructor === google.maps.Marker) {\n          response = {\n              type: 'point',\n              components: [{\n                  x: obj.getPosition().lng(),\n                  y: obj.getPosition().lat()\n              }]\n          };\n          return response;\n      }\n      if (obj.constructor === google.maps.Polyline) {\n          verts = [];\n          for (i = 0; i < obj.getPath().length; i += 1) {\n              tmp = obj.getPath().getAt(i);\n              verts.push({\n                  x: tmp.lng(),\n                  y: tmp.lat()\n              });\n          }\n          response = {\n              type: 'linestring',\n              components: verts\n          };\n          return response;\n      }\n      if (obj.constructor === google.maps.Polygon) {\n          rings = [];\n          if (multiFlag === undefined) {\n              multiFlag = function () {\n                  var areas, l;\n                  l = obj.getPaths().length;\n                  if (l <= 1) {\n                      return false;\n                  }\n                  if (l === 2) {\n                      if (sign(obj.getPaths().getAt(0)) * sign(obj.getPaths().getAt(1)) < 0) {\n                          return false;\n                      }\n                      return true;\n                  }\n                  areas = obj.getPaths().getArray().map(function (k) {\n                      return sign(k) / Math.abs(sign(k));\n                  });\n                  if (areas.indexOf(areas[0]) !== areas.lastIndexOf(areas[0])) {\n                      multiFlag = true;\n                      return true;\n                  }\n                  return false;\n              }();\n          }\n          for (i = 0; i < obj.getPaths().length; i += 1) {\n              tmp = obj.getPaths().getAt(i);\n              verts = [];\n              for (j = 0; j < obj.getPaths().getAt(i).length; j += 1) {\n                  verts.push({\n                      x: tmp.getAt(j).lng(),\n                      y: tmp.getAt(j).lat()\n                  });\n              }\n              if (!tmp.getAt(tmp.length - 1).equals(tmp.getAt(0))) {\n                  if (i % 2 !== 0) {\n                      verts.unshift({\n                          x: tmp.getAt(tmp.length - 1).lng(),\n                          y: tmp.getAt(tmp.length - 1).lat()\n                      });\n                  } else {\n                      verts.push({\n                          x: tmp.getAt(0).lng(),\n                          y: tmp.getAt(0).lat()\n                      });\n                  }\n              }\n              if (obj.getPaths().length > 1 && i > 0) {\n                  if (sign(obj.getPaths().getAt(i)) > 0 && sign(obj.getPaths().getAt(i - 1)) > 0 || sign(obj.getPaths().getAt(i)) < 0 && sign(obj.getPaths().getAt(i - 1)) < 0 && !multiFlag) {\n                      verts = [verts];\n                  }\n              }\n              if (i % 2 !== 0) {\n                  verts.reverse();\n              }\n              rings.push(verts);\n          }\n          response = {\n              type: multiFlag ? 'multipolygon' : 'polygon',\n              components: rings\n          };\n          return response;\n      }\n      if (obj.constructor === google.maps.Circle) {\n          var point = obj.getCenter();\n          var radius = obj.getRadius();\n          verts = [];\n          var d2r = Math.PI / 180;\n          var r2d = 180 / Math.PI;\n          radius = radius / 1609;\n          var earthsradius = 3963;\n          var num_seg = 32;\n          var rlat = radius / earthsradius * r2d;\n          var rlng = rlat / Math.cos(point.lat() * d2r);\n          for (var n = 0; n <= num_seg; n++) {\n              var theta = Math.PI * (n / (num_seg / 2));\n              lng = point.lng() + rlng * Math.cos(theta);\n              lat = point.lat() + rlat * Math.sin(theta);\n              verts.push({\n                  x: lng,\n                  y: lat\n              });\n          }\n          response = {\n              type: 'polygon',\n              components: [verts]\n          };\n          return response;\n      }\n      if (obj.constructor === google.maps.LatLngBounds) {\n          tmp = obj;\n          verts = [];\n          verts.push({\n              x: tmp.getSouthWest().lng(),\n              y: tmp.getNorthEast().lat()\n          });\n          verts.push({\n              x: tmp.getNorthEast().lng(),\n              y: tmp.getNorthEast().lat()\n          });\n          verts.push({\n              x: tmp.getNorthEast().lng(),\n              y: tmp.getSouthWest().lat()\n          });\n          verts.push({\n              x: tmp.getSouthWest().lng(),\n              y: tmp.getSouthWest().lat()\n          });\n          verts.push({\n              x: tmp.getSouthWest().lng(),\n              y: tmp.getNorthEast().lat()\n          });\n          response = {\n              type: 'polygon',\n              isRectangle: true,\n              components: [verts]\n          };\n          return response;\n      }\n      if (obj.constructor === google.maps.Rectangle) {\n          tmp = obj.getBounds();\n          verts = [];\n          verts.push({\n              x: tmp.getSouthWest().lng(),\n              y: tmp.getNorthEast().lat()\n          });\n          verts.push({\n              x: tmp.getNorthEast().lng(),\n              y: tmp.getNorthEast().lat()\n          });\n          verts.push({\n              x: tmp.getNorthEast().lng(),\n              y: tmp.getSouthWest().lat()\n          });\n          verts.push({\n              x: tmp.getSouthWest().lng(),\n              y: tmp.getSouthWest().lat()\n          });\n          verts.push({\n              x: tmp.getSouthWest().lng(),\n              y: tmp.getNorthEast().lat()\n          });\n          response = {\n              type: 'polygon',\n              isRectangle: true,\n              components: [verts]\n          };\n          return response;\n      }\n      if (obj.constructor === google.maps.Data.Feature) {\n          return this.deconstruct.call(this, obj.getGeometry());\n      }\n      if (obj.constructor === google.maps.Data.Point) {\n          response = {\n              type: 'point',\n              components: [{\n                  x: obj.get().lng(),\n                  y: obj.get().lat()\n              }]\n          };\n          return response;\n      }\n      if (obj.constructor === google.maps.Data.LineString) {\n          verts = [];\n          for (i = 0; i < obj.getLength(); i += 1) {\n              vertex = obj.getAt(i);\n              verts.push({\n                  x: vertex.lng(),\n                  y: vertex.lat()\n              });\n          }\n          response = {\n              type: 'linestring',\n              components: verts\n          };\n          return response;\n      }\n      if (obj.constructor === google.maps.Data.Polygon) {\n          rings = [];\n          for (i = 0; i < obj.getLength(); i += 1) {\n              ring = obj.getAt(i);\n              verts = [];\n              for (j = 0; j < ring.getLength(); j += 1) {\n                  vertex = ring.getAt(j);\n                  verts.push({\n                      x: vertex.lng(),\n                      y: vertex.lat()\n                  });\n              }\n              verts.push({\n                  x: ring.getAt(0).lng(),\n                  y: ring.getAt(0).lat()\n              });\n              rings.push(verts);\n          }\n          response = {\n              type: 'polygon',\n              components: rings\n          };\n          return response;\n      }\n      if (obj.constructor === google.maps.Data.MultiPoint) {\n          verts = [];\n          for (i = 0; i < obj.getLength(); i += 1) {\n              vertex = obj.getAt(i);\n              verts.push([{\n                  x: vertex.lng(),\n                  y: vertex.lat()\n              }]);\n          }\n          response = {\n              type: 'multipoint',\n              components: verts\n          };\n          return response;\n      }\n      if (obj.constructor === google.maps.Data.MultiLineString) {\n          linestrings = [];\n          for (i = 0; i < obj.getLength(); i += 1) {\n              verts = [];\n              linestring = obj.getAt(i);\n              for (j = 0; j < linestring.getLength(); j += 1) {\n                  vertex = linestring.getAt(j);\n                  verts.push({\n                      x: vertex.lng(),\n                      y: vertex.lat()\n                  });\n              }\n              linestrings.push(verts);\n          }\n          response = {\n              type: 'multilinestring',\n              components: linestrings\n          };\n          return response;\n      }\n      if (obj.constructor === google.maps.Data.MultiPolygon) {\n          polygons = [];\n          for (k = 0; k < obj.getLength(); k += 1) {\n              polygon = obj.getAt(k);\n              rings = [];\n              for (i = 0; i < polygon.getLength(); i += 1) {\n                  ring = polygon.getAt(i);\n                  verts = [];\n                  for (j = 0; j < ring.getLength(); j += 1) {\n                      vertex = ring.getAt(j);\n                      verts.push({\n                          x: vertex.lng(),\n                          y: vertex.lat()\n                      });\n                  }\n                  verts.push({\n                      x: ring.getAt(0).lng(),\n                      y: ring.getAt(0).lat()\n                  });\n                  rings.push(verts);\n              }\n              polygons.push(rings);\n          }\n          response = {\n              type: 'multipolygon',\n              components: polygons\n          };\n          return response;\n      }\n      if (obj.constructor === google.maps.Data.GeometryCollection) {\n          var objects = [];\n          for (k = 0; k < obj.getLength(); k += 1) {\n              var object = obj.getAt(k);\n              objects.push(this.deconstruct.call(this, object));\n          }\n          response = {\n              type: 'geometrycollection',\n              components: objects\n          };\n          return response;\n      }\n      if (Wkt.isArray(obj)) {\n          features = [];\n          for (i = 0; i < obj.length; i += 1) {\n              features.push(this.deconstruct.call(this, obj[i], true));\n          }\n          response = {\n              type: function () {\n                  var k,\n                      type = obj[0].constructor;\n                  for (k = 0; k < obj.length; k += 1) {\n                      if (obj[k].constructor !== type) {\n                          return 'geometrycollection';\n                      }\n                  }\n                  switch (type) {\n                      case google.maps.Marker:\n                          return 'multipoint';\n                      case google.maps.Polyline:\n                          return 'multilinestring';\n                      case google.maps.Polygon:\n                          return 'multipolygon';\n                      default:\n                          return 'geometrycollection';\n                  }\n              }(),\n              components: function () {\n                  var i, comps;\n                  comps = [];\n                  for (i = 0; i < features.length; i += 1) {\n                      if (features[i].components) {\n                          comps.push(features[i].components);\n                      }\n                  }\n                  return {\n                      comps: comps\n                  };\n              }()\n          };\n          response.components = response.components.comps;\n          return response;\n      }\n      console.warn('The passed object does not have any recognizable properties.');\n  };\n  function Wicket$1() {\n      return new Wkt.Wkt();\n  }\n\n  function arrayMap(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        result = Array(length);\n    while (++index < length) {\n      result[index] = iteratee(array[index], index, array);\n    }\n    return result;\n  }\n\n  function listCacheClear() {\n    this.__data__ = [];\n    this.size = 0;\n  }\n\n  function eq(value, other) {\n    return value === other || value !== value && other !== other;\n  }\n\n  function assocIndexOf(array, key) {\n    var length = array.length;\n    while (length--) {\n      if (eq(array[length][0], key)) {\n        return length;\n      }\n    }\n    return -1;\n  }\n\n  var arrayProto = Array.prototype;\n  var splice = arrayProto.splice;\n  function listCacheDelete(key) {\n    var data = this.__data__,\n        index = assocIndexOf(data, key);\n    if (index < 0) {\n      return false;\n    }\n    var lastIndex = data.length - 1;\n    if (index == lastIndex) {\n      data.pop();\n    } else {\n      splice.call(data, index, 1);\n    }\n    --this.size;\n    return true;\n  }\n\n  function listCacheGet(key) {\n    var data = this.__data__,\n        index = assocIndexOf(data, key);\n    return index < 0 ? undefined : data[index][1];\n  }\n\n  function listCacheHas(key) {\n    return assocIndexOf(this.__data__, key) > -1;\n  }\n\n  function listCacheSet(key, value) {\n    var data = this.__data__,\n        index = assocIndexOf(data, key);\n    if (index < 0) {\n      ++this.size;\n      data.push([key, value]);\n    } else {\n      data[index][1] = value;\n    }\n    return this;\n  }\n\n  function ListCache(entries) {\n    var index = -1,\n        length = entries == null ? 0 : entries.length;\n    this.clear();\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  }\n  ListCache.prototype.clear = listCacheClear;\n  ListCache.prototype['delete'] = listCacheDelete;\n  ListCache.prototype.get = listCacheGet;\n  ListCache.prototype.has = listCacheHas;\n  ListCache.prototype.set = listCacheSet;\n\n  function stackClear() {\n    this.__data__ = new ListCache();\n    this.size = 0;\n  }\n\n  function stackDelete(key) {\n    var data = this.__data__,\n        result = data['delete'](key);\n    this.size = data.size;\n    return result;\n  }\n\n  function stackGet(key) {\n    return this.__data__.get(key);\n  }\n\n  function stackHas(key) {\n    return this.__data__.has(key);\n  }\n\n  var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global && global.Object === Object && global;\n\n  var freeSelf = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self && self.Object === Object && self;\n  var root = freeGlobal || freeSelf || Function('return this')();\n\n  var _Symbol = root.Symbol;\n\n  var objectProto = Object.prototype;\n  var hasOwnProperty = objectProto.hasOwnProperty;\n  var nativeObjectToString = objectProto.toString;\n  var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;\n  function getRawTag(value) {\n    var isOwn = hasOwnProperty.call(value, symToStringTag),\n        tag = value[symToStringTag];\n    try {\n      value[symToStringTag] = undefined;\n      var unmasked = true;\n    } catch (e) {}\n    var result = nativeObjectToString.call(value);\n    if (unmasked) {\n      if (isOwn) {\n        value[symToStringTag] = tag;\n      } else {\n        delete value[symToStringTag];\n      }\n    }\n    return result;\n  }\n\n  var objectProto$1 = Object.prototype;\n  var nativeObjectToString$1 = objectProto$1.toString;\n  function objectToString(value) {\n    return nativeObjectToString$1.call(value);\n  }\n\n  var nullTag = '[object Null]',\n      undefinedTag = '[object Undefined]';\n  var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;\n  function baseGetTag(value) {\n    if (value == null) {\n      return value === undefined ? undefinedTag : nullTag;\n    }\n    return symToStringTag$1 && symToStringTag$1 in Object(value) ? getRawTag(value) : objectToString(value);\n  }\n\n  function isObject(value) {\n    var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);\n    return value != null && (type == 'object' || type == 'function');\n  }\n\n  var asyncTag = '[object AsyncFunction]',\n      funcTag = '[object Function]',\n      genTag = '[object GeneratorFunction]',\n      proxyTag = '[object Proxy]';\n  function isFunction(value) {\n    if (!isObject(value)) {\n      return false;\n    }\n    var tag = baseGetTag(value);\n    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n  }\n\n  var coreJsData = root['__core-js_shared__'];\n\n  var maskSrcKey = function () {\n    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n    return uid ? 'Symbol(src)_1.' + uid : '';\n  }();\n  function isMasked(func) {\n    return !!maskSrcKey && maskSrcKey in func;\n  }\n\n  var funcProto = Function.prototype;\n  var funcToString = funcProto.toString;\n  function toSource(func) {\n    if (func != null) {\n      try {\n        return funcToString.call(func);\n      } catch (e) {}\n      try {\n        return func + '';\n      } catch (e) {}\n    }\n    return '';\n  }\n\n  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n  var funcProto$1 = Function.prototype,\n      objectProto$2 = Object.prototype;\n  var funcToString$1 = funcProto$1.toString;\n  var hasOwnProperty$1 = objectProto$2.hasOwnProperty;\n  var reIsNative = RegExp('^' + funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\\\$&').replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$');\n  function baseIsNative(value) {\n    if (!isObject(value) || isMasked(value)) {\n      return false;\n    }\n    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n    return pattern.test(toSource(value));\n  }\n\n  function getValue(object, key) {\n    return object == null ? undefined : object[key];\n  }\n\n  function getNative(object, key) {\n    var value = getValue(object, key);\n    return baseIsNative(value) ? value : undefined;\n  }\n\n  var Map$1 = getNative(root, 'Map');\n\n  var nativeCreate = getNative(Object, 'create');\n\n  function hashClear() {\n    this.__data__ = nativeCreate ? nativeCreate(null) : {};\n    this.size = 0;\n  }\n\n  function hashDelete(key) {\n    var result = this.has(key) && delete this.__data__[key];\n    this.size -= result ? 1 : 0;\n    return result;\n  }\n\n  var HASH_UNDEFINED = '__lodash_hash_undefined__';\n  var objectProto$3 = Object.prototype;\n  var hasOwnProperty$2 = objectProto$3.hasOwnProperty;\n  function hashGet(key) {\n    var data = this.__data__;\n    if (nativeCreate) {\n      var result = data[key];\n      return result === HASH_UNDEFINED ? undefined : result;\n    }\n    return hasOwnProperty$2.call(data, key) ? data[key] : undefined;\n  }\n\n  var objectProto$4 = Object.prototype;\n  var hasOwnProperty$3 = objectProto$4.hasOwnProperty;\n  function hashHas(key) {\n    var data = this.__data__;\n    return nativeCreate ? data[key] !== undefined : hasOwnProperty$3.call(data, key);\n  }\n\n  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';\n  function hashSet(key, value) {\n    var data = this.__data__;\n    this.size += this.has(key) ? 0 : 1;\n    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED$1 : value;\n    return this;\n  }\n\n  function Hash(entries) {\n    var index = -1,\n        length = entries == null ? 0 : entries.length;\n    this.clear();\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  }\n  Hash.prototype.clear = hashClear;\n  Hash.prototype['delete'] = hashDelete;\n  Hash.prototype.get = hashGet;\n  Hash.prototype.has = hashHas;\n  Hash.prototype.set = hashSet;\n\n  function mapCacheClear() {\n    this.size = 0;\n    this.__data__ = {\n      'hash': new Hash(),\n      'map': new (Map$1 || ListCache)(),\n      'string': new Hash()\n    };\n  }\n\n  function isKeyable(value) {\n    var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);\n    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;\n  }\n\n  function getMapData(map, key) {\n    var data = map.__data__;\n    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;\n  }\n\n  function mapCacheDelete(key) {\n    var result = getMapData(this, key)['delete'](key);\n    this.size -= result ? 1 : 0;\n    return result;\n  }\n\n  function mapCacheGet(key) {\n    return getMapData(this, key).get(key);\n  }\n\n  function mapCacheHas(key) {\n    return getMapData(this, key).has(key);\n  }\n\n  function mapCacheSet(key, value) {\n    var data = getMapData(this, key),\n        size = data.size;\n    data.set(key, value);\n    this.size += data.size == size ? 0 : 1;\n    return this;\n  }\n\n  function MapCache(entries) {\n    var index = -1,\n        length = entries == null ? 0 : entries.length;\n    this.clear();\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  }\n  MapCache.prototype.clear = mapCacheClear;\n  MapCache.prototype['delete'] = mapCacheDelete;\n  MapCache.prototype.get = mapCacheGet;\n  MapCache.prototype.has = mapCacheHas;\n  MapCache.prototype.set = mapCacheSet;\n\n  var LARGE_ARRAY_SIZE = 200;\n  function stackSet(key, value) {\n    var data = this.__data__;\n    if (data instanceof ListCache) {\n      var pairs = data.__data__;\n      if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {\n        pairs.push([key, value]);\n        this.size = ++data.size;\n        return this;\n      }\n      data = this.__data__ = new MapCache(pairs);\n    }\n    data.set(key, value);\n    this.size = data.size;\n    return this;\n  }\n\n  function Stack(entries) {\n    var data = this.__data__ = new ListCache(entries);\n    this.size = data.size;\n  }\n  Stack.prototype.clear = stackClear;\n  Stack.prototype['delete'] = stackDelete;\n  Stack.prototype.get = stackGet;\n  Stack.prototype.has = stackHas;\n  Stack.prototype.set = stackSet;\n\n  var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';\n  function setCacheAdd(value) {\n    this.__data__.set(value, HASH_UNDEFINED$2);\n    return this;\n  }\n\n  function setCacheHas(value) {\n    return this.__data__.has(value);\n  }\n\n  function SetCache(values) {\n    var index = -1,\n        length = values == null ? 0 : values.length;\n    this.__data__ = new MapCache();\n    while (++index < length) {\n      this.add(values[index]);\n    }\n  }\n  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\n  SetCache.prototype.has = setCacheHas;\n\n  function arraySome(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n    while (++index < length) {\n      if (predicate(array[index], index, array)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function cacheHas(cache, key) {\n    return cache.has(key);\n  }\n\n  var COMPARE_PARTIAL_FLAG = 1,\n      COMPARE_UNORDERED_FLAG = 2;\n  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n        arrLength = array.length,\n        othLength = other.length;\n    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n      return false;\n    }\n    var stacked = stack.get(array);\n    if (stacked && stack.get(other)) {\n      return stacked == other;\n    }\n    var index = -1,\n        result = true,\n        seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;\n    stack.set(array, other);\n    stack.set(other, array);\n    while (++index < arrLength) {\n      var arrValue = array[index],\n          othValue = other[index];\n      if (customizer) {\n        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);\n      }\n      if (compared !== undefined) {\n        if (compared) {\n          continue;\n        }\n        result = false;\n        break;\n      }\n      if (seen) {\n        if (!arraySome(other, function (othValue, othIndex) {\n          if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n            return seen.push(othIndex);\n          }\n        })) {\n          result = false;\n          break;\n        }\n      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n        result = false;\n        break;\n      }\n    }\n    stack['delete'](array);\n    stack['delete'](other);\n    return result;\n  }\n\n  var Uint8Array = root.Uint8Array;\n\n  function mapToArray(map) {\n    var index = -1,\n        result = Array(map.size);\n    map.forEach(function (value, key) {\n      result[++index] = [key, value];\n    });\n    return result;\n  }\n\n  function setToArray(set) {\n    var index = -1,\n        result = Array(set.size);\n    set.forEach(function (value) {\n      result[++index] = value;\n    });\n    return result;\n  }\n\n  var COMPARE_PARTIAL_FLAG$1 = 1,\n      COMPARE_UNORDERED_FLAG$1 = 2;\n  var boolTag = '[object Boolean]',\n      dateTag = '[object Date]',\n      errorTag = '[object Error]',\n      mapTag = '[object Map]',\n      numberTag = '[object Number]',\n      regexpTag = '[object RegExp]',\n      setTag = '[object Set]',\n      stringTag = '[object String]',\n      symbolTag = '[object Symbol]';\n  var arrayBufferTag = '[object ArrayBuffer]',\n      dataViewTag = '[object DataView]';\n  var symbolProto = _Symbol ? _Symbol.prototype : undefined,\n      symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n    switch (tag) {\n      case dataViewTag:\n        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {\n          return false;\n        }\n        object = object.buffer;\n        other = other.buffer;\n      case arrayBufferTag:\n        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n          return false;\n        }\n        return true;\n      case boolTag:\n      case dateTag:\n      case numberTag:\n        return eq(+object, +other);\n      case errorTag:\n        return object.name == other.name && object.message == other.message;\n      case regexpTag:\n      case stringTag:\n        return object == other + '';\n      case mapTag:\n        var convert = mapToArray;\n      case setTag:\n        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;\n        convert || (convert = setToArray);\n        if (object.size != other.size && !isPartial) {\n          return false;\n        }\n        var stacked = stack.get(object);\n        if (stacked) {\n          return stacked == other;\n        }\n        bitmask |= COMPARE_UNORDERED_FLAG$1;\n        stack.set(object, other);\n        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n        stack['delete'](object);\n        return result;\n      case symbolTag:\n        if (symbolValueOf) {\n          return symbolValueOf.call(object) == symbolValueOf.call(other);\n        }\n    }\n    return false;\n  }\n\n  function arrayPush(array, values) {\n    var index = -1,\n        length = values.length,\n        offset = array.length;\n    while (++index < length) {\n      array[offset + index] = values[index];\n    }\n    return array;\n  }\n\n  var isArray = Array.isArray;\n\n  function baseGetAllKeys(object, keysFunc, symbolsFunc) {\n    var result = keysFunc(object);\n    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n  }\n\n  function arrayFilter(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        resIndex = 0,\n        result = [];\n    while (++index < length) {\n      var value = array[index];\n      if (predicate(value, index, array)) {\n        result[resIndex++] = value;\n      }\n    }\n    return result;\n  }\n\n  function stubArray() {\n    return [];\n  }\n\n  var objectProto$5 = Object.prototype;\n  var propertyIsEnumerable = objectProto$5.propertyIsEnumerable;\n  var nativeGetSymbols = Object.getOwnPropertySymbols;\n  var getSymbols = !nativeGetSymbols ? stubArray : function (object) {\n    if (object == null) {\n      return [];\n    }\n    object = Object(object);\n    return arrayFilter(nativeGetSymbols(object), function (symbol) {\n      return propertyIsEnumerable.call(object, symbol);\n    });\n  };\n\n  function baseTimes(n, iteratee) {\n    var index = -1,\n        result = Array(n);\n    while (++index < n) {\n      result[index] = iteratee(index);\n    }\n    return result;\n  }\n\n  function isObjectLike(value) {\n    return value != null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object';\n  }\n\n  var argsTag = '[object Arguments]';\n  function baseIsArguments(value) {\n    return isObjectLike(value) && baseGetTag(value) == argsTag;\n  }\n\n  var objectProto$6 = Object.prototype;\n  var hasOwnProperty$4 = objectProto$6.hasOwnProperty;\n  var propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable;\n  var isArguments = baseIsArguments(function () {\n    return arguments;\n  }()) ? baseIsArguments : function (value) {\n    return isObjectLike(value) && hasOwnProperty$4.call(value, 'callee') && !propertyIsEnumerable$1.call(value, 'callee');\n  };\n\n  function stubFalse() {\n    return false;\n  }\n\n  var freeExports = (typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;\n  var freeModule = freeExports && (typeof module === 'undefined' ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;\n  var moduleExports = freeModule && freeModule.exports === freeExports;\n  var Buffer = moduleExports ? root.Buffer : undefined;\n  var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n  var isBuffer = nativeIsBuffer || stubFalse;\n\n  var MAX_SAFE_INTEGER = 9007199254740991;\n  var reIsUint = /^(?:0|[1-9]\\d*)$/;\n  function isIndex(value, length) {\n    length = length == null ? MAX_SAFE_INTEGER : length;\n    return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;\n  }\n\n  var MAX_SAFE_INTEGER$1 = 9007199254740991;\n  function isLength(value) {\n    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;\n  }\n\n  var argsTag$1 = '[object Arguments]',\n      arrayTag = '[object Array]',\n      boolTag$1 = '[object Boolean]',\n      dateTag$1 = '[object Date]',\n      errorTag$1 = '[object Error]',\n      funcTag$1 = '[object Function]',\n      mapTag$1 = '[object Map]',\n      numberTag$1 = '[object Number]',\n      objectTag = '[object Object]',\n      regexpTag$1 = '[object RegExp]',\n      setTag$1 = '[object Set]',\n      stringTag$1 = '[object String]',\n      weakMapTag = '[object WeakMap]';\n  var arrayBufferTag$1 = '[object ArrayBuffer]',\n      dataViewTag$1 = '[object DataView]',\n      float32Tag = '[object Float32Array]',\n      float64Tag = '[object Float64Array]',\n      int8Tag = '[object Int8Array]',\n      int16Tag = '[object Int16Array]',\n      int32Tag = '[object Int32Array]',\n      uint8Tag = '[object Uint8Array]',\n      uint8ClampedTag = '[object Uint8ClampedArray]',\n      uint16Tag = '[object Uint16Array]',\n      uint32Tag = '[object Uint32Array]';\n  var typedArrayTags = {};\n  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;\n  typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$1] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$1] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$1] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag] = false;\n  function baseIsTypedArray(value) {\n      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n  }\n\n  function baseUnary(func) {\n    return function (value) {\n      return func(value);\n    };\n  }\n\n  var freeExports$1 = (typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;\n  var freeModule$1 = freeExports$1 && (typeof module === 'undefined' ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;\n  var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;\n  var freeProcess = moduleExports$1 && freeGlobal.process;\n  var nodeUtil = function () {\n    try {\n      return freeProcess && freeProcess.binding && freeProcess.binding('util');\n    } catch (e) {}\n  }();\n\n  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n  var objectProto$7 = Object.prototype;\n  var hasOwnProperty$5 = objectProto$7.hasOwnProperty;\n  function arrayLikeKeys(value, inherited) {\n    var isArr = isArray(value),\n        isArg = !isArr && isArguments(value),\n        isBuff = !isArr && !isArg && isBuffer(value),\n        isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n        skipIndexes = isArr || isArg || isBuff || isType,\n        result = skipIndexes ? baseTimes(value.length, String) : [],\n        length = result.length;\n    for (var key in value) {\n      if ((inherited || hasOwnProperty$5.call(value, key)) && !(skipIndexes && (\n      key == 'length' ||\n      isBuff && (key == 'offset' || key == 'parent') ||\n      isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') ||\n      isIndex(key, length)))) {\n        result.push(key);\n      }\n    }\n    return result;\n  }\n\n  var objectProto$8 = Object.prototype;\n  function isPrototype(value) {\n    var Ctor = value && value.constructor,\n        proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$8;\n    return value === proto;\n  }\n\n  function overArg(func, transform) {\n    return function (arg) {\n      return func(transform(arg));\n    };\n  }\n\n  var nativeKeys = overArg(Object.keys, Object);\n\n  var objectProto$9 = Object.prototype;\n  var hasOwnProperty$6 = objectProto$9.hasOwnProperty;\n  function baseKeys(object) {\n    if (!isPrototype(object)) {\n      return nativeKeys(object);\n    }\n    var result = [];\n    for (var key in Object(object)) {\n      if (hasOwnProperty$6.call(object, key) && key != 'constructor') {\n        result.push(key);\n      }\n    }\n    return result;\n  }\n\n  function isArrayLike(value) {\n    return value != null && isLength(value.length) && !isFunction(value);\n  }\n\n  function keys(object) {\n    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n  }\n\n  function getAllKeys(object) {\n    return baseGetAllKeys(object, keys, getSymbols);\n  }\n\n  var COMPARE_PARTIAL_FLAG$2 = 1;\n  var objectProto$10 = Object.prototype;\n  var hasOwnProperty$7 = objectProto$10.hasOwnProperty;\n  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2,\n        objProps = getAllKeys(object),\n        objLength = objProps.length,\n        othProps = getAllKeys(other),\n        othLength = othProps.length;\n    if (objLength != othLength && !isPartial) {\n      return false;\n    }\n    var index = objLength;\n    while (index--) {\n      var key = objProps[index];\n      if (!(isPartial ? key in other : hasOwnProperty$7.call(other, key))) {\n        return false;\n      }\n    }\n    var stacked = stack.get(object);\n    if (stacked && stack.get(other)) {\n      return stacked == other;\n    }\n    var result = true;\n    stack.set(object, other);\n    stack.set(other, object);\n    var skipCtor = isPartial;\n    while (++index < objLength) {\n      key = objProps[index];\n      var objValue = object[key],\n          othValue = other[key];\n      if (customizer) {\n        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);\n      }\n      if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {\n        result = false;\n        break;\n      }\n      skipCtor || (skipCtor = key == 'constructor');\n    }\n    if (result && !skipCtor) {\n      var objCtor = object.constructor,\n          othCtor = other.constructor;\n      if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n        result = false;\n      }\n    }\n    stack['delete'](object);\n    stack['delete'](other);\n    return result;\n  }\n\n  var DataView = getNative(root, 'DataView');\n\n  var Promise$1 = getNative(root, 'Promise');\n\n  var Set = getNative(root, 'Set');\n\n  var WeakMap = getNative(root, 'WeakMap');\n\n  var mapTag$2 = '[object Map]',\n      objectTag$1 = '[object Object]',\n      promiseTag = '[object Promise]',\n      setTag$2 = '[object Set]',\n      weakMapTag$1 = '[object WeakMap]';\n  var dataViewTag$2 = '[object DataView]';\n  var dataViewCtorString = toSource(DataView),\n      mapCtorString = toSource(Map$1),\n      promiseCtorString = toSource(Promise$1),\n      setCtorString = toSource(Set),\n      weakMapCtorString = toSource(WeakMap);\n  var getTag = baseGetTag;\n  if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$2 || Map$1 && getTag(new Map$1()) != mapTag$2 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set && getTag(new Set()) != setTag$2 || WeakMap && getTag(new WeakMap()) != weakMapTag$1) {\n      getTag = function getTag(value) {\n          var result = baseGetTag(value),\n              Ctor = result == objectTag$1 ? value.constructor : undefined,\n              ctorString = Ctor ? toSource(Ctor) : '';\n          if (ctorString) {\n              switch (ctorString) {\n                  case dataViewCtorString:\n                      return dataViewTag$2;\n                  case mapCtorString:\n                      return mapTag$2;\n                  case promiseCtorString:\n                      return promiseTag;\n                  case setCtorString:\n                      return setTag$2;\n                  case weakMapCtorString:\n                      return weakMapTag$1;\n              }\n          }\n          return result;\n      };\n  }\n  var getTag$1 = getTag;\n\n  var COMPARE_PARTIAL_FLAG$3 = 1;\n  var argsTag$2 = '[object Arguments]',\n      arrayTag$1 = '[object Array]',\n      objectTag$2 = '[object Object]';\n  var objectProto$11 = Object.prototype;\n  var hasOwnProperty$8 = objectProto$11.hasOwnProperty;\n  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n    var objIsArr = isArray(object),\n        othIsArr = isArray(other),\n        objTag = objIsArr ? arrayTag$1 : getTag$1(object),\n        othTag = othIsArr ? arrayTag$1 : getTag$1(other);\n    objTag = objTag == argsTag$2 ? objectTag$2 : objTag;\n    othTag = othTag == argsTag$2 ? objectTag$2 : othTag;\n    var objIsObj = objTag == objectTag$2,\n        othIsObj = othTag == objectTag$2,\n        isSameTag = objTag == othTag;\n    if (isSameTag && isBuffer(object)) {\n      if (!isBuffer(other)) {\n        return false;\n      }\n      objIsArr = true;\n      objIsObj = false;\n    }\n    if (isSameTag && !objIsObj) {\n      stack || (stack = new Stack());\n      return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n    }\n    if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {\n      var objIsWrapped = objIsObj && hasOwnProperty$8.call(object, '__wrapped__'),\n          othIsWrapped = othIsObj && hasOwnProperty$8.call(other, '__wrapped__');\n      if (objIsWrapped || othIsWrapped) {\n        var objUnwrapped = objIsWrapped ? object.value() : object,\n            othUnwrapped = othIsWrapped ? other.value() : other;\n        stack || (stack = new Stack());\n        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n      }\n    }\n    if (!isSameTag) {\n      return false;\n    }\n    stack || (stack = new Stack());\n    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n  }\n\n  function baseIsEqual(value, other, bitmask, customizer, stack) {\n    if (value === other) {\n      return true;\n    }\n    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {\n      return value !== value && other !== other;\n    }\n    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n  }\n\n  var COMPARE_PARTIAL_FLAG$4 = 1,\n      COMPARE_UNORDERED_FLAG$2 = 2;\n  function baseIsMatch(object, source, matchData, customizer) {\n    var index = matchData.length,\n        length = index,\n        noCustomizer = !customizer;\n    if (object == null) {\n      return !length;\n    }\n    object = Object(object);\n    while (index--) {\n      var data = matchData[index];\n      if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {\n        return false;\n      }\n    }\n    while (++index < length) {\n      data = matchData[index];\n      var key = data[0],\n          objValue = object[key],\n          srcValue = data[1];\n      if (noCustomizer && data[2]) {\n        if (objValue === undefined && !(key in object)) {\n          return false;\n        }\n      } else {\n        var stack = new Stack();\n        if (customizer) {\n          var result = customizer(objValue, srcValue, key, object, source, stack);\n        }\n        if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$4 | COMPARE_UNORDERED_FLAG$2, customizer, stack) : result)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  function isStrictComparable(value) {\n    return value === value && !isObject(value);\n  }\n\n  function getMatchData(object) {\n    var result = keys(object),\n        length = result.length;\n    while (length--) {\n      var key = result[length],\n          value = object[key];\n      result[length] = [key, value, isStrictComparable(value)];\n    }\n    return result;\n  }\n\n  function matchesStrictComparable(key, srcValue) {\n    return function (object) {\n      if (object == null) {\n        return false;\n      }\n      return object[key] === srcValue && (srcValue !== undefined || key in Object(object));\n    };\n  }\n\n  function baseMatches(source) {\n    var matchData = getMatchData(source);\n    if (matchData.length == 1 && matchData[0][2]) {\n      return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n    }\n    return function (object) {\n      return object === source || baseIsMatch(object, source, matchData);\n    };\n  }\n\n  var symbolTag$1 = '[object Symbol]';\n  function isSymbol(value) {\n    return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag$1;\n  }\n\n  var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n      reIsPlainProp = /^\\w*$/;\n  function isKey(value, object) {\n    if (isArray(value)) {\n      return false;\n    }\n    var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);\n    if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {\n      return true;\n    }\n    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);\n  }\n\n  var FUNC_ERROR_TEXT = 'Expected a function';\n  function memoize(func, resolver) {\n    if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {\n      throw new TypeError(FUNC_ERROR_TEXT);\n    }\n    var memoized = function memoized() {\n      var args = arguments,\n          key = resolver ? resolver.apply(this, args) : args[0],\n          cache = memoized.cache;\n      if (cache.has(key)) {\n        return cache.get(key);\n      }\n      var result = func.apply(this, args);\n      memoized.cache = cache.set(key, result) || cache;\n      return result;\n    };\n    memoized.cache = new (memoize.Cache || MapCache)();\n    return memoized;\n  }\n  memoize.Cache = MapCache;\n\n  var MAX_MEMOIZE_SIZE = 500;\n  function memoizeCapped(func) {\n    var result = memoize(func, function (key) {\n      if (cache.size === MAX_MEMOIZE_SIZE) {\n        cache.clear();\n      }\n      return key;\n    });\n    var cache = result.cache;\n    return result;\n  }\n\n  var reLeadingDot = /^\\./,\n      rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n  var reEscapeChar = /\\\\(\\\\)?/g;\n  var stringToPath = memoizeCapped(function (string) {\n    var result = [];\n    if (reLeadingDot.test(string)) {\n      result.push('');\n    }\n    string.replace(rePropName, function (match, number, quote, string) {\n      result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);\n    });\n    return result;\n  });\n\n  var INFINITY = 1 / 0;\n  var symbolProto$1 = _Symbol ? _Symbol.prototype : undefined,\n      symbolToString = symbolProto$1 ? symbolProto$1.toString : undefined;\n  function baseToString(value) {\n    if (typeof value == 'string') {\n      return value;\n    }\n    if (isArray(value)) {\n      return arrayMap(value, baseToString) + '';\n    }\n    if (isSymbol(value)) {\n      return symbolToString ? symbolToString.call(value) : '';\n    }\n    var result = value + '';\n    return result == '0' && 1 / value == -INFINITY ? '-0' : result;\n  }\n\n  function toString(value) {\n    return value == null ? '' : baseToString(value);\n  }\n\n  function castPath(value, object) {\n    if (isArray(value)) {\n      return value;\n    }\n    return isKey(value, object) ? [value] : stringToPath(toString(value));\n  }\n\n  var INFINITY$1 = 1 / 0;\n  function toKey(value) {\n    if (typeof value == 'string' || isSymbol(value)) {\n      return value;\n    }\n    var result = value + '';\n    return result == '0' && 1 / value == -INFINITY$1 ? '-0' : result;\n  }\n\n  function baseGet(object, path) {\n    path = castPath(path, object);\n    var index = 0,\n        length = path.length;\n    while (object != null && index < length) {\n      object = object[toKey(path[index++])];\n    }\n    return index && index == length ? object : undefined;\n  }\n\n  function get$1(object, path, defaultValue) {\n    var result = object == null ? undefined : baseGet(object, path);\n    return result === undefined ? defaultValue : result;\n  }\n\n  function baseHasIn(object, key) {\n    return object != null && key in Object(object);\n  }\n\n  function hasPath(object, path, hasFunc) {\n    path = castPath(path, object);\n    var index = -1,\n        length = path.length,\n        result = false;\n    while (++index < length) {\n      var key = toKey(path[index]);\n      if (!(result = object != null && hasFunc(object, key))) {\n        break;\n      }\n      object = object[key];\n    }\n    if (result || ++index != length) {\n      return result;\n    }\n    length = object == null ? 0 : object.length;\n    return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));\n  }\n\n  function hasIn(object, path) {\n    return object != null && hasPath(object, path, baseHasIn);\n  }\n\n  var COMPARE_PARTIAL_FLAG$5 = 1,\n      COMPARE_UNORDERED_FLAG$3 = 2;\n  function baseMatchesProperty(path, srcValue) {\n    if (isKey(path) && isStrictComparable(srcValue)) {\n      return matchesStrictComparable(toKey(path), srcValue);\n    }\n    return function (object) {\n      var objValue = get$1(object, path);\n      return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$5 | COMPARE_UNORDERED_FLAG$3);\n    };\n  }\n\n  function identity(value) {\n    return value;\n  }\n\n  function baseProperty(key) {\n    return function (object) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  function basePropertyDeep(path) {\n    return function (object) {\n      return baseGet(object, path);\n    };\n  }\n\n  function property(path) {\n    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n  }\n\n  function baseIteratee(value) {\n    if (typeof value == 'function') {\n      return value;\n    }\n    if (value == null) {\n      return identity;\n    }\n    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object') {\n      return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);\n    }\n    return property(value);\n  }\n\n  function createBaseFor(fromRight) {\n    return function (object, iteratee, keysFunc) {\n      var index = -1,\n          iterable = Object(object),\n          props = keysFunc(object),\n          length = props.length;\n      while (length--) {\n        var key = props[fromRight ? length : ++index];\n        if (iteratee(iterable[key], key, iterable) === false) {\n          break;\n        }\n      }\n      return object;\n    };\n  }\n\n  var baseFor = createBaseFor();\n\n  function baseForOwn(object, iteratee) {\n    return object && baseFor(object, iteratee, keys);\n  }\n\n  function createBaseEach(eachFunc, fromRight) {\n    return function (collection, iteratee) {\n      if (collection == null) {\n        return collection;\n      }\n      if (!isArrayLike(collection)) {\n        return eachFunc(collection, iteratee);\n      }\n      var length = collection.length,\n          index = fromRight ? length : -1,\n          iterable = Object(collection);\n      while (fromRight ? index-- : ++index < length) {\n        if (iteratee(iterable[index], index, iterable) === false) {\n          break;\n        }\n      }\n      return collection;\n    };\n  }\n\n  var baseEach = createBaseEach(baseForOwn);\n\n  function baseMap(collection, iteratee) {\n    var index = -1,\n        result = isArrayLike(collection) ? Array(collection.length) : [];\n    baseEach(collection, function (value, key, collection) {\n      result[++index] = iteratee(value, key, collection);\n    });\n    return result;\n  }\n\n  function map(collection, iteratee) {\n    var func = isArray(collection) ? arrayMap : baseMap;\n    return func(collection, baseIteratee(iteratee, 3));\n  }\n\n  function arrayEach(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n    while (++index < length) {\n      if (iteratee(array[index], index, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  function castFunction(value) {\n    return typeof value == 'function' ? value : identity;\n  }\n\n  function forEach(collection, iteratee) {\n    var func = isArray(collection) ? arrayEach : baseEach;\n    return func(collection, castFunction(iteratee));\n  }\n\n  function toLatLng(position) {\n  \tif (position instanceof google.maps.LatLng) {\n  \t\treturn {\n  \t\t\tlat: position.lat(),\n  \t\t\tlng: position.lng()\n  \t\t};\n  \t} else if (position.lat && position.lng) {\n  \t\treturn position;\n  \t} else {\n  \t\treturn {\n  \t\t\tlat: position[1],\n  \t\t\tlng: position[0]\n  \t\t};\n  \t}\n  }\n  function toLatLngs(coordinates) {\n  \treturn map(coordinates, toLatLng);\n  }\n  function toCoord(LatLng) {\n  \tif (google.maps && google.maps.LatLng && LatLng instanceof google.maps.LatLng) {\n  \t\treturn [LatLng.lng(), LatLng.lat()];\n  \t} else if (LatLng.lat && LatLng.lng) {\n  \t\treturn [LatLng.lng, LatLng.lat];\n  \t} else if (LatLng.length && LatLng.length >= 2) {\n  \t\treturn LatLng;\n  \t} else {\n  \t\tthrow new Error('google.maps is not present in the global scope');\n  \t}\n  }\n  function toCoords(arrayLatLng, closeRing) {\n  \tvar ring = map(arrayLatLng, toCoord);\n  \tif (closeRing === true) {\n  \t\tvar last_coord = ring.pop();\n  \t\tif (last_coord[0] === ring[0][0] && last_coord[1] === ring[0][1]) {\n  \t\t\tring.push(ring[0]);\n  \t\t} else {\n  \t\t\tring.push(last_coord);\n  \t\t\tring.push(ring[0]);\n  \t\t}\n  \t}\n  \treturn ring;\n  }\n\n  function geomEach(geojson, callback) {\n      var i,\n          j,\n          g,\n          geometry$$1,\n          stopG,\n          geometryMaybeCollection,\n          isGeometryCollection,\n          featureProperties,\n          featureBBox,\n          featureId,\n          featureIndex = 0,\n          isFeatureCollection = geojson.type === 'FeatureCollection',\n          isFeature = geojson.type === 'Feature',\n          stop = isFeatureCollection ? geojson.features.length : 1;\n      for (i = 0; i < stop; i++) {\n          geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;\n          featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};\n          featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : undefined;\n          featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : undefined;\n          isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n          stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n          for (g = 0; g < stopG; g++) {\n              geometry$$1 = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n              if (geometry$$1 === null) {\n                  if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                  continue;\n              }\n              switch (geometry$$1.type) {\n                  case 'Point':\n                  case 'LineString':\n                  case 'MultiPoint':\n                  case 'Polygon':\n                  case 'MultiLineString':\n                  case 'MultiPolygon':\n                      {\n                          if (callback(geometry$$1, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                          break;\n                      }\n                  case 'GeometryCollection':\n                      {\n                          for (j = 0; j < geometry$$1.geometries.length; j++) {\n                              if (callback(geometry$$1.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                          }\n                          break;\n                      }\n                  default:\n                      throw new Error('Unknown Geometry Type');\n              }\n          }\n          featureIndex++;\n      }\n  }\n  function geomReduce(geojson, callback, initialValue) {\n      var previousValue = initialValue;\n      geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n          if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n      });\n      return previousValue;\n  }\n\n  function area(geojson) {\n      return geomReduce(geojson, function (value, geom) {\n          return value + calculateArea(geom);\n      }, 0);\n  }\n  var RADIUS = 6378137;\n  function calculateArea(geojson) {\n      var area = 0,\n          i;\n      switch (geojson.type) {\n          case 'Polygon':\n              return polygonArea(geojson.coordinates);\n          case 'MultiPolygon':\n              for (i = 0; i < geojson.coordinates.length; i++) {\n                  area += polygonArea(geojson.coordinates[i]);\n              }\n              return area;\n          case 'Point':\n          case 'MultiPoint':\n          case 'LineString':\n          case 'MultiLineString':\n              return 0;\n          case 'GeometryCollection':\n              for (i = 0; i < geojson.geometries.length; i++) {\n                  area += calculateArea(geojson.geometries[i]);\n              }\n              return area;\n      }\n  }\n  function polygonArea(coords) {\n      var area = 0;\n      if (coords && coords.length > 0) {\n          area += Math.abs(ringArea(coords[0]));\n          for (var i = 1; i < coords.length; i++) {\n              area -= Math.abs(ringArea(coords[i]));\n          }\n      }\n      return area;\n  }\n  function ringArea(coords) {\n      var p1;\n      var p2;\n      var p3;\n      var lowerIndex;\n      var middleIndex;\n      var upperIndex;\n      var i;\n      var area = 0;\n      var coordsLength = coords.length;\n      if (coordsLength > 2) {\n          for (i = 0; i < coordsLength; i++) {\n              if (i === coordsLength - 2) {\n                  lowerIndex = coordsLength - 2;\n                  middleIndex = coordsLength - 1;\n                  upperIndex = 0;\n              } else if (i === coordsLength - 1) {\n                  lowerIndex = coordsLength - 1;\n                  middleIndex = 0;\n                  upperIndex = 1;\n              } else {\n                  lowerIndex = i;\n                  middleIndex = i + 1;\n                  upperIndex = i + 2;\n              }\n              p1 = coords[lowerIndex];\n              p2 = coords[middleIndex];\n              p3 = coords[upperIndex];\n              area += (rad(p3[0]) - rad(p1[0])) * Math.sin(rad(p2[1]));\n          }\n          area = area * RADIUS * RADIUS / 2;\n      }\n      return area;\n  }\n  function rad(_) {\n      return _ * Math.PI / 180;\n  }\n\n  var earthRadius$1 = 6371008.8;\n  var factors$1 = {\n      meters: earthRadius$1,\n      metres: earthRadius$1,\n      millimeters: earthRadius$1 * 1000,\n      millimetres: earthRadius$1 * 1000,\n      centimeters: earthRadius$1 * 100,\n      centimetres: earthRadius$1 * 100,\n      kilometers: earthRadius$1 / 1000,\n      kilometres: earthRadius$1 / 1000,\n      miles: earthRadius$1 / 1609.344,\n      nauticalmiles: earthRadius$1 / 1852,\n      inches: earthRadius$1 * 39.370,\n      yards: earthRadius$1 / 1.0936,\n      feet: earthRadius$1 * 3.28084,\n      radians: 1,\n      degrees: earthRadius$1 / 111325\n  };\n  function feature$1(geometry, properties, bbox, id) {\n      if (geometry === undefined) throw new Error('geometry is required');\n      if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n      if (bbox) {\n          if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n          if (bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');\n      }\n      if (id && ['string', 'number'].indexOf(typeof id === 'undefined' ? 'undefined' : _typeof(id)) === -1) throw new Error('id must be a number or a string');\n      var feat = { type: 'Feature' };\n      if (id) feat.id = id;\n      if (bbox) feat.bbox = bbox;\n      feat.properties = properties || {};\n      feat.geometry = geometry;\n      return feat;\n  }\n  function point$1(coordinates, properties, bbox, id) {\n      if (!coordinates) throw new Error('No coordinates passed');\n      if (!Array.isArray(coordinates)) throw new Error('Coordinates must be an Array');\n      if (coordinates.length < 2) throw new Error('Coordinates must be at least 2 numbers long');\n      if (!isNumber$1(coordinates[0]) || !isNumber$1(coordinates[1])) throw new Error('Coordinates must contain numbers');\n      return feature$1({\n          type: 'Point',\n          coordinates: coordinates\n      }, properties, bbox, id);\n  }\n  function polygon$1(coordinates, properties, bbox, id) {\n      if (!coordinates) throw new Error('No coordinates passed');\n      for (var i = 0; i < coordinates.length; i++) {\n          var ring = coordinates[i];\n          if (ring.length < 4) {\n              throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n          }\n          for (var j = 0; j < ring[ring.length - 1].length; j++) {\n              if (i === 0 && j === 0 && !isNumber$1(ring[0][0]) || !isNumber$1(ring[0][1])) throw new Error('Coordinates must contain numbers');\n              if (ring[ring.length - 1][j] !== ring[0][j]) {\n                  throw new Error('First and last Position are not equivalent.');\n              }\n          }\n      }\n      return feature$1({\n          type: 'Polygon',\n          coordinates: coordinates\n      }, properties, bbox, id);\n  }\n  function lineString$1(coordinates, properties, bbox, id) {\n      if (!coordinates) throw new Error('No coordinates passed');\n      if (coordinates.length < 2) throw new Error('Coordinates must be an array of two or more positions');\n      if (!isNumber$1(coordinates[0][1]) || !isNumber$1(coordinates[0][1])) throw new Error('Coordinates must contain numbers');\n      return feature$1({\n          type: 'LineString',\n          coordinates: coordinates\n      }, properties, bbox, id);\n  }\n  function featureCollection$1(features, bbox, id) {\n      if (!features) throw new Error('No features passed');\n      if (!Array.isArray(features)) throw new Error('features must be an Array');\n      if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');\n      if (id && ['string', 'number'].indexOf(typeof id === 'undefined' ? 'undefined' : _typeof(id)) === -1) throw new Error('id must be a number or a string');\n      var fc = { type: 'FeatureCollection' };\n      if (id) fc.id = id;\n      if (bbox) fc.bbox = bbox;\n      fc.features = features;\n      return fc;\n  }\n  function multiLineString$1(coordinates, properties, bbox, id) {\n      if (!coordinates) throw new Error('No coordinates passed');\n      return feature$1({\n          type: 'MultiLineString',\n          coordinates: coordinates\n      }, properties, bbox, id);\n  }\n  function geometryCollection$1(geometries, properties, bbox, id) {\n      if (!geometries) throw new Error('geometries is required');\n      if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n      return feature$1({\n          type: 'GeometryCollection',\n          geometries: geometries\n      }, properties, bbox, id);\n  }\n  function radiansToLength$1(radians, units) {\n      if (radians === undefined || radians === null) throw new Error('radians is required');\n      if (units && typeof units !== 'string') throw new Error('units must be a string');\n      var factor = factors$1[units || 'kilometers'];\n      if (!factor) throw new Error(units + ' units is invalid');\n      return radians * factor;\n  }\n  function lengthToRadians$1(distance, units) {\n      if (distance === undefined || distance === null) throw new Error('distance is required');\n      if (units && typeof units !== 'string') throw new Error('units must be a string');\n      var factor = factors$1[units || 'kilometers'];\n      if (!factor) throw new Error(units + ' units is invalid');\n      return distance / factor;\n  }\n  function radiansToDegrees$1(radians) {\n      if (radians === null || radians === undefined) throw new Error('radians is required');\n      var degrees = radians % (2 * Math.PI);\n      return degrees * 180 / Math.PI;\n  }\n  function degreesToRadians$1(degrees) {\n      if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n      var radians = degrees % 360;\n      return radians * Math.PI / 180;\n  }\n  function isNumber$1(num) {\n      return !isNaN(num) && num !== null && !Array.isArray(num);\n  }\n  function isObject$2(input) {\n      return !!input && input.constructor === Object;\n  }\n\n  var debug = console.debug.bind(console, '%c turfHelper' + ':', \"color:#00CC00;font-weight:bold;\"),\n      warn = console.debug.bind(console, '%c turfHelper' + ':', \"color:orange;font-weight:bold;\");\n  function arrayToFeaturePolygon(LatLngArray) {\n      var vertices = toCoords(LatLngArray, true);\n      return {\n          type: \"Feature\",\n          properties: {},\n          geometry: {\n              type: \"Polygon\",\n              coordinates: [vertices]\n          }\n      };\n  }\n  function markerToFeaturePoint(marker) {\n      if (!marker.getPosition || typeof marker.getPosition !== 'function') {\n          throw new Error('input object does not have a getPosition method');\n      }\n      var position = marker.getPosition(),\n          Feature = {\n          type: \"Feature\",\n          properties: {},\n          geometry: {\n              type: \"Point\",\n              coordinates: [position.lng(), position.lat()]\n          }\n      };\n      return Feature;\n  }\n  function polylineToFeatureLinestring(objeto) {\n      var vertices;\n      if (objeto instanceof google.maps.Polyline) {\n          vertices = toCoords(objeto.getPath().getArray());\n      } else {\n          vertices = toCoords(objeto);\n      }\n      return lineString$1(vertices);\n  }\n  function polygonToFeaturePolygon(object) {\n      var ring, polygonFeature;\n      if (object.type === 'Feature') {\n          polygonFeature = object;\n      } else if (object instanceof google.maps.Polygon) {\n          object = object.getPath().getArray();\n          ring = toCoords(object, true);\n          polygonFeature = arrayToFeaturePolygon(ring);\n      } else if (!!(object && object.constructor === Array)) {\n          ring = toCoords(object, true);\n          polygonFeature = arrayToFeaturePolygon(ring);\n      } else if (object.geometry) {\n          polygonFeature = {\n              type: \"Feature\",\n              properties: {},\n              geometry: object.geometry\n          };\n      } else {\n          throw new Error('object is not a Feature, google.maps.Polygon nor an array of google.maps.LatLng');\n      }\n      polygonFeature.properties = {};\n      return polygonFeature;\n  }\n  function arrayToFeaturePoints(latLngArray) {\n      var FeatureCollection = {\n          \"type\": \"FeatureCollection\",\n          \"features\": []\n      };\n      latLngArray.forEach(function (latLng) {\n          var Feature = {\n              type: \"Feature\",\n              geometry: {\n                  type: \"Point\",\n                  coordinates: toCoords([latLng])[0]\n              }\n          };\n          FeatureCollection.features.push(Feature);\n      });\n      return FeatureCollection;\n  }\n\n  function tin(points, z) {\n      if (points.type !== 'FeatureCollection') throw new Error('points must be a FeatureCollection');\n      var isPointZ = false;\n      return featureCollection$1(triangulate(points.features.map(function (p) {\n          var point = {\n              x: p.geometry.coordinates[0],\n              y: p.geometry.coordinates[1]\n          };\n          if (z) {\n              point.z = p.properties[z];\n          } else if (p.geometry.coordinates.length === 3) {\n              isPointZ = true;\n              point.z = p.geometry.coordinates[2];\n          }\n          return point;\n      })).map(function (triangle) {\n          var a = [triangle.a.x, triangle.a.y];\n          var b = [triangle.b.x, triangle.b.y];\n          var c = [triangle.c.x, triangle.c.y];\n          var properties = {};\n          if (isPointZ) {\n              a.push(triangle.a.z);\n              b.push(triangle.b.z);\n              c.push(triangle.c.z);\n          } else {\n              properties = {\n                  a: triangle.a.z,\n                  b: triangle.b.z,\n                  c: triangle.c.z\n              };\n          }\n          return polygon$1([[a, b, c, a]], properties);\n      }));\n  }\n  function Triangle(a, b, c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n      var A = b.x - a.x,\n          B = b.y - a.y,\n          C = c.x - a.x,\n          D = c.y - a.y,\n          E = A * (a.x + b.x) + B * (a.y + b.y),\n          F = C * (a.x + c.x) + D * (a.y + c.y),\n          G = 2 * (A * (c.y - b.y) - B * (c.x - b.x)),\n          dx,\n          dy;\n      this.x = (D * E - B * F) / G;\n      this.y = (A * F - C * E) / G;\n      dx = this.x - a.x;\n      dy = this.y - a.y;\n      this.r = dx * dx + dy * dy;\n  }\n  function byX(a, b) {\n      return b.x - a.x;\n  }\n  function dedup(edges) {\n      var j = edges.length,\n          a,\n          b,\n          i,\n          m,\n          n;\n      outer: while (j) {\n          b = edges[--j];\n          a = edges[--j];\n          i = j;\n          while (i) {\n              n = edges[--i];\n              m = edges[--i];\n              if (a === m && b === n || a === n && b === m) {\n                  edges.splice(j, 2);\n                  edges.splice(i, 2);\n                  j -= 2;\n                  continue outer;\n              }\n          }\n      }\n  }\n  function triangulate(vertices) {\n      if (vertices.length < 3) return [];\n      vertices.sort(byX);\n      var i = vertices.length - 1,\n          xmin = vertices[i].x,\n          xmax = vertices[0].x,\n          ymin = vertices[i].y,\n          ymax = ymin,\n          epsilon = 1e-12;\n      var a, b, c, A, B, G;\n      while (i--) {\n          if (vertices[i].y < ymin) ymin = vertices[i].y;\n          if (vertices[i].y > ymax) ymax = vertices[i].y;\n      }\n      var dx = xmax - xmin,\n          dy = ymax - ymin,\n          dmax = dx > dy ? dx : dy,\n          xmid = (xmax + xmin) * 0.5,\n          ymid = (ymax + ymin) * 0.5,\n          open = [new Triangle({\n          x: xmid - 20 * dmax,\n          y: ymid - dmax,\n          __sentinel: true\n      }, {\n          x: xmid,\n          y: ymid + 20 * dmax,\n          __sentinel: true\n      }, {\n          x: xmid + 20 * dmax,\n          y: ymid - dmax,\n          __sentinel: true\n      })],\n          closed = [],\n          edges = [],\n          j;\n      i = vertices.length;\n      while (i--) {\n          edges.length = 0;\n          j = open.length;\n          while (j--) {\n              dx = vertices[i].x - open[j].x;\n              if (dx > 0 && dx * dx > open[j].r) {\n                  closed.push(open[j]);\n                  open.splice(j, 1);\n                  continue;\n              }\n              dy = vertices[i].y - open[j].y;\n              if (dx * dx + dy * dy > open[j].r) continue;\n              edges.push(open[j].a, open[j].b, open[j].b, open[j].c, open[j].c, open[j].a);\n              open.splice(j, 1);\n          }\n          dedup(edges);\n          j = edges.length;\n          while (j) {\n              b = edges[--j];\n              a = edges[--j];\n              c = vertices[i];\n              A = b.x - a.x;\n              B = b.y - a.y;\n              G = 2 * (A * (c.y - b.y) - B * (c.x - b.x));\n              if (Math.abs(G) > epsilon) {\n                  open.push(new Triangle(a, b, c));\n              }\n          }\n      }\n      Array.prototype.push.apply(closed, open);\n      i = closed.length;\n      while (i--) {\n          if (closed[i].a.__sentinel || closed[i].b.__sentinel || closed[i].c.__sentinel) closed.splice(i, 1);\n      }return closed;\n  }\n\n  function clone(geojson) {\n      if (!geojson) throw new Error('geojson is required');\n      switch (geojson.type) {\n          case 'Feature':\n              return cloneFeature(geojson);\n          case 'FeatureCollection':\n              return cloneFeatureCollection(geojson);\n          case 'Point':\n          case 'LineString':\n          case 'Polygon':\n          case 'MultiPoint':\n          case 'MultiLineString':\n          case 'MultiPolygon':\n          case 'GeometryCollection':\n              return cloneGeometry(geojson);\n          default:\n              throw new Error('unknown GeoJSON type');\n      }\n  }\n  function cloneFeature(geojson) {\n      var cloned = { type: 'Feature' };\n      Object.keys(geojson).forEach(function (key) {\n          switch (key) {\n              case 'type':\n              case 'properties':\n              case 'geometry':\n                  return;\n              default:\n                  cloned[key] = geojson[key];\n          }\n      });\n      cloned.properties = cloneProperties(geojson.properties);\n      cloned.geometry = cloneGeometry(geojson.geometry);\n      return cloned;\n  }\n  function cloneProperties(properties) {\n      var cloned = {};\n      if (!properties) return cloned;\n      Object.keys(properties).forEach(function (key) {\n          var value = properties[key];\n          if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\n              if (value.length) cloned[key] = value.map(function (item) {\n                  return item;\n              });\n              cloned[key] = cloneProperties(value);\n          } else cloned[key] = value;\n      });\n      return cloned;\n  }\n  function cloneFeatureCollection(geojson) {\n      var cloned = { type: 'FeatureCollection' };\n      Object.keys(geojson).forEach(function (key) {\n          switch (key) {\n              case 'type':\n              case 'features':\n                  return;\n              default:\n                  cloned[key] = geojson[key];\n          }\n      });\n      cloned.features = geojson.features.map(function (feature) {\n          return cloneFeature(feature);\n      });\n      return cloned;\n  }\n  function cloneGeometry(geometry) {\n      var geom = { type: geometry.type };\n      if (geometry.bbox) geom.bbox = geometry.bbox;\n      if (geometry.type === 'GeometryCollection') {\n          geom.geometries = geometry.geometries.map(function (geom) {\n              return cloneGeometry(geom);\n          });\n          return geom;\n      }\n      geom.coordinates = deepSlice(geometry.coordinates);\n      return geom;\n  }\n  function deepSlice(coords) {\n      if (_typeof(coords[0]) !== 'object') {\n          return coords.slice();\n      }\n      return coords.map(function (coord) {\n          return deepSlice(coord);\n      });\n  }\n\n  function getCoord(obj) {\n      if (!obj) throw new Error('obj is required');\n      var coordinates = getCoords(obj);\n      if (coordinates.length > 1 && isNumber$1(coordinates[0]) && isNumber$1(coordinates[1])) {\n          return coordinates;\n      } else {\n          throw new Error('Coordinate is not a valid Point');\n      }\n  }\n  function getCoords(obj) {\n      if (!obj) throw new Error('obj is required');\n      var coordinates;\n      if (obj.length) {\n          coordinates = obj;\n      } else if (obj.coordinates) {\n          coordinates = obj.coordinates;\n      } else if (obj.geometry && obj.geometry.coordinates) {\n          coordinates = obj.geometry.coordinates;\n      }\n      if (coordinates) {\n          containsNumber(coordinates);\n          return coordinates;\n      }\n      throw new Error('No valid coordinates');\n  }\n  function containsNumber(coordinates) {\n      if (coordinates.length > 1 && isNumber$1(coordinates[0]) && isNumber$1(coordinates[1])) {\n          return true;\n      }\n      if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n          return containsNumber(coordinates[0]);\n      }\n      throw new Error('coordinates must only contain numbers');\n  }\n  function getType(geojson, name) {\n      if (!geojson) throw new Error((name || 'geojson') + ' is required');\n      if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n      if (geojson.type) return geojson.type;\n      throw new Error((name || 'geojson') + ' is invalid');\n  }\n\n  function coordEach$1(geojson, callback, excludeWrapCoord) {\n      if (geojson === null) return;\n      var featureIndex,\n          geometryIndex,\n          j,\n          k,\n          l,\n          geometry,\n          stopG,\n          coords,\n          geometryMaybeCollection,\n          wrapShrink = 0,\n          coordIndex = 0,\n          isGeometryCollection,\n          type = geojson.type,\n          isFeatureCollection = type === 'FeatureCollection',\n          isFeature = type === 'Feature',\n          stop = isFeatureCollection ? geojson.features.length : 1;\n      for (featureIndex = 0; featureIndex < stop; featureIndex++) {\n          geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;\n          isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n          stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n          for (geometryIndex = 0; geometryIndex < stopG; geometryIndex++) {\n              var featureSubIndex = 0;\n              geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geometryIndex] : geometryMaybeCollection;\n              if (geometry === null) continue;\n              coords = geometry.coordinates;\n              var geomType = geometry.type;\n              wrapShrink = excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon') ? 1 : 0;\n              switch (geomType) {\n                  case null:\n                      break;\n                  case 'Point':\n                      callback(coords, coordIndex, featureIndex, featureSubIndex);\n                      coordIndex++;\n                      featureSubIndex++;\n                      break;\n                  case 'LineString':\n                  case 'MultiPoint':\n                      for (j = 0; j < coords.length; j++) {\n                          callback(coords[j], coordIndex, featureIndex, featureSubIndex);\n                          coordIndex++;\n                          if (geomType === 'MultiPoint') featureSubIndex++;\n                      }\n                      if (geomType === 'LineString') featureSubIndex++;\n                      break;\n                  case 'Polygon':\n                  case 'MultiLineString':\n                      for (j = 0; j < coords.length; j++) {\n                          for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                              callback(coords[j][k], coordIndex, featureIndex, featureSubIndex);\n                              coordIndex++;\n                          }\n                          if (geomType === 'MultiLineString') featureSubIndex++;\n                      }\n                      if (geomType === 'Polygon') featureSubIndex++;\n                      break;\n                  case 'MultiPolygon':\n                      for (j = 0; j < coords.length; j++) {\n                          for (k = 0; k < coords[j].length; k++) {\n                              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                                  callback(coords[j][k][l], coordIndex, featureIndex, featureSubIndex);\n                                  coordIndex++;\n                              }\n                          }featureSubIndex++;\n                      }\n                      break;\n                  case 'GeometryCollection':\n                      for (j = 0; j < geometry.geometries.length; j++) {\n                          coordEach$1(geometry.geometries[j], callback, excludeWrapCoord);\n                      }break;\n                  default:\n                      throw new Error('Unknown Geometry Type');\n              }\n          }\n      }\n  }\n  function featureEach$1(geojson, callback) {\n      if (geojson.type === 'Feature') {\n          callback(geojson, 0);\n      } else if (geojson.type === 'FeatureCollection') {\n          for (var i = 0; i < geojson.features.length; i++) {\n              callback(geojson.features[i], i);\n          }\n      }\n  }\n  function geomEach$1(geojson, callback) {\n      var i,\n          j,\n          g,\n          geometry,\n          stopG,\n          geometryMaybeCollection,\n          isGeometryCollection,\n          featureProperties,\n          featureBBox,\n          featureId,\n          featureIndex = 0,\n          isFeatureCollection = geojson.type === 'FeatureCollection',\n          isFeature = geojson.type === 'Feature',\n          stop = isFeatureCollection ? geojson.features.length : 1;\n      for (i = 0; i < stop; i++) {\n          geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;\n          featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};\n          featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : undefined;\n          featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : undefined;\n          isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n          stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n          for (g = 0; g < stopG; g++) {\n              geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n              if (geometry === null) {\n                  callback(null, featureIndex, featureProperties, featureBBox, featureId);\n                  continue;\n              }\n              switch (geometry.type) {\n                  case 'Point':\n                  case 'LineString':\n                  case 'MultiPoint':\n                  case 'Polygon':\n                  case 'MultiLineString':\n                  case 'MultiPolygon':\n                      {\n                          callback(geometry, featureIndex, featureProperties, featureBBox, featureId);\n                          break;\n                      }\n                  case 'GeometryCollection':\n                      {\n                          for (j = 0; j < geometry.geometries.length; j++) {\n                              callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId);\n                          }\n                          break;\n                      }\n                  default:\n                      throw new Error('Unknown Geometry Type');\n              }\n          }\n          featureIndex++;\n      }\n  }\n  function flattenEach$1(geojson, callback) {\n      geomEach$1(geojson, function (geometry, featureIndex, properties, bbox, id) {\n          var type = geometry === null ? null : geometry.type;\n          switch (type) {\n              case null:\n              case 'Point':\n              case 'LineString':\n              case 'Polygon':\n                  callback(feature$1(geometry, properties, bbox, id), featureIndex, 0);\n                  return;\n          }\n          var geomType;\n          switch (type) {\n              case 'MultiPoint':\n                  geomType = 'Point';\n                  break;\n              case 'MultiLineString':\n                  geomType = 'LineString';\n                  break;\n              case 'MultiPolygon':\n                  geomType = 'Polygon';\n                  break;\n          }\n          geometry.coordinates.forEach(function (coordinate, featureSubIndex) {\n              var geom = {\n                  type: geomType,\n                  coordinates: coordinate\n              };\n              callback(feature$1(geom, properties), featureIndex, featureSubIndex);\n          });\n      });\n  }\n  function lineEach$1(geojson, callback) {\n      if (!geojson) throw new Error('geojson is required');\n      flattenEach$1(geojson, function (feature, featureIndex, featureSubIndex) {\n          if (feature.geometry === null) return;\n          var type = feature.geometry.type;\n          var coords = feature.geometry.coordinates;\n          switch (type) {\n              case 'LineString':\n                  callback(feature, featureIndex, featureSubIndex, 0);\n                  break;\n              case 'Polygon':\n                  for (var lineIndex = 0; lineIndex < coords.length; lineIndex++) {\n                      callback(lineString$1(coords[lineIndex], feature.properties), featureIndex, featureSubIndex, lineIndex);\n                  }\n                  break;\n          }\n      });\n  }\n  function lineReduce$1(geojson, callback, initialValue) {\n      var previousValue = initialValue;\n      lineEach$1(geojson, function (currentLine, featureIndex, featureSubIndex, lineIndex) {\n          if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;else previousValue = callback(previousValue, currentLine, featureIndex, featureSubIndex, lineIndex);\n      });\n      return previousValue;\n  }\n\n  function lineDissolve(geojson, options) {\n      options = options || {};\n      if (!isObject$2(options)) throw new Error('options is invalid');\n      var mutate = options.mutate;\n      if (getType(geojson) !== 'FeatureCollection') throw new Error('geojson must be a FeatureCollection');\n      if (!geojson.features.length) throw new Error('geojson is empty');\n      if (mutate === false || mutate === undefined) geojson = clone(geojson);\n      var result = [];\n      var lastLine = lineReduce$1(geojson, function (previousLine, currentLine) {\n          var merged = mergeLineStrings(previousLine, currentLine);\n          if (merged) return merged;\n          else {\n                  result.push(previousLine);\n                  return currentLine;\n              }\n      });\n      if (lastLine) result.push(lastLine);\n      if (!result.length) return null;\n      else if (result.length === 1) return result[0];\n          else return multiLineString$1(result.map(function (line) {\n                  return line.coordinates;\n              }));\n  }\n  function coordId(coord) {\n      return coord[0].toString() + ',' + coord[1].toString();\n  }\n  function mergeLineStrings(a, b) {\n      var coords1 = a.geometry.coordinates;\n      var coords2 = b.geometry.coordinates;\n      var s1 = coordId(coords1[0]);\n      var e1 = coordId(coords1[coords1.length - 1]);\n      var s2 = coordId(coords2[0]);\n      var e2 = coordId(coords2[coords2.length - 1]);\n      var coords;\n      if (s1 === e2) coords = coords2.concat(coords1.slice(1));else if (s2 === e1) coords = coords1.concat(coords2.slice(1));else if (s1 === s2) coords = coords1.slice(1).reverse().concat(coords2);else if (e1 === e2) coords = coords1.concat(coords2.reverse().slice(1));else return null;\n      return lineString$1(coords);\n  }\n\n  function identity$1 (x) {\n    return x;\n  }\n\n  function transform (transform) {\n    if (transform == null) return identity$1;\n    var x0,\n        y0,\n        kx = transform.scale[0],\n        ky = transform.scale[1],\n        dx = transform.translate[0],\n        dy = transform.translate[1];\n    return function (input, i) {\n      if (!i) x0 = y0 = 0;\n      var j = 2,\n          n = input.length,\n          output = new Array(n);\n      output[0] = (x0 += input[0]) * kx + dx;\n      output[1] = (y0 += input[1]) * ky + dy;\n      while (j < n) {\n        output[j] = input[j], ++j;\n      }return output;\n    };\n  }\n\n  function reverse (array, n) {\n    var t,\n        j = array.length,\n        i = j - n;\n    while (i < --j) {\n      t = array[i], array[i++] = array[j], array[j] = t;\n    }\n  }\n\n  function object(topology, o) {\n    var transformPoint = transform(topology.transform),\n        arcs = topology.arcs;\n    function arc(i, points) {\n      if (points.length) points.pop();\n      for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {\n        points.push(transformPoint(a[k], k));\n      }\n      if (i < 0) reverse(points, n);\n    }\n    function point(p) {\n      return transformPoint(p);\n    }\n    function line(arcs) {\n      var points = [];\n      for (var i = 0, n = arcs.length; i < n; ++i) {\n        arc(arcs[i], points);\n      }if (points.length < 2) points.push(points[0]);\n      return points;\n    }\n    function ring(arcs) {\n      var points = line(arcs);\n      while (points.length < 4) {\n        points.push(points[0]);\n      }\n      return points;\n    }\n    function polygon(arcs) {\n      return arcs.map(ring);\n    }\n    function geometry(o) {\n      var type = o.type,\n          coordinates;\n      switch (type) {\n        case \"GeometryCollection\":\n          return { type: type, geometries: o.geometries.map(geometry) };\n        case \"Point\":\n          coordinates = point(o.coordinates);break;\n        case \"MultiPoint\":\n          coordinates = o.coordinates.map(point);break;\n        case \"LineString\":\n          coordinates = line(o.arcs);break;\n        case \"MultiLineString\":\n          coordinates = o.arcs.map(line);break;\n        case \"Polygon\":\n          coordinates = polygon(o.arcs);break;\n        case \"MultiPolygon\":\n          coordinates = o.arcs.map(polygon);break;\n        default:\n          return null;\n      }\n      return { type: type, coordinates: coordinates };\n    }\n    return geometry(o);\n  }\n\n  function stitch (topology, arcs) {\n    var stitchedArcs = {},\n        fragmentByStart = {},\n        fragmentByEnd = {},\n        fragments = [],\n        emptyIndex = -1;\n    arcs.forEach(function (i, j) {\n      var arc = topology.arcs[i < 0 ? ~i : i],\n          t;\n      if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {\n        t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;\n      }\n    });\n    arcs.forEach(function (i) {\n      var e = ends(i),\n          start = e[0],\n          end = e[1],\n          f,\n          g;\n      if (f = fragmentByEnd[start]) {\n        delete fragmentByEnd[f.end];\n        f.push(i);\n        f.end = end;\n        if (g = fragmentByStart[end]) {\n          delete fragmentByStart[g.start];\n          var fg = g === f ? f : f.concat(g);\n          fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;\n        } else {\n          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n        }\n      } else if (f = fragmentByStart[end]) {\n        delete fragmentByStart[f.start];\n        f.unshift(i);\n        f.start = start;\n        if (g = fragmentByEnd[start]) {\n          delete fragmentByEnd[g.end];\n          var gf = g === f ? f : g.concat(f);\n          fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;\n        } else {\n          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n        }\n      } else {\n        f = [i];\n        fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;\n      }\n    });\n    function ends(i) {\n      var arc = topology.arcs[i < 0 ? ~i : i],\n          p0 = arc[0],\n          p1;\n      if (topology.transform) p1 = [0, 0], arc.forEach(function (dp) {\n        p1[0] += dp[0], p1[1] += dp[1];\n      });else p1 = arc[arc.length - 1];\n      return i < 0 ? [p1, p0] : [p0, p1];\n    }\n    function flush(fragmentByEnd, fragmentByStart) {\n      for (var k in fragmentByEnd) {\n        var f = fragmentByEnd[k];\n        delete fragmentByStart[f.start];\n        delete f.start;\n        delete f.end;\n        f.forEach(function (i) {\n          stitchedArcs[i < 0 ? ~i : i] = 1;\n        });\n        fragments.push(f);\n      }\n    }\n    flush(fragmentByEnd, fragmentByStart);\n    flush(fragmentByStart, fragmentByEnd);\n    arcs.forEach(function (i) {\n      if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]);\n    });\n    return fragments;\n  }\n\n  function planarRingArea(ring) {\n    var i = -1,\n        n = ring.length,\n        a,\n        b = ring[n - 1],\n        area = 0;\n    while (++i < n) {\n      a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];\n    }return Math.abs(area);\n  }\n  function merge (topology) {\n    return object(topology, mergeArcs.apply(this, arguments));\n  }\n  function mergeArcs(topology, objects) {\n    var polygonsByArc = {},\n        polygons = [],\n        groups = [];\n    objects.forEach(geometry);\n    function geometry(o) {\n      switch (o.type) {\n        case \"GeometryCollection\":\n          o.geometries.forEach(geometry);break;\n        case \"Polygon\":\n          extract(o.arcs);break;\n        case \"MultiPolygon\":\n          o.arcs.forEach(extract);break;\n      }\n    }\n    function extract(polygon) {\n      polygon.forEach(function (ring) {\n        ring.forEach(function (arc) {\n          (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);\n        });\n      });\n      polygons.push(polygon);\n    }\n    function area(ring) {\n      return planarRingArea(object(topology, { type: \"Polygon\", arcs: [ring] }).coordinates[0]);\n    }\n    polygons.forEach(function (polygon) {\n      if (!polygon._) {\n        var group = [],\n            neighbors = [polygon];\n        polygon._ = 1;\n        groups.push(group);\n        while (polygon = neighbors.pop()) {\n          group.push(polygon);\n          polygon.forEach(function (ring) {\n            ring.forEach(function (arc) {\n              polygonsByArc[arc < 0 ? ~arc : arc].forEach(function (polygon) {\n                if (!polygon._) {\n                  polygon._ = 1;\n                  neighbors.push(polygon);\n                }\n              });\n            });\n          });\n        }\n      }\n    });\n    polygons.forEach(function (polygon) {\n      delete polygon._;\n    });\n    return {\n      type: \"MultiPolygon\",\n      arcs: groups.map(function (polygons) {\n        var arcs = [],\n            n;\n        polygons.forEach(function (polygon) {\n          polygon.forEach(function (ring) {\n            ring.forEach(function (arc) {\n              if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {\n                arcs.push(arc);\n              }\n            });\n          });\n        });\n        arcs = stitch(topology, arcs);\n        if ((n = arcs.length) > 1) {\n          for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {\n            if ((ki = area(arcs[i])) > k) {\n              t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;\n            }\n          }\n        }\n        return arcs;\n      })\n    };\n  }\n\n  function bounds (objects) {\n    var x0 = Infinity,\n        y0 = Infinity,\n        x1 = -Infinity,\n        y1 = -Infinity;\n    function boundGeometry(geometry) {\n      if (geometry != null && boundGeometryType.hasOwnProperty(geometry.type)) boundGeometryType[geometry.type](geometry);\n    }\n    var boundGeometryType = {\n      GeometryCollection: function GeometryCollection(o) {\n        o.geometries.forEach(boundGeometry);\n      },\n      Point: function Point(o) {\n        boundPoint(o.coordinates);\n      },\n      MultiPoint: function MultiPoint(o) {\n        o.coordinates.forEach(boundPoint);\n      },\n      LineString: function LineString(o) {\n        boundLine(o.arcs);\n      },\n      MultiLineString: function MultiLineString(o) {\n        o.arcs.forEach(boundLine);\n      },\n      Polygon: function Polygon(o) {\n        o.arcs.forEach(boundLine);\n      },\n      MultiPolygon: function MultiPolygon(o) {\n        o.arcs.forEach(boundMultiLine);\n      }\n    };\n    function boundPoint(coordinates) {\n      var x = coordinates[0],\n          y = coordinates[1];\n      if (x < x0) x0 = x;\n      if (x > x1) x1 = x;\n      if (y < y0) y0 = y;\n      if (y > y1) y1 = y;\n    }\n    function boundLine(coordinates) {\n      coordinates.forEach(boundPoint);\n    }\n    function boundMultiLine(coordinates) {\n      coordinates.forEach(boundLine);\n    }\n    for (var key in objects) {\n      boundGeometry(objects[key]);\n    }\n    return x1 >= x0 && y1 >= y0 ? [x0, y0, x1, y1] : undefined;\n  }\n\n  function hashset (size, hash, equal, type, empty) {\n    if (arguments.length === 3) {\n      type = Array;\n      empty = null;\n    }\n    var store = new type(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))),\n        mask = size - 1;\n    for (var i = 0; i < size; ++i) {\n      store[i] = empty;\n    }\n    function add(value) {\n      var index = hash(value) & mask,\n          match = store[index],\n          collisions = 0;\n      while (match != empty) {\n        if (equal(match, value)) return true;\n        if (++collisions >= size) throw new Error(\"full hashset\");\n        match = store[index = index + 1 & mask];\n      }\n      store[index] = value;\n      return true;\n    }\n    function has(value) {\n      var index = hash(value) & mask,\n          match = store[index],\n          collisions = 0;\n      while (match != empty) {\n        if (equal(match, value)) return true;\n        if (++collisions >= size) break;\n        match = store[index = index + 1 & mask];\n      }\n      return false;\n    }\n    function values() {\n      var values = [];\n      for (var i = 0, n = store.length; i < n; ++i) {\n        var match = store[i];\n        if (match != empty) values.push(match);\n      }\n      return values;\n    }\n    return {\n      add: add,\n      has: has,\n      values: values\n    };\n  }\n\n  function hashmap (size, hash, equal, keyType, keyEmpty, valueType) {\n    if (arguments.length === 3) {\n      keyType = valueType = Array;\n      keyEmpty = null;\n    }\n    var keystore = new keyType(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))),\n        valstore = new valueType(size),\n        mask = size - 1;\n    for (var i = 0; i < size; ++i) {\n      keystore[i] = keyEmpty;\n    }\n    function set(key, value) {\n      var index = hash(key) & mask,\n          matchKey = keystore[index],\n          collisions = 0;\n      while (matchKey != keyEmpty) {\n        if (equal(matchKey, key)) return valstore[index] = value;\n        if (++collisions >= size) throw new Error(\"full hashmap\");\n        matchKey = keystore[index = index + 1 & mask];\n      }\n      keystore[index] = key;\n      valstore[index] = value;\n      return value;\n    }\n    function maybeSet(key, value) {\n      var index = hash(key) & mask,\n          matchKey = keystore[index],\n          collisions = 0;\n      while (matchKey != keyEmpty) {\n        if (equal(matchKey, key)) return valstore[index];\n        if (++collisions >= size) throw new Error(\"full hashmap\");\n        matchKey = keystore[index = index + 1 & mask];\n      }\n      keystore[index] = key;\n      valstore[index] = value;\n      return value;\n    }\n    function get(key, missingValue) {\n      var index = hash(key) & mask,\n          matchKey = keystore[index],\n          collisions = 0;\n      while (matchKey != keyEmpty) {\n        if (equal(matchKey, key)) return valstore[index];\n        if (++collisions >= size) break;\n        matchKey = keystore[index = index + 1 & mask];\n      }\n      return missingValue;\n    }\n    function keys() {\n      var keys = [];\n      for (var i = 0, n = keystore.length; i < n; ++i) {\n        var matchKey = keystore[i];\n        if (matchKey != keyEmpty) keys.push(matchKey);\n      }\n      return keys;\n    }\n    return {\n      set: set,\n      maybeSet: maybeSet,\n      get: get,\n      keys: keys\n    };\n  }\n\n  function equalPoint (pointA, pointB) {\n    return pointA[0] === pointB[0] && pointA[1] === pointB[1];\n  }\n\n  var buffer = new ArrayBuffer(16),\n      floats = new Float64Array(buffer),\n      uints = new Uint32Array(buffer);\n  function hashPoint (point) {\n    floats[0] = point[0];\n    floats[1] = point[1];\n    var hash = uints[0] ^ uints[1];\n    hash = hash << 5 ^ hash >> 7 ^ uints[2] ^ uints[3];\n    return hash & 0x7fffffff;\n  }\n\n  function join (topology) {\n    var coordinates = topology.coordinates,\n        lines = topology.lines,\n        rings = topology.rings,\n        indexes = index(),\n        visitedByIndex = new Int32Array(coordinates.length),\n        leftByIndex = new Int32Array(coordinates.length),\n        rightByIndex = new Int32Array(coordinates.length),\n        junctionByIndex = new Int8Array(coordinates.length),\n        junctionCount = 0,\n    i,\n        n,\n        previousIndex,\n        currentIndex,\n        nextIndex;\n    for (i = 0, n = coordinates.length; i < n; ++i) {\n      visitedByIndex[i] = leftByIndex[i] = rightByIndex[i] = -1;\n    }\n    for (i = 0, n = lines.length; i < n; ++i) {\n      var line = lines[i],\n          lineStart = line[0],\n          lineEnd = line[1];\n      currentIndex = indexes[lineStart];\n      nextIndex = indexes[++lineStart];\n      ++junctionCount, junctionByIndex[currentIndex] = 1;\n      while (++lineStart <= lineEnd) {\n        sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[lineStart]);\n      }\n      ++junctionCount, junctionByIndex[nextIndex] = 1;\n    }\n    for (i = 0, n = coordinates.length; i < n; ++i) {\n      visitedByIndex[i] = -1;\n    }\n    for (i = 0, n = rings.length; i < n; ++i) {\n      var ring = rings[i],\n          ringStart = ring[0] + 1,\n          ringEnd = ring[1];\n      previousIndex = indexes[ringEnd - 1];\n      currentIndex = indexes[ringStart - 1];\n      nextIndex = indexes[ringStart];\n      sequence(i, previousIndex, currentIndex, nextIndex);\n      while (++ringStart <= ringEnd) {\n        sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[ringStart]);\n      }\n    }\n    function sequence(i, previousIndex, currentIndex, nextIndex) {\n      if (visitedByIndex[currentIndex] === i) return;\n      visitedByIndex[currentIndex] = i;\n      var leftIndex = leftByIndex[currentIndex];\n      if (leftIndex >= 0) {\n        var rightIndex = rightByIndex[currentIndex];\n        if ((leftIndex !== previousIndex || rightIndex !== nextIndex) && (leftIndex !== nextIndex || rightIndex !== previousIndex)) {\n          ++junctionCount, junctionByIndex[currentIndex] = 1;\n        }\n      } else {\n        leftByIndex[currentIndex] = previousIndex;\n        rightByIndex[currentIndex] = nextIndex;\n      }\n    }\n    function index() {\n      var indexByPoint = hashmap(coordinates.length * 1.4, hashIndex, equalIndex, Int32Array, -1, Int32Array),\n          indexes = new Int32Array(coordinates.length);\n      for (var i = 0, n = coordinates.length; i < n; ++i) {\n        indexes[i] = indexByPoint.maybeSet(i, i);\n      }\n      return indexes;\n    }\n    function hashIndex(i) {\n      return hashPoint(coordinates[i]);\n    }\n    function equalIndex(i, j) {\n      return equalPoint(coordinates[i], coordinates[j]);\n    }\n    visitedByIndex = leftByIndex = rightByIndex = null;\n    var junctionByPoint = hashset(junctionCount * 1.4, hashPoint, equalPoint),\n        j;\n    for (i = 0, n = coordinates.length; i < n; ++i) {\n      if (junctionByIndex[j = indexes[i]]) {\n        junctionByPoint.add(coordinates[j]);\n      }\n    }\n    return junctionByPoint;\n  }\n\n  function cut (topology) {\n    var junctions = join(topology),\n        coordinates = topology.coordinates,\n        lines = topology.lines,\n        rings = topology.rings,\n        next,\n        i,\n        n;\n    for (i = 0, n = lines.length; i < n; ++i) {\n      var line = lines[i],\n          lineMid = line[0],\n          lineEnd = line[1];\n      while (++lineMid < lineEnd) {\n        if (junctions.has(coordinates[lineMid])) {\n          next = { 0: lineMid, 1: line[1] };\n          line[1] = lineMid;\n          line = line.next = next;\n        }\n      }\n    }\n    for (i = 0, n = rings.length; i < n; ++i) {\n      var ring = rings[i],\n          ringStart = ring[0],\n          ringMid = ringStart,\n          ringEnd = ring[1],\n          ringFixed = junctions.has(coordinates[ringStart]);\n      while (++ringMid < ringEnd) {\n        if (junctions.has(coordinates[ringMid])) {\n          if (ringFixed) {\n            next = { 0: ringMid, 1: ring[1] };\n            ring[1] = ringMid;\n            ring = ring.next = next;\n          } else {\n            rotateArray(coordinates, ringStart, ringEnd, ringEnd - ringMid);\n            coordinates[ringEnd] = coordinates[ringStart];\n            ringFixed = true;\n            ringMid = ringStart;\n          }\n        }\n      }\n    }\n    return topology;\n  }\n  function rotateArray(array, start, end, offset) {\n    reverse$1(array, start, end);\n    reverse$1(array, start, start + offset);\n    reverse$1(array, start + offset, end);\n  }\n  function reverse$1(array, start, end) {\n    for (var mid = start + (end-- - start >> 1), t; start < mid; ++start, --end) {\n      t = array[start], array[start] = array[end], array[end] = t;\n    }\n  }\n\n  function dedup$1 (topology) {\n    var coordinates = topology.coordinates,\n        lines = topology.lines,\n        line,\n        rings = topology.rings,\n        ring,\n        arcCount = lines.length + rings.length,\n        i,\n        n;\n    delete topology.lines;\n    delete topology.rings;\n    for (i = 0, n = lines.length; i < n; ++i) {\n      line = lines[i];while (line = line.next) {\n        ++arcCount;\n      }\n    }\n    for (i = 0, n = rings.length; i < n; ++i) {\n      ring = rings[i];while (ring = ring.next) {\n        ++arcCount;\n      }\n    }\n    var arcsByEnd = hashmap(arcCount * 2 * 1.4, hashPoint, equalPoint),\n        arcs = topology.arcs = [];\n    for (i = 0, n = lines.length; i < n; ++i) {\n      line = lines[i];\n      do {\n        dedupLine(line);\n      } while (line = line.next);\n    }\n    for (i = 0, n = rings.length; i < n; ++i) {\n      ring = rings[i];\n      if (ring.next) {\n        do {\n          dedupLine(ring);\n        } while (ring = ring.next);\n      } else {\n        dedupRing(ring);\n      }\n    }\n    function dedupLine(arc) {\n      var startPoint, endPoint, startArcs, startArc, endArcs, endArc, i, n;\n      if (startArcs = arcsByEnd.get(startPoint = coordinates[arc[0]])) {\n        for (i = 0, n = startArcs.length; i < n; ++i) {\n          startArc = startArcs[i];\n          if (equalLine(startArc, arc)) {\n            arc[0] = startArc[0];\n            arc[1] = startArc[1];\n            return;\n          }\n        }\n      }\n      if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[1]])) {\n        for (i = 0, n = endArcs.length; i < n; ++i) {\n          endArc = endArcs[i];\n          if (reverseEqualLine(endArc, arc)) {\n            arc[1] = endArc[0];\n            arc[0] = endArc[1];\n            return;\n          }\n        }\n      }\n      if (startArcs) startArcs.push(arc);else arcsByEnd.set(startPoint, [arc]);\n      if (endArcs) endArcs.push(arc);else arcsByEnd.set(endPoint, [arc]);\n      arcs.push(arc);\n    }\n    function dedupRing(arc) {\n      var endPoint, endArcs, endArc, i, n;\n      if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0]])) {\n        for (i = 0, n = endArcs.length; i < n; ++i) {\n          endArc = endArcs[i];\n          if (equalRing(endArc, arc)) {\n            arc[0] = endArc[0];\n            arc[1] = endArc[1];\n            return;\n          }\n          if (reverseEqualRing(endArc, arc)) {\n            arc[0] = endArc[1];\n            arc[1] = endArc[0];\n            return;\n          }\n        }\n      }\n      if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0] + findMinimumOffset(arc)])) {\n        for (i = 0, n = endArcs.length; i < n; ++i) {\n          endArc = endArcs[i];\n          if (equalRing(endArc, arc)) {\n            arc[0] = endArc[0];\n            arc[1] = endArc[1];\n            return;\n          }\n          if (reverseEqualRing(endArc, arc)) {\n            arc[0] = endArc[1];\n            arc[1] = endArc[0];\n            return;\n          }\n        }\n      }\n      if (endArcs) endArcs.push(arc);else arcsByEnd.set(endPoint, [arc]);\n      arcs.push(arc);\n    }\n    function equalLine(arcA, arcB) {\n      var ia = arcA[0],\n          ib = arcB[0],\n          ja = arcA[1],\n          jb = arcB[1];\n      if (ia - ja !== ib - jb) return false;\n      for (; ia <= ja; ++ia, ++ib) {\n        if (!equalPoint(coordinates[ia], coordinates[ib])) return false;\n      }return true;\n    }\n    function reverseEqualLine(arcA, arcB) {\n      var ia = arcA[0],\n          ib = arcB[0],\n          ja = arcA[1],\n          jb = arcB[1];\n      if (ia - ja !== ib - jb) return false;\n      for (; ia <= ja; ++ia, --jb) {\n        if (!equalPoint(coordinates[ia], coordinates[jb])) return false;\n      }return true;\n    }\n    function equalRing(arcA, arcB) {\n      var ia = arcA[0],\n          ib = arcB[0],\n          ja = arcA[1],\n          jb = arcB[1],\n          n = ja - ia;\n      if (n !== jb - ib) return false;\n      var ka = findMinimumOffset(arcA),\n          kb = findMinimumOffset(arcB);\n      for (var i = 0; i < n; ++i) {\n        if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[ib + (i + kb) % n])) return false;\n      }\n      return true;\n    }\n    function reverseEqualRing(arcA, arcB) {\n      var ia = arcA[0],\n          ib = arcB[0],\n          ja = arcA[1],\n          jb = arcB[1],\n          n = ja - ia;\n      if (n !== jb - ib) return false;\n      var ka = findMinimumOffset(arcA),\n          kb = n - findMinimumOffset(arcB);\n      for (var i = 0; i < n; ++i) {\n        if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[jb - (i + kb) % n])) return false;\n      }\n      return true;\n    }\n    function findMinimumOffset(arc) {\n      var start = arc[0],\n          end = arc[1],\n          mid = start,\n          minimum = mid,\n          minimumPoint = coordinates[mid];\n      while (++mid < end) {\n        var point = coordinates[mid];\n        if (point[0] < minimumPoint[0] || point[0] === minimumPoint[0] && point[1] < minimumPoint[1]) {\n          minimum = mid;\n          minimumPoint = point;\n        }\n      }\n      return minimum - start;\n    }\n    return topology;\n  }\n\n  function delta (arcs) {\n    var i = -1,\n        n = arcs.length;\n    while (++i < n) {\n      var arc = arcs[i],\n          j = 0,\n          k = 1,\n          m = arc.length,\n          point = arc[0],\n          x0 = point[0],\n          y0 = point[1],\n          x1,\n          y1;\n      while (++j < m) {\n        point = arc[j], x1 = point[0], y1 = point[1];\n        if (x1 !== x0 || y1 !== y0) arc[k++] = [x1 - x0, y1 - y0], x0 = x1, y0 = y1;\n      }\n      if (k === 1) arc[k++] = [0, 0];\n      arc.length = k;\n    }\n    return arcs;\n  }\n\n  function extract (objects) {\n    var index = -1,\n        lines = [],\n        rings = [],\n        coordinates = [];\n    function extractGeometry(geometry) {\n      if (geometry && extractGeometryType.hasOwnProperty(geometry.type)) extractGeometryType[geometry.type](geometry);\n    }\n    var extractGeometryType = {\n      GeometryCollection: function GeometryCollection(o) {\n        o.geometries.forEach(extractGeometry);\n      },\n      LineString: function LineString(o) {\n        o.arcs = extractLine(o.arcs);\n      },\n      MultiLineString: function MultiLineString(o) {\n        o.arcs = o.arcs.map(extractLine);\n      },\n      Polygon: function Polygon(o) {\n        o.arcs = o.arcs.map(extractRing);\n      },\n      MultiPolygon: function MultiPolygon(o) {\n        o.arcs = o.arcs.map(extractMultiRing);\n      }\n    };\n    function extractLine(line) {\n      for (var i = 0, n = line.length; i < n; ++i) {\n        coordinates[++index] = line[i];\n      }var arc = { 0: index - n + 1, 1: index };\n      lines.push(arc);\n      return arc;\n    }\n    function extractRing(ring) {\n      for (var i = 0, n = ring.length; i < n; ++i) {\n        coordinates[++index] = ring[i];\n      }var arc = { 0: index - n + 1, 1: index };\n      rings.push(arc);\n      return arc;\n    }\n    function extractMultiRing(rings) {\n      return rings.map(extractRing);\n    }\n    for (var key in objects) {\n      extractGeometry(objects[key]);\n    }\n    return {\n      type: \"Topology\",\n      coordinates: coordinates,\n      lines: lines,\n      rings: rings,\n      objects: objects\n    };\n  }\n\n  function geometry$2 (inputs) {\n    var outputs = {},\n        key;\n    for (key in inputs) {\n      outputs[key] = geomifyObject(inputs[key]);\n    }return outputs;\n  }\n  function geomifyObject(input) {\n    return input == null ? { type: null } : (input.type === \"FeatureCollection\" ? geomifyFeatureCollection : input.type === \"Feature\" ? geomifyFeature : geomifyGeometry)(input);\n  }\n  function geomifyFeatureCollection(input) {\n    var output = { type: \"GeometryCollection\", geometries: input.features.map(geomifyFeature) };\n    if (input.bbox != null) output.bbox = input.bbox;\n    return output;\n  }\n  function geomifyFeature(input) {\n    var output = geomifyGeometry(input.geometry),\n        key;\n    if (input.id != null) output.id = input.id;\n    if (input.bbox != null) output.bbox = input.bbox;\n    for (key in input.properties) {\n      output.properties = input.properties;break;\n    }\n    return output;\n  }\n  function geomifyGeometry(input) {\n    if (input == null) return { type: null };\n    var output = input.type === \"GeometryCollection\" ? { type: \"GeometryCollection\", geometries: input.geometries.map(geomifyGeometry) } : input.type === \"Point\" || input.type === \"MultiPoint\" ? { type: input.type, coordinates: input.coordinates } : { type: input.type, arcs: input.coordinates };\n    if (input.bbox != null) output.bbox = input.bbox;\n    return output;\n  }\n\n  function prequantize (objects, bbox, n) {\n    var x0 = bbox[0],\n        y0 = bbox[1],\n        x1 = bbox[2],\n        y1 = bbox[3],\n        kx = x1 - x0 ? (n - 1) / (x1 - x0) : 1,\n        ky = y1 - y0 ? (n - 1) / (y1 - y0) : 1;\n    function quantizePoint(input) {\n      return [Math.round((input[0] - x0) * kx), Math.round((input[1] - y0) * ky)];\n    }\n    function quantizePoints(input, m) {\n      var i = -1,\n          j = 0,\n          n = input.length,\n          output = new Array(n),\n      pi,\n          px,\n          py,\n          x,\n          y;\n      while (++i < n) {\n        pi = input[i];\n        x = Math.round((pi[0] - x0) * kx);\n        y = Math.round((pi[1] - y0) * ky);\n        if (x !== px || y !== py) output[j++] = [px = x, py = y];\n      }\n      output.length = j;\n      while (j < m) {\n        j = output.push([output[0][0], output[0][1]]);\n      }return output;\n    }\n    function quantizeLine(input) {\n      return quantizePoints(input, 2);\n    }\n    function quantizeRing(input) {\n      return quantizePoints(input, 4);\n    }\n    function quantizePolygon(input) {\n      return input.map(quantizeRing);\n    }\n    function quantizeGeometry(o) {\n      if (o != null && quantizeGeometryType.hasOwnProperty(o.type)) quantizeGeometryType[o.type](o);\n    }\n    var quantizeGeometryType = {\n      GeometryCollection: function GeometryCollection(o) {\n        o.geometries.forEach(quantizeGeometry);\n      },\n      Point: function Point(o) {\n        o.coordinates = quantizePoint(o.coordinates);\n      },\n      MultiPoint: function MultiPoint(o) {\n        o.coordinates = o.coordinates.map(quantizePoint);\n      },\n      LineString: function LineString(o) {\n        o.arcs = quantizeLine(o.arcs);\n      },\n      MultiLineString: function MultiLineString(o) {\n        o.arcs = o.arcs.map(quantizeLine);\n      },\n      Polygon: function Polygon(o) {\n        o.arcs = quantizePolygon(o.arcs);\n      },\n      MultiPolygon: function MultiPolygon(o) {\n        o.arcs = o.arcs.map(quantizePolygon);\n      }\n    };\n    for (var key in objects) {\n      quantizeGeometry(objects[key]);\n    }\n    return {\n      scale: [1 / kx, 1 / ky],\n      translate: [x0, y0]\n    };\n  }\n\n  function topology (objects, quantization) {\n    var bbox = bounds(objects = geometry$2(objects)),\n        transform = quantization > 0 && bbox && prequantize(objects, bbox, quantization),\n        topology = dedup$1(cut(extract(objects))),\n        coordinates = topology.coordinates,\n        indexByArc = hashmap(topology.arcs.length * 1.4, hashArc, equalArc);\n    objects = topology.objects;\n    topology.bbox = bbox;\n    topology.arcs = topology.arcs.map(function (arc, i) {\n      indexByArc.set(arc, i);\n      return coordinates.slice(arc[0], arc[1] + 1);\n    });\n    delete topology.coordinates;\n    coordinates = null;\n    function indexGeometry(geometry) {\n      if (geometry && indexGeometryType.hasOwnProperty(geometry.type)) indexGeometryType[geometry.type](geometry);\n    }\n    var indexGeometryType = {\n      GeometryCollection: function GeometryCollection(o) {\n        o.geometries.forEach(indexGeometry);\n      },\n      LineString: function LineString(o) {\n        o.arcs = indexArcs(o.arcs);\n      },\n      MultiLineString: function MultiLineString(o) {\n        o.arcs = o.arcs.map(indexArcs);\n      },\n      Polygon: function Polygon(o) {\n        o.arcs = o.arcs.map(indexArcs);\n      },\n      MultiPolygon: function MultiPolygon(o) {\n        o.arcs = o.arcs.map(indexMultiArcs);\n      }\n    };\n    function indexArcs(arc) {\n      var indexes = [];\n      do {\n        var index = indexByArc.get(arc);\n        indexes.push(arc[0] < arc[1] ? index : ~index);\n      } while (arc = arc.next);\n      return indexes;\n    }\n    function indexMultiArcs(arcs) {\n      return arcs.map(indexArcs);\n    }\n    for (var key in objects) {\n      indexGeometry(objects[key]);\n    }\n    if (transform) {\n      topology.transform = transform;\n      topology.arcs = delta(topology.arcs);\n    }\n    return topology;\n  }\n  function hashArc(arc) {\n    var i = arc[0],\n        j = arc[1],\n        t;\n    if (j < i) t = i, i = j, j = t;\n    return i + 31 * j;\n  }\n  function equalArc(arcA, arcB) {\n    var ia = arcA[0],\n        ja = arcA[1],\n        ib = arcB[0],\n        jb = arcB[1],\n        t;\n    if (ja < ia) t = ia, ia = ja, ja = t;\n    if (jb < ib) t = ib, ib = jb, jb = t;\n    return ia === ib && ja === jb;\n  }\n\n  function polygonDissolve(geojson, options) {\n      options = options || {};\n      if (!isObject$2(options)) throw new Error('options is invalid');\n      var mutate = options.mutate;\n      if (getType(geojson) !== 'FeatureCollection') throw new Error('geojson must be a FeatureCollection');\n      if (!geojson.features.length) throw new Error('geojson is empty');\n      if (mutate === false || mutate === undefined) geojson = clone(geojson);\n      var geoms = [];\n      flattenEach$1(geojson, function (feature) {\n          geoms.push(feature.geometry);\n      });\n      var topo = topology({ geoms: geometryCollection$1(geoms).geometry });\n      return merge(topo, topo.objects.geoms.geometries);\n  }\n\n  function dissolve(geojson, options) {\n      options = options || {};\n      if (!isObject$2(options)) throw new Error('options is invalid');\n      var mutate = options.mutate;\n      if (getType(geojson) !== 'FeatureCollection') throw new Error('geojson must be a FeatureCollection');\n      if (!geojson.features.length) throw new Error('geojson is empty');\n      if (mutate === false || mutate === undefined) geojson = clone(geojson);\n      var type = getHomogenousType(geojson);\n      if (!type) throw new Error('geojson must be homogenous');\n      switch (type) {\n          case 'LineString':\n              return lineDissolve(geojson, options);\n          case 'Polygon':\n              return polygonDissolve(geojson, options);\n          default:\n              throw new Error(type + ' is not supported');\n      }\n  }\n  function getHomogenousType(geojson) {\n      var types = {};\n      flattenEach$1(geojson, function (feature) {\n          types[feature.geometry.type] = true;\n      });\n      var keys = Object.keys(types);\n      if (keys.length === 1) return keys[0];\n      return null;\n  }\n\n  function distance(from, to, options) {\n    options = options || {};\n    if (!isObject$2(options)) throw new Error('options is invalid');\n    var units = options.units;\n    var coordinates1 = getCoord(from);\n    var coordinates2 = getCoord(to);\n    var dLat = degreesToRadians$1(coordinates2[1] - coordinates1[1]);\n    var dLon = degreesToRadians$1(coordinates2[0] - coordinates1[0]);\n    var lat1 = degreesToRadians$1(coordinates1[1]);\n    var lat2 = degreesToRadians$1(coordinates2[1]);\n    var a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n    return radiansToLength$1(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), units);\n  }\n\n  function concave(points, options) {\n      options = options || {};\n      if (!isObject$2(options)) throw new Error('options is invalid');\n      if (!points) throw new Error('points is required');\n      var maxEdge = options.maxEdge || Infinity;\n      if (!isNumber$1(maxEdge)) throw new Error('maxEdge is invalid');\n      var cleaned = removeDuplicates(points);\n      var tinPolys = tin(cleaned);\n      tinPolys.features = tinPolys.features.filter(function (triangle) {\n          var pt1 = triangle.geometry.coordinates[0][0];\n          var pt2 = triangle.geometry.coordinates[0][1];\n          var pt3 = triangle.geometry.coordinates[0][2];\n          var dist1 = distance(pt1, pt2, options);\n          var dist2 = distance(pt2, pt3, options);\n          var dist3 = distance(pt1, pt3, options);\n          return dist1 <= maxEdge && dist2 <= maxEdge && dist3 <= maxEdge;\n      });\n      if (tinPolys.features.length < 1) return null;\n      var dissolved = dissolve(tinPolys, options);\n      if (dissolved.coordinates.length === 1) {\n          dissolved.coordinates = dissolved.coordinates[0];\n          dissolved.type = 'Polygon';\n      }\n      return feature$1(dissolved);\n  }\n  function removeDuplicates(points) {\n      var cleaned = [];\n      var existing = {};\n      featureEach$1(points, function (pt) {\n          if (!pt.geometry) return;\n          var key = pt.geometry.coordinates.join('-');\n          if (!existing.hasOwnProperty(key)) {\n              cleaned.push(pt);\n              existing[key] = true;\n          }\n      });\n      return featureCollection$1(cleaned);\n  }\n\n  function concave$1(latLngArray, maxEdge, units) {\n    var FeatureCollection = arrayToFeaturePoints(latLngArray);\n    return concave(FeatureCollection, {\n      maxEdge: maxEdge,\n      units: units\n    });\n  }\n\n  function feature$4(geometry, properties, options) {\n      options = options || {};\n      if (!isObject$3(options)) throw new Error('options is invalid');\n      var bbox = options.bbox;\n      var id = options.id;\n      if (geometry === undefined) throw new Error('geometry is required');\n      if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n      if (bbox) validateBBox$1(bbox);\n      if (id) validateId$1(id);\n      var feat = { type: 'Feature' };\n      if (id) feat.id = id;\n      if (bbox) feat.bbox = bbox;\n      feat.properties = properties || {};\n      feat.geometry = geometry;\n      return feat;\n  }\n  function isNumber$2(num) {\n      return !isNaN(num) && num !== null && !Array.isArray(num);\n  }\n  function isObject$3(input) {\n      return !!input && input.constructor === Object;\n  }\n  function validateBBox$1(bbox) {\n      if (!bbox) throw new Error('bbox is required');\n      if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n      if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n      bbox.forEach(function (num) {\n          if (!isNumber$2(num)) throw new Error('bbox must only contain numbers');\n      });\n  }\n  function validateId$1(id) {\n      if (!id) throw new Error('id is required');\n      if (['string', 'number'].indexOf(typeof id === 'undefined' ? 'undefined' : _typeof(id)) === -1) throw new Error('id must be a number or a string');\n  }\n\n  function getCoords$1(coords) {\n      if (!coords) throw new Error('coords is required');\n      if (coords.type === 'Feature' && coords.geometry !== null) return coords.geometry.coordinates;\n      if (coords.coordinates) return coords.coordinates;\n      if (Array.isArray(coords)) return coords;\n      throw new Error('coords must be GeoJSON Feature, Geometry Object or an Array');\n  }\n  function getType$1(geojson, name) {\n      if (!geojson) throw new Error((name || 'geojson') + ' is required');\n      if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n      if (geojson.type) return geojson.type;\n      throw new Error((name || 'geojson') + ' is invalid');\n  }\n\n  function cleanCoords(geojson, options) {\n      var mutate = (typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object' ? options.mutate : options;\n      if (!geojson) throw new Error('geojson is required');\n      var type = getType$1(geojson);\n      var newCoords = [];\n      switch (type) {\n          case 'LineString':\n              newCoords = cleanLine(geojson);\n              break;\n          case 'MultiLineString':\n          case 'Polygon':\n              getCoords$1(geojson).forEach(function (line) {\n                  newCoords.push(cleanLine(line));\n              });\n              break;\n          case 'MultiPolygon':\n              getCoords$1(geojson).forEach(function (polygons) {\n                  var polyPoints = [];\n                  polygons.forEach(function (ring) {\n                      polyPoints.push(cleanLine(ring));\n                  });\n                  newCoords.push(polyPoints);\n              });\n              break;\n          case 'Point':\n              return geojson;\n          case 'MultiPoint':\n              var existing = {};\n              getCoords$1(geojson).forEach(function (coord) {\n                  var key = coord.join('-');\n                  if (!existing.hasOwnProperty(key)) {\n                      newCoords.push(coord);\n                      existing[key] = true;\n                  }\n              });\n              break;\n          default:\n              throw new Error(type + ' geometry not supported');\n      }\n      if (geojson.coordinates) {\n          if (mutate === true) {\n              geojson.coordinates = newCoords;\n              return geojson;\n          }\n          return { type: type, coordinates: newCoords };\n      } else {\n          if (mutate === true) {\n              geojson.geometry.coordinates = newCoords;\n              return geojson;\n          }\n          return feature$4({ type: type, coordinates: newCoords }, geojson.properties, geojson.bbox, geojson.id);\n      }\n  }\n  function cleanLine(line) {\n      var points = getCoords$1(line);\n      if (points.length === 2 && !equals(points[0], points[1])) return points;\n      var prevPoint, point, nextPoint;\n      var newPoints = [];\n      var secondToLast = points.length - 1;\n      newPoints.push(points[0]);\n      for (var i = 1; i < secondToLast; i++) {\n          prevPoint = points[i - 1];\n          point = points[i];\n          nextPoint = points[i + 1];\n          if (!isPointOnLineSegment(prevPoint, nextPoint, point)) {\n              newPoints.push(point);\n          }\n      }\n      newPoints.push(nextPoint);\n      return newPoints;\n  }\n  function equals(pt1, pt2) {\n      return pt1[0] === pt2[0] && pt1[1] === pt2[1];\n  }\n  function isPointOnLineSegment(start, end, point) {\n      var x = point[0],\n          y = point[1];\n      var startX = start[0],\n          startY = start[1];\n      var endX = end[0],\n          endY = end[1];\n      var dxc = x - startX;\n      var dyc = y - startY;\n      var dxl = endX - startX;\n      var dyl = endY - startY;\n      var cross = dxc * dyl - dyc * dxl;\n      if (cross !== 0) return false;else if (Math.abs(dxl) >= Math.abs(dyl)) return dxl > 0 ? startX <= x && x <= endX : endX <= x && x <= startX;else return dyl > 0 ? startY <= y && y <= endY : endY <= y && y <= startY;\n  }\n\n  function clone$1(geojson) {\n      if (!geojson) throw new Error('geojson is required');\n      switch (geojson.type) {\n          case 'Feature':\n              return cloneFeature$1(geojson);\n          case 'FeatureCollection':\n              return cloneFeatureCollection$1(geojson);\n          case 'Point':\n          case 'LineString':\n          case 'Polygon':\n          case 'MultiPoint':\n          case 'MultiLineString':\n          case 'MultiPolygon':\n          case 'GeometryCollection':\n              return cloneGeometry$1(geojson);\n          default:\n              throw new Error('unknown GeoJSON type');\n      }\n  }\n  function cloneFeature$1(geojson) {\n      var cloned = { type: 'Feature' };\n      Object.keys(geojson).forEach(function (key) {\n          switch (key) {\n              case 'type':\n              case 'properties':\n              case 'geometry':\n                  return;\n              default:\n                  cloned[key] = geojson[key];\n          }\n      });\n      cloned.properties = cloneProperties$1(geojson.properties);\n      cloned.geometry = cloneGeometry$1(geojson.geometry);\n      return cloned;\n  }\n  function cloneProperties$1(properties) {\n      var cloned = {};\n      if (!properties) return cloned;\n      Object.keys(properties).forEach(function (key) {\n          var value = properties[key];\n          if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\n              if (value === null) {\n                  cloned[key] = null;\n              } else if (value.length) {\n                  cloned[key] = value.map(function (item) {\n                      return item;\n                  });\n              } else {\n                  cloned[key] = cloneProperties$1(value);\n              }\n          } else cloned[key] = value;\n      });\n      return cloned;\n  }\n  function cloneFeatureCollection$1(geojson) {\n      var cloned = { type: 'FeatureCollection' };\n      Object.keys(geojson).forEach(function (key) {\n          switch (key) {\n              case 'type':\n              case 'features':\n                  return;\n              default:\n                  cloned[key] = geojson[key];\n          }\n      });\n      cloned.features = geojson.features.map(function (feature) {\n          return cloneFeature$1(feature);\n      });\n      return cloned;\n  }\n  function cloneGeometry$1(geometry) {\n      var geom = { type: geometry.type };\n      if (geometry.bbox) geom.bbox = geometry.bbox;\n      if (geometry.type === 'GeometryCollection') {\n          geom.geometries = geometry.geometries.map(function (geom) {\n              return cloneGeometry$1(geom);\n          });\n          return geom;\n      }\n      geom.coordinates = deepSlice$1(geometry.coordinates);\n      return geom;\n  }\n  function deepSlice$1(coords) {\n      if (_typeof(coords[0]) !== 'object') {\n          return coords.slice();\n      }\n      return coords.map(function (coord) {\n          return deepSlice$1(coord);\n      });\n  }\n\n  function isObject$4(input) {\n      return !!input && input.constructor === Object;\n  }\n\n  function geomEach$2(geojson, callback) {\n      var i,\n          j,\n          g,\n          geometry,\n          stopG,\n          geometryMaybeCollection,\n          isGeometryCollection,\n          featureProperties,\n          featureBBox,\n          featureId,\n          featureIndex = 0,\n          isFeatureCollection = geojson.type === 'FeatureCollection',\n          isFeature = geojson.type === 'Feature',\n          stop = isFeatureCollection ? geojson.features.length : 1;\n      for (i = 0; i < stop; i++) {\n          geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;\n          featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};\n          featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : undefined;\n          featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : undefined;\n          isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n          stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n          for (g = 0; g < stopG; g++) {\n              geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n              if (geometry === null) {\n                  if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                  continue;\n              }\n              switch (geometry.type) {\n                  case 'Point':\n                  case 'LineString':\n                  case 'MultiPoint':\n                  case 'Polygon':\n                  case 'MultiLineString':\n                  case 'MultiPolygon':\n                      {\n                          if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                          break;\n                      }\n                  case 'GeometryCollection':\n                      {\n                          for (j = 0; j < geometry.geometries.length; j++) {\n                              if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                          }\n                          break;\n                      }\n                  default:\n                      throw new Error('Unknown Geometry Type');\n              }\n          }\n          featureIndex++;\n      }\n  }\n\n  function getSqDist(p1, p2) {\n      var dx = p1.x - p2.x,\n          dy = p1.y - p2.y;\n      return dx * dx + dy * dy;\n  }\n  function getSqSegDist(p, p1, p2) {\n      var x = p1.x,\n          y = p1.y,\n          dx = p2.x - x,\n          dy = p2.y - y;\n      if (dx !== 0 || dy !== 0) {\n          var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);\n          if (t > 1) {\n              x = p2.x;\n              y = p2.y;\n          } else if (t > 0) {\n              x += dx * t;\n              y += dy * t;\n          }\n      }\n      dx = p.x - x;\n      dy = p.y - y;\n      return dx * dx + dy * dy;\n  }\n  function simplifyRadialDist(points, sqTolerance) {\n      var prevPoint = points[0],\n          newPoints = [prevPoint],\n          point;\n      for (var i = 1, len = points.length; i < len; i++) {\n          point = points[i];\n          if (getSqDist(point, prevPoint) > sqTolerance) {\n              newPoints.push(point);\n              prevPoint = point;\n          }\n      }\n      if (prevPoint !== point) newPoints.push(point);\n      return newPoints;\n  }\n  function simplifyDPStep(points, first, last, sqTolerance, simplified) {\n      var maxSqDist = sqTolerance,\n          index;\n      for (var i = first + 1; i < last; i++) {\n          var sqDist = getSqSegDist(points[i], points[first], points[last]);\n          if (sqDist > maxSqDist) {\n              index = i;\n              maxSqDist = sqDist;\n          }\n      }\n      if (maxSqDist > sqTolerance) {\n          if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);\n          simplified.push(points[index]);\n          if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);\n      }\n  }\n  function simplifyDouglasPeucker(points, sqTolerance) {\n      var last = points.length - 1;\n      var simplified = [points[0]];\n      simplifyDPStep(points, 0, last, sqTolerance, simplified);\n      simplified.push(points[last]);\n      return simplified;\n  }\n  function simplify$2(points, tolerance, highestQuality) {\n      if (points.length <= 2) return points;\n      var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;\n      points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);\n      points = simplifyDouglasPeucker(points, sqTolerance);\n      return points;\n  }\n  function simplify(geojson, options) {\n      options = options || {};\n      if (!isObject$4(options)) throw new Error('options is invalid');\n      var tolerance = options.tolerance !== undefined ? options.tolerance : 1;\n      var highQuality = options.highQuality || false;\n      var mutate = options.mutate || false;\n      if (!geojson) throw new Error('geojson is required');\n      if (tolerance && tolerance < 0) throw new Error('invalid tolerance');\n      if (mutate !== true) geojson = clone$1(geojson);\n      geomEach$2(geojson, function (geom) {\n          simplifyGeom(geom, tolerance, highQuality);\n      });\n      return geojson;\n  }\n  function simplifyGeom(geometry, tolerance, highQuality) {\n      var type = geometry.type;\n      if (type === 'Point' || type === 'MultiPoint') return geometry;\n      cleanCoords(geometry, true);\n      var coordinates = geometry.coordinates;\n      switch (type) {\n          case 'LineString':\n              geometry['coordinates'] = simplifyLine(coordinates, tolerance, highQuality);\n              break;\n          case 'MultiLineString':\n              geometry['coordinates'] = coordinates.map(function (lines) {\n                  return simplifyLine(lines, tolerance, highQuality);\n              });\n              break;\n          case 'Polygon':\n              geometry['coordinates'] = simplifyPolygon(coordinates, tolerance, highQuality);\n              break;\n          case 'MultiPolygon':\n              geometry['coordinates'] = coordinates.map(function (rings) {\n                  return simplifyPolygon(rings, tolerance, highQuality);\n              });\n      }\n      return geometry;\n  }\n  function simplifyLine(coordinates, tolerance, highQuality) {\n      return simplify$2(coordinates.map(function (coord) {\n          return { x: coord[0], y: coord[1], z: coord[2] };\n      }), tolerance, highQuality).map(function (coords) {\n          return coords.z ? [coords.x, coords.y, coords.z] : [coords.x, coords.y];\n      });\n  }\n  function simplifyPolygon(coordinates, tolerance, highQuality) {\n      return coordinates.map(function (ring) {\n          var pts = ring.map(function (coord) {\n              return { x: coord[0], y: coord[1] };\n          });\n          if (pts.length < 4) {\n              throw new Error('invalid polygon');\n          }\n          var simpleRing = simplify$2(pts, tolerance, highQuality).map(function (coords) {\n              return [coords.x, coords.y];\n          });\n          while (!checkValidity(simpleRing)) {\n              tolerance -= tolerance * 0.01;\n              simpleRing = simplify$2(pts, tolerance, highQuality).map(function (coords) {\n                  return [coords.x, coords.y];\n              });\n          }\n          if (simpleRing[simpleRing.length - 1][0] !== simpleRing[0][0] || simpleRing[simpleRing.length - 1][1] !== simpleRing[0][1]) {\n              simpleRing.push(simpleRing[0]);\n          }\n          return simpleRing;\n      });\n  }\n  function checkValidity(ring) {\n      if (ring.length < 3) return false;\n      return !(ring.length === 3 && ring[2][0] === ring[0][0] && ring[2][1] === ring[0][1]);\n  }\n\n  function simplifyPointArray(coordArray, tolerance, highQuality) {\n  \ttolerance = tolerance || 0.00001;\n  \thighQuality = highQuality || false;\n  \tvar Feature = lineString$1(toCoords(coordArray));\n  \tvar simplifiedgeom = simplify(Feature, tolerance, highQuality);\n  \treturn simplifiedgeom.geometry.coordinates;\n  }function simplifyFeature(object, output, tolerance, highQuality) {\n  \toutput = (output || 'feature').toLowerCase();\n  \tvar Feature;\n  \tif (object instanceof google.maps.Polyline || object instanceof google.maps.Polygon) {\n  \t\tvar geometry = Wicket$1().fromObject(object).toJson();\n  \t\tFeature = {\n  \t\t\ttype: \"Feature\",\n  \t\t\tproperties: {},\n  \t\t\tgeometry: geometry\n  \t\t};\n  \t} else if (object.type && object.type === 'Feature' && object.geometry) {\n  \t\tFeature = object;\n  \t} else {\n  \t\tFeature = polygonToFeaturePolygon(object);\n  \t}\n  \tif (Feature.geometry.type === 'MultiPolygon') {\n  \t\tFeature.geometry.type = 'Polygon';\n  \t\tFeature.geometry.coordinates = Feature.geometry.coordinates[0];\n  \t}\n  \tvar simplifiedgeom = simplify(Feature, tolerance, highQuality);\n  \tif (simplifiedgeom && simplifiedgeom.geometry) {\n  \t\tFeature = simplifiedgeom;\n  \t} else {\n  \t\twarn('Cannot simplify  Feature', Feature);\n  \t}\n  \tif (output === 'geometry') {\n  \t\treturn Feature.geometry;\n  \t} else if (output === 'object') {\n  \t\treturn Wicket$1().fromJson(Feature.geometry).toObject();\n  \t} else {\n  \t\treturn Feature;\n  \t}\n  }\n\n  function bearing(start, end, options) {\n      options = options || {};\n      if (!isObject$2(options)) throw new Error('options is invalid');\n      var final = options.final;\n      if (final === true) return calculateFinalBearing(start, end);\n      var coordinates1 = getCoord(start);\n      var coordinates2 = getCoord(end);\n      var lon1 = degreesToRadians$1(coordinates1[0]);\n      var lon2 = degreesToRadians$1(coordinates2[0]);\n      var lat1 = degreesToRadians$1(coordinates1[1]);\n      var lat2 = degreesToRadians$1(coordinates2[1]);\n      var a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n      var b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n      return radiansToDegrees$1(Math.atan2(a, b));\n  }\n  function calculateFinalBearing(start, end) {\n      var bear = bearing(end, start);\n      bear = (bear + 180) % 360;\n      return bear;\n  }\n\n  function destination(origin, distance, bearing, options) {\n      options = options || {};\n      if (!isObject$2(options)) throw new Error('options is invalid');\n      var units = options.units;\n      var coordinates1 = getCoord(origin);\n      var longitude1 = degreesToRadians$1(coordinates1[0]);\n      var latitude1 = degreesToRadians$1(coordinates1[1]);\n      var bearing_rad = degreesToRadians$1(bearing);\n      var radians = lengthToRadians$1(distance, units);\n      var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) + Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearing_rad));\n      var longitude2 = longitude1 + Math.atan2(Math.sin(bearing_rad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));\n      return point$1([radiansToDegrees$1(longitude2), radiansToDegrees$1(latitude2)]);\n  }\n\n  function along(line, distance$$1, options) {\n      options = options || {};\n      if (!isObject$2(options)) throw new Error('options is invalid');\n      var coords;\n      if (line.type === 'Feature') coords = line.geometry.coordinates;else if (line.type === 'LineString') coords = line.coordinates;else throw new Error('input must be a LineString Feature or Geometry');\n      if (!isNumber$1(distance$$1)) throw new Error('distance must be a number');\n      var travelled = 0;\n      for (var i = 0; i < coords.length; i++) {\n          if (distance$$1 >= travelled && i === coords.length - 1) break;else if (travelled >= distance$$1) {\n              var overshot = distance$$1 - travelled;\n              if (!overshot) return point$1(coords[i]);else {\n                  var direction = bearing(coords[i], coords[i - 1]) - 180;\n                  var interpolated = destination(coords[i], overshot, direction, options);\n                  return interpolated;\n              }\n          } else {\n              travelled += distance(coords[i], coords[i + 1], options);\n          }\n      }\n      return point$1(coords[coords.length - 1]);\n  }\n\n  function along$1(object, distance, units) {\n  \tvar Feature;\n  \tif (object instanceof google.maps.Polyline) {\n  \t\tvar geometry = Wicket$1().fromObject(object).toJson();\n  \t\tFeature = {\n  \t\t\ttype: \"Feature\",\n  \t\t\tproperties: {},\n  \t\t\tgeometry: geometry\n  \t\t};\n  \t} else if (object.type && object.type === 'Feature' && object.geometry) {\n  \t\tFeature = object;\n  \t} else {\n  \t\tvar arrayCoords = toCoords(object);\n  \t\tFeature = lineString$1(arrayCoords);\n  \t}\n  \treturn along(Feature, distance, units);\n  }\n\n  function extend (target, source) {\n    for (var key in source) {\n      if (source.hasOwnProperty(key)) target[key] = source[key];\n    }\n  }\n\n  function NumberUtil() {}\n  extend(NumberUtil.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn NumberUtil;\n  \t}\n  });\n  NumberUtil.equalsWithTolerance = function (x1, x2, tolerance) {\n  \treturn Math.abs(x1 - x2) <= tolerance;\n  };\n\n  function IllegalArgumentException() {}\n\n  function Double() {}\n  Double.isNaN = function (n) {\n    return Number.isNaN(n);\n  };\n  Double.doubleToLongBits = function (n) {\n    return n;\n  };\n  Double.longBitsToDouble = function (n) {\n    return n;\n  };\n  Double.isInfinite = function (n) {\n    return !Number.isFinite(n);\n  };\n  Double.MAX_VALUE = Number.MAX_VALUE;\n\n  function Comparable() {}\n\n  function Clonable() {}\n\n  function Comparator() {}\n\n  function Serializable() {}\n\n  function RuntimeException(message) {\n    this.name = 'RuntimeException';\n    this.message = message;\n    this.stack = new Error().stack;\n    Error.call(this, message);\n  }\n  RuntimeException.prototype = Object.create(Error.prototype);\n  RuntimeException.prototype.constructor = Error;\n\n  function inherits$1 (c, p) {\n    c.prototype = Object.create(p.prototype);\n    c.prototype.constructor = c;\n  }\n\n  function AssertionFailedException() {\n  \tif (arguments.length === 0) {\n  \t\tRuntimeException.call(this);\n  \t} else if (arguments.length === 1) {\n  \t\tvar message = arguments[0];\n  \t\tRuntimeException.call(this, message);\n  \t}\n  }\n  inherits$1(AssertionFailedException, RuntimeException);\n  extend(AssertionFailedException.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn AssertionFailedException;\n  \t}\n  });\n\n  function Assert() {}\n  extend(Assert.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Assert;\n  \t}\n  });\n  Assert.shouldNeverReachHere = function () {\n  \tif (arguments.length === 0) {\n  \t\tAssert.shouldNeverReachHere(null);\n  \t} else if (arguments.length === 1) {\n  \t\tvar message = arguments[0];\n  \t\tthrow new AssertionFailedException(\"Should never reach here\" + (message !== null ? \": \" + message : \"\"));\n  \t}\n  };\n  Assert.isTrue = function () {\n  \tif (arguments.length === 1) {\n  \t\tvar assertion = arguments[0];\n  \t\tAssert.isTrue(assertion, null);\n  \t} else if (arguments.length === 2) {\n  \t\tvar assertion = arguments[0],\n  \t\t    message = arguments[1];\n  \t\tif (!assertion) {\n  \t\t\tif (message === null) {\n  \t\t\t\tthrow new AssertionFailedException();\n  \t\t\t} else {\n  \t\t\t\tthrow new AssertionFailedException(message);\n  \t\t\t}\n  \t\t}\n  \t}\n  };\n  Assert.equals = function () {\n  \tif (arguments.length === 2) {\n  \t\tvar expectedValue = arguments[0],\n  \t\t    actualValue = arguments[1];\n  \t\tAssert.equals(expectedValue, actualValue, null);\n  \t} else if (arguments.length === 3) {\n  \t\tvar expectedValue = arguments[0],\n  \t\t    actualValue = arguments[1],\n  \t\t    message = arguments[2];\n  \t\tif (!actualValue.equals(expectedValue)) {\n  \t\t\tthrow new AssertionFailedException(\"Expected \" + expectedValue + \" but encountered \" + actualValue + (message !== null ? \": \" + message : \"\"));\n  \t\t}\n  \t}\n  };\n\n  function Coordinate() {\n  \tthis.x = null;\n  \tthis.y = null;\n  \tthis.z = null;\n  \tif (arguments.length === 0) {\n  \t\tCoordinate.call(this, 0.0, 0.0);\n  \t} else if (arguments.length === 1) {\n  \t\tvar c = arguments[0];\n  \t\tCoordinate.call(this, c.x, c.y, c.z);\n  \t} else if (arguments.length === 2) {\n  \t\tvar x = arguments[0],\n  \t\t    y = arguments[1];\n  \t\tCoordinate.call(this, x, y, Coordinate.NULL_ORDINATE);\n  \t} else if (arguments.length === 3) {\n  \t\tvar x = arguments[0],\n  \t\t    y = arguments[1],\n  \t\t    z = arguments[2];\n  \t\tthis.x = x;\n  \t\tthis.y = y;\n  \t\tthis.z = z;\n  \t}\n  }\n  extend(Coordinate.prototype, {\n  \tsetOrdinate: function setOrdinate(ordinateIndex, value) {\n  \t\tswitch (ordinateIndex) {\n  \t\t\tcase Coordinate.X:\n  \t\t\t\tthis.x = value;\n  \t\t\t\tbreak;\n  \t\t\tcase Coordinate.Y:\n  \t\t\t\tthis.y = value;\n  \t\t\t\tbreak;\n  \t\t\tcase Coordinate.Z:\n  \t\t\t\tthis.z = value;\n  \t\t\t\tbreak;\n  \t\t\tdefault:\n  \t\t\t\tthrow new IllegalArgumentException(\"Invalid ordinate index: \" + ordinateIndex);\n  \t\t}\n  \t},\n  \tequals2D: function equals2D() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar other = arguments[0];\n  \t\t\tif (this.x !== other.x) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t\tif (this.y !== other.y) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t\treturn true;\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar c = arguments[0],\n  \t\t\t    tolerance = arguments[1];\n  \t\t\tif (!NumberUtil.equalsWithTolerance(this.x, c.x, tolerance)) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t\tif (!NumberUtil.equalsWithTolerance(this.y, c.y, tolerance)) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t\treturn true;\n  \t\t}\n  \t},\n  \tgetOrdinate: function getOrdinate(ordinateIndex) {\n  \t\tswitch (ordinateIndex) {\n  \t\t\tcase Coordinate.X:\n  \t\t\t\treturn this.x;\n  \t\t\tcase Coordinate.Y:\n  \t\t\t\treturn this.y;\n  \t\t\tcase Coordinate.Z:\n  \t\t\t\treturn this.z;\n  \t\t}\n  \t\tthrow new IllegalArgumentException(\"Invalid ordinate index: \" + ordinateIndex);\n  \t},\n  \tequals3D: function equals3D(other) {\n  \t\treturn this.x === other.x && this.y === other.y && (this.z === other.z || Double.isNaN(this.z) && Double.isNaN(other.z));\n  \t},\n  \tequals: function equals(other) {\n  \t\tif (!(other instanceof Coordinate)) {\n  \t\t\treturn false;\n  \t\t}\n  \t\treturn this.equals2D(other);\n  \t},\n  \tequalInZ: function equalInZ(c, tolerance) {\n  \t\treturn NumberUtil.equalsWithTolerance(this.z, c.z, tolerance);\n  \t},\n  \tcompareTo: function compareTo(o) {\n  \t\tvar other = o;\n  \t\tif (this.x < other.x) return -1;\n  \t\tif (this.x > other.x) return 1;\n  \t\tif (this.y < other.y) return -1;\n  \t\tif (this.y > other.y) return 1;\n  \t\treturn 0;\n  \t},\n  \tclone: function clone() {\n  \t\ttry {\n  \t\t\tvar coord = null;\n  \t\t\treturn coord;\n  \t\t} catch (e) {\n  \t\t\tif (e instanceof CloneNotSupportedException) {\n  \t\t\t\tAssert.shouldNeverReachHere(\"this shouldn't happen because this class is Cloneable\");\n  \t\t\t\treturn null;\n  \t\t\t} else throw e;\n  \t\t} finally {}\n  \t},\n  \tcopy: function copy() {\n  \t\treturn new Coordinate(this);\n  \t},\n  \ttoString: function toString() {\n  \t\treturn \"(\" + this.x + \", \" + this.y + \", \" + this.z + \")\";\n  \t},\n  \tdistance3D: function distance3D(c) {\n  \t\tvar dx = this.x - c.x;\n  \t\tvar dy = this.y - c.y;\n  \t\tvar dz = this.z - c.z;\n  \t\treturn Math.sqrt(dx * dx + dy * dy + dz * dz);\n  \t},\n  \tdistance: function distance(c) {\n  \t\tvar dx = this.x - c.x;\n  \t\tvar dy = this.y - c.y;\n  \t\treturn Math.sqrt(dx * dx + dy * dy);\n  \t},\n  \thashCode: function hashCode() {\n  \t\tvar result = 17;\n  \t\tresult = 37 * result + Coordinate.hashCode(this.x);\n  \t\tresult = 37 * result + Coordinate.hashCode(this.y);\n  \t\treturn result;\n  \t},\n  \tsetCoordinate: function setCoordinate(other) {\n  \t\tthis.x = other.x;\n  \t\tthis.y = other.y;\n  \t\tthis.z = other.z;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparable, Clonable, Serializable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Coordinate;\n  \t}\n  });\n  Coordinate.hashCode = function () {\n  \tif (arguments.length === 1) {\n  \t\tvar x = arguments[0];\n  \t\tvar f = Double.doubleToLongBits(x);\n  \t\treturn Math.trunc(f ^ f >>> 32);\n  \t}\n  };\n  function DimensionalComparator() {\n  \tthis._dimensionsToTest = 2;\n  \tif (arguments.length === 0) {\n  \t\tDimensionalComparator.call(this, 2);\n  \t} else if (arguments.length === 1) {\n  \t\tvar dimensionsToTest = arguments[0];\n  \t\tif (dimensionsToTest !== 2 && dimensionsToTest !== 3) throw new IllegalArgumentException(\"only 2 or 3 dimensions may be specified\");\n  \t\tthis._dimensionsToTest = dimensionsToTest;\n  \t}\n  }\n  extend(DimensionalComparator.prototype, {\n  \tcompare: function compare(o1, o2) {\n  \t\tvar c1 = o1;\n  \t\tvar c2 = o2;\n  \t\tvar compX = DimensionalComparator.compare(c1.x, c2.x);\n  \t\tif (compX !== 0) return compX;\n  \t\tvar compY = DimensionalComparator.compare(c1.y, c2.y);\n  \t\tif (compY !== 0) return compY;\n  \t\tif (this._dimensionsToTest <= 2) return 0;\n  \t\tvar compZ = DimensionalComparator.compare(c1.z, c2.z);\n  \t\treturn compZ;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparator];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn DimensionalComparator;\n  \t}\n  });\n  DimensionalComparator.compare = function (a, b) {\n  \tif (a < b) return -1;\n  \tif (a > b) return 1;\n  \tif (Double.isNaN(a)) {\n  \t\tif (Double.isNaN(b)) return 0;\n  \t\treturn -1;\n  \t}\n  \tif (Double.isNaN(b)) return 1;\n  \treturn 0;\n  };\n  Coordinate.DimensionalComparator = DimensionalComparator;\n  Coordinate.serialVersionUID = 6683108902428366910;\n  Coordinate.NULL_ORDINATE = Double.NaN;\n  Coordinate.X = 0;\n  Coordinate.Y = 1;\n  Coordinate.Z = 2;\n\n  function Iterator() {}Iterator.prototype.hasNext = function () {};\n  Iterator.prototype.next = function () {};\n  Iterator.prototype.remove = function () {};\n\n  function Collection() {}Collection.prototype.add = function () {};\n  Collection.prototype.addAll = function () {};\n  Collection.prototype.isEmpty = function () {};\n  Collection.prototype.iterator = function () {};\n  Collection.prototype.size = function () {};\n  Collection.prototype.toArray = function () {};\n  Collection.prototype.remove = function () {};\n\n  function IndexOutOfBoundsException$1(message) {\n    this.message = message || '';\n  }IndexOutOfBoundsException$1.prototype = new Error();\n  IndexOutOfBoundsException$1.prototype.name = 'IndexOutOfBoundsException';\n\n  function List() {}List.prototype = Object.create(Collection.prototype);\n  List.prototype.constructor = List;\n  List.prototype.get = function () {};\n  List.prototype.set = function () {};\n  List.prototype.isEmpty = function () {};\n\n  function NoSuchElementException(message) {\n    this.message = message || '';\n  }NoSuchElementException.prototype = new Error();\n  NoSuchElementException.prototype.name = 'NoSuchElementException';\n\n  function OperationNotSupported(message) {\n    this.message = message || '';\n  }OperationNotSupported.prototype = new Error();\n  OperationNotSupported.prototype.name = 'OperationNotSupported';\n\n  function ArrayList() {\n    this.array_ = [];\n    if (arguments[0] instanceof Collection) {\n      this.addAll(arguments[0]);\n    }\n  }ArrayList.prototype = Object.create(List.prototype);\n  ArrayList.prototype.constructor = ArrayList;\n  ArrayList.prototype.ensureCapacity = function () {};\n  ArrayList.prototype.interfaces_ = function () {\n    return [List, Collection];\n  };\n  ArrayList.prototype.add = function (e) {\n    if (arguments.length === 1) {\n      this.array_.push(e);\n    } else {\n      this.array_.splice(arguments[0], arguments[1]);\n    }\n    return true;\n  };\n  ArrayList.prototype.clear = function () {\n    this.array_ = [];\n  };\n  ArrayList.prototype.addAll = function (c) {\n    for (var i = c.iterator(); i.hasNext();) {\n      this.add(i.next());\n    }\n    return true;\n  };\n  ArrayList.prototype.set = function (index, element) {\n    var oldElement = this.array_[index];\n    this.array_[index] = element;\n    return oldElement;\n  };\n  ArrayList.prototype.iterator = function () {\n    return new Iterator_(this);\n  };\n  ArrayList.prototype.get = function (index) {\n    if (index < 0 || index >= this.size()) {\n      throw new IndexOutOfBoundsException$1();\n    }\n    return this.array_[index];\n  };\n  ArrayList.prototype.isEmpty = function () {\n    return this.array_.length === 0;\n  };\n  ArrayList.prototype.size = function () {\n    return this.array_.length;\n  };\n  ArrayList.prototype.toArray = function () {\n    var array = [];\n    for (var i = 0, len = this.array_.length; i < len; i++) {\n      array.push(this.array_[i]);\n    }\n    return array;\n  };\n  ArrayList.prototype.remove = function (o) {\n    var found = false;\n    for (var i = 0, len = this.array_.length; i < len; i++) {\n      if (this.array_[i] === o) {\n        this.array_.splice(i, 1);\n        found = true;\n        break;\n      }\n    }\n    return found;\n  };\n  var Iterator_ = function Iterator_(arrayList) {\n    this.arrayList_ = arrayList;\n    this.position_ = 0;\n  };\n  Iterator_.prototype.next = function () {\n    if (this.position_ === this.arrayList_.size()) {\n      throw new NoSuchElementException();\n    }\n    return this.arrayList_.get(this.position_++);\n  };\n  Iterator_.prototype.hasNext = function () {\n    if (this.position_ < this.arrayList_.size()) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  Iterator_.prototype.set = function (element) {\n    return this.arrayList_.set(this.position_ - 1, element);\n  };\n  Iterator_.prototype.remove = function () {\n    this.arrayList_.remove(this.arrayList_.get(this.position_));\n  };\n\n  function CoordinateList() {\n  \tArrayList.apply(this);\n  \tif (arguments.length === 0) ; else if (arguments.length === 1) {\n  \t\tvar coord = arguments[0];\n  \t\tthis.ensureCapacity(coord.length);\n  \t\tthis.add(coord, true);\n  \t} else if (arguments.length === 2) {\n  \t\tvar coord = arguments[0],\n  \t\t    allowRepeated = arguments[1];\n  \t\tthis.ensureCapacity(coord.length);\n  \t\tthis.add(coord, allowRepeated);\n  \t}\n  }\n  inherits$1(CoordinateList, ArrayList);\n  extend(CoordinateList.prototype, {\n  \tgetCoordinate: function getCoordinate(i) {\n  \t\treturn this.get(i);\n  \t},\n  \taddAll: function addAll() {\n  \t\tif (arguments.length === 2) {\n  \t\t\tvar coll = arguments[0],\n  \t\t\t    allowRepeated = arguments[1];\n  \t\t\tvar isChanged = false;\n  \t\t\tfor (var i = coll.iterator(); i.hasNext();) {\n  \t\t\t\tthis.add(i.next(), allowRepeated);\n  \t\t\t\tisChanged = true;\n  \t\t\t}\n  \t\t\treturn isChanged;\n  \t\t} else return ArrayList.prototype.addAll.apply(this, arguments);\n  \t},\n  \tclone: function clone() {\n  \t\tvar clone = ArrayList.prototype.clone.call(this);\n  \t\tfor (var i = 0; i < this.size(); i++) {\n  \t\t\tclone.add(i, this.get(i).copy());\n  \t\t}\n  \t\treturn clone;\n  \t},\n  \ttoCoordinateArray: function toCoordinateArray() {\n  \t\treturn this.toArray(CoordinateList.coordArrayType);\n  \t},\n  \tadd: function add() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar coord = arguments[0];\n  \t\t\tArrayList.prototype.add.call(this, coord);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tif (arguments[0] instanceof Array && typeof arguments[1] === \"boolean\") {\n  \t\t\t\tvar coord = arguments[0],\n  \t\t\t\t    allowRepeated = arguments[1];\n  \t\t\t\tthis.add(coord, allowRepeated, true);\n  \t\t\t\treturn true;\n  \t\t\t} else if (arguments[0] instanceof Coordinate && typeof arguments[1] === \"boolean\") {\n  \t\t\t\tvar coord = arguments[0],\n  \t\t\t\t    allowRepeated = arguments[1];\n  \t\t\t\tif (!allowRepeated) {\n  \t\t\t\t\tif (this.size() >= 1) {\n  \t\t\t\t\t\tvar last = this.get(this.size() - 1);\n  \t\t\t\t\t\tif (last.equals2D(coord)) return null;\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t\tArrayList.prototype.add.call(this, coord);\n  \t\t\t} else if (arguments[0] instanceof Object && typeof arguments[1] === \"boolean\") {\n  \t\t\t\tvar obj = arguments[0],\n  \t\t\t\t    allowRepeated = arguments[1];\n  \t\t\t\tthis.add(obj, allowRepeated);\n  \t\t\t\treturn true;\n  \t\t\t}\n  \t\t} else if (arguments.length === 3) {\n  \t\t\tif (typeof arguments[2] === \"boolean\" && arguments[0] instanceof Array && typeof arguments[1] === \"boolean\") {\n  \t\t\t\tvar coord = arguments[0],\n  \t\t\t\t    allowRepeated = arguments[1],\n  \t\t\t\t    direction = arguments[2];\n  \t\t\t\tif (direction) {\n  \t\t\t\t\tfor (var i = 0; i < coord.length; i++) {\n  \t\t\t\t\t\tthis.add(coord[i], allowRepeated);\n  \t\t\t\t\t}\n  \t\t\t\t} else {\n  \t\t\t\t\tfor (var i = coord.length - 1; i >= 0; i--) {\n  \t\t\t\t\t\tthis.add(coord[i], allowRepeated);\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t\treturn true;\n  \t\t\t} else if (typeof arguments[2] === \"boolean\" && Number.isInteger(arguments[0]) && arguments[1] instanceof Coordinate) {\n  \t\t\t\tvar i = arguments[0],\n  \t\t\t\t    coord = arguments[1],\n  \t\t\t\t    allowRepeated = arguments[2];\n  \t\t\t\tif (!allowRepeated) {\n  \t\t\t\t\tvar size = this.size();\n  \t\t\t\t\tif (size > 0) {\n  \t\t\t\t\t\tif (i > 0) {\n  \t\t\t\t\t\t\tvar prev = this.get(i - 1);\n  \t\t\t\t\t\t\tif (prev.equals2D(coord)) return null;\n  \t\t\t\t\t\t}\n  \t\t\t\t\t\tif (i < size) {\n  \t\t\t\t\t\t\tvar next = this.get(i);\n  \t\t\t\t\t\t\tif (next.equals2D(coord)) return null;\n  \t\t\t\t\t\t}\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t\tArrayList.prototype.add.call(this, i, coord);\n  \t\t\t}\n  \t\t} else if (arguments.length === 4) {\n  \t\t\tvar coord = arguments[0],\n  \t\t\t    allowRepeated = arguments[1],\n  \t\t\t    start = arguments[2],\n  \t\t\t    end = arguments[3];\n  \t\t\tvar inc = 1;\n  \t\t\tif (start > end) inc = -1;\n  \t\t\tfor (var i = start; i !== end; i += inc) {\n  \t\t\t\tthis.add(coord[i], allowRepeated);\n  \t\t\t}\n  \t\t\treturn true;\n  \t\t}\n  \t},\n  \tcloseRing: function closeRing() {\n  \t\tif (this.size() > 0) this.add(new Coordinate(this.get(0)), false);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn CoordinateList;\n  \t}\n  });\n  CoordinateList.coordArrayType = new Array(0).fill(null);\n\n  function Envelope() {\n  \tthis._minx = null;\n  \tthis._maxx = null;\n  \tthis._miny = null;\n  \tthis._maxy = null;\n  \tif (arguments.length === 0) {\n  \t\tthis.init();\n  \t} else if (arguments.length === 1) {\n  \t\tif (arguments[0] instanceof Coordinate) {\n  \t\t\tvar p = arguments[0];\n  \t\t\tthis.init(p.x, p.x, p.y, p.y);\n  \t\t} else if (arguments[0] instanceof Envelope) {\n  \t\t\tvar env = arguments[0];\n  \t\t\tthis.init(env);\n  \t\t}\n  \t} else if (arguments.length === 2) {\n  \t\tvar p1 = arguments[0],\n  \t\t    p2 = arguments[1];\n  \t\tthis.init(p1.x, p2.x, p1.y, p2.y);\n  \t} else if (arguments.length === 4) {\n  \t\tvar x1 = arguments[0],\n  \t\t    x2 = arguments[1],\n  \t\t    y1 = arguments[2],\n  \t\t    y2 = arguments[3];\n  \t\tthis.init(x1, x2, y1, y2);\n  \t}\n  }\n  extend(Envelope.prototype, {\n  \tgetArea: function getArea() {\n  \t\treturn this.getWidth() * this.getHeight();\n  \t},\n  \tequals: function equals(other) {\n  \t\tif (!(other instanceof Envelope)) {\n  \t\t\treturn false;\n  \t\t}\n  \t\tvar otherEnvelope = other;\n  \t\tif (this.isNull()) {\n  \t\t\treturn otherEnvelope.isNull();\n  \t\t}\n  \t\treturn this._maxx === otherEnvelope.getMaxX() && this._maxy === otherEnvelope.getMaxY() && this._minx === otherEnvelope.getMinX() && this._miny === otherEnvelope.getMinY();\n  \t},\n  \tintersection: function intersection(env) {\n  \t\tif (this.isNull() || env.isNull() || !this.intersects(env)) return new Envelope();\n  \t\tvar intMinX = this._minx > env._minx ? this._minx : env._minx;\n  \t\tvar intMinY = this._miny > env._miny ? this._miny : env._miny;\n  \t\tvar intMaxX = this._maxx < env._maxx ? this._maxx : env._maxx;\n  \t\tvar intMaxY = this._maxy < env._maxy ? this._maxy : env._maxy;\n  \t\treturn new Envelope(intMinX, intMaxX, intMinY, intMaxY);\n  \t},\n  \tisNull: function isNull() {\n  \t\treturn this._maxx < this._minx;\n  \t},\n  \tgetMaxX: function getMaxX() {\n  \t\treturn this._maxx;\n  \t},\n  \tcovers: function covers() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tif (arguments[0] instanceof Coordinate) {\n  \t\t\t\tvar p = arguments[0];\n  \t\t\t\treturn this.covers(p.x, p.y);\n  \t\t\t} else if (arguments[0] instanceof Envelope) {\n  \t\t\t\tvar other = arguments[0];\n  \t\t\t\tif (this.isNull() || other.isNull()) {\n  \t\t\t\t\treturn false;\n  \t\t\t\t}\n  \t\t\t\treturn other.getMinX() >= this._minx && other.getMaxX() <= this._maxx && other.getMinY() >= this._miny && other.getMaxY() <= this._maxy;\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar x = arguments[0],\n  \t\t\t    y = arguments[1];\n  \t\t\tif (this.isNull()) return false;\n  \t\t\treturn x >= this._minx && x <= this._maxx && y >= this._miny && y <= this._maxy;\n  \t\t}\n  \t},\n  \tintersects: function intersects() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tif (arguments[0] instanceof Envelope) {\n  \t\t\t\tvar other = arguments[0];\n  \t\t\t\tif (this.isNull() || other.isNull()) {\n  \t\t\t\t\treturn false;\n  \t\t\t\t}\n  \t\t\t\treturn !(other._minx > this._maxx || other._maxx < this._minx || other._miny > this._maxy || other._maxy < this._miny);\n  \t\t\t} else if (arguments[0] instanceof Coordinate) {\n  \t\t\t\tvar p = arguments[0];\n  \t\t\t\treturn this.intersects(p.x, p.y);\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar x = arguments[0],\n  \t\t\t    y = arguments[1];\n  \t\t\tif (this.isNull()) return false;\n  \t\t\treturn !(x > this._maxx || x < this._minx || y > this._maxy || y < this._miny);\n  \t\t}\n  \t},\n  \tgetMinY: function getMinY() {\n  \t\treturn this._miny;\n  \t},\n  \tgetMinX: function getMinX() {\n  \t\treturn this._minx;\n  \t},\n  \texpandToInclude: function expandToInclude() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tif (arguments[0] instanceof Coordinate) {\n  \t\t\t\tvar p = arguments[0];\n  \t\t\t\tthis.expandToInclude(p.x, p.y);\n  \t\t\t} else if (arguments[0] instanceof Envelope) {\n  \t\t\t\tvar other = arguments[0];\n  \t\t\t\tif (other.isNull()) {\n  \t\t\t\t\treturn null;\n  \t\t\t\t}\n  \t\t\t\tif (this.isNull()) {\n  \t\t\t\t\tthis._minx = other.getMinX();\n  \t\t\t\t\tthis._maxx = other.getMaxX();\n  \t\t\t\t\tthis._miny = other.getMinY();\n  \t\t\t\t\tthis._maxy = other.getMaxY();\n  \t\t\t\t} else {\n  \t\t\t\t\tif (other._minx < this._minx) {\n  \t\t\t\t\t\tthis._minx = other._minx;\n  \t\t\t\t\t}\n  \t\t\t\t\tif (other._maxx > this._maxx) {\n  \t\t\t\t\t\tthis._maxx = other._maxx;\n  \t\t\t\t\t}\n  \t\t\t\t\tif (other._miny < this._miny) {\n  \t\t\t\t\t\tthis._miny = other._miny;\n  \t\t\t\t\t}\n  \t\t\t\t\tif (other._maxy > this._maxy) {\n  \t\t\t\t\t\tthis._maxy = other._maxy;\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar x = arguments[0],\n  \t\t\t    y = arguments[1];\n  \t\t\tif (this.isNull()) {\n  \t\t\t\tthis._minx = x;\n  \t\t\t\tthis._maxx = x;\n  \t\t\t\tthis._miny = y;\n  \t\t\t\tthis._maxy = y;\n  \t\t\t} else {\n  \t\t\t\tif (x < this._minx) {\n  \t\t\t\t\tthis._minx = x;\n  \t\t\t\t}\n  \t\t\t\tif (x > this._maxx) {\n  \t\t\t\t\tthis._maxx = x;\n  \t\t\t\t}\n  \t\t\t\tif (y < this._miny) {\n  \t\t\t\t\tthis._miny = y;\n  \t\t\t\t}\n  \t\t\t\tif (y > this._maxy) {\n  \t\t\t\t\tthis._maxy = y;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tminExtent: function minExtent() {\n  \t\tif (this.isNull()) return 0.0;\n  \t\tvar w = this.getWidth();\n  \t\tvar h = this.getHeight();\n  \t\tif (w < h) return w;\n  \t\treturn h;\n  \t},\n  \tgetWidth: function getWidth() {\n  \t\tif (this.isNull()) {\n  \t\t\treturn 0;\n  \t\t}\n  \t\treturn this._maxx - this._minx;\n  \t},\n  \tcompareTo: function compareTo(o) {\n  \t\tvar env = o;\n  \t\tif (this.isNull()) {\n  \t\t\tif (env.isNull()) return 0;\n  \t\t\treturn -1;\n  \t\t} else {\n  \t\t\tif (env.isNull()) return 1;\n  \t\t}\n  \t\tif (this._minx < env._minx) return -1;\n  \t\tif (this._minx > env._minx) return 1;\n  \t\tif (this._miny < env._miny) return -1;\n  \t\tif (this._miny > env._miny) return 1;\n  \t\tif (this._maxx < env._maxx) return -1;\n  \t\tif (this._maxx > env._maxx) return 1;\n  \t\tif (this._maxy < env._maxy) return -1;\n  \t\tif (this._maxy > env._maxy) return 1;\n  \t\treturn 0;\n  \t},\n  \ttranslate: function translate(transX, transY) {\n  \t\tif (this.isNull()) {\n  \t\t\treturn null;\n  \t\t}\n  \t\tthis.init(this.getMinX() + transX, this.getMaxX() + transX, this.getMinY() + transY, this.getMaxY() + transY);\n  \t},\n  \ttoString: function toString() {\n  \t\treturn \"Env[\" + this._minx + \" : \" + this._maxx + \", \" + this._miny + \" : \" + this._maxy + \"]\";\n  \t},\n  \tsetToNull: function setToNull() {\n  \t\tthis._minx = 0;\n  \t\tthis._maxx = -1;\n  \t\tthis._miny = 0;\n  \t\tthis._maxy = -1;\n  \t},\n  \tgetHeight: function getHeight() {\n  \t\tif (this.isNull()) {\n  \t\t\treturn 0;\n  \t\t}\n  \t\treturn this._maxy - this._miny;\n  \t},\n  \tmaxExtent: function maxExtent() {\n  \t\tif (this.isNull()) return 0.0;\n  \t\tvar w = this.getWidth();\n  \t\tvar h = this.getHeight();\n  \t\tif (w > h) return w;\n  \t\treturn h;\n  \t},\n  \texpandBy: function expandBy() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar distance = arguments[0];\n  \t\t\tthis.expandBy(distance, distance);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar deltaX = arguments[0],\n  \t\t\t    deltaY = arguments[1];\n  \t\t\tif (this.isNull()) return null;\n  \t\t\tthis._minx -= deltaX;\n  \t\t\tthis._maxx += deltaX;\n  \t\t\tthis._miny -= deltaY;\n  \t\t\tthis._maxy += deltaY;\n  \t\t\tif (this._minx > this._maxx || this._miny > this._maxy) this.setToNull();\n  \t\t}\n  \t},\n  \tcontains: function contains() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tif (arguments[0] instanceof Envelope) {\n  \t\t\t\tvar other = arguments[0];\n  \t\t\t\treturn this.covers(other);\n  \t\t\t} else if (arguments[0] instanceof Coordinate) {\n  \t\t\t\tvar p = arguments[0];\n  \t\t\t\treturn this.covers(p);\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar x = arguments[0],\n  \t\t\t    y = arguments[1];\n  \t\t\treturn this.covers(x, y);\n  \t\t}\n  \t},\n  \tcentre: function centre() {\n  \t\tif (this.isNull()) return null;\n  \t\treturn new Coordinate((this.getMinX() + this.getMaxX()) / 2.0, (this.getMinY() + this.getMaxY()) / 2.0);\n  \t},\n  \tinit: function init() {\n  \t\tif (arguments.length === 0) {\n  \t\t\tthis.setToNull();\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tif (arguments[0] instanceof Coordinate) {\n  \t\t\t\tvar p = arguments[0];\n  \t\t\t\tthis.init(p.x, p.x, p.y, p.y);\n  \t\t\t} else if (arguments[0] instanceof Envelope) {\n  \t\t\t\tvar env = arguments[0];\n  \t\t\t\tthis._minx = env._minx;\n  \t\t\t\tthis._maxx = env._maxx;\n  \t\t\t\tthis._miny = env._miny;\n  \t\t\t\tthis._maxy = env._maxy;\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar p1 = arguments[0],\n  \t\t\t    p2 = arguments[1];\n  \t\t\tthis.init(p1.x, p2.x, p1.y, p2.y);\n  \t\t} else if (arguments.length === 4) {\n  \t\t\tvar x1 = arguments[0],\n  \t\t\t    x2 = arguments[1],\n  \t\t\t    y1 = arguments[2],\n  \t\t\t    y2 = arguments[3];\n  \t\t\tif (x1 < x2) {\n  \t\t\t\tthis._minx = x1;\n  \t\t\t\tthis._maxx = x2;\n  \t\t\t} else {\n  \t\t\t\tthis._minx = x2;\n  \t\t\t\tthis._maxx = x1;\n  \t\t\t}\n  \t\t\tif (y1 < y2) {\n  \t\t\t\tthis._miny = y1;\n  \t\t\t\tthis._maxy = y2;\n  \t\t\t} else {\n  \t\t\t\tthis._miny = y2;\n  \t\t\t\tthis._maxy = y1;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetMaxY: function getMaxY() {\n  \t\treturn this._maxy;\n  \t},\n  \tdistance: function distance(env) {\n  \t\tif (this.intersects(env)) return 0;\n  \t\tvar dx = 0.0;\n  \t\tif (this._maxx < env._minx) dx = env._minx - this._maxx;else if (this._minx > env._maxx) dx = this._minx - env._maxx;\n  \t\tvar dy = 0.0;\n  \t\tif (this._maxy < env._miny) dy = env._miny - this._maxy;else if (this._miny > env._maxy) dy = this._miny - env._maxy;\n  \t\tif (dx === 0.0) return dy;\n  \t\tif (dy === 0.0) return dx;\n  \t\treturn Math.sqrt(dx * dx + dy * dy);\n  \t},\n  \thashCode: function hashCode() {\n  \t\tvar result = 17;\n  \t\tresult = 37 * result + Coordinate.hashCode(this._minx);\n  \t\tresult = 37 * result + Coordinate.hashCode(this._maxx);\n  \t\tresult = 37 * result + Coordinate.hashCode(this._miny);\n  \t\tresult = 37 * result + Coordinate.hashCode(this._maxy);\n  \t\treturn result;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparable, Serializable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Envelope;\n  \t}\n  });\n  Envelope.intersects = function () {\n  \tif (arguments.length === 3) {\n  \t\tvar p1 = arguments[0],\n  \t\t    p2 = arguments[1],\n  \t\t    q = arguments[2];\n  \t\tif (q.x >= (p1.x < p2.x ? p1.x : p2.x) && q.x <= (p1.x > p2.x ? p1.x : p2.x) && q.y >= (p1.y < p2.y ? p1.y : p2.y) && q.y <= (p1.y > p2.y ? p1.y : p2.y)) {\n  \t\t\treturn true;\n  \t\t}\n  \t\treturn false;\n  \t} else if (arguments.length === 4) {\n  \t\tvar p1 = arguments[0],\n  \t\t    p2 = arguments[1],\n  \t\t    q1 = arguments[2],\n  \t\t    q2 = arguments[3];\n  \t\tvar minq = Math.min(q1.x, q2.x);\n  \t\tvar maxq = Math.max(q1.x, q2.x);\n  \t\tvar minp = Math.min(p1.x, p2.x);\n  \t\tvar maxp = Math.max(p1.x, p2.x);\n  \t\tif (minp > maxq) return false;\n  \t\tif (maxp < minq) return false;\n  \t\tminq = Math.min(q1.y, q2.y);\n  \t\tmaxq = Math.max(q1.y, q2.y);\n  \t\tminp = Math.min(p1.y, p2.y);\n  \t\tmaxp = Math.max(p1.y, p2.y);\n  \t\tif (minp > maxq) return false;\n  \t\tif (maxp < minq) return false;\n  \t\treturn true;\n  \t}\n  };\n  Envelope.serialVersionUID = 5873921885273102420;\n\n  function Exception() {}\n\n  function NotRepresentableException() {\n  \tException.call(this, \"Projective point not representable on the Cartesian plane.\");\n  }\n  inherits$1(NotRepresentableException, Exception);\n  extend(NotRepresentableException.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn NotRepresentableException;\n  \t}\n  });\n\n  function Location() {}\n  extend(Location.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Location;\n  \t}\n  });\n  Location.toLocationSymbol = function (locationValue) {\n  \tswitch (locationValue) {\n  \t\tcase Location.EXTERIOR:\n  \t\t\treturn 'e';\n  \t\tcase Location.BOUNDARY:\n  \t\t\treturn 'b';\n  \t\tcase Location.INTERIOR:\n  \t\t\treturn 'i';\n  \t\tcase Location.NONE:\n  \t\t\treturn '-';\n  \t}\n  \tthrow new IllegalArgumentException(\"Unknown location value: \" + locationValue);\n  };\n  Location.INTERIOR = 0;\n  Location.BOUNDARY = 1;\n  Location.EXTERIOR = 2;\n  Location.NONE = -1;\n\n  function hasInterface (o, i) {\n    return o.interfaces_ && o.interfaces_().indexOf(i) > -1;\n  }\n\n  function MathUtil() {}\n  extend(MathUtil.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MathUtil;\n  \t}\n  });\n  MathUtil.log10 = function (x) {\n  \tvar ln = Math.log(x);\n  \tif (Double.isInfinite(ln)) return ln;\n  \tif (Double.isNaN(ln)) return ln;\n  \treturn ln / MathUtil.LOG_10;\n  };\n  MathUtil.min = function (v1, v2, v3, v4) {\n  \tvar min = v1;\n  \tif (v2 < min) min = v2;\n  \tif (v3 < min) min = v3;\n  \tif (v4 < min) min = v4;\n  \treturn min;\n  };\n  MathUtil.clamp = function () {\n  \tif (typeof arguments[2] === \"number\" && typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\") {\n  \t\tvar x = arguments[0],\n  \t\t    min = arguments[1],\n  \t\t    max = arguments[2];\n  \t\tif (x < min) return min;\n  \t\tif (x > max) return max;\n  \t\treturn x;\n  \t} else if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {\n  \t\tvar x = arguments[0],\n  \t\t    min = arguments[1],\n  \t\t    max = arguments[2];\n  \t\tif (x < min) return min;\n  \t\tif (x > max) return max;\n  \t\treturn x;\n  \t}\n  };\n  MathUtil.wrap = function (index, max) {\n  \tif (index < 0) {\n  \t\treturn max - -index % max;\n  \t}\n  \treturn index % max;\n  };\n  MathUtil.max = function () {\n  \tif (arguments.length === 3) {\n  \t\tvar v1 = arguments[0],\n  \t\t    v2 = arguments[1],\n  \t\t    v3 = arguments[2];\n  \t\tvar max = v1;\n  \t\tif (v2 > max) max = v2;\n  \t\tif (v3 > max) max = v3;\n  \t\treturn max;\n  \t} else if (arguments.length === 4) {\n  \t\tvar v1 = arguments[0],\n  \t\t    v2 = arguments[1],\n  \t\t    v3 = arguments[2],\n  \t\t    v4 = arguments[3];\n  \t\tvar max = v1;\n  \t\tif (v2 > max) max = v2;\n  \t\tif (v3 > max) max = v3;\n  \t\tif (v4 > max) max = v4;\n  \t\treturn max;\n  \t}\n  };\n  MathUtil.average = function (x1, x2) {\n  \treturn (x1 + x2) / 2.0;\n  };\n  MathUtil.LOG_10 = Math.log(10);\n\n  function StringBuffer(str) {\n    this.str = str;\n  }\n  StringBuffer.prototype.append = function (e) {\n    this.str += e;\n  };\n  StringBuffer.prototype.setCharAt = function (i, c) {\n    this.str = this.str.substr(0, i) + c + this.str.substr(i + 1);\n  };\n  StringBuffer.prototype.toString = function (e) {\n    return this.str;\n  };\n\n  function Integer(value) {\n    this.value = value;\n  }\n  Integer.prototype.intValue = function () {\n    return this.value;\n  };\n  Integer.prototype.compareTo = function (o) {\n    if (this.value < o) return -1;\n    if (this.value > o) return 1;\n    return 0;\n  };\n  Integer.isNaN = function (n) {\n    return Number.isNaN(n);\n  };\n\n  function Character() {}\n  Character.isWhitespace = function (c) {\n    return c <= 32 && c >= 0 || c == 127;\n  };\n  Character.toUpperCase = function (c) {\n    return c.toUpperCase();\n  };\n\n  function DD() {\n  \tthis._hi = 0.0;\n  \tthis._lo = 0.0;\n  \tif (arguments.length === 0) {\n  \t\tthis.init(0.0);\n  \t} else if (arguments.length === 1) {\n  \t\tif (typeof arguments[0] === \"number\") {\n  \t\t\tvar x = arguments[0];\n  \t\t\tthis.init(x);\n  \t\t} else if (arguments[0] instanceof DD) {\n  \t\t\tvar dd = arguments[0];\n  \t\t\tthis.init(dd);\n  \t\t} else if (typeof arguments[0] === \"string\") {\n  \t\t\tvar str = arguments[0];\n  \t\t\tDD.call(this, DD.parse(str));\n  \t\t}\n  \t} else if (arguments.length === 2) {\n  \t\tvar hi = arguments[0],\n  \t\t    lo = arguments[1];\n  \t\tthis.init(hi, lo);\n  \t}\n  }\n  extend(DD.prototype, {\n  \tle: function le(y) {\n  \t\treturn this._hi < y._hi || this._hi === y._hi && this._lo <= y._lo;\n  \t},\n  \textractSignificantDigits: function extractSignificantDigits(insertDecimalPoint, magnitude) {\n  \t\tvar y = this.abs();\n  \t\tvar mag = DD.magnitude(y._hi);\n  \t\tvar scale = DD.TEN.pow(mag);\n  \t\ty = y.divide(scale);\n  \t\tif (y.gt(DD.TEN)) {\n  \t\t\ty = y.divide(DD.TEN);\n  \t\t\tmag += 1;\n  \t\t} else if (y.lt(DD.ONE)) {\n  \t\t\ty = y.multiply(DD.TEN);\n  \t\t\tmag -= 1;\n  \t\t}\n  \t\tvar decimalPointPos = mag + 1;\n  \t\tvar buf = new StringBuffer();\n  \t\tvar numDigits = DD.MAX_PRINT_DIGITS - 1;\n  \t\tfor (var i = 0; i <= numDigits; i++) {\n  \t\t\tif (insertDecimalPoint && i === decimalPointPos) {\n  \t\t\t\tbuf.append('.');\n  \t\t\t}\n  \t\t\tvar digit = Math.trunc(y._hi);\n  \t\t\tif (digit < 0) {\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t\tvar rebiasBy10 = false;\n  \t\t\tvar digitChar = 0;\n  \t\t\tif (digit > 9) {\n  \t\t\t\trebiasBy10 = true;\n  \t\t\t\tdigitChar = '9';\n  \t\t\t} else {\n  \t\t\t\tdigitChar = '0' + digit;\n  \t\t\t}\n  \t\t\tbuf.append(digitChar);\n  \t\t\ty = y.subtract(DD.valueOf(digit)).multiply(DD.TEN);\n  \t\t\tif (rebiasBy10) y.selfAdd(DD.TEN);\n  \t\t\tvar continueExtractingDigits = true;\n  \t\t\tvar remMag = DD.magnitude(y._hi);\n  \t\t\tif (remMag < 0 && Math.abs(remMag) >= numDigits - i) continueExtractingDigits = false;\n  \t\t\tif (!continueExtractingDigits) break;\n  \t\t}\n  \t\tmagnitude[0] = mag;\n  \t\treturn buf.toString();\n  \t},\n  \tsqr: function sqr() {\n  \t\treturn this.multiply(this);\n  \t},\n  \tdoubleValue: function doubleValue() {\n  \t\treturn this._hi + this._lo;\n  \t},\n  \tsubtract: function subtract() {\n  \t\tif (arguments[0] instanceof DD) {\n  \t\t\tvar y = arguments[0];\n  \t\t\treturn this.add(y.negate());\n  \t\t} else if (typeof arguments[0] === \"number\") {\n  \t\t\tvar y = arguments[0];\n  \t\t\treturn this.add(-y);\n  \t\t}\n  \t},\n  \tequals: function equals() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar y = arguments[0];\n  \t\t\treturn this._hi === y._hi && this._lo === y._lo;\n  \t\t}\n  \t},\n  \tisZero: function isZero() {\n  \t\treturn this._hi === 0.0 && this._lo === 0.0;\n  \t},\n  \tselfSubtract: function selfSubtract() {\n  \t\tif (arguments[0] instanceof DD) {\n  \t\t\tvar y = arguments[0];\n  \t\t\tif (this.isNaN()) return this;\n  \t\t\treturn this.selfAdd(-y._hi, -y._lo);\n  \t\t} else if (typeof arguments[0] === \"number\") {\n  \t\t\tvar y = arguments[0];\n  \t\t\tif (this.isNaN()) return this;\n  \t\t\treturn this.selfAdd(-y, 0.0);\n  \t\t}\n  \t},\n  \tgetSpecialNumberString: function getSpecialNumberString() {\n  \t\tif (this.isZero()) return \"0.0\";\n  \t\tif (this.isNaN()) return \"NaN \";\n  \t\treturn null;\n  \t},\n  \tmin: function min(x) {\n  \t\tif (this.le(x)) {\n  \t\t\treturn this;\n  \t\t} else {\n  \t\t\treturn x;\n  \t\t}\n  \t},\n  \tselfDivide: function selfDivide() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tif (arguments[0] instanceof DD) {\n  \t\t\t\tvar y = arguments[0];\n  \t\t\t\treturn this.selfDivide(y._hi, y._lo);\n  \t\t\t} else if (typeof arguments[0] === \"number\") {\n  \t\t\t\tvar y = arguments[0];\n  \t\t\t\treturn this.selfDivide(y, 0.0);\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar yhi = arguments[0],\n  \t\t\t    ylo = arguments[1];\n  \t\t\tvar hc = null,\n  \t\t\t    tc = null,\n  \t\t\t    hy = null,\n  \t\t\t    ty = null,\n  \t\t\t    C = null,\n  \t\t\t    c = null,\n  \t\t\t    U = null,\n  \t\t\t    u = null;\n  \t\t\tC = this._hi / yhi;\n  \t\t\tc = DD.SPLIT * C;\n  \t\t\thc = c - C;\n  \t\t\tu = DD.SPLIT * yhi;\n  \t\t\thc = c - hc;\n  \t\t\ttc = C - hc;\n  \t\t\thy = u - yhi;\n  \t\t\tU = C * yhi;\n  \t\t\thy = u - hy;\n  \t\t\tty = yhi - hy;\n  \t\t\tu = hc * hy - U + hc * ty + tc * hy + tc * ty;\n  \t\t\tc = (this._hi - U - u + this._lo - C * ylo) / yhi;\n  \t\t\tu = C + c;\n  \t\t\tthis._hi = u;\n  \t\t\tthis._lo = C - u + c;\n  \t\t\treturn this;\n  \t\t}\n  \t},\n  \tdump: function dump() {\n  \t\treturn \"DD<\" + this._hi + \", \" + this._lo + \">\";\n  \t},\n  \tdivide: function divide() {\n  \t\tif (arguments[0] instanceof DD) {\n  \t\t\tvar y = arguments[0];\n  \t\t\tvar hc = null,\n  \t\t\t    tc = null,\n  \t\t\t    hy = null,\n  \t\t\t    ty = null,\n  \t\t\t    C = null,\n  \t\t\t    c = null,\n  \t\t\t    U = null,\n  \t\t\t    u = null;\n  \t\t\tC = this._hi / y._hi;\n  \t\t\tc = DD.SPLIT * C;\n  \t\t\thc = c - C;\n  \t\t\tu = DD.SPLIT * y._hi;\n  \t\t\thc = c - hc;\n  \t\t\ttc = C - hc;\n  \t\t\thy = u - y._hi;\n  \t\t\tU = C * y._hi;\n  \t\t\thy = u - hy;\n  \t\t\tty = y._hi - hy;\n  \t\t\tu = hc * hy - U + hc * ty + tc * hy + tc * ty;\n  \t\t\tc = (this._hi - U - u + this._lo - C * y._lo) / y._hi;\n  \t\t\tu = C + c;\n  \t\t\tvar zhi = u;\n  \t\t\tvar zlo = C - u + c;\n  \t\t\treturn new DD(zhi, zlo);\n  \t\t} else if (typeof arguments[0] === \"number\") {\n  \t\t\tvar y = arguments[0];\n  \t\t\tif (Double.isNaN(y)) return DD.createNaN();\n  \t\t\treturn DD.copy(this).selfDivide(y, 0.0);\n  \t\t}\n  \t},\n  \tge: function ge(y) {\n  \t\treturn this._hi > y._hi || this._hi === y._hi && this._lo >= y._lo;\n  \t},\n  \tpow: function pow(exp) {\n  \t\tif (exp === 0.0) return DD.valueOf(1.0);\n  \t\tvar r = new DD(this);\n  \t\tvar s = DD.valueOf(1.0);\n  \t\tvar n = Math.abs(exp);\n  \t\tif (n > 1) {\n  \t\t\twhile (n > 0) {\n  \t\t\t\tif (n % 2 === 1) {\n  \t\t\t\t\ts.selfMultiply(r);\n  \t\t\t\t}\n  \t\t\t\tn /= 2;\n  \t\t\t\tif (n > 0) r = r.sqr();\n  \t\t\t}\n  \t\t} else {\n  \t\t\ts = r;\n  \t\t}\n  \t\tif (exp < 0) return s.reciprocal();\n  \t\treturn s;\n  \t},\n  \tceil: function ceil() {\n  \t\tif (this.isNaN()) return DD.NaN;\n  \t\tvar fhi = Math.ceil(this._hi);\n  \t\tvar flo = 0.0;\n  \t\tif (fhi === this._hi) {\n  \t\t\tflo = Math.ceil(this._lo);\n  \t\t}\n  \t\treturn new DD(fhi, flo);\n  \t},\n  \tcompareTo: function compareTo(o) {\n  \t\tvar other = o;\n  \t\tif (this._hi < other._hi) return -1;\n  \t\tif (this._hi > other._hi) return 1;\n  \t\tif (this._lo < other._lo) return -1;\n  \t\tif (this._lo > other._lo) return 1;\n  \t\treturn 0;\n  \t},\n  \trint: function rint() {\n  \t\tif (this.isNaN()) return this;\n  \t\tvar plus5 = this.add(0.5);\n  \t\treturn plus5.floor();\n  \t},\n  \tsetValue: function setValue() {\n  \t\tif (arguments[0] instanceof DD) {\n  \t\t\tvar value = arguments[0];\n  \t\t\tthis.init(value);\n  \t\t\treturn this;\n  \t\t} else if (typeof arguments[0] === \"number\") {\n  \t\t\tvar value = arguments[0];\n  \t\t\tthis.init(value);\n  \t\t\treturn this;\n  \t\t}\n  \t},\n  \tmax: function max(x) {\n  \t\tif (this.ge(x)) {\n  \t\t\treturn this;\n  \t\t} else {\n  \t\t\treturn x;\n  \t\t}\n  \t},\n  \tsqrt: function sqrt() {\n  \t\tif (this.isZero()) return DD.valueOf(0.0);\n  \t\tif (this.isNegative()) {\n  \t\t\treturn DD.NaN;\n  \t\t}\n  \t\tvar x = 1.0 / Math.sqrt(this._hi);\n  \t\tvar ax = this._hi * x;\n  \t\tvar axdd = DD.valueOf(ax);\n  \t\tvar diffSq = this.subtract(axdd.sqr());\n  \t\tvar d2 = diffSq._hi * (x * 0.5);\n  \t\treturn axdd.add(d2);\n  \t},\n  \tselfAdd: function selfAdd() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tif (arguments[0] instanceof DD) {\n  \t\t\t\tvar y = arguments[0];\n  \t\t\t\treturn this.selfAdd(y._hi, y._lo);\n  \t\t\t} else if (typeof arguments[0] === \"number\") {\n  \t\t\t\tvar y = arguments[0];\n  \t\t\t\tvar H = null,\n  \t\t\t\t    h = null,\n  \t\t\t\t    S = null,\n  \t\t\t\t    s = null,\n  \t\t\t\t    e = null,\n  \t\t\t\t    f = null;\n  \t\t\t\tS = this._hi + y;\n  \t\t\t\te = S - this._hi;\n  \t\t\t\ts = S - e;\n  \t\t\t\ts = y - e + (this._hi - s);\n  \t\t\t\tf = s + this._lo;\n  \t\t\t\tH = S + f;\n  \t\t\t\th = f + (S - H);\n  \t\t\t\tthis._hi = H + h;\n  \t\t\t\tthis._lo = h + (H - this._hi);\n  \t\t\t\treturn this;\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar yhi = arguments[0],\n  \t\t\t    ylo = arguments[1];\n  \t\t\tvar H = null,\n  \t\t\t    h = null,\n  \t\t\t    T = null,\n  \t\t\t    t = null,\n  \t\t\t    S = null,\n  \t\t\t    s = null,\n  \t\t\t    e = null,\n  \t\t\t    f = null;\n  \t\t\tS = this._hi + yhi;\n  \t\t\tT = this._lo + ylo;\n  \t\t\te = S - this._hi;\n  \t\t\tf = T - this._lo;\n  \t\t\ts = S - e;\n  \t\t\tt = T - f;\n  \t\t\ts = yhi - e + (this._hi - s);\n  \t\t\tt = ylo - f + (this._lo - t);\n  \t\t\te = s + T;\n  \t\t\tH = S + e;\n  \t\t\th = e + (S - H);\n  \t\t\te = t + h;\n  \t\t\tvar zhi = H + e;\n  \t\t\tvar zlo = e + (H - zhi);\n  \t\t\tthis._hi = zhi;\n  \t\t\tthis._lo = zlo;\n  \t\t\treturn this;\n  \t\t}\n  \t},\n  \tselfMultiply: function selfMultiply() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tif (arguments[0] instanceof DD) {\n  \t\t\t\tvar y = arguments[0];\n  \t\t\t\treturn this.selfMultiply(y._hi, y._lo);\n  \t\t\t} else if (typeof arguments[0] === \"number\") {\n  \t\t\t\tvar y = arguments[0];\n  \t\t\t\treturn this.selfMultiply(y, 0.0);\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar yhi = arguments[0],\n  \t\t\t    ylo = arguments[1];\n  \t\t\tvar hx = null,\n  \t\t\t    tx = null,\n  \t\t\t    hy = null,\n  \t\t\t    ty = null,\n  \t\t\t    C = null,\n  \t\t\t    c = null;\n  \t\t\tC = DD.SPLIT * this._hi;\n  \t\t\thx = C - this._hi;\n  \t\t\tc = DD.SPLIT * yhi;\n  \t\t\thx = C - hx;\n  \t\t\ttx = this._hi - hx;\n  \t\t\thy = c - yhi;\n  \t\t\tC = this._hi * yhi;\n  \t\t\thy = c - hy;\n  \t\t\tty = yhi - hy;\n  \t\t\tc = hx * hy - C + hx * ty + tx * hy + tx * ty + (this._hi * ylo + this._lo * yhi);\n  \t\t\tvar zhi = C + c;\n  \t\t\thx = C - zhi;\n  \t\t\tvar zlo = c + hx;\n  \t\t\tthis._hi = zhi;\n  \t\t\tthis._lo = zlo;\n  \t\t\treturn this;\n  \t\t}\n  \t},\n  \tselfSqr: function selfSqr() {\n  \t\treturn this.selfMultiply(this);\n  \t},\n  \tfloor: function floor() {\n  \t\tif (this.isNaN()) return DD.NaN;\n  \t\tvar fhi = Math.floor(this._hi);\n  \t\tvar flo = 0.0;\n  \t\tif (fhi === this._hi) {\n  \t\t\tflo = Math.floor(this._lo);\n  \t\t}\n  \t\treturn new DD(fhi, flo);\n  \t},\n  \tnegate: function negate() {\n  \t\tif (this.isNaN()) return this;\n  \t\treturn new DD(-this._hi, -this._lo);\n  \t},\n  \tclone: function clone() {\n  \t\ttry {\n  \t\t\treturn null;\n  \t\t} catch (ex) {\n  \t\t\tif (ex instanceof CloneNotSupportedException) {\n  \t\t\t\treturn null;\n  \t\t\t} else throw ex;\n  \t\t} finally {}\n  \t},\n  \tmultiply: function multiply() {\n  \t\tif (arguments[0] instanceof DD) {\n  \t\t\tvar y = arguments[0];\n  \t\t\tif (y.isNaN()) return DD.createNaN();\n  \t\t\treturn DD.copy(this).selfMultiply(y);\n  \t\t} else if (typeof arguments[0] === \"number\") {\n  \t\t\tvar y = arguments[0];\n  \t\t\tif (Double.isNaN(y)) return DD.createNaN();\n  \t\t\treturn DD.copy(this).selfMultiply(y, 0.0);\n  \t\t}\n  \t},\n  \tisNaN: function isNaN() {\n  \t\treturn Double.isNaN(this._hi);\n  \t},\n  \tintValue: function intValue() {\n  \t\treturn Math.trunc(this._hi);\n  \t},\n  \ttoString: function toString() {\n  \t\tvar mag = DD.magnitude(this._hi);\n  \t\tif (mag >= -3 && mag <= 20) return this.toStandardNotation();\n  \t\treturn this.toSciNotation();\n  \t},\n  \ttoStandardNotation: function toStandardNotation() {\n  \t\tvar specialStr = this.getSpecialNumberString();\n  \t\tif (specialStr !== null) return specialStr;\n  \t\tvar magnitude = new Array(1).fill(null);\n  \t\tvar sigDigits = this.extractSignificantDigits(true, magnitude);\n  \t\tvar decimalPointPos = magnitude[0] + 1;\n  \t\tvar num = sigDigits;\n  \t\tif (sigDigits.charAt(0) === '.') {\n  \t\t\tnum = \"0\" + sigDigits;\n  \t\t} else if (decimalPointPos < 0) {\n  \t\t\tnum = \"0.\" + DD.stringOfChar('0', -decimalPointPos) + sigDigits;\n  \t\t} else if (sigDigits.indexOf('.') === -1) {\n  \t\t\tvar numZeroes = decimalPointPos - sigDigits.length;\n  \t\t\tvar zeroes = DD.stringOfChar('0', numZeroes);\n  \t\t\tnum = sigDigits + zeroes + \".0\";\n  \t\t}\n  \t\tif (this.isNegative()) return \"-\" + num;\n  \t\treturn num;\n  \t},\n  \treciprocal: function reciprocal() {\n  \t\tvar hc = null,\n  \t\t    tc = null,\n  \t\t    hy = null,\n  \t\t    ty = null,\n  \t\t    C = null,\n  \t\t    c = null,\n  \t\t    U = null,\n  \t\t    u = null;\n  \t\tC = 1.0 / this._hi;\n  \t\tc = DD.SPLIT * C;\n  \t\thc = c - C;\n  \t\tu = DD.SPLIT * this._hi;\n  \t\thc = c - hc;\n  \t\ttc = C - hc;\n  \t\thy = u - this._hi;\n  \t\tU = C * this._hi;\n  \t\thy = u - hy;\n  \t\tty = this._hi - hy;\n  \t\tu = hc * hy - U + hc * ty + tc * hy + tc * ty;\n  \t\tc = (1.0 - U - u - C * this._lo) / this._hi;\n  \t\tvar zhi = C + c;\n  \t\tvar zlo = C - zhi + c;\n  \t\treturn new DD(zhi, zlo);\n  \t},\n  \ttoSciNotation: function toSciNotation() {\n  \t\tif (this.isZero()) return DD.SCI_NOT_ZERO;\n  \t\tvar specialStr = this.getSpecialNumberString();\n  \t\tif (specialStr !== null) return specialStr;\n  \t\tvar magnitude = new Array(1).fill(null);\n  \t\tvar digits = this.extractSignificantDigits(false, magnitude);\n  \t\tvar expStr = DD.SCI_NOT_EXPONENT_CHAR + magnitude[0];\n  \t\tif (digits.charAt(0) === '0') {\n  \t\t\tthrow new IllegalStateException(\"Found leading zero: \" + digits);\n  \t\t}\n  \t\tvar trailingDigits = \"\";\n  \t\tif (digits.length > 1) trailingDigits = digits.substring(1);\n  \t\tvar digitsWithDecimal = digits.charAt(0) + \".\" + trailingDigits;\n  \t\tif (this.isNegative()) return \"-\" + digitsWithDecimal + expStr;\n  \t\treturn digitsWithDecimal + expStr;\n  \t},\n  \tabs: function abs() {\n  \t\tif (this.isNaN()) return DD.NaN;\n  \t\tif (this.isNegative()) return this.negate();\n  \t\treturn new DD(this);\n  \t},\n  \tisPositive: function isPositive() {\n  \t\treturn this._hi > 0.0 || this._hi === 0.0 && this._lo > 0.0;\n  \t},\n  \tlt: function lt(y) {\n  \t\treturn this._hi < y._hi || this._hi === y._hi && this._lo < y._lo;\n  \t},\n  \tadd: function add() {\n  \t\tif (arguments[0] instanceof DD) {\n  \t\t\tvar y = arguments[0];\n  \t\t\treturn DD.copy(this).selfAdd(y);\n  \t\t} else if (typeof arguments[0] === \"number\") {\n  \t\t\tvar y = arguments[0];\n  \t\t\treturn DD.copy(this).selfAdd(y);\n  \t\t}\n  \t},\n  \tinit: function init() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tif (typeof arguments[0] === \"number\") {\n  \t\t\t\tvar x = arguments[0];\n  \t\t\t\tthis._hi = x;\n  \t\t\t\tthis._lo = 0.0;\n  \t\t\t} else if (arguments[0] instanceof DD) {\n  \t\t\t\tvar dd = arguments[0];\n  \t\t\t\tthis._hi = dd._hi;\n  \t\t\t\tthis._lo = dd._lo;\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar hi = arguments[0],\n  \t\t\t    lo = arguments[1];\n  \t\t\tthis._hi = hi;\n  \t\t\tthis._lo = lo;\n  \t\t}\n  \t},\n  \tgt: function gt(y) {\n  \t\treturn this._hi > y._hi || this._hi === y._hi && this._lo > y._lo;\n  \t},\n  \tisNegative: function isNegative() {\n  \t\treturn this._hi < 0.0 || this._hi === 0.0 && this._lo < 0.0;\n  \t},\n  \ttrunc: function trunc() {\n  \t\tif (this.isNaN()) return DD.NaN;\n  \t\tif (this.isPositive()) return this.floor();else return this.ceil();\n  \t},\n  \tsignum: function signum() {\n  \t\tif (this._hi > 0) return 1;\n  \t\tif (this._hi < 0) return -1;\n  \t\tif (this._lo > 0) return 1;\n  \t\tif (this._lo < 0) return -1;\n  \t\treturn 0;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Serializable, Comparable, Clonable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn DD;\n  \t}\n  });\n  DD.sqr = function (x) {\n  \treturn DD.valueOf(x).selfMultiply(x);\n  };\n  DD.valueOf = function () {\n  \tif (typeof arguments[0] === \"string\") {\n  \t\tvar str = arguments[0];\n  \t\treturn DD.parse(str);\n  \t} else if (typeof arguments[0] === \"number\") {\n  \t\tvar x = arguments[0];\n  \t\treturn new DD(x);\n  \t}\n  };\n  DD.sqrt = function (x) {\n  \treturn DD.valueOf(x).sqrt();\n  };\n  DD.parse = function (str) {\n  \tvar i = 0;\n  \tvar strlen = str.length;\n  \twhile (Character.isWhitespace(str.charAt(i))) {\n  \t\ti++;\n  \t}var isNegative = false;\n  \tif (i < strlen) {\n  \t\tvar signCh = str.charAt(i);\n  \t\tif (signCh === '-' || signCh === '+') {\n  \t\t\ti++;\n  \t\t\tif (signCh === '-') isNegative = true;\n  \t\t}\n  \t}\n  \tvar val = new DD();\n  \tvar numDigits = 0;\n  \tvar numBeforeDec = 0;\n  \tvar exp = 0;\n  \twhile (true) {\n  \t\tif (i >= strlen) break;\n  \t\tvar ch = str.charAt(i);\n  \t\ti++;\n  \t\tif (Character.isDigit(ch)) {\n  \t\t\tvar d = ch - '0';\n  \t\t\tval.selfMultiply(DD.TEN);\n  \t\t\tval.selfAdd(d);\n  \t\t\tnumDigits++;\n  \t\t\tcontinue;\n  \t\t}\n  \t\tif (ch === '.') {\n  \t\t\tnumBeforeDec = numDigits;\n  \t\t\tcontinue;\n  \t\t}\n  \t\tif (ch === 'e' || ch === 'E') {\n  \t\t\tvar expStr = str.substring(i);\n  \t\t\ttry {\n  \t\t\t\texp = Integer.parseInt(expStr);\n  \t\t\t} catch (ex) {\n  \t\t\t\tif (ex instanceof NumberFormatException) {\n  \t\t\t\t\tthrow new NumberFormatException(\"Invalid exponent \" + expStr + \" in string \" + str);\n  \t\t\t\t} else throw ex;\n  \t\t\t} finally {}\n  \t\t\tbreak;\n  \t\t}\n  \t\tthrow new NumberFormatException(\"Unexpected character '\" + ch + \"' at position \" + i + \" in string \" + str);\n  \t}\n  \tvar val2 = val;\n  \tvar numDecPlaces = numDigits - numBeforeDec - exp;\n  \tif (numDecPlaces === 0) {\n  \t\tval2 = val;\n  \t} else if (numDecPlaces > 0) {\n  \t\tvar scale = DD.TEN.pow(numDecPlaces);\n  \t\tval2 = val.divide(scale);\n  \t} else if (numDecPlaces < 0) {\n  \t\tvar scale = DD.TEN.pow(-numDecPlaces);\n  \t\tval2 = val.multiply(scale);\n  \t}\n  \tif (isNegative) {\n  \t\treturn val2.negate();\n  \t}\n  \treturn val2;\n  };\n  DD.createNaN = function () {\n  \treturn new DD(Double.NaN, Double.NaN);\n  };\n  DD.copy = function (dd) {\n  \treturn new DD(dd);\n  };\n  DD.magnitude = function (x) {\n  \tvar xAbs = Math.abs(x);\n  \tvar xLog10 = Math.log(xAbs) / Math.log(10);\n  \tvar xMag = Math.trunc(Math.floor(xLog10));\n  \tvar xApprox = Math.pow(10, xMag);\n  \tif (xApprox * 10 <= xAbs) xMag += 1;\n  \treturn xMag;\n  };\n  DD.stringOfChar = function (ch, len) {\n  \tvar buf = new StringBuffer();\n  \tfor (var i = 0; i < len; i++) {\n  \t\tbuf.append(ch);\n  \t}\n  \treturn buf.toString();\n  };\n  DD.PI = new DD(3.141592653589793116e+00, 1.224646799147353207e-16);\n  DD.TWO_PI = new DD(6.283185307179586232e+00, 2.449293598294706414e-16);\n  DD.PI_2 = new DD(1.570796326794896558e+00, 6.123233995736766036e-17);\n  DD.E = new DD(2.718281828459045091e+00, 1.445646891729250158e-16);\n  DD.NaN = new DD(Double.NaN, Double.NaN);\n  DD.EPS = 1.23259516440783e-32;\n  DD.SPLIT = 134217729.0;\n  DD.MAX_PRINT_DIGITS = 32;\n  DD.TEN = DD.valueOf(10.0);\n  DD.ONE = DD.valueOf(1.0);\n  DD.SCI_NOT_EXPONENT_CHAR = \"E\";\n  DD.SCI_NOT_ZERO = \"0.0E0\";\n\n  function CGAlgorithmsDD() {}\n  extend(CGAlgorithmsDD.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn CGAlgorithmsDD;\n  \t}\n  });\n  CGAlgorithmsDD.orientationIndex = function (p1, p2, q) {\n  \tvar index = CGAlgorithmsDD.orientationIndexFilter(p1, p2, q);\n  \tif (index <= 1) return index;\n  \tvar dx1 = DD.valueOf(p2.x).selfAdd(-p1.x);\n  \tvar dy1 = DD.valueOf(p2.y).selfAdd(-p1.y);\n  \tvar dx2 = DD.valueOf(q.x).selfAdd(-p2.x);\n  \tvar dy2 = DD.valueOf(q.y).selfAdd(-p2.y);\n  \treturn dx1.selfMultiply(dy2).selfSubtract(dy1.selfMultiply(dx2)).signum();\n  };\n  CGAlgorithmsDD.signOfDet2x2 = function (x1, y1, x2, y2) {\n  \tvar det = x1.multiply(y2).selfSubtract(y1.multiply(x2));\n  \treturn det.signum();\n  };\n  CGAlgorithmsDD.intersection = function (p1, p2, q1, q2) {\n  \tvar denom1 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p2.x).selfSubtract(p1.x));\n  \tvar denom2 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p2.y).selfSubtract(p1.y));\n  \tvar denom = denom1.subtract(denom2);\n  \tvar numx1 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));\n  \tvar numx2 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));\n  \tvar numx = numx1.subtract(numx2);\n  \tvar fracP = numx.selfDivide(denom).doubleValue();\n  \tvar x = DD.valueOf(p1.x).selfAdd(DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(fracP)).doubleValue();\n  \tvar numy1 = DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));\n  \tvar numy2 = DD.valueOf(p2.y).selfSubtract(p1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));\n  \tvar numy = numy1.subtract(numy2);\n  \tvar fracQ = numy.selfDivide(denom).doubleValue();\n  \tvar y = DD.valueOf(q1.y).selfAdd(DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(fracQ)).doubleValue();\n  \treturn new Coordinate(x, y);\n  };\n  CGAlgorithmsDD.orientationIndexFilter = function (pa, pb, pc) {\n  \tvar detsum = null;\n  \tvar detleft = (pa.x - pc.x) * (pb.y - pc.y);\n  \tvar detright = (pa.y - pc.y) * (pb.x - pc.x);\n  \tvar det = detleft - detright;\n  \tif (detleft > 0.0) {\n  \t\tif (detright <= 0.0) {\n  \t\t\treturn CGAlgorithmsDD.signum(det);\n  \t\t} else {\n  \t\t\tdetsum = detleft + detright;\n  \t\t}\n  \t} else if (detleft < 0.0) {\n  \t\tif (detright >= 0.0) {\n  \t\t\treturn CGAlgorithmsDD.signum(det);\n  \t\t} else {\n  \t\t\tdetsum = -detleft - detright;\n  \t\t}\n  \t} else {\n  \t\treturn CGAlgorithmsDD.signum(det);\n  \t}\n  \tvar errbound = CGAlgorithmsDD.DP_SAFE_EPSILON * detsum;\n  \tif (det >= errbound || -det >= errbound) {\n  \t\treturn CGAlgorithmsDD.signum(det);\n  \t}\n  \treturn 2;\n  };\n  CGAlgorithmsDD.signum = function (x) {\n  \tif (x > 0) return 1;\n  \tif (x < 0) return -1;\n  \treturn 0;\n  };\n  CGAlgorithmsDD.DP_SAFE_EPSILON = 1e-15;\n\n  function CoordinateSequence() {}\n  extend(CoordinateSequence.prototype, {\n  \tsetOrdinate: function setOrdinate(index, ordinateIndex, value) {},\n  \tsize: function size() {},\n  \tgetOrdinate: function getOrdinate(index, ordinateIndex) {},\n  \tgetCoordinate: function getCoordinate() {\n  \t},\n  \tgetCoordinateCopy: function getCoordinateCopy(i) {},\n  \tgetDimension: function getDimension() {},\n  \tgetX: function getX(index) {},\n  \tclone: function clone() {},\n  \texpandEnvelope: function expandEnvelope(env) {},\n  \tcopy: function copy() {},\n  \tgetY: function getY(index) {},\n  \ttoCoordinateArray: function toCoordinateArray() {},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Clonable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn CoordinateSequence;\n  \t}\n  });\n  CoordinateSequence.X = 0;\n  CoordinateSequence.Y = 1;\n  CoordinateSequence.Z = 2;\n  CoordinateSequence.M = 3;\n\n  function System() {}\n  System.arraycopy = function (src, srcPos, dest, destPos, len) {\n    var c = 0;\n    for (var i = srcPos; i < srcPos + len; i++) {\n      dest[destPos + c] = src[i];\n      c++;\n    }\n  };\n  System.getProperty = function (name) {\n    return {\n      'line.separator': '\\n'\n    }[name];\n  };\n\n  function HCoordinate() {\n  \tthis.x = null;\n  \tthis.y = null;\n  \tthis.w = null;\n  \tif (arguments.length === 0) {\n  \t\tthis.x = 0.0;\n  \t\tthis.y = 0.0;\n  \t\tthis.w = 1.0;\n  \t} else if (arguments.length === 1) {\n  \t\tvar p = arguments[0];\n  \t\tthis.x = p.x;\n  \t\tthis.y = p.y;\n  \t\tthis.w = 1.0;\n  \t} else if (arguments.length === 2) {\n  \t\tif (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\") {\n  \t\t\tvar _x = arguments[0],\n  \t\t\t    _y = arguments[1];\n  \t\t\tthis.x = _x;\n  \t\t\tthis.y = _y;\n  \t\t\tthis.w = 1.0;\n  \t\t} else if (arguments[0] instanceof HCoordinate && arguments[1] instanceof HCoordinate) {\n  \t\t\tvar p1 = arguments[0],\n  \t\t\t    p2 = arguments[1];\n  \t\t\tthis.x = p1.y * p2.w - p2.y * p1.w;\n  \t\t\tthis.y = p2.x * p1.w - p1.x * p2.w;\n  \t\t\tthis.w = p1.x * p2.y - p2.x * p1.y;\n  \t\t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n  \t\t\tvar p1 = arguments[0],\n  \t\t\t    p2 = arguments[1];\n  \t\t\tthis.x = p1.y - p2.y;\n  \t\t\tthis.y = p2.x - p1.x;\n  \t\t\tthis.w = p1.x * p2.y - p2.x * p1.y;\n  \t\t}\n  \t} else if (arguments.length === 3) {\n  \t\tvar _x = arguments[0],\n  \t\t    _y = arguments[1],\n  \t\t    _w = arguments[2];\n  \t\tthis.x = _x;\n  \t\tthis.y = _y;\n  \t\tthis.w = _w;\n  \t} else if (arguments.length === 4) {\n  \t\tvar p1 = arguments[0],\n  \t\t    p2 = arguments[1],\n  \t\t    q1 = arguments[2],\n  \t\t    q2 = arguments[3];\n  \t\tvar px = p1.y - p2.y;\n  \t\tvar py = p2.x - p1.x;\n  \t\tvar pw = p1.x * p2.y - p2.x * p1.y;\n  \t\tvar qx = q1.y - q2.y;\n  \t\tvar qy = q2.x - q1.x;\n  \t\tvar qw = q1.x * q2.y - q2.x * q1.y;\n  \t\tthis.x = py * qw - qy * pw;\n  \t\tthis.y = qx * pw - px * qw;\n  \t\tthis.w = px * qy - qx * py;\n  \t}\n  }\n  extend(HCoordinate.prototype, {\n  \tgetY: function getY() {\n  \t\tvar a = this.y / this.w;\n  \t\tif (Double.isNaN(a) || Double.isInfinite(a)) {\n  \t\t\tthrow new NotRepresentableException();\n  \t\t}\n  \t\treturn a;\n  \t},\n  \tgetX: function getX() {\n  \t\tvar a = this.x / this.w;\n  \t\tif (Double.isNaN(a) || Double.isInfinite(a)) {\n  \t\t\tthrow new NotRepresentableException();\n  \t\t}\n  \t\treturn a;\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\tvar p = new Coordinate();\n  \t\tp.x = this.getX();\n  \t\tp.y = this.getY();\n  \t\treturn p;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn HCoordinate;\n  \t}\n  });\n  HCoordinate.intersection = function (p1, p2, q1, q2) {\n  \tvar px = p1.y - p2.y;\n  \tvar py = p2.x - p1.x;\n  \tvar pw = p1.x * p2.y - p2.x * p1.y;\n  \tvar qx = q1.y - q2.y;\n  \tvar qy = q2.x - q1.x;\n  \tvar qw = q1.x * q2.y - q2.x * q1.y;\n  \tvar x = py * qw - qy * pw;\n  \tvar y = qx * pw - px * qw;\n  \tvar w = px * qy - qx * py;\n  \tvar xInt = x / w;\n  \tvar yInt = y / w;\n  \tif (Double.isNaN(xInt) || Double.isInfinite(xInt) || Double.isNaN(yInt) || Double.isInfinite(yInt)) {\n  \t\tthrow new NotRepresentableException();\n  \t}\n  \treturn new Coordinate(xInt, yInt);\n  };\n\n  function CoordinateSequenceFactory() {}\n  extend(CoordinateSequenceFactory.prototype, {\n  \tcreate: function create() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tif (arguments[0] instanceof Array) ; else if (hasInterface(arguments[0], CoordinateSequence)) ;\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn CoordinateSequenceFactory;\n  \t}\n  });\n\n  function GeometryComponentFilter() {}\n  extend(GeometryComponentFilter.prototype, {\n  \tfilter: function filter(geom) {},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn GeometryComponentFilter;\n  \t}\n  });\n\n  function Geometry() {\n  \tthis._envelope = null;\n  \tthis._factory = null;\n  \tthis._SRID = null;\n  \tthis._userData = null;\n  \tvar factory = arguments[0];\n  \tthis._factory = factory;\n  \tthis._SRID = factory.getSRID();\n  }\n  extend(Geometry.prototype, {\n  \tisGeometryCollection: function isGeometryCollection() {\n  \t\treturn this.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION;\n  \t},\n  \tgetFactory: function getFactory() {\n  \t\treturn this._factory;\n  \t},\n  \tgetGeometryN: function getGeometryN(n) {\n  \t\treturn this;\n  \t},\n  \tgetArea: function getArea() {\n  \t\treturn 0.0;\n  \t},\n  \tisRectangle: function isRectangle() {\n  \t\treturn false;\n  \t},\n  \tequals: function equals() {\n  \t\tif (arguments[0] instanceof Geometry) {\n  \t\t\tvar g = arguments[0];\n  \t\t\tif (g === null) return false;\n  \t\t\treturn this.equalsTopo(g);\n  \t\t} else if (arguments[0] instanceof Object) {\n  \t\t\tvar o = arguments[0];\n  \t\t\tif (!(o instanceof Geometry)) return false;\n  \t\t\tvar g = o;\n  \t\t\treturn this.equalsExact(g);\n  \t\t}\n  \t},\n  \tequalsExact: function equalsExact(other) {\n  \t\treturn this === other || this.equalsExact(other, 0);\n  \t},\n  \tgeometryChanged: function geometryChanged() {\n  \t\tthis.apply(Geometry.geometryChangedFilter);\n  \t},\n  \tgeometryChangedAction: function geometryChangedAction() {\n  \t\tthis._envelope = null;\n  \t},\n  \tequalsNorm: function equalsNorm(g) {\n  \t\tif (g === null) return false;\n  \t\treturn this.norm().equalsExact(g.norm());\n  \t},\n  \tgetLength: function getLength() {\n  \t\treturn 0.0;\n  \t},\n  \tgetNumGeometries: function getNumGeometries() {\n  \t\treturn 1;\n  \t},\n  \tcompareTo: function compareTo() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar o = arguments[0];\n  \t\t\tvar other = o;\n  \t\t\tif (this.getSortIndex() !== other.getSortIndex()) {\n  \t\t\t\treturn this.getSortIndex() - other.getSortIndex();\n  \t\t\t}\n  \t\t\tif (this.isEmpty() && other.isEmpty()) {\n  \t\t\t\treturn 0;\n  \t\t\t}\n  \t\t\tif (this.isEmpty()) {\n  \t\t\t\treturn -1;\n  \t\t\t}\n  \t\t\tif (other.isEmpty()) {\n  \t\t\t\treturn 1;\n  \t\t\t}\n  \t\t\treturn this.compareToSameClass(o);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar o = arguments[0],\n  \t\t\t    comp = arguments[1];\n  \t\t\tvar other = o;\n  \t\t\tif (this.getSortIndex() !== other.getSortIndex()) {\n  \t\t\t\treturn this.getSortIndex() - other.getSortIndex();\n  \t\t\t}\n  \t\t\tif (this.isEmpty() && other.isEmpty()) {\n  \t\t\t\treturn 0;\n  \t\t\t}\n  \t\t\tif (this.isEmpty()) {\n  \t\t\t\treturn -1;\n  \t\t\t}\n  \t\t\tif (other.isEmpty()) {\n  \t\t\t\treturn 1;\n  \t\t\t}\n  \t\t\treturn this.compareToSameClass(o, comp);\n  \t\t}\n  \t},\n  \tgetUserData: function getUserData() {\n  \t\treturn this._userData;\n  \t},\n  \tgetSRID: function getSRID() {\n  \t\treturn this._SRID;\n  \t},\n  \tgetEnvelope: function getEnvelope() {\n  \t\treturn this.getFactory().toGeometry(this.getEnvelopeInternal());\n  \t},\n  \tcheckNotGeometryCollection: function checkNotGeometryCollection(g) {\n  \t\tif (g.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION) {\n  \t\t\tthrow new IllegalArgumentException(\"This method does not support GeometryCollection arguments\");\n  \t\t}\n  \t},\n  \tequal: function equal(a, b, tolerance) {\n  \t\tif (tolerance === 0) {\n  \t\t\treturn a.equals(b);\n  \t\t}\n  \t\treturn a.distance(b) <= tolerance;\n  \t},\n  \tnorm: function norm() {\n  \t\tvar copy = this.copy();\n  \t\tcopy.normalize();\n  \t\treturn copy;\n  \t},\n  \tgetPrecisionModel: function getPrecisionModel() {\n  \t\treturn this._factory.getPrecisionModel();\n  \t},\n  \tgetEnvelopeInternal: function getEnvelopeInternal() {\n  \t\tif (this._envelope === null) {\n  \t\t\tthis._envelope = this.computeEnvelopeInternal();\n  \t\t}\n  \t\treturn new Envelope(this._envelope);\n  \t},\n  \tsetSRID: function setSRID(SRID) {\n  \t\tthis._SRID = SRID;\n  \t},\n  \tsetUserData: function setUserData(userData) {\n  \t\tthis._userData = userData;\n  \t},\n  \tcompare: function compare(a, b) {\n  \t\tvar i = a.iterator();\n  \t\tvar j = b.iterator();\n  \t\twhile (i.hasNext() && j.hasNext()) {\n  \t\t\tvar aElement = i.next();\n  \t\t\tvar bElement = j.next();\n  \t\t\tvar comparison = aElement.compareTo(bElement);\n  \t\t\tif (comparison !== 0) {\n  \t\t\t\treturn comparison;\n  \t\t\t}\n  \t\t}\n  \t\tif (i.hasNext()) {\n  \t\t\treturn 1;\n  \t\t}\n  \t\tif (j.hasNext()) {\n  \t\t\treturn -1;\n  \t\t}\n  \t\treturn 0;\n  \t},\n  \thashCode: function hashCode() {\n  \t\treturn this.getEnvelopeInternal().hashCode();\n  \t},\n  \tisGeometryCollectionOrDerived: function isGeometryCollectionOrDerived() {\n  \t\tif (this.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === Geometry.SORTINDEX_MULTIPOINT || this.getSortIndex() === Geometry.SORTINDEX_MULTILINESTRING || this.getSortIndex() === Geometry.SORTINDEX_MULTIPOLYGON) {\n  \t\t\treturn true;\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Clonable, Comparable, Serializable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Geometry;\n  \t}\n  });\n  Geometry.hasNonEmptyElements = function (geometries) {\n  \tfor (var i = 0; i < geometries.length; i++) {\n  \t\tif (!geometries[i].isEmpty()) {\n  \t\t\treturn true;\n  \t\t}\n  \t}\n  \treturn false;\n  };\n  Geometry.hasNullElements = function (array) {\n  \tfor (var i = 0; i < array.length; i++) {\n  \t\tif (array[i] === null) {\n  \t\t\treturn true;\n  \t\t}\n  \t}\n  \treturn false;\n  };\n  Geometry.serialVersionUID = 8763622679187376702;\n  Geometry.SORTINDEX_POINT = 0;\n  Geometry.SORTINDEX_MULTIPOINT = 1;\n  Geometry.SORTINDEX_LINESTRING = 2;\n  Geometry.SORTINDEX_LINEARRING = 3;\n  Geometry.SORTINDEX_MULTILINESTRING = 4;\n  Geometry.SORTINDEX_POLYGON = 5;\n  Geometry.SORTINDEX_MULTIPOLYGON = 6;\n  Geometry.SORTINDEX_GEOMETRYCOLLECTION = 7;\n  Geometry.geometryChangedFilter = {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [GeometryComponentFilter];\n  \t},\n  \tfilter: function filter(geom) {\n  \t\tgeom.geometryChangedAction();\n  \t}\n  };\n\n  function CoordinateFilter() {}\n  extend(CoordinateFilter.prototype, {\n  \tfilter: function filter(coord) {},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn CoordinateFilter;\n  \t}\n  });\n\n  function BoundaryNodeRule() {}\n  extend(BoundaryNodeRule.prototype, {\n  \tisInBoundary: function isInBoundary(boundaryCount) {},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn BoundaryNodeRule;\n  \t}\n  });\n  function Mod2BoundaryNodeRule() {}\n  extend(Mod2BoundaryNodeRule.prototype, {\n  \tisInBoundary: function isInBoundary(boundaryCount) {\n  \t\treturn boundaryCount % 2 === 1;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [BoundaryNodeRule];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Mod2BoundaryNodeRule;\n  \t}\n  });\n  function EndPointBoundaryNodeRule() {}\n  extend(EndPointBoundaryNodeRule.prototype, {\n  \tisInBoundary: function isInBoundary(boundaryCount) {\n  \t\treturn boundaryCount > 0;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [BoundaryNodeRule];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn EndPointBoundaryNodeRule;\n  \t}\n  });\n  function MultiValentEndPointBoundaryNodeRule() {}\n  extend(MultiValentEndPointBoundaryNodeRule.prototype, {\n  \tisInBoundary: function isInBoundary(boundaryCount) {\n  \t\treturn boundaryCount > 1;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [BoundaryNodeRule];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MultiValentEndPointBoundaryNodeRule;\n  \t}\n  });\n  function MonoValentEndPointBoundaryNodeRule() {}\n  extend(MonoValentEndPointBoundaryNodeRule.prototype, {\n  \tisInBoundary: function isInBoundary(boundaryCount) {\n  \t\treturn boundaryCount === 1;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [BoundaryNodeRule];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MonoValentEndPointBoundaryNodeRule;\n  \t}\n  });\n  BoundaryNodeRule.Mod2BoundaryNodeRule = Mod2BoundaryNodeRule;\n  BoundaryNodeRule.EndPointBoundaryNodeRule = EndPointBoundaryNodeRule;\n  BoundaryNodeRule.MultiValentEndPointBoundaryNodeRule = MultiValentEndPointBoundaryNodeRule;\n  BoundaryNodeRule.MonoValentEndPointBoundaryNodeRule = MonoValentEndPointBoundaryNodeRule;\n  BoundaryNodeRule.MOD2_BOUNDARY_RULE = new Mod2BoundaryNodeRule();\n  BoundaryNodeRule.ENDPOINT_BOUNDARY_RULE = new EndPointBoundaryNodeRule();\n  BoundaryNodeRule.MULTIVALENT_ENDPOINT_BOUNDARY_RULE = new MultiValentEndPointBoundaryNodeRule();\n  BoundaryNodeRule.MONOVALENT_ENDPOINT_BOUNDARY_RULE = new MonoValentEndPointBoundaryNodeRule();\n  BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE = BoundaryNodeRule.MOD2_BOUNDARY_RULE;\n\n  function CoordinateArrays() {}\n  extend(CoordinateArrays.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn CoordinateArrays;\n  \t}\n  });\n  CoordinateArrays.isRing = function (pts) {\n  \tif (pts.length < 4) return false;\n  \tif (!pts[0].equals2D(pts[pts.length - 1])) return false;\n  \treturn true;\n  };\n  CoordinateArrays.ptNotInList = function (testPts, pts) {\n  \tfor (var i = 0; i < testPts.length; i++) {\n  \t\tvar testPt = testPts[i];\n  \t\tif (CoordinateArrays.indexOf(testPt, pts) < 0) return testPt;\n  \t}\n  \treturn null;\n  };\n  CoordinateArrays.scroll = function (coordinates, firstCoordinate) {\n  \tvar i = CoordinateArrays.indexOf(firstCoordinate, coordinates);\n  \tif (i < 0) return null;\n  \tvar newCoordinates = new Array(coordinates.length).fill(null);\n  \tSystem.arraycopy(coordinates, i, newCoordinates, 0, coordinates.length - i);\n  \tSystem.arraycopy(coordinates, 0, newCoordinates, coordinates.length - i, i);\n  \tSystem.arraycopy(newCoordinates, 0, coordinates, 0, coordinates.length);\n  };\n  CoordinateArrays.equals = function () {\n  \tif (arguments.length === 2) {\n  \t\tvar coord1 = arguments[0],\n  \t\t    coord2 = arguments[1];\n  \t\tif (coord1 === coord2) return true;\n  \t\tif (coord1 === null || coord2 === null) return false;\n  \t\tif (coord1.length !== coord2.length) return false;\n  \t\tfor (var i = 0; i < coord1.length; i++) {\n  \t\t\tif (!coord1[i].equals(coord2[i])) return false;\n  \t\t}\n  \t\treturn true;\n  \t} else if (arguments.length === 3) {\n  \t\tvar coord1 = arguments[0],\n  \t\t    coord2 = arguments[1],\n  \t\t    coordinateComparator = arguments[2];\n  \t\tif (coord1 === coord2) return true;\n  \t\tif (coord1 === null || coord2 === null) return false;\n  \t\tif (coord1.length !== coord2.length) return false;\n  \t\tfor (var i = 0; i < coord1.length; i++) {\n  \t\t\tif (coordinateComparator.compare(coord1[i], coord2[i]) !== 0) return false;\n  \t\t}\n  \t\treturn true;\n  \t}\n  };\n  CoordinateArrays.intersection = function (coordinates, env) {\n  \tvar coordList = new CoordinateList();\n  \tfor (var i = 0; i < coordinates.length; i++) {\n  \t\tif (env.intersects(coordinates[i])) coordList.add(coordinates[i], true);\n  \t}\n  \treturn coordList.toCoordinateArray();\n  };\n  CoordinateArrays.hasRepeatedPoints = function (coord) {\n  \tfor (var i = 1; i < coord.length; i++) {\n  \t\tif (coord[i - 1].equals(coord[i])) {\n  \t\t\treturn true;\n  \t\t}\n  \t}\n  \treturn false;\n  };\n  CoordinateArrays.removeRepeatedPoints = function (coord) {\n  \tif (!CoordinateArrays.hasRepeatedPoints(coord)) return coord;\n  \tvar coordList = new CoordinateList(coord, false);\n  \treturn coordList.toCoordinateArray();\n  };\n  CoordinateArrays.reverse = function (coord) {\n  \tvar last = coord.length - 1;\n  \tvar mid = Math.trunc(last / 2);\n  \tfor (var i = 0; i <= mid; i++) {\n  \t\tvar tmp = coord[i];\n  \t\tcoord[i] = coord[last - i];\n  \t\tcoord[last - i] = tmp;\n  \t}\n  };\n  CoordinateArrays.removeNull = function (coord) {\n  \tvar nonNull = 0;\n  \tfor (var i = 0; i < coord.length; i++) {\n  \t\tif (coord[i] !== null) nonNull++;\n  \t}\n  \tvar newCoord = new Array(nonNull).fill(null);\n  \tif (nonNull === 0) return newCoord;\n  \tvar j = 0;\n  \tfor (var i = 0; i < coord.length; i++) {\n  \t\tif (coord[i] !== null) newCoord[j++] = coord[i];\n  \t}\n  \treturn newCoord;\n  };\n  CoordinateArrays.copyDeep = function () {\n  \tif (arguments.length === 1) {\n  \t\tvar coordinates = arguments[0];\n  \t\tvar copy = new Array(coordinates.length).fill(null);\n  \t\tfor (var i = 0; i < coordinates.length; i++) {\n  \t\t\tcopy[i] = new Coordinate(coordinates[i]);\n  \t\t}\n  \t\treturn copy;\n  \t} else if (arguments.length === 5) {\n  \t\tvar src = arguments[0],\n  \t\t    srcStart = arguments[1],\n  \t\t    dest = arguments[2],\n  \t\t    destStart = arguments[3],\n  \t\t    length = arguments[4];\n  \t\tfor (var i = 0; i < length; i++) {\n  \t\t\tdest[destStart + i] = new Coordinate(src[srcStart + i]);\n  \t\t}\n  \t}\n  };\n  CoordinateArrays.isEqualReversed = function (pts1, pts2) {\n  \tfor (var i = 0; i < pts1.length; i++) {\n  \t\tvar p1 = pts1[i];\n  \t\tvar p2 = pts2[pts1.length - i - 1];\n  \t\tif (p1.compareTo(p2) !== 0) return false;\n  \t}\n  \treturn true;\n  };\n  CoordinateArrays.envelope = function (coordinates) {\n  \tvar env = new Envelope();\n  \tfor (var i = 0; i < coordinates.length; i++) {\n  \t\tenv.expandToInclude(coordinates[i]);\n  \t}\n  \treturn env;\n  };\n  CoordinateArrays.toCoordinateArray = function (coordList) {\n  \treturn coordList.toArray(CoordinateArrays.coordArrayType);\n  };\n  CoordinateArrays.atLeastNCoordinatesOrNothing = function (n, c) {\n  \treturn c.length >= n ? c : [];\n  };\n  CoordinateArrays.indexOf = function (coordinate, coordinates) {\n  \tfor (var i = 0; i < coordinates.length; i++) {\n  \t\tif (coordinate.equals(coordinates[i])) {\n  \t\t\treturn i;\n  \t\t}\n  \t}\n  \treturn -1;\n  };\n  CoordinateArrays.increasingDirection = function (pts) {\n  \tfor (var i = 0; i < Math.trunc(pts.length / 2); i++) {\n  \t\tvar j = pts.length - 1 - i;\n  \t\tvar comp = pts[i].compareTo(pts[j]);\n  \t\tif (comp !== 0) return comp;\n  \t}\n  \treturn 1;\n  };\n  CoordinateArrays.compare = function (pts1, pts2) {\n  \tvar i = 0;\n  \twhile (i < pts1.length && i < pts2.length) {\n  \t\tvar compare = pts1[i].compareTo(pts2[i]);\n  \t\tif (compare !== 0) return compare;\n  \t\ti++;\n  \t}\n  \tif (i < pts2.length) return -1;\n  \tif (i < pts1.length) return 1;\n  \treturn 0;\n  };\n  CoordinateArrays.minCoordinate = function (coordinates) {\n  \tvar minCoord = null;\n  \tfor (var i = 0; i < coordinates.length; i++) {\n  \t\tif (minCoord === null || minCoord.compareTo(coordinates[i]) > 0) {\n  \t\t\tminCoord = coordinates[i];\n  \t\t}\n  \t}\n  \treturn minCoord;\n  };\n  CoordinateArrays.extract = function (pts, start, end) {\n  \tstart = MathUtil.clamp(start, 0, pts.length);\n  \tend = MathUtil.clamp(end, -1, pts.length);\n  \tvar npts = end - start + 1;\n  \tif (end < 0) npts = 0;\n  \tif (start >= pts.length) npts = 0;\n  \tif (end < start) npts = 0;\n  \tvar extractPts = new Array(npts).fill(null);\n  \tif (npts === 0) return extractPts;\n  \tvar iPts = 0;\n  \tfor (var i = start; i <= end; i++) {\n  \t\textractPts[iPts++] = pts[i];\n  \t}\n  \treturn extractPts;\n  };\n  function ForwardComparator() {}\n  extend(ForwardComparator.prototype, {\n  \tcompare: function compare(o1, o2) {\n  \t\tvar pts1 = o1;\n  \t\tvar pts2 = o2;\n  \t\treturn CoordinateArrays.compare(pts1, pts2);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparator];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn ForwardComparator;\n  \t}\n  });\n  function BidirectionalComparator() {}\n  extend(BidirectionalComparator.prototype, {\n  \tcompare: function compare(o1, o2) {\n  \t\tvar pts1 = o1;\n  \t\tvar pts2 = o2;\n  \t\tif (pts1.length < pts2.length) return -1;\n  \t\tif (pts1.length > pts2.length) return 1;\n  \t\tif (pts1.length === 0) return 0;\n  \t\tvar forwardComp = CoordinateArrays.compare(pts1, pts2);\n  \t\tvar isEqualRev = CoordinateArrays.isEqualReversed(pts1, pts2);\n  \t\tif (isEqualRev) return 0;\n  \t\treturn forwardComp;\n  \t},\n  \tOLDcompare: function OLDcompare(o1, o2) {\n  \t\tvar pts1 = o1;\n  \t\tvar pts2 = o2;\n  \t\tif (pts1.length < pts2.length) return -1;\n  \t\tif (pts1.length > pts2.length) return 1;\n  \t\tif (pts1.length === 0) return 0;\n  \t\tvar dir1 = CoordinateArrays.increasingDirection(pts1);\n  \t\tvar dir2 = CoordinateArrays.increasingDirection(pts2);\n  \t\tvar i1 = dir1 > 0 ? 0 : pts1.length - 1;\n  \t\tvar i2 = dir2 > 0 ? 0 : pts1.length - 1;\n  \t\tfor (var i = 0; i < pts1.length; i++) {\n  \t\t\tvar comparePt = pts1[i1].compareTo(pts2[i2]);\n  \t\t\tif (comparePt !== 0) return comparePt;\n  \t\t\ti1 += dir1;\n  \t\t\ti2 += dir2;\n  \t\t}\n  \t\treturn 0;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparator];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn BidirectionalComparator;\n  \t}\n  });\n  CoordinateArrays.ForwardComparator = ForwardComparator;\n  CoordinateArrays.BidirectionalComparator = BidirectionalComparator;\n  CoordinateArrays.coordArrayType = new Array(0).fill(null);\n\n  function Map$2() {}Map$2.prototype.get = function () {};\n  Map$2.prototype.put = function () {};\n  Map$2.prototype.size = function () {};\n  Map$2.prototype.values = function () {};\n  Map$2.prototype.entrySet = function () {};\n\n  function SortedMap() {}SortedMap.prototype = new Map$2();\n\n  function Set$1() {}Set$1.prototype = new Collection();\n  Set$1.prototype.contains = function () {};\n\n  function HashSet() {\n    this.array_ = [];\n    if (arguments[0] instanceof Collection) {\n      this.addAll(arguments[0]);\n    }\n  }HashSet.prototype = new Set$1();\n  HashSet.prototype.contains = function (o) {\n    for (var i = 0, len = this.array_.length; i < len; i++) {\n      var e = this.array_[i];\n      if (e === o) {\n        return true;\n      }\n    }\n    return false;\n  };\n  HashSet.prototype.add = function (o) {\n    if (this.contains(o)) {\n      return false;\n    }\n    this.array_.push(o);\n    return true;\n  };\n  HashSet.prototype.addAll = function (c) {\n    for (var i = c.iterator(); i.hasNext();) {\n      this.add(i.next());\n    }\n    return true;\n  };\n  HashSet.prototype.remove = function (o) {\n    throw new javascript.util.OperationNotSupported();\n  };\n  HashSet.prototype.size = function () {\n    return this.array_.length;\n  };\n  HashSet.prototype.isEmpty = function () {\n    return this.array_.length === 0;\n  };\n  HashSet.prototype.toArray = function () {\n    var array = [];\n    for (var i = 0, len = this.array_.length; i < len; i++) {\n      array.push(this.array_[i]);\n    }\n    return array;\n  };\n  HashSet.prototype.iterator = function () {\n    return new Iterator_$1(this);\n  };\n  var Iterator_$1 = function Iterator_(hashSet) {\n    this.hashSet_ = hashSet;\n    this.position_ = 0;\n  };\n  Iterator_$1.prototype.next = function () {\n    if (this.position_ === this.hashSet_.size()) {\n      throw new NoSuchElementException();\n    }\n    return this.hashSet_.array_[this.position_++];\n  };\n  Iterator_$1.prototype.hasNext = function () {\n    if (this.position_ < this.hashSet_.size()) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  Iterator_$1.prototype.remove = function () {\n    throw new OperationNotSupported();\n  };\n\n  var BLACK = 0;\n  var RED = 1;\n  function colorOf(p) {\n    return p == null ? BLACK : p.color;\n  }\n  function parentOf(p) {\n    return p == null ? null : p.parent;\n  }\n  function setColor(p, c) {\n    if (p !== null) p.color = c;\n  }\n  function leftOf(p) {\n    return p == null ? null : p.left;\n  }\n  function rightOf(p) {\n    return p == null ? null : p.right;\n  }\n  function TreeMap() {\n    this.root_ = null;\n    this.size_ = 0;\n  }TreeMap.prototype = new SortedMap();\n  TreeMap.prototype.get = function (key) {\n    var p = this.root_;\n    while (p !== null) {\n      var cmp = key['compareTo'](p.key);\n      if (cmp < 0) {\n        p = p.left;\n      } else if (cmp > 0) {\n        p = p.right;\n      } else {\n        return p.value;\n      }\n    }\n    return null;\n  };\n  TreeMap.prototype.put = function (key, value) {\n    if (this.root_ === null) {\n      this.root_ = {\n        key: key,\n        value: value,\n        left: null,\n        right: null,\n        parent: null,\n        color: BLACK,\n        getValue: function getValue() {\n          return this.value;\n        },\n        getKey: function getKey() {\n          return this.key;\n        }\n      };\n      this.size_ = 1;\n      return null;\n    }\n    var t = this.root_,\n        parent,\n        cmp;\n    do {\n      parent = t;\n      cmp = key['compareTo'](t.key);\n      if (cmp < 0) {\n        t = t.left;\n      } else if (cmp > 0) {\n        t = t.right;\n      } else {\n        var oldValue = t.value;\n        t.value = value;\n        return oldValue;\n      }\n    } while (t !== null);\n    var e = {\n      key: key,\n      left: null,\n      right: null,\n      value: value,\n      parent: parent,\n      color: BLACK,\n      getValue: function getValue() {\n        return this.value;\n      },\n      getKey: function getKey() {\n        return this.key;\n      }\n    };\n    if (cmp < 0) {\n      parent.left = e;\n    } else {\n      parent.right = e;\n    }\n    this.fixAfterInsertion(e);\n    this.size_++;\n    return null;\n  };\n  TreeMap.prototype.fixAfterInsertion = function (x) {\n    x.color = RED;\n    while (x != null && x != this.root_ && x.parent.color == RED) {\n      if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {\n        var y = rightOf(parentOf(parentOf(x)));\n        if (colorOf(y) == RED) {\n          setColor(parentOf(x), BLACK);\n          setColor(y, BLACK);\n          setColor(parentOf(parentOf(x)), RED);\n          x = parentOf(parentOf(x));\n        } else {\n          if (x == rightOf(parentOf(x))) {\n            x = parentOf(x);\n            this.rotateLeft(x);\n          }\n          setColor(parentOf(x), BLACK);\n          setColor(parentOf(parentOf(x)), RED);\n          this.rotateRight(parentOf(parentOf(x)));\n        }\n      } else {\n        var y = leftOf(parentOf(parentOf(x)));\n        if (colorOf(y) == RED) {\n          setColor(parentOf(x), BLACK);\n          setColor(y, BLACK);\n          setColor(parentOf(parentOf(x)), RED);\n          x = parentOf(parentOf(x));\n        } else {\n          if (x == leftOf(parentOf(x))) {\n            x = parentOf(x);\n            this.rotateRight(x);\n          }\n          setColor(parentOf(x), BLACK);\n          setColor(parentOf(parentOf(x)), RED);\n          this.rotateLeft(parentOf(parentOf(x)));\n        }\n      }\n    }\n    this.root_.color = BLACK;\n  };\n  TreeMap.prototype.values = function () {\n    var arrayList = new ArrayList();\n    var p = this.getFirstEntry();\n    if (p !== null) {\n      arrayList.add(p.value);\n      while ((p = TreeMap.successor(p)) !== null) {\n        arrayList.add(p.value);\n      }\n    }\n    return arrayList;\n  };\n  TreeMap.prototype.entrySet = function () {\n    var hashSet = new HashSet();\n    var p = this.getFirstEntry();\n    if (p !== null) {\n      hashSet.add(p);\n      while ((p = TreeMap.successor(p)) !== null) {\n        hashSet.add(p);\n      }\n    }\n    return hashSet;\n  };\n  TreeMap.prototype.rotateLeft = function (p) {\n    if (p != null) {\n      var r = p.right;\n      p.right = r.left;\n      if (r.left != null) r.left.parent = p;\n      r.parent = p.parent;\n      if (p.parent == null) this.root_ = r;else if (p.parent.left == p) p.parent.left = r;else p.parent.right = r;\n      r.left = p;\n      p.parent = r;\n    }\n  };\n  TreeMap.prototype.rotateRight = function (p) {\n    if (p != null) {\n      var l = p.left;\n      p.left = l.right;\n      if (l.right != null) l.right.parent = p;\n      l.parent = p.parent;\n      if (p.parent == null) this.root_ = l;else if (p.parent.right == p) p.parent.right = l;else p.parent.left = l;\n      l.right = p;\n      p.parent = l;\n    }\n  };\n  TreeMap.prototype.getFirstEntry = function () {\n    var p = this.root_;\n    if (p != null) {\n      while (p.left != null) {\n        p = p.left;\n      }\n    }\n    return p;\n  };\n  TreeMap.successor = function (t) {\n    if (t === null) return null;else if (t.right !== null) {\n      var p = t.right;\n      while (p.left !== null) {\n        p = p.left;\n      }\n      return p;\n    } else {\n      var p = t.parent;\n      var ch = t;\n      while (p !== null && ch === p.right) {\n        ch = p;\n        p = p.parent;\n      }\n      return p;\n    }\n  };\n  TreeMap.prototype.size = function () {\n    return this.size_;\n  };\n\n  function Lineal() {}\n  extend(Lineal.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Lineal;\n  \t}\n  });\n\n  function SortedSet() {}SortedSet.prototype = new Set$1();\n\n  function TreeSet() {\n    this.array_ = [];\n    if (arguments[0] instanceof Collection) {\n      this.addAll(arguments[0]);\n    }\n  }TreeSet.prototype = new SortedSet();\n  TreeSet.prototype.contains = function (o) {\n    for (var i = 0, len = this.array_.length; i < len; i++) {\n      var e = this.array_[i];\n      if (e['compareTo'](o) === 0) {\n        return true;\n      }\n    }\n    return false;\n  };\n  TreeSet.prototype.add = function (o) {\n    if (this.contains(o)) {\n      return false;\n    }\n    for (var i = 0, len = this.array_.length; i < len; i++) {\n      var e = this.array_[i];\n      if (e['compareTo'](o) === 1) {\n        this.array_.splice(i, 0, o);\n        return true;\n      }\n    }\n    this.array_.push(o);\n    return true;\n  };\n  TreeSet.prototype.addAll = function (c) {\n    for (var i = c.iterator(); i.hasNext();) {\n      this.add(i.next());\n    }\n    return true;\n  };\n  TreeSet.prototype.remove = function (e) {\n    throw new OperationNotSupported();\n  };\n  TreeSet.prototype.size = function () {\n    return this.array_.length;\n  };\n  TreeSet.prototype.isEmpty = function () {\n    return this.array_.length === 0;\n  };\n  TreeSet.prototype.toArray = function () {\n    var array = [];\n    for (var i = 0, len = this.array_.length; i < len; i++) {\n      array.push(this.array_[i]);\n    }\n    return array;\n  };\n  TreeSet.prototype.iterator = function () {\n    return new Iterator_$2(this);\n  };\n  var Iterator_$2 = function Iterator_(treeSet) {\n    this.treeSet_ = treeSet;\n    this.position_ = 0;\n  };\n  Iterator_$2.prototype.next = function () {\n    if (this.position_ === this.treeSet_.size()) {\n      throw new NoSuchElementException();\n    }\n    return this.treeSet_.array_[this.position_++];\n  };\n  Iterator_$2.prototype.hasNext = function () {\n    if (this.position_ < this.treeSet_.size()) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  Iterator_$2.prototype.remove = function () {\n    throw new OperationNotSupported();\n  };\n\n  function Arrays() {}Arrays.sort = function () {\n    var a = arguments[0],\n        i,\n        t,\n        comparator,\n        compare;\n    if (arguments.length === 1) {\n      compare = function compare(a, b) {\n        return a.compareTo(b);\n      };\n      a.sort(compare);\n      return;\n    } else if (arguments.length === 2) {\n      comparator = arguments[1];\n      compare = function compare(a, b) {\n        return comparator['compare'](a, b);\n      };\n      a.sort(compare);\n    } else if (arguments.length === 3) {\n      t = a.slice(arguments[1], arguments[2]);\n      t.sort();\n      var r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));\n      a.splice(0, a.length);\n      for (i = 0; i < r.length; i++) {\n        a.push(r[i]);\n      }\n      return;\n    } else if (arguments.length === 4) {\n      t = a.slice(arguments[1], arguments[2]);\n      comparator = arguments[3];\n      compare = function compare(a, b) {\n        return comparator['compare'](a, b);\n      };\n      t.sort(compare);\n      r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));\n      a.splice(0, a.length);\n      for (i = 0; i < r.length; i++) {\n        a.push(r[i]);\n      }\n      return;\n    }\n  };\n  Arrays.asList = function (array) {\n    var arrayList = new ArrayList();\n    for (var i = 0, len = array.length; i < len; i++) {\n      arrayList.add(array[i]);\n    }\n    return arrayList;\n  };\n\n  function Dimension() {}\n  extend(Dimension.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Dimension;\n  \t}\n  });\n  Dimension.toDimensionSymbol = function (dimensionValue) {\n  \tswitch (dimensionValue) {\n  \t\tcase Dimension.FALSE:\n  \t\t\treturn Dimension.SYM_FALSE;\n  \t\tcase Dimension.TRUE:\n  \t\t\treturn Dimension.SYM_TRUE;\n  \t\tcase Dimension.DONTCARE:\n  \t\t\treturn Dimension.SYM_DONTCARE;\n  \t\tcase Dimension.P:\n  \t\t\treturn Dimension.SYM_P;\n  \t\tcase Dimension.L:\n  \t\t\treturn Dimension.SYM_L;\n  \t\tcase Dimension.A:\n  \t\t\treturn Dimension.SYM_A;\n  \t}\n  \tthrow new IllegalArgumentException(\"Unknown dimension value: \" + dimensionValue);\n  };\n  Dimension.toDimensionValue = function (dimensionSymbol) {\n  \tswitch (Character.toUpperCase(dimensionSymbol)) {\n  \t\tcase Dimension.SYM_FALSE:\n  \t\t\treturn Dimension.FALSE;\n  \t\tcase Dimension.SYM_TRUE:\n  \t\t\treturn Dimension.TRUE;\n  \t\tcase Dimension.SYM_DONTCARE:\n  \t\t\treturn Dimension.DONTCARE;\n  \t\tcase Dimension.SYM_P:\n  \t\t\treturn Dimension.P;\n  \t\tcase Dimension.SYM_L:\n  \t\t\treturn Dimension.L;\n  \t\tcase Dimension.SYM_A:\n  \t\t\treturn Dimension.A;\n  \t}\n  \tthrow new IllegalArgumentException(\"Unknown dimension symbol: \" + dimensionSymbol);\n  };\n  Dimension.P = 0;\n  Dimension.L = 1;\n  Dimension.A = 2;\n  Dimension.FALSE = -1;\n  Dimension.TRUE = -2;\n  Dimension.DONTCARE = -3;\n  Dimension.SYM_FALSE = 'F';\n  Dimension.SYM_TRUE = 'T';\n  Dimension.SYM_DONTCARE = '*';\n  Dimension.SYM_P = '0';\n  Dimension.SYM_L = '1';\n  Dimension.SYM_A = '2';\n\n  function GeometryFilter() {}\n  extend(GeometryFilter.prototype, {\n  \tfilter: function filter(geom) {},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn GeometryFilter;\n  \t}\n  });\n\n  function CoordinateSequenceFilter() {}\n  extend(CoordinateSequenceFilter.prototype, {\n  \tfilter: function filter(seq, i) {},\n  \tisDone: function isDone() {},\n  \tisGeometryChanged: function isGeometryChanged() {},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn CoordinateSequenceFilter;\n  \t}\n  });\n\n  function GeometryCollection() {\n  \tthis._geometries = null;\n  \tvar geometries = arguments[0],\n  \t    factory = arguments[1];\n  \tGeometry.call(this, factory);\n  \tif (geometries === null) {\n  \t\tgeometries = [];\n  \t}\n  \tif (Geometry.hasNullElements(geometries)) {\n  \t\tthrow new IllegalArgumentException(\"geometries must not contain null elements\");\n  \t}\n  \tthis._geometries = geometries;\n  }\n  inherits$1(GeometryCollection, Geometry);\n  extend(GeometryCollection.prototype, {\n  \tcomputeEnvelopeInternal: function computeEnvelopeInternal() {\n  \t\tvar envelope = new Envelope();\n  \t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\tenvelope.expandToInclude(this._geometries[i].getEnvelopeInternal());\n  \t\t}\n  \t\treturn envelope;\n  \t},\n  \tgetGeometryN: function getGeometryN(n) {\n  \t\treturn this._geometries[n];\n  \t},\n  \tgetSortIndex: function getSortIndex() {\n  \t\treturn Geometry.SORTINDEX_GEOMETRYCOLLECTION;\n  \t},\n  \tgetCoordinates: function getCoordinates() {\n  \t\tvar coordinates = new Array(this.getNumPoints()).fill(null);\n  \t\tvar k = -1;\n  \t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\tvar childCoordinates = this._geometries[i].getCoordinates();\n  \t\t\tfor (var j = 0; j < childCoordinates.length; j++) {\n  \t\t\t\tk++;\n  \t\t\t\tcoordinates[k] = childCoordinates[j];\n  \t\t\t}\n  \t\t}\n  \t\treturn coordinates;\n  \t},\n  \tgetArea: function getArea() {\n  \t\tvar area = 0.0;\n  \t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\tarea += this._geometries[i].getArea();\n  \t\t}\n  \t\treturn area;\n  \t},\n  \tequalsExact: function equalsExact() {\n  \t\tif (arguments.length === 2) {\n  \t\t\tvar other = arguments[0],\n  \t\t\t    tolerance = arguments[1];\n  \t\t\tif (!this.isEquivalentClass(other)) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t\tvar otherCollection = other;\n  \t\t\tif (this._geometries.length !== otherCollection._geometries.length) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\t\tif (!this._geometries[i].equalsExact(otherCollection._geometries[i], tolerance)) {\n  \t\t\t\t\treturn false;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\treturn true;\n  \t\t} else return Geometry.prototype.equalsExact.apply(this, arguments);\n  \t},\n  \tnormalize: function normalize() {\n  \t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\tthis._geometries[i].normalize();\n  \t\t}\n  \t\tArrays.sort(this._geometries);\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\tif (this.isEmpty()) return null;\n  \t\treturn this._geometries[0].getCoordinate();\n  \t},\n  \tgetBoundaryDimension: function getBoundaryDimension() {\n  \t\tvar dimension = Dimension.FALSE;\n  \t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\tdimension = Math.max(dimension, this._geometries[i].getBoundaryDimension());\n  \t\t}\n  \t\treturn dimension;\n  \t},\n  \tgetDimension: function getDimension() {\n  \t\tvar dimension = Dimension.FALSE;\n  \t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\tdimension = Math.max(dimension, this._geometries[i].getDimension());\n  \t\t}\n  \t\treturn dimension;\n  \t},\n  \tgetLength: function getLength() {\n  \t\tvar sum = 0.0;\n  \t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\tsum += this._geometries[i].getLength();\n  \t\t}\n  \t\treturn sum;\n  \t},\n  \tgetNumPoints: function getNumPoints() {\n  \t\tvar numPoints = 0;\n  \t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\tnumPoints += this._geometries[i].getNumPoints();\n  \t\t}\n  \t\treturn numPoints;\n  \t},\n  \tgetNumGeometries: function getNumGeometries() {\n  \t\treturn this._geometries.length;\n  \t},\n  \treverse: function reverse() {\n  \t\tvar n = this._geometries.length;\n  \t\tvar revGeoms = new Array(n).fill(null);\n  \t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\trevGeoms[i] = this._geometries[i].reverse();\n  \t\t}\n  \t\treturn this.getFactory().createGeometryCollection(revGeoms);\n  \t},\n  \tcompareToSameClass: function compareToSameClass() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar o = arguments[0];\n  \t\t\tvar theseElements = new TreeSet(Arrays.asList(this._geometries));\n  \t\t\tvar otherElements = new TreeSet(Arrays.asList(o._geometries));\n  \t\t\treturn this.compare(theseElements, otherElements);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar o = arguments[0],\n  \t\t\t    comp = arguments[1];\n  \t\t\tvar gc = o;\n  \t\t\tvar n1 = this.getNumGeometries();\n  \t\t\tvar n2 = gc.getNumGeometries();\n  \t\t\tvar i = 0;\n  \t\t\twhile (i < n1 && i < n2) {\n  \t\t\t\tvar thisGeom = this.getGeometryN(i);\n  \t\t\t\tvar otherGeom = gc.getGeometryN(i);\n  \t\t\t\tvar holeComp = thisGeom.compareToSameClass(otherGeom, comp);\n  \t\t\t\tif (holeComp !== 0) return holeComp;\n  \t\t\t\ti++;\n  \t\t\t}\n  \t\t\tif (i < n1) return 1;\n  \t\t\tif (i < n2) return -1;\n  \t\t\treturn 0;\n  \t\t}\n  \t},\n  \tapply: function apply() {\n  \t\tif (hasInterface(arguments[0], CoordinateFilter)) {\n  \t\t\tvar filter = arguments[0];\n  \t\t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\t\tthis._geometries[i].apply(filter);\n  \t\t\t}\n  \t\t} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n  \t\t\tvar filter = arguments[0];\n  \t\t\tif (this._geometries.length === 0) return null;\n  \t\t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\t\tthis._geometries[i].apply(filter);\n  \t\t\t\tif (filter.isDone()) {\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\tif (filter.isGeometryChanged()) this.geometryChanged();\n  \t\t} else if (hasInterface(arguments[0], GeometryFilter)) {\n  \t\t\tvar filter = arguments[0];\n  \t\t\tfilter.filter(this);\n  \t\t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\t\tthis._geometries[i].apply(filter);\n  \t\t\t}\n  \t\t} else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n  \t\t\tvar filter = arguments[0];\n  \t\t\tfilter.filter(this);\n  \t\t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\t\tthis._geometries[i].apply(filter);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetBoundary: function getBoundary() {\n  \t\tthis.checkNotGeometryCollection(this);\n  \t\tAssert.shouldNeverReachHere();\n  \t\treturn null;\n  \t},\n  \tclone: function clone() {\n  \t\tvar gc = Geometry.prototype.clone.call(this);\n  \t\tgc._geometries = new Array(this._geometries.length).fill(null);\n  \t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\tgc._geometries[i] = this._geometries[i].clone();\n  \t\t}\n  \t\treturn gc;\n  \t},\n  \tgetGeometryType: function getGeometryType() {\n  \t\treturn \"GeometryCollection\";\n  \t},\n  \tcopy: function copy() {\n  \t\tvar geometries = new Array(this._geometries.length).fill(null);\n  \t\tfor (var i = 0; i < geometries.length; i++) {\n  \t\t\tgeometries[i] = this._geometries[i].copy();\n  \t\t}\n  \t\treturn new GeometryCollection(geometries, this._factory);\n  \t},\n  \tisEmpty: function isEmpty() {\n  \t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\tif (!this._geometries[i].isEmpty()) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t}\n  \t\treturn true;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn GeometryCollection;\n  \t}\n  });\n  GeometryCollection.serialVersionUID = -5694727726395021467;\n\n  function MultiLineString() {\n  \tvar lineStrings = arguments[0],\n  \t    factory = arguments[1];\n  \tGeometryCollection.call(this, lineStrings, factory);\n  }\n  inherits$1(MultiLineString, GeometryCollection);\n  extend(MultiLineString.prototype, {\n  \tgetSortIndex: function getSortIndex() {\n  \t\treturn Geometry.SORTINDEX_MULTILINESTRING;\n  \t},\n  \tequalsExact: function equalsExact() {\n  \t\tif (arguments.length === 2) {\n  \t\t\tvar other = arguments[0],\n  \t\t\t    tolerance = arguments[1];\n  \t\t\tif (!this.isEquivalentClass(other)) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t\treturn GeometryCollection.prototype.equalsExact.call(this, other, tolerance);\n  \t\t} else return GeometryCollection.prototype.equalsExact.apply(this, arguments);\n  \t},\n  \tgetBoundaryDimension: function getBoundaryDimension() {\n  \t\tif (this.isClosed()) {\n  \t\t\treturn Dimension.FALSE;\n  \t\t}\n  \t\treturn 0;\n  \t},\n  \tisClosed: function isClosed() {\n  \t\tif (this.isEmpty()) {\n  \t\t\treturn false;\n  \t\t}\n  \t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\tif (!this._geometries[i].isClosed()) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t}\n  \t\treturn true;\n  \t},\n  \tgetDimension: function getDimension() {\n  \t\treturn 1;\n  \t},\n  \treverse: function reverse() {\n  \t\tvar nLines = this._geometries.length;\n  \t\tvar revLines = new Array(nLines).fill(null);\n  \t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\trevLines[nLines - 1 - i] = this._geometries[i].reverse();\n  \t\t}\n  \t\treturn this.getFactory().createMultiLineString(revLines);\n  \t},\n  \tgetBoundary: function getBoundary() {\n  \t\treturn new BoundaryOp(this).getBoundary();\n  \t},\n  \tgetGeometryType: function getGeometryType() {\n  \t\treturn \"MultiLineString\";\n  \t},\n  \tcopy: function copy() {\n  \t\tvar lineStrings = new Array(this._geometries.length).fill(null);\n  \t\tfor (var i = 0; i < lineStrings.length; i++) {\n  \t\t\tlineStrings[i] = this._geometries[i].copy();\n  \t\t}\n  \t\treturn new MultiLineString(lineStrings, this._factory);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Lineal];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MultiLineString;\n  \t}\n  });\n  MultiLineString.serialVersionUID = 8166665132445433741;\n\n  function BoundaryOp() {\n  \tthis._geom = null;\n  \tthis._geomFact = null;\n  \tthis._bnRule = null;\n  \tthis._endpointMap = null;\n  \tif (arguments.length === 1) {\n  \t\tvar geom = arguments[0];\n  \t\tBoundaryOp.call(this, geom, BoundaryNodeRule.MOD2_BOUNDARY_RULE);\n  \t} else if (arguments.length === 2) {\n  \t\tvar geom = arguments[0],\n  \t\t    bnRule = arguments[1];\n  \t\tthis._geom = geom;\n  \t\tthis._geomFact = geom.getFactory();\n  \t\tthis._bnRule = bnRule;\n  \t}\n  }\n  extend(BoundaryOp.prototype, {\n  \tboundaryMultiLineString: function boundaryMultiLineString(mLine) {\n  \t\tif (this._geom.isEmpty()) {\n  \t\t\treturn this.getEmptyMultiPoint();\n  \t\t}\n  \t\tvar bdyPts = this.computeBoundaryCoordinates(mLine);\n  \t\tif (bdyPts.length === 1) {\n  \t\t\treturn this._geomFact.createPoint(bdyPts[0]);\n  \t\t}\n  \t\treturn this._geomFact.createMultiPointFromCoords(bdyPts);\n  \t},\n  \tgetBoundary: function getBoundary() {\n  \t\tif (this._geom instanceof LineString) return this.boundaryLineString(this._geom);\n  \t\tif (this._geom instanceof MultiLineString) return this.boundaryMultiLineString(this._geom);\n  \t\treturn this._geom.getBoundary();\n  \t},\n  \tboundaryLineString: function boundaryLineString(line) {\n  \t\tif (this._geom.isEmpty()) {\n  \t\t\treturn this.getEmptyMultiPoint();\n  \t\t}\n  \t\tif (line.isClosed()) {\n  \t\t\tvar closedEndpointOnBoundary = this._bnRule.isInBoundary(2);\n  \t\t\tif (closedEndpointOnBoundary) {\n  \t\t\t\treturn line.getStartPoint();\n  \t\t\t} else {\n  \t\t\t\treturn this._geomFact.createMultiPoint();\n  \t\t\t}\n  \t\t}\n  \t\treturn this._geomFact.createMultiPoint([line.getStartPoint(), line.getEndPoint()]);\n  \t},\n  \tgetEmptyMultiPoint: function getEmptyMultiPoint() {\n  \t\treturn this._geomFact.createMultiPoint();\n  \t},\n  \tcomputeBoundaryCoordinates: function computeBoundaryCoordinates(mLine) {\n  \t\tvar bdyPts = new ArrayList();\n  \t\tthis._endpointMap = new TreeMap();\n  \t\tfor (var i = 0; i < mLine.getNumGeometries(); i++) {\n  \t\t\tvar line = mLine.getGeometryN(i);\n  \t\t\tif (line.getNumPoints() === 0) continue;\n  \t\t\tthis.addEndpoint(line.getCoordinateN(0));\n  \t\t\tthis.addEndpoint(line.getCoordinateN(line.getNumPoints() - 1));\n  \t\t}\n  \t\tfor (var it = this._endpointMap.entrySet().iterator(); it.hasNext();) {\n  \t\t\tvar entry = it.next();\n  \t\t\tvar counter = entry.getValue();\n  \t\t\tvar valence = counter.count;\n  \t\t\tif (this._bnRule.isInBoundary(valence)) {\n  \t\t\t\tbdyPts.add(entry.getKey());\n  \t\t\t}\n  \t\t}\n  \t\treturn CoordinateArrays.toCoordinateArray(bdyPts);\n  \t},\n  \taddEndpoint: function addEndpoint(pt) {\n  \t\tvar counter = this._endpointMap.get(pt);\n  \t\tif (counter === null) {\n  \t\t\tcounter = new Counter();\n  \t\t\tthis._endpointMap.put(pt, counter);\n  \t\t}\n  \t\tcounter.count++;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn BoundaryOp;\n  \t}\n  });\n  BoundaryOp.getBoundary = function () {\n  \tif (arguments.length === 1) {\n  \t\tvar g = arguments[0];\n  \t\tvar bop = new BoundaryOp(g);\n  \t\treturn bop.getBoundary();\n  \t} else if (arguments.length === 2) {\n  \t\tvar g = arguments[0],\n  \t\t    bnRule = arguments[1];\n  \t\tvar bop = new BoundaryOp(g, bnRule);\n  \t\treturn bop.getBoundary();\n  \t}\n  };\n  function Counter() {\n  \tthis.count = null;\n  }\n  extend(Counter.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Counter;\n  \t}\n  });\n\n  function PrintStream() {}\n\n  function StringReader() {}\n\n  function DecimalFormat() {}\n\n  function ByteArrayOutputStream() {}\n\n  function IOException() {}\n\n  function LineNumberReader() {}\n\n  function StringUtil() {}\n  extend(StringUtil.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn StringUtil;\n  \t}\n  });\n  StringUtil.chars = function (c, n) {\n  \tvar ch = new Array(n).fill(null);\n  \tfor (var i = 0; i < n; i++) {\n  \t\tch[i] = c;\n  \t}\n  \treturn new String(ch);\n  };\n  StringUtil.getStackTrace = function () {\n  \tif (arguments.length === 1) {\n  \t\tvar t = arguments[0];\n  \t\tvar os = new ByteArrayOutputStream();\n  \t\tvar ps = new PrintStream(os);\n  \t\tt.printStackTrace(ps);\n  \t\treturn os.toString();\n  \t} else if (arguments.length === 2) {\n  \t\tvar t = arguments[0],\n  \t\t    depth = arguments[1];\n  \t\tvar stackTrace = \"\";\n  \t\tvar stringReader = new StringReader(StringUtil.getStackTrace(t));\n  \t\tvar lineNumberReader = new LineNumberReader(stringReader);\n  \t\tfor (var i = 0; i < depth; i++) {\n  \t\t\ttry {\n  \t\t\t\tstackTrace += lineNumberReader.readLine() + StringUtil.NEWLINE;\n  \t\t\t} catch (e) {\n  \t\t\t\tif (e instanceof IOException) {\n  \t\t\t\t\tAssert.shouldNeverReachHere();\n  \t\t\t\t} else throw e;\n  \t\t\t} finally {}\n  \t\t}\n  \t\treturn stackTrace;\n  \t}\n  };\n  StringUtil.split = function (s, separator) {\n  \tvar separatorlen = separator.length;\n  \tvar tokenList = new ArrayList();\n  \tvar tmpString = \"\" + s;\n  \tvar pos = tmpString.indexOf(separator);\n  \twhile (pos >= 0) {\n  \t\tvar token = tmpString.substring(0, pos);\n  \t\ttokenList.add(token);\n  \t\ttmpString = tmpString.substring(pos + separatorlen);\n  \t\tpos = tmpString.indexOf(separator);\n  \t}\n  \tif (tmpString.length > 0) tokenList.add(tmpString);\n  \tvar res = new Array(tokenList.size()).fill(null);\n  \tfor (var i = 0; i < res.length; i++) {\n  \t\tres[i] = tokenList.get(i);\n  \t}\n  \treturn res;\n  };\n  StringUtil.toString = function () {\n  \tif (arguments.length === 1) {\n  \t\tvar d = arguments[0];\n  \t\treturn StringUtil.SIMPLE_ORDINATE_FORMAT.format(d);\n  \t}\n  };\n  StringUtil.spaces = function (n) {\n  \treturn StringUtil.chars(' ', n);\n  };\n  StringUtil.NEWLINE = System.getProperty(\"line.separator\");\n  StringUtil.SIMPLE_ORDINATE_FORMAT = new DecimalFormat(\"0.#\");\n\n  function CoordinateSequences() {}\n  extend(CoordinateSequences.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn CoordinateSequences;\n  \t}\n  });\n  CoordinateSequences.copyCoord = function (src, srcPos, dest, destPos) {\n  \tvar minDim = Math.min(src.getDimension(), dest.getDimension());\n  \tfor (var dim = 0; dim < minDim; dim++) {\n  \t\tdest.setOrdinate(destPos, dim, src.getOrdinate(srcPos, dim));\n  \t}\n  };\n  CoordinateSequences.isRing = function (seq) {\n  \tvar n = seq.size();\n  \tif (n === 0) return true;\n  \tif (n <= 3) return false;\n  \treturn seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);\n  };\n  CoordinateSequences.isEqual = function (cs1, cs2) {\n  \tvar cs1Size = cs1.size();\n  \tvar cs2Size = cs2.size();\n  \tif (cs1Size !== cs2Size) return false;\n  \tvar dim = Math.min(cs1.getDimension(), cs2.getDimension());\n  \tfor (var i = 0; i < cs1Size; i++) {\n  \t\tfor (var d = 0; d < dim; d++) {\n  \t\t\tvar v1 = cs1.getOrdinate(i, d);\n  \t\t\tvar v2 = cs2.getOrdinate(i, d);\n  \t\t\tif (cs1.getOrdinate(i, d) === cs2.getOrdinate(i, d)) continue;\n  \t\t\tif (Double.isNaN(v1) && Double.isNaN(v2)) continue;\n  \t\t\treturn false;\n  \t\t}\n  \t}\n  \treturn true;\n  };\n  CoordinateSequences.extend = function (fact, seq, size) {\n  \tvar newseq = fact.create(size, seq.getDimension());\n  \tvar n = seq.size();\n  \tCoordinateSequences.copy(seq, 0, newseq, 0, n);\n  \tif (n > 0) {\n  \t\tfor (var i = n; i < size; i++) {\n  \t\t\tCoordinateSequences.copy(seq, n - 1, newseq, i, 1);\n  \t\t}\n  \t}\n  \treturn newseq;\n  };\n  CoordinateSequences.reverse = function (seq) {\n  \tvar last = seq.size() - 1;\n  \tvar mid = Math.trunc(last / 2);\n  \tfor (var i = 0; i <= mid; i++) {\n  \t\tCoordinateSequences.swap(seq, i, last - i);\n  \t}\n  };\n  CoordinateSequences.swap = function (seq, i, j) {\n  \tif (i === j) return null;\n  \tfor (var dim = 0; dim < seq.getDimension(); dim++) {\n  \t\tvar tmp = seq.getOrdinate(i, dim);\n  \t\tseq.setOrdinate(i, dim, seq.getOrdinate(j, dim));\n  \t\tseq.setOrdinate(j, dim, tmp);\n  \t}\n  };\n  CoordinateSequences.copy = function (src, srcPos, dest, destPos, length) {\n  \tfor (var i = 0; i < length; i++) {\n  \t\tCoordinateSequences.copyCoord(src, srcPos + i, dest, destPos + i);\n  \t}\n  };\n  CoordinateSequences.toString = function () {\n  \tif (arguments.length === 1) {\n  \t\tvar cs = arguments[0];\n  \t\tvar size = cs.size();\n  \t\tif (size === 0) return \"()\";\n  \t\tvar dim = cs.getDimension();\n  \t\tvar buf = new StringBuffer();\n  \t\tbuf.append('(');\n  \t\tfor (var i = 0; i < size; i++) {\n  \t\t\tif (i > 0) buf.append(\" \");\n  \t\t\tfor (var d = 0; d < dim; d++) {\n  \t\t\t\tif (d > 0) buf.append(\",\");\n  \t\t\t\tbuf.append(StringUtil.toString(cs.getOrdinate(i, d)));\n  \t\t\t}\n  \t\t}\n  \t\tbuf.append(')');\n  \t\treturn buf.toString();\n  \t}\n  };\n  CoordinateSequences.ensureValidRing = function (fact, seq) {\n  \tvar n = seq.size();\n  \tif (n === 0) return seq;\n  \tif (n <= 3) return CoordinateSequences.createClosedRing(fact, seq, 4);\n  \tvar isClosed = seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);\n  \tif (isClosed) return seq;\n  \treturn CoordinateSequences.createClosedRing(fact, seq, n + 1);\n  };\n  CoordinateSequences.createClosedRing = function (fact, seq, size) {\n  \tvar newseq = fact.create(size, seq.getDimension());\n  \tvar n = seq.size();\n  \tCoordinateSequences.copy(seq, 0, newseq, 0, n);\n  \tfor (var i = n; i < size; i++) {\n  \t\tCoordinateSequences.copy(seq, 0, newseq, i, 1);\n  \t}return newseq;\n  };\n\n  function LineString() {\n  \tthis._points = null;\n  \tvar points = arguments[0],\n  \t    factory = arguments[1];\n  \tGeometry.call(this, factory);\n  \tthis.init(points);\n  }\n  inherits$1(LineString, Geometry);\n  extend(LineString.prototype, {\n  \tcomputeEnvelopeInternal: function computeEnvelopeInternal() {\n  \t\tif (this.isEmpty()) {\n  \t\t\treturn new Envelope();\n  \t\t}\n  \t\treturn this._points.expandEnvelope(new Envelope());\n  \t},\n  \tisRing: function isRing() {\n  \t\treturn this.isClosed() && this.isSimple();\n  \t},\n  \tgetSortIndex: function getSortIndex() {\n  \t\treturn Geometry.SORTINDEX_LINESTRING;\n  \t},\n  \tgetCoordinates: function getCoordinates() {\n  \t\treturn this._points.toCoordinateArray();\n  \t},\n  \tequalsExact: function equalsExact() {\n  \t\tif (arguments.length === 2) {\n  \t\t\tvar other = arguments[0],\n  \t\t\t    tolerance = arguments[1];\n  \t\t\tif (!this.isEquivalentClass(other)) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t\tvar otherLineString = other;\n  \t\t\tif (this._points.size() !== otherLineString._points.size()) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t\tfor (var i = 0; i < this._points.size(); i++) {\n  \t\t\t\tif (!this.equal(this._points.getCoordinate(i), otherLineString._points.getCoordinate(i), tolerance)) {\n  \t\t\t\t\treturn false;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\treturn true;\n  \t\t} else return Geometry.prototype.equalsExact.apply(this, arguments);\n  \t},\n  \tnormalize: function normalize() {\n  \t\tfor (var i = 0; i < Math.trunc(this._points.size() / 2); i++) {\n  \t\t\tvar j = this._points.size() - 1 - i;\n  \t\t\tif (!this._points.getCoordinate(i).equals(this._points.getCoordinate(j))) {\n  \t\t\t\tif (this._points.getCoordinate(i).compareTo(this._points.getCoordinate(j)) > 0) {\n  \t\t\t\t\tCoordinateSequences.reverse(this._points);\n  \t\t\t\t}\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\tif (this.isEmpty()) return null;\n  \t\treturn this._points.getCoordinate(0);\n  \t},\n  \tgetBoundaryDimension: function getBoundaryDimension() {\n  \t\tif (this.isClosed()) {\n  \t\t\treturn Dimension.FALSE;\n  \t\t}\n  \t\treturn 0;\n  \t},\n  \tisClosed: function isClosed() {\n  \t\tif (this.isEmpty()) {\n  \t\t\treturn false;\n  \t\t}\n  \t\treturn this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));\n  \t},\n  \tgetEndPoint: function getEndPoint() {\n  \t\tif (this.isEmpty()) {\n  \t\t\treturn null;\n  \t\t}\n  \t\treturn this.getPointN(this.getNumPoints() - 1);\n  \t},\n  \tgetDimension: function getDimension() {\n  \t\treturn 1;\n  \t},\n  \tgetLength: function getLength() {\n  \t\treturn CGAlgorithms.computeLength(this._points);\n  \t},\n  \tgetNumPoints: function getNumPoints() {\n  \t\treturn this._points.size();\n  \t},\n  \treverse: function reverse() {\n  \t\tvar seq = this._points.copy();\n  \t\tCoordinateSequences.reverse(seq);\n  \t\tvar revLine = this.getFactory().createLineString(seq);\n  \t\treturn revLine;\n  \t},\n  \tcompareToSameClass: function compareToSameClass() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar o = arguments[0];\n  \t\t\tvar line = o;\n  \t\t\tvar i = 0;\n  \t\t\tvar j = 0;\n  \t\t\twhile (i < this._points.size() && j < line._points.size()) {\n  \t\t\t\tvar comparison = this._points.getCoordinate(i).compareTo(line._points.getCoordinate(j));\n  \t\t\t\tif (comparison !== 0) {\n  \t\t\t\t\treturn comparison;\n  \t\t\t\t}\n  \t\t\t\ti++;\n  \t\t\t\tj++;\n  \t\t\t}\n  \t\t\tif (i < this._points.size()) {\n  \t\t\t\treturn 1;\n  \t\t\t}\n  \t\t\tif (j < line._points.size()) {\n  \t\t\t\treturn -1;\n  \t\t\t}\n  \t\t\treturn 0;\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar o = arguments[0],\n  \t\t\t    comp = arguments[1];\n  \t\t\tvar line = o;\n  \t\t\treturn comp.compare(this._points, line._points);\n  \t\t}\n  \t},\n  \tapply: function apply() {\n  \t\tif (hasInterface(arguments[0], CoordinateFilter)) {\n  \t\t\tvar filter = arguments[0];\n  \t\t\tfor (var i = 0; i < this._points.size(); i++) {\n  \t\t\t\tfilter.filter(this._points.getCoordinate(i));\n  \t\t\t}\n  \t\t} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n  \t\t\tvar filter = arguments[0];\n  \t\t\tif (this._points.size() === 0) return null;\n  \t\t\tfor (var i = 0; i < this._points.size(); i++) {\n  \t\t\t\tfilter.filter(this._points, i);\n  \t\t\t\tif (filter.isDone()) break;\n  \t\t\t}\n  \t\t\tif (filter.isGeometryChanged()) this.geometryChanged();\n  \t\t} else if (hasInterface(arguments[0], GeometryFilter)) {\n  \t\t\tvar filter = arguments[0];\n  \t\t\tfilter.filter(this);\n  \t\t} else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n  \t\t\tvar filter = arguments[0];\n  \t\t\tfilter.filter(this);\n  \t\t}\n  \t},\n  \tgetBoundary: function getBoundary() {\n  \t\treturn new BoundaryOp(this).getBoundary();\n  \t},\n  \tisEquivalentClass: function isEquivalentClass(other) {\n  \t\treturn other instanceof LineString;\n  \t},\n  \tclone: function clone() {\n  \t\tvar ls = Geometry.prototype.clone.call(this);\n  \t\tls._points = this._points.clone();\n  \t\treturn ls;\n  \t},\n  \tgetCoordinateN: function getCoordinateN(n) {\n  \t\treturn this._points.getCoordinate(n);\n  \t},\n  \tgetGeometryType: function getGeometryType() {\n  \t\treturn \"LineString\";\n  \t},\n  \tcopy: function copy() {\n  \t\treturn new LineString(this._points.copy(), this._factory);\n  \t},\n  \tgetCoordinateSequence: function getCoordinateSequence() {\n  \t\treturn this._points;\n  \t},\n  \tisEmpty: function isEmpty() {\n  \t\treturn this._points.size() === 0;\n  \t},\n  \tinit: function init(points) {\n  \t\tif (points === null) {\n  \t\t\tpoints = this.getFactory().getCoordinateSequenceFactory().create([]);\n  \t\t}\n  \t\tif (points.size() === 1) {\n  \t\t\tthrow new IllegalArgumentException(\"Invalid number of points in LineString (found \" + points.size() + \" - must be 0 or >= 2)\");\n  \t\t}\n  \t\tthis._points = points;\n  \t},\n  \tisCoordinate: function isCoordinate(pt) {\n  \t\tfor (var i = 0; i < this._points.size(); i++) {\n  \t\t\tif (this._points.getCoordinate(i).equals(pt)) {\n  \t\t\t\treturn true;\n  \t\t\t}\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tgetStartPoint: function getStartPoint() {\n  \t\tif (this.isEmpty()) {\n  \t\t\treturn null;\n  \t\t}\n  \t\treturn this.getPointN(0);\n  \t},\n  \tgetPointN: function getPointN(n) {\n  \t\treturn this.getFactory().createPoint(this._points.getCoordinate(n));\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Lineal];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LineString;\n  \t}\n  });\n  LineString.serialVersionUID = 3110669828065365560;\n\n  function Puntal() {}\n  extend(Puntal.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Puntal;\n  \t}\n  });\n\n  function Point() {\n  \tthis._coordinates = null;\n  \tvar coordinates = arguments[0],\n  \t    factory = arguments[1];\n  \tGeometry.call(this, factory);\n  \tthis.init(coordinates);\n  }\n  inherits$1(Point, Geometry);\n  extend(Point.prototype, {\n  \tcomputeEnvelopeInternal: function computeEnvelopeInternal() {\n  \t\tif (this.isEmpty()) {\n  \t\t\treturn new Envelope();\n  \t\t}\n  \t\tvar env = new Envelope();\n  \t\tenv.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0));\n  \t\treturn env;\n  \t},\n  \tgetSortIndex: function getSortIndex() {\n  \t\treturn Geometry.SORTINDEX_POINT;\n  \t},\n  \tgetCoordinates: function getCoordinates() {\n  \t\treturn this.isEmpty() ? [] : [this.getCoordinate()];\n  \t},\n  \tequalsExact: function equalsExact() {\n  \t\tif (arguments.length === 2) {\n  \t\t\tvar other = arguments[0],\n  \t\t\t    tolerance = arguments[1];\n  \t\t\tif (!this.isEquivalentClass(other)) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t\tif (this.isEmpty() && other.isEmpty()) {\n  \t\t\t\treturn true;\n  \t\t\t}\n  \t\t\tif (this.isEmpty() !== other.isEmpty()) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t\treturn this.equal(other.getCoordinate(), this.getCoordinate(), tolerance);\n  \t\t} else return Geometry.prototype.equalsExact.apply(this, arguments);\n  \t},\n  \tnormalize: function normalize() {},\n  \tgetCoordinate: function getCoordinate() {\n  \t\treturn this._coordinates.size() !== 0 ? this._coordinates.getCoordinate(0) : null;\n  \t},\n  \tgetBoundaryDimension: function getBoundaryDimension() {\n  \t\treturn Dimension.FALSE;\n  \t},\n  \tgetDimension: function getDimension() {\n  \t\treturn 0;\n  \t},\n  \tgetNumPoints: function getNumPoints() {\n  \t\treturn this.isEmpty() ? 0 : 1;\n  \t},\n  \treverse: function reverse() {\n  \t\treturn this.copy();\n  \t},\n  \tgetX: function getX() {\n  \t\tif (this.getCoordinate() === null) {\n  \t\t\tthrow new IllegalStateException(\"getX called on empty Point\");\n  \t\t}\n  \t\treturn this.getCoordinate().x;\n  \t},\n  \tcompareToSameClass: function compareToSameClass() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar other = arguments[0];\n  \t\t\tvar point = other;\n  \t\t\treturn this.getCoordinate().compareTo(point.getCoordinate());\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar other = arguments[0],\n  \t\t\t    comp = arguments[1];\n  \t\t\tvar point = other;\n  \t\t\treturn comp.compare(this._coordinates, point._coordinates);\n  \t\t}\n  \t},\n  \tapply: function apply() {\n  \t\tif (hasInterface(arguments[0], CoordinateFilter)) {\n  \t\t\tvar filter = arguments[0];\n  \t\t\tif (this.isEmpty()) {\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t\tfilter.filter(this.getCoordinate());\n  \t\t} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n  \t\t\tvar filter = arguments[0];\n  \t\t\tif (this.isEmpty()) return null;\n  \t\t\tfilter.filter(this._coordinates, 0);\n  \t\t\tif (filter.isGeometryChanged()) this.geometryChanged();\n  \t\t} else if (hasInterface(arguments[0], GeometryFilter)) {\n  \t\t\tvar filter = arguments[0];\n  \t\t\tfilter.filter(this);\n  \t\t} else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n  \t\t\tvar filter = arguments[0];\n  \t\t\tfilter.filter(this);\n  \t\t}\n  \t},\n  \tgetBoundary: function getBoundary() {\n  \t\treturn this.getFactory().createGeometryCollection(null);\n  \t},\n  \tclone: function clone() {\n  \t\tvar p = Geometry.prototype.clone.call(this);\n  \t\tp._coordinates = this._coordinates.clone();\n  \t\treturn p;\n  \t},\n  \tgetGeometryType: function getGeometryType() {\n  \t\treturn \"Point\";\n  \t},\n  \tcopy: function copy() {\n  \t\treturn new Point(this._coordinates.copy(), this._factory);\n  \t},\n  \tgetCoordinateSequence: function getCoordinateSequence() {\n  \t\treturn this._coordinates;\n  \t},\n  \tgetY: function getY() {\n  \t\tif (this.getCoordinate() === null) {\n  \t\t\tthrow new IllegalStateException(\"getY called on empty Point\");\n  \t\t}\n  \t\treturn this.getCoordinate().y;\n  \t},\n  \tisEmpty: function isEmpty() {\n  \t\treturn this._coordinates.size() === 0;\n  \t},\n  \tinit: function init(coordinates) {\n  \t\tif (coordinates === null) {\n  \t\t\tcoordinates = this.getFactory().getCoordinateSequenceFactory().create([]);\n  \t\t}\n  \t\tAssert.isTrue(coordinates.size() <= 1);\n  \t\tthis._coordinates = coordinates;\n  \t},\n  \tisSimple: function isSimple() {\n  \t\treturn true;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Puntal];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Point;\n  \t}\n  });\n  Point.serialVersionUID = 4902022702746614570;\n\n  function Polygonal() {}\n  extend(Polygonal.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Polygonal;\n  \t}\n  });\n\n  function Polygon() {\n  \tthis._shell = null;\n  \tthis._holes = null;\n  \tvar shell = arguments[0],\n  \t    holes = arguments[1],\n  \t    factory = arguments[2];\n  \tGeometry.call(this, factory);\n  \tif (shell === null) {\n  \t\tshell = this.getFactory().createLinearRing();\n  \t}\n  \tif (holes === null) {\n  \t\tholes = [];\n  \t}\n  \tif (Geometry.hasNullElements(holes)) {\n  \t\tthrow new IllegalArgumentException(\"holes must not contain null elements\");\n  \t}\n  \tif (shell.isEmpty() && Geometry.hasNonEmptyElements(holes)) {\n  \t\tthrow new IllegalArgumentException(\"shell is empty but holes are not\");\n  \t}\n  \tthis._shell = shell;\n  \tthis._holes = holes;\n  }\n  inherits$1(Polygon, Geometry);\n  extend(Polygon.prototype, {\n  \tcomputeEnvelopeInternal: function computeEnvelopeInternal() {\n  \t\treturn this._shell.getEnvelopeInternal();\n  \t},\n  \tgetSortIndex: function getSortIndex() {\n  \t\treturn Geometry.SORTINDEX_POLYGON;\n  \t},\n  \tgetCoordinates: function getCoordinates() {\n  \t\tif (this.isEmpty()) {\n  \t\t\treturn [];\n  \t\t}\n  \t\tvar coordinates = new Array(this.getNumPoints()).fill(null);\n  \t\tvar k = -1;\n  \t\tvar shellCoordinates = this._shell.getCoordinates();\n  \t\tfor (var x = 0; x < shellCoordinates.length; x++) {\n  \t\t\tk++;\n  \t\t\tcoordinates[k] = shellCoordinates[x];\n  \t\t}\n  \t\tfor (var i = 0; i < this._holes.length; i++) {\n  \t\t\tvar childCoordinates = this._holes[i].getCoordinates();\n  \t\t\tfor (var j = 0; j < childCoordinates.length; j++) {\n  \t\t\t\tk++;\n  \t\t\t\tcoordinates[k] = childCoordinates[j];\n  \t\t\t}\n  \t\t}\n  \t\treturn coordinates;\n  \t},\n  \tgetArea: function getArea() {\n  \t\tvar area = 0.0;\n  \t\tarea += Math.abs(CGAlgorithms.signedArea(this._shell.getCoordinateSequence()));\n  \t\tfor (var i = 0; i < this._holes.length; i++) {\n  \t\t\tarea -= Math.abs(CGAlgorithms.signedArea(this._holes[i].getCoordinateSequence()));\n  \t\t}\n  \t\treturn area;\n  \t},\n  \tisRectangle: function isRectangle() {\n  \t\tif (this.getNumInteriorRing() !== 0) return false;\n  \t\tif (this._shell === null) return false;\n  \t\tif (this._shell.getNumPoints() !== 5) return false;\n  \t\tvar seq = this._shell.getCoordinateSequence();\n  \t\tvar env = this.getEnvelopeInternal();\n  \t\tfor (var i = 0; i < 5; i++) {\n  \t\t\tvar x = seq.getX(i);\n  \t\t\tif (!(x === env.getMinX() || x === env.getMaxX())) return false;\n  \t\t\tvar y = seq.getY(i);\n  \t\t\tif (!(y === env.getMinY() || y === env.getMaxY())) return false;\n  \t\t}\n  \t\tvar prevX = seq.getX(0);\n  \t\tvar prevY = seq.getY(0);\n  \t\tfor (var i = 1; i <= 4; i++) {\n  \t\t\tvar x = seq.getX(i);\n  \t\t\tvar y = seq.getY(i);\n  \t\t\tvar xChanged = x !== prevX;\n  \t\t\tvar yChanged = y !== prevY;\n  \t\t\tif (xChanged === yChanged) return false;\n  \t\t\tprevX = x;\n  \t\t\tprevY = y;\n  \t\t}\n  \t\treturn true;\n  \t},\n  \tequalsExact: function equalsExact() {\n  \t\tif (arguments.length === 2) {\n  \t\t\tvar other = arguments[0],\n  \t\t\t    tolerance = arguments[1];\n  \t\t\tif (!this.isEquivalentClass(other)) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t\tvar otherPolygon = other;\n  \t\t\tvar thisShell = this._shell;\n  \t\t\tvar otherPolygonShell = otherPolygon._shell;\n  \t\t\tif (!thisShell.equalsExact(otherPolygonShell, tolerance)) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t\tif (this._holes.length !== otherPolygon._holes.length) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t\tfor (var i = 0; i < this._holes.length; i++) {\n  \t\t\t\tif (!this._holes[i].equalsExact(otherPolygon._holes[i], tolerance)) {\n  \t\t\t\t\treturn false;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\treturn true;\n  \t\t} else return Geometry.prototype.equalsExact.apply(this, arguments);\n  \t},\n  \tnormalize: function normalize() {\n  \t\tif (arguments.length === 0) {\n  \t\t\tthis.normalize(this._shell, true);\n  \t\t\tfor (var i = 0; i < this._holes.length; i++) {\n  \t\t\t\tthis.normalize(this._holes[i], false);\n  \t\t\t}\n  \t\t\tArrays.sort(this._holes);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar ring = arguments[0],\n  \t\t\t    clockwise = arguments[1];\n  \t\t\tif (ring.isEmpty()) {\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t\tvar uniqueCoordinates = new Array(ring.getCoordinates().length - 1).fill(null);\n  \t\t\tSystem.arraycopy(ring.getCoordinates(), 0, uniqueCoordinates, 0, uniqueCoordinates.length);\n  \t\t\tvar minCoordinate = CoordinateArrays.minCoordinate(ring.getCoordinates());\n  \t\t\tCoordinateArrays.scroll(uniqueCoordinates, minCoordinate);\n  \t\t\tSystem.arraycopy(uniqueCoordinates, 0, ring.getCoordinates(), 0, uniqueCoordinates.length);\n  \t\t\tring.getCoordinates()[uniqueCoordinates.length] = uniqueCoordinates[0];\n  \t\t\tif (CGAlgorithms.isCCW(ring.getCoordinates()) === clockwise) {\n  \t\t\t\tCoordinateArrays.reverse(ring.getCoordinates());\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\treturn this._shell.getCoordinate();\n  \t},\n  \tgetNumInteriorRing: function getNumInteriorRing() {\n  \t\treturn this._holes.length;\n  \t},\n  \tgetBoundaryDimension: function getBoundaryDimension() {\n  \t\treturn 1;\n  \t},\n  \tgetDimension: function getDimension() {\n  \t\treturn 2;\n  \t},\n  \tgetLength: function getLength() {\n  \t\tvar len = 0.0;\n  \t\tlen += this._shell.getLength();\n  \t\tfor (var i = 0; i < this._holes.length; i++) {\n  \t\t\tlen += this._holes[i].getLength();\n  \t\t}\n  \t\treturn len;\n  \t},\n  \tgetNumPoints: function getNumPoints() {\n  \t\tvar numPoints = this._shell.getNumPoints();\n  \t\tfor (var i = 0; i < this._holes.length; i++) {\n  \t\t\tnumPoints += this._holes[i].getNumPoints();\n  \t\t}\n  \t\treturn numPoints;\n  \t},\n  \treverse: function reverse() {\n  \t\tvar poly = this.copy();\n  \t\tpoly._shell = this._shell.copy().reverse();\n  \t\tpoly._holes = new Array(this._holes.length).fill(null);\n  \t\tfor (var i = 0; i < this._holes.length; i++) {\n  \t\t\tpoly._holes[i] = this._holes[i].copy().reverse();\n  \t\t}\n  \t\treturn poly;\n  \t},\n  \tconvexHull: function convexHull() {\n  \t\treturn this.getExteriorRing().convexHull();\n  \t},\n  \tcompareToSameClass: function compareToSameClass() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar o = arguments[0];\n  \t\t\tvar thisShell = this._shell;\n  \t\t\tvar otherShell = o._shell;\n  \t\t\treturn thisShell.compareToSameClass(otherShell);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar o = arguments[0],\n  \t\t\t    comp = arguments[1];\n  \t\t\tvar poly = o;\n  \t\t\tvar thisShell = this._shell;\n  \t\t\tvar otherShell = poly._shell;\n  \t\t\tvar shellComp = thisShell.compareToSameClass(otherShell, comp);\n  \t\t\tif (shellComp !== 0) return shellComp;\n  \t\t\tvar nHole1 = this.getNumInteriorRing();\n  \t\t\tvar nHole2 = poly.getNumInteriorRing();\n  \t\t\tvar i = 0;\n  \t\t\twhile (i < nHole1 && i < nHole2) {\n  \t\t\t\tvar thisHole = this.getInteriorRingN(i);\n  \t\t\t\tvar otherHole = poly.getInteriorRingN(i);\n  \t\t\t\tvar holeComp = thisHole.compareToSameClass(otherHole, comp);\n  \t\t\t\tif (holeComp !== 0) return holeComp;\n  \t\t\t\ti++;\n  \t\t\t}\n  \t\t\tif (i < nHole1) return 1;\n  \t\t\tif (i < nHole2) return -1;\n  \t\t\treturn 0;\n  \t\t}\n  \t},\n  \tapply: function apply() {\n  \t\tif (hasInterface(arguments[0], CoordinateFilter)) {\n  \t\t\tvar filter = arguments[0];\n  \t\t\tthis._shell.apply(filter);\n  \t\t\tfor (var i = 0; i < this._holes.length; i++) {\n  \t\t\t\tthis._holes[i].apply(filter);\n  \t\t\t}\n  \t\t} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n  \t\t\tvar filter = arguments[0];\n  \t\t\tthis._shell.apply(filter);\n  \t\t\tif (!filter.isDone()) {\n  \t\t\t\tfor (var i = 0; i < this._holes.length; i++) {\n  \t\t\t\t\tthis._holes[i].apply(filter);\n  \t\t\t\t\tif (filter.isDone()) break;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\tif (filter.isGeometryChanged()) this.geometryChanged();\n  \t\t} else if (hasInterface(arguments[0], GeometryFilter)) {\n  \t\t\tvar filter = arguments[0];\n  \t\t\tfilter.filter(this);\n  \t\t} else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n  \t\t\tvar filter = arguments[0];\n  \t\t\tfilter.filter(this);\n  \t\t\tthis._shell.apply(filter);\n  \t\t\tfor (var i = 0; i < this._holes.length; i++) {\n  \t\t\t\tthis._holes[i].apply(filter);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetBoundary: function getBoundary() {\n  \t\tif (this.isEmpty()) {\n  \t\t\treturn this.getFactory().createMultiLineString();\n  \t\t}\n  \t\tvar rings = new Array(this._holes.length + 1).fill(null);\n  \t\trings[0] = this._shell;\n  \t\tfor (var i = 0; i < this._holes.length; i++) {\n  \t\t\trings[i + 1] = this._holes[i];\n  \t\t}\n  \t\tif (rings.length <= 1) return this.getFactory().createLinearRing(rings[0].getCoordinateSequence());\n  \t\treturn this.getFactory().createMultiLineString(rings);\n  \t},\n  \tclone: function clone() {\n  \t\tvar poly = Geometry.prototype.clone.call(this);\n  \t\tpoly._shell = this._shell.clone();\n  \t\tpoly._holes = new Array(this._holes.length).fill(null);\n  \t\tfor (var i = 0; i < this._holes.length; i++) {\n  \t\t\tpoly._holes[i] = this._holes[i].clone();\n  \t\t}\n  \t\treturn poly;\n  \t},\n  \tgetGeometryType: function getGeometryType() {\n  \t\treturn \"Polygon\";\n  \t},\n  \tcopy: function copy() {\n  \t\tvar shell = this._shell.copy();\n  \t\tvar holes = new Array(this._holes.length).fill(null);\n  \t\tfor (var i = 0; i < holes.length; i++) {\n  \t\t\tholes[i] = this._holes[i].copy();\n  \t\t}\n  \t\treturn new Polygon(shell, holes, this._factory);\n  \t},\n  \tgetExteriorRing: function getExteriorRing() {\n  \t\treturn this._shell;\n  \t},\n  \tisEmpty: function isEmpty() {\n  \t\treturn this._shell.isEmpty();\n  \t},\n  \tgetInteriorRingN: function getInteriorRingN(n) {\n  \t\treturn this._holes[n];\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Polygonal];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Polygon;\n  \t}\n  });\n  Polygon.serialVersionUID = -3494792200821764533;\n\n  function MultiPoint() {\n  \tvar points = arguments[0],\n  \t    factory = arguments[1];\n  \tGeometryCollection.call(this, points, factory);\n  }\n  inherits$1(MultiPoint, GeometryCollection);\n  extend(MultiPoint.prototype, {\n  \tgetSortIndex: function getSortIndex() {\n  \t\treturn Geometry.SORTINDEX_MULTIPOINT;\n  \t},\n  \tisValid: function isValid() {\n  \t\treturn true;\n  \t},\n  \tequalsExact: function equalsExact() {\n  \t\tif (arguments.length === 2) {\n  \t\t\tvar other = arguments[0],\n  \t\t\t    tolerance = arguments[1];\n  \t\t\tif (!this.isEquivalentClass(other)) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t\treturn GeometryCollection.prototype.equalsExact.call(this, other, tolerance);\n  \t\t} else return GeometryCollection.prototype.equalsExact.apply(this, arguments);\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar n = arguments[0];\n  \t\t\treturn this._geometries[n].getCoordinate();\n  \t\t} else return GeometryCollection.prototype.getCoordinate.apply(this, arguments);\n  \t},\n  \tgetBoundaryDimension: function getBoundaryDimension() {\n  \t\treturn Dimension.FALSE;\n  \t},\n  \tgetDimension: function getDimension() {\n  \t\treturn 0;\n  \t},\n  \tgetBoundary: function getBoundary() {\n  \t\treturn this.getFactory().createGeometryCollection(null);\n  \t},\n  \tgetGeometryType: function getGeometryType() {\n  \t\treturn \"MultiPoint\";\n  \t},\n  \tcopy: function copy() {\n  \t\tvar points = new Array(this._geometries.length).fill(null);\n  \t\tfor (var i = 0; i < points.length; i++) {\n  \t\t\tpoints[i] = this._geometries[i].copy();\n  \t\t}\n  \t\treturn new MultiPoint(points, this._factory);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Puntal];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MultiPoint;\n  \t}\n  });\n  MultiPoint.serialVersionUID = -8048474874175355449;\n\n  function LinearRing() {\n  \tif (arguments[0] instanceof Coordinate && arguments[1] instanceof GeometryFactory) {\n  \t\tvar points = arguments[0],\n  \t\t    factory = arguments[1];\n  \t\tLinearRing.call(this, factory.getCoordinateSequenceFactory().create(points), factory);\n  \t} else if (hasInterface(arguments[0], CoordinateSequence) && arguments[1] instanceof GeometryFactory) {\n  \t\tvar points = arguments[0],\n  \t\t    factory = arguments[1];\n  \t\tLineString.call(this, points, factory);\n  \t\tthis.validateConstruction();\n  \t}\n  }\n  inherits$1(LinearRing, LineString);\n  extend(LinearRing.prototype, {\n  \tgetSortIndex: function getSortIndex() {\n  \t\treturn Geometry.SORTINDEX_LINEARRING;\n  \t},\n  \tgetBoundaryDimension: function getBoundaryDimension() {\n  \t\treturn Dimension.FALSE;\n  \t},\n  \tisClosed: function isClosed() {\n  \t\tif (this.isEmpty()) {\n  \t\t\treturn true;\n  \t\t}\n  \t\treturn LineString.prototype.isClosed.call(this);\n  \t},\n  \treverse: function reverse() {\n  \t\tvar seq = this._points.copy();\n  \t\tCoordinateSequences.reverse(seq);\n  \t\tvar rev = this.getFactory().createLinearRing(seq);\n  \t\treturn rev;\n  \t},\n  \tvalidateConstruction: function validateConstruction() {\n  \t\tif (!this.isEmpty() && !LineString.prototype.isClosed.call(this)) {\n  \t\t\tthrow new IllegalArgumentException(\"Points of LinearRing do not form a closed linestring\");\n  \t\t}\n  \t\tif (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < LinearRing.MINIMUM_VALID_SIZE) {\n  \t\t\tthrow new IllegalArgumentException(\"Invalid number of points in LinearRing (found \" + this.getCoordinateSequence().size() + \" - must be 0 or >= 4)\");\n  \t\t}\n  \t},\n  \tgetGeometryType: function getGeometryType() {\n  \t\treturn \"LinearRing\";\n  \t},\n  \tcopy: function copy() {\n  \t\treturn new LinearRing(this._points.copy(), this._factory);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LinearRing;\n  \t}\n  });\n  LinearRing.MINIMUM_VALID_SIZE = 4;\n  LinearRing.serialVersionUID = -4261142084085851829;\n\n  function MultiPolygon() {\n  \tvar polygons = arguments[0],\n  \t    factory = arguments[1];\n  \tGeometryCollection.call(this, polygons, factory);\n  }\n  inherits$1(MultiPolygon, GeometryCollection);\n  extend(MultiPolygon.prototype, {\n  \tgetSortIndex: function getSortIndex() {\n  \t\treturn Geometry.SORTINDEX_MULTIPOLYGON;\n  \t},\n  \tequalsExact: function equalsExact() {\n  \t\tif (arguments.length === 2) {\n  \t\t\tvar other = arguments[0],\n  \t\t\t    tolerance = arguments[1];\n  \t\t\tif (!this.isEquivalentClass(other)) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t\treturn GeometryCollection.prototype.equalsExact.call(this, other, tolerance);\n  \t\t} else return GeometryCollection.prototype.equalsExact.apply(this, arguments);\n  \t},\n  \tgetBoundaryDimension: function getBoundaryDimension() {\n  \t\treturn 1;\n  \t},\n  \tgetDimension: function getDimension() {\n  \t\treturn 2;\n  \t},\n  \treverse: function reverse() {\n  \t\tvar n = this._geometries.length;\n  \t\tvar revGeoms = new Array(n).fill(null);\n  \t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\trevGeoms[i] = this._geometries[i].reverse();\n  \t\t}\n  \t\treturn this.getFactory().createMultiPolygon(revGeoms);\n  \t},\n  \tgetBoundary: function getBoundary() {\n  \t\tif (this.isEmpty()) {\n  \t\t\treturn this.getFactory().createMultiLineString();\n  \t\t}\n  \t\tvar allRings = new ArrayList();\n  \t\tfor (var i = 0; i < this._geometries.length; i++) {\n  \t\t\tvar polygon = this._geometries[i];\n  \t\t\tvar rings = polygon.getBoundary();\n  \t\t\tfor (var j = 0; j < rings.getNumGeometries(); j++) {\n  \t\t\t\tallRings.add(rings.getGeometryN(j));\n  \t\t\t}\n  \t\t}\n  \t\tvar allRingsArray = new Array(allRings.size()).fill(null);\n  \t\treturn this.getFactory().createMultiLineString(allRings.toArray(allRingsArray));\n  \t},\n  \tgetGeometryType: function getGeometryType() {\n  \t\treturn \"MultiPolygon\";\n  \t},\n  \tcopy: function copy() {\n  \t\tvar polygons = new Array(this._geometries.length).fill(null);\n  \t\tfor (var i = 0; i < polygons.length; i++) {\n  \t\t\tpolygons[i] = this._geometries[i].copy();\n  \t\t}\n  \t\treturn new MultiPolygon(polygons, this._factory);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Polygonal];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MultiPolygon;\n  \t}\n  });\n  MultiPolygon.serialVersionUID = -551033529766975875;\n\n  function GeometryEditor() {\n  \tthis._factory = null;\n  \tthis._isUserDataCopied = false;\n  \tif (arguments.length === 0) ; else if (arguments.length === 1) {\n  \t\tvar factory = arguments[0];\n  \t\tthis._factory = factory;\n  \t}\n  }\n  extend(GeometryEditor.prototype, {\n  \tsetCopyUserData: function setCopyUserData(isUserDataCopied) {\n  \t\tthis._isUserDataCopied = isUserDataCopied;\n  \t},\n  \tedit: function edit(geometry, operation) {\n  \t\tif (geometry === null) return null;\n  \t\tvar result = this.editInternal(geometry, operation);\n  \t\tif (this._isUserDataCopied) {\n  \t\t\tresult.setUserData(geometry.getUserData());\n  \t\t}\n  \t\treturn result;\n  \t},\n  \teditInternal: function editInternal(geometry, operation) {\n  \t\tif (this._factory === null) this._factory = geometry.getFactory();\n  \t\tif (geometry instanceof GeometryCollection) {\n  \t\t\treturn this.editGeometryCollection(geometry, operation);\n  \t\t}\n  \t\tif (geometry instanceof Polygon) {\n  \t\t\treturn this.editPolygon(geometry, operation);\n  \t\t}\n  \t\tif (geometry instanceof Point) {\n  \t\t\treturn operation.edit(geometry, this._factory);\n  \t\t}\n  \t\tif (geometry instanceof LineString) {\n  \t\t\treturn operation.edit(geometry, this._factory);\n  \t\t}\n  \t\tAssert.shouldNeverReachHere(\"Unsupported Geometry class: \" + geometry.getClass().getName());\n  \t\treturn null;\n  \t},\n  \teditGeometryCollection: function editGeometryCollection(collection, operation) {\n  \t\tvar collectionForType = operation.edit(collection, this._factory);\n  \t\tvar geometries = new ArrayList();\n  \t\tfor (var i = 0; i < collectionForType.getNumGeometries(); i++) {\n  \t\t\tvar geometry = this.edit(collectionForType.getGeometryN(i), operation);\n  \t\t\tif (geometry === null || geometry.isEmpty()) {\n  \t\t\t\tcontinue;\n  \t\t\t}\n  \t\t\tgeometries.add(geometry);\n  \t\t}\n  \t\tif (collectionForType.getClass() === MultiPoint) {\n  \t\t\treturn this._factory.createMultiPoint(geometries.toArray([]));\n  \t\t}\n  \t\tif (collectionForType.getClass() === MultiLineString) {\n  \t\t\treturn this._factory.createMultiLineString(geometries.toArray([]));\n  \t\t}\n  \t\tif (collectionForType.getClass() === MultiPolygon) {\n  \t\t\treturn this._factory.createMultiPolygon(geometries.toArray([]));\n  \t\t}\n  \t\treturn this._factory.createGeometryCollection(geometries.toArray([]));\n  \t},\n  \teditPolygon: function editPolygon(polygon, operation) {\n  \t\tvar newPolygon = operation.edit(polygon, this._factory);\n  \t\tif (newPolygon === null) newPolygon = this._factory.createPolygon(null);\n  \t\tif (newPolygon.isEmpty()) {\n  \t\t\treturn newPolygon;\n  \t\t}\n  \t\tvar shell = this.edit(newPolygon.getExteriorRing(), operation);\n  \t\tif (shell === null || shell.isEmpty()) {\n  \t\t\treturn this._factory.createPolygon();\n  \t\t}\n  \t\tvar holes = new ArrayList();\n  \t\tfor (var i = 0; i < newPolygon.getNumInteriorRing(); i++) {\n  \t\t\tvar hole = this.edit(newPolygon.getInteriorRingN(i), operation);\n  \t\t\tif (hole === null || hole.isEmpty()) {\n  \t\t\t\tcontinue;\n  \t\t\t}\n  \t\t\tholes.add(hole);\n  \t\t}\n  \t\treturn this._factory.createPolygon(shell, holes.toArray([]));\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn GeometryEditor;\n  \t}\n  });\n  function GeometryEditorOperation() {}\n  GeometryEditor.GeometryEditorOperation = GeometryEditorOperation;\n  function NoOpGeometryOperation() {}\n  extend(NoOpGeometryOperation.prototype, {\n  \tedit: function edit(geometry, factory) {\n  \t\treturn geometry;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [GeometryEditorOperation];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn NoOpGeometryOperation;\n  \t}\n  });\n  function CoordinateOperation() {}\n  extend(CoordinateOperation.prototype, {\n  \tedit: function edit(geometry, factory) {\n  \t\tvar coords = this.editCoordinates(geometry.getCoordinates(), geometry);\n  \t\tif (coords === null) return geometry;\n  \t\tif (geometry instanceof LinearRing) {\n  \t\t\treturn factory.createLinearRing(coords);\n  \t\t}\n  \t\tif (geometry instanceof LineString) {\n  \t\t\treturn factory.createLineString(coords);\n  \t\t}\n  \t\tif (geometry instanceof Point) {\n  \t\t\tif (coords.length > 0) {\n  \t\t\t\treturn factory.createPoint(coords[0]);\n  \t\t\t} else {\n  \t\t\t\treturn factory.createPoint();\n  \t\t\t}\n  \t\t}\n  \t\treturn geometry;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [GeometryEditorOperation];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn CoordinateOperation;\n  \t}\n  });\n  function CoordinateSequenceOperation() {}\n  extend(CoordinateSequenceOperation.prototype, {\n  \tedit: function edit(geometry, factory) {\n  \t\tif (geometry instanceof LinearRing) {\n  \t\t\treturn factory.createLinearRing(this.edit(geometry.getCoordinateSequence(), geometry));\n  \t\t}\n  \t\tif (geometry instanceof LineString) {\n  \t\t\treturn factory.createLineString(this.edit(geometry.getCoordinateSequence(), geometry));\n  \t\t}\n  \t\tif (geometry instanceof Point) {\n  \t\t\treturn factory.createPoint(this.edit(geometry.getCoordinateSequence(), geometry));\n  \t\t}\n  \t\treturn geometry;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [GeometryEditorOperation];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn CoordinateSequenceOperation;\n  \t}\n  });\n  GeometryEditor.NoOpGeometryOperation = NoOpGeometryOperation;\n  GeometryEditor.CoordinateOperation = CoordinateOperation;\n  GeometryEditor.CoordinateSequenceOperation = CoordinateSequenceOperation;\n\n  function CoordinateArraySequence() {\n  \tthis._dimension = 3;\n  \tthis._coordinates = null;\n  \tif (arguments.length === 1) {\n  \t\tif (arguments[0] instanceof Array) {\n  \t\t\tvar coordinates = arguments[0];\n  \t\t\tCoordinateArraySequence.call(this, coordinates, 3);\n  \t\t} else if (Number.isInteger(arguments[0])) {\n  \t\t\tvar size = arguments[0];\n  \t\t\tthis._coordinates = new Array(size).fill(null);\n  \t\t\tfor (var i = 0; i < size; i++) {\n  \t\t\t\tthis._coordinates[i] = new Coordinate();\n  \t\t\t}\n  \t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n  \t\t\tvar coordSeq = arguments[0];\n  \t\t\tif (coordSeq === null) {\n  \t\t\t\tthis._coordinates = new Array(0).fill(null);\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t\tthis._dimension = coordSeq.getDimension();\n  \t\t\tthis._coordinates = new Array(coordSeq.size()).fill(null);\n  \t\t\tfor (var i = 0; i < this._coordinates.length; i++) {\n  \t\t\t\tthis._coordinates[i] = coordSeq.getCoordinateCopy(i);\n  \t\t\t}\n  \t\t}\n  \t} else if (arguments.length === 2) {\n  \t\tif (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {\n  \t\t\tvar coordinates = arguments[0],\n  \t\t\t    dimension = arguments[1];\n  \t\t\tthis._coordinates = coordinates;\n  \t\t\tthis._dimension = dimension;\n  \t\t\tif (coordinates === null) this._coordinates = new Array(0).fill(null);\n  \t\t} else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {\n  \t\t\tvar size = arguments[0],\n  \t\t\t    dimension = arguments[1];\n  \t\t\tthis._coordinates = new Array(size).fill(null);\n  \t\t\tthis._dimension = dimension;\n  \t\t\tfor (var i = 0; i < size; i++) {\n  \t\t\t\tthis._coordinates[i] = new Coordinate();\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n  extend(CoordinateArraySequence.prototype, {\n  \tsetOrdinate: function setOrdinate(index, ordinateIndex, value) {\n  \t\tswitch (ordinateIndex) {\n  \t\t\tcase CoordinateSequence.X:\n  \t\t\t\tthis._coordinates[index].x = value;\n  \t\t\t\tbreak;\n  \t\t\tcase CoordinateSequence.Y:\n  \t\t\t\tthis._coordinates[index].y = value;\n  \t\t\t\tbreak;\n  \t\t\tcase CoordinateSequence.Z:\n  \t\t\t\tthis._coordinates[index].z = value;\n  \t\t\t\tbreak;\n  \t\t\tdefault:\n  \t\t\t\tthrow new IllegalArgumentException(\"invalid ordinateIndex\");\n  \t\t}\n  \t},\n  \tsize: function size() {\n  \t\treturn this._coordinates.length;\n  \t},\n  \tgetOrdinate: function getOrdinate(index, ordinateIndex) {\n  \t\tswitch (ordinateIndex) {\n  \t\t\tcase CoordinateSequence.X:\n  \t\t\t\treturn this._coordinates[index].x;\n  \t\t\tcase CoordinateSequence.Y:\n  \t\t\t\treturn this._coordinates[index].y;\n  \t\t\tcase CoordinateSequence.Z:\n  \t\t\t\treturn this._coordinates[index].z;\n  \t\t}\n  \t\treturn Double.NaN;\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar i = arguments[0];\n  \t\t\treturn this._coordinates[i];\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar index = arguments[0],\n  \t\t\t    coord = arguments[1];\n  \t\t\tcoord.x = this._coordinates[index].x;\n  \t\t\tcoord.y = this._coordinates[index].y;\n  \t\t\tcoord.z = this._coordinates[index].z;\n  \t\t}\n  \t},\n  \tgetCoordinateCopy: function getCoordinateCopy(i) {\n  \t\treturn new Coordinate(this._coordinates[i]);\n  \t},\n  \tgetDimension: function getDimension() {\n  \t\treturn this._dimension;\n  \t},\n  \tgetX: function getX(index) {\n  \t\treturn this._coordinates[index].x;\n  \t},\n  \tclone: function clone() {\n  \t\tvar cloneCoordinates = new Array(this.size()).fill(null);\n  \t\tfor (var i = 0; i < this._coordinates.length; i++) {\n  \t\t\tcloneCoordinates[i] = this._coordinates[i].clone();\n  \t\t}\n  \t\treturn new CoordinateArraySequence(cloneCoordinates, this._dimension);\n  \t},\n  \texpandEnvelope: function expandEnvelope(env) {\n  \t\tfor (var i = 0; i < this._coordinates.length; i++) {\n  \t\t\tenv.expandToInclude(this._coordinates[i]);\n  \t\t}\n  \t\treturn env;\n  \t},\n  \tcopy: function copy() {\n  \t\tvar cloneCoordinates = new Array(this.size()).fill(null);\n  \t\tfor (var i = 0; i < this._coordinates.length; i++) {\n  \t\t\tcloneCoordinates[i] = this._coordinates[i].copy();\n  \t\t}\n  \t\treturn new CoordinateArraySequence(cloneCoordinates, this._dimension);\n  \t},\n  \ttoString: function toString() {\n  \t\tif (this._coordinates.length > 0) {\n  \t\t\tvar strBuf = new StringBuffer(17 * this._coordinates.length);\n  \t\t\tstrBuf.append('(');\n  \t\t\tstrBuf.append(this._coordinates[0]);\n  \t\t\tfor (var i = 1; i < this._coordinates.length; i++) {\n  \t\t\t\tstrBuf.append(\", \");\n  \t\t\t\tstrBuf.append(this._coordinates[i]);\n  \t\t\t}\n  \t\t\tstrBuf.append(')');\n  \t\t\treturn strBuf.toString();\n  \t\t} else {\n  \t\t\treturn \"()\";\n  \t\t}\n  \t},\n  \tgetY: function getY(index) {\n  \t\treturn this._coordinates[index].y;\n  \t},\n  \ttoCoordinateArray: function toCoordinateArray() {\n  \t\treturn this._coordinates;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [CoordinateSequence, Serializable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn CoordinateArraySequence;\n  \t}\n  });\n  CoordinateArraySequence.serialVersionUID = -915438501601840650;\n\n  function CoordinateArraySequenceFactory() {}\n  extend(CoordinateArraySequenceFactory.prototype, {\n  \treadResolve: function readResolve() {\n  \t\treturn CoordinateArraySequenceFactory.instance();\n  \t},\n  \tcreate: function create() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tif (arguments[0] instanceof Array) {\n  \t\t\t\tvar coordinates = arguments[0];\n  \t\t\t\treturn new CoordinateArraySequence(coordinates);\n  \t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n  \t\t\t\tvar coordSeq = arguments[0];\n  \t\t\t\treturn new CoordinateArraySequence(coordSeq);\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar size = arguments[0],\n  \t\t\t    dimension = arguments[1];\n  \t\t\tif (dimension > 3) dimension = 3;\n  \t\t\tif (dimension < 2) return new CoordinateArraySequence(size);\n  \t\t\treturn new CoordinateArraySequence(size, dimension);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [CoordinateSequenceFactory, Serializable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn CoordinateArraySequenceFactory;\n  \t}\n  });\n  CoordinateArraySequenceFactory.instance = function () {\n  \treturn CoordinateArraySequenceFactory.instanceObject;\n  };\n  CoordinateArraySequenceFactory.serialVersionUID = -4099577099607551657;\n  CoordinateArraySequenceFactory.instanceObject = new CoordinateArraySequenceFactory();\n\n  var i;\n  var defineProperty$1 = Object.defineProperty;\n  function is(a, b) {\n    return a === b || a !== a && b !== b;\n  }\n  var MapPolyfill = createCollection({\n    'delete': sharedDelete,\n    has: mapHas,\n    get: sharedGet,\n    set: sharedSet,\n    keys: sharedKeys,\n    values: sharedValues,\n    entries: mapEntries,\n    forEach: sharedForEach,\n    clear: sharedClear\n  });\n  function createCollection(proto, objectOnly) {\n    function Collection(a) {\n      if (!this || this.constructor !== Collection) return new Collection(a);\n      this._keys = [];\n      this._values = [];\n      this._itp = [];\n      this.objectOnly = objectOnly;\n      if (a) init.call(this, a);\n    }\n    if (!objectOnly) {\n      defineProperty$1(proto, 'size', {\n        get: sharedSize\n      });\n    }\n    proto.constructor = Collection;\n    Collection.prototype = proto;\n    return Collection;\n  }\n  function init(a) {\n    if (this.add) a.forEach(this.add, this);\n    else a.forEach(function (a) {\n        this.set(a[0], a[1]);\n      }, this);\n  }\n  function sharedDelete(key) {\n    if (this.has(key)) {\n      this._keys.splice(i, 1);\n      this._values.splice(i, 1);\n      this._itp.forEach(function (p) {\n        if (i < p[0]) p[0]--;\n      });\n    }\n    return i > -1;\n  }\n  function sharedGet(key) {\n    return this.has(key) ? this._values[i] : undefined;\n  }\n  function has(list, key) {\n    if (this.objectOnly && key !== Object(key)) throw new TypeError('Invalid value used as weak collection key');\n    if (key !== key || key === 0) for (i = list.length; i-- && !is(list[i], key);) {}\n    else i = list.indexOf(key);\n    return i > -1;\n  }\n  function mapHas(value) {\n    return has.call(this, this._keys, value);\n  }\n  function sharedSet(key, value) {\n    this.has(key) ? this._values[i] = value : this._values[this._keys.push(key) - 1] = value;\n    return this;\n  }\n  function sharedClear() {\n    (this._keys || 0).length = this._values.length = 0;\n  }\n  function sharedKeys() {\n    return sharedIterator(this._itp, this._keys);\n  }\n  function sharedValues() {\n    return sharedIterator(this._itp, this._values);\n  }\n  function mapEntries() {\n    return sharedIterator(this._itp, this._keys, this._values);\n  }\n  function sharedIterator(itp, array, array2) {\n    var p = [0];\n    var done = false;\n    itp.push(p);\n    return {\n      next: function next() {\n        var v;\n        var k = p[0];\n        if (!done && k < array.length) {\n          v = array2 ? [array[k], array2[k]] : array[k];\n          p[0]++;\n        } else {\n          done = true;\n          itp.splice(itp.indexOf(p), 1);\n        }\n        return { done: done, value: v };\n      }\n    };\n  }\n  function sharedSize() {\n    return this._values.length;\n  }\n  function sharedForEach(callback, context) {\n    var it = this.entries();\n    for (;;) {\n      var r = it.next();\n      if (r.done) break;\n      callback.call(context, r.value[1], r.value[0], this);\n    }\n  }\n\n  var MapImpl = typeof Map === 'undefined' || !Map.prototype.values ? MapPolyfill : Map;\n  function HashMap() {\n    this.map_ = new MapImpl();\n  }\n  HashMap.prototype = new Map$2();\n  HashMap.prototype.get = function (key) {\n    return this.map_.get(key) || null;\n  };\n  HashMap.prototype.put = function (key, value) {\n    this.map_.set(key, value);\n    return value;\n  };\n  HashMap.prototype.values = function () {\n    var arrayList = new ArrayList();\n    var it = this.map_.values();\n    var o = it.next();\n    while (!o.done) {\n      arrayList.add(o.value);\n      o = it.next();\n    }\n    return arrayList;\n  };\n  HashMap.prototype.entrySet = function () {\n    var hashSet = new HashSet();\n    this.map_.entries().forEach(function (entry) {\n      return hashSet.add(entry);\n    });\n    return hashSet;\n  };\n  HashMap.prototype.size = function () {\n    return this.map_.size();\n  };\n\n  function PrecisionModel() {\n  \tthis._modelType = null;\n  \tthis._scale = null;\n  \tif (arguments.length === 0) {\n  \t\tthis._modelType = PrecisionModel.FLOATING;\n  \t} else if (arguments.length === 1) {\n  \t\tif (arguments[0] instanceof Type) {\n  \t\t\tvar modelType = arguments[0];\n  \t\t\tthis._modelType = modelType;\n  \t\t\tif (modelType === PrecisionModel.FIXED) {\n  \t\t\t\tthis.setScale(1.0);\n  \t\t\t}\n  \t\t} else if (typeof arguments[0] === \"number\") {\n  \t\t\tvar scale = arguments[0];\n  \t\t\tthis._modelType = PrecisionModel.FIXED;\n  \t\t\tthis.setScale(scale);\n  \t\t} else if (arguments[0] instanceof PrecisionModel) {\n  \t\t\tvar pm = arguments[0];\n  \t\t\tthis._modelType = pm._modelType;\n  \t\t\tthis._scale = pm._scale;\n  \t\t}\n  \t}\n  }\n  extend(PrecisionModel.prototype, {\n  \tequals: function equals(other) {\n  \t\tif (!(other instanceof PrecisionModel)) {\n  \t\t\treturn false;\n  \t\t}\n  \t\tvar otherPrecisionModel = other;\n  \t\treturn this._modelType === otherPrecisionModel._modelType && this._scale === otherPrecisionModel._scale;\n  \t},\n  \tcompareTo: function compareTo(o) {\n  \t\tvar other = o;\n  \t\tvar sigDigits = this.getMaximumSignificantDigits();\n  \t\tvar otherSigDigits = other.getMaximumSignificantDigits();\n  \t\treturn new Integer(sigDigits).compareTo(new Integer(otherSigDigits));\n  \t},\n  \tgetScale: function getScale() {\n  \t\treturn this._scale;\n  \t},\n  \tisFloating: function isFloating() {\n  \t\treturn this._modelType === PrecisionModel.FLOATING || this._modelType === PrecisionModel.FLOATING_SINGLE;\n  \t},\n  \tgetType: function getType() {\n  \t\treturn this._modelType;\n  \t},\n  \ttoString: function toString() {\n  \t\tvar description = \"UNKNOWN\";\n  \t\tif (this._modelType === PrecisionModel.FLOATING) {\n  \t\t\tdescription = \"Floating\";\n  \t\t} else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {\n  \t\t\tdescription = \"Floating-Single\";\n  \t\t} else if (this._modelType === PrecisionModel.FIXED) {\n  \t\t\tdescription = \"Fixed (Scale=\" + this.getScale() + \")\";\n  \t\t}\n  \t\treturn description;\n  \t},\n  \tmakePrecise: function makePrecise() {\n  \t\tif (typeof arguments[0] === \"number\") {\n  \t\t\tvar val = arguments[0];\n  \t\t\tif (Double.isNaN(val)) return val;\n  \t\t\tif (this._modelType === PrecisionModel.FLOATING_SINGLE) {\n  \t\t\t\tvar floatSingleVal = val;\n  \t\t\t\treturn floatSingleVal;\n  \t\t\t}\n  \t\t\tif (this._modelType === PrecisionModel.FIXED) {\n  \t\t\t\treturn Math.round(val * this._scale) / this._scale;\n  \t\t\t}\n  \t\t\treturn val;\n  \t\t} else if (arguments[0] instanceof Coordinate) {\n  \t\t\tvar coord = arguments[0];\n  \t\t\tif (this._modelType === PrecisionModel.FLOATING) return null;\n  \t\t\tcoord.x = this.makePrecise(coord.x);\n  \t\t\tcoord.y = this.makePrecise(coord.y);\n  \t\t}\n  \t},\n  \tgetMaximumSignificantDigits: function getMaximumSignificantDigits() {\n  \t\tvar maxSigDigits = 16;\n  \t\tif (this._modelType === PrecisionModel.FLOATING) {\n  \t\t\tmaxSigDigits = 16;\n  \t\t} else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {\n  \t\t\tmaxSigDigits = 6;\n  \t\t} else if (this._modelType === PrecisionModel.FIXED) {\n  \t\t\tmaxSigDigits = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)));\n  \t\t}\n  \t\treturn maxSigDigits;\n  \t},\n  \tsetScale: function setScale(scale) {\n  \t\tthis._scale = Math.abs(scale);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Serializable, Comparable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn PrecisionModel;\n  \t}\n  });\n  PrecisionModel.mostPrecise = function (pm1, pm2) {\n  \tif (pm1.compareTo(pm2) >= 0) return pm1;\n  \treturn pm2;\n  };\n  function Type() {\n  \tthis._name = null;\n  \tvar name = arguments[0];\n  \tthis._name = name;\n  \tType.nameToTypeMap.put(name, this);\n  }\n  extend(Type.prototype, {\n  \treadResolve: function readResolve() {\n  \t\treturn Type.nameToTypeMap.get(this._name);\n  \t},\n  \ttoString: function toString() {\n  \t\treturn this._name;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Serializable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Type;\n  \t}\n  });\n  Type.serialVersionUID = -5528602631731589822;\n  Type.nameToTypeMap = new HashMap();\n  PrecisionModel.Type = Type;\n  PrecisionModel.serialVersionUID = 7777263578777803835;\n  PrecisionModel.FIXED = new Type(\"FIXED\");\n  PrecisionModel.FLOATING = new Type(\"FLOATING\");\n  PrecisionModel.FLOATING_SINGLE = new Type(\"FLOATING SINGLE\");\n  PrecisionModel.maximumPreciseValue = 9007199254740992.0;\n\n  function GeometryFactory() {\n  \tthis._precisionModel = null;\n  \tthis._coordinateSequenceFactory = null;\n  \tthis._SRID = null;\n  \tif (arguments.length === 0) {\n  \t\tGeometryFactory.call(this, new PrecisionModel(), 0);\n  \t} else if (arguments.length === 1) {\n  \t\tif (hasInterface(arguments[0], CoordinateSequenceFactory)) {\n  \t\t\tvar coordinateSequenceFactory = arguments[0];\n  \t\t\tGeometryFactory.call(this, new PrecisionModel(), 0, coordinateSequenceFactory);\n  \t\t} else if (arguments[0] instanceof PrecisionModel) {\n  \t\t\tvar precisionModel = arguments[0];\n  \t\t\tGeometryFactory.call(this, precisionModel, 0, GeometryFactory.getDefaultCoordinateSequenceFactory());\n  \t\t}\n  \t} else if (arguments.length === 2) {\n  \t\tvar precisionModel = arguments[0],\n  \t\t    SRID = arguments[1];\n  \t\tGeometryFactory.call(this, precisionModel, SRID, GeometryFactory.getDefaultCoordinateSequenceFactory());\n  \t} else if (arguments.length === 3) {\n  \t\tvar precisionModel = arguments[0],\n  \t\t    SRID = arguments[1],\n  \t\t    coordinateSequenceFactory = arguments[2];\n  \t\tthis._precisionModel = precisionModel;\n  \t\tthis._coordinateSequenceFactory = coordinateSequenceFactory;\n  \t\tthis._SRID = SRID;\n  \t}\n  }\n  extend(GeometryFactory.prototype, {\n  \ttoGeometry: function toGeometry(envelope) {\n  \t\tif (envelope.isNull()) {\n  \t\t\treturn this.createPoint(null);\n  \t\t}\n  \t\tif (envelope.getMinX() === envelope.getMaxX() && envelope.getMinY() === envelope.getMaxY()) {\n  \t\t\treturn this.createPoint(new Coordinate(envelope.getMinX(), envelope.getMinY()));\n  \t\t}\n  \t\tif (envelope.getMinX() === envelope.getMaxX() || envelope.getMinY() === envelope.getMaxY()) {\n  \t\t\treturn this.createLineString([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY())]);\n  \t\t}\n  \t\treturn this.createPolygon(this.createLinearRing([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMinY())]), null);\n  \t},\n  \tcreateLineString: function createLineString() {\n  \t\tif (arguments.length === 0) {\n  \t\t\treturn this.createLineString(this.getCoordinateSequenceFactory().create([]));\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tif (arguments[0] instanceof Array) {\n  \t\t\t\tvar coordinates = arguments[0];\n  \t\t\t\treturn this.createLineString(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);\n  \t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n  \t\t\t\tvar coordinates = arguments[0];\n  \t\t\t\treturn new LineString(coordinates, this);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcreateMultiLineString: function createMultiLineString() {\n  \t\tif (arguments.length === 0) {\n  \t\t\treturn new MultiLineString(null, this);\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tvar lineStrings = arguments[0];\n  \t\t\treturn new MultiLineString(lineStrings, this);\n  \t\t}\n  \t},\n  \tbuildGeometry: function buildGeometry(geomList) {\n  \t\tvar geomClass = null;\n  \t\tvar isHeterogeneous = false;\n  \t\tvar hasGeometryCollection = false;\n  \t\tfor (var i = geomList.iterator(); i.hasNext();) {\n  \t\t\tvar geom = i.next();\n  \t\t\tvar partClass = geom.getClass();\n  \t\t\tif (geomClass === null) {\n  \t\t\t\tgeomClass = partClass;\n  \t\t\t}\n  \t\t\tif (partClass !== geomClass) {\n  \t\t\t\tisHeterogeneous = true;\n  \t\t\t}\n  \t\t\tif (geom.isGeometryCollectionOrDerived()) hasGeometryCollection = true;\n  \t\t}\n  \t\tif (geomClass === null) {\n  \t\t\treturn this.createGeometryCollection();\n  \t\t}\n  \t\tif (isHeterogeneous || hasGeometryCollection) {\n  \t\t\treturn this.createGeometryCollection(GeometryFactory.toGeometryArray(geomList));\n  \t\t}\n  \t\tvar geom0 = geomList.iterator().next();\n  \t\tvar isCollection = geomList.size() > 1;\n  \t\tif (isCollection) {\n  \t\t\tif (geom0 instanceof Polygon) {\n  \t\t\t\treturn this.createMultiPolygon(GeometryFactory.toPolygonArray(geomList));\n  \t\t\t} else if (geom0 instanceof LineString) {\n  \t\t\t\treturn this.createMultiLineString(GeometryFactory.toLineStringArray(geomList));\n  \t\t\t} else if (geom0 instanceof Point) {\n  \t\t\t\treturn this.createMultiPoint(GeometryFactory.toPointArray(geomList));\n  \t\t\t}\n  \t\t\tAssert.shouldNeverReachHere(\"Unhandled class: \" + geom0.getClass().getName());\n  \t\t}\n  \t\treturn geom0;\n  \t},\n  \tcreateMultiPointFromCoords: function createMultiPointFromCoords(coordinates) {\n  \t\treturn this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);\n  \t},\n  \tcreatePoint: function createPoint() {\n  \t\tif (arguments.length === 0) {\n  \t\t\treturn this.createPoint(this.getCoordinateSequenceFactory().create([]));\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tif (arguments[0] instanceof Coordinate) {\n  \t\t\t\tvar coordinate = arguments[0];\n  \t\t\t\treturn this.createPoint(coordinate !== null ? this.getCoordinateSequenceFactory().create([coordinate]) : null);\n  \t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n  \t\t\t\tvar coordinates = arguments[0];\n  \t\t\t\treturn new Point(coordinates, this);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetCoordinateSequenceFactory: function getCoordinateSequenceFactory() {\n  \t\treturn this._coordinateSequenceFactory;\n  \t},\n  \tcreatePolygon: function createPolygon() {\n  \t\tif (arguments.length === 0) {\n  \t\t\treturn new Polygon(null, null, this);\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tif (hasInterface(arguments[0], CoordinateSequence)) {\n  \t\t\t\tvar coordinates = arguments[0];\n  \t\t\t\treturn this.createPolygon(this.createLinearRing(coordinates));\n  \t\t\t} else if (arguments[0] instanceof Array) {\n  \t\t\t\tvar coordinates = arguments[0];\n  \t\t\t\treturn this.createPolygon(this.createLinearRing(coordinates));\n  \t\t\t} else if (arguments[0] instanceof LinearRing) {\n  \t\t\t\tvar shell = arguments[0];\n  \t\t\t\treturn this.createPolygon(shell, null);\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar shell = arguments[0],\n  \t\t\t    holes = arguments[1];\n  \t\t\treturn new Polygon(shell, holes, this);\n  \t\t}\n  \t},\n  \tgetSRID: function getSRID() {\n  \t\treturn this._SRID;\n  \t},\n  \tcreateGeometryCollection: function createGeometryCollection() {\n  \t\tif (arguments.length === 0) {\n  \t\t\treturn new GeometryCollection(null, this);\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tvar geometries = arguments[0];\n  \t\t\treturn new GeometryCollection(geometries, this);\n  \t\t}\n  \t},\n  \tcreateGeometry: function createGeometry(g) {\n  \t\tvar editor = new GeometryEditor(this);\n  \t\treturn editor.edit(g, {\n  \t\t\tedit: function edit() {\n  \t\t\t\tif (arguments.length === 2) {\n  \t\t\t\t\tvar coordSeq = arguments[0];\n  \t\t\t\t\treturn this._coordinateSequenceFactory.create(coordSeq);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t});\n  \t},\n  \tgetPrecisionModel: function getPrecisionModel() {\n  \t\treturn this._precisionModel;\n  \t},\n  \tcreateLinearRing: function createLinearRing() {\n  \t\tif (arguments.length === 0) {\n  \t\t\treturn this.createLinearRing(this.getCoordinateSequenceFactory().create([]));\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tif (arguments[0] instanceof Array) {\n  \t\t\t\tvar coordinates = arguments[0];\n  \t\t\t\treturn this.createLinearRing(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);\n  \t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n  \t\t\t\tvar coordinates = arguments[0];\n  \t\t\t\treturn new LinearRing(coordinates, this);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcreateMultiPolygon: function createMultiPolygon() {\n  \t\tif (arguments.length === 0) {\n  \t\t\treturn new MultiPolygon(null, this);\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tvar polygons = arguments[0];\n  \t\t\treturn new MultiPolygon(polygons, this);\n  \t\t}\n  \t},\n  \tcreateMultiPoint: function createMultiPoint() {\n  \t\tif (arguments.length === 0) {\n  \t\t\treturn new MultiPoint(null, this);\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tif (arguments[0] instanceof Array) {\n  \t\t\t\tvar point = arguments[0];\n  \t\t\t\treturn new MultiPoint(point, this);\n  \t\t\t} else if (arguments[0] instanceof Array) {\n  \t\t\t\tvar coordinates = arguments[0];\n  \t\t\t\treturn this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);\n  \t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n  \t\t\t\tvar coordinates = arguments[0];\n  \t\t\t\tif (coordinates === null) {\n  \t\t\t\t\treturn this.createMultiPoint(new Array(0).fill(null));\n  \t\t\t\t}\n  \t\t\t\tvar points = new Array(coordinates.size()).fill(null);\n  \t\t\t\tfor (var i = 0; i < coordinates.size(); i++) {\n  \t\t\t\t\tvar ptSeq = this.getCoordinateSequenceFactory().create(1, coordinates.getDimension());\n  \t\t\t\t\tCoordinateSequences.copy(coordinates, i, ptSeq, 0, 1);\n  \t\t\t\t\tpoints[i] = this.createPoint(ptSeq);\n  \t\t\t\t}\n  \t\t\t\treturn this.createMultiPoint(points);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Serializable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn GeometryFactory;\n  \t}\n  });\n  GeometryFactory.toMultiPolygonArray = function (multiPolygons) {\n  \tvar multiPolygonArray = new Array(multiPolygons.size()).fill(null);\n  \treturn multiPolygons.toArray(multiPolygonArray);\n  };\n  GeometryFactory.toGeometryArray = function (geometries) {\n  \tif (geometries === null) return null;\n  \tvar geometryArray = new Array(geometries.size()).fill(null);\n  \treturn geometries.toArray(geometryArray);\n  };\n  GeometryFactory.getDefaultCoordinateSequenceFactory = function () {\n  \treturn CoordinateArraySequenceFactory.instance();\n  };\n  GeometryFactory.toMultiLineStringArray = function (multiLineStrings) {\n  \tvar multiLineStringArray = new Array(multiLineStrings.size()).fill(null);\n  \treturn multiLineStrings.toArray(multiLineStringArray);\n  };\n  GeometryFactory.toLineStringArray = function (lineStrings) {\n  \tvar lineStringArray = new Array(lineStrings.size()).fill(null);\n  \treturn lineStrings.toArray(lineStringArray);\n  };\n  GeometryFactory.toMultiPointArray = function (multiPoints) {\n  \tvar multiPointArray = new Array(multiPoints.size()).fill(null);\n  \treturn multiPoints.toArray(multiPointArray);\n  };\n  GeometryFactory.toLinearRingArray = function (linearRings) {\n  \tvar linearRingArray = new Array(linearRings.size()).fill(null);\n  \treturn linearRings.toArray(linearRingArray);\n  };\n  GeometryFactory.toPointArray = function (points) {\n  \tvar pointArray = new Array(points.size()).fill(null);\n  \treturn points.toArray(pointArray);\n  };\n  GeometryFactory.toPolygonArray = function (polygons) {\n  \tvar polygonArray = new Array(polygons.size()).fill(null);\n  \treturn polygons.toArray(polygonArray);\n  };\n  GeometryFactory.createPointFromInternalCoord = function (coord, exemplar) {\n  \texemplar.getPrecisionModel().makePrecise(coord);\n  \treturn exemplar.getFactory().createPoint(coord);\n  };\n  GeometryFactory.serialVersionUID = -6820524753094095635;\n\n  var regExes = {\n    'typeStr': /^\\s*(\\w+)\\s*\\(\\s*(.*)\\s*\\)\\s*$/,\n    'emptyTypeStr': /^\\s*(\\w+)\\s*EMPTY\\s*$/,\n    'spaces': /\\s+/,\n    'parenComma': /\\)\\s*,\\s*\\(/,\n    'doubleParenComma': /\\)\\s*\\)\\s*,\\s*\\(\\s*\\(/,\n    'trimParens': /^\\s*\\(?(.*?)\\)?\\s*$/\n  };function WKTParser(geometryFactory) {\n    this.geometryFactory = geometryFactory || new GeometryFactory();\n  }\n  extend(WKTParser.prototype, {\n    read: function read(wkt) {\n      var geometry, type, str;\n      wkt = wkt.replace(/[\\n\\r]/g, ' ');\n      var matches = regExes.typeStr.exec(wkt);\n      if (wkt.search('EMPTY') !== -1) {\n        matches = regExes.emptyTypeStr.exec(wkt);\n        matches[2] = undefined;\n      }\n      if (matches) {\n        type = matches[1].toLowerCase();\n        str = matches[2];\n        if (parse[type]) {\n          geometry = parse[type].apply(this, [str]);\n        }\n      }\n      if (geometry === undefined) throw new Error('Could not parse WKT ' + wkt);\n      return geometry;\n    },\n    write: function write(geometry) {\n      return this.extractGeometry(geometry);\n    },\n    extractGeometry: function extractGeometry(geometry) {\n      var type = geometry.getGeometryType().toLowerCase();\n      if (!extract$1[type]) {\n        return null;\n      }\n      var wktType = type.toUpperCase();\n      var data;\n      if (geometry.isEmpty()) {\n        data = wktType + ' EMPTY';\n      } else {\n        data = wktType + '(' + extract$1[type].apply(this, [geometry]) + ')';\n      }\n      return data;\n    }\n  });\n  var extract$1 = {\n    coordinate: function coordinate(_coordinate) {\n      return _coordinate.x + ' ' + _coordinate.y;\n    },\n    point: function point(_point) {\n      return extract$1.coordinate.call(this, _point._coordinates._coordinates[0]);\n    },\n    multipoint: function multipoint(_multipoint) {\n      var array = [];\n      for (var i = 0, len = _multipoint._geometries.length; i < len; ++i) {\n        array.push('(' + extract$1.point.apply(this, [_multipoint._geometries[i]]) + ')');\n      }\n      return array.join(',');\n    },\n    linestring: function linestring(_linestring) {\n      var array = [];\n      for (var i = 0, len = _linestring._points._coordinates.length; i < len; ++i) {\n        array.push(extract$1.coordinate.apply(this, [_linestring._points._coordinates[i]]));\n      }\n      return array.join(',');\n    },\n    linearring: function linearring(_linearring) {\n      var array = [];\n      for (var i = 0, len = _linearring._points._coordinates.length; i < len; ++i) {\n        array.push(extract$1.coordinate.apply(this, [_linearring._points._coordinates[i]]));\n      }\n      return array.join(',');\n    },\n    multilinestring: function multilinestring(_multilinestring) {\n      var array = [];\n      for (var i = 0, len = _multilinestring._geometries.length; i < len; ++i) {\n        array.push('(' + extract$1.linestring.apply(this, [_multilinestring._geometries[i]]) + ')');\n      }\n      return array.join(',');\n    },\n    polygon: function polygon(_polygon) {\n      var array = [];\n      array.push('(' + extract$1.linestring.apply(this, [_polygon._shell]) + ')');\n      for (var i = 0, len = _polygon._holes.length; i < len; ++i) {\n        array.push('(' + extract$1.linestring.apply(this, [_polygon._holes[i]]) + ')');\n      }\n      return array.join(',');\n    },\n    multipolygon: function multipolygon(_multipolygon) {\n      var array = [];\n      for (var i = 0, len = _multipolygon._geometries.length; i < len; ++i) {\n        array.push('(' + extract$1.polygon.apply(this, [_multipolygon._geometries[i]]) + ')');\n      }\n      return array.join(',');\n    },\n    geometrycollection: function geometrycollection(collection) {\n      var array = [];\n      for (var i = 0, len = collection._geometries.length; i < len; ++i) {\n        array.push(this.extractGeometry(collection._geometries[i]));\n      }\n      return array.join(',');\n    }\n  };\n  var parse = {\n    point: function point(str) {\n      if (str === undefined) {\n        return this.geometryFactory.createPoint();\n      }\n      var coords = str.trim().split(regExes.spaces);\n      return this.geometryFactory.createPoint(new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1])));\n    },\n    multipoint: function multipoint(str) {\n      if (str === undefined) {\n        return this.geometryFactory.createMultiPoint();\n      }\n      var point;\n      var points = str.trim().split(',');\n      var components = [];\n      for (var i = 0, len = points.length; i < len; ++i) {\n        point = points[i].replace(regExes.trimParens, '$1');\n        components.push(parse.point.apply(this, [point]));\n      }\n      return this.geometryFactory.createMultiPoint(components);\n    },\n    linestring: function linestring(str) {\n      if (str === undefined) {\n        return this.geometryFactory.createLineString();\n      }\n      var points = str.trim().split(',');\n      var components = [];\n      var coords;\n      for (var i = 0, len = points.length; i < len; ++i) {\n        coords = points[i].trim().split(regExes.spaces);\n        components.push(new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1])));\n      }\n      return this.geometryFactory.createLineString(components);\n    },\n    linearring: function linearring(str) {\n      if (str === undefined) {\n        return this.geometryFactory.createLinearRing();\n      }\n      var points = str.trim().split(',');\n      var components = [];\n      var coords;\n      for (var i = 0, len = points.length; i < len; ++i) {\n        coords = points[i].trim().split(regExes.spaces);\n        components.push(new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1])));\n      }\n      return this.geometryFactory.createLinearRing(components);\n    },\n    multilinestring: function multilinestring(str) {\n      if (str === undefined) {\n        return this.geometryFactory.createMultiLineString();\n      }\n      var line;\n      var lines = str.trim().split(regExes.parenComma);\n      var components = [];\n      for (var i = 0, len = lines.length; i < len; ++i) {\n        line = lines[i].replace(regExes.trimParens, '$1');\n        components.push(parse.linestring.apply(this, [line]));\n      }\n      return this.geometryFactory.createMultiLineString(components);\n    },\n    polygon: function polygon(str) {\n      if (str === undefined) {\n        return this.geometryFactory.createPolygon();\n      }\n      var ring, linestring, linearring;\n      var rings = str.trim().split(regExes.parenComma);\n      var shell;\n      var holes = [];\n      for (var i = 0, len = rings.length; i < len; ++i) {\n        ring = rings[i].replace(regExes.trimParens, '$1');\n        linestring = parse.linestring.apply(this, [ring]);\n        linearring = this.geometryFactory.createLinearRing(linestring._points);\n        if (i === 0) {\n          shell = linearring;\n        } else {\n          holes.push(linearring);\n        }\n      }\n      return this.geometryFactory.createPolygon(shell, holes);\n    },\n    multipolygon: function multipolygon(str) {\n      if (str === undefined) {\n        return this.geometryFactory.createMultiPolygon();\n      }\n      var polygon;\n      var polygons = str.trim().split(regExes.doubleParenComma);\n      var components = [];\n      for (var i = 0, len = polygons.length; i < len; ++i) {\n        polygon = polygons[i].replace(regExes.trimParens, '$1');\n        components.push(parse.polygon.apply(this, [polygon]));\n      }\n      return this.geometryFactory.createMultiPolygon(components);\n    },\n    geometrycollection: function geometrycollection(str) {\n      if (str === undefined) {\n        return this.geometryFactory.createGeometryCollection();\n      }\n      str = str.replace(/,\\s*([A-Za-z])/g, '|$1');\n      var wktArray = str.trim().split('|');\n      var components = [];\n      for (var i = 0, len = wktArray.length; i < len; ++i) {\n        components.push(this.read(wktArray[i]));\n      }\n      return this.geometryFactory.createGeometryCollection(components);\n    }\n  };\n\n  function WKTWriter(geometryFactory) {\n    this.parser = new WKTParser(geometryFactory);\n  }\n  extend(WKTWriter.prototype, {\n    write: function write(geometry) {\n      return this.parser.write(geometry);\n    }\n  });\n  extend(WKTWriter, {\n    toLineString: function toLineString(p0, p1) {\n      if (arguments.length !== 2) {\n        throw new Error('Not implemented');\n      }\n      return 'LINESTRING ( ' + p0.x + ' ' + p0.y + ', ' + p1.x + ' ' + p1.y + ' )';\n    }\n  });\n\n  function LineIntersector() {\n  \tthis._result = null;\n  \tthis._inputLines = Array(2).fill().map(function () {\n  \t\treturn Array(2);\n  \t});\n  \tthis._intPt = new Array(2).fill(null);\n  \tthis._intLineIndex = null;\n  \tthis._isProper = null;\n  \tthis._pa = null;\n  \tthis._pb = null;\n  \tthis._precisionModel = null;\n  \tthis._intPt[0] = new Coordinate();\n  \tthis._intPt[1] = new Coordinate();\n  \tthis._pa = this._intPt[0];\n  \tthis._pb = this._intPt[1];\n  \tthis._result = 0;\n  }\n  extend(LineIntersector.prototype, {\n  \tgetIndexAlongSegment: function getIndexAlongSegment(segmentIndex, intIndex) {\n  \t\tthis.computeIntLineIndex();\n  \t\treturn this._intLineIndex[segmentIndex][intIndex];\n  \t},\n  \tgetTopologySummary: function getTopologySummary() {\n  \t\tvar catBuf = new StringBuffer();\n  \t\tif (this.isEndPoint()) catBuf.append(\" endpoint\");\n  \t\tif (this._isProper) catBuf.append(\" proper\");\n  \t\tif (this.isCollinear()) catBuf.append(\" collinear\");\n  \t\treturn catBuf.toString();\n  \t},\n  \tcomputeIntersection: function computeIntersection(p1, p2, p3, p4) {\n  \t\tthis._inputLines[0][0] = p1;\n  \t\tthis._inputLines[0][1] = p2;\n  \t\tthis._inputLines[1][0] = p3;\n  \t\tthis._inputLines[1][1] = p4;\n  \t\tthis._result = this.computeIntersect(p1, p2, p3, p4);\n  \t},\n  \tgetIntersectionNum: function getIntersectionNum() {\n  \t\treturn this._result;\n  \t},\n  \tcomputeIntLineIndex: function computeIntLineIndex() {\n  \t\tif (arguments.length === 0) {\n  \t\t\tif (this._intLineIndex === null) {\n  \t\t\t\tthis._intLineIndex = Array(2).fill().map(function () {\n  \t\t\t\t\treturn Array(2);\n  \t\t\t\t});\n  \t\t\t\tthis.computeIntLineIndex(0);\n  \t\t\t\tthis.computeIntLineIndex(1);\n  \t\t\t}\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tvar segmentIndex = arguments[0];\n  \t\t\tvar dist0 = this.getEdgeDistance(segmentIndex, 0);\n  \t\t\tvar dist1 = this.getEdgeDistance(segmentIndex, 1);\n  \t\t\tif (dist0 > dist1) {\n  \t\t\t\tthis._intLineIndex[segmentIndex][0] = 0;\n  \t\t\t\tthis._intLineIndex[segmentIndex][1] = 1;\n  \t\t\t} else {\n  \t\t\t\tthis._intLineIndex[segmentIndex][0] = 1;\n  \t\t\t\tthis._intLineIndex[segmentIndex][1] = 0;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tisProper: function isProper() {\n  \t\treturn this.hasIntersection() && this._isProper;\n  \t},\n  \tsetPrecisionModel: function setPrecisionModel(precisionModel) {\n  \t\tthis._precisionModel = precisionModel;\n  \t},\n  \tisInteriorIntersection: function isInteriorIntersection() {\n  \t\tif (arguments.length === 0) {\n  \t\t\tif (this.isInteriorIntersection(0)) return true;\n  \t\t\tif (this.isInteriorIntersection(1)) return true;\n  \t\t\treturn false;\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tvar inputLineIndex = arguments[0];\n  \t\t\tfor (var i = 0; i < this._result; i++) {\n  \t\t\t\tif (!(this._intPt[i].equals2D(this._inputLines[inputLineIndex][0]) || this._intPt[i].equals2D(this._inputLines[inputLineIndex][1]))) {\n  \t\t\t\t\treturn true;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\treturn false;\n  \t\t}\n  \t},\n  \tgetIntersection: function getIntersection(intIndex) {\n  \t\treturn this._intPt[intIndex];\n  \t},\n  \tisEndPoint: function isEndPoint() {\n  \t\treturn this.hasIntersection() && !this._isProper;\n  \t},\n  \thasIntersection: function hasIntersection() {\n  \t\treturn this._result !== LineIntersector.NO_INTERSECTION;\n  \t},\n  \tgetEdgeDistance: function getEdgeDistance(segmentIndex, intIndex) {\n  \t\tvar dist = LineIntersector.computeEdgeDistance(this._intPt[intIndex], this._inputLines[segmentIndex][0], this._inputLines[segmentIndex][1]);\n  \t\treturn dist;\n  \t},\n  \tisCollinear: function isCollinear() {\n  \t\treturn this._result === LineIntersector.COLLINEAR_INTERSECTION;\n  \t},\n  \ttoString: function toString() {\n  \t\treturn WKTWriter.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + \" - \" + WKTWriter.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();\n  \t},\n  \tgetEndpoint: function getEndpoint(segmentIndex, ptIndex) {\n  \t\treturn this._inputLines[segmentIndex][ptIndex];\n  \t},\n  \tisIntersection: function isIntersection(pt) {\n  \t\tfor (var i = 0; i < this._result; i++) {\n  \t\t\tif (this._intPt[i].equals2D(pt)) {\n  \t\t\t\treturn true;\n  \t\t\t}\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tgetIntersectionAlongSegment: function getIntersectionAlongSegment(segmentIndex, intIndex) {\n  \t\tthis.computeIntLineIndex();\n  \t\treturn this._intPt[this._intLineIndex[segmentIndex][intIndex]];\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LineIntersector;\n  \t}\n  });\n  LineIntersector.computeEdgeDistance = function (p, p0, p1) {\n  \tvar dx = Math.abs(p1.x - p0.x);\n  \tvar dy = Math.abs(p1.y - p0.y);\n  \tvar dist = -1.0;\n  \tif (p.equals(p0)) {\n  \t\tdist = 0.0;\n  \t} else if (p.equals(p1)) {\n  \t\tif (dx > dy) dist = dx;else dist = dy;\n  \t} else {\n  \t\tvar pdx = Math.abs(p.x - p0.x);\n  \t\tvar pdy = Math.abs(p.y - p0.y);\n  \t\tif (dx > dy) dist = pdx;else dist = pdy;\n  \t\tif (dist === 0.0 && !p.equals(p0)) {\n  \t\t\tdist = Math.max(pdx, pdy);\n  \t\t}\n  \t}\n  \tAssert.isTrue(!(dist === 0.0 && !p.equals(p0)), \"Bad distance calculation\");\n  \treturn dist;\n  };\n  LineIntersector.nonRobustComputeEdgeDistance = function (p, p1, p2) {\n  \tvar dx = p.x - p1.x;\n  \tvar dy = p.y - p1.y;\n  \tvar dist = Math.sqrt(dx * dx + dy * dy);\n  \tAssert.isTrue(!(dist === 0.0 && !p.equals(p1)), \"Invalid distance calculation\");\n  \treturn dist;\n  };\n  LineIntersector.DONT_INTERSECT = 0;\n  LineIntersector.DO_INTERSECT = 1;\n  LineIntersector.COLLINEAR = 2;\n  LineIntersector.NO_INTERSECTION = 0;\n  LineIntersector.POINT_INTERSECTION = 1;\n  LineIntersector.COLLINEAR_INTERSECTION = 2;\n\n  function RobustLineIntersector() {\n  \tLineIntersector.apply(this);\n  }\n  inherits$1(RobustLineIntersector, LineIntersector);\n  extend(RobustLineIntersector.prototype, {\n  \tisInSegmentEnvelopes: function isInSegmentEnvelopes(intPt) {\n  \t\tvar env0 = new Envelope(this._inputLines[0][0], this._inputLines[0][1]);\n  \t\tvar env1 = new Envelope(this._inputLines[1][0], this._inputLines[1][1]);\n  \t\treturn env0.contains(intPt) && env1.contains(intPt);\n  \t},\n  \tcomputeIntersection: function computeIntersection() {\n  \t\tif (arguments.length === 3) {\n  \t\t\tvar p = arguments[0],\n  \t\t\t    p1 = arguments[1],\n  \t\t\t    p2 = arguments[2];\n  \t\t\tthis._isProper = false;\n  \t\t\tif (Envelope.intersects(p1, p2, p)) {\n  \t\t\t\tif (CGAlgorithms.orientationIndex(p1, p2, p) === 0 && CGAlgorithms.orientationIndex(p2, p1, p) === 0) {\n  \t\t\t\t\tthis._isProper = true;\n  \t\t\t\t\tif (p.equals(p1) || p.equals(p2)) {\n  \t\t\t\t\t\tthis._isProper = false;\n  \t\t\t\t\t}\n  \t\t\t\t\tthis._result = LineIntersector.POINT_INTERSECTION;\n  \t\t\t\t\treturn null;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\tthis._result = LineIntersector.NO_INTERSECTION;\n  \t\t} else return LineIntersector.prototype.computeIntersection.apply(this, arguments);\n  \t},\n  \tnormalizeToMinimum: function normalizeToMinimum(n1, n2, n3, n4, normPt) {\n  \t\tnormPt.x = this.smallestInAbsValue(n1.x, n2.x, n3.x, n4.x);\n  \t\tnormPt.y = this.smallestInAbsValue(n1.y, n2.y, n3.y, n4.y);\n  \t\tn1.x -= normPt.x;\n  \t\tn1.y -= normPt.y;\n  \t\tn2.x -= normPt.x;\n  \t\tn2.y -= normPt.y;\n  \t\tn3.x -= normPt.x;\n  \t\tn3.y -= normPt.y;\n  \t\tn4.x -= normPt.x;\n  \t\tn4.y -= normPt.y;\n  \t},\n  \tsafeHCoordinateIntersection: function safeHCoordinateIntersection(p1, p2, q1, q2) {\n  \t\tvar intPt = null;\n  \t\ttry {\n  \t\t\tintPt = HCoordinate.intersection(p1, p2, q1, q2);\n  \t\t} catch (e) {\n  \t\t\tif (e instanceof NotRepresentableException) {\n  \t\t\t\tintPt = RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2);\n  \t\t\t} else throw e;\n  \t\t} finally {}\n  \t\treturn intPt;\n  \t},\n  \tintersection: function intersection(p1, p2, q1, q2) {\n  \t\tvar intPt = this.intersectionWithNormalization(p1, p2, q1, q2);\n  \t\tif (!this.isInSegmentEnvelopes(intPt)) {\n  \t\t\tintPt = new Coordinate(RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2));\n  \t\t}\n  \t\tif (this._precisionModel !== null) {\n  \t\t\tthis._precisionModel.makePrecise(intPt);\n  \t\t}\n  \t\treturn intPt;\n  \t},\n  \tsmallestInAbsValue: function smallestInAbsValue(x1, x2, x3, x4) {\n  \t\tvar x = x1;\n  \t\tvar xabs = Math.abs(x);\n  \t\tif (Math.abs(x2) < xabs) {\n  \t\t\tx = x2;\n  \t\t\txabs = Math.abs(x2);\n  \t\t}\n  \t\tif (Math.abs(x3) < xabs) {\n  \t\t\tx = x3;\n  \t\t\txabs = Math.abs(x3);\n  \t\t}\n  \t\tif (Math.abs(x4) < xabs) {\n  \t\t\tx = x4;\n  \t\t}\n  \t\treturn x;\n  \t},\n  \tcheckDD: function checkDD(p1, p2, q1, q2, intPt) {\n  \t\tvar intPtDD = CGAlgorithmsDD.intersection(p1, p2, q1, q2);\n  \t\tvar isIn = this.isInSegmentEnvelopes(intPtDD);\n  \t\tSystem.out.println(\"DD in env = \" + isIn + \"  --------------------- \" + intPtDD);\n  \t\tif (intPt.distance(intPtDD) > 0.0001) {\n  \t\t\tSystem.out.println(\"Distance = \" + intPt.distance(intPtDD));\n  \t\t}\n  \t},\n  \tintersectionWithNormalization: function intersectionWithNormalization(p1, p2, q1, q2) {\n  \t\tvar n1 = new Coordinate(p1);\n  \t\tvar n2 = new Coordinate(p2);\n  \t\tvar n3 = new Coordinate(q1);\n  \t\tvar n4 = new Coordinate(q2);\n  \t\tvar normPt = new Coordinate();\n  \t\tthis.normalizeToEnvCentre(n1, n2, n3, n4, normPt);\n  \t\tvar intPt = this.safeHCoordinateIntersection(n1, n2, n3, n4);\n  \t\tintPt.x += normPt.x;\n  \t\tintPt.y += normPt.y;\n  \t\treturn intPt;\n  \t},\n  \tcomputeCollinearIntersection: function computeCollinearIntersection(p1, p2, q1, q2) {\n  \t\tvar p1q1p2 = Envelope.intersects(p1, p2, q1);\n  \t\tvar p1q2p2 = Envelope.intersects(p1, p2, q2);\n  \t\tvar q1p1q2 = Envelope.intersects(q1, q2, p1);\n  \t\tvar q1p2q2 = Envelope.intersects(q1, q2, p2);\n  \t\tif (p1q1p2 && p1q2p2) {\n  \t\t\tthis._intPt[0] = q1;\n  \t\t\tthis._intPt[1] = q2;\n  \t\t\treturn LineIntersector.COLLINEAR_INTERSECTION;\n  \t\t}\n  \t\tif (q1p1q2 && q1p2q2) {\n  \t\t\tthis._intPt[0] = p1;\n  \t\t\tthis._intPt[1] = p2;\n  \t\t\treturn LineIntersector.COLLINEAR_INTERSECTION;\n  \t\t}\n  \t\tif (p1q1p2 && q1p1q2) {\n  \t\t\tthis._intPt[0] = q1;\n  \t\t\tthis._intPt[1] = p1;\n  \t\t\treturn q1.equals(p1) && !p1q2p2 && !q1p2q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n  \t\t}\n  \t\tif (p1q1p2 && q1p2q2) {\n  \t\t\tthis._intPt[0] = q1;\n  \t\t\tthis._intPt[1] = p2;\n  \t\t\treturn q1.equals(p2) && !p1q2p2 && !q1p1q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n  \t\t}\n  \t\tif (p1q2p2 && q1p1q2) {\n  \t\t\tthis._intPt[0] = q2;\n  \t\t\tthis._intPt[1] = p1;\n  \t\t\treturn q2.equals(p1) && !p1q1p2 && !q1p2q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n  \t\t}\n  \t\tif (p1q2p2 && q1p2q2) {\n  \t\t\tthis._intPt[0] = q2;\n  \t\t\tthis._intPt[1] = p2;\n  \t\t\treturn q2.equals(p2) && !p1q1p2 && !q1p1q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n  \t\t}\n  \t\treturn LineIntersector.NO_INTERSECTION;\n  \t},\n  \tnormalizeToEnvCentre: function normalizeToEnvCentre(n00, n01, n10, n11, normPt) {\n  \t\tvar minX0 = n00.x < n01.x ? n00.x : n01.x;\n  \t\tvar minY0 = n00.y < n01.y ? n00.y : n01.y;\n  \t\tvar maxX0 = n00.x > n01.x ? n00.x : n01.x;\n  \t\tvar maxY0 = n00.y > n01.y ? n00.y : n01.y;\n  \t\tvar minX1 = n10.x < n11.x ? n10.x : n11.x;\n  \t\tvar minY1 = n10.y < n11.y ? n10.y : n11.y;\n  \t\tvar maxX1 = n10.x > n11.x ? n10.x : n11.x;\n  \t\tvar maxY1 = n10.y > n11.y ? n10.y : n11.y;\n  \t\tvar intMinX = minX0 > minX1 ? minX0 : minX1;\n  \t\tvar intMaxX = maxX0 < maxX1 ? maxX0 : maxX1;\n  \t\tvar intMinY = minY0 > minY1 ? minY0 : minY1;\n  \t\tvar intMaxY = maxY0 < maxY1 ? maxY0 : maxY1;\n  \t\tvar intMidX = (intMinX + intMaxX) / 2.0;\n  \t\tvar intMidY = (intMinY + intMaxY) / 2.0;\n  \t\tnormPt.x = intMidX;\n  \t\tnormPt.y = intMidY;\n  \t\tn00.x -= normPt.x;\n  \t\tn00.y -= normPt.y;\n  \t\tn01.x -= normPt.x;\n  \t\tn01.y -= normPt.y;\n  \t\tn10.x -= normPt.x;\n  \t\tn10.y -= normPt.y;\n  \t\tn11.x -= normPt.x;\n  \t\tn11.y -= normPt.y;\n  \t},\n  \tcomputeIntersect: function computeIntersect(p1, p2, q1, q2) {\n  \t\tthis._isProper = false;\n  \t\tif (!Envelope.intersects(p1, p2, q1, q2)) return LineIntersector.NO_INTERSECTION;\n  \t\tvar Pq1 = CGAlgorithms.orientationIndex(p1, p2, q1);\n  \t\tvar Pq2 = CGAlgorithms.orientationIndex(p1, p2, q2);\n  \t\tif (Pq1 > 0 && Pq2 > 0 || Pq1 < 0 && Pq2 < 0) {\n  \t\t\treturn LineIntersector.NO_INTERSECTION;\n  \t\t}\n  \t\tvar Qp1 = CGAlgorithms.orientationIndex(q1, q2, p1);\n  \t\tvar Qp2 = CGAlgorithms.orientationIndex(q1, q2, p2);\n  \t\tif (Qp1 > 0 && Qp2 > 0 || Qp1 < 0 && Qp2 < 0) {\n  \t\t\treturn LineIntersector.NO_INTERSECTION;\n  \t\t}\n  \t\tvar collinear = Pq1 === 0 && Pq2 === 0 && Qp1 === 0 && Qp2 === 0;\n  \t\tif (collinear) {\n  \t\t\treturn this.computeCollinearIntersection(p1, p2, q1, q2);\n  \t\t}\n  \t\tif (Pq1 === 0 || Pq2 === 0 || Qp1 === 0 || Qp2 === 0) {\n  \t\t\tthis._isProper = false;\n  \t\t\tif (p1.equals2D(q1) || p1.equals2D(q2)) {\n  \t\t\t\tthis._intPt[0] = p1;\n  \t\t\t} else if (p2.equals2D(q1) || p2.equals2D(q2)) {\n  \t\t\t\tthis._intPt[0] = p2;\n  \t\t\t} else if (Pq1 === 0) {\n  \t\t\t\tthis._intPt[0] = new Coordinate(q1);\n  \t\t\t} else if (Pq2 === 0) {\n  \t\t\t\tthis._intPt[0] = new Coordinate(q2);\n  \t\t\t} else if (Qp1 === 0) {\n  \t\t\t\tthis._intPt[0] = new Coordinate(p1);\n  \t\t\t} else if (Qp2 === 0) {\n  \t\t\t\tthis._intPt[0] = new Coordinate(p2);\n  \t\t\t}\n  \t\t} else {\n  \t\t\tthis._isProper = true;\n  \t\t\tthis._intPt[0] = this.intersection(p1, p2, q1, q2);\n  \t\t}\n  \t\treturn LineIntersector.POINT_INTERSECTION;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn RobustLineIntersector;\n  \t}\n  });\n  RobustLineIntersector.nearestEndpoint = function (p1, p2, q1, q2) {\n  \tvar nearestPt = p1;\n  \tvar minDist = CGAlgorithms.distancePointLine(p1, q1, q2);\n  \tvar dist = CGAlgorithms.distancePointLine(p2, q1, q2);\n  \tif (dist < minDist) {\n  \t\tminDist = dist;\n  \t\tnearestPt = p2;\n  \t}\n  \tdist = CGAlgorithms.distancePointLine(q1, p1, p2);\n  \tif (dist < minDist) {\n  \t\tminDist = dist;\n  \t\tnearestPt = q1;\n  \t}\n  \tdist = CGAlgorithms.distancePointLine(q2, p1, p2);\n  \tif (dist < minDist) {\n  \t\tminDist = dist;\n  \t\tnearestPt = q2;\n  \t}\n  \treturn nearestPt;\n  };\n\n  function RobustDeterminant() {}\n  extend(RobustDeterminant.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn RobustDeterminant;\n  \t}\n  });\n  RobustDeterminant.orientationIndex = function (p1, p2, q) {\n  \tvar dx1 = p2.x - p1.x;\n  \tvar dy1 = p2.y - p1.y;\n  \tvar dx2 = q.x - p2.x;\n  \tvar dy2 = q.y - p2.y;\n  \treturn RobustDeterminant.signOfDet2x2(dx1, dy1, dx2, dy2);\n  };\n  RobustDeterminant.signOfDet2x2 = function (x1, y1, x2, y2) {\n  \tvar sign = null;\n  \tvar swap = null;\n  \tvar k = null;\n  \tsign = 1;\n  \tif (x1 === 0.0 || y2 === 0.0) {\n  \t\tif (y1 === 0.0 || x2 === 0.0) {\n  \t\t\treturn 0;\n  \t\t} else if (y1 > 0) {\n  \t\t\tif (x2 > 0) {\n  \t\t\t\treturn -sign;\n  \t\t\t} else {\n  \t\t\t\treturn sign;\n  \t\t\t}\n  \t\t} else {\n  \t\t\tif (x2 > 0) {\n  \t\t\t\treturn sign;\n  \t\t\t} else {\n  \t\t\t\treturn -sign;\n  \t\t\t}\n  \t\t}\n  \t}\n  \tif (y1 === 0.0 || x2 === 0.0) {\n  \t\tif (y2 > 0) {\n  \t\t\tif (x1 > 0) {\n  \t\t\t\treturn sign;\n  \t\t\t} else {\n  \t\t\t\treturn -sign;\n  \t\t\t}\n  \t\t} else {\n  \t\t\tif (x1 > 0) {\n  \t\t\t\treturn -sign;\n  \t\t\t} else {\n  \t\t\t\treturn sign;\n  \t\t\t}\n  \t\t}\n  \t}\n  \tif (0.0 < y1) {\n  \t\tif (0.0 < y2) {\n  \t\t\tif (y1 <= y2) ; else {\n  \t\t\t\tsign = -sign;\n  \t\t\t\tswap = x1;\n  \t\t\t\tx1 = x2;\n  \t\t\t\tx2 = swap;\n  \t\t\t\tswap = y1;\n  \t\t\t\ty1 = y2;\n  \t\t\t\ty2 = swap;\n  \t\t\t}\n  \t\t} else {\n  \t\t\tif (y1 <= -y2) {\n  \t\t\t\tsign = -sign;\n  \t\t\t\tx2 = -x2;\n  \t\t\t\ty2 = -y2;\n  \t\t\t} else {\n  \t\t\t\tswap = x1;\n  \t\t\t\tx1 = -x2;\n  \t\t\t\tx2 = swap;\n  \t\t\t\tswap = y1;\n  \t\t\t\ty1 = -y2;\n  \t\t\t\ty2 = swap;\n  \t\t\t}\n  \t\t}\n  \t} else {\n  \t\tif (0.0 < y2) {\n  \t\t\tif (-y1 <= y2) {\n  \t\t\t\tsign = -sign;\n  \t\t\t\tx1 = -x1;\n  \t\t\t\ty1 = -y1;\n  \t\t\t} else {\n  \t\t\t\tswap = -x1;\n  \t\t\t\tx1 = x2;\n  \t\t\t\tx2 = swap;\n  \t\t\t\tswap = -y1;\n  \t\t\t\ty1 = y2;\n  \t\t\t\ty2 = swap;\n  \t\t\t}\n  \t\t} else {\n  \t\t\tif (y1 >= y2) {\n  \t\t\t\tx1 = -x1;\n  \t\t\t\ty1 = -y1;\n  \t\t\t\tx2 = -x2;\n  \t\t\t\ty2 = -y2;\n  \t\t\t} else {\n  \t\t\t\tsign = -sign;\n  \t\t\t\tswap = -x1;\n  \t\t\t\tx1 = -x2;\n  \t\t\t\tx2 = swap;\n  \t\t\t\tswap = -y1;\n  \t\t\t\ty1 = -y2;\n  \t\t\t\ty2 = swap;\n  \t\t\t}\n  \t\t}\n  \t}\n  \tif (0.0 < x1) {\n  \t\tif (0.0 < x2) {\n  \t\t\tif (x1 <= x2) ; else {\n  \t\t\t\treturn sign;\n  \t\t\t}\n  \t\t} else {\n  \t\t\treturn sign;\n  \t\t}\n  \t} else {\n  \t\tif (0.0 < x2) {\n  \t\t\treturn -sign;\n  \t\t} else {\n  \t\t\tif (x1 >= x2) {\n  \t\t\t\tsign = -sign;\n  \t\t\t\tx1 = -x1;\n  \t\t\t\tx2 = -x2;\n  \t\t\t} else {\n  \t\t\t\treturn -sign;\n  \t\t\t}\n  \t\t}\n  \t}\n  \twhile (true) {\n  \t\tk = Math.floor(x2 / x1);\n  \t\tx2 = x2 - k * x1;\n  \t\ty2 = y2 - k * y1;\n  \t\tif (y2 < 0.0) {\n  \t\t\treturn -sign;\n  \t\t}\n  \t\tif (y2 > y1) {\n  \t\t\treturn sign;\n  \t\t}\n  \t\tif (x1 > x2 + x2) {\n  \t\t\tif (y1 < y2 + y2) {\n  \t\t\t\treturn sign;\n  \t\t\t}\n  \t\t} else {\n  \t\t\tif (y1 > y2 + y2) {\n  \t\t\t\treturn -sign;\n  \t\t\t} else {\n  \t\t\t\tx2 = x1 - x2;\n  \t\t\t\ty2 = y1 - y2;\n  \t\t\t\tsign = -sign;\n  \t\t\t}\n  \t\t}\n  \t\tif (y2 === 0.0) {\n  \t\t\tif (x2 === 0.0) {\n  \t\t\t\treturn 0;\n  \t\t\t} else {\n  \t\t\t\treturn -sign;\n  \t\t\t}\n  \t\t}\n  \t\tif (x2 === 0.0) {\n  \t\t\treturn sign;\n  \t\t}\n  \t\tk = Math.floor(x1 / x2);\n  \t\tx1 = x1 - k * x2;\n  \t\ty1 = y1 - k * y2;\n  \t\tif (y1 < 0.0) {\n  \t\t\treturn sign;\n  \t\t}\n  \t\tif (y1 > y2) {\n  \t\t\treturn -sign;\n  \t\t}\n  \t\tif (x2 > x1 + x1) {\n  \t\t\tif (y2 < y1 + y1) {\n  \t\t\t\treturn -sign;\n  \t\t\t}\n  \t\t} else {\n  \t\t\tif (y2 > y1 + y1) {\n  \t\t\t\treturn sign;\n  \t\t\t} else {\n  \t\t\t\tx1 = x2 - x1;\n  \t\t\t\ty1 = y2 - y1;\n  \t\t\t\tsign = -sign;\n  \t\t\t}\n  \t\t}\n  \t\tif (y1 === 0.0) {\n  \t\t\tif (x1 === 0.0) {\n  \t\t\t\treturn 0;\n  \t\t\t} else {\n  \t\t\t\treturn sign;\n  \t\t\t}\n  \t\t}\n  \t\tif (x1 === 0.0) {\n  \t\t\treturn -sign;\n  \t\t}\n  \t}\n  };\n\n  function RayCrossingCounter() {\n  \tthis._p = null;\n  \tthis._crossingCount = 0;\n  \tthis._isPointOnSegment = false;\n  \tvar p = arguments[0];\n  \tthis._p = p;\n  }\n  extend(RayCrossingCounter.prototype, {\n  \tcountSegment: function countSegment(p1, p2) {\n  \t\tif (p1.x < this._p.x && p2.x < this._p.x) return null;\n  \t\tif (this._p.x === p2.x && this._p.y === p2.y) {\n  \t\t\tthis._isPointOnSegment = true;\n  \t\t\treturn null;\n  \t\t}\n  \t\tif (p1.y === this._p.y && p2.y === this._p.y) {\n  \t\t\tvar minx = p1.x;\n  \t\t\tvar maxx = p2.x;\n  \t\t\tif (minx > maxx) {\n  \t\t\t\tminx = p2.x;\n  \t\t\t\tmaxx = p1.x;\n  \t\t\t}\n  \t\t\tif (this._p.x >= minx && this._p.x <= maxx) {\n  \t\t\t\tthis._isPointOnSegment = true;\n  \t\t\t}\n  \t\t\treturn null;\n  \t\t}\n  \t\tif (p1.y > this._p.y && p2.y <= this._p.y || p2.y > this._p.y && p1.y <= this._p.y) {\n  \t\t\tvar x1 = p1.x - this._p.x;\n  \t\t\tvar y1 = p1.y - this._p.y;\n  \t\t\tvar x2 = p2.x - this._p.x;\n  \t\t\tvar y2 = p2.y - this._p.y;\n  \t\t\tvar xIntSign = RobustDeterminant.signOfDet2x2(x1, y1, x2, y2);\n  \t\t\tif (xIntSign === 0.0) {\n  \t\t\t\tthis._isPointOnSegment = true;\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t\tif (y2 < y1) xIntSign = -xIntSign;\n  \t\t\tif (xIntSign > 0.0) {\n  \t\t\t\tthis._crossingCount++;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tisPointInPolygon: function isPointInPolygon() {\n  \t\treturn this.getLocation() !== Location.EXTERIOR;\n  \t},\n  \tgetLocation: function getLocation() {\n  \t\tif (this._isPointOnSegment) return Location.BOUNDARY;\n  \t\tif (this._crossingCount % 2 === 1) {\n  \t\t\treturn Location.INTERIOR;\n  \t\t}\n  \t\treturn Location.EXTERIOR;\n  \t},\n  \tisOnSegment: function isOnSegment() {\n  \t\treturn this._isPointOnSegment;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn RayCrossingCounter;\n  \t}\n  });\n  RayCrossingCounter.locatePointInRing = function () {\n  \tif (arguments[0] instanceof Coordinate && hasInterface(arguments[1], CoordinateSequence)) {\n  \t\tvar p = arguments[0],\n  \t\t    ring = arguments[1];\n  \t\tvar counter = new RayCrossingCounter(p);\n  \t\tvar p1 = new Coordinate();\n  \t\tvar p2 = new Coordinate();\n  \t\tfor (var i = 1; i < ring.size(); i++) {\n  \t\t\tring.getCoordinate(i, p1);\n  \t\t\tring.getCoordinate(i - 1, p2);\n  \t\t\tcounter.countSegment(p1, p2);\n  \t\t\tif (counter.isOnSegment()) return counter.getLocation();\n  \t\t}\n  \t\treturn counter.getLocation();\n  \t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Array) {\n  \t\tvar p = arguments[0],\n  \t\t    ring = arguments[1];\n  \t\tvar counter = new RayCrossingCounter(p);\n  \t\tfor (var i = 1; i < ring.length; i++) {\n  \t\t\tvar p1 = ring[i];\n  \t\t\tvar p2 = ring[i - 1];\n  \t\t\tcounter.countSegment(p1, p2);\n  \t\t\tif (counter.isOnSegment()) return counter.getLocation();\n  \t\t}\n  \t\treturn counter.getLocation();\n  \t}\n  };\n\n  function CGAlgorithms() {}\n  extend(CGAlgorithms.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn CGAlgorithms;\n  \t}\n  });\n  CGAlgorithms.orientationIndex = function (p1, p2, q) {\n  \treturn CGAlgorithmsDD.orientationIndex(p1, p2, q);\n  };\n  CGAlgorithms.signedArea = function () {\n  \tif (arguments[0] instanceof Array) {\n  \t\tvar ring = arguments[0];\n  \t\tif (ring.length < 3) return 0.0;\n  \t\tvar sum = 0.0;\n  \t\tvar x0 = ring[0].x;\n  \t\tfor (var i = 1; i < ring.length - 1; i++) {\n  \t\t\tvar x = ring[i].x - x0;\n  \t\t\tvar y1 = ring[i + 1].y;\n  \t\t\tvar y2 = ring[i - 1].y;\n  \t\t\tsum += x * (y2 - y1);\n  \t\t}\n  \t\treturn sum / 2.0;\n  \t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n  \t\tvar ring = arguments[0];\n  \t\tvar n = ring.size();\n  \t\tif (n < 3) return 0.0;\n  \t\tvar p0 = new Coordinate();\n  \t\tvar p1 = new Coordinate();\n  \t\tvar p2 = new Coordinate();\n  \t\tring.getCoordinate(0, p1);\n  \t\tring.getCoordinate(1, p2);\n  \t\tvar x0 = p1.x;\n  \t\tp2.x -= x0;\n  \t\tvar sum = 0.0;\n  \t\tfor (var i = 1; i < n - 1; i++) {\n  \t\t\tp0.y = p1.y;\n  \t\t\tp1.x = p2.x;\n  \t\t\tp1.y = p2.y;\n  \t\t\tring.getCoordinate(i + 1, p2);\n  \t\t\tp2.x -= x0;\n  \t\t\tsum += p1.x * (p0.y - p2.y);\n  \t\t}\n  \t\treturn sum / 2.0;\n  \t}\n  };\n  CGAlgorithms.distanceLineLine = function (A, B, C, D) {\n  \tif (A.equals(B)) return CGAlgorithms.distancePointLine(A, C, D);\n  \tif (C.equals(D)) return CGAlgorithms.distancePointLine(D, A, B);\n  \tvar noIntersection = false;\n  \tif (!Envelope.intersects(A, B, C, D)) {\n  \t\tnoIntersection = true;\n  \t} else {\n  \t\tvar denom = (B.x - A.x) * (D.y - C.y) - (B.y - A.y) * (D.x - C.x);\n  \t\tif (denom === 0) {\n  \t\t\tnoIntersection = true;\n  \t\t} else {\n  \t\t\tvar r_num = (A.y - C.y) * (D.x - C.x) - (A.x - C.x) * (D.y - C.y);\n  \t\t\tvar s_num = (A.y - C.y) * (B.x - A.x) - (A.x - C.x) * (B.y - A.y);\n  \t\t\tvar s = s_num / denom;\n  \t\t\tvar r = r_num / denom;\n  \t\t\tif (r < 0 || r > 1 || s < 0 || s > 1) {\n  \t\t\t\tnoIntersection = true;\n  \t\t\t}\n  \t\t}\n  \t}\n  \tif (noIntersection) {\n  \t\treturn MathUtil.min(CGAlgorithms.distancePointLine(A, C, D), CGAlgorithms.distancePointLine(B, C, D), CGAlgorithms.distancePointLine(C, A, B), CGAlgorithms.distancePointLine(D, A, B));\n  \t}\n  \treturn 0.0;\n  };\n  CGAlgorithms.isPointInRing = function (p, ring) {\n  \treturn CGAlgorithms.locatePointInRing(p, ring) !== Location.EXTERIOR;\n  };\n  CGAlgorithms.computeLength = function (pts) {\n  \tvar n = pts.size();\n  \tif (n <= 1) return 0.0;\n  \tvar len = 0.0;\n  \tvar p = new Coordinate();\n  \tpts.getCoordinate(0, p);\n  \tvar x0 = p.x;\n  \tvar y0 = p.y;\n  \tfor (var i = 1; i < n; i++) {\n  \t\tpts.getCoordinate(i, p);\n  \t\tvar x1 = p.x;\n  \t\tvar y1 = p.y;\n  \t\tvar dx = x1 - x0;\n  \t\tvar dy = y1 - y0;\n  \t\tlen += Math.sqrt(dx * dx + dy * dy);\n  \t\tx0 = x1;\n  \t\ty0 = y1;\n  \t}\n  \treturn len;\n  };\n  CGAlgorithms.isCCW = function (ring) {\n  \tvar nPts = ring.length - 1;\n  \tif (nPts < 3) throw new IllegalArgumentException(\"Ring has fewer than 4 points, so orientation cannot be determined\");\n  \tvar hiPt = ring[0];\n  \tvar hiIndex = 0;\n  \tfor (var i = 1; i <= nPts; i++) {\n  \t\tvar p = ring[i];\n  \t\tif (p.y > hiPt.y) {\n  \t\t\thiPt = p;\n  \t\t\thiIndex = i;\n  \t\t}\n  \t}\n  \tvar iPrev = hiIndex;\n  \tdo {\n  \t\tiPrev = iPrev - 1;\n  \t\tif (iPrev < 0) iPrev = nPts;\n  \t} while (ring[iPrev].equals2D(hiPt) && iPrev !== hiIndex);\n  \tvar iNext = hiIndex;\n  \tdo {\n  \t\tiNext = (iNext + 1) % nPts;\n  \t} while (ring[iNext].equals2D(hiPt) && iNext !== hiIndex);\n  \tvar prev = ring[iPrev];\n  \tvar next = ring[iNext];\n  \tif (prev.equals2D(hiPt) || next.equals2D(hiPt) || prev.equals2D(next)) return false;\n  \tvar disc = CGAlgorithms.computeOrientation(prev, hiPt, next);\n  \tvar isCCW = false;\n  \tif (disc === 0) {\n  \t\tisCCW = prev.x > next.x;\n  \t} else {\n  \t\tisCCW = disc > 0;\n  \t}\n  \treturn isCCW;\n  };\n  CGAlgorithms.locatePointInRing = function (p, ring) {\n  \treturn RayCrossingCounter.locatePointInRing(p, ring);\n  };\n  CGAlgorithms.distancePointLinePerpendicular = function (p, A, B) {\n  \tvar len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);\n  \tvar s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;\n  \treturn Math.abs(s) * Math.sqrt(len2);\n  };\n  CGAlgorithms.computeOrientation = function (p1, p2, q) {\n  \treturn CGAlgorithms.orientationIndex(p1, p2, q);\n  };\n  CGAlgorithms.distancePointLine = function () {\n  \tif (arguments.length === 2) {\n  \t\tvar p = arguments[0],\n  \t\t    line = arguments[1];\n  \t\tif (line.length === 0) throw new IllegalArgumentException(\"Line array must contain at least one vertex\");\n  \t\tvar minDistance = p.distance(line[0]);\n  \t\tfor (var i = 0; i < line.length - 1; i++) {\n  \t\t\tvar dist = CGAlgorithms.distancePointLine(p, line[i], line[i + 1]);\n  \t\t\tif (dist < minDistance) {\n  \t\t\t\tminDistance = dist;\n  \t\t\t}\n  \t\t}\n  \t\treturn minDistance;\n  \t} else if (arguments.length === 3) {\n  \t\tvar p = arguments[0],\n  \t\t    A = arguments[1],\n  \t\t    B = arguments[2];\n  \t\tif (A.x === B.x && A.y === B.y) return p.distance(A);\n  \t\tvar len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);\n  \t\tvar r = ((p.x - A.x) * (B.x - A.x) + (p.y - A.y) * (B.y - A.y)) / len2;\n  \t\tif (r <= 0.0) return p.distance(A);\n  \t\tif (r >= 1.0) return p.distance(B);\n  \t\tvar s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;\n  \t\treturn Math.abs(s) * Math.sqrt(len2);\n  \t}\n  };\n  CGAlgorithms.isOnLine = function (p, pt) {\n  \tvar lineIntersector = new RobustLineIntersector();\n  \tfor (var i = 1; i < pt.length; i++) {\n  \t\tvar p0 = pt[i - 1];\n  \t\tvar p1 = pt[i];\n  \t\tlineIntersector.computeIntersection(p, p0, p1);\n  \t\tif (lineIntersector.hasIntersection()) {\n  \t\t\treturn true;\n  \t\t}\n  \t}\n  \treturn false;\n  };\n  CGAlgorithms.CLOCKWISE = -1;\n  CGAlgorithms.RIGHT = CGAlgorithms.CLOCKWISE;\n  CGAlgorithms.COUNTERCLOCKWISE = 1;\n  CGAlgorithms.LEFT = CGAlgorithms.COUNTERCLOCKWISE;\n  CGAlgorithms.COLLINEAR = 0;\n  CGAlgorithms.STRAIGHT = CGAlgorithms.COLLINEAR;\n\n  function LineSegment() {\n  \tthis.p0 = null;\n  \tthis.p1 = null;\n  \tif (arguments.length === 0) {\n  \t\tLineSegment.call(this, new Coordinate(), new Coordinate());\n  \t} else if (arguments.length === 1) {\n  \t\tvar ls = arguments[0];\n  \t\tLineSegment.call(this, ls.p0, ls.p1);\n  \t} else if (arguments.length === 2) {\n  \t\tvar p0 = arguments[0],\n  \t\t    p1 = arguments[1];\n  \t\tthis.p0 = p0;\n  \t\tthis.p1 = p1;\n  \t} else if (arguments.length === 4) {\n  \t\tvar x0 = arguments[0],\n  \t\t    y0 = arguments[1],\n  \t\t    x1 = arguments[2],\n  \t\t    y1 = arguments[3];\n  \t\tLineSegment.call(this, new Coordinate(x0, y0), new Coordinate(x1, y1));\n  \t}\n  }\n  extend(LineSegment.prototype, {\n  \tminX: function minX() {\n  \t\treturn Math.min(this.p0.x, this.p1.x);\n  \t},\n  \torientationIndex: function orientationIndex() {\n  \t\tif (arguments[0] instanceof LineSegment) {\n  \t\t\tvar seg = arguments[0];\n  \t\t\tvar orient0 = CGAlgorithms.orientationIndex(this.p0, this.p1, seg.p0);\n  \t\t\tvar orient1 = CGAlgorithms.orientationIndex(this.p0, this.p1, seg.p1);\n  \t\t\tif (orient0 >= 0 && orient1 >= 0) return Math.max(orient0, orient1);\n  \t\t\tif (orient0 <= 0 && orient1 <= 0) return Math.max(orient0, orient1);\n  \t\t\treturn 0;\n  \t\t} else if (arguments[0] instanceof Coordinate) {\n  \t\t\tvar p = arguments[0];\n  \t\t\treturn CGAlgorithms.orientationIndex(this.p0, this.p1, p);\n  \t\t}\n  \t},\n  \ttoGeometry: function toGeometry(geomFactory) {\n  \t\treturn geomFactory.createLineString([this.p0, this.p1]);\n  \t},\n  \tisVertical: function isVertical() {\n  \t\treturn this.p0.x === this.p1.x;\n  \t},\n  \tequals: function equals(o) {\n  \t\tif (!(o instanceof LineSegment)) {\n  \t\t\treturn false;\n  \t\t}\n  \t\tvar other = o;\n  \t\treturn this.p0.equals(other.p0) && this.p1.equals(other.p1);\n  \t},\n  \tintersection: function intersection(line) {\n  \t\tvar li = new RobustLineIntersector();\n  \t\tli.computeIntersection(this.p0, this.p1, line.p0, line.p1);\n  \t\tif (li.hasIntersection()) return li.getIntersection(0);\n  \t\treturn null;\n  \t},\n  \tproject: function project() {\n  \t\tif (arguments[0] instanceof Coordinate) {\n  \t\t\tvar p = arguments[0];\n  \t\t\tif (p.equals(this.p0) || p.equals(this.p1)) return new Coordinate(p);\n  \t\t\tvar r = this.projectionFactor(p);\n  \t\t\tvar coord = new Coordinate();\n  \t\t\tcoord.x = this.p0.x + r * (this.p1.x - this.p0.x);\n  \t\t\tcoord.y = this.p0.y + r * (this.p1.y - this.p0.y);\n  \t\t\treturn coord;\n  \t\t} else if (arguments[0] instanceof LineSegment) {\n  \t\t\tvar seg = arguments[0];\n  \t\t\tvar pf0 = this.projectionFactor(seg.p0);\n  \t\t\tvar pf1 = this.projectionFactor(seg.p1);\n  \t\t\tif (pf0 >= 1.0 && pf1 >= 1.0) return null;\n  \t\t\tif (pf0 <= 0.0 && pf1 <= 0.0) return null;\n  \t\t\tvar newp0 = this.project(seg.p0);\n  \t\t\tif (pf0 < 0.0) newp0 = this.p0;\n  \t\t\tif (pf0 > 1.0) newp0 = this.p1;\n  \t\t\tvar newp1 = this.project(seg.p1);\n  \t\t\tif (pf1 < 0.0) newp1 = this.p0;\n  \t\t\tif (pf1 > 1.0) newp1 = this.p1;\n  \t\t\treturn new LineSegment(newp0, newp1);\n  \t\t}\n  \t},\n  \tnormalize: function normalize() {\n  \t\tif (this.p1.compareTo(this.p0) < 0) this.reverse();\n  \t},\n  \tangle: function angle() {\n  \t\treturn Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);\n  \t},\n  \tgetCoordinate: function getCoordinate(i) {\n  \t\tif (i === 0) return this.p0;\n  \t\treturn this.p1;\n  \t},\n  \tdistancePerpendicular: function distancePerpendicular(p) {\n  \t\treturn CGAlgorithms.distancePointLinePerpendicular(p, this.p0, this.p1);\n  \t},\n  \tminY: function minY() {\n  \t\treturn Math.min(this.p0.y, this.p1.y);\n  \t},\n  \tmidPoint: function midPoint() {\n  \t\treturn LineSegment.midPoint(this.p0, this.p1);\n  \t},\n  \tprojectionFactor: function projectionFactor(p) {\n  \t\tif (p.equals(this.p0)) return 0.0;\n  \t\tif (p.equals(this.p1)) return 1.0;\n  \t\tvar dx = this.p1.x - this.p0.x;\n  \t\tvar dy = this.p1.y - this.p0.y;\n  \t\tvar len = dx * dx + dy * dy;\n  \t\tif (len <= 0.0) return Double.NaN;\n  \t\tvar r = ((p.x - this.p0.x) * dx + (p.y - this.p0.y) * dy) / len;\n  \t\treturn r;\n  \t},\n  \tclosestPoints: function closestPoints(line) {\n  \t\tvar intPt = this.intersection(line);\n  \t\tif (intPt !== null) {\n  \t\t\treturn [intPt, intPt];\n  \t\t}\n  \t\tvar closestPt = new Array(2).fill(null);\n  \t\tvar minDistance = Double.MAX_VALUE;\n  \t\tvar dist = null;\n  \t\tvar close00 = this.closestPoint(line.p0);\n  \t\tminDistance = close00.distance(line.p0);\n  \t\tclosestPt[0] = close00;\n  \t\tclosestPt[1] = line.p0;\n  \t\tvar close01 = this.closestPoint(line.p1);\n  \t\tdist = close01.distance(line.p1);\n  \t\tif (dist < minDistance) {\n  \t\t\tminDistance = dist;\n  \t\t\tclosestPt[0] = close01;\n  \t\t\tclosestPt[1] = line.p1;\n  \t\t}\n  \t\tvar close10 = line.closestPoint(this.p0);\n  \t\tdist = close10.distance(this.p0);\n  \t\tif (dist < minDistance) {\n  \t\t\tminDistance = dist;\n  \t\t\tclosestPt[0] = this.p0;\n  \t\t\tclosestPt[1] = close10;\n  \t\t}\n  \t\tvar close11 = line.closestPoint(this.p1);\n  \t\tdist = close11.distance(this.p1);\n  \t\tif (dist < minDistance) {\n  \t\t\tminDistance = dist;\n  \t\t\tclosestPt[0] = this.p1;\n  \t\t\tclosestPt[1] = close11;\n  \t\t}\n  \t\treturn closestPt;\n  \t},\n  \tclosestPoint: function closestPoint(p) {\n  \t\tvar factor = this.projectionFactor(p);\n  \t\tif (factor > 0 && factor < 1) {\n  \t\t\treturn this.project(p);\n  \t\t}\n  \t\tvar dist0 = this.p0.distance(p);\n  \t\tvar dist1 = this.p1.distance(p);\n  \t\tif (dist0 < dist1) return this.p0;\n  \t\treturn this.p1;\n  \t},\n  \tmaxX: function maxX() {\n  \t\treturn Math.max(this.p0.x, this.p1.x);\n  \t},\n  \tgetLength: function getLength() {\n  \t\treturn this.p0.distance(this.p1);\n  \t},\n  \tcompareTo: function compareTo(o) {\n  \t\tvar other = o;\n  \t\tvar comp0 = this.p0.compareTo(other.p0);\n  \t\tif (comp0 !== 0) return comp0;\n  \t\treturn this.p1.compareTo(other.p1);\n  \t},\n  \treverse: function reverse() {\n  \t\tvar temp = this.p0;\n  \t\tthis.p0 = this.p1;\n  \t\tthis.p1 = temp;\n  \t},\n  \tequalsTopo: function equalsTopo(other) {\n  \t\treturn this.p0.equals(other.p0) && this.p1.equals(other.p1) || this.p0.equals(other.p1) && this.p1.equals(other.p0);\n  \t},\n  \tlineIntersection: function lineIntersection(line) {\n  \t\ttry {\n  \t\t\tvar intPt = HCoordinate.intersection(this.p0, this.p1, line.p0, line.p1);\n  \t\t\treturn intPt;\n  \t\t} catch (ex) {\n  \t\t\tif (ex instanceof NotRepresentableException) ; else throw ex;\n  \t\t} finally {}\n  \t\treturn null;\n  \t},\n  \tmaxY: function maxY() {\n  \t\treturn Math.max(this.p0.y, this.p1.y);\n  \t},\n  \tpointAlongOffset: function pointAlongOffset(segmentLengthFraction, offsetDistance) {\n  \t\tvar segx = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);\n  \t\tvar segy = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);\n  \t\tvar dx = this.p1.x - this.p0.x;\n  \t\tvar dy = this.p1.y - this.p0.y;\n  \t\tvar len = Math.sqrt(dx * dx + dy * dy);\n  \t\tvar ux = 0.0;\n  \t\tvar uy = 0.0;\n  \t\tif (offsetDistance !== 0.0) {\n  \t\t\tif (len <= 0.0) throw new IllegalStateException(\"Cannot compute offset from zero-length line segment\");\n  \t\t\tux = offsetDistance * dx / len;\n  \t\t\tuy = offsetDistance * dy / len;\n  \t\t}\n  \t\tvar offsetx = segx - uy;\n  \t\tvar offsety = segy + ux;\n  \t\tvar coord = new Coordinate(offsetx, offsety);\n  \t\treturn coord;\n  \t},\n  \tsetCoordinates: function setCoordinates() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar ls = arguments[0];\n  \t\t\tthis.setCoordinates(ls.p0, ls.p1);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar p0 = arguments[0],\n  \t\t\t    p1 = arguments[1];\n  \t\t\tthis.p0.x = p0.x;\n  \t\t\tthis.p0.y = p0.y;\n  \t\t\tthis.p1.x = p1.x;\n  \t\t\tthis.p1.y = p1.y;\n  \t\t}\n  \t},\n  \tsegmentFraction: function segmentFraction(inputPt) {\n  \t\tvar segFrac = this.projectionFactor(inputPt);\n  \t\tif (segFrac < 0.0) segFrac = 0.0;else if (segFrac > 1.0 || Double.isNaN(segFrac)) segFrac = 1.0;\n  \t\treturn segFrac;\n  \t},\n  \ttoString: function toString() {\n  \t\treturn \"LINESTRING( \" + this.p0.x + \" \" + this.p0.y + \", \" + this.p1.x + \" \" + this.p1.y + \")\";\n  \t},\n  \tisHorizontal: function isHorizontal() {\n  \t\treturn this.p0.y === this.p1.y;\n  \t},\n  \tdistance: function distance() {\n  \t\tif (arguments[0] instanceof LineSegment) {\n  \t\t\tvar ls = arguments[0];\n  \t\t\treturn CGAlgorithms.distanceLineLine(this.p0, this.p1, ls.p0, ls.p1);\n  \t\t} else if (arguments[0] instanceof Coordinate) {\n  \t\t\tvar p = arguments[0];\n  \t\t\treturn CGAlgorithms.distancePointLine(p, this.p0, this.p1);\n  \t\t}\n  \t},\n  \tpointAlong: function pointAlong(segmentLengthFraction) {\n  \t\tvar coord = new Coordinate();\n  \t\tcoord.x = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);\n  \t\tcoord.y = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);\n  \t\treturn coord;\n  \t},\n  \thashCode: function hashCode() {\n  \t\tvar bits0 = java.lang.Double.doubleToLongBits(this.p0.x);\n  \t\tbits0 ^= java.lang.Double.doubleToLongBits(this.p0.y) * 31;\n  \t\tvar hash0 = Math.trunc(bits0) ^ Math.trunc(bits0 >> 32);\n  \t\tvar bits1 = java.lang.Double.doubleToLongBits(this.p1.x);\n  \t\tbits1 ^= java.lang.Double.doubleToLongBits(this.p1.y) * 31;\n  \t\tvar hash1 = Math.trunc(bits1) ^ Math.trunc(bits1 >> 32);\n  \t\treturn hash0 ^ hash1;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparable, Serializable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LineSegment;\n  \t}\n  });\n  LineSegment.midPoint = function (p0, p1) {\n  \treturn new Coordinate((p0.x + p1.x) / 2, (p0.y + p1.y) / 2);\n  };\n  LineSegment.serialVersionUID = 3252005833466256227;\n\n  function IntersectionMatrix() {\n  \tthis._matrix = null;\n  \tif (arguments.length === 0) {\n  \t\tthis._matrix = Array(3).fill().map(function () {\n  \t\t\treturn Array(3);\n  \t\t});\n  \t\tthis.setAll(Dimension.FALSE);\n  \t} else if (arguments.length === 1) {\n  \t\tif (typeof arguments[0] === \"string\") {\n  \t\t\tvar elements = arguments[0];\n  \t\t\tIntersectionMatrix.call(this);\n  \t\t\tthis.set(elements);\n  \t\t} else if (arguments[0] instanceof IntersectionMatrix) {\n  \t\t\tvar other = arguments[0];\n  \t\t\tIntersectionMatrix.call(this);\n  \t\t\tthis._matrix[Location.INTERIOR][Location.INTERIOR] = other._matrix[Location.INTERIOR][Location.INTERIOR];\n  \t\t\tthis._matrix[Location.INTERIOR][Location.BOUNDARY] = other._matrix[Location.INTERIOR][Location.BOUNDARY];\n  \t\t\tthis._matrix[Location.INTERIOR][Location.EXTERIOR] = other._matrix[Location.INTERIOR][Location.EXTERIOR];\n  \t\t\tthis._matrix[Location.BOUNDARY][Location.INTERIOR] = other._matrix[Location.BOUNDARY][Location.INTERIOR];\n  \t\t\tthis._matrix[Location.BOUNDARY][Location.BOUNDARY] = other._matrix[Location.BOUNDARY][Location.BOUNDARY];\n  \t\t\tthis._matrix[Location.BOUNDARY][Location.EXTERIOR] = other._matrix[Location.BOUNDARY][Location.EXTERIOR];\n  \t\t\tthis._matrix[Location.EXTERIOR][Location.INTERIOR] = other._matrix[Location.EXTERIOR][Location.INTERIOR];\n  \t\t\tthis._matrix[Location.EXTERIOR][Location.BOUNDARY] = other._matrix[Location.EXTERIOR][Location.BOUNDARY];\n  \t\t\tthis._matrix[Location.EXTERIOR][Location.EXTERIOR] = other._matrix[Location.EXTERIOR][Location.EXTERIOR];\n  \t\t}\n  \t}\n  }\n  extend(IntersectionMatrix.prototype, {\n  \tisIntersects: function isIntersects() {\n  \t\treturn !this.isDisjoint();\n  \t},\n  \tisCovers: function isCovers() {\n  \t\tvar hasPointInCommon = IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY]);\n  \t\treturn hasPointInCommon && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE;\n  \t},\n  \tisCoveredBy: function isCoveredBy() {\n  \t\tvar hasPointInCommon = IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY]);\n  \t\treturn hasPointInCommon && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE;\n  \t},\n  \tset: function set() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar dimensionSymbols = arguments[0];\n  \t\t\tfor (var i = 0; i < dimensionSymbols.length; i++) {\n  \t\t\t\tvar row = Math.trunc(i / 3);\n  \t\t\t\tvar col = i % 3;\n  \t\t\t\tthis._matrix[row][col] = Dimension.toDimensionValue(dimensionSymbols.charAt(i));\n  \t\t\t}\n  \t\t} else if (arguments.length === 3) {\n  \t\t\tvar row = arguments[0],\n  \t\t\t    column = arguments[1],\n  \t\t\t    dimensionValue = arguments[2];\n  \t\t\tthis._matrix[row][column] = dimensionValue;\n  \t\t}\n  \t},\n  \tisContains: function isContains() {\n  \t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE;\n  \t},\n  \tsetAtLeast: function setAtLeast() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar minimumDimensionSymbols = arguments[0];\n  \t\t\tfor (var i = 0; i < minimumDimensionSymbols.length; i++) {\n  \t\t\t\tvar row = Math.trunc(i / 3);\n  \t\t\t\tvar col = i % 3;\n  \t\t\t\tthis.setAtLeast(row, col, Dimension.toDimensionValue(minimumDimensionSymbols.charAt(i)));\n  \t\t\t}\n  \t\t} else if (arguments.length === 3) {\n  \t\t\tvar row = arguments[0],\n  \t\t\t    column = arguments[1],\n  \t\t\t    minimumDimensionValue = arguments[2];\n  \t\t\tif (this._matrix[row][column] < minimumDimensionValue) {\n  \t\t\t\tthis._matrix[row][column] = minimumDimensionValue;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tsetAtLeastIfValid: function setAtLeastIfValid(row, column, minimumDimensionValue) {\n  \t\tif (row >= 0 && column >= 0) {\n  \t\t\tthis.setAtLeast(row, column, minimumDimensionValue);\n  \t\t}\n  \t},\n  \tisWithin: function isWithin() {\n  \t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE;\n  \t},\n  \tisTouches: function isTouches(dimensionOfGeometryA, dimensionOfGeometryB) {\n  \t\tif (dimensionOfGeometryA > dimensionOfGeometryB) {\n  \t\t\treturn this.isTouches(dimensionOfGeometryB, dimensionOfGeometryA);\n  \t\t}\n  \t\tif (dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.L) {\n  \t\t\treturn this._matrix[Location.INTERIOR][Location.INTERIOR] === Dimension.FALSE && (IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY]));\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tisOverlaps: function isOverlaps(dimensionOfGeometryA, dimensionOfGeometryB) {\n  \t\tif (dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.A) {\n  \t\t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR]);\n  \t\t}\n  \t\tif (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L) {\n  \t\t\treturn this._matrix[Location.INTERIOR][Location.INTERIOR] === 1 && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR]);\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tisEquals: function isEquals(dimensionOfGeometryA, dimensionOfGeometryB) {\n  \t\tif (dimensionOfGeometryA !== dimensionOfGeometryB) {\n  \t\t\treturn false;\n  \t\t}\n  \t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE;\n  \t},\n  \ttoString: function toString() {\n  \t\tvar buf = new StringBuffer(\"123456789\");\n  \t\tfor (var ai = 0; ai < 3; ai++) {\n  \t\t\tfor (var bi = 0; bi < 3; bi++) {\n  \t\t\t\tbuf.setCharAt(3 * ai + bi, Dimension.toDimensionSymbol(this._matrix[ai][bi]));\n  \t\t\t}\n  \t\t}\n  \t\treturn buf.toString();\n  \t},\n  \tsetAll: function setAll(dimensionValue) {\n  \t\tfor (var ai = 0; ai < 3; ai++) {\n  \t\t\tfor (var bi = 0; bi < 3; bi++) {\n  \t\t\t\tthis._matrix[ai][bi] = dimensionValue;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tget: function get(row, column) {\n  \t\treturn this._matrix[row][column];\n  \t},\n  \ttranspose: function transpose() {\n  \t\tvar temp = this._matrix[1][0];\n  \t\tthis._matrix[1][0] = this._matrix[0][1];\n  \t\tthis._matrix[0][1] = temp;\n  \t\ttemp = this._matrix[2][0];\n  \t\tthis._matrix[2][0] = this._matrix[0][2];\n  \t\tthis._matrix[0][2] = temp;\n  \t\ttemp = this._matrix[2][1];\n  \t\tthis._matrix[2][1] = this._matrix[1][2];\n  \t\tthis._matrix[1][2] = temp;\n  \t\treturn this;\n  \t},\n  \tmatches: function matches(requiredDimensionSymbols) {\n  \t\tif (requiredDimensionSymbols.length !== 9) {\n  \t\t\tthrow new IllegalArgumentException(\"Should be length 9: \" + requiredDimensionSymbols);\n  \t\t}\n  \t\tfor (var ai = 0; ai < 3; ai++) {\n  \t\t\tfor (var bi = 0; bi < 3; bi++) {\n  \t\t\t\tif (!IntersectionMatrix.matches(this._matrix[ai][bi], requiredDimensionSymbols.charAt(3 * ai + bi))) {\n  \t\t\t\t\treturn false;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\treturn true;\n  \t},\n  \tadd: function add(im) {\n  \t\tfor (var i = 0; i < 3; i++) {\n  \t\t\tfor (var j = 0; j < 3; j++) {\n  \t\t\t\tthis.setAtLeast(i, j, im.get(i, j));\n  \t\t\t}\n  \t\t}\n  \t},\n  \tisDisjoint: function isDisjoint() {\n  \t\treturn this._matrix[Location.INTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.INTERIOR][Location.BOUNDARY] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.BOUNDARY] === Dimension.FALSE;\n  \t},\n  \tisCrosses: function isCrosses(dimensionOfGeometryA, dimensionOfGeometryB) {\n  \t\tif (dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.L || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.A) {\n  \t\t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR]);\n  \t\t}\n  \t\tif (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.L) {\n  \t\t\treturn IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR]);\n  \t\t}\n  \t\tif (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L) {\n  \t\t\treturn this._matrix[Location.INTERIOR][Location.INTERIOR] === 0;\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Clonable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn IntersectionMatrix;\n  \t}\n  });\n  IntersectionMatrix.matches = function () {\n  \tif (Number.isInteger(arguments[0]) && typeof arguments[1] === \"string\") {\n  \t\tvar actualDimensionValue = arguments[0],\n  \t\t    requiredDimensionSymbol = arguments[1];\n  \t\tif (requiredDimensionSymbol === Dimension.SYM_DONTCARE) {\n  \t\t\treturn true;\n  \t\t}\n  \t\tif (requiredDimensionSymbol === Dimension.SYM_TRUE && (actualDimensionValue >= 0 || actualDimensionValue === Dimension.TRUE)) {\n  \t\t\treturn true;\n  \t\t}\n  \t\tif (requiredDimensionSymbol === Dimension.SYM_FALSE && actualDimensionValue === Dimension.FALSE) {\n  \t\t\treturn true;\n  \t\t}\n  \t\tif (requiredDimensionSymbol === Dimension.SYM_P && actualDimensionValue === Dimension.P) {\n  \t\t\treturn true;\n  \t\t}\n  \t\tif (requiredDimensionSymbol === Dimension.SYM_L && actualDimensionValue === Dimension.L) {\n  \t\t\treturn true;\n  \t\t}\n  \t\tif (requiredDimensionSymbol === Dimension.SYM_A && actualDimensionValue === Dimension.A) {\n  \t\t\treturn true;\n  \t\t}\n  \t\treturn false;\n  \t} else if (typeof arguments[0] === \"string\" && typeof arguments[1] === \"string\") {\n  \t\tvar actualDimensionSymbols = arguments[0],\n  \t\t    requiredDimensionSymbols = arguments[1];\n  \t\tvar m = new IntersectionMatrix(actualDimensionSymbols);\n  \t\treturn m.matches(requiredDimensionSymbols);\n  \t}\n  };\n  IntersectionMatrix.isTrue = function (actualDimensionValue) {\n  \tif (actualDimensionValue >= 0 || actualDimensionValue === Dimension.TRUE) {\n  \t\treturn true;\n  \t}\n  \treturn false;\n  };\n\n  function Centroid() {\n  \tthis._areaBasePt = null;\n  \tthis._triangleCent3 = new Coordinate();\n  \tthis._areasum2 = 0;\n  \tthis._cg3 = new Coordinate();\n  \tthis._lineCentSum = new Coordinate();\n  \tthis._totalLength = 0.0;\n  \tthis._ptCount = 0;\n  \tthis._ptCentSum = new Coordinate();\n  \tvar geom = arguments[0];\n  \tthis._areaBasePt = null;\n  \tthis.add(geom);\n  }\n  extend(Centroid.prototype, {\n  \taddPoint: function addPoint(pt) {\n  \t\tthis._ptCount += 1;\n  \t\tthis._ptCentSum.x += pt.x;\n  \t\tthis._ptCentSum.y += pt.y;\n  \t},\n  \tsetBasePoint: function setBasePoint(basePt) {\n  \t\tif (this._areaBasePt === null) this._areaBasePt = basePt;\n  \t},\n  \taddLineSegments: function addLineSegments(pts) {\n  \t\tvar lineLen = 0.0;\n  \t\tfor (var i = 0; i < pts.length - 1; i++) {\n  \t\t\tvar segmentLen = pts[i].distance(pts[i + 1]);\n  \t\t\tif (segmentLen === 0.0) continue;\n  \t\t\tlineLen += segmentLen;\n  \t\t\tvar midx = (pts[i].x + pts[i + 1].x) / 2;\n  \t\t\tthis._lineCentSum.x += segmentLen * midx;\n  \t\t\tvar midy = (pts[i].y + pts[i + 1].y) / 2;\n  \t\t\tthis._lineCentSum.y += segmentLen * midy;\n  \t\t}\n  \t\tthis._totalLength += lineLen;\n  \t\tif (lineLen === 0.0 && pts.length > 0) this.addPoint(pts[0]);\n  \t},\n  \taddHole: function addHole(pts) {\n  \t\tvar isPositiveArea = CGAlgorithms.isCCW(pts);\n  \t\tfor (var i = 0; i < pts.length - 1; i++) {\n  \t\t\tthis.addTriangle(this._areaBasePt, pts[i], pts[i + 1], isPositiveArea);\n  \t\t}\n  \t\tthis.addLineSegments(pts);\n  \t},\n  \tgetCentroid: function getCentroid() {\n  \t\tvar cent = new Coordinate();\n  \t\tif (Math.abs(this._areasum2) > 0.0) {\n  \t\t\tcent.x = this._cg3.x / 3 / this._areasum2;\n  \t\t\tcent.y = this._cg3.y / 3 / this._areasum2;\n  \t\t} else if (this._totalLength > 0.0) {\n  \t\t\tcent.x = this._lineCentSum.x / this._totalLength;\n  \t\t\tcent.y = this._lineCentSum.y / this._totalLength;\n  \t\t} else if (this._ptCount > 0) {\n  \t\t\tcent.x = this._ptCentSum.x / this._ptCount;\n  \t\t\tcent.y = this._ptCentSum.y / this._ptCount;\n  \t\t} else {\n  \t\t\treturn null;\n  \t\t}\n  \t\treturn cent;\n  \t},\n  \taddShell: function addShell(pts) {\n  \t\tif (pts.length > 0) this.setBasePoint(pts[0]);\n  \t\tvar isPositiveArea = !CGAlgorithms.isCCW(pts);\n  \t\tfor (var i = 0; i < pts.length - 1; i++) {\n  \t\t\tthis.addTriangle(this._areaBasePt, pts[i], pts[i + 1], isPositiveArea);\n  \t\t}\n  \t\tthis.addLineSegments(pts);\n  \t},\n  \taddTriangle: function addTriangle(p0, p1, p2, isPositiveArea) {\n  \t\tvar sign = isPositiveArea ? 1.0 : -1.0;\n  \t\tCentroid.centroid3(p0, p1, p2, this._triangleCent3);\n  \t\tvar area2 = Centroid.area2(p0, p1, p2);\n  \t\tthis._cg3.x += sign * area2 * this._triangleCent3.x;\n  \t\tthis._cg3.y += sign * area2 * this._triangleCent3.y;\n  \t\tthis._areasum2 += sign * area2;\n  \t},\n  \tadd: function add() {\n  \t\tif (arguments[0] instanceof Polygon) {\n  \t\t\tvar poly = arguments[0];\n  \t\t\tthis.addShell(poly.getExteriorRing().getCoordinates());\n  \t\t\tfor (var i = 0; i < poly.getNumInteriorRing(); i++) {\n  \t\t\t\tthis.addHole(poly.getInteriorRingN(i).getCoordinates());\n  \t\t\t}\n  \t\t} else if (arguments[0] instanceof Geometry) {\n  \t\t\tvar geom = arguments[0];\n  \t\t\tif (geom.isEmpty()) return null;\n  \t\t\tif (geom instanceof Point) {\n  \t\t\t\tthis.addPoint(geom.getCoordinate());\n  \t\t\t} else if (geom instanceof LineString) {\n  \t\t\t\tthis.addLineSegments(geom.getCoordinates());\n  \t\t\t} else if (geom instanceof Polygon) {\n  \t\t\t\tvar poly = geom;\n  \t\t\t\tthis.add(poly);\n  \t\t\t} else if (geom instanceof GeometryCollection) {\n  \t\t\t\tvar gc = geom;\n  \t\t\t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n  \t\t\t\t\tthis.add(gc.getGeometryN(i));\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Centroid;\n  \t}\n  });\n  Centroid.area2 = function (p1, p2, p3) {\n  \treturn (p2.x - p1.x) * (p3.y - p1.y) - (p3.x - p1.x) * (p2.y - p1.y);\n  };\n  Centroid.centroid3 = function (p1, p2, p3, c) {\n  \tc.x = p1.x + p2.x + p3.x;\n  \tc.y = p1.y + p2.y + p3.y;\n  \treturn null;\n  };\n  Centroid.getCentroid = function (geom) {\n  \tvar cent = new Centroid(geom);\n  \treturn cent.getCentroid();\n  };\n\n  function EmptyStackException(message) {\n    this.message = message || '';\n  }EmptyStackException.prototype = new Error();\n  EmptyStackException.prototype.name = 'EmptyStackException';\n\n  function Stack$1() {\n    this.array_ = [];\n  }Stack$1.prototype = new List();\n  Stack$1.prototype.add = function (e) {\n    this.array_.push(e);\n    return true;\n  };\n  Stack$1.prototype.get = function (index) {\n    if (index < 0 || index >= this.size()) {\n      throw new IndexOutOfBoundsException();\n    }\n    return this.array_[index];\n  };\n  Stack$1.prototype.push = function (e) {\n    this.array_.push(e);\n    return e;\n  };\n  Stack$1.prototype.pop = function (e) {\n    if (this.array_.length === 0) {\n      throw new EmptyStackException();\n    }\n    return this.array_.pop();\n  };\n  Stack$1.prototype.peek = function () {\n    if (this.array_.length === 0) {\n      throw new EmptyStackException();\n    }\n    return this.array_[this.array_.length - 1];\n  };\n  Stack$1.prototype.empty = function () {\n    if (this.array_.length === 0) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  Stack$1.prototype.isEmpty = function () {\n    return this.empty();\n  };\n  Stack$1.prototype.search = function (o) {\n    return this.array_.indexOf(o);\n  };\n  Stack$1.prototype.size = function () {\n    return this.array_.length;\n  };\n  Stack$1.prototype.toArray = function () {\n    var array = [];\n    for (var i = 0, len = this.array_.length; i < len; i++) {\n      array.push(this.array_[i]);\n    }\n    return array;\n  };\n\n  function UniqueCoordinateArrayFilter() {\n  \tthis.treeSet = new TreeSet();\n  \tthis.list = new ArrayList();\n  }\n  extend(UniqueCoordinateArrayFilter.prototype, {\n  \tfilter: function filter(coord) {\n  \t\tif (!this.treeSet.contains(coord)) {\n  \t\t\tthis.list.add(coord);\n  \t\t\tthis.treeSet.add(coord);\n  \t\t}\n  \t},\n  \tgetCoordinates: function getCoordinates() {\n  \t\tvar coordinates = new Array(this.list.size()).fill(null);\n  \t\treturn this.list.toArray(coordinates);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [CoordinateFilter];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn UniqueCoordinateArrayFilter;\n  \t}\n  });\n  UniqueCoordinateArrayFilter.filterCoordinates = function (coords) {\n  \tvar filter = new UniqueCoordinateArrayFilter();\n  \tfor (var i = 0; i < coords.length; i++) {\n  \t\tfilter.filter(coords[i]);\n  \t}\n  \treturn filter.getCoordinates();\n  };\n\n  function ConvexHull() {\n  \tthis._geomFactory = null;\n  \tthis._inputPts = null;\n  \tif (arguments.length === 1) {\n  \t\tvar geometry = arguments[0];\n  \t\tConvexHull.call(this, ConvexHull.extractCoordinates(geometry), geometry.getFactory());\n  \t} else if (arguments.length === 2) {\n  \t\tvar pts = arguments[0],\n  \t\t    geomFactory = arguments[1];\n  \t\tthis._inputPts = UniqueCoordinateArrayFilter.filterCoordinates(pts);\n  \t\tthis._geomFactory = geomFactory;\n  \t}\n  }\n  extend(ConvexHull.prototype, {\n  \tpreSort: function preSort(pts) {\n  \t\tvar t = null;\n  \t\tfor (var i = 1; i < pts.length; i++) {\n  \t\t\tif (pts[i].y < pts[0].y || pts[i].y === pts[0].y && pts[i].x < pts[0].x) {\n  \t\t\t\tt = pts[0];\n  \t\t\t\tpts[0] = pts[i];\n  \t\t\t\tpts[i] = t;\n  \t\t\t}\n  \t\t}\n  \t\tArrays.sort(pts, 1, pts.length, new RadialComparator(pts[0]));\n  \t\treturn pts;\n  \t},\n  \tcomputeOctRing: function computeOctRing(inputPts) {\n  \t\tvar octPts = this.computeOctPts(inputPts);\n  \t\tvar coordList = new CoordinateList();\n  \t\tcoordList.add(octPts, false);\n  \t\tif (coordList.size() < 3) {\n  \t\t\treturn null;\n  \t\t}\n  \t\tcoordList.closeRing();\n  \t\treturn coordList.toCoordinateArray();\n  \t},\n  \tlineOrPolygon: function lineOrPolygon(coordinates) {\n  \t\tcoordinates = this.cleanRing(coordinates);\n  \t\tif (coordinates.length === 3) {\n  \t\t\treturn this._geomFactory.createLineString([coordinates[0], coordinates[1]]);\n  \t\t}\n  \t\tvar linearRing = this._geomFactory.createLinearRing(coordinates);\n  \t\treturn this._geomFactory.createPolygon(linearRing, null);\n  \t},\n  \tcleanRing: function cleanRing(original) {\n  \t\tAssert.equals(original[0], original[original.length - 1]);\n  \t\tvar cleanedRing = new ArrayList();\n  \t\tvar previousDistinctCoordinate = null;\n  \t\tfor (var i = 0; i <= original.length - 2; i++) {\n  \t\t\tvar currentCoordinate = original[i];\n  \t\t\tvar nextCoordinate = original[i + 1];\n  \t\t\tif (currentCoordinate.equals(nextCoordinate)) {\n  \t\t\t\tcontinue;\n  \t\t\t}\n  \t\t\tif (previousDistinctCoordinate !== null && this.isBetween(previousDistinctCoordinate, currentCoordinate, nextCoordinate)) {\n  \t\t\t\tcontinue;\n  \t\t\t}\n  \t\t\tcleanedRing.add(currentCoordinate);\n  \t\t\tpreviousDistinctCoordinate = currentCoordinate;\n  \t\t}\n  \t\tcleanedRing.add(original[original.length - 1]);\n  \t\tvar cleanedRingCoordinates = new Array(cleanedRing.size()).fill(null);\n  \t\treturn cleanedRing.toArray(cleanedRingCoordinates);\n  \t},\n  \tisBetween: function isBetween(c1, c2, c3) {\n  \t\tif (CGAlgorithms.computeOrientation(c1, c2, c3) !== 0) {\n  \t\t\treturn false;\n  \t\t}\n  \t\tif (c1.x !== c3.x) {\n  \t\t\tif (c1.x <= c2.x && c2.x <= c3.x) {\n  \t\t\t\treturn true;\n  \t\t\t}\n  \t\t\tif (c3.x <= c2.x && c2.x <= c1.x) {\n  \t\t\t\treturn true;\n  \t\t\t}\n  \t\t}\n  \t\tif (c1.y !== c3.y) {\n  \t\t\tif (c1.y <= c2.y && c2.y <= c3.y) {\n  \t\t\t\treturn true;\n  \t\t\t}\n  \t\t\tif (c3.y <= c2.y && c2.y <= c1.y) {\n  \t\t\t\treturn true;\n  \t\t\t}\n  \t\t}\n  \t\treturn false;\n  \t},\n  \treduce: function reduce(inputPts) {\n  \t\tvar polyPts = this.computeOctRing(inputPts);\n  \t\tif (polyPts === null) return inputPts;\n  \t\tvar reducedSet = new TreeSet();\n  \t\tfor (var i = 0; i < polyPts.length; i++) {\n  \t\t\treducedSet.add(polyPts[i]);\n  \t\t}\n  \t\tfor (var i = 0; i < inputPts.length; i++) {\n  \t\t\tif (!CGAlgorithms.isPointInRing(inputPts[i], polyPts)) {\n  \t\t\t\treducedSet.add(inputPts[i]);\n  \t\t\t}\n  \t\t}\n  \t\tvar reducedPts = CoordinateArrays.toCoordinateArray(reducedSet);\n  \t\tif (reducedPts.length < 3) return this.padArray3(reducedPts);\n  \t\treturn reducedPts;\n  \t},\n  \tgetConvexHull: function getConvexHull() {\n  \t\tif (this._inputPts.length === 0) {\n  \t\t\treturn this._geomFactory.createGeometryCollection(null);\n  \t\t}\n  \t\tif (this._inputPts.length === 1) {\n  \t\t\treturn this._geomFactory.createPoint(this._inputPts[0]);\n  \t\t}\n  \t\tif (this._inputPts.length === 2) {\n  \t\t\treturn this._geomFactory.createLineString(this._inputPts);\n  \t\t}\n  \t\tvar reducedPts = this._inputPts;\n  \t\tif (this._inputPts.length > 50) {\n  \t\t\treducedPts = this.reduce(this._inputPts);\n  \t\t}\n  \t\tvar sortedPts = this.preSort(reducedPts);\n  \t\tvar cHS = this.grahamScan(sortedPts);\n  \t\tvar cH = this.toCoordinateArray(cHS);\n  \t\treturn this.lineOrPolygon(cH);\n  \t},\n  \tpadArray3: function padArray3(pts) {\n  \t\tvar pad = new Array(3).fill(null);\n  \t\tfor (var i = 0; i < pad.length; i++) {\n  \t\t\tif (i < pts.length) {\n  \t\t\t\tpad[i] = pts[i];\n  \t\t\t} else pad[i] = pts[0];\n  \t\t}\n  \t\treturn pad;\n  \t},\n  \tcomputeOctPts: function computeOctPts(inputPts) {\n  \t\tvar pts = new Array(8).fill(null);\n  \t\tfor (var j = 0; j < pts.length; j++) {\n  \t\t\tpts[j] = inputPts[0];\n  \t\t}\n  \t\tfor (var i = 1; i < inputPts.length; i++) {\n  \t\t\tif (inputPts[i].x < pts[0].x) {\n  \t\t\t\tpts[0] = inputPts[i];\n  \t\t\t}\n  \t\t\tif (inputPts[i].x - inputPts[i].y < pts[1].x - pts[1].y) {\n  \t\t\t\tpts[1] = inputPts[i];\n  \t\t\t}\n  \t\t\tif (inputPts[i].y > pts[2].y) {\n  \t\t\t\tpts[2] = inputPts[i];\n  \t\t\t}\n  \t\t\tif (inputPts[i].x + inputPts[i].y > pts[3].x + pts[3].y) {\n  \t\t\t\tpts[3] = inputPts[i];\n  \t\t\t}\n  \t\t\tif (inputPts[i].x > pts[4].x) {\n  \t\t\t\tpts[4] = inputPts[i];\n  \t\t\t}\n  \t\t\tif (inputPts[i].x - inputPts[i].y > pts[5].x - pts[5].y) {\n  \t\t\t\tpts[5] = inputPts[i];\n  \t\t\t}\n  \t\t\tif (inputPts[i].y < pts[6].y) {\n  \t\t\t\tpts[6] = inputPts[i];\n  \t\t\t}\n  \t\t\tif (inputPts[i].x + inputPts[i].y < pts[7].x + pts[7].y) {\n  \t\t\t\tpts[7] = inputPts[i];\n  \t\t\t}\n  \t\t}\n  \t\treturn pts;\n  \t},\n  \ttoCoordinateArray: function toCoordinateArray(stack) {\n  \t\tvar coordinates = new Array(stack.size()).fill(null);\n  \t\tfor (var i = 0; i < stack.size(); i++) {\n  \t\t\tvar coordinate = stack.get(i);\n  \t\t\tcoordinates[i] = coordinate;\n  \t\t}\n  \t\treturn coordinates;\n  \t},\n  \tgrahamScan: function grahamScan(c) {\n  \t\tvar p = null;\n  \t\tvar ps = new Stack$1();\n  \t\tp = ps.push(c[0]);\n  \t\tp = ps.push(c[1]);\n  \t\tp = ps.push(c[2]);\n  \t\tfor (var i = 3; i < c.length; i++) {\n  \t\t\tp = ps.pop();\n  \t\t\twhile (!ps.empty() && CGAlgorithms.computeOrientation(ps.peek(), p, c[i]) > 0) {\n  \t\t\t\tp = ps.pop();\n  \t\t\t}\n  \t\t\tp = ps.push(p);\n  \t\t\tp = ps.push(c[i]);\n  \t\t}\n  \t\tp = ps.push(c[0]);\n  \t\treturn ps;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn ConvexHull;\n  \t}\n  });\n  ConvexHull.extractCoordinates = function (geom) {\n  \tvar filter = new UniqueCoordinateArrayFilter();\n  \tgeom.apply(filter);\n  \treturn filter.getCoordinates();\n  };\n  function RadialComparator() {\n  \tthis._origin = null;\n  \tvar origin = arguments[0];\n  \tthis._origin = origin;\n  }\n  extend(RadialComparator.prototype, {\n  \tcompare: function compare(o1, o2) {\n  \t\tvar p1 = o1;\n  \t\tvar p2 = o2;\n  \t\treturn RadialComparator.polarCompare(this._origin, p1, p2);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparator];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn RadialComparator;\n  \t}\n  });\n  RadialComparator.polarCompare = function (o, p, q) {\n  \tvar dxp = p.x - o.x;\n  \tvar dyp = p.y - o.y;\n  \tvar dxq = q.x - o.x;\n  \tvar dyq = q.y - o.y;\n  \tvar orient = CGAlgorithms.computeOrientation(o, p, q);\n  \tif (orient === CGAlgorithms.COUNTERCLOCKWISE) return 1;\n  \tif (orient === CGAlgorithms.CLOCKWISE) return -1;\n  \tvar op = dxp * dxp + dyp * dyp;\n  \tvar oq = dxq * dxq + dyq * dyq;\n  \tif (op < oq) {\n  \t\treturn -1;\n  \t}\n  \tif (op > oq) {\n  \t\treturn 1;\n  \t}\n  \treturn 0;\n  };\n  ConvexHull.RadialComparator = RadialComparator;\n\n  function GeometryTransformer() {\n  \tthis._inputGeom = null;\n  \tthis._factory = null;\n  \tthis._pruneEmptyGeometry = true;\n  \tthis._preserveGeometryCollectionType = true;\n  \tthis._preserveCollections = false;\n  \tthis._preserveType = false;\n  }\n  extend(GeometryTransformer.prototype, {\n  \ttransformPoint: function transformPoint(geom, parent) {\n  \t\treturn this._factory.createPoint(this.transformCoordinates(geom.getCoordinateSequence(), geom));\n  \t},\n  \ttransformPolygon: function transformPolygon(geom, parent) {\n  \t\tvar isAllValidLinearRings = true;\n  \t\tvar shell = this.transformLinearRing(geom.getExteriorRing(), geom);\n  \t\tif (shell === null || !(shell instanceof LinearRing) || shell.isEmpty()) isAllValidLinearRings = false;\n  \t\tvar holes = new ArrayList();\n  \t\tfor (var i = 0; i < geom.getNumInteriorRing(); i++) {\n  \t\t\tvar hole = this.transformLinearRing(geom.getInteriorRingN(i), geom);\n  \t\t\tif (hole === null || hole.isEmpty()) {\n  \t\t\t\tcontinue;\n  \t\t\t}\n  \t\t\tif (!(hole instanceof LinearRing)) isAllValidLinearRings = false;\n  \t\t\tholes.add(hole);\n  \t\t}\n  \t\tif (isAllValidLinearRings) return this._factory.createPolygon(shell, holes.toArray([]));else {\n  \t\t\tvar components = new ArrayList();\n  \t\t\tif (shell !== null) components.add(shell);\n  \t\t\tcomponents.addAll(holes);\n  \t\t\treturn this._factory.buildGeometry(components);\n  \t\t}\n  \t},\n  \tcreateCoordinateSequence: function createCoordinateSequence(coords) {\n  \t\treturn this._factory.getCoordinateSequenceFactory().create(coords);\n  \t},\n  \tgetInputGeometry: function getInputGeometry() {\n  \t\treturn this._inputGeom;\n  \t},\n  \ttransformMultiLineString: function transformMultiLineString(geom, parent) {\n  \t\tvar transGeomList = new ArrayList();\n  \t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n  \t\t\tvar transformGeom = this.transformLineString(geom.getGeometryN(i), geom);\n  \t\t\tif (transformGeom === null) continue;\n  \t\t\tif (transformGeom.isEmpty()) continue;\n  \t\t\ttransGeomList.add(transformGeom);\n  \t\t}\n  \t\treturn this._factory.buildGeometry(transGeomList);\n  \t},\n  \ttransformCoordinates: function transformCoordinates(coords, parent) {\n  \t\treturn this.copy(coords);\n  \t},\n  \ttransformLineString: function transformLineString(geom, parent) {\n  \t\treturn this._factory.createLineString(this.transformCoordinates(geom.getCoordinateSequence(), geom));\n  \t},\n  \ttransformMultiPoint: function transformMultiPoint(geom, parent) {\n  \t\tvar transGeomList = new ArrayList();\n  \t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n  \t\t\tvar transformGeom = this.transformPoint(geom.getGeometryN(i), geom);\n  \t\t\tif (transformGeom === null) continue;\n  \t\t\tif (transformGeom.isEmpty()) continue;\n  \t\t\ttransGeomList.add(transformGeom);\n  \t\t}\n  \t\treturn this._factory.buildGeometry(transGeomList);\n  \t},\n  \ttransformMultiPolygon: function transformMultiPolygon(geom, parent) {\n  \t\tvar transGeomList = new ArrayList();\n  \t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n  \t\t\tvar transformGeom = this.transformPolygon(geom.getGeometryN(i), geom);\n  \t\t\tif (transformGeom === null) continue;\n  \t\t\tif (transformGeom.isEmpty()) continue;\n  \t\t\ttransGeomList.add(transformGeom);\n  \t\t}\n  \t\treturn this._factory.buildGeometry(transGeomList);\n  \t},\n  \tcopy: function copy(seq) {\n  \t\treturn seq.copy();\n  \t},\n  \ttransformGeometryCollection: function transformGeometryCollection(geom, parent) {\n  \t\tvar transGeomList = new ArrayList();\n  \t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n  \t\t\tvar transformGeom = this.transform(geom.getGeometryN(i));\n  \t\t\tif (transformGeom === null) continue;\n  \t\t\tif (this._pruneEmptyGeometry && transformGeom.isEmpty()) continue;\n  \t\t\ttransGeomList.add(transformGeom);\n  \t\t}\n  \t\tif (this._preserveGeometryCollectionType) return this._factory.createGeometryCollection(GeometryFactory.toGeometryArray(transGeomList));\n  \t\treturn this._factory.buildGeometry(transGeomList);\n  \t},\n  \ttransform: function transform(inputGeom) {\n  \t\tthis._inputGeom = inputGeom;\n  \t\tthis._factory = inputGeom.getFactory();\n  \t\tif (inputGeom instanceof Point) return this.transformPoint(inputGeom, null);\n  \t\tif (inputGeom instanceof MultiPoint) return this.transformMultiPoint(inputGeom, null);\n  \t\tif (inputGeom instanceof LinearRing) return this.transformLinearRing(inputGeom, null);\n  \t\tif (inputGeom instanceof LineString) return this.transformLineString(inputGeom, null);\n  \t\tif (inputGeom instanceof MultiLineString) return this.transformMultiLineString(inputGeom, null);\n  \t\tif (inputGeom instanceof Polygon) return this.transformPolygon(inputGeom, null);\n  \t\tif (inputGeom instanceof MultiPolygon) return this.transformMultiPolygon(inputGeom, null);\n  \t\tif (inputGeom instanceof GeometryCollection) return this.transformGeometryCollection(inputGeom, null);\n  \t\tthrow new IllegalArgumentException(\"Unknown Geometry subtype: \" + inputGeom.getClass().getName());\n  \t},\n  \ttransformLinearRing: function transformLinearRing(geom, parent) {\n  \t\tvar seq = this.transformCoordinates(geom.getCoordinateSequence(), geom);\n  \t\tif (seq === null) return this._factory.createLinearRing(null);\n  \t\tvar seqSize = seq.size();\n  \t\tif (seqSize > 0 && seqSize < 4 && !this._preserveType) return this._factory.createLineString(seq);\n  \t\treturn this._factory.createLinearRing(seq);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn GeometryTransformer;\n  \t}\n  });\n\n  function LineStringSnapper() {\n  \tthis._snapTolerance = 0.0;\n  \tthis._srcPts = null;\n  \tthis._seg = new LineSegment();\n  \tthis._allowSnappingToSourceVertices = false;\n  \tthis._isClosed = false;\n  \tif (arguments[0] instanceof LineString && typeof arguments[1] === \"number\") {\n  \t\tvar srcLine = arguments[0],\n  \t\t    snapTolerance = arguments[1];\n  \t\tLineStringSnapper.call(this, srcLine.getCoordinates(), snapTolerance);\n  \t} else if (arguments[0] instanceof Array && typeof arguments[1] === \"number\") {\n  \t\tvar srcPts = arguments[0],\n  \t\t    snapTolerance = arguments[1];\n  \t\tthis._srcPts = srcPts;\n  \t\tthis._isClosed = LineStringSnapper.isClosed(srcPts);\n  \t\tthis._snapTolerance = snapTolerance;\n  \t}\n  }\n  extend(LineStringSnapper.prototype, {\n  \tsnapVertices: function snapVertices(srcCoords, snapPts) {\n  \t\tvar end = this._isClosed ? srcCoords.size() - 1 : srcCoords.size();\n  \t\tfor (var i = 0; i < end; i++) {\n  \t\t\tvar srcPt = srcCoords.get(i);\n  \t\t\tvar snapVert = this.findSnapForVertex(srcPt, snapPts);\n  \t\t\tif (snapVert !== null) {\n  \t\t\t\tsrcCoords.set(i, new Coordinate(snapVert));\n  \t\t\t\tif (i === 0 && this._isClosed) srcCoords.set(srcCoords.size() - 1, new Coordinate(snapVert));\n  \t\t\t}\n  \t\t}\n  \t},\n  \tfindSnapForVertex: function findSnapForVertex(pt, snapPts) {\n  \t\tfor (var i = 0; i < snapPts.length; i++) {\n  \t\t\tif (pt.equals2D(snapPts[i])) return null;\n  \t\t\tif (pt.distance(snapPts[i]) < this._snapTolerance) return snapPts[i];\n  \t\t}\n  \t\treturn null;\n  \t},\n  \tsnapTo: function snapTo(snapPts) {\n  \t\tvar coordList = new CoordinateList(this._srcPts);\n  \t\tthis.snapVertices(coordList, snapPts);\n  \t\tthis.snapSegments(coordList, snapPts);\n  \t\tvar newPts = coordList.toCoordinateArray();\n  \t\treturn newPts;\n  \t},\n  \tsnapSegments: function snapSegments(srcCoords, snapPts) {\n  \t\tif (snapPts.length === 0) return null;\n  \t\tvar distinctPtCount = snapPts.length;\n  \t\tif (snapPts[0].equals2D(snapPts[snapPts.length - 1])) distinctPtCount = snapPts.length - 1;\n  \t\tfor (var i = 0; i < distinctPtCount; i++) {\n  \t\t\tvar snapPt = snapPts[i];\n  \t\t\tvar index = this.findSegmentIndexToSnap(snapPt, srcCoords);\n  \t\t\tif (index >= 0) {\n  \t\t\t\tsrcCoords.add(index + 1, new Coordinate(snapPt), false);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tfindSegmentIndexToSnap: function findSegmentIndexToSnap(snapPt, srcCoords) {\n  \t\tvar minDist = Double.MAX_VALUE;\n  \t\tvar snapIndex = -1;\n  \t\tfor (var i = 0; i < srcCoords.size() - 1; i++) {\n  \t\t\tthis._seg.p0 = srcCoords.get(i);\n  \t\t\tthis._seg.p1 = srcCoords.get(i + 1);\n  \t\t\tif (this._seg.p0.equals2D(snapPt) || this._seg.p1.equals2D(snapPt)) {\n  \t\t\t\tif (this._allowSnappingToSourceVertices) continue;else return -1;\n  \t\t\t}\n  \t\t\tvar dist = this._seg.distance(snapPt);\n  \t\t\tif (dist < this._snapTolerance && dist < minDist) {\n  \t\t\t\tminDist = dist;\n  \t\t\t\tsnapIndex = i;\n  \t\t\t}\n  \t\t}\n  \t\treturn snapIndex;\n  \t},\n  \tsetAllowSnappingToSourceVertices: function setAllowSnappingToSourceVertices(allowSnappingToSourceVertices) {\n  \t\tthis._allowSnappingToSourceVertices = allowSnappingToSourceVertices;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LineStringSnapper;\n  \t}\n  });\n  LineStringSnapper.isClosed = function (pts) {\n  \tif (pts.length <= 1) return false;\n  \treturn pts[0].equals2D(pts[pts.length - 1]);\n  };\n\n  function GeometrySnapper() {\n  \tthis._srcGeom = null;\n  \tvar srcGeom = arguments[0];\n  \tthis._srcGeom = srcGeom;\n  }\n  extend(GeometrySnapper.prototype, {\n  \tsnapTo: function snapTo(snapGeom, snapTolerance) {\n  \t\tvar snapPts = this.extractTargetCoordinates(snapGeom);\n  \t\tvar snapTrans = new SnapTransformer(snapTolerance, snapPts);\n  \t\treturn snapTrans.transform(this._srcGeom);\n  \t},\n  \tsnapToSelf: function snapToSelf(snapTolerance, cleanResult) {\n  \t\tvar snapPts = this.extractTargetCoordinates(this._srcGeom);\n  \t\tvar snapTrans = new SnapTransformer(snapTolerance, snapPts, true);\n  \t\tvar snappedGeom = snapTrans.transform(this._srcGeom);\n  \t\tvar result = snappedGeom;\n  \t\tif (cleanResult && hasInterface(result, Polygonal)) {\n  \t\t\tresult = snappedGeom.buffer(0);\n  \t\t}\n  \t\treturn result;\n  \t},\n  \tcomputeSnapTolerance: function computeSnapTolerance(ringPts) {\n  \t\tvar minSegLen = this.computeMinimumSegmentLength(ringPts);\n  \t\tvar snapTol = minSegLen / 10;\n  \t\treturn snapTol;\n  \t},\n  \textractTargetCoordinates: function extractTargetCoordinates(g) {\n  \t\tvar ptSet = new TreeSet();\n  \t\tvar pts = g.getCoordinates();\n  \t\tfor (var i = 0; i < pts.length; i++) {\n  \t\t\tptSet.add(pts[i]);\n  \t\t}\n  \t\treturn ptSet.toArray(new Array(0).fill(null));\n  \t},\n  \tcomputeMinimumSegmentLength: function computeMinimumSegmentLength(pts) {\n  \t\tvar minSegLen = Double.MAX_VALUE;\n  \t\tfor (var i = 0; i < pts.length - 1; i++) {\n  \t\t\tvar segLen = pts[i].distance(pts[i + 1]);\n  \t\t\tif (segLen < minSegLen) minSegLen = segLen;\n  \t\t}\n  \t\treturn minSegLen;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn GeometrySnapper;\n  \t}\n  });\n  GeometrySnapper.snap = function (g0, g1, snapTolerance) {\n  \tvar snapGeom = new Array(2).fill(null);\n  \tvar snapper0 = new GeometrySnapper(g0);\n  \tsnapGeom[0] = snapper0.snapTo(g1, snapTolerance);\n  \tvar snapper1 = new GeometrySnapper(g1);\n  \tsnapGeom[1] = snapper1.snapTo(snapGeom[0], snapTolerance);\n  \treturn snapGeom;\n  };\n  GeometrySnapper.computeOverlaySnapTolerance = function () {\n  \tif (arguments.length === 1) {\n  \t\tvar g = arguments[0];\n  \t\tvar snapTolerance = GeometrySnapper.computeSizeBasedSnapTolerance(g);\n  \t\tvar pm = g.getPrecisionModel();\n  \t\tif (pm.getType() === PrecisionModel.FIXED) {\n  \t\t\tvar fixedSnapTol = 1 / pm.getScale() * 2 / 1.415;\n  \t\t\tif (fixedSnapTol > snapTolerance) snapTolerance = fixedSnapTol;\n  \t\t}\n  \t\treturn snapTolerance;\n  \t} else if (arguments.length === 2) {\n  \t\tvar g0 = arguments[0],\n  \t\t    g1 = arguments[1];\n  \t\treturn Math.min(GeometrySnapper.computeOverlaySnapTolerance(g0), GeometrySnapper.computeOverlaySnapTolerance(g1));\n  \t}\n  };\n  GeometrySnapper.computeSizeBasedSnapTolerance = function (g) {\n  \tvar env = g.getEnvelopeInternal();\n  \tvar minDimension = Math.min(env.getHeight(), env.getWidth());\n  \tvar snapTol = minDimension * GeometrySnapper.SNAP_PRECISION_FACTOR;\n  \treturn snapTol;\n  };\n  GeometrySnapper.snapToSelf = function (geom, snapTolerance, cleanResult) {\n  \tvar snapper0 = new GeometrySnapper(geom);\n  \treturn snapper0.snapToSelf(snapTolerance, cleanResult);\n  };\n  GeometrySnapper.SNAP_PRECISION_FACTOR = 1e-9;\n  function SnapTransformer() {\n  \tGeometryTransformer.apply(this);\n  \tthis._snapTolerance = null;\n  \tthis._snapPts = null;\n  \tthis._isSelfSnap = false;\n  \tif (arguments.length === 2) {\n  \t\tvar snapTolerance = arguments[0],\n  \t\t    snapPts = arguments[1];\n  \t\tthis._snapTolerance = snapTolerance;\n  \t\tthis._snapPts = snapPts;\n  \t} else if (arguments.length === 3) {\n  \t\tvar snapTolerance = arguments[0],\n  \t\t    snapPts = arguments[1],\n  \t\t    isSelfSnap = arguments[2];\n  \t\tthis._snapTolerance = snapTolerance;\n  \t\tthis._snapPts = snapPts;\n  \t\tthis._isSelfSnap = isSelfSnap;\n  \t}\n  }\n  inherits$1(SnapTransformer, GeometryTransformer);\n  extend(SnapTransformer.prototype, {\n  \tsnapLine: function snapLine(srcPts, snapPts) {\n  \t\tvar snapper = new LineStringSnapper(srcPts, this._snapTolerance);\n  \t\tsnapper.setAllowSnappingToSourceVertices(this._isSelfSnap);\n  \t\treturn snapper.snapTo(snapPts);\n  \t},\n  \ttransformCoordinates: function transformCoordinates(coords, parent) {\n  \t\tvar srcPts = coords.toCoordinateArray();\n  \t\tvar newPts = this.snapLine(srcPts, this._snapPts);\n  \t\treturn this._factory.getCoordinateSequenceFactory().create(newPts);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SnapTransformer;\n  \t}\n  });\n\n  function CommonBits() {\n  \tthis._isFirst = true;\n  \tthis._commonMantissaBitsCount = 53;\n  \tthis._commonBits = 0;\n  \tthis._commonSignExp = null;\n  }\n  extend(CommonBits.prototype, {\n  \tgetCommon: function getCommon() {\n  \t\treturn Double.longBitsToDouble(this._commonBits);\n  \t},\n  \tadd: function add(num) {\n  \t\tvar numBits = Double.doubleToLongBits(num);\n  \t\tif (this._isFirst) {\n  \t\t\tthis._commonBits = numBits;\n  \t\t\tthis._commonSignExp = CommonBits.signExpBits(this._commonBits);\n  \t\t\tthis._isFirst = false;\n  \t\t\treturn null;\n  \t\t}\n  \t\tvar numSignExp = CommonBits.signExpBits(numBits);\n  \t\tif (numSignExp !== this._commonSignExp) {\n  \t\t\tthis._commonBits = 0;\n  \t\t\treturn null;\n  \t\t}\n  \t\tthis._commonMantissaBitsCount = CommonBits.numCommonMostSigMantissaBits(this._commonBits, numBits);\n  \t\tthis._commonBits = CommonBits.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount));\n  \t},\n  \ttoString: function toString() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar bits = arguments[0];\n  \t\t\tvar x = Double.longBitsToDouble(bits);\n  \t\t\tvar numStr = Long.toBinaryString(bits);\n  \t\t\tvar padStr = \"0000000000000000000000000000000000000000000000000000000000000000\" + numStr;\n  \t\t\tvar bitStr = padStr.substring(padStr.length - 64);\n  \t\t\tvar str = bitStr.substring(0, 1) + \"  \" + bitStr.substring(1, 12) + \"(exp) \" + bitStr.substring(12) + \" [ \" + x + \" ]\";\n  \t\t\treturn str;\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn CommonBits;\n  \t}\n  });\n  CommonBits.getBit = function (bits, i) {\n  \tvar mask = 1 << i;\n  \treturn (bits & mask) !== 0 ? 1 : 0;\n  };\n  CommonBits.signExpBits = function (num) {\n  \treturn num >> 52;\n  };\n  CommonBits.zeroLowerBits = function (bits, nBits) {\n  \tvar invMask = (1 << nBits) - 1;\n  \tvar mask = ~invMask;\n  \tvar zeroed = bits & mask;\n  \treturn zeroed;\n  };\n  CommonBits.numCommonMostSigMantissaBits = function (num1, num2) {\n  \tvar count = 0;\n  \tfor (var i = 52; i >= 0; i--) {\n  \t\tif (CommonBits.getBit(num1, i) !== CommonBits.getBit(num2, i)) return count;\n  \t\tcount++;\n  \t}\n  \treturn 52;\n  };\n\n  function CommonBitsRemover() {\n  \tthis._commonCoord = null;\n  \tthis._ccFilter = new CommonCoordinateFilter();\n  }\n  extend(CommonBitsRemover.prototype, {\n  \taddCommonBits: function addCommonBits(geom) {\n  \t\tvar trans = new Translater(this._commonCoord);\n  \t\tgeom.apply(trans);\n  \t\tgeom.geometryChanged();\n  \t},\n  \tremoveCommonBits: function removeCommonBits(geom) {\n  \t\tif (this._commonCoord.x === 0.0 && this._commonCoord.y === 0.0) return geom;\n  \t\tvar invCoord = new Coordinate(this._commonCoord);\n  \t\tinvCoord.x = -invCoord.x;\n  \t\tinvCoord.y = -invCoord.y;\n  \t\tvar trans = new Translater(invCoord);\n  \t\tgeom.apply(trans);\n  \t\tgeom.geometryChanged();\n  \t\treturn geom;\n  \t},\n  \tgetCommonCoordinate: function getCommonCoordinate() {\n  \t\treturn this._commonCoord;\n  \t},\n  \tadd: function add(geom) {\n  \t\tgeom.apply(this._ccFilter);\n  \t\tthis._commonCoord = this._ccFilter.getCommonCoordinate();\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn CommonBitsRemover;\n  \t}\n  });\n  function CommonCoordinateFilter() {\n  \tthis._commonBitsX = new CommonBits();\n  \tthis._commonBitsY = new CommonBits();\n  }\n  extend(CommonCoordinateFilter.prototype, {\n  \tfilter: function filter(coord) {\n  \t\tthis._commonBitsX.add(coord.x);\n  \t\tthis._commonBitsY.add(coord.y);\n  \t},\n  \tgetCommonCoordinate: function getCommonCoordinate() {\n  \t\treturn new Coordinate(this._commonBitsX.getCommon(), this._commonBitsY.getCommon());\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [CoordinateFilter];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn CommonCoordinateFilter;\n  \t}\n  });\n  function Translater() {\n  \tthis.trans = null;\n  \tvar trans = arguments[0];\n  \tthis.trans = trans;\n  }\n  extend(Translater.prototype, {\n  \tfilter: function filter(seq, i) {\n  \t\tvar xp = seq.getOrdinate(i, 0) + this.trans.x;\n  \t\tvar yp = seq.getOrdinate(i, 1) + this.trans.y;\n  \t\tseq.setOrdinate(i, 0, xp);\n  \t\tseq.setOrdinate(i, 1, yp);\n  \t},\n  \tisDone: function isDone() {\n  \t\treturn false;\n  \t},\n  \tisGeometryChanged: function isGeometryChanged() {\n  \t\treturn true;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [CoordinateSequenceFilter];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Translater;\n  \t}\n  });\n  CommonBitsRemover.CommonCoordinateFilter = CommonCoordinateFilter;\n  CommonBitsRemover.Translater = Translater;\n\n  function GeometryCollectionIterator() {\n  \tthis._parent = null;\n  \tthis._atStart = null;\n  \tthis._max = null;\n  \tthis._index = null;\n  \tthis._subcollectionIterator = null;\n  \tvar parent = arguments[0];\n  \tthis._parent = parent;\n  \tthis._atStart = true;\n  \tthis._index = 0;\n  \tthis._max = parent.getNumGeometries();\n  }\n  extend(GeometryCollectionIterator.prototype, {\n  \tnext: function next() {\n  \t\tif (this._atStart) {\n  \t\t\tthis._atStart = false;\n  \t\t\tif (GeometryCollectionIterator.isAtomic(this._parent)) this._index++;\n  \t\t\treturn this._parent;\n  \t\t}\n  \t\tif (this._subcollectionIterator !== null) {\n  \t\t\tif (this._subcollectionIterator.hasNext()) {\n  \t\t\t\treturn this._subcollectionIterator.next();\n  \t\t\t} else {\n  \t\t\t\tthis._subcollectionIterator = null;\n  \t\t\t}\n  \t\t}\n  \t\tif (this._index >= this._max) {\n  \t\t\tthrow new NoSuchElementException();\n  \t\t}\n  \t\tvar obj = this._parent.getGeometryN(this._index++);\n  \t\tif (obj instanceof GeometryCollection) {\n  \t\t\tthis._subcollectionIterator = new GeometryCollectionIterator(obj);\n  \t\t\treturn this._subcollectionIterator.next();\n  \t\t}\n  \t\treturn obj;\n  \t},\n  \tremove: function remove() {\n  \t\tthrow new UnsupportedOperationException(this.getClass().getName());\n  \t},\n  \thasNext: function hasNext() {\n  \t\tif (this._atStart) {\n  \t\t\treturn true;\n  \t\t}\n  \t\tif (this._subcollectionIterator !== null) {\n  \t\t\tif (this._subcollectionIterator.hasNext()) {\n  \t\t\t\treturn true;\n  \t\t\t}\n  \t\t\tthis._subcollectionIterator = null;\n  \t\t}\n  \t\tif (this._index >= this._max) {\n  \t\t\treturn false;\n  \t\t}\n  \t\treturn true;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Iterator];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn GeometryCollectionIterator;\n  \t}\n  });\n  GeometryCollectionIterator.isAtomic = function (geom) {\n  \treturn !(geom instanceof GeometryCollection);\n  };\n\n  function PointLocator() {\n  \tthis._boundaryRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;\n  \tthis._isIn = null;\n  \tthis._numBoundaries = null;\n  \tif (arguments.length === 0) ; else if (arguments.length === 1) {\n  \t\tvar boundaryRule = arguments[0];\n  \t\tif (boundaryRule === null) throw new IllegalArgumentException(\"Rule must be non-null\");\n  \t\tthis._boundaryRule = boundaryRule;\n  \t}\n  }\n  extend(PointLocator.prototype, {\n  \tlocateInternal: function locateInternal() {\n  \t\tif (arguments[0] instanceof Coordinate && arguments[1] instanceof Polygon) {\n  \t\t\tvar p = arguments[0],\n  \t\t\t    poly = arguments[1];\n  \t\t\tif (poly.isEmpty()) return Location.EXTERIOR;\n  \t\t\tvar shell = poly.getExteriorRing();\n  \t\t\tvar shellLoc = this.locateInPolygonRing(p, shell);\n  \t\t\tif (shellLoc === Location.EXTERIOR) return Location.EXTERIOR;\n  \t\t\tif (shellLoc === Location.BOUNDARY) return Location.BOUNDARY;\n  \t\t\tfor (var i = 0; i < poly.getNumInteriorRing(); i++) {\n  \t\t\t\tvar hole = poly.getInteriorRingN(i);\n  \t\t\t\tvar holeLoc = this.locateInPolygonRing(p, hole);\n  \t\t\t\tif (holeLoc === Location.INTERIOR) return Location.EXTERIOR;\n  \t\t\t\tif (holeLoc === Location.BOUNDARY) return Location.BOUNDARY;\n  \t\t\t}\n  \t\t\treturn Location.INTERIOR;\n  \t\t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof LineString) {\n  \t\t\tvar p = arguments[0],\n  \t\t\t    l = arguments[1];\n  \t\t\tif (!l.getEnvelopeInternal().intersects(p)) return Location.EXTERIOR;\n  \t\t\tvar pt = l.getCoordinates();\n  \t\t\tif (!l.isClosed()) {\n  \t\t\t\tif (p.equals(pt[0]) || p.equals(pt[pt.length - 1])) {\n  \t\t\t\t\treturn Location.BOUNDARY;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\tif (CGAlgorithms.isOnLine(p, pt)) return Location.INTERIOR;\n  \t\t\treturn Location.EXTERIOR;\n  \t\t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Point) {\n  \t\t\tvar p = arguments[0],\n  \t\t\t    pt = arguments[1];\n  \t\t\tvar ptCoord = pt.getCoordinate();\n  \t\t\tif (ptCoord.equals2D(p)) return Location.INTERIOR;\n  \t\t\treturn Location.EXTERIOR;\n  \t\t}\n  \t},\n  \tlocateInPolygonRing: function locateInPolygonRing(p, ring) {\n  \t\tif (!ring.getEnvelopeInternal().intersects(p)) return Location.EXTERIOR;\n  \t\treturn CGAlgorithms.locatePointInRing(p, ring.getCoordinates());\n  \t},\n  \tintersects: function intersects(p, geom) {\n  \t\treturn this.locate(p, geom) !== Location.EXTERIOR;\n  \t},\n  \tupdateLocationInfo: function updateLocationInfo(loc) {\n  \t\tif (loc === Location.INTERIOR) this._isIn = true;\n  \t\tif (loc === Location.BOUNDARY) this._numBoundaries++;\n  \t},\n  \tcomputeLocation: function computeLocation(p, geom) {\n  \t\tif (geom instanceof Point) {\n  \t\t\tthis.updateLocationInfo(this.locateInternal(p, geom));\n  \t\t}\n  \t\tif (geom instanceof LineString) {\n  \t\t\tthis.updateLocationInfo(this.locateInternal(p, geom));\n  \t\t} else if (geom instanceof Polygon) {\n  \t\t\tthis.updateLocationInfo(this.locateInternal(p, geom));\n  \t\t} else if (geom instanceof MultiLineString) {\n  \t\t\tvar ml = geom;\n  \t\t\tfor (var i = 0; i < ml.getNumGeometries(); i++) {\n  \t\t\t\tvar l = ml.getGeometryN(i);\n  \t\t\t\tthis.updateLocationInfo(this.locateInternal(p, l));\n  \t\t\t}\n  \t\t} else if (geom instanceof MultiPolygon) {\n  \t\t\tvar mpoly = geom;\n  \t\t\tfor (var i = 0; i < mpoly.getNumGeometries(); i++) {\n  \t\t\t\tvar poly = mpoly.getGeometryN(i);\n  \t\t\t\tthis.updateLocationInfo(this.locateInternal(p, poly));\n  \t\t\t}\n  \t\t} else if (geom instanceof GeometryCollection) {\n  \t\t\tvar geomi = new GeometryCollectionIterator(geom);\n  \t\t\twhile (geomi.hasNext()) {\n  \t\t\t\tvar g2 = geomi.next();\n  \t\t\t\tif (g2 !== geom) this.computeLocation(p, g2);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tlocate: function locate(p, geom) {\n  \t\tif (geom.isEmpty()) return Location.EXTERIOR;\n  \t\tif (geom instanceof LineString) {\n  \t\t\treturn this.locateInternal(p, geom);\n  \t\t} else if (geom instanceof Polygon) {\n  \t\t\treturn this.locateInternal(p, geom);\n  \t\t}\n  \t\tthis._isIn = false;\n  \t\tthis._numBoundaries = 0;\n  \t\tthis.computeLocation(p, geom);\n  \t\tif (this._boundaryRule.isInBoundary(this._numBoundaries)) return Location.BOUNDARY;\n  \t\tif (this._numBoundaries > 0 || this._isIn) return Location.INTERIOR;\n  \t\treturn Location.EXTERIOR;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn PointLocator;\n  \t}\n  });\n\n  function Octant() {}\n  extend(Octant.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Octant;\n  \t}\n  });\n  Octant.octant = function () {\n  \tif (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\") {\n  \t\tvar dx = arguments[0],\n  \t\t    dy = arguments[1];\n  \t\tif (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException(\"Cannot compute the octant for point ( \" + dx + \", \" + dy + \" )\");\n  \t\tvar adx = Math.abs(dx);\n  \t\tvar ady = Math.abs(dy);\n  \t\tif (dx >= 0) {\n  \t\t\tif (dy >= 0) {\n  \t\t\t\tif (adx >= ady) return 0;else return 1;\n  \t\t\t} else {\n  \t\t\t\tif (adx >= ady) return 7;else return 6;\n  \t\t\t}\n  \t\t} else {\n  \t\t\tif (dy >= 0) {\n  \t\t\t\tif (adx >= ady) return 3;else return 2;\n  \t\t\t} else {\n  \t\t\t\tif (adx >= ady) return 4;else return 5;\n  \t\t\t}\n  \t\t}\n  \t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n  \t\tvar p0 = arguments[0],\n  \t\t    p1 = arguments[1];\n  \t\tvar dx = p1.x - p0.x;\n  \t\tvar dy = p1.y - p0.y;\n  \t\tif (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException(\"Cannot compute the octant for two identical points \" + p0);\n  \t\treturn Octant.octant(dx, dy);\n  \t}\n  };\n\n  function SegmentString() {}\n  extend(SegmentString.prototype, {\n  \tgetCoordinates: function getCoordinates() {},\n  \tsize: function size() {},\n  \tgetCoordinate: function getCoordinate(i) {},\n  \tisClosed: function isClosed() {},\n  \tsetData: function setData(data) {},\n  \tgetData: function getData() {},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SegmentString;\n  \t}\n  });\n\n  function BasicSegmentString() {\n  \tthis._pts = null;\n  \tthis._data = null;\n  \tvar pts = arguments[0],\n  \t    data = arguments[1];\n  \tthis._pts = pts;\n  \tthis._data = data;\n  }\n  extend(BasicSegmentString.prototype, {\n  \tgetCoordinates: function getCoordinates() {\n  \t\treturn this._pts;\n  \t},\n  \tsize: function size() {\n  \t\treturn this._pts.length;\n  \t},\n  \tgetCoordinate: function getCoordinate(i) {\n  \t\treturn this._pts[i];\n  \t},\n  \tisClosed: function isClosed() {\n  \t\treturn this._pts[0].equals(this._pts[this._pts.length - 1]);\n  \t},\n  \tgetSegmentOctant: function getSegmentOctant(index) {\n  \t\tif (index === this._pts.length - 1) return -1;\n  \t\treturn Octant.octant(this.getCoordinate(index), this.getCoordinate(index + 1));\n  \t},\n  \tsetData: function setData(data) {\n  \t\tthis._data = data;\n  \t},\n  \tgetData: function getData() {\n  \t\treturn this._data;\n  \t},\n  \ttoString: function toString() {\n  \t\treturn WKTWriter.toLineString(new CoordinateArraySequence(this._pts));\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [SegmentString];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn BasicSegmentString;\n  \t}\n  });\n\n  function Boundable() {}\n  extend(Boundable.prototype, {\n  \tgetBounds: function getBounds() {},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Boundable;\n  \t}\n  });\n\n  function ItemBoundable() {\n  \tthis._bounds = null;\n  \tthis._item = null;\n  \tvar bounds = arguments[0],\n  \t    item = arguments[1];\n  \tthis._bounds = bounds;\n  \tthis._item = item;\n  }\n  extend(ItemBoundable.prototype, {\n  \tgetItem: function getItem() {\n  \t\treturn this._item;\n  \t},\n  \tgetBounds: function getBounds() {\n  \t\treturn this._bounds;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Boundable, Serializable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn ItemBoundable;\n  \t}\n  });\n\n  function PriorityQueue() {\n  \tthis._size = null;\n  \tthis._items = null;\n  \tthis._size = 0;\n  \tthis._items = new ArrayList();\n  \tthis._items.add(null);\n  }\n  extend(PriorityQueue.prototype, {\n  \tpoll: function poll() {\n  \t\tif (this.isEmpty()) return null;\n  \t\tvar minItem = this._items.get(1);\n  \t\tthis._items.set(1, this._items.get(this._size));\n  \t\tthis._size -= 1;\n  \t\tthis.reorder(1);\n  \t\treturn minItem;\n  \t},\n  \tsize: function size() {\n  \t\treturn this._size;\n  \t},\n  \treorder: function reorder(hole) {\n  \t\tvar child = null;\n  \t\tvar tmp = this._items.get(hole);\n  \t\tfor (; hole * 2 <= this._size; hole = child) {\n  \t\t\tchild = hole * 2;\n  \t\t\tif (child !== this._size && this._items.get(child + 1).compareTo(this._items.get(child)) < 0) child++;\n  \t\t\tif (this._items.get(child).compareTo(tmp) < 0) this._items.set(hole, this._items.get(child));else break;\n  \t\t}\n  \t\tthis._items.set(hole, tmp);\n  \t},\n  \tclear: function clear() {\n  \t\tthis._size = 0;\n  \t\tthis._items.clear();\n  \t},\n  \tisEmpty: function isEmpty() {\n  \t\treturn this._size === 0;\n  \t},\n  \tadd: function add(x) {\n  \t\tthis._items.add(null);\n  \t\tthis._size += 1;\n  \t\tvar hole = this._size;\n  \t\tthis._items.set(0, x);\n  \t\tfor (; x.compareTo(this._items.get(Math.trunc(hole / 2))) < 0; hole /= 2) {\n  \t\t\tthis._items.set(hole, this._items.get(Math.trunc(hole / 2)));\n  \t\t}\n  \t\tthis._items.set(hole, x);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn PriorityQueue;\n  \t}\n  });\n\n  function ItemVisitor() {}\n  extend(ItemVisitor.prototype, {\n  \tvisitItem: function visitItem(item) {},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn ItemVisitor;\n  \t}\n  });\n\n  function SpatialIndex() {}\n  extend(SpatialIndex.prototype, {\n  \tinsert: function insert(itemEnv, item) {},\n  \tremove: function remove(itemEnv, item) {},\n  \tquery: function query() {\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SpatialIndex;\n  \t}\n  });\n\n  function AbstractNode() {\n  \tthis._childBoundables = new ArrayList();\n  \tthis._bounds = null;\n  \tthis._level = null;\n  \tif (arguments.length === 0) ; else if (arguments.length === 1) {\n  \t\tvar level = arguments[0];\n  \t\tthis._level = level;\n  \t}\n  }\n  extend(AbstractNode.prototype, {\n  \tgetLevel: function getLevel() {\n  \t\treturn this._level;\n  \t},\n  \tsize: function size() {\n  \t\treturn this._childBoundables.size();\n  \t},\n  \tgetChildBoundables: function getChildBoundables() {\n  \t\treturn this._childBoundables;\n  \t},\n  \taddChildBoundable: function addChildBoundable(childBoundable) {\n  \t\tAssert.isTrue(this._bounds === null);\n  \t\tthis._childBoundables.add(childBoundable);\n  \t},\n  \tisEmpty: function isEmpty() {\n  \t\treturn this._childBoundables.isEmpty();\n  \t},\n  \tgetBounds: function getBounds() {\n  \t\tif (this._bounds === null) {\n  \t\t\tthis._bounds = this.computeBounds();\n  \t\t}\n  \t\treturn this._bounds;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Boundable, Serializable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn AbstractNode;\n  \t}\n  });\n  AbstractNode.serialVersionUID = 6493722185909573708;\n\n  var Collections = {\n    reverseOrder: function reverseOrder() {\n      return {\n        compare: function compare(a, b) {\n          return b.compareTo(a);\n        }\n      };\n    },\n    min: function min(l) {\n      Collections.sort(l);\n      return l.get(0);\n    },\n    sort: function sort(l, c) {\n      var a = l.toArray();\n      if (c) {\n        Arrays.sort(a, c);\n      } else {\n        Arrays.sort(a);\n      }\n      var i = l.iterator();\n      for (var pos = 0, alen = a.length; pos < alen; pos++) {\n        i.next();\n        i.set(a[pos]);\n      }\n    },\n    singletonList: function singletonList(o) {\n      var arrayList = new ArrayList();\n      arrayList.add(o);\n      return arrayList;\n    }\n  };\n\n  function BoundablePair() {\n  \tthis._boundable1 = null;\n  \tthis._boundable2 = null;\n  \tthis._distance = null;\n  \tthis._itemDistance = null;\n  \tvar boundable1 = arguments[0],\n  \t    boundable2 = arguments[1],\n  \t    itemDistance = arguments[2];\n  \tthis._boundable1 = boundable1;\n  \tthis._boundable2 = boundable2;\n  \tthis._itemDistance = itemDistance;\n  \tthis._distance = this.distance();\n  }\n  extend(BoundablePair.prototype, {\n  \texpandToQueue: function expandToQueue(priQ, minDistance) {\n  \t\tvar isComp1 = BoundablePair.isComposite(this._boundable1);\n  \t\tvar isComp2 = BoundablePair.isComposite(this._boundable2);\n  \t\tif (isComp1 && isComp2) {\n  \t\t\tif (BoundablePair.area(this._boundable1) > BoundablePair.area(this._boundable2)) {\n  \t\t\t\tthis.expand(this._boundable1, this._boundable2, priQ, minDistance);\n  \t\t\t\treturn null;\n  \t\t\t} else {\n  \t\t\t\tthis.expand(this._boundable2, this._boundable1, priQ, minDistance);\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t} else if (isComp1) {\n  \t\t\tthis.expand(this._boundable1, this._boundable2, priQ, minDistance);\n  \t\t\treturn null;\n  \t\t} else if (isComp2) {\n  \t\t\tthis.expand(this._boundable2, this._boundable1, priQ, minDistance);\n  \t\t\treturn null;\n  \t\t}\n  \t\tthrow new IllegalArgumentException(\"neither boundable is composite\");\n  \t},\n  \tisLeaves: function isLeaves() {\n  \t\treturn !(BoundablePair.isComposite(this._boundable1) || BoundablePair.isComposite(this._boundable2));\n  \t},\n  \tcompareTo: function compareTo(o) {\n  \t\tvar nd = o;\n  \t\tif (this._distance < nd._distance) return -1;\n  \t\tif (this._distance > nd._distance) return 1;\n  \t\treturn 0;\n  \t},\n  \texpand: function expand(bndComposite, bndOther, priQ, minDistance) {\n  \t\tvar children = bndComposite.getChildBoundables();\n  \t\tfor (var i = children.iterator(); i.hasNext();) {\n  \t\t\tvar child = i.next();\n  \t\t\tvar bp = new BoundablePair(child, bndOther, this._itemDistance);\n  \t\t\tif (bp.getDistance() < minDistance) {\n  \t\t\t\tpriQ.add(bp);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetBoundable: function getBoundable(i) {\n  \t\tif (i === 0) return this._boundable1;\n  \t\treturn this._boundable2;\n  \t},\n  \tgetDistance: function getDistance() {\n  \t\treturn this._distance;\n  \t},\n  \tdistance: function distance() {\n  \t\tif (this.isLeaves()) {\n  \t\t\treturn this._itemDistance.distance(this._boundable1, this._boundable2);\n  \t\t}\n  \t\treturn this._boundable1.getBounds().distance(this._boundable2.getBounds());\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn BoundablePair;\n  \t}\n  });\n  BoundablePair.area = function (b) {\n  \treturn b.getBounds().getArea();\n  };\n  BoundablePair.isComposite = function (item) {\n  \treturn item instanceof AbstractNode;\n  };\n\n  function AbstractSTRtree() {\n  \tthis._root = null;\n  \tthis._built = false;\n  \tthis._itemBoundables = new ArrayList();\n  \tthis._nodeCapacity = null;\n  \tif (arguments.length === 0) {\n  \t\tAbstractSTRtree.call(this, AbstractSTRtree.DEFAULT_NODE_CAPACITY);\n  \t} else if (arguments.length === 1) {\n  \t\tvar nodeCapacity = arguments[0];\n  \t\tAssert.isTrue(nodeCapacity > 1, \"Node capacity must be greater than 1\");\n  \t\tthis._nodeCapacity = nodeCapacity;\n  \t}\n  }\n  extend(AbstractSTRtree.prototype, {\n  \tgetNodeCapacity: function getNodeCapacity() {\n  \t\treturn this._nodeCapacity;\n  \t},\n  \tlastNode: function lastNode(nodes) {\n  \t\treturn nodes.get(nodes.size() - 1);\n  \t},\n  \tsize: function size() {\n  \t\tif (arguments.length === 0) {\n  \t\t\tif (this.isEmpty()) {\n  \t\t\t\treturn 0;\n  \t\t\t}\n  \t\t\tthis.build();\n  \t\t\treturn this.size(this._root);\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tvar node = arguments[0];\n  \t\t\tvar size = 0;\n  \t\t\tfor (var i = node.getChildBoundables().iterator(); i.hasNext();) {\n  \t\t\t\tvar childBoundable = i.next();\n  \t\t\t\tif (childBoundable instanceof AbstractNode) {\n  \t\t\t\t\tsize += this.size(childBoundable);\n  \t\t\t\t} else if (childBoundable instanceof ItemBoundable) {\n  \t\t\t\t\tsize += 1;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\treturn size;\n  \t\t}\n  \t},\n  \tremoveItem: function removeItem(node, item) {\n  \t\tvar childToRemove = null;\n  \t\tfor (var i = node.getChildBoundables().iterator(); i.hasNext();) {\n  \t\t\tvar childBoundable = i.next();\n  \t\t\tif (childBoundable instanceof ItemBoundable) {\n  \t\t\t\tif (childBoundable.getItem() === item) childToRemove = childBoundable;\n  \t\t\t}\n  \t\t}\n  \t\tif (childToRemove !== null) {\n  \t\t\tnode.getChildBoundables().remove(childToRemove);\n  \t\t\treturn true;\n  \t\t}\n  \t\treturn false;\n  \t},\n  \titemsTree: function itemsTree() {\n  \t\tif (arguments.length === 0) {\n  \t\t\tthis.build();\n  \t\t\tvar valuesTree = this.itemsTree(this._root);\n  \t\t\tif (valuesTree === null) return new ArrayList();\n  \t\t\treturn valuesTree;\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tvar node = arguments[0];\n  \t\t\tvar valuesTreeForNode = new ArrayList();\n  \t\t\tfor (var i = node.getChildBoundables().iterator(); i.hasNext();) {\n  \t\t\t\tvar childBoundable = i.next();\n  \t\t\t\tif (childBoundable instanceof AbstractNode) {\n  \t\t\t\t\tvar valuesTreeForChild = this.itemsTree(childBoundable);\n  \t\t\t\t\tif (valuesTreeForChild !== null) valuesTreeForNode.add(valuesTreeForChild);\n  \t\t\t\t} else if (childBoundable instanceof ItemBoundable) {\n  \t\t\t\t\tvaluesTreeForNode.add(childBoundable.getItem());\n  \t\t\t\t} else {\n  \t\t\t\t\tAssert.shouldNeverReachHere();\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\tif (valuesTreeForNode.size() <= 0) return null;\n  \t\t\treturn valuesTreeForNode;\n  \t\t}\n  \t},\n  \tinsert: function insert(bounds, item) {\n  \t\tAssert.isTrue(!this._built, \"Cannot insert items into an STR packed R-tree after it has been built.\");\n  \t\tthis._itemBoundables.add(new ItemBoundable(bounds, item));\n  \t},\n  \tboundablesAtLevel: function boundablesAtLevel() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar level = arguments[0];\n  \t\t\tvar boundables = new ArrayList();\n  \t\t\tthis.boundablesAtLevel(level, this._root, boundables);\n  \t\t\treturn boundables;\n  \t\t} else if (arguments.length === 3) {\n  \t\t\tvar level = arguments[0],\n  \t\t\t    top = arguments[1],\n  \t\t\t    boundables = arguments[2];\n  \t\t\tAssert.isTrue(level > -2);\n  \t\t\tif (top.getLevel() === level) {\n  \t\t\t\tboundables.add(top);\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t\tfor (var i = top.getChildBoundables().iterator(); i.hasNext();) {\n  \t\t\t\tvar boundable = i.next();\n  \t\t\t\tif (boundable instanceof AbstractNode) {\n  \t\t\t\t\tthis.boundablesAtLevel(level, boundable, boundables);\n  \t\t\t\t} else {\n  \t\t\t\t\tAssert.isTrue(boundable instanceof ItemBoundable);\n  \t\t\t\t\tif (level === -1) {\n  \t\t\t\t\t\tboundables.add(boundable);\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\treturn null;\n  \t\t}\n  \t},\n  \tquery: function query() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar searchBounds = arguments[0];\n  \t\t\tthis.build();\n  \t\t\tvar matches = new ArrayList();\n  \t\t\tif (this.isEmpty()) {\n  \t\t\t\treturn matches;\n  \t\t\t}\n  \t\t\tif (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {\n  \t\t\t\tthis.query(searchBounds, this._root, matches);\n  \t\t\t}\n  \t\t\treturn matches;\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar searchBounds = arguments[0],\n  \t\t\t    visitor = arguments[1];\n  \t\t\tthis.build();\n  \t\t\tif (this.isEmpty()) {\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t\tif (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {\n  \t\t\t\tthis.query(searchBounds, this._root, visitor);\n  \t\t\t}\n  \t\t} else if (arguments.length === 3) {\n  \t\t\tif (hasInterface(arguments[2], ItemVisitor) && arguments[0] instanceof Object && arguments[1] instanceof AbstractNode) {\n  \t\t\t\tvar searchBounds = arguments[0],\n  \t\t\t\t    node = arguments[1],\n  \t\t\t\t    visitor = arguments[2];\n  \t\t\t\tvar childBoundables = node.getChildBoundables();\n  \t\t\t\tfor (var i = 0; i < childBoundables.size(); i++) {\n  \t\t\t\t\tvar childBoundable = childBoundables.get(i);\n  \t\t\t\t\tif (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) {\n  \t\t\t\t\t\tcontinue;\n  \t\t\t\t\t}\n  \t\t\t\t\tif (childBoundable instanceof AbstractNode) {\n  \t\t\t\t\t\tthis.query(searchBounds, childBoundable, visitor);\n  \t\t\t\t\t} else if (childBoundable instanceof ItemBoundable) {\n  \t\t\t\t\t\tvisitor.visitItem(childBoundable.getItem());\n  \t\t\t\t\t} else {\n  \t\t\t\t\t\tAssert.shouldNeverReachHere();\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t} else if (hasInterface(arguments[2], List) && arguments[0] instanceof Object && arguments[1] instanceof AbstractNode) {\n  \t\t\t\tvar searchBounds = arguments[0],\n  \t\t\t\t    node = arguments[1],\n  \t\t\t\t    matches = arguments[2];\n  \t\t\t\tvar childBoundables = node.getChildBoundables();\n  \t\t\t\tfor (var i = 0; i < childBoundables.size(); i++) {\n  \t\t\t\t\tvar childBoundable = childBoundables.get(i);\n  \t\t\t\t\tif (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) {\n  \t\t\t\t\t\tcontinue;\n  \t\t\t\t\t}\n  \t\t\t\t\tif (childBoundable instanceof AbstractNode) {\n  \t\t\t\t\t\tthis.query(searchBounds, childBoundable, matches);\n  \t\t\t\t\t} else if (childBoundable instanceof ItemBoundable) {\n  \t\t\t\t\t\tmatches.add(childBoundable.getItem());\n  \t\t\t\t\t} else {\n  \t\t\t\t\t\tAssert.shouldNeverReachHere();\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tbuild: function build() {\n  \t\tif (this._built) return null;\n  \t\tthis._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1);\n  \t\tthis._itemBoundables = null;\n  \t\tthis._built = true;\n  \t},\n  \tgetRoot: function getRoot() {\n  \t\tthis.build();\n  \t\treturn this._root;\n  \t},\n  \tremove: function remove() {\n  \t\tif (arguments.length === 2) {\n  \t\t\tvar searchBounds = arguments[0],\n  \t\t\t    item = arguments[1];\n  \t\t\tthis.build();\n  \t\t\tif (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {\n  \t\t\t\treturn this.remove(searchBounds, this._root, item);\n  \t\t\t}\n  \t\t\treturn false;\n  \t\t} else if (arguments.length === 3) {\n  \t\t\tvar searchBounds = arguments[0],\n  \t\t\t    node = arguments[1],\n  \t\t\t    item = arguments[2];\n  \t\t\tvar found = this.removeItem(node, item);\n  \t\t\tif (found) return true;\n  \t\t\tvar childToPrune = null;\n  \t\t\tfor (var i = node.getChildBoundables().iterator(); i.hasNext();) {\n  \t\t\t\tvar childBoundable = i.next();\n  \t\t\t\tif (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) {\n  \t\t\t\t\tcontinue;\n  \t\t\t\t}\n  \t\t\t\tif (childBoundable instanceof AbstractNode) {\n  \t\t\t\t\tfound = this.remove(searchBounds, childBoundable, item);\n  \t\t\t\t\tif (found) {\n  \t\t\t\t\t\tchildToPrune = childBoundable;\n  \t\t\t\t\t\tbreak;\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\tif (childToPrune !== null) {\n  \t\t\t\tif (childToPrune.getChildBoundables().isEmpty()) {\n  \t\t\t\t\tnode.getChildBoundables().remove(childToPrune);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\treturn found;\n  \t\t}\n  \t},\n  \tcreateHigherLevels: function createHigherLevels(boundablesOfALevel, level) {\n  \t\tAssert.isTrue(!boundablesOfALevel.isEmpty());\n  \t\tvar parentBoundables = this.createParentBoundables(boundablesOfALevel, level + 1);\n  \t\tif (parentBoundables.size() === 1) {\n  \t\t\treturn parentBoundables.get(0);\n  \t\t}\n  \t\treturn this.createHigherLevels(parentBoundables, level + 1);\n  \t},\n  \tdepth: function depth() {\n  \t\tif (arguments.length === 0) {\n  \t\t\tif (this.isEmpty()) {\n  \t\t\t\treturn 0;\n  \t\t\t}\n  \t\t\tthis.build();\n  \t\t\treturn this.depth(this._root);\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tvar node = arguments[0];\n  \t\t\tvar maxChildDepth = 0;\n  \t\t\tfor (var i = node.getChildBoundables().iterator(); i.hasNext();) {\n  \t\t\t\tvar childBoundable = i.next();\n  \t\t\t\tif (childBoundable instanceof AbstractNode) {\n  \t\t\t\t\tvar childDepth = this.depth(childBoundable);\n  \t\t\t\t\tif (childDepth > maxChildDepth) maxChildDepth = childDepth;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\treturn maxChildDepth + 1;\n  \t\t}\n  \t},\n  \tcreateParentBoundables: function createParentBoundables(childBoundables, newLevel) {\n  \t\tAssert.isTrue(!childBoundables.isEmpty());\n  \t\tvar parentBoundables = new ArrayList();\n  \t\tparentBoundables.add(this.createNode(newLevel));\n  \t\tvar sortedChildBoundables = new ArrayList(childBoundables);\n  \t\tCollections.sort(sortedChildBoundables, this.getComparator());\n  \t\tfor (var i = sortedChildBoundables.iterator(); i.hasNext();) {\n  \t\t\tvar childBoundable = i.next();\n  \t\t\tif (this.lastNode(parentBoundables).getChildBoundables().size() === this.getNodeCapacity()) {\n  \t\t\t\tparentBoundables.add(this.createNode(newLevel));\n  \t\t\t}\n  \t\t\tthis.lastNode(parentBoundables).addChildBoundable(childBoundable);\n  \t\t}\n  \t\treturn parentBoundables;\n  \t},\n  \tisEmpty: function isEmpty() {\n  \t\tif (!this._built) return this._itemBoundables.isEmpty();\n  \t\treturn this._root.isEmpty();\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Serializable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn AbstractSTRtree;\n  \t}\n  });\n  AbstractSTRtree.compareDoubles = function (a, b) {\n  \treturn a > b ? 1 : a < b ? -1 : 0;\n  };\n  function IntersectsOp$1() {}\n  AbstractSTRtree.IntersectsOp = IntersectsOp$1;\n  AbstractSTRtree.serialVersionUID = -3886435814360241337;\n  AbstractSTRtree.DEFAULT_NODE_CAPACITY = 10;\n\n  function ItemDistance() {}\n  extend(ItemDistance.prototype, {\n  \tdistance: function distance(item1, item2) {},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn ItemDistance;\n  \t}\n  });\n\n  function STRtree() {\n  \tif (arguments.length === 0) {\n  \t\tSTRtree.call(this, STRtree.DEFAULT_NODE_CAPACITY);\n  \t} else if (arguments.length === 1) {\n  \t\tvar nodeCapacity = arguments[0];\n  \t\tAbstractSTRtree.call(this, nodeCapacity);\n  \t}\n  }\n  inherits$1(STRtree, AbstractSTRtree);\n  extend(STRtree.prototype, {\n  \tcreateParentBoundablesFromVerticalSlices: function createParentBoundablesFromVerticalSlices(verticalSlices, newLevel) {\n  \t\tAssert.isTrue(verticalSlices.length > 0);\n  \t\tvar parentBoundables = new ArrayList();\n  \t\tfor (var i = 0; i < verticalSlices.length; i++) {\n  \t\t\tparentBoundables.addAll(this.createParentBoundablesFromVerticalSlice(verticalSlices[i], newLevel));\n  \t\t}\n  \t\treturn parentBoundables;\n  \t},\n  \tcreateNode: function createNode(level) {\n  \t\treturn new STRtreeNode(level);\n  \t},\n  \tsize: function size() {\n  \t\tif (arguments.length === 0) {\n  \t\t\treturn AbstractSTRtree.prototype.size.call(this);\n  \t\t} else return AbstractSTRtree.prototype.size.apply(this, arguments);\n  \t},\n  \tinsert: function insert() {\n  \t\tif (arguments.length === 2) {\n  \t\t\tvar itemEnv = arguments[0],\n  \t\t\t    item = arguments[1];\n  \t\t\tif (itemEnv.isNull()) {\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t\tAbstractSTRtree.prototype.insert.call(this, itemEnv, item);\n  \t\t} else return AbstractSTRtree.prototype.insert.apply(this, arguments);\n  \t},\n  \tgetIntersectsOp: function getIntersectsOp() {\n  \t\treturn STRtree.intersectsOp;\n  \t},\n  \tverticalSlices: function verticalSlices(childBoundables, sliceCount) {\n  \t\tvar sliceCapacity = Math.trunc(Math.ceil(childBoundables.size() / sliceCount));\n  \t\tvar slices = new Array(sliceCount).fill(null);\n  \t\tvar i = childBoundables.iterator();\n  \t\tfor (var j = 0; j < sliceCount; j++) {\n  \t\t\tslices[j] = new ArrayList();\n  \t\t\tvar boundablesAddedToSlice = 0;\n  \t\t\twhile (i.hasNext() && boundablesAddedToSlice < sliceCapacity) {\n  \t\t\t\tvar childBoundable = i.next();\n  \t\t\t\tslices[j].add(childBoundable);\n  \t\t\t\tboundablesAddedToSlice++;\n  \t\t\t}\n  \t\t}\n  \t\treturn slices;\n  \t},\n  \tquery: function query() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar searchEnv = arguments[0];\n  \t\t\treturn AbstractSTRtree.prototype.query.call(this, searchEnv);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar searchEnv = arguments[0],\n  \t\t\t    visitor = arguments[1];\n  \t\t\tAbstractSTRtree.prototype.query.call(this, searchEnv, visitor);\n  \t\t} else if (arguments.length === 3) {\n  \t\t\tif (hasInterface(arguments[2], ItemVisitor) && arguments[0] instanceof Object && arguments[1] instanceof AbstractNode) {\n  \t\t\t\tvar searchBounds = arguments[0],\n  \t\t\t\t    node = arguments[1],\n  \t\t\t\t    visitor = arguments[2];\n  \t\t\t\tAbstractSTRtree.prototype.query.call(this, searchBounds, node, visitor);\n  \t\t\t} else if (hasInterface(arguments[2], List) && arguments[0] instanceof Object && arguments[1] instanceof AbstractNode) {\n  \t\t\t\tvar searchBounds = arguments[0],\n  \t\t\t\t    node = arguments[1],\n  \t\t\t\t    matches = arguments[2];\n  \t\t\t\tAbstractSTRtree.prototype.query.call(this, searchBounds, node, matches);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetComparator: function getComparator() {\n  \t\treturn STRtree.yComparator;\n  \t},\n  \tcreateParentBoundablesFromVerticalSlice: function createParentBoundablesFromVerticalSlice(childBoundables, newLevel) {\n  \t\treturn AbstractSTRtree.prototype.createParentBoundables.call(this, childBoundables, newLevel);\n  \t},\n  \tremove: function remove() {\n  \t\tif (arguments.length === 2) {\n  \t\t\tvar itemEnv = arguments[0],\n  \t\t\t    item = arguments[1];\n  \t\t\treturn AbstractSTRtree.prototype.remove.call(this, itemEnv, item);\n  \t\t} else return AbstractSTRtree.prototype.remove.apply(this, arguments);\n  \t},\n  \tdepth: function depth() {\n  \t\tif (arguments.length === 0) {\n  \t\t\treturn AbstractSTRtree.prototype.depth.call(this);\n  \t\t} else return AbstractSTRtree.prototype.depth.apply(this, arguments);\n  \t},\n  \tcreateParentBoundables: function createParentBoundables(childBoundables, newLevel) {\n  \t\tAssert.isTrue(!childBoundables.isEmpty());\n  \t\tvar minLeafCount = Math.trunc(Math.ceil(childBoundables.size() / this.getNodeCapacity()));\n  \t\tvar sortedChildBoundables = new ArrayList(childBoundables);\n  \t\tCollections.sort(sortedChildBoundables, STRtree.xComparator);\n  \t\tvar verticalSlices = this.verticalSlices(sortedChildBoundables, Math.trunc(Math.ceil(Math.sqrt(minLeafCount))));\n  \t\treturn this.createParentBoundablesFromVerticalSlices(verticalSlices, newLevel);\n  \t},\n  \tnearestNeighbour: function nearestNeighbour() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tif (hasInterface(arguments[0], ItemDistance)) {\n  \t\t\t\tvar itemDist = arguments[0];\n  \t\t\t\tvar bp = new BoundablePair(this.getRoot(), this.getRoot(), itemDist);\n  \t\t\t\treturn this.nearestNeighbour(bp);\n  \t\t\t} else if (arguments[0] instanceof BoundablePair) {\n  \t\t\t\tvar initBndPair = arguments[0];\n  \t\t\t\treturn this.nearestNeighbour(initBndPair, Double.POSITIVE_INFINITY);\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tif (arguments[0] instanceof STRtree && hasInterface(arguments[1], ItemDistance)) {\n  \t\t\t\tvar tree = arguments[0],\n  \t\t\t\t    itemDist = arguments[1];\n  \t\t\t\tvar bp = new BoundablePair(this.getRoot(), tree.getRoot(), itemDist);\n  \t\t\t\treturn this.nearestNeighbour(bp);\n  \t\t\t} else if (arguments[0] instanceof BoundablePair && typeof arguments[1] === \"number\") {\n  \t\t\t\tvar initBndPair = arguments[0],\n  \t\t\t\t    maxDistance = arguments[1];\n  \t\t\t\tvar distanceLowerBound = maxDistance;\n  \t\t\t\tvar minPair = null;\n  \t\t\t\tvar priQ = new PriorityQueue();\n  \t\t\t\tpriQ.add(initBndPair);\n  \t\t\t\twhile (!priQ.isEmpty() && distanceLowerBound > 0.0) {\n  \t\t\t\t\tvar bndPair = priQ.poll();\n  \t\t\t\t\tvar currentDistance = bndPair.getDistance();\n  \t\t\t\t\tif (currentDistance >= distanceLowerBound) break;\n  \t\t\t\t\tif (bndPair.isLeaves()) {\n  \t\t\t\t\t\tdistanceLowerBound = currentDistance;\n  \t\t\t\t\t\tminPair = bndPair;\n  \t\t\t\t\t} else {\n  \t\t\t\t\t\tbndPair.expandToQueue(priQ, distanceLowerBound);\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t\treturn [minPair.getBoundable(0).getItem(), minPair.getBoundable(1).getItem()];\n  \t\t\t}\n  \t\t} else if (arguments.length === 3) {\n  \t\t\tvar env = arguments[0],\n  \t\t\t    item = arguments[1],\n  \t\t\t    itemDist = arguments[2];\n  \t\t\tvar bnd = new ItemBoundable(env, item);\n  \t\t\tvar bp = new BoundablePair(this.getRoot(), bnd, itemDist);\n  \t\t\treturn this.nearestNeighbour(bp)[0];\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [SpatialIndex, Serializable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn STRtree;\n  \t}\n  });\n  STRtree.centreX = function (e) {\n  \treturn STRtree.avg(e.getMinX(), e.getMaxX());\n  };\n  STRtree.avg = function (a, b) {\n  \treturn (a + b) / 2;\n  };\n  STRtree.centreY = function (e) {\n  \treturn STRtree.avg(e.getMinY(), e.getMaxY());\n  };\n  function STRtreeNode() {\n  \tvar level = arguments[0];\n  \tAbstractNode.call(this, level);\n  }\n  inherits$1(STRtreeNode, AbstractNode);\n  extend(STRtreeNode.prototype, {\n  \tcomputeBounds: function computeBounds() {\n  \t\tvar bounds = null;\n  \t\tfor (var i = this.getChildBoundables().iterator(); i.hasNext();) {\n  \t\t\tvar childBoundable = i.next();\n  \t\t\tif (bounds === null) {\n  \t\t\t\tbounds = new Envelope(childBoundable.getBounds());\n  \t\t\t} else {\n  \t\t\t\tbounds.expandToInclude(childBoundable.getBounds());\n  \t\t\t}\n  \t\t}\n  \t\treturn bounds;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn STRtreeNode;\n  \t}\n  });\n  STRtree.STRtreeNode = STRtreeNode;\n  STRtree.serialVersionUID = 259274702368956900;\n  STRtree.xComparator = {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparator];\n  \t},\n  \tcompare: function compare(o1, o2) {\n  \t\treturn AbstractSTRtree.compareDoubles(STRtree.centreX(o1.getBounds()), STRtree.centreX(o2.getBounds()));\n  \t}\n  };\n  STRtree.yComparator = {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparator];\n  \t},\n  \tcompare: function compare(o1, o2) {\n  \t\treturn AbstractSTRtree.compareDoubles(STRtree.centreY(o1.getBounds()), STRtree.centreY(o2.getBounds()));\n  \t}\n  };\n  STRtree.intersectsOp = {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [IntersectsOp];\n  \t},\n  \tintersects: function intersects(aBounds, bBounds) {\n  \t\treturn aBounds.intersects(bBounds);\n  \t}\n  };\n  STRtree.DEFAULT_NODE_CAPACITY = 10;\n\n  function SegmentPointComparator() {}\n  extend(SegmentPointComparator.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SegmentPointComparator;\n  \t}\n  });\n  SegmentPointComparator.relativeSign = function (x0, x1) {\n  \tif (x0 < x1) return -1;\n  \tif (x0 > x1) return 1;\n  \treturn 0;\n  };\n  SegmentPointComparator.compare = function (octant, p0, p1) {\n  \tif (p0.equals2D(p1)) return 0;\n  \tvar xSign = SegmentPointComparator.relativeSign(p0.x, p1.x);\n  \tvar ySign = SegmentPointComparator.relativeSign(p0.y, p1.y);\n  \tswitch (octant) {\n  \t\tcase 0:\n  \t\t\treturn SegmentPointComparator.compareValue(xSign, ySign);\n  \t\tcase 1:\n  \t\t\treturn SegmentPointComparator.compareValue(ySign, xSign);\n  \t\tcase 2:\n  \t\t\treturn SegmentPointComparator.compareValue(ySign, -xSign);\n  \t\tcase 3:\n  \t\t\treturn SegmentPointComparator.compareValue(-xSign, ySign);\n  \t\tcase 4:\n  \t\t\treturn SegmentPointComparator.compareValue(-xSign, -ySign);\n  \t\tcase 5:\n  \t\t\treturn SegmentPointComparator.compareValue(-ySign, -xSign);\n  \t\tcase 6:\n  \t\t\treturn SegmentPointComparator.compareValue(-ySign, xSign);\n  \t\tcase 7:\n  \t\t\treturn SegmentPointComparator.compareValue(xSign, -ySign);\n  \t}\n  \tAssert.shouldNeverReachHere(\"invalid octant value\");\n  \treturn 0;\n  };\n  SegmentPointComparator.compareValue = function (compareSign0, compareSign1) {\n  \tif (compareSign0 < 0) return -1;\n  \tif (compareSign0 > 0) return 1;\n  \tif (compareSign1 < 0) return -1;\n  \tif (compareSign1 > 0) return 1;\n  \treturn 0;\n  };\n\n  function SegmentNode() {\n  \tthis._segString = null;\n  \tthis.coord = null;\n  \tthis.segmentIndex = null;\n  \tthis._segmentOctant = null;\n  \tthis._isInterior = null;\n  \tvar segString = arguments[0],\n  \t    coord = arguments[1],\n  \t    segmentIndex = arguments[2],\n  \t    segmentOctant = arguments[3];\n  \tthis._segString = segString;\n  \tthis.coord = new Coordinate(coord);\n  \tthis.segmentIndex = segmentIndex;\n  \tthis._segmentOctant = segmentOctant;\n  \tthis._isInterior = !coord.equals2D(segString.getCoordinate(segmentIndex));\n  }\n  extend(SegmentNode.prototype, {\n  \tgetCoordinate: function getCoordinate() {\n  \t\treturn this.coord;\n  \t},\n  \tprint: function print(out) {\n  \t\tout.print(this.coord);\n  \t\tout.print(\" seg # = \" + this.segmentIndex);\n  \t},\n  \tcompareTo: function compareTo(obj) {\n  \t\tvar other = obj;\n  \t\tif (this.segmentIndex < other.segmentIndex) return -1;\n  \t\tif (this.segmentIndex > other.segmentIndex) return 1;\n  \t\tif (this.coord.equals2D(other.coord)) return 0;\n  \t\treturn SegmentPointComparator.compare(this._segmentOctant, this.coord, other.coord);\n  \t},\n  \tisEndPoint: function isEndPoint(maxSegmentIndex) {\n  \t\tif (this.segmentIndex === 0 && !this._isInterior) return true;\n  \t\tif (this.segmentIndex === maxSegmentIndex) return true;\n  \t\treturn false;\n  \t},\n  \tisInterior: function isInterior() {\n  \t\treturn this._isInterior;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SegmentNode;\n  \t}\n  });\n\n  function SegmentNodeList() {\n  \tthis._nodeMap = new TreeMap();\n  \tthis._edge = null;\n  \tvar edge = arguments[0];\n  \tthis._edge = edge;\n  }\n  extend(SegmentNodeList.prototype, {\n  \tgetSplitCoordinates: function getSplitCoordinates() {\n  \t\tvar coordList = new CoordinateList();\n  \t\tthis.addEndpoints();\n  \t\tvar it = this.iterator();\n  \t\tvar eiPrev = it.next();\n  \t\twhile (it.hasNext()) {\n  \t\t\tvar ei = it.next();\n  \t\t\tthis.addEdgeCoordinates(eiPrev, ei, coordList);\n  \t\t\teiPrev = ei;\n  \t\t}\n  \t\treturn coordList.toCoordinateArray();\n  \t},\n  \taddCollapsedNodes: function addCollapsedNodes() {\n  \t\tvar collapsedVertexIndexes = new ArrayList();\n  \t\tthis.findCollapsesFromInsertedNodes(collapsedVertexIndexes);\n  \t\tthis.findCollapsesFromExistingVertices(collapsedVertexIndexes);\n  \t\tfor (var it = collapsedVertexIndexes.iterator(); it.hasNext();) {\n  \t\t\tvar vertexIndex = it.next().intValue();\n  \t\t\tthis.add(this._edge.getCoordinate(vertexIndex), vertexIndex);\n  \t\t}\n  \t},\n  \tprint: function print(out) {\n  \t\tout.println(\"Intersections:\");\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar ei = it.next();\n  \t\t\tei.print(out);\n  \t\t}\n  \t},\n  \tfindCollapsesFromExistingVertices: function findCollapsesFromExistingVertices(collapsedVertexIndexes) {\n  \t\tfor (var i = 0; i < this._edge.size() - 2; i++) {\n  \t\t\tvar p0 = this._edge.getCoordinate(i);\n  \t\t\tvar p1 = this._edge.getCoordinate(i + 1);\n  \t\t\tvar p2 = this._edge.getCoordinate(i + 2);\n  \t\t\tif (p0.equals2D(p2)) {\n  \t\t\t\tcollapsedVertexIndexes.add(new Integer(i + 1));\n  \t\t\t}\n  \t\t}\n  \t},\n  \taddEdgeCoordinates: function addEdgeCoordinates(ei0, ei1, coordList) {\n  \t\tvar npts = ei1.segmentIndex - ei0.segmentIndex + 2;\n  \t\tvar lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);\n  \t\tvar useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);\n  \t\tif (!useIntPt1) {\n  \t\t\tnpts--;\n  \t\t}\n  \t\tcoordList.add(new Coordinate(ei0.coord), false);\n  \t\tfor (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {\n  \t\t\tcoordList.add(this._edge.getCoordinate(i));\n  \t\t}\n  \t\tif (useIntPt1) {\n  \t\t\tcoordList.add(new Coordinate(ei1.coord));\n  \t\t}\n  \t},\n  \titerator: function iterator() {\n  \t\treturn this._nodeMap.values().iterator();\n  \t},\n  \taddSplitEdges: function addSplitEdges(edgeList) {\n  \t\tthis.addEndpoints();\n  \t\tthis.addCollapsedNodes();\n  \t\tvar it = this.iterator();\n  \t\tvar eiPrev = it.next();\n  \t\twhile (it.hasNext()) {\n  \t\t\tvar ei = it.next();\n  \t\t\tvar newEdge = this.createSplitEdge(eiPrev, ei);\n  \t\t\tedgeList.add(newEdge);\n  \t\t\teiPrev = ei;\n  \t\t}\n  \t},\n  \tfindCollapseIndex: function findCollapseIndex(ei0, ei1, collapsedVertexIndex) {\n  \t\tif (!ei0.coord.equals2D(ei1.coord)) return false;\n  \t\tvar numVerticesBetween = ei1.segmentIndex - ei0.segmentIndex;\n  \t\tif (!ei1.isInterior()) {\n  \t\t\tnumVerticesBetween--;\n  \t\t}\n  \t\tif (numVerticesBetween === 1) {\n  \t\t\tcollapsedVertexIndex[0] = ei0.segmentIndex + 1;\n  \t\t\treturn true;\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tfindCollapsesFromInsertedNodes: function findCollapsesFromInsertedNodes(collapsedVertexIndexes) {\n  \t\tvar collapsedVertexIndex = new Array(1).fill(null);\n  \t\tvar it = this.iterator();\n  \t\tvar eiPrev = it.next();\n  \t\twhile (it.hasNext()) {\n  \t\t\tvar ei = it.next();\n  \t\t\tvar isCollapsed = this.findCollapseIndex(eiPrev, ei, collapsedVertexIndex);\n  \t\t\tif (isCollapsed) collapsedVertexIndexes.add(new Integer(collapsedVertexIndex[0]));\n  \t\t\teiPrev = ei;\n  \t\t}\n  \t},\n  \tgetEdge: function getEdge() {\n  \t\treturn this._edge;\n  \t},\n  \taddEndpoints: function addEndpoints() {\n  \t\tvar maxSegIndex = this._edge.size() - 1;\n  \t\tthis.add(this._edge.getCoordinate(0), 0);\n  \t\tthis.add(this._edge.getCoordinate(maxSegIndex), maxSegIndex);\n  \t},\n  \tcreateSplitEdge: function createSplitEdge(ei0, ei1) {\n  \t\tvar npts = ei1.segmentIndex - ei0.segmentIndex + 2;\n  \t\tvar lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);\n  \t\tvar useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);\n  \t\tif (!useIntPt1) {\n  \t\t\tnpts--;\n  \t\t}\n  \t\tvar pts = new Array(npts).fill(null);\n  \t\tvar ipt = 0;\n  \t\tpts[ipt++] = new Coordinate(ei0.coord);\n  \t\tfor (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {\n  \t\t\tpts[ipt++] = this._edge.getCoordinate(i);\n  \t\t}\n  \t\tif (useIntPt1) pts[ipt] = new Coordinate(ei1.coord);\n  \t\treturn new NodedSegmentString(pts, this._edge.getData());\n  \t},\n  \tadd: function add(intPt, segmentIndex) {\n  \t\tvar eiNew = new SegmentNode(this._edge, intPt, segmentIndex, this._edge.getSegmentOctant(segmentIndex));\n  \t\tvar ei = this._nodeMap.get(eiNew);\n  \t\tif (ei !== null) {\n  \t\t\tAssert.isTrue(ei.coord.equals2D(intPt), \"Found equal nodes with different coordinates\");\n  \t\t\treturn ei;\n  \t\t}\n  \t\tthis._nodeMap.put(eiNew, eiNew);\n  \t\treturn eiNew;\n  \t},\n  \tcheckSplitEdgesCorrectness: function checkSplitEdgesCorrectness(splitEdges) {\n  \t\tvar edgePts = this._edge.getCoordinates();\n  \t\tvar split0 = splitEdges.get(0);\n  \t\tvar pt0 = split0.getCoordinate(0);\n  \t\tif (!pt0.equals2D(edgePts[0])) throw new RuntimeException(\"bad split edge start point at \" + pt0);\n  \t\tvar splitn = splitEdges.get(splitEdges.size() - 1);\n  \t\tvar splitnPts = splitn.getCoordinates();\n  \t\tvar ptn = splitnPts[splitnPts.length - 1];\n  \t\tif (!ptn.equals2D(edgePts[edgePts.length - 1])) throw new RuntimeException(\"bad split edge end point at \" + ptn);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SegmentNodeList;\n  \t}\n  });\n  function NodeVertexIterator() {\n  \tthis._nodeList = null;\n  \tthis._edge = null;\n  \tthis._nodeIt = null;\n  \tthis._currNode = null;\n  \tthis._nextNode = null;\n  \tthis._currSegIndex = 0;\n  \tvar nodeList = arguments[0];\n  \tthis._nodeList = nodeList;\n  \tthis._edge = nodeList.getEdge();\n  \tthis._nodeIt = nodeList.iterator();\n  \tthis.readNextNode();\n  }\n  extend(NodeVertexIterator.prototype, {\n  \tnext: function next() {\n  \t\tif (this._currNode === null) {\n  \t\t\tthis._currNode = this._nextNode;\n  \t\t\tthis._currSegIndex = this._currNode.segmentIndex;\n  \t\t\tthis.readNextNode();\n  \t\t\treturn this._currNode;\n  \t\t}\n  \t\tif (this._nextNode === null) return null;\n  \t\tif (this._nextNode.segmentIndex === this._currNode.segmentIndex) {\n  \t\t\tthis._currNode = this._nextNode;\n  \t\t\tthis._currSegIndex = this._currNode.segmentIndex;\n  \t\t\tthis.readNextNode();\n  \t\t\treturn this._currNode;\n  \t\t}\n  \t\tif (this._nextNode.segmentIndex > this._currNode.segmentIndex) ;\n  \t\treturn null;\n  \t},\n  \tremove: function remove() {\n  \t\tthrow new UnsupportedOperationException(this.getClass().getName());\n  \t},\n  \thasNext: function hasNext() {\n  \t\tif (this._nextNode === null) return false;\n  \t\treturn true;\n  \t},\n  \treadNextNode: function readNextNode() {\n  \t\tif (this._nodeIt.hasNext()) this._nextNode = this._nodeIt.next();else this._nextNode = null;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Iterator];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn NodeVertexIterator;\n  \t}\n  });\n\n  function NodableSegmentString() {}\n  extend(NodableSegmentString.prototype, {\n  \taddIntersection: function addIntersection(intPt, segmentIndex) {},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [SegmentString];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn NodableSegmentString;\n  \t}\n  });\n\n  function NodedSegmentString() {\n  \tthis._nodeList = new SegmentNodeList(this);\n  \tthis._pts = null;\n  \tthis._data = null;\n  \tvar pts = arguments[0],\n  \t    data = arguments[1];\n  \tthis._pts = pts;\n  \tthis._data = data;\n  }\n  extend(NodedSegmentString.prototype, {\n  \tgetCoordinates: function getCoordinates() {\n  \t\treturn this._pts;\n  \t},\n  \tsize: function size() {\n  \t\treturn this._pts.length;\n  \t},\n  \tgetCoordinate: function getCoordinate(i) {\n  \t\treturn this._pts[i];\n  \t},\n  \tisClosed: function isClosed() {\n  \t\treturn this._pts[0].equals(this._pts[this._pts.length - 1]);\n  \t},\n  \tgetSegmentOctant: function getSegmentOctant(index) {\n  \t\tif (index === this._pts.length - 1) return -1;\n  \t\treturn this.safeOctant(this.getCoordinate(index), this.getCoordinate(index + 1));\n  \t},\n  \tsetData: function setData(data) {\n  \t\tthis._data = data;\n  \t},\n  \tsafeOctant: function safeOctant(p0, p1) {\n  \t\tif (p0.equals2D(p1)) return 0;\n  \t\treturn Octant.octant(p0, p1);\n  \t},\n  \tgetData: function getData() {\n  \t\treturn this._data;\n  \t},\n  \taddIntersection: function addIntersection() {\n  \t\tif (arguments.length === 2) {\n  \t\t\tvar intPt = arguments[0],\n  \t\t\t    segmentIndex = arguments[1];\n  \t\t\tthis.addIntersectionNode(intPt, segmentIndex);\n  \t\t} else if (arguments.length === 4) {\n  \t\t\tvar li = arguments[0],\n  \t\t\t    segmentIndex = arguments[1],\n  \t\t\t    intIndex = arguments[3];\n  \t\t\tvar intPt = new Coordinate(li.getIntersection(intIndex));\n  \t\t\tthis.addIntersection(intPt, segmentIndex);\n  \t\t}\n  \t},\n  \ttoString: function toString() {\n  \t\treturn WKTWriter.toLineString(new CoordinateArraySequence(this._pts));\n  \t},\n  \tgetNodeList: function getNodeList() {\n  \t\treturn this._nodeList;\n  \t},\n  \taddIntersectionNode: function addIntersectionNode(intPt, segmentIndex) {\n  \t\tvar normalizedSegmentIndex = segmentIndex;\n  \t\tvar nextSegIndex = normalizedSegmentIndex + 1;\n  \t\tif (nextSegIndex < this._pts.length) {\n  \t\t\tvar nextPt = this._pts[nextSegIndex];\n  \t\t\tif (intPt.equals2D(nextPt)) {\n  \t\t\t\tnormalizedSegmentIndex = nextSegIndex;\n  \t\t\t}\n  \t\t}\n  \t\tvar ei = this._nodeList.add(intPt, normalizedSegmentIndex);\n  \t\treturn ei;\n  \t},\n  \taddIntersections: function addIntersections(li, segmentIndex, geomIndex) {\n  \t\tfor (var i = 0; i < li.getIntersectionNum(); i++) {\n  \t\t\tthis.addIntersection(li, segmentIndex, geomIndex, i);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [NodableSegmentString];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn NodedSegmentString;\n  \t}\n  });\n  NodedSegmentString.getNodedSubstrings = function () {\n  \tif (arguments.length === 1) {\n  \t\tvar segStrings = arguments[0];\n  \t\tvar resultEdgelist = new ArrayList();\n  \t\tNodedSegmentString.getNodedSubstrings(segStrings, resultEdgelist);\n  \t\treturn resultEdgelist;\n  \t} else if (arguments.length === 2) {\n  \t\tvar segStrings = arguments[0],\n  \t\t    resultEdgelist = arguments[1];\n  \t\tfor (var i = segStrings.iterator(); i.hasNext();) {\n  \t\t\tvar ss = i.next();\n  \t\t\tss.getNodeList().addSplitEdges(resultEdgelist);\n  \t\t}\n  \t}\n  };\n\n  function MonotoneChainOverlapAction() {\n  \tthis.tempEnv1 = new Envelope();\n  \tthis.tempEnv2 = new Envelope();\n  \tthis._overlapSeg1 = new LineSegment();\n  \tthis._overlapSeg2 = new LineSegment();\n  }\n  extend(MonotoneChainOverlapAction.prototype, {\n  \toverlap: function overlap() {\n  \t\tif (arguments.length === 2) ; else if (arguments.length === 4) {\n  \t\t\tvar mc1 = arguments[0],\n  \t\t\t    start1 = arguments[1],\n  \t\t\t    mc2 = arguments[2],\n  \t\t\t    start2 = arguments[3];\n  \t\t\tmc1.getLineSegment(start1, this._overlapSeg1);\n  \t\t\tmc2.getLineSegment(start2, this._overlapSeg2);\n  \t\t\tthis.overlap(this._overlapSeg1, this._overlapSeg2);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MonotoneChainOverlapAction;\n  \t}\n  });\n\n  function MonotoneChain() {\n  \tthis._pts = null;\n  \tthis._start = null;\n  \tthis._end = null;\n  \tthis._env = null;\n  \tthis._context = null;\n  \tthis._id = null;\n  \tvar pts = arguments[0],\n  \t    start = arguments[1],\n  \t    end = arguments[2],\n  \t    context = arguments[3];\n  \tthis._pts = pts;\n  \tthis._start = start;\n  \tthis._end = end;\n  \tthis._context = context;\n  }\n  extend(MonotoneChain.prototype, {\n  \tgetLineSegment: function getLineSegment(index, ls) {\n  \t\tls.p0 = this._pts[index];\n  \t\tls.p1 = this._pts[index + 1];\n  \t},\n  \tcomputeSelect: function computeSelect(searchEnv, start0, end0, mcs) {\n  \t\tvar p0 = this._pts[start0];\n  \t\tvar p1 = this._pts[end0];\n  \t\tmcs.tempEnv1.init(p0, p1);\n  \t\tif (end0 - start0 === 1) {\n  \t\t\tmcs.select(this, start0);\n  \t\t\treturn null;\n  \t\t}\n  \t\tif (!searchEnv.intersects(mcs.tempEnv1)) return null;\n  \t\tvar mid = Math.trunc((start0 + end0) / 2);\n  \t\tif (start0 < mid) {\n  \t\t\tthis.computeSelect(searchEnv, start0, mid, mcs);\n  \t\t}\n  \t\tif (mid < end0) {\n  \t\t\tthis.computeSelect(searchEnv, mid, end0, mcs);\n  \t\t}\n  \t},\n  \tgetCoordinates: function getCoordinates() {\n  \t\tvar coord = new Array(this._end - this._start + 1).fill(null);\n  \t\tvar index = 0;\n  \t\tfor (var i = this._start; i <= this._end; i++) {\n  \t\t\tcoord[index++] = this._pts[i];\n  \t\t}\n  \t\treturn coord;\n  \t},\n  \tcomputeOverlaps: function computeOverlaps(mc, mco) {\n  \t\tthis.computeOverlapsInternal(this._start, this._end, mc, mc._start, mc._end, mco);\n  \t},\n  \tsetId: function setId(id) {\n  \t\tthis._id = id;\n  \t},\n  \tselect: function select(searchEnv, mcs) {\n  \t\tthis.computeSelect(searchEnv, this._start, this._end, mcs);\n  \t},\n  \tgetEnvelope: function getEnvelope() {\n  \t\tif (this._env === null) {\n  \t\t\tvar p0 = this._pts[this._start];\n  \t\t\tvar p1 = this._pts[this._end];\n  \t\t\tthis._env = new Envelope(p0, p1);\n  \t\t}\n  \t\treturn this._env;\n  \t},\n  \tgetEndIndex: function getEndIndex() {\n  \t\treturn this._end;\n  \t},\n  \tgetStartIndex: function getStartIndex() {\n  \t\treturn this._start;\n  \t},\n  \tgetContext: function getContext() {\n  \t\treturn this._context;\n  \t},\n  \tgetId: function getId() {\n  \t\treturn this._id;\n  \t},\n  \tcomputeOverlapsInternal: function computeOverlapsInternal(start0, end0, mc, start1, end1, mco) {\n  \t\tvar p00 = this._pts[start0];\n  \t\tvar p01 = this._pts[end0];\n  \t\tvar p10 = mc._pts[start1];\n  \t\tvar p11 = mc._pts[end1];\n  \t\tif (end0 - start0 === 1 && end1 - start1 === 1) {\n  \t\t\tmco.overlap(this, start0, mc, start1);\n  \t\t\treturn null;\n  \t\t}\n  \t\tmco.tempEnv1.init(p00, p01);\n  \t\tmco.tempEnv2.init(p10, p11);\n  \t\tif (!mco.tempEnv1.intersects(mco.tempEnv2)) return null;\n  \t\tvar mid0 = Math.trunc((start0 + end0) / 2);\n  \t\tvar mid1 = Math.trunc((start1 + end1) / 2);\n  \t\tif (start0 < mid0) {\n  \t\t\tif (start1 < mid1) this.computeOverlapsInternal(start0, mid0, mc, start1, mid1, mco);\n  \t\t\tif (mid1 < end1) this.computeOverlapsInternal(start0, mid0, mc, mid1, end1, mco);\n  \t\t}\n  \t\tif (mid0 < end0) {\n  \t\t\tif (start1 < mid1) this.computeOverlapsInternal(mid0, end0, mc, start1, mid1, mco);\n  \t\t\tif (mid1 < end1) this.computeOverlapsInternal(mid0, end0, mc, mid1, end1, mco);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MonotoneChain;\n  \t}\n  });\n\n  function Quadrant() {}\n  extend(Quadrant.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Quadrant;\n  \t}\n  });\n  Quadrant.isNorthern = function (quad) {\n  \treturn quad === Quadrant.NE || quad === Quadrant.NW;\n  };\n  Quadrant.isOpposite = function (quad1, quad2) {\n  \tif (quad1 === quad2) return false;\n  \tvar diff = (quad1 - quad2 + 4) % 4;\n  \tif (diff === 2) return true;\n  \treturn false;\n  };\n  Quadrant.commonHalfPlane = function (quad1, quad2) {\n  \tif (quad1 === quad2) return quad1;\n  \tvar diff = (quad1 - quad2 + 4) % 4;\n  \tif (diff === 2) return -1;\n  \tvar min = quad1 < quad2 ? quad1 : quad2;\n  \tvar max = quad1 > quad2 ? quad1 : quad2;\n  \tif (min === 0 && max === 3) return 3;\n  \treturn min;\n  };\n  Quadrant.isInHalfPlane = function (quad, halfPlane) {\n  \tif (halfPlane === Quadrant.SE) {\n  \t\treturn quad === Quadrant.SE || quad === Quadrant.SW;\n  \t}\n  \treturn quad === halfPlane || quad === halfPlane + 1;\n  };\n  Quadrant.quadrant = function () {\n  \tif (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\") {\n  \t\tvar dx = arguments[0],\n  \t\t    dy = arguments[1];\n  \t\tif (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException(\"Cannot compute the quadrant for point ( \" + dx + \", \" + dy + \" )\");\n  \t\tif (dx >= 0.0) {\n  \t\t\tif (dy >= 0.0) return Quadrant.NE;else return Quadrant.SE;\n  \t\t} else {\n  \t\t\tif (dy >= 0.0) return Quadrant.NW;else return Quadrant.SW;\n  \t\t}\n  \t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n  \t\tvar p0 = arguments[0],\n  \t\t    p1 = arguments[1];\n  \t\tif (p1.x === p0.x && p1.y === p0.y) throw new IllegalArgumentException(\"Cannot compute the quadrant for two identical points \" + p0);\n  \t\tif (p1.x >= p0.x) {\n  \t\t\tif (p1.y >= p0.y) return Quadrant.NE;else return Quadrant.SE;\n  \t\t} else {\n  \t\t\tif (p1.y >= p0.y) return Quadrant.NW;else return Quadrant.SW;\n  \t\t}\n  \t}\n  };\n  Quadrant.NE = 0;\n  Quadrant.NW = 1;\n  Quadrant.SW = 2;\n  Quadrant.SE = 3;\n\n  function MonotoneChainBuilder() {}\n  extend(MonotoneChainBuilder.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MonotoneChainBuilder;\n  \t}\n  });\n  MonotoneChainBuilder.getChainStartIndices = function (pts) {\n  \tvar start = 0;\n  \tvar startIndexList = new ArrayList();\n  \tstartIndexList.add(new Integer(start));\n  \tdo {\n  \t\tvar last = MonotoneChainBuilder.findChainEnd(pts, start);\n  \t\tstartIndexList.add(new Integer(last));\n  \t\tstart = last;\n  \t} while (start < pts.length - 1);\n  \tvar startIndex = MonotoneChainBuilder.toIntArray(startIndexList);\n  \treturn startIndex;\n  };\n  MonotoneChainBuilder.findChainEnd = function (pts, start) {\n  \tvar safeStart = start;\n  \twhile (safeStart < pts.length - 1 && pts[safeStart].equals2D(pts[safeStart + 1])) {\n  \t\tsafeStart++;\n  \t}\n  \tif (safeStart >= pts.length - 1) {\n  \t\treturn pts.length - 1;\n  \t}\n  \tvar chainQuad = Quadrant.quadrant(pts[safeStart], pts[safeStart + 1]);\n  \tvar last = start + 1;\n  \twhile (last < pts.length) {\n  \t\tif (!pts[last - 1].equals2D(pts[last])) {\n  \t\t\tvar quad = Quadrant.quadrant(pts[last - 1], pts[last]);\n  \t\t\tif (quad !== chainQuad) break;\n  \t\t}\n  \t\tlast++;\n  \t}\n  \treturn last - 1;\n  };\n  MonotoneChainBuilder.getChains = function () {\n  \tif (arguments.length === 1) {\n  \t\tvar pts = arguments[0];\n  \t\treturn MonotoneChainBuilder.getChains(pts, null);\n  \t} else if (arguments.length === 2) {\n  \t\tvar pts = arguments[0],\n  \t\t    context = arguments[1];\n  \t\tvar mcList = new ArrayList();\n  \t\tvar startIndex = MonotoneChainBuilder.getChainStartIndices(pts);\n  \t\tfor (var i = 0; i < startIndex.length - 1; i++) {\n  \t\t\tvar mc = new MonotoneChain(pts, startIndex[i], startIndex[i + 1], context);\n  \t\t\tmcList.add(mc);\n  \t\t}\n  \t\treturn mcList;\n  \t}\n  };\n  MonotoneChainBuilder.toIntArray = function (list) {\n  \tvar array = new Array(list.size()).fill(null);\n  \tfor (var i = 0; i < array.length; i++) {\n  \t\tarray[i] = list.get(i).intValue();\n  \t}\n  \treturn array;\n  };\n\n  function Noder() {}\n  extend(Noder.prototype, {\n  \tcomputeNodes: function computeNodes(segStrings) {},\n  \tgetNodedSubstrings: function getNodedSubstrings() {},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Noder;\n  \t}\n  });\n\n  function SinglePassNoder() {\n  \tthis._segInt = null;\n  \tif (arguments.length === 0) ; else if (arguments.length === 1) {\n  \t\tvar segInt = arguments[0];\n  \t\tthis.setSegmentIntersector(segInt);\n  \t}\n  }\n  extend(SinglePassNoder.prototype, {\n  \tsetSegmentIntersector: function setSegmentIntersector(segInt) {\n  \t\tthis._segInt = segInt;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Noder];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SinglePassNoder;\n  \t}\n  });\n\n  function MCIndexNoder() {\n  \tthis._monoChains = new ArrayList();\n  \tthis._index = new STRtree();\n  \tthis._idCounter = 0;\n  \tthis._nodedSegStrings = null;\n  \tthis._nOverlaps = 0;\n  \tif (arguments.length === 0) ; else if (arguments.length === 1) {\n  \t\tvar si = arguments[0];\n  \t\tSinglePassNoder.call(this, si);\n  \t}\n  }\n  inherits$1(MCIndexNoder, SinglePassNoder);\n  extend(MCIndexNoder.prototype, {\n  \tgetMonotoneChains: function getMonotoneChains() {\n  \t\treturn this._monoChains;\n  \t},\n  \tgetNodedSubstrings: function getNodedSubstrings() {\n  \t\treturn NodedSegmentString.getNodedSubstrings(this._nodedSegStrings);\n  \t},\n  \tgetIndex: function getIndex() {\n  \t\treturn this._index;\n  \t},\n  \tadd: function add(segStr) {\n  \t\tvar segChains = MonotoneChainBuilder.getChains(segStr.getCoordinates(), segStr);\n  \t\tfor (var i = segChains.iterator(); i.hasNext();) {\n  \t\t\tvar mc = i.next();\n  \t\t\tmc.setId(this._idCounter++);\n  \t\t\tthis._index.insert(mc.getEnvelope(), mc);\n  \t\t\tthis._monoChains.add(mc);\n  \t\t}\n  \t},\n  \tcomputeNodes: function computeNodes(inputSegStrings) {\n  \t\tthis._nodedSegStrings = inputSegStrings;\n  \t\tfor (var i = inputSegStrings.iterator(); i.hasNext();) {\n  \t\t\tthis.add(i.next());\n  \t\t}\n  \t\tthis.intersectChains();\n  \t},\n  \tintersectChains: function intersectChains() {\n  \t\tvar overlapAction = new SegmentOverlapAction(this._segInt);\n  \t\tfor (var i = this._monoChains.iterator(); i.hasNext();) {\n  \t\t\tvar queryChain = i.next();\n  \t\t\tvar overlapChains = this._index.query(queryChain.getEnvelope());\n  \t\t\tfor (var j = overlapChains.iterator(); j.hasNext();) {\n  \t\t\t\tvar testChain = j.next();\n  \t\t\t\tif (testChain.getId() > queryChain.getId()) {\n  \t\t\t\t\tqueryChain.computeOverlaps(testChain, overlapAction);\n  \t\t\t\t\tthis._nOverlaps++;\n  \t\t\t\t}\n  \t\t\t\tif (this._segInt.isDone()) return null;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MCIndexNoder;\n  \t}\n  });\n  function SegmentOverlapAction() {\n  \tMonotoneChainOverlapAction.apply(this);\n  \tthis._si = null;\n  \tvar si = arguments[0];\n  \tthis._si = si;\n  }\n  inherits$1(SegmentOverlapAction, MonotoneChainOverlapAction);\n  extend(SegmentOverlapAction.prototype, {\n  \toverlap: function overlap() {\n  \t\tif (arguments.length === 4) {\n  \t\t\tvar mc1 = arguments[0],\n  \t\t\t    start1 = arguments[1],\n  \t\t\t    mc2 = arguments[2],\n  \t\t\t    start2 = arguments[3];\n  \t\t\tvar ss1 = mc1.getContext();\n  \t\t\tvar ss2 = mc2.getContext();\n  \t\t\tthis._si.processIntersections(ss1, start1, ss2, start2);\n  \t\t} else return MonotoneChainOverlapAction.prototype.overlap.apply(this, arguments);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SegmentOverlapAction;\n  \t}\n  });\n  MCIndexNoder.SegmentOverlapAction = SegmentOverlapAction;\n\n  function TopologyException() {\n  \tthis.pt = null;\n  \tif (arguments.length === 1) {\n  \t\tvar msg = arguments[0];\n  \t\tRuntimeException.call(this, msg);\n  \t} else if (arguments.length === 2) {\n  \t\tvar msg = arguments[0],\n  \t\t    pt = arguments[1];\n  \t\tRuntimeException.call(this, TopologyException.msgWithCoord(msg, pt));\n  \t\tthis.name = 'TopologyException';\n  \t\tthis.pt = new Coordinate(pt);\n  \t}\n  }\n  inherits$1(TopologyException, RuntimeException);\n  extend(TopologyException.prototype, {\n  \tgetCoordinate: function getCoordinate() {\n  \t\treturn this.pt;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn TopologyException;\n  \t}\n  });\n  TopologyException.msgWithCoord = function (msg, pt) {\n  \tif (pt !== null) return msg + \" [ \" + pt + \" ]\";\n  \treturn msg;\n  };\n\n  function SegmentIntersector() {}\n  extend(SegmentIntersector.prototype, {\n  \tprocessIntersections: function processIntersections(e0, segIndex0, e1, segIndex1) {},\n  \tisDone: function isDone() {},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SegmentIntersector;\n  \t}\n  });\n\n  function InteriorIntersectionFinder() {\n  \tthis._findAllIntersections = false;\n  \tthis._isCheckEndSegmentsOnly = false;\n  \tthis._li = null;\n  \tthis._interiorIntersection = null;\n  \tthis._intSegments = null;\n  \tthis._intersections = new ArrayList();\n  \tthis._intersectionCount = 0;\n  \tthis._keepIntersections = true;\n  \tvar li = arguments[0];\n  \tthis._li = li;\n  \tthis._interiorIntersection = null;\n  }\n  extend(InteriorIntersectionFinder.prototype, {\n  \tgetInteriorIntersection: function getInteriorIntersection() {\n  \t\treturn this._interiorIntersection;\n  \t},\n  \tsetCheckEndSegmentsOnly: function setCheckEndSegmentsOnly(isCheckEndSegmentsOnly) {\n  \t\tthis._isCheckEndSegmentsOnly = isCheckEndSegmentsOnly;\n  \t},\n  \tgetIntersectionSegments: function getIntersectionSegments() {\n  \t\treturn this._intSegments;\n  \t},\n  \tcount: function count() {\n  \t\treturn this._intersectionCount;\n  \t},\n  \tgetIntersections: function getIntersections() {\n  \t\treturn this._intersections;\n  \t},\n  \tsetFindAllIntersections: function setFindAllIntersections(findAllIntersections) {\n  \t\tthis._findAllIntersections = findAllIntersections;\n  \t},\n  \tsetKeepIntersections: function setKeepIntersections(keepIntersections) {\n  \t\tthis._keepIntersections = keepIntersections;\n  \t},\n  \tprocessIntersections: function processIntersections(e0, segIndex0, e1, segIndex1) {\n  \t\tif (!this._findAllIntersections && this.hasIntersection()) return null;\n  \t\tif (e0 === e1 && segIndex0 === segIndex1) return null;\n  \t\tif (this._isCheckEndSegmentsOnly) {\n  \t\t\tvar isEndSegPresent = this.isEndSegment(e0, segIndex0) || this.isEndSegment(e1, segIndex1);\n  \t\t\tif (!isEndSegPresent) return null;\n  \t\t}\n  \t\tvar p00 = e0.getCoordinates()[segIndex0];\n  \t\tvar p01 = e0.getCoordinates()[segIndex0 + 1];\n  \t\tvar p10 = e1.getCoordinates()[segIndex1];\n  \t\tvar p11 = e1.getCoordinates()[segIndex1 + 1];\n  \t\tthis._li.computeIntersection(p00, p01, p10, p11);\n  \t\tif (this._li.hasIntersection()) {\n  \t\t\tif (this._li.isInteriorIntersection()) {\n  \t\t\t\tthis._intSegments = new Array(4).fill(null);\n  \t\t\t\tthis._intSegments[0] = p00;\n  \t\t\t\tthis._intSegments[1] = p01;\n  \t\t\t\tthis._intSegments[2] = p10;\n  \t\t\t\tthis._intSegments[3] = p11;\n  \t\t\t\tthis._interiorIntersection = this._li.getIntersection(0);\n  \t\t\t\tif (this._keepIntersections) this._intersections.add(this._interiorIntersection);\n  \t\t\t\tthis._intersectionCount++;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tisEndSegment: function isEndSegment(segStr, index) {\n  \t\tif (index === 0) return true;\n  \t\tif (index >= segStr.size() - 2) return true;\n  \t\treturn false;\n  \t},\n  \thasIntersection: function hasIntersection() {\n  \t\treturn this._interiorIntersection !== null;\n  \t},\n  \tisDone: function isDone() {\n  \t\tif (this._findAllIntersections) return false;\n  \t\treturn this._interiorIntersection !== null;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [SegmentIntersector];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn InteriorIntersectionFinder;\n  \t}\n  });\n  InteriorIntersectionFinder.createAllIntersectionsFinder = function (li) {\n  \tvar finder = new InteriorIntersectionFinder(li);\n  \tfinder.setFindAllIntersections(true);\n  \treturn finder;\n  };\n  InteriorIntersectionFinder.createAnyIntersectionFinder = function (li) {\n  \treturn new InteriorIntersectionFinder(li);\n  };\n  InteriorIntersectionFinder.createIntersectionCounter = function (li) {\n  \tvar finder = new InteriorIntersectionFinder(li);\n  \tfinder.setFindAllIntersections(true);\n  \tfinder.setKeepIntersections(false);\n  \treturn finder;\n  };\n\n  function FastNodingValidator() {\n  \tthis._li = new RobustLineIntersector();\n  \tthis._segStrings = null;\n  \tthis._findAllIntersections = false;\n  \tthis._segInt = null;\n  \tthis._isValid = true;\n  \tvar segStrings = arguments[0];\n  \tthis._segStrings = segStrings;\n  }\n  extend(FastNodingValidator.prototype, {\n  \texecute: function execute() {\n  \t\tif (this._segInt !== null) return null;\n  \t\tthis.checkInteriorIntersections();\n  \t},\n  \tgetIntersections: function getIntersections() {\n  \t\treturn this._segInt.getIntersections();\n  \t},\n  \tisValid: function isValid() {\n  \t\tthis.execute();\n  \t\treturn this._isValid;\n  \t},\n  \tsetFindAllIntersections: function setFindAllIntersections(findAllIntersections) {\n  \t\tthis._findAllIntersections = findAllIntersections;\n  \t},\n  \tcheckInteriorIntersections: function checkInteriorIntersections() {\n  \t\tthis._isValid = true;\n  \t\tthis._segInt = new InteriorIntersectionFinder(this._li);\n  \t\tthis._segInt.setFindAllIntersections(this._findAllIntersections);\n  \t\tvar noder = new MCIndexNoder();\n  \t\tnoder.setSegmentIntersector(this._segInt);\n  \t\tnoder.computeNodes(this._segStrings);\n  \t\tif (this._segInt.hasIntersection()) {\n  \t\t\tthis._isValid = false;\n  \t\t\treturn null;\n  \t\t}\n  \t},\n  \tcheckValid: function checkValid() {\n  \t\tthis.execute();\n  \t\tif (!this._isValid) throw new TopologyException(this.getErrorMessage(), this._segInt.getInteriorIntersection());\n  \t},\n  \tgetErrorMessage: function getErrorMessage() {\n  \t\tif (this._isValid) return \"no intersections found\";\n  \t\tvar intSegs = this._segInt.getIntersectionSegments();\n  \t\treturn \"found non-noded intersection between \" + WKTWriter.toLineString(intSegs[0], intSegs[1]) + \" and \" + WKTWriter.toLineString(intSegs[2], intSegs[3]);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn FastNodingValidator;\n  \t}\n  });\n  FastNodingValidator.computeIntersections = function (segStrings) {\n  \tvar nv = new FastNodingValidator(segStrings);\n  \tnv.setFindAllIntersections(true);\n  \tnv.isValid();\n  \treturn nv.getIntersections();\n  };\n\n  function EdgeNodingValidator() {\n  \tthis._nv = null;\n  \tvar edges = arguments[0];\n  \tthis._nv = new FastNodingValidator(EdgeNodingValidator.toSegmentStrings(edges));\n  }\n  extend(EdgeNodingValidator.prototype, {\n  \tcheckValid: function checkValid() {\n  \t\tthis._nv.checkValid();\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn EdgeNodingValidator;\n  \t}\n  });\n  EdgeNodingValidator.toSegmentStrings = function (edges) {\n  \tvar segStrings = new ArrayList();\n  \tfor (var i = edges.iterator(); i.hasNext();) {\n  \t\tvar e = i.next();\n  \t\tsegStrings.add(new BasicSegmentString(e.getCoordinates(), e));\n  \t}\n  \treturn segStrings;\n  };\n  EdgeNodingValidator.checkValid = function (edges) {\n  \tvar validator = new EdgeNodingValidator(edges);\n  \tvalidator.checkValid();\n  };\n\n  function GeometryCollectionMapper() {\n  \tthis._mapOp = null;\n  \tvar mapOp = arguments[0];\n  \tthis._mapOp = mapOp;\n  }\n  extend(GeometryCollectionMapper.prototype, {\n  \tmap: function map(gc) {\n  \t\tvar mapped = new ArrayList();\n  \t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n  \t\t\tvar g = this._mapOp.map(gc.getGeometryN(i));\n  \t\t\tif (!g.isEmpty()) mapped.add(g);\n  \t\t}\n  \t\treturn gc.getFactory().createGeometryCollection(GeometryFactory.toGeometryArray(mapped));\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn GeometryCollectionMapper;\n  \t}\n  });\n  GeometryCollectionMapper.map = function (gc, op) {\n  \tvar mapper = new GeometryCollectionMapper(op);\n  \treturn mapper.map(gc);\n  };\n\n  function Position() {}\n  extend(Position.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Position;\n  \t}\n  });\n  Position.opposite = function (position) {\n  \tif (position === Position.LEFT) return Position.RIGHT;\n  \tif (position === Position.RIGHT) return Position.LEFT;\n  \treturn position;\n  };\n  Position.ON = 0;\n  Position.LEFT = 1;\n  Position.RIGHT = 2;\n\n  function TopologyLocation() {\n  \tthis.location = null;\n  \tif (arguments.length === 1) {\n  \t\tif (arguments[0] instanceof Array) {\n  \t\t\tvar location = arguments[0];\n  \t\t\tthis.init(location.length);\n  \t\t} else if (Number.isInteger(arguments[0])) {\n  \t\t\tvar on = arguments[0];\n  \t\t\tthis.init(1);\n  \t\t\tthis.location[Position.ON] = on;\n  \t\t} else if (arguments[0] instanceof TopologyLocation) {\n  \t\t\tvar gl = arguments[0];\n  \t\t\tthis.init(gl.location.length);\n  \t\t\tif (gl !== null) {\n  \t\t\t\tfor (var i = 0; i < this.location.length; i++) {\n  \t\t\t\t\tthis.location[i] = gl.location[i];\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t} else if (arguments.length === 3) {\n  \t\tvar on = arguments[0],\n  \t\t    left = arguments[1],\n  \t\t    right = arguments[2];\n  \t\tthis.init(3);\n  \t\tthis.location[Position.ON] = on;\n  \t\tthis.location[Position.LEFT] = left;\n  \t\tthis.location[Position.RIGHT] = right;\n  \t}\n  }\n  extend(TopologyLocation.prototype, {\n  \tsetAllLocations: function setAllLocations(locValue) {\n  \t\tfor (var i = 0; i < this.location.length; i++) {\n  \t\t\tthis.location[i] = locValue;\n  \t\t}\n  \t},\n  \tisNull: function isNull() {\n  \t\tfor (var i = 0; i < this.location.length; i++) {\n  \t\t\tif (this.location[i] !== Location.NONE) return false;\n  \t\t}\n  \t\treturn true;\n  \t},\n  \tsetAllLocationsIfNull: function setAllLocationsIfNull(locValue) {\n  \t\tfor (var i = 0; i < this.location.length; i++) {\n  \t\t\tif (this.location[i] === Location.NONE) this.location[i] = locValue;\n  \t\t}\n  \t},\n  \tisLine: function isLine() {\n  \t\treturn this.location.length === 1;\n  \t},\n  \tmerge: function merge(gl) {\n  \t\tif (gl.location.length > this.location.length) {\n  \t\t\tvar newLoc = new Array(3).fill(null);\n  \t\t\tnewLoc[Position.ON] = this.location[Position.ON];\n  \t\t\tnewLoc[Position.LEFT] = Location.NONE;\n  \t\t\tnewLoc[Position.RIGHT] = Location.NONE;\n  \t\t\tthis.location = newLoc;\n  \t\t}\n  \t\tfor (var i = 0; i < this.location.length; i++) {\n  \t\t\tif (this.location[i] === Location.NONE && i < gl.location.length) this.location[i] = gl.location[i];\n  \t\t}\n  \t},\n  \tgetLocations: function getLocations() {\n  \t\treturn this.location;\n  \t},\n  \tflip: function flip() {\n  \t\tif (this.location.length <= 1) return null;\n  \t\tvar temp = this.location[Position.LEFT];\n  \t\tthis.location[Position.LEFT] = this.location[Position.RIGHT];\n  \t\tthis.location[Position.RIGHT] = temp;\n  \t},\n  \ttoString: function toString() {\n  \t\tvar buf = new StringBuffer();\n  \t\tif (this.location.length > 1) buf.append(Location.toLocationSymbol(this.location[Position.LEFT]));\n  \t\tbuf.append(Location.toLocationSymbol(this.location[Position.ON]));\n  \t\tif (this.location.length > 1) buf.append(Location.toLocationSymbol(this.location[Position.RIGHT]));\n  \t\treturn buf.toString();\n  \t},\n  \tsetLocations: function setLocations(on, left, right) {\n  \t\tthis.location[Position.ON] = on;\n  \t\tthis.location[Position.LEFT] = left;\n  \t\tthis.location[Position.RIGHT] = right;\n  \t},\n  \tget: function get(posIndex) {\n  \t\tif (posIndex < this.location.length) return this.location[posIndex];\n  \t\treturn Location.NONE;\n  \t},\n  \tisArea: function isArea() {\n  \t\treturn this.location.length > 1;\n  \t},\n  \tisAnyNull: function isAnyNull() {\n  \t\tfor (var i = 0; i < this.location.length; i++) {\n  \t\t\tif (this.location[i] === Location.NONE) return true;\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tsetLocation: function setLocation() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar locValue = arguments[0];\n  \t\t\tthis.setLocation(Position.ON, locValue);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar locIndex = arguments[0],\n  \t\t\t    locValue = arguments[1];\n  \t\t\tthis.location[locIndex] = locValue;\n  \t\t}\n  \t},\n  \tinit: function init(size) {\n  \t\tthis.location = new Array(size).fill(null);\n  \t\tthis.setAllLocations(Location.NONE);\n  \t},\n  \tisEqualOnSide: function isEqualOnSide(le, locIndex) {\n  \t\treturn this.location[locIndex] === le.location[locIndex];\n  \t},\n  \tallPositionsEqual: function allPositionsEqual(loc) {\n  \t\tfor (var i = 0; i < this.location.length; i++) {\n  \t\t\tif (this.location[i] !== loc) return false;\n  \t\t}\n  \t\treturn true;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn TopologyLocation;\n  \t}\n  });\n\n  function Label() {\n  \tthis.elt = new Array(2).fill(null);\n  \tif (arguments.length === 1) {\n  \t\tif (Number.isInteger(arguments[0])) {\n  \t\t\tvar onLoc = arguments[0];\n  \t\t\tthis.elt[0] = new TopologyLocation(onLoc);\n  \t\t\tthis.elt[1] = new TopologyLocation(onLoc);\n  \t\t} else if (arguments[0] instanceof Label) {\n  \t\t\tvar lbl = arguments[0];\n  \t\t\tthis.elt[0] = new TopologyLocation(lbl.elt[0]);\n  \t\t\tthis.elt[1] = new TopologyLocation(lbl.elt[1]);\n  \t\t}\n  \t} else if (arguments.length === 2) {\n  \t\tvar geomIndex = arguments[0],\n  \t\t    onLoc = arguments[1];\n  \t\tthis.elt[0] = new TopologyLocation(Location.NONE);\n  \t\tthis.elt[1] = new TopologyLocation(Location.NONE);\n  \t\tthis.elt[geomIndex].setLocation(onLoc);\n  \t} else if (arguments.length === 3) {\n  \t\tvar onLoc = arguments[0],\n  \t\t    leftLoc = arguments[1],\n  \t\t    rightLoc = arguments[2];\n  \t\tthis.elt[0] = new TopologyLocation(onLoc, leftLoc, rightLoc);\n  \t\tthis.elt[1] = new TopologyLocation(onLoc, leftLoc, rightLoc);\n  \t} else if (arguments.length === 4) {\n  \t\tvar geomIndex = arguments[0],\n  \t\t    onLoc = arguments[1],\n  \t\t    leftLoc = arguments[2],\n  \t\t    rightLoc = arguments[3];\n  \t\tthis.elt[0] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);\n  \t\tthis.elt[1] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);\n  \t\tthis.elt[geomIndex].setLocations(onLoc, leftLoc, rightLoc);\n  \t}\n  }\n  extend(Label.prototype, {\n  \tgetGeometryCount: function getGeometryCount() {\n  \t\tvar count = 0;\n  \t\tif (!this.elt[0].isNull()) count++;\n  \t\tif (!this.elt[1].isNull()) count++;\n  \t\treturn count;\n  \t},\n  \tsetAllLocations: function setAllLocations(geomIndex, location) {\n  \t\tthis.elt[geomIndex].setAllLocations(location);\n  \t},\n  \tisNull: function isNull(geomIndex) {\n  \t\treturn this.elt[geomIndex].isNull();\n  \t},\n  \tsetAllLocationsIfNull: function setAllLocationsIfNull() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar location = arguments[0];\n  \t\t\tthis.setAllLocationsIfNull(0, location);\n  \t\t\tthis.setAllLocationsIfNull(1, location);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar geomIndex = arguments[0],\n  \t\t\t    location = arguments[1];\n  \t\t\tthis.elt[geomIndex].setAllLocationsIfNull(location);\n  \t\t}\n  \t},\n  \tisLine: function isLine(geomIndex) {\n  \t\treturn this.elt[geomIndex].isLine();\n  \t},\n  \tmerge: function merge(lbl) {\n  \t\tfor (var i = 0; i < 2; i++) {\n  \t\t\tif (this.elt[i] === null && lbl.elt[i] !== null) {\n  \t\t\t\tthis.elt[i] = new TopologyLocation(lbl.elt[i]);\n  \t\t\t} else {\n  \t\t\t\tthis.elt[i].merge(lbl.elt[i]);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tflip: function flip() {\n  \t\tthis.elt[0].flip();\n  \t\tthis.elt[1].flip();\n  \t},\n  \tgetLocation: function getLocation() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar geomIndex = arguments[0];\n  \t\t\treturn this.elt[geomIndex].get(Position.ON);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar geomIndex = arguments[0],\n  \t\t\t    posIndex = arguments[1];\n  \t\t\treturn this.elt[geomIndex].get(posIndex);\n  \t\t}\n  \t},\n  \ttoString: function toString() {\n  \t\tvar buf = new StringBuffer();\n  \t\tif (this.elt[0] !== null) {\n  \t\t\tbuf.append(\"A:\");\n  \t\t\tbuf.append(this.elt[0].toString());\n  \t\t}\n  \t\tif (this.elt[1] !== null) {\n  \t\t\tbuf.append(\" B:\");\n  \t\t\tbuf.append(this.elt[1].toString());\n  \t\t}\n  \t\treturn buf.toString();\n  \t},\n  \tisArea: function isArea() {\n  \t\tif (arguments.length === 0) {\n  \t\t\treturn this.elt[0].isArea() || this.elt[1].isArea();\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tvar geomIndex = arguments[0];\n  \t\t\treturn this.elt[geomIndex].isArea();\n  \t\t}\n  \t},\n  \tisAnyNull: function isAnyNull(geomIndex) {\n  \t\treturn this.elt[geomIndex].isAnyNull();\n  \t},\n  \tsetLocation: function setLocation() {\n  \t\tif (arguments.length === 2) {\n  \t\t\tvar geomIndex = arguments[0],\n  \t\t\t    location = arguments[1];\n  \t\t\tthis.elt[geomIndex].setLocation(Position.ON, location);\n  \t\t} else if (arguments.length === 3) {\n  \t\t\tvar geomIndex = arguments[0],\n  \t\t\t    posIndex = arguments[1],\n  \t\t\t    location = arguments[2];\n  \t\t\tthis.elt[geomIndex].setLocation(posIndex, location);\n  \t\t}\n  \t},\n  \tisEqualOnSide: function isEqualOnSide(lbl, side) {\n  \t\treturn this.elt[0].isEqualOnSide(lbl.elt[0], side) && this.elt[1].isEqualOnSide(lbl.elt[1], side);\n  \t},\n  \tallPositionsEqual: function allPositionsEqual(geomIndex, loc) {\n  \t\treturn this.elt[geomIndex].allPositionsEqual(loc);\n  \t},\n  \ttoLine: function toLine(geomIndex) {\n  \t\tif (this.elt[geomIndex].isArea()) this.elt[geomIndex] = new TopologyLocation(this.elt[geomIndex].location[0]);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Label;\n  \t}\n  });\n  Label.toLineLabel = function (label) {\n  \tvar lineLabel = new Label(Location.NONE);\n  \tfor (var i = 0; i < 2; i++) {\n  \t\tlineLabel.setLocation(i, label.getLocation(i));\n  \t}\n  \treturn lineLabel;\n  };\n\n  function EdgeRing() {\n  \tthis._startDe = null;\n  \tthis._maxNodeDegree = -1;\n  \tthis._edges = new ArrayList();\n  \tthis._pts = new ArrayList();\n  \tthis._label = new Label(Location.NONE);\n  \tthis._ring = null;\n  \tthis._isHole = null;\n  \tthis._shell = null;\n  \tthis._holes = new ArrayList();\n  \tthis._geometryFactory = null;\n  \tvar start = arguments[0],\n  \t    geometryFactory = arguments[1];\n  \tthis._geometryFactory = geometryFactory;\n  \tthis.computePoints(start);\n  \tthis.computeRing();\n  }\n  extend(EdgeRing.prototype, {\n  \tcomputeRing: function computeRing() {\n  \t\tif (this._ring !== null) return null;\n  \t\tvar coord = new Array(this._pts.size()).fill(null);\n  \t\tfor (var i = 0; i < this._pts.size(); i++) {\n  \t\t\tcoord[i] = this._pts.get(i);\n  \t\t}\n  \t\tthis._ring = this._geometryFactory.createLinearRing(coord);\n  \t\tthis._isHole = CGAlgorithms.isCCW(this._ring.getCoordinates());\n  \t},\n  \tisIsolated: function isIsolated() {\n  \t\treturn this._label.getGeometryCount() === 1;\n  \t},\n  \tcomputePoints: function computePoints(start) {\n  \t\tthis._startDe = start;\n  \t\tvar de = start;\n  \t\tvar isFirstEdge = true;\n  \t\tdo {\n  \t\t\tif (de === null) throw new TopologyException(\"Found null DirectedEdge\");\n  \t\t\tif (de.getEdgeRing() === this) throw new TopologyException(\"Directed Edge visited twice during ring-building at \" + de.getCoordinate());\n  \t\t\tthis._edges.add(de);\n  \t\t\tvar label = de.getLabel();\n  \t\t\tAssert.isTrue(label.isArea());\n  \t\t\tthis.mergeLabel(label);\n  \t\t\tthis.addPoints(de.getEdge(), de.isForward(), isFirstEdge);\n  \t\t\tisFirstEdge = false;\n  \t\t\tthis.setEdgeRing(de, this);\n  \t\t\tde = this.getNext(de);\n  \t\t} while (de !== this._startDe);\n  \t},\n  \tgetLinearRing: function getLinearRing() {\n  \t\treturn this._ring;\n  \t},\n  \tgetCoordinate: function getCoordinate(i) {\n  \t\treturn this._pts.get(i);\n  \t},\n  \tcomputeMaxNodeDegree: function computeMaxNodeDegree() {\n  \t\tthis._maxNodeDegree = 0;\n  \t\tvar de = this._startDe;\n  \t\tdo {\n  \t\t\tvar node = de.getNode();\n  \t\t\tvar degree = node.getEdges().getOutgoingDegree(this);\n  \t\t\tif (degree > this._maxNodeDegree) this._maxNodeDegree = degree;\n  \t\t\tde = this.getNext(de);\n  \t\t} while (de !== this._startDe);\n  \t\tthis._maxNodeDegree *= 2;\n  \t},\n  \taddPoints: function addPoints(edge, isForward, isFirstEdge) {\n  \t\tvar edgePts = edge.getCoordinates();\n  \t\tif (isForward) {\n  \t\t\tvar startIndex = 1;\n  \t\t\tif (isFirstEdge) startIndex = 0;\n  \t\t\tfor (var i = startIndex; i < edgePts.length; i++) {\n  \t\t\t\tthis._pts.add(edgePts[i]);\n  \t\t\t}\n  \t\t} else {\n  \t\t\tvar startIndex = edgePts.length - 2;\n  \t\t\tif (isFirstEdge) startIndex = edgePts.length - 1;\n  \t\t\tfor (var i = startIndex; i >= 0; i--) {\n  \t\t\t\tthis._pts.add(edgePts[i]);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tisHole: function isHole() {\n  \t\treturn this._isHole;\n  \t},\n  \tsetInResult: function setInResult() {\n  \t\tvar de = this._startDe;\n  \t\tdo {\n  \t\t\tde.getEdge().setInResult(true);\n  \t\t\tde = de.getNext();\n  \t\t} while (de !== this._startDe);\n  \t},\n  \tcontainsPoint: function containsPoint(p) {\n  \t\tvar shell = this.getLinearRing();\n  \t\tvar env = shell.getEnvelopeInternal();\n  \t\tif (!env.contains(p)) return false;\n  \t\tif (!CGAlgorithms.isPointInRing(p, shell.getCoordinates())) return false;\n  \t\tfor (var i = this._holes.iterator(); i.hasNext();) {\n  \t\t\tvar hole = i.next();\n  \t\t\tif (hole.containsPoint(p)) return false;\n  \t\t}\n  \t\treturn true;\n  \t},\n  \taddHole: function addHole(ring) {\n  \t\tthis._holes.add(ring);\n  \t},\n  \tisShell: function isShell() {\n  \t\treturn this._shell === null;\n  \t},\n  \tgetLabel: function getLabel() {\n  \t\treturn this._label;\n  \t},\n  \tgetEdges: function getEdges() {\n  \t\treturn this._edges;\n  \t},\n  \tgetMaxNodeDegree: function getMaxNodeDegree() {\n  \t\tif (this._maxNodeDegree < 0) this.computeMaxNodeDegree();\n  \t\treturn this._maxNodeDegree;\n  \t},\n  \tgetShell: function getShell() {\n  \t\treturn this._shell;\n  \t},\n  \tmergeLabel: function mergeLabel() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar deLabel = arguments[0];\n  \t\t\tthis.mergeLabel(deLabel, 0);\n  \t\t\tthis.mergeLabel(deLabel, 1);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar deLabel = arguments[0],\n  \t\t\t    geomIndex = arguments[1];\n  \t\t\tvar loc = deLabel.getLocation(geomIndex, Position.RIGHT);\n  \t\t\tif (loc === Location.NONE) return null;\n  \t\t\tif (this._label.getLocation(geomIndex) === Location.NONE) {\n  \t\t\t\tthis._label.setLocation(geomIndex, loc);\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tsetShell: function setShell(shell) {\n  \t\tthis._shell = shell;\n  \t\tif (shell !== null) shell.addHole(this);\n  \t},\n  \ttoPolygon: function toPolygon(geometryFactory) {\n  \t\tvar holeLR = new Array(this._holes.size()).fill(null);\n  \t\tfor (var i = 0; i < this._holes.size(); i++) {\n  \t\t\tholeLR[i] = this._holes.get(i).getLinearRing();\n  \t\t}\n  \t\tvar poly = geometryFactory.createPolygon(this.getLinearRing(), holeLR);\n  \t\treturn poly;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn EdgeRing;\n  \t}\n  });\n\n  function MinimalEdgeRing() {\n  \tvar start = arguments[0],\n  \t    geometryFactory = arguments[1];\n  \tEdgeRing.call(this, start, geometryFactory);\n  }\n  inherits$1(MinimalEdgeRing, EdgeRing);\n  extend(MinimalEdgeRing.prototype, {\n  \tsetEdgeRing: function setEdgeRing(de, er) {\n  \t\tde.setMinEdgeRing(er);\n  \t},\n  \tgetNext: function getNext(de) {\n  \t\treturn de.getNextMin();\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MinimalEdgeRing;\n  \t}\n  });\n\n  function MaximalEdgeRing() {\n  \tvar start = arguments[0],\n  \t    geometryFactory = arguments[1];\n  \tEdgeRing.call(this, start, geometryFactory);\n  }\n  inherits$1(MaximalEdgeRing, EdgeRing);\n  extend(MaximalEdgeRing.prototype, {\n  \tbuildMinimalRings: function buildMinimalRings() {\n  \t\tvar minEdgeRings = new ArrayList();\n  \t\tvar de = this._startDe;\n  \t\tdo {\n  \t\t\tif (de.getMinEdgeRing() === null) {\n  \t\t\t\tvar minEr = new MinimalEdgeRing(de, this._geometryFactory);\n  \t\t\t\tminEdgeRings.add(minEr);\n  \t\t\t}\n  \t\t\tde = de.getNext();\n  \t\t} while (de !== this._startDe);\n  \t\treturn minEdgeRings;\n  \t},\n  \tsetEdgeRing: function setEdgeRing(de, er) {\n  \t\tde.setEdgeRing(er);\n  \t},\n  \tlinkDirectedEdgesForMinimalEdgeRings: function linkDirectedEdgesForMinimalEdgeRings() {\n  \t\tvar de = this._startDe;\n  \t\tdo {\n  \t\t\tvar node = de.getNode();\n  \t\t\tnode.getEdges().linkMinimalDirectedEdges(this);\n  \t\t\tde = de.getNext();\n  \t\t} while (de !== this._startDe);\n  \t},\n  \tgetNext: function getNext(de) {\n  \t\treturn de.getNext();\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MaximalEdgeRing;\n  \t}\n  });\n\n  function GraphComponent() {\n  \tthis._label = null;\n  \tthis._isInResult = false;\n  \tthis._isCovered = false;\n  \tthis._isCoveredSet = false;\n  \tthis._isVisited = false;\n  \tif (arguments.length === 0) ; else if (arguments.length === 1) {\n  \t\tvar label = arguments[0];\n  \t\tthis._label = label;\n  \t}\n  }\n  extend(GraphComponent.prototype, {\n  \tsetVisited: function setVisited(isVisited) {\n  \t\tthis._isVisited = isVisited;\n  \t},\n  \tsetInResult: function setInResult(isInResult) {\n  \t\tthis._isInResult = isInResult;\n  \t},\n  \tisCovered: function isCovered() {\n  \t\treturn this._isCovered;\n  \t},\n  \tisCoveredSet: function isCoveredSet() {\n  \t\treturn this._isCoveredSet;\n  \t},\n  \tsetLabel: function setLabel(label) {\n  \t\tthis._label = label;\n  \t},\n  \tgetLabel: function getLabel() {\n  \t\treturn this._label;\n  \t},\n  \tsetCovered: function setCovered(isCovered) {\n  \t\tthis._isCovered = isCovered;\n  \t\tthis._isCoveredSet = true;\n  \t},\n  \tupdateIM: function updateIM(im) {\n  \t\tAssert.isTrue(this._label.getGeometryCount() >= 2, \"found partial label\");\n  \t\tthis.computeIM(im);\n  \t},\n  \tisInResult: function isInResult() {\n  \t\treturn this._isInResult;\n  \t},\n  \tisVisited: function isVisited() {\n  \t\treturn this._isVisited;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn GraphComponent;\n  \t}\n  });\n\n  function Node() {\n  \tGraphComponent.apply(this);\n  \tthis._coord = null;\n  \tthis._edges = null;\n  \tvar coord = arguments[0],\n  \t    edges = arguments[1];\n  \tthis._coord = coord;\n  \tthis._edges = edges;\n  \tthis._label = new Label(0, Location.NONE);\n  }\n  inherits$1(Node, GraphComponent);\n  extend(Node.prototype, {\n  \tisIncidentEdgeInResult: function isIncidentEdgeInResult() {\n  \t\tfor (var it = this.getEdges().getEdges().iterator(); it.hasNext();) {\n  \t\t\tvar de = it.next();\n  \t\t\tif (de.getEdge().isInResult()) return true;\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tisIsolated: function isIsolated() {\n  \t\treturn this._label.getGeometryCount() === 1;\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\treturn this._coord;\n  \t},\n  \tprint: function print(out) {\n  \t\tout.println(\"node \" + this._coord + \" lbl: \" + this._label);\n  \t},\n  \tcomputeIM: function computeIM(im) {},\n  \tcomputeMergedLocation: function computeMergedLocation(label2, eltIndex) {\n  \t\tvar loc = Location.NONE;\n  \t\tloc = this._label.getLocation(eltIndex);\n  \t\tif (!label2.isNull(eltIndex)) {\n  \t\t\tvar nLoc = label2.getLocation(eltIndex);\n  \t\t\tif (loc !== Location.BOUNDARY) loc = nLoc;\n  \t\t}\n  \t\treturn loc;\n  \t},\n  \tsetLabel: function setLabel() {\n  \t\tif (arguments.length === 2) {\n  \t\t\tvar argIndex = arguments[0],\n  \t\t\t    onLocation = arguments[1];\n  \t\t\tif (this._label === null) {\n  \t\t\t\tthis._label = new Label(argIndex, onLocation);\n  \t\t\t} else this._label.setLocation(argIndex, onLocation);\n  \t\t} else return GraphComponent.prototype.setLabel.apply(this, arguments);\n  \t},\n  \tgetEdges: function getEdges() {\n  \t\treturn this._edges;\n  \t},\n  \tmergeLabel: function mergeLabel() {\n  \t\tif (arguments[0] instanceof Node) {\n  \t\t\tvar n = arguments[0];\n  \t\t\tthis.mergeLabel(n._label);\n  \t\t} else if (arguments[0] instanceof Label) {\n  \t\t\tvar label2 = arguments[0];\n  \t\t\tfor (var i = 0; i < 2; i++) {\n  \t\t\t\tvar loc = this.computeMergedLocation(label2, i);\n  \t\t\t\tvar thisLoc = this._label.getLocation(i);\n  \t\t\t\tif (thisLoc === Location.NONE) this._label.setLocation(i, loc);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tadd: function add(e) {\n  \t\tthis._edges.insert(e);\n  \t\te.setNode(this);\n  \t},\n  \tsetLabelBoundary: function setLabelBoundary(argIndex) {\n  \t\tif (this._label === null) return null;\n  \t\tvar loc = Location.NONE;\n  \t\tif (this._label !== null) loc = this._label.getLocation(argIndex);\n  \t\tvar newLoc = null;\n  \t\tswitch (loc) {\n  \t\t\tcase Location.BOUNDARY:\n  \t\t\t\tnewLoc = Location.INTERIOR;\n  \t\t\t\tbreak;\n  \t\t\tcase Location.INTERIOR:\n  \t\t\t\tnewLoc = Location.BOUNDARY;\n  \t\t\t\tbreak;\n  \t\t\tdefault:\n  \t\t\t\tnewLoc = Location.BOUNDARY;\n  \t\t\t\tbreak;\n  \t\t}\n  \t\tthis._label.setLocation(argIndex, newLoc);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Node;\n  \t}\n  });\n\n  function NodeMap() {\n  \tthis.nodeMap = new TreeMap();\n  \tthis.nodeFact = null;\n  \tvar nodeFact = arguments[0];\n  \tthis.nodeFact = nodeFact;\n  }\n  extend(NodeMap.prototype, {\n  \tfind: function find(coord) {\n  \t\treturn this.nodeMap.get(coord);\n  \t},\n  \taddNode: function addNode() {\n  \t\tif (arguments[0] instanceof Coordinate) {\n  \t\t\tvar coord = arguments[0];\n  \t\t\tvar node = this.nodeMap.get(coord);\n  \t\t\tif (node === null) {\n  \t\t\t\tnode = this.nodeFact.createNode(coord);\n  \t\t\t\tthis.nodeMap.put(coord, node);\n  \t\t\t}\n  \t\t\treturn node;\n  \t\t} else if (arguments[0] instanceof Node) {\n  \t\t\tvar n = arguments[0];\n  \t\t\tvar node = this.nodeMap.get(n.getCoordinate());\n  \t\t\tif (node === null) {\n  \t\t\t\tthis.nodeMap.put(n.getCoordinate(), n);\n  \t\t\t\treturn n;\n  \t\t\t}\n  \t\t\tnode.mergeLabel(n);\n  \t\t\treturn node;\n  \t\t}\n  \t},\n  \tprint: function print(out) {\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar n = it.next();\n  \t\t\tn.print(out);\n  \t\t}\n  \t},\n  \titerator: function iterator() {\n  \t\treturn this.nodeMap.values().iterator();\n  \t},\n  \tvalues: function values() {\n  \t\treturn this.nodeMap.values();\n  \t},\n  \tgetBoundaryNodes: function getBoundaryNodes(geomIndex) {\n  \t\tvar bdyNodes = new ArrayList();\n  \t\tfor (var i = this.iterator(); i.hasNext();) {\n  \t\t\tvar node = i.next();\n  \t\t\tif (node.getLabel().getLocation(geomIndex) === Location.BOUNDARY) bdyNodes.add(node);\n  \t\t}\n  \t\treturn bdyNodes;\n  \t},\n  \tadd: function add(e) {\n  \t\tvar p = e.getCoordinate();\n  \t\tvar n = this.addNode(p);\n  \t\tn.add(e);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn NodeMap;\n  \t}\n  });\n\n  function EdgeEnd() {\n  \tthis._edge = null;\n  \tthis._label = null;\n  \tthis._node = null;\n  \tthis._p0 = null;\n  \tthis._p1 = null;\n  \tthis._dx = null;\n  \tthis._dy = null;\n  \tthis._quadrant = null;\n  \tif (arguments.length === 1) {\n  \t\tvar edge = arguments[0];\n  \t\tthis._edge = edge;\n  \t} else if (arguments.length === 3) {\n  \t\tvar edge = arguments[0],\n  \t\t    p0 = arguments[1],\n  \t\t    p1 = arguments[2];\n  \t\tEdgeEnd.call(this, edge, p0, p1, null);\n  \t} else if (arguments.length === 4) {\n  \t\tvar edge = arguments[0],\n  \t\t    p0 = arguments[1],\n  \t\t    p1 = arguments[2],\n  \t\t    label = arguments[3];\n  \t\tEdgeEnd.call(this, edge);\n  \t\tthis.init(p0, p1);\n  \t\tthis._label = label;\n  \t}\n  }\n  extend(EdgeEnd.prototype, {\n  \tcompareDirection: function compareDirection(e) {\n  \t\tif (this._dx === e._dx && this._dy === e._dy) return 0;\n  \t\tif (this._quadrant > e._quadrant) return 1;\n  \t\tif (this._quadrant < e._quadrant) return -1;\n  \t\treturn CGAlgorithms.computeOrientation(e._p0, e._p1, this._p1);\n  \t},\n  \tgetDy: function getDy() {\n  \t\treturn this._dy;\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\treturn this._p0;\n  \t},\n  \tsetNode: function setNode(node) {\n  \t\tthis._node = node;\n  \t},\n  \tprint: function print(out) {\n  \t\tvar angle = Math.atan2(this._dy, this._dx);\n  \t\tvar className = this.getClass().getName();\n  \t\tvar lastDotPos = className.lastIndexOf('.');\n  \t\tvar name = className.substring(lastDotPos + 1);\n  \t\tout.print(\"  \" + name + \": \" + this._p0 + \" - \" + this._p1 + \" \" + this._quadrant + \":\" + angle + \"   \" + this._label);\n  \t},\n  \tcompareTo: function compareTo(obj) {\n  \t\tvar e = obj;\n  \t\treturn this.compareDirection(e);\n  \t},\n  \tgetDirectedCoordinate: function getDirectedCoordinate() {\n  \t\treturn this._p1;\n  \t},\n  \tgetDx: function getDx() {\n  \t\treturn this._dx;\n  \t},\n  \tgetLabel: function getLabel() {\n  \t\treturn this._label;\n  \t},\n  \tgetEdge: function getEdge() {\n  \t\treturn this._edge;\n  \t},\n  \tgetQuadrant: function getQuadrant() {\n  \t\treturn this._quadrant;\n  \t},\n  \tgetNode: function getNode() {\n  \t\treturn this._node;\n  \t},\n  \ttoString: function toString() {\n  \t\tvar angle = Math.atan2(this._dy, this._dx);\n  \t\tvar className = this.getClass().getName();\n  \t\tvar lastDotPos = className.lastIndexOf('.');\n  \t\tvar name = className.substring(lastDotPos + 1);\n  \t\treturn \"  \" + name + \": \" + this._p0 + \" - \" + this._p1 + \" \" + this._quadrant + \":\" + angle + \"   \" + this._label;\n  \t},\n  \tcomputeLabel: function computeLabel(boundaryNodeRule) {},\n  \tinit: function init(p0, p1) {\n  \t\tthis._p0 = p0;\n  \t\tthis._p1 = p1;\n  \t\tthis._dx = p1.x - p0.x;\n  \t\tthis._dy = p1.y - p0.y;\n  \t\tthis._quadrant = Quadrant.quadrant(this._dx, this._dy);\n  \t\tAssert.isTrue(!(this._dx === 0 && this._dy === 0), \"EdgeEnd with identical endpoints found\");\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn EdgeEnd;\n  \t}\n  });\n\n  function DirectedEdge() {\n  \tthis._isForward = null;\n  \tthis._isInResult = false;\n  \tthis._isVisited = false;\n  \tthis._sym = null;\n  \tthis._next = null;\n  \tthis._nextMin = null;\n  \tthis._edgeRing = null;\n  \tthis._minEdgeRing = null;\n  \tthis._depth = [0, -999, -999];\n  \tvar edge = arguments[0],\n  \t    isForward = arguments[1];\n  \tEdgeEnd.call(this, edge);\n  \tthis._isForward = isForward;\n  \tif (isForward) {\n  \t\tthis.init(edge.getCoordinate(0), edge.getCoordinate(1));\n  \t} else {\n  \t\tvar n = edge.getNumPoints() - 1;\n  \t\tthis.init(edge.getCoordinate(n), edge.getCoordinate(n - 1));\n  \t}\n  \tthis.computeDirectedLabel();\n  }\n  inherits$1(DirectedEdge, EdgeEnd);\n  extend(DirectedEdge.prototype, {\n  \tgetNextMin: function getNextMin() {\n  \t\treturn this._nextMin;\n  \t},\n  \tgetDepth: function getDepth(position) {\n  \t\treturn this._depth[position];\n  \t},\n  \tsetVisited: function setVisited(isVisited) {\n  \t\tthis._isVisited = isVisited;\n  \t},\n  \tcomputeDirectedLabel: function computeDirectedLabel() {\n  \t\tthis._label = new Label(this._edge.getLabel());\n  \t\tif (!this._isForward) this._label.flip();\n  \t},\n  \tgetNext: function getNext() {\n  \t\treturn this._next;\n  \t},\n  \tsetDepth: function setDepth(position, depthVal) {\n  \t\tif (this._depth[position] !== -999) {\n  \t\t\tif (this._depth[position] !== depthVal) throw new TopologyException(\"assigned depths do not match\", this.getCoordinate());\n  \t\t}\n  \t\tthis._depth[position] = depthVal;\n  \t},\n  \tisInteriorAreaEdge: function isInteriorAreaEdge() {\n  \t\tvar isInteriorAreaEdge = true;\n  \t\tfor (var i = 0; i < 2; i++) {\n  \t\t\tif (!(this._label.isArea(i) && this._label.getLocation(i, Position.LEFT) === Location.INTERIOR && this._label.getLocation(i, Position.RIGHT) === Location.INTERIOR)) {\n  \t\t\t\tisInteriorAreaEdge = false;\n  \t\t\t}\n  \t\t}\n  \t\treturn isInteriorAreaEdge;\n  \t},\n  \tsetNextMin: function setNextMin(nextMin) {\n  \t\tthis._nextMin = nextMin;\n  \t},\n  \tprint: function print(out) {\n  \t\tEdgeEnd.prototype.print.call(this, out);\n  \t\tout.print(\" \" + this._depth[Position.LEFT] + \"/\" + this._depth[Position.RIGHT]);\n  \t\tout.print(\" (\" + this.getDepthDelta() + \")\");\n  \t\tif (this._isInResult) out.print(\" inResult\");\n  \t},\n  \tsetMinEdgeRing: function setMinEdgeRing(minEdgeRing) {\n  \t\tthis._minEdgeRing = minEdgeRing;\n  \t},\n  \tisLineEdge: function isLineEdge() {\n  \t\tvar isLine = this._label.isLine(0) || this._label.isLine(1);\n  \t\tvar isExteriorIfArea0 = !this._label.isArea(0) || this._label.allPositionsEqual(0, Location.EXTERIOR);\n  \t\tvar isExteriorIfArea1 = !this._label.isArea(1) || this._label.allPositionsEqual(1, Location.EXTERIOR);\n  \t\treturn isLine && isExteriorIfArea0 && isExteriorIfArea1;\n  \t},\n  \tsetEdgeRing: function setEdgeRing(edgeRing) {\n  \t\tthis._edgeRing = edgeRing;\n  \t},\n  \tgetMinEdgeRing: function getMinEdgeRing() {\n  \t\treturn this._minEdgeRing;\n  \t},\n  \tgetDepthDelta: function getDepthDelta() {\n  \t\tvar depthDelta = this._edge.getDepthDelta();\n  \t\tif (!this._isForward) depthDelta = -depthDelta;\n  \t\treturn depthDelta;\n  \t},\n  \tsetInResult: function setInResult(isInResult) {\n  \t\tthis._isInResult = isInResult;\n  \t},\n  \tgetSym: function getSym() {\n  \t\treturn this._sym;\n  \t},\n  \tisForward: function isForward() {\n  \t\treturn this._isForward;\n  \t},\n  \tgetEdge: function getEdge() {\n  \t\treturn this._edge;\n  \t},\n  \tprintEdge: function printEdge(out) {\n  \t\tthis.print(out);\n  \t\tout.print(\" \");\n  \t\tif (this._isForward) this._edge.print(out);else this._edge.printReverse(out);\n  \t},\n  \tsetSym: function setSym(de) {\n  \t\tthis._sym = de;\n  \t},\n  \tsetVisitedEdge: function setVisitedEdge(isVisited) {\n  \t\tthis.setVisited(isVisited);\n  \t\tthis._sym.setVisited(isVisited);\n  \t},\n  \tsetEdgeDepths: function setEdgeDepths(position, depth) {\n  \t\tvar depthDelta = this.getEdge().getDepthDelta();\n  \t\tif (!this._isForward) depthDelta = -depthDelta;\n  \t\tvar directionFactor = 1;\n  \t\tif (position === Position.LEFT) directionFactor = -1;\n  \t\tvar oppositePos = Position.opposite(position);\n  \t\tvar delta = depthDelta * directionFactor;\n  \t\tvar oppositeDepth = depth + delta;\n  \t\tthis.setDepth(position, depth);\n  \t\tthis.setDepth(oppositePos, oppositeDepth);\n  \t},\n  \tgetEdgeRing: function getEdgeRing() {\n  \t\treturn this._edgeRing;\n  \t},\n  \tisInResult: function isInResult() {\n  \t\treturn this._isInResult;\n  \t},\n  \tsetNext: function setNext(next) {\n  \t\tthis._next = next;\n  \t},\n  \tisVisited: function isVisited() {\n  \t\treturn this._isVisited;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn DirectedEdge;\n  \t}\n  });\n  DirectedEdge.depthFactor = function (currLocation, nextLocation) {\n  \tif (currLocation === Location.EXTERIOR && nextLocation === Location.INTERIOR) return 1;else if (currLocation === Location.INTERIOR && nextLocation === Location.EXTERIOR) return -1;\n  \treturn 0;\n  };\n\n  function NodeFactory() {}\n  extend(NodeFactory.prototype, {\n  \tcreateNode: function createNode(coord) {\n  \t\treturn new Node(coord, null);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn NodeFactory;\n  \t}\n  });\n\n  function PlanarGraph() {\n  \tthis._edges = new ArrayList();\n  \tthis._nodes = null;\n  \tthis._edgeEndList = new ArrayList();\n  \tif (arguments.length === 0) {\n  \t\tthis._nodes = new NodeMap(new NodeFactory());\n  \t} else if (arguments.length === 1) {\n  \t\tvar nodeFact = arguments[0];\n  \t\tthis._nodes = new NodeMap(nodeFact);\n  \t}\n  }\n  extend(PlanarGraph.prototype, {\n  \tprintEdges: function printEdges(out) {\n  \t\tout.println(\"Edges:\");\n  \t\tfor (var i = 0; i < this._edges.size(); i++) {\n  \t\t\tout.println(\"edge \" + i + \":\");\n  \t\t\tvar e = this._edges.get(i);\n  \t\t\te.print(out);\n  \t\t\te.eiList.print(out);\n  \t\t}\n  \t},\n  \tfind: function find(coord) {\n  \t\treturn this._nodes.find(coord);\n  \t},\n  \taddNode: function addNode() {\n  \t\tif (arguments[0] instanceof Node) {\n  \t\t\tvar node = arguments[0];\n  \t\t\treturn this._nodes.addNode(node);\n  \t\t} else if (arguments[0] instanceof Coordinate) {\n  \t\t\tvar coord = arguments[0];\n  \t\t\treturn this._nodes.addNode(coord);\n  \t\t}\n  \t},\n  \tgetNodeIterator: function getNodeIterator() {\n  \t\treturn this._nodes.iterator();\n  \t},\n  \tlinkResultDirectedEdges: function linkResultDirectedEdges() {\n  \t\tfor (var nodeit = this._nodes.iterator(); nodeit.hasNext();) {\n  \t\t\tvar node = nodeit.next();\n  \t\t\tnode.getEdges().linkResultDirectedEdges();\n  \t\t}\n  \t},\n  \tdebugPrintln: function debugPrintln(o) {\n  \t\tSystem.out.println(o);\n  \t},\n  \tisBoundaryNode: function isBoundaryNode(geomIndex, coord) {\n  \t\tvar node = this._nodes.find(coord);\n  \t\tif (node === null) return false;\n  \t\tvar label = node.getLabel();\n  \t\tif (label !== null && label.getLocation(geomIndex) === Location.BOUNDARY) return true;\n  \t\treturn false;\n  \t},\n  \tlinkAllDirectedEdges: function linkAllDirectedEdges() {\n  \t\tfor (var nodeit = this._nodes.iterator(); nodeit.hasNext();) {\n  \t\t\tvar node = nodeit.next();\n  \t\t\tnode.getEdges().linkAllDirectedEdges();\n  \t\t}\n  \t},\n  \tmatchInSameDirection: function matchInSameDirection(p0, p1, ep0, ep1) {\n  \t\tif (!p0.equals(ep0)) return false;\n  \t\tif (CGAlgorithms.computeOrientation(p0, p1, ep1) === CGAlgorithms.COLLINEAR && Quadrant.quadrant(p0, p1) === Quadrant.quadrant(ep0, ep1)) return true;\n  \t\treturn false;\n  \t},\n  \tgetEdgeEnds: function getEdgeEnds() {\n  \t\treturn this._edgeEndList;\n  \t},\n  \tdebugPrint: function debugPrint(o) {\n  \t\tSystem.out.print(o);\n  \t},\n  \tgetEdgeIterator: function getEdgeIterator() {\n  \t\treturn this._edges.iterator();\n  \t},\n  \tfindEdgeInSameDirection: function findEdgeInSameDirection(p0, p1) {\n  \t\tfor (var i = 0; i < this._edges.size(); i++) {\n  \t\t\tvar e = this._edges.get(i);\n  \t\t\tvar eCoord = e.getCoordinates();\n  \t\t\tif (this.matchInSameDirection(p0, p1, eCoord[0], eCoord[1])) return e;\n  \t\t\tif (this.matchInSameDirection(p0, p1, eCoord[eCoord.length - 1], eCoord[eCoord.length - 2])) return e;\n  \t\t}\n  \t\treturn null;\n  \t},\n  \tinsertEdge: function insertEdge(e) {\n  \t\tthis._edges.add(e);\n  \t},\n  \tfindEdgeEnd: function findEdgeEnd(e) {\n  \t\tfor (var i = this.getEdgeEnds().iterator(); i.hasNext();) {\n  \t\t\tvar ee = i.next();\n  \t\t\tif (ee.getEdge() === e) return ee;\n  \t\t}\n  \t\treturn null;\n  \t},\n  \taddEdges: function addEdges(edgesToAdd) {\n  \t\tfor (var it = edgesToAdd.iterator(); it.hasNext();) {\n  \t\t\tvar e = it.next();\n  \t\t\tthis._edges.add(e);\n  \t\t\tvar de1 = new DirectedEdge(e, true);\n  \t\t\tvar de2 = new DirectedEdge(e, false);\n  \t\t\tde1.setSym(de2);\n  \t\t\tde2.setSym(de1);\n  \t\t\tthis.add(de1);\n  \t\t\tthis.add(de2);\n  \t\t}\n  \t},\n  \tadd: function add(e) {\n  \t\tthis._nodes.add(e);\n  \t\tthis._edgeEndList.add(e);\n  \t},\n  \tgetNodes: function getNodes() {\n  \t\treturn this._nodes.values();\n  \t},\n  \tfindEdge: function findEdge(p0, p1) {\n  \t\tfor (var i = 0; i < this._edges.size(); i++) {\n  \t\t\tvar e = this._edges.get(i);\n  \t\t\tvar eCoord = e.getCoordinates();\n  \t\t\tif (p0.equals(eCoord[0]) && p1.equals(eCoord[1])) return e;\n  \t\t}\n  \t\treturn null;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn PlanarGraph;\n  \t}\n  });\n  PlanarGraph.linkResultDirectedEdges = function (nodes) {\n  \tfor (var nodeit = nodes.iterator(); nodeit.hasNext();) {\n  \t\tvar node = nodeit.next();\n  \t\tnode.getEdges().linkResultDirectedEdges();\n  \t}\n  };\n\n  function PolygonBuilder() {\n  \tthis._geometryFactory = null;\n  \tthis._shellList = new ArrayList();\n  \tvar geometryFactory = arguments[0];\n  \tthis._geometryFactory = geometryFactory;\n  }\n  extend(PolygonBuilder.prototype, {\n  \tsortShellsAndHoles: function sortShellsAndHoles(edgeRings, shellList, freeHoleList) {\n  \t\tfor (var it = edgeRings.iterator(); it.hasNext();) {\n  \t\t\tvar er = it.next();\n  \t\t\tif (er.isHole()) {\n  \t\t\t\tfreeHoleList.add(er);\n  \t\t\t} else {\n  \t\t\t\tshellList.add(er);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcomputePolygons: function computePolygons(shellList) {\n  \t\tvar resultPolyList = new ArrayList();\n  \t\tfor (var it = shellList.iterator(); it.hasNext();) {\n  \t\t\tvar er = it.next();\n  \t\t\tvar poly = er.toPolygon(this._geometryFactory);\n  \t\t\tresultPolyList.add(poly);\n  \t\t}\n  \t\treturn resultPolyList;\n  \t},\n  \tplaceFreeHoles: function placeFreeHoles(shellList, freeHoleList) {\n  \t\tfor (var it = freeHoleList.iterator(); it.hasNext();) {\n  \t\t\tvar hole = it.next();\n  \t\t\tif (hole.getShell() === null) {\n  \t\t\t\tvar shell = this.findEdgeRingContaining(hole, shellList);\n  \t\t\t\tif (shell === null) throw new TopologyException(\"unable to assign hole to a shell\", hole.getCoordinate(0));\n  \t\t\t\thole.setShell(shell);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tbuildMinimalEdgeRings: function buildMinimalEdgeRings(maxEdgeRings, shellList, freeHoleList) {\n  \t\tvar edgeRings = new ArrayList();\n  \t\tfor (var it = maxEdgeRings.iterator(); it.hasNext();) {\n  \t\t\tvar er = it.next();\n  \t\t\tif (er.getMaxNodeDegree() > 2) {\n  \t\t\t\ter.linkDirectedEdgesForMinimalEdgeRings();\n  \t\t\t\tvar minEdgeRings = er.buildMinimalRings();\n  \t\t\t\tvar shell = this.findShell(minEdgeRings);\n  \t\t\t\tif (shell !== null) {\n  \t\t\t\t\tthis.placePolygonHoles(shell, minEdgeRings);\n  \t\t\t\t\tshellList.add(shell);\n  \t\t\t\t} else {\n  \t\t\t\t\tfreeHoleList.addAll(minEdgeRings);\n  \t\t\t\t}\n  \t\t\t} else {\n  \t\t\t\tedgeRings.add(er);\n  \t\t\t}\n  \t\t}\n  \t\treturn edgeRings;\n  \t},\n  \tcontainsPoint: function containsPoint(p) {\n  \t\tfor (var it = this._shellList.iterator(); it.hasNext();) {\n  \t\t\tvar er = it.next();\n  \t\t\tif (er.containsPoint(p)) return true;\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tbuildMaximalEdgeRings: function buildMaximalEdgeRings(dirEdges) {\n  \t\tvar maxEdgeRings = new ArrayList();\n  \t\tfor (var it = dirEdges.iterator(); it.hasNext();) {\n  \t\t\tvar de = it.next();\n  \t\t\tif (de.isInResult() && de.getLabel().isArea()) {\n  \t\t\t\tif (de.getEdgeRing() === null) {\n  \t\t\t\t\tvar er = new MaximalEdgeRing(de, this._geometryFactory);\n  \t\t\t\t\tmaxEdgeRings.add(er);\n  \t\t\t\t\ter.setInResult();\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\treturn maxEdgeRings;\n  \t},\n  \tplacePolygonHoles: function placePolygonHoles(shell, minEdgeRings) {\n  \t\tfor (var it = minEdgeRings.iterator(); it.hasNext();) {\n  \t\t\tvar er = it.next();\n  \t\t\tif (er.isHole()) {\n  \t\t\t\ter.setShell(shell);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetPolygons: function getPolygons() {\n  \t\tvar resultPolyList = this.computePolygons(this._shellList);\n  \t\treturn resultPolyList;\n  \t},\n  \tfindEdgeRingContaining: function findEdgeRingContaining(testEr, shellList) {\n  \t\tvar testRing = testEr.getLinearRing();\n  \t\tvar testEnv = testRing.getEnvelopeInternal();\n  \t\tvar testPt = testRing.getCoordinateN(0);\n  \t\tvar minShell = null;\n  \t\tvar minEnv = null;\n  \t\tfor (var it = shellList.iterator(); it.hasNext();) {\n  \t\t\tvar tryShell = it.next();\n  \t\t\tvar tryRing = tryShell.getLinearRing();\n  \t\t\tvar tryEnv = tryRing.getEnvelopeInternal();\n  \t\t\tif (minShell !== null) minEnv = minShell.getLinearRing().getEnvelopeInternal();\n  \t\t\tvar isContained = false;\n  \t\t\tif (tryEnv.contains(testEnv) && CGAlgorithms.isPointInRing(testPt, tryRing.getCoordinates())) isContained = true;\n  \t\t\tif (isContained) {\n  \t\t\t\tif (minShell === null || minEnv.contains(tryEnv)) {\n  \t\t\t\t\tminShell = tryShell;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\treturn minShell;\n  \t},\n  \tfindShell: function findShell(minEdgeRings) {\n  \t\tvar shellCount = 0;\n  \t\tvar shell = null;\n  \t\tfor (var it = minEdgeRings.iterator(); it.hasNext();) {\n  \t\t\tvar er = it.next();\n  \t\t\tif (!er.isHole()) {\n  \t\t\t\tshell = er;\n  \t\t\t\tshellCount++;\n  \t\t\t}\n  \t\t}\n  \t\tAssert.isTrue(shellCount <= 1, \"found two shells in MinimalEdgeRing list\");\n  \t\treturn shell;\n  \t},\n  \tadd: function add() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar graph = arguments[0];\n  \t\t\tthis.add(graph.getEdgeEnds(), graph.getNodes());\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar dirEdges = arguments[0],\n  \t\t\t    nodes = arguments[1];\n  \t\t\tPlanarGraph.linkResultDirectedEdges(nodes);\n  \t\t\tvar maxEdgeRings = this.buildMaximalEdgeRings(dirEdges);\n  \t\t\tvar freeHoleList = new ArrayList();\n  \t\t\tvar edgeRings = this.buildMinimalEdgeRings(maxEdgeRings, this._shellList, freeHoleList);\n  \t\t\tthis.sortShellsAndHoles(edgeRings, this._shellList, freeHoleList);\n  \t\t\tthis.placeFreeHoles(this._shellList, freeHoleList);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn PolygonBuilder;\n  \t}\n  });\n\n  function LineBuilder() {\n  \tthis._op = null;\n  \tthis._geometryFactory = null;\n  \tthis._ptLocator = null;\n  \tthis._lineEdgesList = new ArrayList();\n  \tthis._resultLineList = new ArrayList();\n  \tvar op = arguments[0],\n  \t    geometryFactory = arguments[1],\n  \t    ptLocator = arguments[2];\n  \tthis._op = op;\n  \tthis._geometryFactory = geometryFactory;\n  \tthis._ptLocator = ptLocator;\n  }\n  extend(LineBuilder.prototype, {\n  \tcollectLines: function collectLines(opCode) {\n  \t\tfor (var it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext();) {\n  \t\t\tvar de = it.next();\n  \t\t\tthis.collectLineEdge(de, opCode, this._lineEdgesList);\n  \t\t\tthis.collectBoundaryTouchEdge(de, opCode, this._lineEdgesList);\n  \t\t}\n  \t},\n  \tlabelIsolatedLine: function labelIsolatedLine(e, targetIndex) {\n  \t\tvar loc = this._ptLocator.locate(e.getCoordinate(), this._op.getArgGeometry(targetIndex));\n  \t\te.getLabel().setLocation(targetIndex, loc);\n  \t},\n  \tbuild: function build(opCode) {\n  \t\tthis.findCoveredLineEdges();\n  \t\tthis.collectLines(opCode);\n  \t\tthis.buildLines(opCode);\n  \t\treturn this._resultLineList;\n  \t},\n  \tcollectLineEdge: function collectLineEdge(de, opCode, edges) {\n  \t\tvar label = de.getLabel();\n  \t\tvar e = de.getEdge();\n  \t\tif (de.isLineEdge()) {\n  \t\t\tif (!de.isVisited() && OverlayOp.isResultOfOp(label, opCode) && !e.isCovered()) {\n  \t\t\t\tedges.add(e);\n  \t\t\t\tde.setVisitedEdge(true);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tfindCoveredLineEdges: function findCoveredLineEdges() {\n  \t\tfor (var nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext();) {\n  \t\t\tvar node = nodeit.next();\n  \t\t\tnode.getEdges().findCoveredLineEdges();\n  \t\t}\n  \t\tfor (var it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext();) {\n  \t\t\tvar de = it.next();\n  \t\t\tvar e = de.getEdge();\n  \t\t\tif (de.isLineEdge() && !e.isCoveredSet()) {\n  \t\t\t\tvar isCovered = this._op.isCoveredByA(de.getCoordinate());\n  \t\t\t\te.setCovered(isCovered);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tlabelIsolatedLines: function labelIsolatedLines(edgesList) {\n  \t\tfor (var it = edgesList.iterator(); it.hasNext();) {\n  \t\t\tvar e = it.next();\n  \t\t\tvar label = e.getLabel();\n  \t\t\tif (e.isIsolated()) {\n  \t\t\t\tif (label.isNull(0)) this.labelIsolatedLine(e, 0);else this.labelIsolatedLine(e, 1);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tbuildLines: function buildLines(opCode) {\n  \t\tfor (var it = this._lineEdgesList.iterator(); it.hasNext();) {\n  \t\t\tvar e = it.next();\n  \t\t\tvar label = e.getLabel();\n  \t\t\tvar line = this._geometryFactory.createLineString(e.getCoordinates());\n  \t\t\tthis._resultLineList.add(line);\n  \t\t\te.setInResult(true);\n  \t\t}\n  \t},\n  \tcollectBoundaryTouchEdge: function collectBoundaryTouchEdge(de, opCode, edges) {\n  \t\tvar label = de.getLabel();\n  \t\tif (de.isLineEdge()) return null;\n  \t\tif (de.isVisited()) return null;\n  \t\tif (de.isInteriorAreaEdge()) return null;\n  \t\tif (de.getEdge().isInResult()) return null;\n  \t\tAssert.isTrue(!(de.isInResult() || de.getSym().isInResult()) || !de.getEdge().isInResult());\n  \t\tif (OverlayOp.isResultOfOp(label, opCode) && opCode === OverlayOp.INTERSECTION) {\n  \t\t\tedges.add(de.getEdge());\n  \t\t\tde.setVisitedEdge(true);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LineBuilder;\n  \t}\n  });\n\n  function PointBuilder() {\n  \tthis._op = null;\n  \tthis._geometryFactory = null;\n  \tthis._resultPointList = new ArrayList();\n  \tvar op = arguments[0],\n  \t    geometryFactory = arguments[1];\n  \tthis._op = op;\n  \tthis._geometryFactory = geometryFactory;\n  }\n  extend(PointBuilder.prototype, {\n  \tfilterCoveredNodeToPoint: function filterCoveredNodeToPoint(n) {\n  \t\tvar coord = n.getCoordinate();\n  \t\tif (!this._op.isCoveredByLA(coord)) {\n  \t\t\tvar pt = this._geometryFactory.createPoint(coord);\n  \t\t\tthis._resultPointList.add(pt);\n  \t\t}\n  \t},\n  \textractNonCoveredResultNodes: function extractNonCoveredResultNodes(opCode) {\n  \t\tfor (var nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext();) {\n  \t\t\tvar n = nodeit.next();\n  \t\t\tif (n.isInResult()) continue;\n  \t\t\tif (n.isIncidentEdgeInResult()) continue;\n  \t\t\tif (n.getEdges().getDegree() === 0 || opCode === OverlayOp.INTERSECTION) {\n  \t\t\t\tvar label = n.getLabel();\n  \t\t\t\tif (OverlayOp.isResultOfOp(label, opCode)) {\n  \t\t\t\t\tthis.filterCoveredNodeToPoint(n);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tbuild: function build(opCode) {\n  \t\tthis.extractNonCoveredResultNodes(opCode);\n  \t\treturn this._resultPointList;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn PointBuilder;\n  \t}\n  });\n\n  function PointOnGeometryLocator() {}\n  extend(PointOnGeometryLocator.prototype, {\n  \tlocate: function locate(p) {},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn PointOnGeometryLocator;\n  \t}\n  });\n\n  function SimplePointInAreaLocator() {\n  \tthis._geom = null;\n  \tvar geom = arguments[0];\n  \tthis._geom = geom;\n  }\n  extend(SimplePointInAreaLocator.prototype, {\n  \tlocate: function locate(p) {\n  \t\treturn SimplePointInAreaLocator.locate(p, this._geom);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [PointOnGeometryLocator];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SimplePointInAreaLocator;\n  \t}\n  });\n  SimplePointInAreaLocator.isPointInRing = function (p, ring) {\n  \tif (!ring.getEnvelopeInternal().intersects(p)) return false;\n  \treturn CGAlgorithms.isPointInRing(p, ring.getCoordinates());\n  };\n  SimplePointInAreaLocator.containsPointInPolygon = function (p, poly) {\n  \tif (poly.isEmpty()) return false;\n  \tvar shell = poly.getExteriorRing();\n  \tif (!SimplePointInAreaLocator.isPointInRing(p, shell)) return false;\n  \tfor (var i = 0; i < poly.getNumInteriorRing(); i++) {\n  \t\tvar hole = poly.getInteriorRingN(i);\n  \t\tif (SimplePointInAreaLocator.isPointInRing(p, hole)) return false;\n  \t}\n  \treturn true;\n  };\n  SimplePointInAreaLocator.containsPoint = function (p, geom) {\n  \tif (geom instanceof Polygon) {\n  \t\treturn SimplePointInAreaLocator.containsPointInPolygon(p, geom);\n  \t} else if (geom instanceof GeometryCollection) {\n  \t\tvar geomi = new GeometryCollectionIterator(geom);\n  \t\twhile (geomi.hasNext()) {\n  \t\t\tvar g2 = geomi.next();\n  \t\t\tif (g2 !== geom) if (SimplePointInAreaLocator.containsPoint(p, g2)) return true;\n  \t\t}\n  \t}\n  \treturn false;\n  };\n  SimplePointInAreaLocator.locate = function (p, geom) {\n  \tif (geom.isEmpty()) return Location.EXTERIOR;\n  \tif (SimplePointInAreaLocator.containsPoint(p, geom)) return Location.INTERIOR;\n  \treturn Location.EXTERIOR;\n  };\n\n  function EdgeEndStar() {\n  \tthis._edgeMap = new TreeMap();\n  \tthis._edgeList = null;\n  \tthis._ptInAreaLocation = [Location.NONE, Location.NONE];\n  }\n  extend(EdgeEndStar.prototype, {\n  \tgetNextCW: function getNextCW(ee) {\n  \t\tthis.getEdges();\n  \t\tvar i = this._edgeList.indexOf(ee);\n  \t\tvar iNextCW = i - 1;\n  \t\tif (i === 0) iNextCW = this._edgeList.size() - 1;\n  \t\treturn this._edgeList.get(iNextCW);\n  \t},\n  \tpropagateSideLabels: function propagateSideLabels(geomIndex) {\n  \t\tvar startLoc = Location.NONE;\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar e = it.next();\n  \t\t\tvar label = e.getLabel();\n  \t\t\tif (label.isArea(geomIndex) && label.getLocation(geomIndex, Position.LEFT) !== Location.NONE) startLoc = label.getLocation(geomIndex, Position.LEFT);\n  \t\t}\n  \t\tif (startLoc === Location.NONE) return null;\n  \t\tvar currLoc = startLoc;\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar e = it.next();\n  \t\t\tvar label = e.getLabel();\n  \t\t\tif (label.getLocation(geomIndex, Position.ON) === Location.NONE) label.setLocation(geomIndex, Position.ON, currLoc);\n  \t\t\tif (label.isArea(geomIndex)) {\n  \t\t\t\tvar leftLoc = label.getLocation(geomIndex, Position.LEFT);\n  \t\t\t\tvar rightLoc = label.getLocation(geomIndex, Position.RIGHT);\n  \t\t\t\tif (rightLoc !== Location.NONE) {\n  \t\t\t\t\tif (rightLoc !== currLoc) throw new TopologyException(\"side location conflict\", e.getCoordinate());\n  \t\t\t\t\tif (leftLoc === Location.NONE) {\n  \t\t\t\t\t\tAssert.shouldNeverReachHere(\"found single null side (at \" + e.getCoordinate() + \")\");\n  \t\t\t\t\t}\n  \t\t\t\t\tcurrLoc = leftLoc;\n  \t\t\t\t} else {\n  \t\t\t\t\tAssert.isTrue(label.getLocation(geomIndex, Position.LEFT) === Location.NONE, \"found single null side\");\n  \t\t\t\t\tlabel.setLocation(geomIndex, Position.RIGHT, currLoc);\n  \t\t\t\t\tlabel.setLocation(geomIndex, Position.LEFT, currLoc);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\tvar it = this.iterator();\n  \t\tif (!it.hasNext()) return null;\n  \t\tvar e = it.next();\n  \t\treturn e.getCoordinate();\n  \t},\n  \tprint: function print(out) {\n  \t\tSystem.out.println(\"EdgeEndStar:   \" + this.getCoordinate());\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar e = it.next();\n  \t\t\te.print(out);\n  \t\t}\n  \t},\n  \tisAreaLabelsConsistent: function isAreaLabelsConsistent(geomGraph) {\n  \t\tthis.computeEdgeEndLabels(geomGraph.getBoundaryNodeRule());\n  \t\treturn this.checkAreaLabelsConsistent(0);\n  \t},\n  \tcheckAreaLabelsConsistent: function checkAreaLabelsConsistent(geomIndex) {\n  \t\tvar edges = this.getEdges();\n  \t\tif (edges.size() <= 0) return true;\n  \t\tvar lastEdgeIndex = edges.size() - 1;\n  \t\tvar startLabel = edges.get(lastEdgeIndex).getLabel();\n  \t\tvar startLoc = startLabel.getLocation(geomIndex, Position.LEFT);\n  \t\tAssert.isTrue(startLoc !== Location.NONE, \"Found unlabelled area edge\");\n  \t\tvar currLoc = startLoc;\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar e = it.next();\n  \t\t\tvar label = e.getLabel();\n  \t\t\tAssert.isTrue(label.isArea(geomIndex), \"Found non-area edge\");\n  \t\t\tvar leftLoc = label.getLocation(geomIndex, Position.LEFT);\n  \t\t\tvar rightLoc = label.getLocation(geomIndex, Position.RIGHT);\n  \t\t\tif (leftLoc === rightLoc) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t\tif (rightLoc !== currLoc) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t\tcurrLoc = leftLoc;\n  \t\t}\n  \t\treturn true;\n  \t},\n  \tfindIndex: function findIndex(eSearch) {\n  \t\tthis.iterator();\n  \t\tfor (var i = 0; i < this._edgeList.size(); i++) {\n  \t\t\tvar e = this._edgeList.get(i);\n  \t\t\tif (e === eSearch) return i;\n  \t\t}\n  \t\treturn -1;\n  \t},\n  \titerator: function iterator() {\n  \t\treturn this.getEdges().iterator();\n  \t},\n  \tgetEdges: function getEdges() {\n  \t\tif (this._edgeList === null) {\n  \t\t\tthis._edgeList = new ArrayList(this._edgeMap.values());\n  \t\t}\n  \t\treturn this._edgeList;\n  \t},\n  \tgetLocation: function getLocation(geomIndex, p, geom) {\n  \t\tif (this._ptInAreaLocation[geomIndex] === Location.NONE) {\n  \t\t\tthis._ptInAreaLocation[geomIndex] = SimplePointInAreaLocator.locate(p, geom[geomIndex].getGeometry());\n  \t\t}\n  \t\treturn this._ptInAreaLocation[geomIndex];\n  \t},\n  \ttoString: function toString() {\n  \t\tvar buf = new StringBuffer();\n  \t\tbuf.append(\"EdgeEndStar:   \" + this.getCoordinate());\n  \t\tbuf.append(\"\\n\");\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar e = it.next();\n  \t\t\tbuf.append(e);\n  \t\t\tbuf.append(\"\\n\");\n  \t\t}\n  \t\treturn buf.toString();\n  \t},\n  \tcomputeEdgeEndLabels: function computeEdgeEndLabels(boundaryNodeRule) {\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar ee = it.next();\n  \t\t\tee.computeLabel(boundaryNodeRule);\n  \t\t}\n  \t},\n  \tcomputeLabelling: function computeLabelling(geomGraph) {\n  \t\tthis.computeEdgeEndLabels(geomGraph[0].getBoundaryNodeRule());\n  \t\tthis.propagateSideLabels(0);\n  \t\tthis.propagateSideLabels(1);\n  \t\tvar hasDimensionalCollapseEdge = [false, false];\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar e = it.next();\n  \t\t\tvar label = e.getLabel();\n  \t\t\tfor (var geomi = 0; geomi < 2; geomi++) {\n  \t\t\t\tif (label.isLine(geomi) && label.getLocation(geomi) === Location.BOUNDARY) hasDimensionalCollapseEdge[geomi] = true;\n  \t\t\t}\n  \t\t}\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar e = it.next();\n  \t\t\tvar label = e.getLabel();\n  \t\t\tfor (var geomi = 0; geomi < 2; geomi++) {\n  \t\t\t\tif (label.isAnyNull(geomi)) {\n  \t\t\t\t\tvar loc = Location.NONE;\n  \t\t\t\t\tif (hasDimensionalCollapseEdge[geomi]) {\n  \t\t\t\t\t\tloc = Location.EXTERIOR;\n  \t\t\t\t\t} else {\n  \t\t\t\t\t\tvar p = e.getCoordinate();\n  \t\t\t\t\t\tloc = this.getLocation(geomi, p, geomGraph);\n  \t\t\t\t\t}\n  \t\t\t\t\tlabel.setAllLocationsIfNull(geomi, loc);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetDegree: function getDegree() {\n  \t\treturn this._edgeMap.size();\n  \t},\n  \tinsertEdgeEnd: function insertEdgeEnd(e, obj) {\n  \t\tthis._edgeMap.put(e, obj);\n  \t\tthis._edgeList = null;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn EdgeEndStar;\n  \t}\n  });\n\n  function DirectedEdgeStar() {\n  \tEdgeEndStar.apply(this);\n  \tthis._resultAreaEdgeList = null;\n  \tthis._label = null;\n  \tthis._SCANNING_FOR_INCOMING = 1;\n  \tthis._LINKING_TO_OUTGOING = 2;\n  }\n  inherits$1(DirectedEdgeStar, EdgeEndStar);\n  extend(DirectedEdgeStar.prototype, {\n  \tlinkResultDirectedEdges: function linkResultDirectedEdges() {\n  \t\tthis.getResultAreaEdges();\n  \t\tvar firstOut = null;\n  \t\tvar incoming = null;\n  \t\tvar state = this._SCANNING_FOR_INCOMING;\n  \t\tfor (var i = 0; i < this._resultAreaEdgeList.size(); i++) {\n  \t\t\tvar nextOut = this._resultAreaEdgeList.get(i);\n  \t\t\tvar nextIn = nextOut.getSym();\n  \t\t\tif (!nextOut.getLabel().isArea()) continue;\n  \t\t\tif (firstOut === null && nextOut.isInResult()) firstOut = nextOut;\n  \t\t\tswitch (state) {\n  \t\t\t\tcase this._SCANNING_FOR_INCOMING:\n  \t\t\t\t\tif (!nextIn.isInResult()) continue;\n  \t\t\t\t\tincoming = nextIn;\n  \t\t\t\t\tstate = this._LINKING_TO_OUTGOING;\n  \t\t\t\t\tbreak;\n  \t\t\t\tcase this._LINKING_TO_OUTGOING:\n  \t\t\t\t\tif (!nextOut.isInResult()) continue;\n  \t\t\t\t\tincoming.setNext(nextOut);\n  \t\t\t\t\tstate = this._SCANNING_FOR_INCOMING;\n  \t\t\t\t\tbreak;\n  \t\t\t}\n  \t\t}\n  \t\tif (state === this._LINKING_TO_OUTGOING) {\n  \t\t\tif (firstOut === null) throw new TopologyException(\"no outgoing dirEdge found\", this.getCoordinate());\n  \t\t\tAssert.isTrue(firstOut.isInResult(), \"unable to link last incoming dirEdge\");\n  \t\t\tincoming.setNext(firstOut);\n  \t\t}\n  \t},\n  \tinsert: function insert(ee) {\n  \t\tvar de = ee;\n  \t\tthis.insertEdgeEnd(de, de);\n  \t},\n  \tgetRightmostEdge: function getRightmostEdge() {\n  \t\tvar edges = this.getEdges();\n  \t\tvar size = edges.size();\n  \t\tif (size < 1) return null;\n  \t\tvar de0 = edges.get(0);\n  \t\tif (size === 1) return de0;\n  \t\tvar deLast = edges.get(size - 1);\n  \t\tvar quad0 = de0.getQuadrant();\n  \t\tvar quad1 = deLast.getQuadrant();\n  \t\tif (Quadrant.isNorthern(quad0) && Quadrant.isNorthern(quad1)) return de0;else if (!Quadrant.isNorthern(quad0) && !Quadrant.isNorthern(quad1)) return deLast;else {\n  \t\t\tif (de0.getDy() !== 0) return de0;else if (deLast.getDy() !== 0) return deLast;\n  \t\t}\n  \t\tAssert.shouldNeverReachHere(\"found two horizontal edges incident on node\");\n  \t\treturn null;\n  \t},\n  \tprint: function print(out) {\n  \t\tSystem.out.println(\"DirectedEdgeStar: \" + this.getCoordinate());\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar de = it.next();\n  \t\t\tout.print(\"out \");\n  \t\t\tde.print(out);\n  \t\t\tout.println();\n  \t\t\tout.print(\"in \");\n  \t\t\tde.getSym().print(out);\n  \t\t\tout.println();\n  \t\t}\n  \t},\n  \tgetResultAreaEdges: function getResultAreaEdges() {\n  \t\tif (this._resultAreaEdgeList !== null) return this._resultAreaEdgeList;\n  \t\tthis._resultAreaEdgeList = new ArrayList();\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar de = it.next();\n  \t\t\tif (de.isInResult() || de.getSym().isInResult()) this._resultAreaEdgeList.add(de);\n  \t\t}\n  \t\treturn this._resultAreaEdgeList;\n  \t},\n  \tupdateLabelling: function updateLabelling(nodeLabel) {\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar de = it.next();\n  \t\t\tvar label = de.getLabel();\n  \t\t\tlabel.setAllLocationsIfNull(0, nodeLabel.getLocation(0));\n  \t\t\tlabel.setAllLocationsIfNull(1, nodeLabel.getLocation(1));\n  \t\t}\n  \t},\n  \tlinkAllDirectedEdges: function linkAllDirectedEdges() {\n  \t\tthis.getEdges();\n  \t\tvar prevOut = null;\n  \t\tvar firstIn = null;\n  \t\tfor (var i = this._edgeList.size() - 1; i >= 0; i--) {\n  \t\t\tvar nextOut = this._edgeList.get(i);\n  \t\t\tvar nextIn = nextOut.getSym();\n  \t\t\tif (firstIn === null) firstIn = nextIn;\n  \t\t\tif (prevOut !== null) nextIn.setNext(prevOut);\n  \t\t\tprevOut = nextOut;\n  \t\t}\n  \t\tfirstIn.setNext(prevOut);\n  \t},\n  \tcomputeDepths: function computeDepths() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar de = arguments[0];\n  \t\t\tvar edgeIndex = this.findIndex(de);\n  \t\t\tvar label = de.getLabel();\n  \t\t\tvar startDepth = de.getDepth(Position.LEFT);\n  \t\t\tvar targetLastDepth = de.getDepth(Position.RIGHT);\n  \t\t\tvar nextDepth = this.computeDepths(edgeIndex + 1, this._edgeList.size(), startDepth);\n  \t\t\tvar lastDepth = this.computeDepths(0, edgeIndex, nextDepth);\n  \t\t\tif (lastDepth !== targetLastDepth) throw new TopologyException(\"depth mismatch at \" + de.getCoordinate());\n  \t\t} else if (arguments.length === 3) {\n  \t\t\tvar startIndex = arguments[0],\n  \t\t\t    endIndex = arguments[1],\n  \t\t\t    startDepth = arguments[2];\n  \t\t\tvar currDepth = startDepth;\n  \t\t\tfor (var i = startIndex; i < endIndex; i++) {\n  \t\t\t\tvar nextDe = this._edgeList.get(i);\n  \t\t\t\tvar label = nextDe.getLabel();\n  \t\t\t\tnextDe.setEdgeDepths(Position.RIGHT, currDepth);\n  \t\t\t\tcurrDepth = nextDe.getDepth(Position.LEFT);\n  \t\t\t}\n  \t\t\treturn currDepth;\n  \t\t}\n  \t},\n  \tmergeSymLabels: function mergeSymLabels() {\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar de = it.next();\n  \t\t\tvar label = de.getLabel();\n  \t\t\tlabel.merge(de.getSym().getLabel());\n  \t\t}\n  \t},\n  \tlinkMinimalDirectedEdges: function linkMinimalDirectedEdges(er) {\n  \t\tvar firstOut = null;\n  \t\tvar incoming = null;\n  \t\tvar state = this._SCANNING_FOR_INCOMING;\n  \t\tfor (var i = this._resultAreaEdgeList.size() - 1; i >= 0; i--) {\n  \t\t\tvar nextOut = this._resultAreaEdgeList.get(i);\n  \t\t\tvar nextIn = nextOut.getSym();\n  \t\t\tif (firstOut === null && nextOut.getEdgeRing() === er) firstOut = nextOut;\n  \t\t\tswitch (state) {\n  \t\t\t\tcase this._SCANNING_FOR_INCOMING:\n  \t\t\t\t\tif (nextIn.getEdgeRing() !== er) continue;\n  \t\t\t\t\tincoming = nextIn;\n  \t\t\t\t\tstate = this._LINKING_TO_OUTGOING;\n  \t\t\t\t\tbreak;\n  \t\t\t\tcase this._LINKING_TO_OUTGOING:\n  \t\t\t\t\tif (nextOut.getEdgeRing() !== er) continue;\n  \t\t\t\t\tincoming.setNextMin(nextOut);\n  \t\t\t\t\tstate = this._SCANNING_FOR_INCOMING;\n  \t\t\t\t\tbreak;\n  \t\t\t}\n  \t\t}\n  \t\tif (state === this._LINKING_TO_OUTGOING) {\n  \t\t\tAssert.isTrue(firstOut !== null, \"found null for first outgoing dirEdge\");\n  \t\t\tAssert.isTrue(firstOut.getEdgeRing() === er, \"unable to link last incoming dirEdge\");\n  \t\t\tincoming.setNextMin(firstOut);\n  \t\t}\n  \t},\n  \tgetOutgoingDegree: function getOutgoingDegree() {\n  \t\tif (arguments.length === 0) {\n  \t\t\tvar degree = 0;\n  \t\t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\t\tvar de = it.next();\n  \t\t\t\tif (de.isInResult()) degree++;\n  \t\t\t}\n  \t\t\treturn degree;\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tvar er = arguments[0];\n  \t\t\tvar degree = 0;\n  \t\t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\t\tvar de = it.next();\n  \t\t\t\tif (de.getEdgeRing() === er) degree++;\n  \t\t\t}\n  \t\t\treturn degree;\n  \t\t}\n  \t},\n  \tgetLabel: function getLabel() {\n  \t\treturn this._label;\n  \t},\n  \tfindCoveredLineEdges: function findCoveredLineEdges() {\n  \t\tvar startLoc = Location.NONE;\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar nextOut = it.next();\n  \t\t\tvar nextIn = nextOut.getSym();\n  \t\t\tif (!nextOut.isLineEdge()) {\n  \t\t\t\tif (nextOut.isInResult()) {\n  \t\t\t\t\tstartLoc = Location.INTERIOR;\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t\tif (nextIn.isInResult()) {\n  \t\t\t\t\tstartLoc = Location.EXTERIOR;\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\tif (startLoc === Location.NONE) return null;\n  \t\tvar currLoc = startLoc;\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar nextOut = it.next();\n  \t\t\tvar nextIn = nextOut.getSym();\n  \t\t\tif (nextOut.isLineEdge()) {\n  \t\t\t\tnextOut.getEdge().setCovered(currLoc === Location.INTERIOR);\n  \t\t\t} else {\n  \t\t\t\tif (nextOut.isInResult()) currLoc = Location.EXTERIOR;\n  \t\t\t\tif (nextIn.isInResult()) currLoc = Location.INTERIOR;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcomputeLabelling: function computeLabelling(geom) {\n  \t\tEdgeEndStar.prototype.computeLabelling.call(this, geom);\n  \t\tthis._label = new Label(Location.NONE);\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar ee = it.next();\n  \t\t\tvar e = ee.getEdge();\n  \t\t\tvar eLabel = e.getLabel();\n  \t\t\tfor (var i = 0; i < 2; i++) {\n  \t\t\t\tvar eLoc = eLabel.getLocation(i);\n  \t\t\t\tif (eLoc === Location.INTERIOR || eLoc === Location.BOUNDARY) this._label.setLocation(i, Location.INTERIOR);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn DirectedEdgeStar;\n  \t}\n  });\n\n  function OverlayNodeFactory() {\n  \tNodeFactory.apply(this);\n  }\n  inherits$1(OverlayNodeFactory, NodeFactory);\n  extend(OverlayNodeFactory.prototype, {\n  \tcreateNode: function createNode(coord) {\n  \t\treturn new Node(coord, new DirectedEdgeStar());\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn OverlayNodeFactory;\n  \t}\n  });\n\n  function MonotoneChain$1() {\n  \tthis.mce = null;\n  \tthis.chainIndex = null;\n  \tvar mce = arguments[0],\n  \t    chainIndex = arguments[1];\n  \tthis.mce = mce;\n  \tthis.chainIndex = chainIndex;\n  }\n  extend(MonotoneChain$1.prototype, {\n  \tcomputeIntersections: function computeIntersections(mc, si) {\n  \t\tthis.mce.computeIntersectsForChain(this.chainIndex, mc.mce, mc.chainIndex, si);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MonotoneChain$1;\n  \t}\n  });\n\n  function SweepLineEvent() {\n  \tthis._label = null;\n  \tthis._xValue = null;\n  \tthis._eventType = null;\n  \tthis._insertEvent = null;\n  \tthis._deleteEventIndex = null;\n  \tthis._obj = null;\n  \tif (arguments.length === 2) {\n  \t\tvar x = arguments[0],\n  \t\t    insertEvent = arguments[1];\n  \t\tthis._eventType = SweepLineEvent.DELETE;\n  \t\tthis._xValue = x;\n  \t\tthis._insertEvent = insertEvent;\n  \t} else if (arguments.length === 3) {\n  \t\tvar label = arguments[0],\n  \t\t    x = arguments[1],\n  \t\t    obj = arguments[2];\n  \t\tthis._eventType = SweepLineEvent.INSERT;\n  \t\tthis._label = label;\n  \t\tthis._xValue = x;\n  \t\tthis._obj = obj;\n  \t}\n  }\n  extend(SweepLineEvent.prototype, {\n  \tisDelete: function isDelete() {\n  \t\treturn this._eventType === SweepLineEvent.DELETE;\n  \t},\n  \tsetDeleteEventIndex: function setDeleteEventIndex(deleteEventIndex) {\n  \t\tthis._deleteEventIndex = deleteEventIndex;\n  \t},\n  \tgetObject: function getObject() {\n  \t\treturn this._obj;\n  \t},\n  \tcompareTo: function compareTo(o) {\n  \t\tvar pe = o;\n  \t\tif (this._xValue < pe._xValue) return -1;\n  \t\tif (this._xValue > pe._xValue) return 1;\n  \t\tif (this._eventType < pe._eventType) return -1;\n  \t\tif (this._eventType > pe._eventType) return 1;\n  \t\treturn 0;\n  \t},\n  \tgetInsertEvent: function getInsertEvent() {\n  \t\treturn this._insertEvent;\n  \t},\n  \tisInsert: function isInsert() {\n  \t\treturn this._eventType === SweepLineEvent.INSERT;\n  \t},\n  \tisSameLabel: function isSameLabel(ev) {\n  \t\tif (this._label === null) return false;\n  \t\treturn this._label === ev._label;\n  \t},\n  \tgetDeleteEventIndex: function getDeleteEventIndex() {\n  \t\treturn this._deleteEventIndex;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SweepLineEvent;\n  \t}\n  });\n  SweepLineEvent.INSERT = 1;\n  SweepLineEvent.DELETE = 2;\n\n  function EdgeSetIntersector() {}\n  extend(EdgeSetIntersector.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn EdgeSetIntersector;\n  \t}\n  });\n\n  function SegmentIntersector$1() {\n  \tthis._hasIntersection = false;\n  \tthis._hasProper = false;\n  \tthis._hasProperInterior = false;\n  \tthis._properIntersectionPoint = null;\n  \tthis._li = null;\n  \tthis._includeProper = null;\n  \tthis._recordIsolated = null;\n  \tthis._isSelfIntersection = null;\n  \tthis._numIntersections = 0;\n  \tthis.numTests = 0;\n  \tthis._bdyNodes = null;\n  \tthis._isDone = false;\n  \tthis._isDoneWhenProperInt = false;\n  \tvar li = arguments[0],\n  \t    includeProper = arguments[1],\n  \t    recordIsolated = arguments[2];\n  \tthis._li = li;\n  \tthis._includeProper = includeProper;\n  \tthis._recordIsolated = recordIsolated;\n  }\n  extend(SegmentIntersector$1.prototype, {\n  \tisTrivialIntersection: function isTrivialIntersection(e0, segIndex0, e1, segIndex1) {\n  \t\tif (e0 === e1) {\n  \t\t\tif (this._li.getIntersectionNum() === 1) {\n  \t\t\t\tif (SegmentIntersector$1.isAdjacentSegments(segIndex0, segIndex1)) return true;\n  \t\t\t\tif (e0.isClosed()) {\n  \t\t\t\t\tvar maxSegIndex = e0.getNumPoints() - 1;\n  \t\t\t\t\tif (segIndex0 === 0 && segIndex1 === maxSegIndex || segIndex1 === 0 && segIndex0 === maxSegIndex) {\n  \t\t\t\t\t\treturn true;\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tgetProperIntersectionPoint: function getProperIntersectionPoint() {\n  \t\treturn this._properIntersectionPoint;\n  \t},\n  \tsetIsDoneIfProperInt: function setIsDoneIfProperInt(isDoneWhenProperInt) {\n  \t\tthis._isDoneWhenProperInt = isDoneWhenProperInt;\n  \t},\n  \thasProperInteriorIntersection: function hasProperInteriorIntersection() {\n  \t\treturn this._hasProperInterior;\n  \t},\n  \tisBoundaryPointInternal: function isBoundaryPointInternal(li, bdyNodes) {\n  \t\tfor (var i = bdyNodes.iterator(); i.hasNext();) {\n  \t\t\tvar node = i.next();\n  \t\t\tvar pt = node.getCoordinate();\n  \t\t\tif (li.isIntersection(pt)) return true;\n  \t\t}\n  \t\treturn false;\n  \t},\n  \thasProperIntersection: function hasProperIntersection() {\n  \t\treturn this._hasProper;\n  \t},\n  \thasIntersection: function hasIntersection() {\n  \t\treturn this._hasIntersection;\n  \t},\n  \tisDone: function isDone() {\n  \t\treturn this._isDone;\n  \t},\n  \tisBoundaryPoint: function isBoundaryPoint(li, bdyNodes) {\n  \t\tif (bdyNodes === null) return false;\n  \t\tif (this.isBoundaryPointInternal(li, bdyNodes[0])) return true;\n  \t\tif (this.isBoundaryPointInternal(li, bdyNodes[1])) return true;\n  \t\treturn false;\n  \t},\n  \tsetBoundaryNodes: function setBoundaryNodes(bdyNodes0, bdyNodes1) {\n  \t\tthis._bdyNodes = new Array(2).fill(null);\n  \t\tthis._bdyNodes[0] = bdyNodes0;\n  \t\tthis._bdyNodes[1] = bdyNodes1;\n  \t},\n  \taddIntersections: function addIntersections(e0, segIndex0, e1, segIndex1) {\n  \t\tif (e0 === e1 && segIndex0 === segIndex1) return null;\n  \t\tthis.numTests++;\n  \t\tvar p00 = e0.getCoordinates()[segIndex0];\n  \t\tvar p01 = e0.getCoordinates()[segIndex0 + 1];\n  \t\tvar p10 = e1.getCoordinates()[segIndex1];\n  \t\tvar p11 = e1.getCoordinates()[segIndex1 + 1];\n  \t\tthis._li.computeIntersection(p00, p01, p10, p11);\n  \t\tif (this._li.hasIntersection()) {\n  \t\t\tif (this._recordIsolated) {\n  \t\t\t\te0.setIsolated(false);\n  \t\t\t\te1.setIsolated(false);\n  \t\t\t}\n  \t\t\tthis._numIntersections++;\n  \t\t\tif (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {\n  \t\t\t\tthis._hasIntersection = true;\n  \t\t\t\tif (this._includeProper || !this._li.isProper()) {\n  \t\t\t\t\te0.addIntersections(this._li, segIndex0, 0);\n  \t\t\t\t\te1.addIntersections(this._li, segIndex1, 1);\n  \t\t\t\t}\n  \t\t\t\tif (this._li.isProper()) {\n  \t\t\t\t\tthis._properIntersectionPoint = this._li.getIntersection(0).copy();\n  \t\t\t\t\tthis._hasProper = true;\n  \t\t\t\t\tif (this._isDoneWhenProperInt) {\n  \t\t\t\t\t\tthis._isDone = true;\n  \t\t\t\t\t}\n  \t\t\t\t\tif (!this.isBoundaryPoint(this._li, this._bdyNodes)) this._hasProperInterior = true;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SegmentIntersector$1;\n  \t}\n  });\n  SegmentIntersector$1.isAdjacentSegments = function (i1, i2) {\n  \treturn Math.abs(i1 - i2) === 1;\n  };\n\n  function SimpleMCSweepLineIntersector() {\n  \tEdgeSetIntersector.apply(this);\n  \tthis.events = new ArrayList();\n  \tthis.nOverlaps = null;\n  }\n  inherits$1(SimpleMCSweepLineIntersector, EdgeSetIntersector);\n  extend(SimpleMCSweepLineIntersector.prototype, {\n  \tprepareEvents: function prepareEvents() {\n  \t\tCollections.sort(this.events);\n  \t\tfor (var i = 0; i < this.events.size(); i++) {\n  \t\t\tvar ev = this.events.get(i);\n  \t\t\tif (ev.isDelete()) {\n  \t\t\t\tev.getInsertEvent().setDeleteEventIndex(i);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcomputeIntersections: function computeIntersections() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar si = arguments[0];\n  \t\t\tthis.nOverlaps = 0;\n  \t\t\tthis.prepareEvents();\n  \t\t\tfor (var i = 0; i < this.events.size(); i++) {\n  \t\t\t\tvar ev = this.events.get(i);\n  \t\t\t\tif (ev.isInsert()) {\n  \t\t\t\t\tthis.processOverlaps(i, ev.getDeleteEventIndex(), ev, si);\n  \t\t\t\t}\n  \t\t\t\tif (si.isDone()) {\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} else if (arguments.length === 3) {\n  \t\t\tif (arguments[2] instanceof SegmentIntersector$1 && hasInterface(arguments[0], List) && hasInterface(arguments[1], List)) {\n  \t\t\t\tvar edges0 = arguments[0],\n  \t\t\t\t    edges1 = arguments[1],\n  \t\t\t\t    si = arguments[2];\n  \t\t\t\tthis.addEdges(edges0, edges0);\n  \t\t\t\tthis.addEdges(edges1, edges1);\n  \t\t\t\tthis.computeIntersections(si);\n  \t\t\t} else if (typeof arguments[2] === \"boolean\" && hasInterface(arguments[0], List) && arguments[1] instanceof SegmentIntersector$1) {\n  \t\t\t\tvar edges = arguments[0],\n  \t\t\t\t    si = arguments[1],\n  \t\t\t\t    testAllSegments = arguments[2];\n  \t\t\t\tif (testAllSegments) this.addEdges(edges, null);else this.addEdges(edges);\n  \t\t\t\tthis.computeIntersections(si);\n  \t\t\t}\n  \t\t}\n  \t},\n  \taddEdge: function addEdge(edge, edgeSet) {\n  \t\tvar mce = edge.getMonotoneChainEdge();\n  \t\tvar startIndex = mce.getStartIndexes();\n  \t\tfor (var i = 0; i < startIndex.length - 1; i++) {\n  \t\t\tvar mc = new MonotoneChain$1(mce, i);\n  \t\t\tvar insertEvent = new SweepLineEvent(edgeSet, mce.getMinX(i), mc);\n  \t\t\tthis.events.add(insertEvent);\n  \t\t\tthis.events.add(new SweepLineEvent(mce.getMaxX(i), insertEvent));\n  \t\t}\n  \t},\n  \tprocessOverlaps: function processOverlaps(start, end, ev0, si) {\n  \t\tvar mc0 = ev0.getObject();\n  \t\tfor (var i = start; i < end; i++) {\n  \t\t\tvar ev1 = this.events.get(i);\n  \t\t\tif (ev1.isInsert()) {\n  \t\t\t\tvar mc1 = ev1.getObject();\n  \t\t\t\tif (!ev0.isSameLabel(ev1)) {\n  \t\t\t\t\tmc0.computeIntersections(mc1, si);\n  \t\t\t\t\tthis.nOverlaps++;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \taddEdges: function addEdges() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar edges = arguments[0];\n  \t\t\tfor (var i = edges.iterator(); i.hasNext();) {\n  \t\t\t\tvar edge = i.next();\n  \t\t\t\tthis.addEdge(edge, edge);\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar edges = arguments[0],\n  \t\t\t    edgeSet = arguments[1];\n  \t\t\tfor (var i = edges.iterator(); i.hasNext();) {\n  \t\t\t\tvar edge = i.next();\n  \t\t\t\tthis.addEdge(edge, edgeSet);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SimpleMCSweepLineIntersector;\n  \t}\n  });\n\n  function IntervalRTreeNode$1() {\n  \tthis._min = Double.POSITIVE_INFINITY;\n  \tthis._max = Double.NEGATIVE_INFINITY;\n  }\n  extend(IntervalRTreeNode$1.prototype, {\n  \tgetMin: function getMin() {\n  \t\treturn this._min;\n  \t},\n  \tintersects: function intersects(queryMin, queryMax) {\n  \t\tif (this._min > queryMax || this._max < queryMin) return false;\n  \t\treturn true;\n  \t},\n  \tgetMax: function getMax() {\n  \t\treturn this._max;\n  \t},\n  \ttoString: function toString() {\n  \t\treturn WKTWriter.toLineString(new Coordinate(this._min, 0), new Coordinate(this._max, 0));\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn IntervalRTreeNode$1;\n  \t}\n  });\n  function NodeComparator() {}\n  extend(NodeComparator.prototype, {\n  \tcompare: function compare(o1, o2) {\n  \t\tvar n1 = o1;\n  \t\tvar n2 = o2;\n  \t\tvar mid1 = (n1._min + n1._max) / 2;\n  \t\tvar mid2 = (n2._min + n2._max) / 2;\n  \t\tif (mid1 < mid2) return -1;\n  \t\tif (mid1 > mid2) return 1;\n  \t\treturn 0;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparator];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn NodeComparator;\n  \t}\n  });\n  IntervalRTreeNode$1.NodeComparator = NodeComparator;\n\n  function IntervalRTreeLeafNode() {\n  \tIntervalRTreeNode$1.apply(this);\n  \tthis._item = null;\n  \tvar min = arguments[0],\n  \t    max = arguments[1],\n  \t    item = arguments[2];\n  \tthis._min = min;\n  \tthis._max = max;\n  \tthis._item = item;\n  }\n  inherits$1(IntervalRTreeLeafNode, IntervalRTreeNode$1);\n  extend(IntervalRTreeLeafNode.prototype, {\n  \tquery: function query(queryMin, queryMax, visitor) {\n  \t\tif (!this.intersects(queryMin, queryMax)) return null;\n  \t\tvisitor.visitItem(this._item);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn IntervalRTreeLeafNode;\n  \t}\n  });\n\n  function IntervalRTreeBranchNode() {\n  \tIntervalRTreeNode$1.apply(this);\n  \tthis._node1 = null;\n  \tthis._node2 = null;\n  \tvar n1 = arguments[0],\n  \t    n2 = arguments[1];\n  \tthis._node1 = n1;\n  \tthis._node2 = n2;\n  \tthis.buildExtent(this._node1, this._node2);\n  }\n  inherits$1(IntervalRTreeBranchNode, IntervalRTreeNode$1);\n  extend(IntervalRTreeBranchNode.prototype, {\n  \tbuildExtent: function buildExtent(n1, n2) {\n  \t\tthis._min = Math.min(n1._min, n2._min);\n  \t\tthis._max = Math.max(n1._max, n2._max);\n  \t},\n  \tquery: function query(queryMin, queryMax, visitor) {\n  \t\tif (!this.intersects(queryMin, queryMax)) {\n  \t\t\treturn null;\n  \t\t}\n  \t\tif (this._node1 !== null) this._node1.query(queryMin, queryMax, visitor);\n  \t\tif (this._node2 !== null) this._node2.query(queryMin, queryMax, visitor);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn IntervalRTreeBranchNode;\n  \t}\n  });\n\n  function SortedPackedIntervalRTree() {\n  \tthis._leaves = new ArrayList();\n  \tthis._root = null;\n  \tthis._level = 0;\n  }\n  extend(SortedPackedIntervalRTree.prototype, {\n  \tbuildTree: function buildTree() {\n  \t\tCollections.sort(this._leaves, new IntervalRTreeNode.NodeComparator());\n  \t\tvar src = this._leaves;\n  \t\tvar temp = null;\n  \t\tvar dest = new ArrayList();\n  \t\twhile (true) {\n  \t\t\tthis.buildLevel(src, dest);\n  \t\t\tif (dest.size() === 1) return dest.get(0);\n  \t\t\ttemp = src;\n  \t\t\tsrc = dest;\n  \t\t\tdest = temp;\n  \t\t}\n  \t},\n  \tinsert: function insert(min, max, item) {\n  \t\tif (this._root !== null) throw new IllegalStateException(\"Index cannot be added to once it has been queried\");\n  \t\tthis._leaves.add(new IntervalRTreeLeafNode(min, max, item));\n  \t},\n  \tquery: function query(min, max, visitor) {\n  \t\tthis.init();\n  \t\tthis._root.query(min, max, visitor);\n  \t},\n  \tbuildRoot: function buildRoot() {\n  \t\tif (this._root !== null) return null;\n  \t\tthis._root = this.buildTree();\n  \t},\n  \tprintNode: function printNode(node) {\n  \t\tSystem.out.println(WKTWriter.toLineString(new Coordinate(node._min, this._level), new Coordinate(node._max, this._level)));\n  \t},\n  \tinit: function init() {\n  \t\tif (this._root !== null) return null;\n  \t\tthis.buildRoot();\n  \t},\n  \tbuildLevel: function buildLevel(src, dest) {\n  \t\tthis._level++;\n  \t\tdest.clear();\n  \t\tfor (var i = 0; i < src.size(); i += 2) {\n  \t\t\tvar n1 = src.get(i);\n  \t\t\tvar n2 = i + 1 < src.size() ? src.get(i) : null;\n  \t\t\tif (n2 === null) {\n  \t\t\t\tdest.add(n1);\n  \t\t\t} else {\n  \t\t\t\tvar node = new IntervalRTreeBranchNode(src.get(i), src.get(i + 1));\n  \t\t\t\tdest.add(node);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SortedPackedIntervalRTree;\n  \t}\n  });\n\n  function LinearComponentExtracter() {\n  \tthis._lines = null;\n  \tthis._isForcedToLineString = false;\n  \tif (arguments.length === 1) {\n  \t\tvar lines = arguments[0];\n  \t\tthis._lines = lines;\n  \t} else if (arguments.length === 2) {\n  \t\tvar lines = arguments[0],\n  \t\t    isForcedToLineString = arguments[1];\n  \t\tthis._lines = lines;\n  \t\tthis._isForcedToLineString = isForcedToLineString;\n  \t}\n  }\n  extend(LinearComponentExtracter.prototype, {\n  \tfilter: function filter(geom) {\n  \t\tif (this._isForcedToLineString && geom instanceof LinearRing) {\n  \t\t\tvar line = geom.getFactory().createLineString(geom.getCoordinateSequence());\n  \t\t\tthis._lines.add(line);\n  \t\t\treturn null;\n  \t\t}\n  \t\tif (geom instanceof LineString) this._lines.add(geom);\n  \t},\n  \tsetForceToLineString: function setForceToLineString(isForcedToLineString) {\n  \t\tthis._isForcedToLineString = isForcedToLineString;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [GeometryComponentFilter];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LinearComponentExtracter;\n  \t}\n  });\n  LinearComponentExtracter.getGeometry = function () {\n  \tif (arguments.length === 1) {\n  \t\tvar geom = arguments[0];\n  \t\treturn geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom));\n  \t} else if (arguments.length === 2) {\n  \t\tvar geom = arguments[0],\n  \t\t    forceToLineString = arguments[1];\n  \t\treturn geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom, forceToLineString));\n  \t}\n  };\n  LinearComponentExtracter.getLines = function () {\n  \tif (arguments.length === 1) {\n  \t\tvar geom = arguments[0];\n  \t\treturn LinearComponentExtracter.getLines(geom, false);\n  \t} else if (arguments.length === 2) {\n  \t\tif (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection)) {\n  \t\t\tvar geoms = arguments[0],\n  \t\t\t    lines = arguments[1];\n  \t\t\tfor (var i = geoms.iterator(); i.hasNext();) {\n  \t\t\t\tvar g = i.next();\n  \t\t\t\tLinearComponentExtracter.getLines(g, lines);\n  \t\t\t}\n  \t\t\treturn lines;\n  \t\t} else if (arguments[0] instanceof Geometry && typeof arguments[1] === \"boolean\") {\n  \t\t\tvar geom = arguments[0],\n  \t\t\t    forceToLineString = arguments[1];\n  \t\t\tvar lines = new ArrayList();\n  \t\t\tgeom.apply(new LinearComponentExtracter(lines, forceToLineString));\n  \t\t\treturn lines;\n  \t\t} else if (arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection)) {\n  \t\t\tvar geom = arguments[0],\n  \t\t\t    lines = arguments[1];\n  \t\t\tif (geom instanceof LineString) {\n  \t\t\t\tlines.add(geom);\n  \t\t\t} else {\n  \t\t\t\tgeom.apply(new LinearComponentExtracter(lines));\n  \t\t\t}\n  \t\t\treturn lines;\n  \t\t}\n  \t} else if (arguments.length === 3) {\n  \t\tif (typeof arguments[2] === \"boolean\" && hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection)) {\n  \t\t\tvar geoms = arguments[0],\n  \t\t\t    lines = arguments[1],\n  \t\t\t    forceToLineString = arguments[2];\n  \t\t\tfor (var i = geoms.iterator(); i.hasNext();) {\n  \t\t\t\tvar g = i.next();\n  \t\t\t\tLinearComponentExtracter.getLines(g, lines, forceToLineString);\n  \t\t\t}\n  \t\t\treturn lines;\n  \t\t} else if (typeof arguments[2] === \"boolean\" && arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection)) {\n  \t\t\tvar geom = arguments[0],\n  \t\t\t    lines = arguments[1],\n  \t\t\t    forceToLineString = arguments[2];\n  \t\t\tgeom.apply(new LinearComponentExtracter(lines, forceToLineString));\n  \t\t\treturn lines;\n  \t\t}\n  \t}\n  };\n\n  function ArrayListVisitor() {\n  \tthis._items = new ArrayList();\n  }\n  extend(ArrayListVisitor.prototype, {\n  \tvisitItem: function visitItem(item) {\n  \t\tthis._items.add(item);\n  \t},\n  \tgetItems: function getItems() {\n  \t\treturn this._items;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [ItemVisitor];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn ArrayListVisitor;\n  \t}\n  });\n\n  function IndexedPointInAreaLocator() {\n  \tthis._index = null;\n  \tvar g = arguments[0];\n  \tif (!hasInterface(g, Polygonal)) throw new IllegalArgumentException(\"Argument must be Polygonal\");\n  \tthis._index = new IntervalIndexedGeometry(g);\n  }\n  extend(IndexedPointInAreaLocator.prototype, {\n  \tlocate: function locate(p) {\n  \t\tvar rcc = new RayCrossingCounter(p);\n  \t\tvar visitor = new SegmentVisitor(rcc);\n  \t\tthis._index.query(p.y, p.y, visitor);\n  \t\treturn rcc.getLocation();\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [PointOnGeometryLocator];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn IndexedPointInAreaLocator;\n  \t}\n  });\n  function SegmentVisitor() {\n  \tthis._counter = null;\n  \tvar counter = arguments[0];\n  \tthis._counter = counter;\n  }\n  extend(SegmentVisitor.prototype, {\n  \tvisitItem: function visitItem(item) {\n  \t\tvar seg = item;\n  \t\tthis._counter.countSegment(seg.getCoordinate(0), seg.getCoordinate(1));\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [ItemVisitor];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SegmentVisitor;\n  \t}\n  });\n  function IntervalIndexedGeometry() {\n  \tthis._index = new SortedPackedIntervalRTree();\n  \tvar geom = arguments[0];\n  \tthis.init(geom);\n  }\n  extend(IntervalIndexedGeometry.prototype, {\n  \tinit: function init(geom) {\n  \t\tvar lines = LinearComponentExtracter.getLines(geom);\n  \t\tfor (var i = lines.iterator(); i.hasNext();) {\n  \t\t\tvar line = i.next();\n  \t\t\tvar pts = line.getCoordinates();\n  \t\t\tthis.addLine(pts);\n  \t\t}\n  \t},\n  \taddLine: function addLine(pts) {\n  \t\tfor (var i = 1; i < pts.length; i++) {\n  \t\t\tvar seg = new LineSegment(pts[i - 1], pts[i]);\n  \t\t\tvar min = Math.min(seg.p0.y, seg.p1.y);\n  \t\t\tvar max = Math.max(seg.p0.y, seg.p1.y);\n  \t\t\tthis._index.insert(min, max, seg);\n  \t\t}\n  \t},\n  \tquery: function query() {\n  \t\tif (arguments.length === 2) {\n  \t\t\tvar min = arguments[0],\n  \t\t\t    max = arguments[1];\n  \t\t\tvar visitor = new ArrayListVisitor();\n  \t\t\tthis._index.query(min, max, visitor);\n  \t\t\treturn visitor.getItems();\n  \t\t} else if (arguments.length === 3) {\n  \t\t\tvar min = arguments[0],\n  \t\t\t    max = arguments[1],\n  \t\t\t    visitor = arguments[2];\n  \t\t\tthis._index.query(min, max, visitor);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn IntervalIndexedGeometry;\n  \t}\n  });\n  IndexedPointInAreaLocator.SegmentVisitor = SegmentVisitor;\n  IndexedPointInAreaLocator.IntervalIndexedGeometry = IntervalIndexedGeometry;\n\n  function EdgeIntersection() {\n  \tthis.coord = null;\n  \tthis.segmentIndex = null;\n  \tthis.dist = null;\n  \tvar coord = arguments[0],\n  \t    segmentIndex = arguments[1],\n  \t    dist = arguments[2];\n  \tthis.coord = new Coordinate(coord);\n  \tthis.segmentIndex = segmentIndex;\n  \tthis.dist = dist;\n  }\n  extend(EdgeIntersection.prototype, {\n  \tgetSegmentIndex: function getSegmentIndex() {\n  \t\treturn this.segmentIndex;\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\treturn this.coord;\n  \t},\n  \tprint: function print(out) {\n  \t\tout.print(this.coord);\n  \t\tout.print(\" seg # = \" + this.segmentIndex);\n  \t\tout.println(\" dist = \" + this.dist);\n  \t},\n  \tcompareTo: function compareTo(obj) {\n  \t\tvar other = obj;\n  \t\treturn this.compare(other.segmentIndex, other.dist);\n  \t},\n  \tisEndPoint: function isEndPoint(maxSegmentIndex) {\n  \t\tif (this.segmentIndex === 0 && this.dist === 0.0) return true;\n  \t\tif (this.segmentIndex === maxSegmentIndex) return true;\n  \t\treturn false;\n  \t},\n  \ttoString: function toString() {\n  \t\treturn this.coord + \" seg # = \" + this.segmentIndex + \" dist = \" + this.dist;\n  \t},\n  \tgetDistance: function getDistance() {\n  \t\treturn this.dist;\n  \t},\n  \tcompare: function compare(segmentIndex, dist) {\n  \t\tif (this.segmentIndex < segmentIndex) return -1;\n  \t\tif (this.segmentIndex > segmentIndex) return 1;\n  \t\tif (this.dist < dist) return -1;\n  \t\tif (this.dist > dist) return 1;\n  \t\treturn 0;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn EdgeIntersection;\n  \t}\n  });\n\n  function EdgeIntersectionList() {\n  \tthis._nodeMap = new TreeMap();\n  \tthis.edge = null;\n  \tvar edge = arguments[0];\n  \tthis.edge = edge;\n  }\n  extend(EdgeIntersectionList.prototype, {\n  \tprint: function print(out) {\n  \t\tout.println(\"Intersections:\");\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar ei = it.next();\n  \t\t\tei.print(out);\n  \t\t}\n  \t},\n  \titerator: function iterator() {\n  \t\treturn this._nodeMap.values().iterator();\n  \t},\n  \taddSplitEdges: function addSplitEdges(edgeList) {\n  \t\tthis.addEndpoints();\n  \t\tvar it = this.iterator();\n  \t\tvar eiPrev = it.next();\n  \t\twhile (it.hasNext()) {\n  \t\t\tvar ei = it.next();\n  \t\t\tvar newEdge = this.createSplitEdge(eiPrev, ei);\n  \t\t\tedgeList.add(newEdge);\n  \t\t\teiPrev = ei;\n  \t\t}\n  \t},\n  \taddEndpoints: function addEndpoints() {\n  \t\tvar maxSegIndex = this.edge.pts.length - 1;\n  \t\tthis.add(this.edge.pts[0], 0, 0.0);\n  \t\tthis.add(this.edge.pts[maxSegIndex], maxSegIndex, 0.0);\n  \t},\n  \tcreateSplitEdge: function createSplitEdge(ei0, ei1) {\n  \t\tvar npts = ei1.segmentIndex - ei0.segmentIndex + 2;\n  \t\tvar lastSegStartPt = this.edge.pts[ei1.segmentIndex];\n  \t\tvar useIntPt1 = ei1.dist > 0.0 || !ei1.coord.equals2D(lastSegStartPt);\n  \t\tif (!useIntPt1) {\n  \t\t\tnpts--;\n  \t\t}\n  \t\tvar pts = new Array(npts).fill(null);\n  \t\tvar ipt = 0;\n  \t\tpts[ipt++] = new Coordinate(ei0.coord);\n  \t\tfor (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {\n  \t\t\tpts[ipt++] = this.edge.pts[i];\n  \t\t}\n  \t\tif (useIntPt1) pts[ipt] = ei1.coord;\n  \t\treturn new Edge(pts, new Label(this.edge._label));\n  \t},\n  \tadd: function add(intPt, segmentIndex, dist) {\n  \t\tvar eiNew = new EdgeIntersection(intPt, segmentIndex, dist);\n  \t\tvar ei = this._nodeMap.get(eiNew);\n  \t\tif (ei !== null) {\n  \t\t\treturn ei;\n  \t\t}\n  \t\tthis._nodeMap.put(eiNew, eiNew);\n  \t\treturn eiNew;\n  \t},\n  \tisIntersection: function isIntersection(pt) {\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar ei = it.next();\n  \t\t\tif (ei.coord.equals(pt)) return true;\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn EdgeIntersectionList;\n  \t}\n  });\n\n  function MonotoneChainIndexer() {}\n  extend(MonotoneChainIndexer.prototype, {\n  \tgetChainStartIndices: function getChainStartIndices(pts) {\n  \t\tvar start = 0;\n  \t\tvar startIndexList = new ArrayList();\n  \t\tstartIndexList.add(new Integer(start));\n  \t\tdo {\n  \t\t\tvar last = this.findChainEnd(pts, start);\n  \t\t\tstartIndexList.add(new Integer(last));\n  \t\t\tstart = last;\n  \t\t} while (start < pts.length - 1);\n  \t\tvar startIndex = MonotoneChainIndexer.toIntArray(startIndexList);\n  \t\treturn startIndex;\n  \t},\n  \tfindChainEnd: function findChainEnd(pts, start) {\n  \t\tvar chainQuad = Quadrant.quadrant(pts[start], pts[start + 1]);\n  \t\tvar last = start + 1;\n  \t\twhile (last < pts.length) {\n  \t\t\tvar quad = Quadrant.quadrant(pts[last - 1], pts[last]);\n  \t\t\tif (quad !== chainQuad) break;\n  \t\t\tlast++;\n  \t\t}\n  \t\treturn last - 1;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MonotoneChainIndexer;\n  \t}\n  });\n  MonotoneChainIndexer.toIntArray = function (list) {\n  \tvar array = new Array(list.size()).fill(null);\n  \tfor (var i = 0; i < array.length; i++) {\n  \t\tarray[i] = list.get(i).intValue();\n  \t}\n  \treturn array;\n  };\n\n  function MonotoneChainEdge() {\n  \tthis.e = null;\n  \tthis.pts = null;\n  \tthis.startIndex = null;\n  \tthis.env1 = new Envelope();\n  \tthis.env2 = new Envelope();\n  \tvar e = arguments[0];\n  \tthis.e = e;\n  \tthis.pts = e.getCoordinates();\n  \tvar mcb = new MonotoneChainIndexer();\n  \tthis.startIndex = mcb.getChainStartIndices(this.pts);\n  }\n  extend(MonotoneChainEdge.prototype, {\n  \tgetCoordinates: function getCoordinates() {\n  \t\treturn this.pts;\n  \t},\n  \tgetMaxX: function getMaxX(chainIndex) {\n  \t\tvar x1 = this.pts[this.startIndex[chainIndex]].x;\n  \t\tvar x2 = this.pts[this.startIndex[chainIndex + 1]].x;\n  \t\treturn x1 > x2 ? x1 : x2;\n  \t},\n  \tgetMinX: function getMinX(chainIndex) {\n  \t\tvar x1 = this.pts[this.startIndex[chainIndex]].x;\n  \t\tvar x2 = this.pts[this.startIndex[chainIndex + 1]].x;\n  \t\treturn x1 < x2 ? x1 : x2;\n  \t},\n  \tcomputeIntersectsForChain: function computeIntersectsForChain() {\n  \t\tif (arguments.length === 4) {\n  \t\t\tvar chainIndex0 = arguments[0],\n  \t\t\t    mce = arguments[1],\n  \t\t\t    chainIndex1 = arguments[2],\n  \t\t\t    si = arguments[3];\n  \t\t\tthis.computeIntersectsForChain(this.startIndex[chainIndex0], this.startIndex[chainIndex0 + 1], mce, mce.startIndex[chainIndex1], mce.startIndex[chainIndex1 + 1], si);\n  \t\t} else if (arguments.length === 6) {\n  \t\t\tvar start0 = arguments[0],\n  \t\t\t    end0 = arguments[1],\n  \t\t\t    mce = arguments[2],\n  \t\t\t    start1 = arguments[3],\n  \t\t\t    end1 = arguments[4],\n  \t\t\t    ei = arguments[5];\n  \t\t\tvar p00 = this.pts[start0];\n  \t\t\tvar p01 = this.pts[end0];\n  \t\t\tvar p10 = mce.pts[start1];\n  \t\t\tvar p11 = mce.pts[end1];\n  \t\t\tif (end0 - start0 === 1 && end1 - start1 === 1) {\n  \t\t\t\tei.addIntersections(this.e, start0, mce.e, start1);\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t\tthis.env1.init(p00, p01);\n  \t\t\tthis.env2.init(p10, p11);\n  \t\t\tif (!this.env1.intersects(this.env2)) return null;\n  \t\t\tvar mid0 = Math.trunc((start0 + end0) / 2);\n  \t\t\tvar mid1 = Math.trunc((start1 + end1) / 2);\n  \t\t\tif (start0 < mid0) {\n  \t\t\t\tif (start1 < mid1) this.computeIntersectsForChain(start0, mid0, mce, start1, mid1, ei);\n  \t\t\t\tif (mid1 < end1) this.computeIntersectsForChain(start0, mid0, mce, mid1, end1, ei);\n  \t\t\t}\n  \t\t\tif (mid0 < end0) {\n  \t\t\t\tif (start1 < mid1) this.computeIntersectsForChain(mid0, end0, mce, start1, mid1, ei);\n  \t\t\t\tif (mid1 < end1) this.computeIntersectsForChain(mid0, end0, mce, mid1, end1, ei);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetStartIndexes: function getStartIndexes() {\n  \t\treturn this.startIndex;\n  \t},\n  \tcomputeIntersects: function computeIntersects(mce, si) {\n  \t\tfor (var i = 0; i < this.startIndex.length - 1; i++) {\n  \t\t\tfor (var j = 0; j < mce.startIndex.length - 1; j++) {\n  \t\t\t\tthis.computeIntersectsForChain(i, mce, j, si);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MonotoneChainEdge;\n  \t}\n  });\n\n  function Depth() {\n  \tthis._depth = Array(2).fill().map(function () {\n  \t\treturn Array(3);\n  \t});\n  \tfor (var i = 0; i < 2; i++) {\n  \t\tfor (var j = 0; j < 3; j++) {\n  \t\t\tthis._depth[i][j] = Depth.NULL_VALUE;\n  \t\t}\n  \t}\n  }\n  extend(Depth.prototype, {\n  \tgetDepth: function getDepth(geomIndex, posIndex) {\n  \t\treturn this._depth[geomIndex][posIndex];\n  \t},\n  \tsetDepth: function setDepth(geomIndex, posIndex, depthValue) {\n  \t\tthis._depth[geomIndex][posIndex] = depthValue;\n  \t},\n  \tisNull: function isNull() {\n  \t\tif (arguments.length === 0) {\n  \t\t\tfor (var i = 0; i < 2; i++) {\n  \t\t\t\tfor (var j = 0; j < 3; j++) {\n  \t\t\t\t\tif (this._depth[i][j] !== Depth.NULL_VALUE) return false;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\treturn true;\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tvar geomIndex = arguments[0];\n  \t\t\treturn this._depth[geomIndex][1] === Depth.NULL_VALUE;\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar geomIndex = arguments[0],\n  \t\t\t    posIndex = arguments[1];\n  \t\t\treturn this._depth[geomIndex][posIndex] === Depth.NULL_VALUE;\n  \t\t}\n  \t},\n  \tnormalize: function normalize() {\n  \t\tfor (var i = 0; i < 2; i++) {\n  \t\t\tif (!this.isNull(i)) {\n  \t\t\t\tvar minDepth = this._depth[i][1];\n  \t\t\t\tif (this._depth[i][2] < minDepth) minDepth = this._depth[i][2];\n  \t\t\t\tif (minDepth < 0) minDepth = 0;\n  \t\t\t\tfor (var j = 1; j < 3; j++) {\n  \t\t\t\t\tvar newValue = 0;\n  \t\t\t\t\tif (this._depth[i][j] > minDepth) newValue = 1;\n  \t\t\t\t\tthis._depth[i][j] = newValue;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetDelta: function getDelta(geomIndex) {\n  \t\treturn this._depth[geomIndex][Position.RIGHT] - this._depth[geomIndex][Position.LEFT];\n  \t},\n  \tgetLocation: function getLocation(geomIndex, posIndex) {\n  \t\tif (this._depth[geomIndex][posIndex] <= 0) return Location.EXTERIOR;\n  \t\treturn Location.INTERIOR;\n  \t},\n  \ttoString: function toString() {\n  \t\treturn \"A: \" + this._depth[0][1] + \",\" + this._depth[0][2] + \" B: \" + this._depth[1][1] + \",\" + this._depth[1][2];\n  \t},\n  \tadd: function add() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar lbl = arguments[0];\n  \t\t\tfor (var i = 0; i < 2; i++) {\n  \t\t\t\tfor (var j = 1; j < 3; j++) {\n  \t\t\t\t\tvar loc = lbl.getLocation(i, j);\n  \t\t\t\t\tif (loc === Location.EXTERIOR || loc === Location.INTERIOR) {\n  \t\t\t\t\t\tif (this.isNull(i, j)) {\n  \t\t\t\t\t\t\tthis._depth[i][j] = Depth.depthAtLocation(loc);\n  \t\t\t\t\t\t} else this._depth[i][j] += Depth.depthAtLocation(loc);\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} else if (arguments.length === 3) {\n  \t\t\tvar geomIndex = arguments[0],\n  \t\t\t    posIndex = arguments[1],\n  \t\t\t    location = arguments[2];\n  \t\t\tif (location === Location.INTERIOR) this._depth[geomIndex][posIndex]++;\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Depth;\n  \t}\n  });\n  Depth.depthAtLocation = function (location) {\n  \tif (location === Location.EXTERIOR) return 0;\n  \tif (location === Location.INTERIOR) return 1;\n  \treturn Depth.NULL_VALUE;\n  };\n  Depth.NULL_VALUE = -1;\n\n  function Edge() {\n  \tGraphComponent.apply(this);\n  \tthis.pts = null;\n  \tthis._env = null;\n  \tthis.eiList = new EdgeIntersectionList(this);\n  \tthis._name = null;\n  \tthis._mce = null;\n  \tthis._isIsolated = true;\n  \tthis._depth = new Depth();\n  \tthis._depthDelta = 0;\n  \tif (arguments.length === 1) {\n  \t\tvar pts = arguments[0];\n  \t\tEdge.call(this, pts, null);\n  \t} else if (arguments.length === 2) {\n  \t\tvar pts = arguments[0],\n  \t\t    label = arguments[1];\n  \t\tthis.pts = pts;\n  \t\tthis._label = label;\n  \t}\n  }\n  inherits$1(Edge, GraphComponent);\n  extend(Edge.prototype, {\n  \tgetDepth: function getDepth() {\n  \t\treturn this._depth;\n  \t},\n  \tgetCollapsedEdge: function getCollapsedEdge() {\n  \t\tvar newPts = new Array(2).fill(null);\n  \t\tnewPts[0] = this.pts[0];\n  \t\tnewPts[1] = this.pts[1];\n  \t\tvar newe = new Edge(newPts, Label.toLineLabel(this._label));\n  \t\treturn newe;\n  \t},\n  \tisIsolated: function isIsolated() {\n  \t\treturn this._isIsolated;\n  \t},\n  \tgetCoordinates: function getCoordinates() {\n  \t\treturn this.pts;\n  \t},\n  \tsetIsolated: function setIsolated(isIsolated) {\n  \t\tthis._isIsolated = isIsolated;\n  \t},\n  \tsetName: function setName(name) {\n  \t\tthis._name = name;\n  \t},\n  \tequals: function equals(o) {\n  \t\tif (!(o instanceof Edge)) return false;\n  \t\tvar e = o;\n  \t\tif (this.pts.length !== e.pts.length) return false;\n  \t\tvar isEqualForward = true;\n  \t\tvar isEqualReverse = true;\n  \t\tvar iRev = this.pts.length;\n  \t\tfor (var i = 0; i < this.pts.length; i++) {\n  \t\t\tif (!this.pts[i].equals2D(e.pts[i])) {\n  \t\t\t\tisEqualForward = false;\n  \t\t\t}\n  \t\t\tif (!this.pts[i].equals2D(e.pts[--iRev])) {\n  \t\t\t\tisEqualReverse = false;\n  \t\t\t}\n  \t\t\tif (!isEqualForward && !isEqualReverse) return false;\n  \t\t}\n  \t\treturn true;\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\tif (arguments.length === 0) {\n  \t\t\tif (this.pts.length > 0) return this.pts[0];\n  \t\t\treturn null;\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tvar i = arguments[0];\n  \t\t\treturn this.pts[i];\n  \t\t}\n  \t},\n  \tprint: function print(out) {\n  \t\tout.print(\"edge \" + this._name + \": \");\n  \t\tout.print(\"LINESTRING (\");\n  \t\tfor (var i = 0; i < this.pts.length; i++) {\n  \t\t\tif (i > 0) out.print(\",\");\n  \t\t\tout.print(this.pts[i].x + \" \" + this.pts[i].y);\n  \t\t}\n  \t\tout.print(\")  \" + this._label + \" \" + this._depthDelta);\n  \t},\n  \tcomputeIM: function computeIM(im) {\n  \t\tEdge.updateIM(this._label, im);\n  \t},\n  \tisCollapsed: function isCollapsed() {\n  \t\tif (!this._label.isArea()) return false;\n  \t\tif (this.pts.length !== 3) return false;\n  \t\tif (this.pts[0].equals(this.pts[2])) return true;\n  \t\treturn false;\n  \t},\n  \tisClosed: function isClosed() {\n  \t\treturn this.pts[0].equals(this.pts[this.pts.length - 1]);\n  \t},\n  \tgetMaximumSegmentIndex: function getMaximumSegmentIndex() {\n  \t\treturn this.pts.length - 1;\n  \t},\n  \tgetDepthDelta: function getDepthDelta() {\n  \t\treturn this._depthDelta;\n  \t},\n  \tgetNumPoints: function getNumPoints() {\n  \t\treturn this.pts.length;\n  \t},\n  \tprintReverse: function printReverse(out) {\n  \t\tout.print(\"edge \" + this._name + \": \");\n  \t\tfor (var i = this.pts.length - 1; i >= 0; i--) {\n  \t\t\tout.print(this.pts[i] + \" \");\n  \t\t}\n  \t\tout.println(\"\");\n  \t},\n  \tgetMonotoneChainEdge: function getMonotoneChainEdge() {\n  \t\tif (this._mce === null) this._mce = new MonotoneChainEdge(this);\n  \t\treturn this._mce;\n  \t},\n  \tgetEnvelope: function getEnvelope() {\n  \t\tif (this._env === null) {\n  \t\t\tthis._env = new Envelope();\n  \t\t\tfor (var i = 0; i < this.pts.length; i++) {\n  \t\t\t\tthis._env.expandToInclude(this.pts[i]);\n  \t\t\t}\n  \t\t}\n  \t\treturn this._env;\n  \t},\n  \taddIntersection: function addIntersection(li, segmentIndex, geomIndex, intIndex) {\n  \t\tvar intPt = new Coordinate(li.getIntersection(intIndex));\n  \t\tvar normalizedSegmentIndex = segmentIndex;\n  \t\tvar dist = li.getEdgeDistance(geomIndex, intIndex);\n  \t\tvar nextSegIndex = normalizedSegmentIndex + 1;\n  \t\tif (nextSegIndex < this.pts.length) {\n  \t\t\tvar nextPt = this.pts[nextSegIndex];\n  \t\t\tif (intPt.equals2D(nextPt)) {\n  \t\t\t\tnormalizedSegmentIndex = nextSegIndex;\n  \t\t\t\tdist = 0.0;\n  \t\t\t}\n  \t\t}\n  \t\tvar ei = this.eiList.add(intPt, normalizedSegmentIndex, dist);\n  \t},\n  \ttoString: function toString() {\n  \t\tvar buf = new StringBuffer();\n  \t\tbuf.append(\"edge \" + this._name + \": \");\n  \t\tbuf.append(\"LINESTRING (\");\n  \t\tfor (var i = 0; i < this.pts.length; i++) {\n  \t\t\tif (i > 0) buf.append(\",\");\n  \t\t\tbuf.append(this.pts[i].x + \" \" + this.pts[i].y);\n  \t\t}\n  \t\tbuf.append(\")  \" + this._label + \" \" + this._depthDelta);\n  \t\treturn buf.toString();\n  \t},\n  \tisPointwiseEqual: function isPointwiseEqual(e) {\n  \t\tif (this.pts.length !== e.pts.length) return false;\n  \t\tfor (var i = 0; i < this.pts.length; i++) {\n  \t\t\tif (!this.pts[i].equals2D(e.pts[i])) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t}\n  \t\treturn true;\n  \t},\n  \tsetDepthDelta: function setDepthDelta(depthDelta) {\n  \t\tthis._depthDelta = depthDelta;\n  \t},\n  \tgetEdgeIntersectionList: function getEdgeIntersectionList() {\n  \t\treturn this.eiList;\n  \t},\n  \taddIntersections: function addIntersections(li, segmentIndex, geomIndex) {\n  \t\tfor (var i = 0; i < li.getIntersectionNum(); i++) {\n  \t\t\tthis.addIntersection(li, segmentIndex, geomIndex, i);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Edge;\n  \t}\n  });\n  Edge.updateIM = function () {\n  \tif (arguments.length === 2) {\n  \t\tvar label = arguments[0],\n  \t\t    im = arguments[1];\n  \t\tim.setAtLeastIfValid(label.getLocation(0, Position.ON), label.getLocation(1, Position.ON), 1);\n  \t\tif (label.isArea()) {\n  \t\t\tim.setAtLeastIfValid(label.getLocation(0, Position.LEFT), label.getLocation(1, Position.LEFT), 2);\n  \t\t\tim.setAtLeastIfValid(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), 2);\n  \t\t}\n  \t} else return GraphComponent.prototype.updateIM.apply(this, arguments);\n  };\n\n  function GeometryGraph() {\n  \tPlanarGraph.apply(this);\n  \tthis._parentGeom = null;\n  \tthis._lineEdgeMap = new HashMap();\n  \tthis._boundaryNodeRule = null;\n  \tthis._useBoundaryDeterminationRule = true;\n  \tthis._argIndex = null;\n  \tthis._boundaryNodes = null;\n  \tthis._hasTooFewPoints = false;\n  \tthis._invalidPoint = null;\n  \tthis._areaPtLocator = null;\n  \tthis._ptLocator = new PointLocator();\n  \tif (arguments.length === 2) {\n  \t\tvar argIndex = arguments[0],\n  \t\t    parentGeom = arguments[1];\n  \t\tGeometryGraph.call(this, argIndex, parentGeom, BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE);\n  \t} else if (arguments.length === 3) {\n  \t\tvar argIndex = arguments[0],\n  \t\t    parentGeom = arguments[1],\n  \t\t    boundaryNodeRule = arguments[2];\n  \t\tthis._argIndex = argIndex;\n  \t\tthis._parentGeom = parentGeom;\n  \t\tthis._boundaryNodeRule = boundaryNodeRule;\n  \t\tif (parentGeom !== null) {\n  \t\t\tthis.add(parentGeom);\n  \t\t}\n  \t}\n  }\n  inherits$1(GeometryGraph, PlanarGraph);\n  extend(GeometryGraph.prototype, {\n  \tinsertBoundaryPoint: function insertBoundaryPoint(argIndex, coord) {\n  \t\tvar n = this._nodes.addNode(coord);\n  \t\tvar lbl = n.getLabel();\n  \t\tvar boundaryCount = 1;\n  \t\tvar loc = Location.NONE;\n  \t\tloc = lbl.getLocation(argIndex, Position.ON);\n  \t\tif (loc === Location.BOUNDARY) boundaryCount++;\n  \t\tvar newLoc = GeometryGraph.determineBoundary(this._boundaryNodeRule, boundaryCount);\n  \t\tlbl.setLocation(argIndex, newLoc);\n  \t},\n  \tcomputeSelfNodes: function computeSelfNodes() {\n  \t\tif (arguments.length === 2) {\n  \t\t\tvar li = arguments[0],\n  \t\t\t    computeRingSelfNodes = arguments[1];\n  \t\t\treturn this.computeSelfNodes(li, computeRingSelfNodes, false);\n  \t\t} else if (arguments.length === 3) {\n  \t\t\tvar li = arguments[0],\n  \t\t\t    computeRingSelfNodes = arguments[1],\n  \t\t\t    isDoneIfProperInt = arguments[2];\n  \t\t\tvar si = new SegmentIntersector$1(li, true, false);\n  \t\t\tsi.setIsDoneIfProperInt(isDoneIfProperInt);\n  \t\t\tvar esi = this.createEdgeSetIntersector();\n  \t\t\tvar isRings = this._parentGeom instanceof LinearRing || this._parentGeom instanceof Polygon || this._parentGeom instanceof MultiPolygon;\n  \t\t\tvar computeAllSegments = computeRingSelfNodes || !isRings;\n  \t\t\tesi.computeIntersections(this._edges, si, computeAllSegments);\n  \t\t\tthis.addSelfIntersectionNodes(this._argIndex);\n  \t\t\treturn si;\n  \t\t}\n  \t},\n  \tcomputeSplitEdges: function computeSplitEdges(edgelist) {\n  \t\tfor (var i = this._edges.iterator(); i.hasNext();) {\n  \t\t\tvar e = i.next();\n  \t\t\te.eiList.addSplitEdges(edgelist);\n  \t\t}\n  \t},\n  \tcomputeEdgeIntersections: function computeEdgeIntersections(g, li, includeProper) {\n  \t\tvar si = new SegmentIntersector$1(li, includeProper, true);\n  \t\tsi.setBoundaryNodes(this.getBoundaryNodes(), g.getBoundaryNodes());\n  \t\tvar esi = this.createEdgeSetIntersector();\n  \t\tesi.computeIntersections(this._edges, g._edges, si);\n  \t\treturn si;\n  \t},\n  \tgetGeometry: function getGeometry() {\n  \t\treturn this._parentGeom;\n  \t},\n  \tgetBoundaryNodeRule: function getBoundaryNodeRule() {\n  \t\treturn this._boundaryNodeRule;\n  \t},\n  \thasTooFewPoints: function hasTooFewPoints() {\n  \t\treturn this._hasTooFewPoints;\n  \t},\n  \taddPoint: function addPoint() {\n  \t\tif (arguments[0] instanceof Point) {\n  \t\t\tvar p = arguments[0];\n  \t\t\tvar coord = p.getCoordinate();\n  \t\t\tthis.insertPoint(this._argIndex, coord, Location.INTERIOR);\n  \t\t} else if (arguments[0] instanceof Coordinate) {\n  \t\t\tvar pt = arguments[0];\n  \t\t\tthis.insertPoint(this._argIndex, pt, Location.INTERIOR);\n  \t\t}\n  \t},\n  \taddPolygon: function addPolygon(p) {\n  \t\tthis.addPolygonRing(p.getExteriorRing(), Location.EXTERIOR, Location.INTERIOR);\n  \t\tfor (var i = 0; i < p.getNumInteriorRing(); i++) {\n  \t\t\tvar hole = p.getInteriorRingN(i);\n  \t\t\tthis.addPolygonRing(hole, Location.INTERIOR, Location.EXTERIOR);\n  \t\t}\n  \t},\n  \taddEdge: function addEdge(e) {\n  \t\tthis.insertEdge(e);\n  \t\tvar coord = e.getCoordinates();\n  \t\tthis.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);\n  \t\tthis.insertPoint(this._argIndex, coord[coord.length - 1], Location.BOUNDARY);\n  \t},\n  \taddLineString: function addLineString(line) {\n  \t\tvar coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());\n  \t\tif (coord.length < 2) {\n  \t\t\tthis._hasTooFewPoints = true;\n  \t\t\tthis._invalidPoint = coord[0];\n  \t\t\treturn null;\n  \t\t}\n  \t\tvar e = new Edge(coord, new Label(this._argIndex, Location.INTERIOR));\n  \t\tthis._lineEdgeMap.put(line, e);\n  \t\tthis.insertEdge(e);\n  \t\tAssert.isTrue(coord.length >= 2, \"found LineString with single point\");\n  \t\tthis.insertBoundaryPoint(this._argIndex, coord[0]);\n  \t\tthis.insertBoundaryPoint(this._argIndex, coord[coord.length - 1]);\n  \t},\n  \tgetInvalidPoint: function getInvalidPoint() {\n  \t\treturn this._invalidPoint;\n  \t},\n  \tgetBoundaryPoints: function getBoundaryPoints() {\n  \t\tvar coll = this.getBoundaryNodes();\n  \t\tvar pts = new Array(coll.size()).fill(null);\n  \t\tvar i = 0;\n  \t\tfor (var it = coll.iterator(); it.hasNext();) {\n  \t\t\tvar node = it.next();\n  \t\t\tpts[i++] = node.getCoordinate().copy();\n  \t\t}\n  \t\treturn pts;\n  \t},\n  \tgetBoundaryNodes: function getBoundaryNodes() {\n  \t\tif (this._boundaryNodes === null) this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex);\n  \t\treturn this._boundaryNodes;\n  \t},\n  \taddSelfIntersectionNode: function addSelfIntersectionNode(argIndex, coord, loc) {\n  \t\tif (this.isBoundaryNode(argIndex, coord)) return null;\n  \t\tif (loc === Location.BOUNDARY && this._useBoundaryDeterminationRule) this.insertBoundaryPoint(argIndex, coord);else this.insertPoint(argIndex, coord, loc);\n  \t},\n  \taddPolygonRing: function addPolygonRing(lr, cwLeft, cwRight) {\n  \t\tif (lr.isEmpty()) return null;\n  \t\tvar coord = CoordinateArrays.removeRepeatedPoints(lr.getCoordinates());\n  \t\tif (coord.length < 4) {\n  \t\t\tthis._hasTooFewPoints = true;\n  \t\t\tthis._invalidPoint = coord[0];\n  \t\t\treturn null;\n  \t\t}\n  \t\tvar left = cwLeft;\n  \t\tvar right = cwRight;\n  \t\tif (CGAlgorithms.isCCW(coord)) {\n  \t\t\tleft = cwRight;\n  \t\t\tright = cwLeft;\n  \t\t}\n  \t\tvar e = new Edge(coord, new Label(this._argIndex, Location.BOUNDARY, left, right));\n  \t\tthis._lineEdgeMap.put(lr, e);\n  \t\tthis.insertEdge(e);\n  \t\tthis.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);\n  \t},\n  \tinsertPoint: function insertPoint(argIndex, coord, onLocation) {\n  \t\tvar n = this._nodes.addNode(coord);\n  \t\tvar lbl = n.getLabel();\n  \t\tif (lbl === null) {\n  \t\t\tn._label = new Label(argIndex, onLocation);\n  \t\t} else lbl.setLocation(argIndex, onLocation);\n  \t},\n  \tcreateEdgeSetIntersector: function createEdgeSetIntersector() {\n  \t\treturn new SimpleMCSweepLineIntersector();\n  \t},\n  \taddSelfIntersectionNodes: function addSelfIntersectionNodes(argIndex) {\n  \t\tfor (var i = this._edges.iterator(); i.hasNext();) {\n  \t\t\tvar e = i.next();\n  \t\t\tvar eLoc = e.getLabel().getLocation(argIndex);\n  \t\t\tfor (var eiIt = e.eiList.iterator(); eiIt.hasNext();) {\n  \t\t\t\tvar ei = eiIt.next();\n  \t\t\t\tthis.addSelfIntersectionNode(argIndex, ei.coord, eLoc);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tadd: function add() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar g = arguments[0];\n  \t\t\tif (g.isEmpty()) return null;\n  \t\t\tif (g instanceof MultiPolygon) this._useBoundaryDeterminationRule = false;\n  \t\t\tif (g instanceof Polygon) this.addPolygon(g);else if (g instanceof LineString) this.addLineString(g);else if (g instanceof Point) this.addPoint(g);else if (g instanceof MultiPoint) this.addCollection(g);else if (g instanceof MultiLineString) this.addCollection(g);else if (g instanceof MultiPolygon) this.addCollection(g);else if (g instanceof GeometryCollection) this.addCollection(g);else throw new UnsupportedOperationException(g.getClass().getName());\n  \t\t} else return PlanarGraph.prototype.add.apply(this, arguments);\n  \t},\n  \taddCollection: function addCollection(gc) {\n  \t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n  \t\t\tvar g = gc.getGeometryN(i);\n  \t\t\tthis.add(g);\n  \t\t}\n  \t},\n  \tlocate: function locate(pt) {\n  \t\tif (hasInterface(this._parentGeom, Polygonal) && this._parentGeom.getNumGeometries() > 50) {\n  \t\t\tif (this._areaPtLocator === null) {\n  \t\t\t\tthis._areaPtLocator = new IndexedPointInAreaLocator(this._parentGeom);\n  \t\t\t}\n  \t\t\treturn this._areaPtLocator.locate(pt);\n  \t\t}\n  \t\treturn this._ptLocator.locate(pt, this._parentGeom);\n  \t},\n  \tfindEdge: function findEdge() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar line = arguments[0];\n  \t\t\treturn this._lineEdgeMap.get(line);\n  \t\t} else return PlanarGraph.prototype.findEdge.apply(this, arguments);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn GeometryGraph;\n  \t}\n  });\n  GeometryGraph.determineBoundary = function (boundaryNodeRule, boundaryCount) {\n  \treturn boundaryNodeRule.isInBoundary(boundaryCount) ? Location.BOUNDARY : Location.INTERIOR;\n  };\n\n  function GeometryGraphOperation() {\n  \tthis._li = new RobustLineIntersector();\n  \tthis._resultPrecisionModel = null;\n  \tthis._arg = null;\n  \tif (arguments.length === 1) {\n  \t\tvar g0 = arguments[0];\n  \t\tthis.setComputationPrecision(g0.getPrecisionModel());\n  \t\tthis._arg = new Array(1).fill(null);\n  \t\tthis._arg[0] = new GeometryGraph(0, g0);\n  \t} else if (arguments.length === 2) {\n  \t\tvar g0 = arguments[0],\n  \t\t    g1 = arguments[1];\n  \t\tGeometryGraphOperation.call(this, g0, g1, BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE);\n  \t} else if (arguments.length === 3) {\n  \t\tvar g0 = arguments[0],\n  \t\t    g1 = arguments[1],\n  \t\t    boundaryNodeRule = arguments[2];\n  \t\tif (g0.getPrecisionModel().compareTo(g1.getPrecisionModel()) >= 0) this.setComputationPrecision(g0.getPrecisionModel());else this.setComputationPrecision(g1.getPrecisionModel());\n  \t\tthis._arg = new Array(2).fill(null);\n  \t\tthis._arg[0] = new GeometryGraph(0, g0, boundaryNodeRule);\n  \t\tthis._arg[1] = new GeometryGraph(1, g1, boundaryNodeRule);\n  \t}\n  }\n  extend(GeometryGraphOperation.prototype, {\n  \tgetArgGeometry: function getArgGeometry(i) {\n  \t\treturn this._arg[i].getGeometry();\n  \t},\n  \tsetComputationPrecision: function setComputationPrecision(pm) {\n  \t\tthis._resultPrecisionModel = pm;\n  \t\tthis._li.setPrecisionModel(this._resultPrecisionModel);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn GeometryGraphOperation;\n  \t}\n  });\n\n  function OrientedCoordinateArray() {\n  \tthis._pts = null;\n  \tthis._orientation = null;\n  \tvar pts = arguments[0];\n  \tthis._pts = pts;\n  \tthis._orientation = OrientedCoordinateArray.orientation(pts);\n  }\n  extend(OrientedCoordinateArray.prototype, {\n  \tcompareTo: function compareTo(o1) {\n  \t\tvar oca = o1;\n  \t\tvar comp = OrientedCoordinateArray.compareOriented(this._pts, this._orientation, oca._pts, oca._orientation);\n  \t\treturn comp;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn OrientedCoordinateArray;\n  \t}\n  });\n  OrientedCoordinateArray.orientation = function (pts) {\n  \treturn CoordinateArrays.increasingDirection(pts) === 1;\n  };\n  OrientedCoordinateArray.compareOriented = function (pts1, orientation1, pts2, orientation2) {\n  \tvar dir1 = orientation1 ? 1 : -1;\n  \tvar dir2 = orientation2 ? 1 : -1;\n  \tvar limit1 = orientation1 ? pts1.length : -1;\n  \tvar limit2 = orientation2 ? pts2.length : -1;\n  \tvar i1 = orientation1 ? 0 : pts1.length - 1;\n  \tvar i2 = orientation2 ? 0 : pts2.length - 1;\n  \twhile (true) {\n  \t\tvar compPt = pts1[i1].compareTo(pts2[i2]);\n  \t\tif (compPt !== 0) return compPt;\n  \t\ti1 += dir1;\n  \t\ti2 += dir2;\n  \t\tvar done1 = i1 === limit1;\n  \t\tvar done2 = i2 === limit2;\n  \t\tif (done1 && !done2) return -1;\n  \t\tif (!done1 && done2) return 1;\n  \t\tif (done1 && done2) return 0;\n  \t}\n  };\n\n  function EdgeList() {\n  \tthis._edges = new ArrayList();\n  \tthis._ocaMap = new TreeMap();\n  }\n  extend(EdgeList.prototype, {\n  \tprint: function print(out) {\n  \t\tout.print(\"MULTILINESTRING ( \");\n  \t\tfor (var j = 0; j < this._edges.size(); j++) {\n  \t\t\tvar e = this._edges.get(j);\n  \t\t\tif (j > 0) out.print(\",\");\n  \t\t\tout.print(\"(\");\n  \t\t\tvar pts = e.getCoordinates();\n  \t\t\tfor (var i = 0; i < pts.length; i++) {\n  \t\t\t\tif (i > 0) out.print(\",\");\n  \t\t\t\tout.print(pts[i].x + \" \" + pts[i].y);\n  \t\t\t}\n  \t\t\tout.println(\")\");\n  \t\t}\n  \t\tout.print(\")  \");\n  \t},\n  \taddAll: function addAll(edgeColl) {\n  \t\tfor (var i = edgeColl.iterator(); i.hasNext();) {\n  \t\t\tthis.add(i.next());\n  \t\t}\n  \t},\n  \tfindEdgeIndex: function findEdgeIndex(e) {\n  \t\tfor (var i = 0; i < this._edges.size(); i++) {\n  \t\t\tif (this._edges.get(i).equals(e)) return i;\n  \t\t}\n  \t\treturn -1;\n  \t},\n  \titerator: function iterator() {\n  \t\treturn this._edges.iterator();\n  \t},\n  \tgetEdges: function getEdges() {\n  \t\treturn this._edges;\n  \t},\n  \tget: function get(i) {\n  \t\treturn this._edges.get(i);\n  \t},\n  \tfindEqualEdge: function findEqualEdge(e) {\n  \t\tvar oca = new OrientedCoordinateArray(e.getCoordinates());\n  \t\tvar matchEdge = this._ocaMap.get(oca);\n  \t\treturn matchEdge;\n  \t},\n  \tadd: function add(e) {\n  \t\tthis._edges.add(e);\n  \t\tvar oca = new OrientedCoordinateArray(e.getCoordinates());\n  \t\tthis._ocaMap.put(oca, e);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn EdgeList;\n  \t}\n  });\n\n  function OverlayOp() {\n  \tthis._ptLocator = new PointLocator();\n  \tthis._geomFact = null;\n  \tthis._resultGeom = null;\n  \tthis._graph = null;\n  \tthis._edgeList = new EdgeList();\n  \tthis._resultPolyList = new ArrayList();\n  \tthis._resultLineList = new ArrayList();\n  \tthis._resultPointList = new ArrayList();\n  \tvar g0 = arguments[0],\n  \t    g1 = arguments[1];\n  \tGeometryGraphOperation.call(this, g0, g1);\n  \tthis._graph = new PlanarGraph(new OverlayNodeFactory());\n  \tthis._geomFact = g0.getFactory();\n  }\n  inherits$1(OverlayOp, GeometryGraphOperation);\n  extend(OverlayOp.prototype, {\n  \tinsertUniqueEdge: function insertUniqueEdge(e) {\n  \t\tvar existingEdge = this._edgeList.findEqualEdge(e);\n  \t\tif (existingEdge !== null) {\n  \t\t\tvar existingLabel = existingEdge.getLabel();\n  \t\t\tvar labelToMerge = e.getLabel();\n  \t\t\tif (!existingEdge.isPointwiseEqual(e)) {\n  \t\t\t\tlabelToMerge = new Label(e.getLabel());\n  \t\t\t\tlabelToMerge.flip();\n  \t\t\t}\n  \t\t\tvar depth = existingEdge.getDepth();\n  \t\t\tif (depth.isNull()) {\n  \t\t\t\tdepth.add(existingLabel);\n  \t\t\t}\n  \t\t\tdepth.add(labelToMerge);\n  \t\t\texistingLabel.merge(labelToMerge);\n  \t\t} else {\n  \t\t\tthis._edgeList.add(e);\n  \t\t}\n  \t},\n  \tgetGraph: function getGraph() {\n  \t\treturn this._graph;\n  \t},\n  \tcancelDuplicateResultEdges: function cancelDuplicateResultEdges() {\n  \t\tfor (var it = this._graph.getEdgeEnds().iterator(); it.hasNext();) {\n  \t\t\tvar de = it.next();\n  \t\t\tvar sym = de.getSym();\n  \t\t\tif (de.isInResult() && sym.isInResult()) {\n  \t\t\t\tde.setInResult(false);\n  \t\t\t\tsym.setInResult(false);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tisCoveredByLA: function isCoveredByLA(coord) {\n  \t\tif (this.isCovered(coord, this._resultLineList)) return true;\n  \t\tif (this.isCovered(coord, this._resultPolyList)) return true;\n  \t\treturn false;\n  \t},\n  \tcomputeGeometry: function computeGeometry(resultPointList, resultLineList, resultPolyList, opcode) {\n  \t\tvar geomList = new ArrayList();\n  \t\tgeomList.addAll(resultPointList);\n  \t\tgeomList.addAll(resultLineList);\n  \t\tgeomList.addAll(resultPolyList);\n  \t\tif (geomList.isEmpty()) return OverlayOp.createEmptyResult(opcode, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact);\n  \t\treturn this._geomFact.buildGeometry(geomList);\n  \t},\n  \tmergeSymLabels: function mergeSymLabels() {\n  \t\tfor (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {\n  \t\t\tvar node = nodeit.next();\n  \t\t\tnode.getEdges().mergeSymLabels();\n  \t\t}\n  \t},\n  \tisCovered: function isCovered(coord, geomList) {\n  \t\tfor (var it = geomList.iterator(); it.hasNext();) {\n  \t\t\tvar geom = it.next();\n  \t\t\tvar loc = this._ptLocator.locate(coord, geom);\n  \t\t\tif (loc !== Location.EXTERIOR) return true;\n  \t\t}\n  \t\treturn false;\n  \t},\n  \treplaceCollapsedEdges: function replaceCollapsedEdges() {\n  \t\tvar newEdges = new ArrayList();\n  \t\tfor (var it = this._edgeList.iterator(); it.hasNext();) {\n  \t\t\tvar e = it.next();\n  \t\t\tif (e.isCollapsed()) {\n  \t\t\t\tit.remove();\n  \t\t\t\tnewEdges.add(e.getCollapsedEdge());\n  \t\t\t}\n  \t\t}\n  \t\tthis._edgeList.addAll(newEdges);\n  \t},\n  \tupdateNodeLabelling: function updateNodeLabelling() {\n  \t\tfor (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {\n  \t\t\tvar node = nodeit.next();\n  \t\t\tvar lbl = node.getEdges().getLabel();\n  \t\t\tnode.getLabel().merge(lbl);\n  \t\t}\n  \t},\n  \tgetResultGeometry: function getResultGeometry(overlayOpCode) {\n  \t\tthis.computeOverlay(overlayOpCode);\n  \t\treturn this._resultGeom;\n  \t},\n  \tinsertUniqueEdges: function insertUniqueEdges(edges) {\n  \t\tfor (var i = edges.iterator(); i.hasNext();) {\n  \t\t\tvar e = i.next();\n  \t\t\tthis.insertUniqueEdge(e);\n  \t\t}\n  \t},\n  \tcomputeOverlay: function computeOverlay(opCode) {\n  \t\tthis.copyPoints(0);\n  \t\tthis.copyPoints(1);\n  \t\tthis._arg[0].computeSelfNodes(this._li, false);\n  \t\tthis._arg[1].computeSelfNodes(this._li, false);\n  \t\tthis._arg[0].computeEdgeIntersections(this._arg[1], this._li, true);\n  \t\tvar baseSplitEdges = new ArrayList();\n  \t\tthis._arg[0].computeSplitEdges(baseSplitEdges);\n  \t\tthis._arg[1].computeSplitEdges(baseSplitEdges);\n  \t\tthis.insertUniqueEdges(baseSplitEdges);\n  \t\tthis.computeLabelsFromDepths();\n  \t\tthis.replaceCollapsedEdges();\n  \t\tEdgeNodingValidator.checkValid(this._edgeList.getEdges());\n  \t\tthis._graph.addEdges(this._edgeList.getEdges());\n  \t\tthis.computeLabelling();\n  \t\tthis.labelIncompleteNodes();\n  \t\tthis.findResultAreaEdges(opCode);\n  \t\tthis.cancelDuplicateResultEdges();\n  \t\tvar polyBuilder = new PolygonBuilder(this._geomFact);\n  \t\tpolyBuilder.add(this._graph);\n  \t\tthis._resultPolyList = polyBuilder.getPolygons();\n  \t\tvar lineBuilder = new LineBuilder(this, this._geomFact, this._ptLocator);\n  \t\tthis._resultLineList = lineBuilder.build(opCode);\n  \t\tvar pointBuilder = new PointBuilder(this, this._geomFact, this._ptLocator);\n  \t\tthis._resultPointList = pointBuilder.build(opCode);\n  \t\tthis._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, opCode);\n  \t},\n  \tlabelIncompleteNode: function labelIncompleteNode(n, targetIndex) {\n  \t\tvar loc = this._ptLocator.locate(n.getCoordinate(), this._arg[targetIndex].getGeometry());\n  \t\tn.getLabel().setLocation(targetIndex, loc);\n  \t},\n  \tcopyPoints: function copyPoints(argIndex) {\n  \t\tfor (var i = this._arg[argIndex].getNodeIterator(); i.hasNext();) {\n  \t\t\tvar graphNode = i.next();\n  \t\t\tvar newNode = this._graph.addNode(graphNode.getCoordinate());\n  \t\t\tnewNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));\n  \t\t}\n  \t},\n  \tfindResultAreaEdges: function findResultAreaEdges(opCode) {\n  \t\tfor (var it = this._graph.getEdgeEnds().iterator(); it.hasNext();) {\n  \t\t\tvar de = it.next();\n  \t\t\tvar label = de.getLabel();\n  \t\t\tif (label.isArea() && !de.isInteriorAreaEdge() && OverlayOp.isResultOfOp(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), opCode)) {\n  \t\t\t\tde.setInResult(true);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcomputeLabelsFromDepths: function computeLabelsFromDepths() {\n  \t\tfor (var it = this._edgeList.iterator(); it.hasNext();) {\n  \t\t\tvar e = it.next();\n  \t\t\tvar lbl = e.getLabel();\n  \t\t\tvar depth = e.getDepth();\n  \t\t\tif (!depth.isNull()) {\n  \t\t\t\tdepth.normalize();\n  \t\t\t\tfor (var i = 0; i < 2; i++) {\n  \t\t\t\t\tif (!lbl.isNull(i) && lbl.isArea() && !depth.isNull(i)) {\n  \t\t\t\t\t\tif (depth.getDelta(i) === 0) {\n  \t\t\t\t\t\t\tlbl.toLine(i);\n  \t\t\t\t\t\t} else {\n  \t\t\t\t\t\t\tAssert.isTrue(!depth.isNull(i, Position.LEFT), \"depth of LEFT side has not been initialized\");\n  \t\t\t\t\t\t\tlbl.setLocation(i, Position.LEFT, depth.getLocation(i, Position.LEFT));\n  \t\t\t\t\t\t\tAssert.isTrue(!depth.isNull(i, Position.RIGHT), \"depth of RIGHT side has not been initialized\");\n  \t\t\t\t\t\t\tlbl.setLocation(i, Position.RIGHT, depth.getLocation(i, Position.RIGHT));\n  \t\t\t\t\t\t}\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcomputeLabelling: function computeLabelling() {\n  \t\tfor (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {\n  \t\t\tvar node = nodeit.next();\n  \t\t\tnode.getEdges().computeLabelling(this._arg);\n  \t\t}\n  \t\tthis.mergeSymLabels();\n  \t\tthis.updateNodeLabelling();\n  \t},\n  \tlabelIncompleteNodes: function labelIncompleteNodes() {\n  \t\tfor (var ni = this._graph.getNodes().iterator(); ni.hasNext();) {\n  \t\t\tvar n = ni.next();\n  \t\t\tvar label = n.getLabel();\n  \t\t\tif (n.isIsolated()) {\n  \t\t\t\tif (label.isNull(0)) this.labelIncompleteNode(n, 0);else this.labelIncompleteNode(n, 1);\n  \t\t\t}\n  \t\t\tn.getEdges().updateLabelling(label);\n  \t\t}\n  \t},\n  \tisCoveredByA: function isCoveredByA(coord) {\n  \t\tif (this.isCovered(coord, this._resultPolyList)) return true;\n  \t\treturn false;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn OverlayOp;\n  \t}\n  });\n  OverlayOp.overlayOp = function (geom0, geom1, opCode) {\n  \tvar gov = new OverlayOp(geom0, geom1);\n  \tvar geomOv = gov.getResultGeometry(opCode);\n  \treturn geomOv;\n  };\n  OverlayOp.intersection = function (g, other) {\n  \tif (g.isEmpty() || other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.INTERSECTION, g, other, g.getFactory());\n  \tif (g.isGeometryCollection()) {\n  \t\tvar g2 = other;\n  \t\treturn GeometryCollectionMapper.map(g, {\n  \t\t\tinterfaces_: function interfaces_() {\n  \t\t\t\treturn [MapOp];\n  \t\t\t},\n  \t\t\tmap: function map(g) {\n  \t\t\t\treturn g.intersection(g2);\n  \t\t\t}\n  \t\t});\n  \t}\n  \tg.checkNotGeometryCollection(g);\n  \tg.checkNotGeometryCollection(other);\n  \treturn SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.INTERSECTION);\n  };\n  OverlayOp.symDifference = function (g, other) {\n  \tif (g.isEmpty() || other.isEmpty()) {\n  \t\tif (g.isEmpty() && other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.SYMDIFFERENCE, g, other, g.getFactory());\n  \t\tif (g.isEmpty()) return other.copy();\n  \t\tif (other.isEmpty()) return g.copy();\n  \t}\n  \tg.checkNotGeometryCollection(g);\n  \tg.checkNotGeometryCollection(other);\n  \treturn SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.SYMDIFFERENCE);\n  };\n  OverlayOp.resultDimension = function (opCode, g0, g1) {\n  \tvar dim0 = g0.getDimension();\n  \tvar dim1 = g1.getDimension();\n  \tvar resultDimension = -1;\n  \tswitch (opCode) {\n  \t\tcase OverlayOp.INTERSECTION:\n  \t\t\tresultDimension = Math.min(dim0, dim1);\n  \t\t\tbreak;\n  \t\tcase OverlayOp.UNION:\n  \t\t\tresultDimension = Math.max(dim0, dim1);\n  \t\t\tbreak;\n  \t\tcase OverlayOp.DIFFERENCE:\n  \t\t\tresultDimension = dim0;\n  \t\t\tbreak;\n  \t\tcase OverlayOp.SYMDIFFERENCE:\n  \t\t\tresultDimension = Math.max(dim0, dim1);\n  \t\t\tbreak;\n  \t}\n  \treturn resultDimension;\n  };\n  OverlayOp.createEmptyResult = function (overlayOpCode, a, b, geomFact) {\n  \tvar result = null;\n  \tswitch (OverlayOp.resultDimension(overlayOpCode, a, b)) {\n  \t\tcase -1:\n  \t\t\tresult = geomFact.createGeometryCollection(new Array(0).fill(null));\n  \t\t\tbreak;\n  \t\tcase 0:\n  \t\t\tresult = geomFact.createPoint();\n  \t\t\tbreak;\n  \t\tcase 1:\n  \t\t\tresult = geomFact.createLineString();\n  \t\t\tbreak;\n  \t\tcase 2:\n  \t\t\tresult = geomFact.createPolygon();\n  \t\t\tbreak;\n  \t}\n  \treturn result;\n  };\n  OverlayOp.difference = function (g, other) {\n  \tif (g.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.DIFFERENCE, g, other, g.getFactory());\n  \tif (other.isEmpty()) return g.copy();\n  \tg.checkNotGeometryCollection(g);\n  \tg.checkNotGeometryCollection(other);\n  \treturn SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.DIFFERENCE);\n  };\n  OverlayOp.isResultOfOp = function () {\n  \tif (arguments.length === 2) {\n  \t\tvar label = arguments[0],\n  \t\t    opCode = arguments[1];\n  \t\tvar loc0 = label.getLocation(0);\n  \t\tvar loc1 = label.getLocation(1);\n  \t\treturn OverlayOp.isResultOfOp(loc0, loc1, opCode);\n  \t} else if (arguments.length === 3) {\n  \t\tvar loc0 = arguments[0],\n  \t\t    loc1 = arguments[1],\n  \t\t    overlayOpCode = arguments[2];\n  \t\tif (loc0 === Location.BOUNDARY) loc0 = Location.INTERIOR;\n  \t\tif (loc1 === Location.BOUNDARY) loc1 = Location.INTERIOR;\n  \t\tswitch (overlayOpCode) {\n  \t\t\tcase OverlayOp.INTERSECTION:\n  \t\t\t\treturn loc0 === Location.INTERIOR && loc1 === Location.INTERIOR;\n  \t\t\tcase OverlayOp.UNION:\n  \t\t\t\treturn loc0 === Location.INTERIOR || loc1 === Location.INTERIOR;\n  \t\t\tcase OverlayOp.DIFFERENCE:\n  \t\t\t\treturn loc0 === Location.INTERIOR && loc1 !== Location.INTERIOR;\n  \t\t\tcase OverlayOp.SYMDIFFERENCE:\n  \t\t\t\treturn loc0 === Location.INTERIOR && loc1 !== Location.INTERIOR || loc0 !== Location.INTERIOR && loc1 === Location.INTERIOR;\n  \t\t}\n  \t\treturn false;\n  \t}\n  };\n  OverlayOp.INTERSECTION = 1;\n  OverlayOp.UNION = 2;\n  OverlayOp.DIFFERENCE = 3;\n  OverlayOp.SYMDIFFERENCE = 4;\n\n  function SnapOverlayOp() {\n  \tthis._geom = new Array(2).fill(null);\n  \tthis._snapTolerance = null;\n  \tthis._cbr = null;\n  \tvar g1 = arguments[0],\n  \t    g2 = arguments[1];\n  \tthis._geom[0] = g1;\n  \tthis._geom[1] = g2;\n  \tthis.computeSnapTolerance();\n  }\n  extend(SnapOverlayOp.prototype, {\n  \tselfSnap: function selfSnap(geom) {\n  \t\tvar snapper0 = new GeometrySnapper(geom);\n  \t\tvar snapGeom = snapper0.snapTo(geom, this._snapTolerance);\n  \t\treturn snapGeom;\n  \t},\n  \tremoveCommonBits: function removeCommonBits(geom) {\n  \t\tthis._cbr = new CommonBitsRemover();\n  \t\tthis._cbr.add(geom[0]);\n  \t\tthis._cbr.add(geom[1]);\n  \t\tvar remGeom = new Array(2).fill(null);\n  \t\tremGeom[0] = this._cbr.removeCommonBits(geom[0].copy());\n  \t\tremGeom[1] = this._cbr.removeCommonBits(geom[1].copy());\n  \t\treturn remGeom;\n  \t},\n  \tprepareResult: function prepareResult(geom) {\n  \t\tthis._cbr.addCommonBits(geom);\n  \t\treturn geom;\n  \t},\n  \tgetResultGeometry: function getResultGeometry(opCode) {\n  \t\tvar prepGeom = this.snap(this._geom);\n  \t\tvar result = OverlayOp.overlayOp(prepGeom[0], prepGeom[1], opCode);\n  \t\treturn this.prepareResult(result);\n  \t},\n  \tcheckValid: function checkValid(g) {\n  \t\tif (!g.isValid()) {\n  \t\t\tSystem.out.println(\"Snapped geometry is invalid\");\n  \t\t}\n  \t},\n  \tcomputeSnapTolerance: function computeSnapTolerance() {\n  \t\tthis._snapTolerance = GeometrySnapper.computeOverlaySnapTolerance(this._geom[0], this._geom[1]);\n  \t},\n  \tsnap: function snap(geom) {\n  \t\tvar remGeom = this.removeCommonBits(geom);\n  \t\tvar snapGeom = GeometrySnapper.snap(remGeom[0], remGeom[1], this._snapTolerance);\n  \t\treturn snapGeom;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SnapOverlayOp;\n  \t}\n  });\n  SnapOverlayOp.overlayOp = function (g0, g1, opCode) {\n  \tvar op = new SnapOverlayOp(g0, g1);\n  \treturn op.getResultGeometry(opCode);\n  };\n  SnapOverlayOp.union = function (g0, g1) {\n  \treturn SnapOverlayOp.overlayOp(g0, g1, OverlayOp.UNION);\n  };\n  SnapOverlayOp.intersection = function (g0, g1) {\n  \treturn SnapOverlayOp.overlayOp(g0, g1, OverlayOp.INTERSECTION);\n  };\n  SnapOverlayOp.symDifference = function (g0, g1) {\n  \treturn SnapOverlayOp.overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE);\n  };\n  SnapOverlayOp.difference = function (g0, g1) {\n  \treturn SnapOverlayOp.overlayOp(g0, g1, OverlayOp.DIFFERENCE);\n  };\n\n  function SnapIfNeededOverlayOp() {\n  \tthis._geom = new Array(2).fill(null);\n  \tvar g1 = arguments[0],\n  \t    g2 = arguments[1];\n  \tthis._geom[0] = g1;\n  \tthis._geom[1] = g2;\n  }\n  extend(SnapIfNeededOverlayOp.prototype, {\n  \tgetResultGeometry: function getResultGeometry(opCode) {\n  \t\tvar result = null;\n  \t\tvar isSuccess = false;\n  \t\tvar savedException = null;\n  \t\ttry {\n  \t\t\tresult = OverlayOp.overlayOp(this._geom[0], this._geom[1], opCode);\n  \t\t\tvar isValid = true;\n  \t\t\tif (isValid) isSuccess = true;\n  \t\t} catch (ex) {\n  \t\t\tif (ex instanceof RuntimeException) {\n  \t\t\t\tsavedException = ex;\n  \t\t\t} else throw ex;\n  \t\t} finally {}\n  \t\tif (!isSuccess) {\n  \t\t\ttry {\n  \t\t\t\tresult = SnapOverlayOp.overlayOp(this._geom[0], this._geom[1], opCode);\n  \t\t\t} catch (ex) {\n  \t\t\t\tif (ex instanceof RuntimeException) {\n  \t\t\t\t\tthrow savedException;\n  \t\t\t\t} else throw ex;\n  \t\t\t} finally {}\n  \t\t}\n  \t\treturn result;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SnapIfNeededOverlayOp;\n  \t}\n  });\n  SnapIfNeededOverlayOp.overlayOp = function (g0, g1, opCode) {\n  \tvar op = new SnapIfNeededOverlayOp(g0, g1);\n  \treturn op.getResultGeometry(opCode);\n  };\n  SnapIfNeededOverlayOp.union = function (g0, g1) {\n  \treturn SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.UNION);\n  };\n  SnapIfNeededOverlayOp.intersection = function (g0, g1) {\n  \treturn SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.INTERSECTION);\n  };\n  SnapIfNeededOverlayOp.symDifference = function (g0, g1) {\n  \treturn SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE);\n  };\n  SnapIfNeededOverlayOp.difference = function (g0, g1) {\n  \treturn SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.DIFFERENCE);\n  };\n\n  function InteriorPointArea() {\n  \tthis._factory = null;\n  \tthis._interiorPoint = null;\n  \tthis._maxWidth = 0.0;\n  \tvar g = arguments[0];\n  \tthis._factory = g.getFactory();\n  \tthis.add(g);\n  }\n  extend(InteriorPointArea.prototype, {\n  \taddPolygon: function addPolygon(geometry) {\n  \t\tif (geometry.isEmpty()) return null;\n  \t\tvar intPt = null;\n  \t\tvar width = 0;\n  \t\tvar bisector = this.horizontalBisector(geometry);\n  \t\tif (bisector.getLength() === 0.0) {\n  \t\t\twidth = 0;\n  \t\t\tintPt = bisector.getCoordinate();\n  \t\t} else {\n  \t\t\tvar intersections = SnapIfNeededOverlayOp.overlayOp(bisector, geometry, OverlayOp.INTERSECTION);\n  \t\t\tvar widestIntersection = this.widestGeometry(intersections);\n  \t\t\twidth = widestIntersection.getEnvelopeInternal().getWidth();\n  \t\t\tintPt = InteriorPointArea.centre(widestIntersection.getEnvelopeInternal());\n  \t\t}\n  \t\tif (this._interiorPoint === null || width > this._maxWidth) {\n  \t\t\tthis._interiorPoint = intPt;\n  \t\t\tthis._maxWidth = width;\n  \t\t}\n  \t},\n  \tgetInteriorPoint: function getInteriorPoint() {\n  \t\treturn this._interiorPoint;\n  \t},\n  \twidestGeometry: function widestGeometry() {\n  \t\tif (arguments[0] instanceof GeometryCollection) {\n  \t\t\tvar gc = arguments[0];\n  \t\t\tif (gc.isEmpty()) {\n  \t\t\t\treturn gc;\n  \t\t\t}\n  \t\t\tvar widestGeometry = gc.getGeometryN(0);\n  \t\t\tfor (var i = 1; i < gc.getNumGeometries(); i++) {\n  \t\t\t\tif (gc.getGeometryN(i).getEnvelopeInternal().getWidth() > widestGeometry.getEnvelopeInternal().getWidth()) {\n  \t\t\t\t\twidestGeometry = gc.getGeometryN(i);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\treturn widestGeometry;\n  \t\t} else if (arguments[0] instanceof Geometry) {\n  \t\t\tvar geometry = arguments[0];\n  \t\t\tif (!(geometry instanceof GeometryCollection)) {\n  \t\t\t\treturn geometry;\n  \t\t\t}\n  \t\t\treturn this.widestGeometry(geometry);\n  \t\t}\n  \t},\n  \thorizontalBisector: function horizontalBisector(geometry) {\n  \t\tvar envelope = geometry.getEnvelopeInternal();\n  \t\tvar bisectY = SafeBisectorFinder.getBisectorY(geometry);\n  \t\treturn this._factory.createLineString([new Coordinate(envelope.getMinX(), bisectY), new Coordinate(envelope.getMaxX(), bisectY)]);\n  \t},\n  \tadd: function add(geom) {\n  \t\tif (geom instanceof Polygon) {\n  \t\t\tthis.addPolygon(geom);\n  \t\t} else if (geom instanceof GeometryCollection) {\n  \t\t\tvar gc = geom;\n  \t\t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n  \t\t\t\tthis.add(gc.getGeometryN(i));\n  \t\t\t}\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn InteriorPointArea;\n  \t}\n  });\n  InteriorPointArea.centre = function (envelope) {\n  \treturn new Coordinate(InteriorPointArea.avg(envelope.getMinX(), envelope.getMaxX()), InteriorPointArea.avg(envelope.getMinY(), envelope.getMaxY()));\n  };\n  InteriorPointArea.avg = function (a, b) {\n  \treturn (a + b) / 2.0;\n  };\n  function SafeBisectorFinder() {\n  \tthis._poly = null;\n  \tthis._centreY = null;\n  \tthis._hiY = Double.MAX_VALUE;\n  \tthis._loY = -Double.MAX_VALUE;\n  \tvar poly = arguments[0];\n  \tthis._poly = poly;\n  \tthis._hiY = poly.getEnvelopeInternal().getMaxY();\n  \tthis._loY = poly.getEnvelopeInternal().getMinY();\n  \tthis._centreY = InteriorPointArea.avg(this._loY, this._hiY);\n  }\n  extend(SafeBisectorFinder.prototype, {\n  \tupdateInterval: function updateInterval(y) {\n  \t\tif (y <= this._centreY) {\n  \t\t\tif (y > this._loY) this._loY = y;\n  \t\t} else if (y > this._centreY) {\n  \t\t\tif (y < this._hiY) {\n  \t\t\t\tthis._hiY = y;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetBisectorY: function getBisectorY() {\n  \t\tthis.process(this._poly.getExteriorRing());\n  \t\tfor (var i = 0; i < this._poly.getNumInteriorRing(); i++) {\n  \t\t\tthis.process(this._poly.getInteriorRingN(i));\n  \t\t}\n  \t\tvar bisectY = InteriorPointArea.avg(this._hiY, this._loY);\n  \t\treturn bisectY;\n  \t},\n  \tprocess: function process(line) {\n  \t\tvar seq = line.getCoordinateSequence();\n  \t\tfor (var i = 0; i < seq.size(); i++) {\n  \t\t\tvar y = seq.getY(i);\n  \t\t\tthis.updateInterval(y);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SafeBisectorFinder;\n  \t}\n  });\n  SafeBisectorFinder.getBisectorY = function (poly) {\n  \tvar finder = new SafeBisectorFinder(poly);\n  \treturn finder.getBisectorY();\n  };\n  InteriorPointArea.SafeBisectorFinder = SafeBisectorFinder;\n\n  function InteriorPointLine() {\n  \tthis._centroid = null;\n  \tthis._minDistance = Double.MAX_VALUE;\n  \tthis._interiorPoint = null;\n  \tvar g = arguments[0];\n  \tthis._centroid = g.getCentroid().getCoordinate();\n  \tthis.addInterior(g);\n  \tif (this._interiorPoint === null) this.addEndpoints(g);\n  }\n  extend(InteriorPointLine.prototype, {\n  \taddEndpoints: function addEndpoints() {\n  \t\tif (arguments[0] instanceof Geometry) {\n  \t\t\tvar geom = arguments[0];\n  \t\t\tif (geom instanceof LineString) {\n  \t\t\t\tthis.addEndpoints(geom.getCoordinates());\n  \t\t\t} else if (geom instanceof GeometryCollection) {\n  \t\t\t\tvar gc = geom;\n  \t\t\t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n  \t\t\t\t\tthis.addEndpoints(gc.getGeometryN(i));\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} else if (arguments[0] instanceof Array) {\n  \t\t\tvar pts = arguments[0];\n  \t\t\tthis.add(pts[0]);\n  \t\t\tthis.add(pts[pts.length - 1]);\n  \t\t}\n  \t},\n  \tgetInteriorPoint: function getInteriorPoint() {\n  \t\treturn this._interiorPoint;\n  \t},\n  \taddInterior: function addInterior() {\n  \t\tif (arguments[0] instanceof Geometry) {\n  \t\t\tvar geom = arguments[0];\n  \t\t\tif (geom instanceof LineString) {\n  \t\t\t\tthis.addInterior(geom.getCoordinates());\n  \t\t\t} else if (geom instanceof GeometryCollection) {\n  \t\t\t\tvar gc = geom;\n  \t\t\t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n  \t\t\t\t\tthis.addInterior(gc.getGeometryN(i));\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} else if (arguments[0] instanceof Array) {\n  \t\t\tvar pts = arguments[0];\n  \t\t\tfor (var i = 1; i < pts.length - 1; i++) {\n  \t\t\t\tthis.add(pts[i]);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tadd: function add(point) {\n  \t\tvar dist = point.distance(this._centroid);\n  \t\tif (dist < this._minDistance) {\n  \t\t\tthis._interiorPoint = new Coordinate(point);\n  \t\t\tthis._minDistance = dist;\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn InteriorPointLine;\n  \t}\n  });\n\n  function InteriorPointPoint() {\n  \tthis._centroid = null;\n  \tthis._minDistance = Double.MAX_VALUE;\n  \tthis._interiorPoint = null;\n  \tvar g = arguments[0];\n  \tthis._centroid = g.getCentroid().getCoordinate();\n  \tthis.add(g);\n  }\n  extend(InteriorPointPoint.prototype, {\n  \tgetInteriorPoint: function getInteriorPoint() {\n  \t\treturn this._interiorPoint;\n  \t},\n  \tadd: function add() {\n  \t\tif (arguments[0] instanceof Geometry) {\n  \t\t\tvar geom = arguments[0];\n  \t\t\tif (geom instanceof Point) {\n  \t\t\t\tthis.add(geom.getCoordinate());\n  \t\t\t} else if (geom instanceof GeometryCollection) {\n  \t\t\t\tvar gc = geom;\n  \t\t\t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n  \t\t\t\t\tthis.add(gc.getGeometryN(i));\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} else if (arguments[0] instanceof Coordinate) {\n  \t\t\tvar point = arguments[0];\n  \t\t\tvar dist = point.distance(this._centroid);\n  \t\t\tif (dist < this._minDistance) {\n  \t\t\t\tthis._interiorPoint = new Coordinate(point);\n  \t\t\t\tthis._minDistance = dist;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn InteriorPointPoint;\n  \t}\n  });\n\n  function MonotoneChainSelectAction() {\n  \tthis.tempEnv1 = new Envelope();\n  \tthis.selectedSegment = new LineSegment();\n  }\n  extend(MonotoneChainSelectAction.prototype, {\n  \tselect: function select() {\n  \t\tif (arguments.length === 1) ; else if (arguments.length === 2) {\n  \t\t\tvar mc = arguments[0],\n  \t\t\t    startIndex = arguments[1];\n  \t\t\tmc.getLineSegment(startIndex, this.selectedSegment);\n  \t\t\tthis.select(this.selectedSegment);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MonotoneChainSelectAction;\n  \t}\n  });\n\n  function NodeBase() {\n  \tthis._items = new ArrayList();\n  \tthis._subnode = [null, null];\n  }\n  extend(NodeBase.prototype, {\n  \thasChildren: function hasChildren() {\n  \t\tfor (var i = 0; i < 2; i++) {\n  \t\t\tif (this._subnode[i] !== null) return true;\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tisPrunable: function isPrunable() {\n  \t\treturn !(this.hasChildren() || this.hasItems());\n  \t},\n  \taddAllItems: function addAllItems(items) {\n  \t\titems.addAll(this._items);\n  \t\tfor (var i = 0; i < 2; i++) {\n  \t\t\tif (this._subnode[i] !== null) {\n  \t\t\t\tthis._subnode[i].addAllItems(items);\n  \t\t\t}\n  \t\t}\n  \t\treturn items;\n  \t},\n  \tsize: function size() {\n  \t\tvar subSize = 0;\n  \t\tfor (var i = 0; i < 2; i++) {\n  \t\t\tif (this._subnode[i] !== null) {\n  \t\t\t\tsubSize += this._subnode[i].size();\n  \t\t\t}\n  \t\t}\n  \t\treturn subSize + this._items.size();\n  \t},\n  \taddAllItemsFromOverlapping: function addAllItemsFromOverlapping(interval, resultItems) {\n  \t\tif (interval !== null && !this.isSearchMatch(interval)) return null;\n  \t\tresultItems.addAll(this._items);\n  \t\tif (this._subnode[0] !== null) this._subnode[0].addAllItemsFromOverlapping(interval, resultItems);\n  \t\tif (this._subnode[1] !== null) this._subnode[1].addAllItemsFromOverlapping(interval, resultItems);\n  \t},\n  \thasItems: function hasItems() {\n  \t\treturn !this._items.isEmpty();\n  \t},\n  \tremove: function remove(itemInterval, item) {\n  \t\tif (!this.isSearchMatch(itemInterval)) return false;\n  \t\tvar found = false;\n  \t\tfor (var i = 0; i < 2; i++) {\n  \t\t\tif (this._subnode[i] !== null) {\n  \t\t\t\tfound = this._subnode[i].remove(itemInterval, item);\n  \t\t\t\tif (found) {\n  \t\t\t\t\tif (this._subnode[i].isPrunable()) this._subnode[i] = null;\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\tif (found) return found;\n  \t\tfound = this._items.remove(item);\n  \t\treturn found;\n  \t},\n  \tgetItems: function getItems() {\n  \t\treturn this._items;\n  \t},\n  \tdepth: function depth() {\n  \t\tvar maxSubDepth = 0;\n  \t\tfor (var i = 0; i < 2; i++) {\n  \t\t\tif (this._subnode[i] !== null) {\n  \t\t\t\tvar sqd = this._subnode[i].depth();\n  \t\t\t\tif (sqd > maxSubDepth) maxSubDepth = sqd;\n  \t\t\t}\n  \t\t}\n  \t\treturn maxSubDepth + 1;\n  \t},\n  \tnodeSize: function nodeSize() {\n  \t\tvar subSize = 0;\n  \t\tfor (var i = 0; i < 2; i++) {\n  \t\t\tif (this._subnode[i] !== null) {\n  \t\t\t\tsubSize += this._subnode[i].nodeSize();\n  \t\t\t}\n  \t\t}\n  \t\treturn subSize + 1;\n  \t},\n  \tadd: function add(item) {\n  \t\tthis._items.add(item);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn NodeBase;\n  \t}\n  });\n  NodeBase.getSubnodeIndex = function (interval, centre) {\n  \tvar subnodeIndex = -1;\n  \tif (interval.min >= centre) subnodeIndex = 1;\n  \tif (interval.max <= centre) subnodeIndex = 0;\n  \treturn subnodeIndex;\n  };\n\n  function Interval() {\n  \tthis.min = null;\n  \tthis.max = null;\n  \tif (arguments.length === 0) {\n  \t\tthis.min = 0.0;\n  \t\tthis.max = 0.0;\n  \t} else if (arguments.length === 1) {\n  \t\tvar interval = arguments[0];\n  \t\tthis.init(interval.min, interval.max);\n  \t} else if (arguments.length === 2) {\n  \t\tvar min = arguments[0],\n  \t\t    max = arguments[1];\n  \t\tthis.init(min, max);\n  \t}\n  }\n  extend(Interval.prototype, {\n  \texpandToInclude: function expandToInclude(interval) {\n  \t\tif (interval.max > this.max) this.max = interval.max;\n  \t\tif (interval.min < this.min) this.min = interval.min;\n  \t},\n  \tgetWidth: function getWidth() {\n  \t\treturn this.max - this.min;\n  \t},\n  \toverlaps: function overlaps() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar interval = arguments[0];\n  \t\t\treturn this.overlaps(interval.min, interval.max);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar min = arguments[0],\n  \t\t\t    max = arguments[1];\n  \t\t\tif (this.min > max || this.max < min) return false;\n  \t\t\treturn true;\n  \t\t}\n  \t},\n  \tgetMin: function getMin() {\n  \t\treturn this.min;\n  \t},\n  \ttoString: function toString() {\n  \t\treturn \"[\" + this.min + \", \" + this.max + \"]\";\n  \t},\n  \tcontains: function contains() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tif (arguments[0] instanceof Interval) {\n  \t\t\t\tvar interval = arguments[0];\n  \t\t\t\treturn this.contains(interval.min, interval.max);\n  \t\t\t} else if (typeof arguments[0] === \"number\") {\n  \t\t\t\tvar p = arguments[0];\n  \t\t\t\treturn p >= this.min && p <= this.max;\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar min = arguments[0],\n  \t\t\t    max = arguments[1];\n  \t\t\treturn min >= this.min && max <= this.max;\n  \t\t}\n  \t},\n  \tinit: function init(min, max) {\n  \t\tthis.min = min;\n  \t\tthis.max = max;\n  \t\tif (min > max) {\n  \t\t\tthis.min = max;\n  \t\t\tthis.max = min;\n  \t\t}\n  \t},\n  \tgetMax: function getMax() {\n  \t\treturn this.max;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Interval;\n  \t}\n  });\n\n  function DoubleBits() {}\n  DoubleBits.exponent = function (d) {\n    return CVTFWD(64, d) - 1023;\n  };\n  DoubleBits.powerOf2 = function (exp) {\n    return Math.pow(2, exp);\n  };\n  function CVTFWD(NumW, Qty) {\n    var Sign;\n    var Expo;\n    var Mant;\n    var Bin;\n    var Inf = {\n      32: {\n        d: 0x7F,\n        c: 0x80,\n        b: 0,\n        a: 0\n      },\n      64: {\n        d: 0x7FF0,\n        c: 0,\n        b: 0,\n        a: 0\n      }\n    };\n    var ExW = {\n      32: 8,\n      64: 11\n    }[NumW];\n    if (!Bin) {\n      Sign = Qty < 0 || 1 / Qty < 0;\n      if (!isFinite(Qty)) {\n        Bin = Inf[NumW];\n        if (Sign) {\n          Bin.d += 1 << NumW / 4 - 1;\n        }\n        Expo = Math.pow(2, ExW) - 1;\n        Mant = 0;\n      }\n    }\n    if (!Bin) {\n      Expo = {\n        32: 127,\n        64: 1023\n      }[NumW];\n      Mant = Math.abs(Qty);\n      while (Mant >= 2) {\n        Expo++;\n        Mant /= 2;\n      }\n      while (Mant < 1 && Expo > 0) {\n        Expo--;\n        Mant *= 2;\n      }\n      if (Expo <= 0) {\n        Mant /= 2;\n      }\n      if (NumW === 32 && Expo > 254) {\n        Bin = {\n          d: Sign ? 0xFF : 0x7F,\n          c: 0x80,\n          b: 0,\n          a: 0\n        };\n        Expo = Math.pow(2, ExW) - 1;\n        Mant = 0;\n      }\n    }\n    return Expo;\n  }\n\n  function Key() {\n  \tthis._pt = 0.0;\n  \tthis._level = 0;\n  \tthis._interval = null;\n  \tvar interval = arguments[0];\n  \tthis.computeKey(interval);\n  }\n  extend(Key.prototype, {\n  \tgetInterval: function getInterval() {\n  \t\treturn this._interval;\n  \t},\n  \tgetLevel: function getLevel() {\n  \t\treturn this._level;\n  \t},\n  \tcomputeKey: function computeKey(itemInterval) {\n  \t\tthis._level = Key.computeLevel(itemInterval);\n  \t\tthis._interval = new Interval();\n  \t\tthis.computeInterval(this._level, itemInterval);\n  \t\twhile (!this._interval.contains(itemInterval)) {\n  \t\t\tthis._level += 1;\n  \t\t\tthis.computeInterval(this._level, itemInterval);\n  \t\t}\n  \t},\n  \tcomputeInterval: function computeInterval(level, itemInterval) {\n  \t\tvar size = DoubleBits.powerOf2(level);\n  \t\tthis._pt = Math.floor(itemInterval.getMin() / size) * size;\n  \t\tthis._interval.init(this._pt, this._pt + size);\n  \t},\n  \tgetPoint: function getPoint() {\n  \t\treturn this._pt;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Key;\n  \t}\n  });\n  Key.computeLevel = function (interval) {\n  \tvar dx = interval.getWidth();\n  \tvar level = DoubleBits.exponent(dx) + 1;\n  \treturn level;\n  };\n\n  function Node$1() {\n  \tNodeBase.apply(this);\n  \tthis._interval = null;\n  \tthis._centre = null;\n  \tthis._level = null;\n  \tvar interval = arguments[0],\n  \t    level = arguments[1];\n  \tthis._interval = interval;\n  \tthis._level = level;\n  \tthis._centre = (interval.getMin() + interval.getMax()) / 2;\n  }\n  inherits$1(Node$1, NodeBase);\n  extend(Node$1.prototype, {\n  \tgetInterval: function getInterval() {\n  \t\treturn this._interval;\n  \t},\n  \tfind: function find(searchInterval) {\n  \t\tvar subnodeIndex = NodeBase.getSubnodeIndex(searchInterval, this._centre);\n  \t\tif (subnodeIndex === -1) return this;\n  \t\tif (this._subnode[subnodeIndex] !== null) {\n  \t\t\tvar node = this._subnode[subnodeIndex];\n  \t\t\treturn node.find(searchInterval);\n  \t\t}\n  \t\treturn this;\n  \t},\n  \tinsert: function insert(node) {\n  \t\tAssert.isTrue(this._interval === null || this._interval.contains(node._interval));\n  \t\tvar index = NodeBase.getSubnodeIndex(node._interval, this._centre);\n  \t\tif (node._level === this._level - 1) {\n  \t\t\tthis._subnode[index] = node;\n  \t\t} else {\n  \t\t\tvar childNode = this.createSubnode(index);\n  \t\t\tchildNode.insert(node);\n  \t\t\tthis._subnode[index] = childNode;\n  \t\t}\n  \t},\n  \tisSearchMatch: function isSearchMatch(itemInterval) {\n  \t\treturn itemInterval.overlaps(this._interval);\n  \t},\n  \tgetSubnode: function getSubnode(index) {\n  \t\tif (this._subnode[index] === null) {\n  \t\t\tthis._subnode[index] = this.createSubnode(index);\n  \t\t}\n  \t\treturn this._subnode[index];\n  \t},\n  \tgetNode: function getNode(searchInterval) {\n  \t\tvar subnodeIndex = NodeBase.getSubnodeIndex(searchInterval, this._centre);\n  \t\tif (subnodeIndex !== -1) {\n  \t\t\tvar node = this.getSubnode(subnodeIndex);\n  \t\t\treturn node.getNode(searchInterval);\n  \t\t} else {\n  \t\t\treturn this;\n  \t\t}\n  \t},\n  \tcreateSubnode: function createSubnode(index) {\n  \t\tvar min = 0.0;\n  \t\tvar max = 0.0;\n  \t\tswitch (index) {\n  \t\t\tcase 0:\n  \t\t\t\tmin = this._interval.getMin();\n  \t\t\t\tmax = this._centre;\n  \t\t\t\tbreak;\n  \t\t\tcase 1:\n  \t\t\t\tmin = this._centre;\n  \t\t\t\tmax = this._interval.getMax();\n  \t\t\t\tbreak;\n  \t\t}\n  \t\tvar subInt = new Interval(min, max);\n  \t\tvar node = new Node$1(subInt, this._level - 1);\n  \t\treturn node;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Node$1;\n  \t}\n  });\n  Node$1.createNode = function (itemInterval) {\n  \tvar key = new Key(itemInterval);\n  \tvar node = new Node$1(key.getInterval(), key.getLevel());\n  \treturn node;\n  };\n  Node$1.createExpanded = function (node, addInterval) {\n  \tvar expandInt = new Interval(addInterval);\n  \tif (node !== null) expandInt.expandToInclude(node._interval);\n  \tvar largerNode = Node$1.createNode(expandInt);\n  \tif (node !== null) largerNode.insert(node);\n  \treturn largerNode;\n  };\n\n  function IntervalSize() {}\n  extend(IntervalSize.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn IntervalSize;\n  \t}\n  });\n  IntervalSize.isZeroWidth = function (min, max) {\n  \tvar width = max - min;\n  \tif (width === 0.0) return true;\n  \tvar maxAbs = Math.max(Math.abs(min), Math.abs(max));\n  \tvar scaledInterval = width / maxAbs;\n  \tvar level = DoubleBits.exponent(scaledInterval);\n  \treturn level <= IntervalSize.MIN_BINARY_EXPONENT;\n  };\n  IntervalSize.MIN_BINARY_EXPONENT = -50;\n\n  function Root() {\n  \tNodeBase.apply(this);\n  }\n  inherits$1(Root, NodeBase);\n  extend(Root.prototype, {\n  \tinsert: function insert(itemInterval, item) {\n  \t\tvar index = NodeBase.getSubnodeIndex(itemInterval, Root.origin);\n  \t\tif (index === -1) {\n  \t\t\tthis.add(item);\n  \t\t\treturn null;\n  \t\t}\n  \t\tvar node = this._subnode[index];\n  \t\tif (node === null || !node.getInterval().contains(itemInterval)) {\n  \t\t\tvar largerNode = Node$1.createExpanded(node, itemInterval);\n  \t\t\tthis._subnode[index] = largerNode;\n  \t\t}\n  \t\tthis.insertContained(this._subnode[index], itemInterval, item);\n  \t},\n  \tisSearchMatch: function isSearchMatch(interval) {\n  \t\treturn true;\n  \t},\n  \tinsertContained: function insertContained(tree, itemInterval, item) {\n  \t\tAssert.isTrue(tree.getInterval().contains(itemInterval));\n  \t\tvar isZeroArea = IntervalSize.isZeroWidth(itemInterval.getMin(), itemInterval.getMax());\n  \t\tvar node = null;\n  \t\tif (isZeroArea) node = tree.find(itemInterval);else node = tree.getNode(itemInterval);\n  \t\tnode.add(item);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Root;\n  \t}\n  });\n  Root.origin = 0.0;\n\n  function Bintree() {\n  \tthis._root = null;\n  \tthis._minExtent = 1.0;\n  \tthis._root = new Root();\n  }\n  extend(Bintree.prototype, {\n  \tsize: function size() {\n  \t\tif (this._root !== null) return this._root.size();\n  \t\treturn 0;\n  \t},\n  \tinsert: function insert(itemInterval, item) {\n  \t\tthis.collectStats(itemInterval);\n  \t\tvar insertInterval = Bintree.ensureExtent(itemInterval, this._minExtent);\n  \t\tthis._root.insert(insertInterval, item);\n  \t},\n  \tquery: function query() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tif (typeof arguments[0] === \"number\") {\n  \t\t\t\tvar x = arguments[0];\n  \t\t\t\treturn this.query(new Interval(x, x));\n  \t\t\t} else if (arguments[0] instanceof Interval) {\n  \t\t\t\tvar interval = arguments[0];\n  \t\t\t\tvar foundItems = new ArrayList();\n  \t\t\t\tthis.query(interval, foundItems);\n  \t\t\t\treturn foundItems;\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar interval = arguments[0],\n  \t\t\t    foundItems = arguments[1];\n  \t\t\tthis._root.addAllItemsFromOverlapping(interval, foundItems);\n  \t\t}\n  \t},\n  \titerator: function iterator() {\n  \t\tvar foundItems = new ArrayList();\n  \t\tthis._root.addAllItems(foundItems);\n  \t\treturn foundItems.iterator();\n  \t},\n  \tremove: function remove(itemInterval, item) {\n  \t\tvar insertInterval = Bintree.ensureExtent(itemInterval, this._minExtent);\n  \t\treturn this._root.remove(insertInterval, item);\n  \t},\n  \tcollectStats: function collectStats(interval) {\n  \t\tvar del = interval.getWidth();\n  \t\tif (del < this._minExtent && del > 0.0) this._minExtent = del;\n  \t},\n  \tdepth: function depth() {\n  \t\tif (this._root !== null) return this._root.depth();\n  \t\treturn 0;\n  \t},\n  \tnodeSize: function nodeSize() {\n  \t\tif (this._root !== null) return this._root.nodeSize();\n  \t\treturn 0;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Bintree;\n  \t}\n  });\n  Bintree.ensureExtent = function (itemInterval, minExtent) {\n  \tvar min = itemInterval.getMin();\n  \tvar max = itemInterval.getMax();\n  \tif (min !== max) return itemInterval;\n  \tif (min === max) {\n  \t\tmin = min - minExtent / 2.0;\n  \t\tmax = min + minExtent / 2.0;\n  \t}\n  \treturn new Interval(min, max);\n  };\n\n  function PointInRing() {}\n  extend(PointInRing.prototype, {\n  \tisInside: function isInside(pt) {},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn PointInRing;\n  \t}\n  });\n\n  function MCPointInRing() {\n  \tthis._ring = null;\n  \tthis._tree = null;\n  \tthis._crossings = 0;\n  \tthis._interval = new Interval();\n  \tvar ring = arguments[0];\n  \tthis._ring = ring;\n  \tthis.buildIndex();\n  }\n  extend(MCPointInRing.prototype, {\n  \ttestLineSegment: function testLineSegment(p, seg) {\n  \t\tvar xInt = null;\n  \t\tvar x1 = null;\n  \t\tvar y1 = null;\n  \t\tvar x2 = null;\n  \t\tvar y2 = null;\n  \t\tvar p1 = seg.p0;\n  \t\tvar p2 = seg.p1;\n  \t\tx1 = p1.x - p.x;\n  \t\ty1 = p1.y - p.y;\n  \t\tx2 = p2.x - p.x;\n  \t\ty2 = p2.y - p.y;\n  \t\tif (y1 > 0 && y2 <= 0 || y2 > 0 && y1 <= 0) {\n  \t\t\txInt = RobustDeterminant.signOfDet2x2(x1, y1, x2, y2) / (y2 - y1);\n  \t\t\tif (0.0 < xInt) {\n  \t\t\t\tthis._crossings++;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tbuildIndex: function buildIndex() {\n  \t\tthis._tree = new Bintree();\n  \t\tvar pts = CoordinateArrays.removeRepeatedPoints(this._ring.getCoordinates());\n  \t\tvar mcList = MonotoneChainBuilder.getChains(pts);\n  \t\tfor (var i = 0; i < mcList.size(); i++) {\n  \t\t\tvar mc = mcList.get(i);\n  \t\t\tvar mcEnv = mc.getEnvelope();\n  \t\t\tthis._interval.min = mcEnv.getMinY();\n  \t\t\tthis._interval.max = mcEnv.getMaxY();\n  \t\t\tthis._tree.insert(this._interval, mc);\n  \t\t}\n  \t},\n  \ttestMonotoneChain: function testMonotoneChain(rayEnv, mcSelecter, mc) {\n  \t\tmc.select(rayEnv, mcSelecter);\n  \t},\n  \tisInside: function isInside(pt) {\n  \t\tthis._crossings = 0;\n  \t\tvar rayEnv = new Envelope(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, pt.y, pt.y);\n  \t\tthis._interval.min = pt.y;\n  \t\tthis._interval.max = pt.y;\n  \t\tvar segs = this._tree.query(this._interval);\n  \t\tvar mcSelecter = new MCSelecter(this, pt);\n  \t\tfor (var i = segs.iterator(); i.hasNext();) {\n  \t\t\tvar mc = i.next();\n  \t\t\tthis.testMonotoneChain(rayEnv, mcSelecter, mc);\n  \t\t}\n  \t\tif (this._crossings % 2 === 1) {\n  \t\t\treturn true;\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [PointInRing];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MCPointInRing;\n  \t}\n  });\n  function MCSelecter() {\n  \tMonotoneChainSelectAction.apply(this);\n  \tthis.mcp = null;\n  \tthis.p = null;\n  \tvar mcp = arguments[0],\n  \t    p = arguments[1];\n  \tthis.mcp = mcp;\n  \tthis.p = p;\n  }\n  inherits$1(MCSelecter, MonotoneChainSelectAction);\n  extend(MCSelecter.prototype, {\n  \tselect: function select() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar ls = arguments[0];\n  \t\t\tthis.mcp.testLineSegment(this.p, ls);\n  \t\t} else return MonotoneChainSelectAction.prototype.select.apply(this, arguments);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MCSelecter;\n  \t}\n  });\n  MCPointInRing.MCSelecter = MCSelecter;\n\n  function Angle() {}\n  extend(Angle.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Angle;\n  \t}\n  });\n  Angle.toDegrees = function (radians) {\n  \treturn radians * 180 / Math.PI;\n  };\n  Angle.normalize = function (angle) {\n  \twhile (angle > Math.PI) {\n  \t\tangle -= Angle.PI_TIMES_2;\n  \t}while (angle <= -Math.PI) {\n  \t\tangle += Angle.PI_TIMES_2;\n  \t}return angle;\n  };\n  Angle.angle = function () {\n  \tif (arguments.length === 1) {\n  \t\tvar p = arguments[0];\n  \t\treturn Math.atan2(p.y, p.x);\n  \t} else if (arguments.length === 2) {\n  \t\tvar p0 = arguments[0],\n  \t\t    p1 = arguments[1];\n  \t\tvar dx = p1.x - p0.x;\n  \t\tvar dy = p1.y - p0.y;\n  \t\treturn Math.atan2(dy, dx);\n  \t}\n  };\n  Angle.isAcute = function (p0, p1, p2) {\n  \tvar dx0 = p0.x - p1.x;\n  \tvar dy0 = p0.y - p1.y;\n  \tvar dx1 = p2.x - p1.x;\n  \tvar dy1 = p2.y - p1.y;\n  \tvar dotprod = dx0 * dx1 + dy0 * dy1;\n  \treturn dotprod > 0;\n  };\n  Angle.isObtuse = function (p0, p1, p2) {\n  \tvar dx0 = p0.x - p1.x;\n  \tvar dy0 = p0.y - p1.y;\n  \tvar dx1 = p2.x - p1.x;\n  \tvar dy1 = p2.y - p1.y;\n  \tvar dotprod = dx0 * dx1 + dy0 * dy1;\n  \treturn dotprod < 0;\n  };\n  Angle.interiorAngle = function (p0, p1, p2) {\n  \tvar anglePrev = Angle.angle(p1, p0);\n  \tvar angleNext = Angle.angle(p1, p2);\n  \treturn Math.abs(angleNext - anglePrev);\n  };\n  Angle.normalizePositive = function (angle) {\n  \tif (angle < 0.0) {\n  \t\twhile (angle < 0.0) {\n  \t\t\tangle += Angle.PI_TIMES_2;\n  \t\t}if (angle >= Angle.PI_TIMES_2) angle = 0.0;\n  \t} else {\n  \t\twhile (angle >= Angle.PI_TIMES_2) {\n  \t\t\tangle -= Angle.PI_TIMES_2;\n  \t\t}if (angle < 0.0) angle = 0.0;\n  \t}\n  \treturn angle;\n  };\n  Angle.angleBetween = function (tip1, tail, tip2) {\n  \tvar a1 = Angle.angle(tail, tip1);\n  \tvar a2 = Angle.angle(tail, tip2);\n  \treturn Angle.diff(a1, a2);\n  };\n  Angle.diff = function (ang1, ang2) {\n  \tvar delAngle = null;\n  \tif (ang1 < ang2) {\n  \t\tdelAngle = ang2 - ang1;\n  \t} else {\n  \t\tdelAngle = ang1 - ang2;\n  \t}\n  \tif (delAngle > Math.PI) {\n  \t\tdelAngle = 2 * Math.PI - delAngle;\n  \t}\n  \treturn delAngle;\n  };\n  Angle.toRadians = function (angleDegrees) {\n  \treturn angleDegrees * Math.PI / 180.0;\n  };\n  Angle.getTurn = function (ang1, ang2) {\n  \tvar crossproduct = Math.sin(ang2 - ang1);\n  \tif (crossproduct > 0) {\n  \t\treturn Angle.COUNTERCLOCKWISE;\n  \t}\n  \tif (crossproduct < 0) {\n  \t\treturn Angle.CLOCKWISE;\n  \t}\n  \treturn Angle.NONE;\n  };\n  Angle.angleBetweenOriented = function (tip1, tail, tip2) {\n  \tvar a1 = Angle.angle(tail, tip1);\n  \tvar a2 = Angle.angle(tail, tip2);\n  \tvar angDel = a2 - a1;\n  \tif (angDel <= -Math.PI) return angDel + Angle.PI_TIMES_2;\n  \tif (angDel > Math.PI) return angDel - Angle.PI_TIMES_2;\n  \treturn angDel;\n  };\n  Angle.PI_TIMES_2 = 2.0 * Math.PI;\n  Angle.PI_OVER_2 = Math.PI / 2.0;\n  Angle.PI_OVER_4 = Math.PI / 4.0;\n  Angle.COUNTERCLOCKWISE = CGAlgorithms.COUNTERCLOCKWISE;\n  Angle.CLOCKWISE = CGAlgorithms.CLOCKWISE;\n  Angle.NONE = CGAlgorithms.COLLINEAR;\n\n  function Triangle$1() {\n  \tthis.p0 = null;\n  \tthis.p1 = null;\n  \tthis.p2 = null;\n  \tvar p0 = arguments[0],\n  \t    p1 = arguments[1],\n  \t    p2 = arguments[2];\n  \tthis.p0 = p0;\n  \tthis.p1 = p1;\n  \tthis.p2 = p2;\n  }\n  extend(Triangle$1.prototype, {\n  \tarea: function area() {\n  \t\treturn Triangle$1.area(this.p0, this.p1, this.p2);\n  \t},\n  \tsignedArea: function signedArea() {\n  \t\treturn Triangle$1.signedArea(this.p0, this.p1, this.p2);\n  \t},\n  \tinterpolateZ: function interpolateZ(p) {\n  \t\tif (p === null) throw new IllegalArgumentException(\"Supplied point is null.\");\n  \t\treturn Triangle$1.interpolateZ(p, this.p0, this.p1, this.p2);\n  \t},\n  \tlongestSideLength: function longestSideLength() {\n  \t\treturn Triangle$1.longestSideLength(this.p0, this.p1, this.p2);\n  \t},\n  \tisAcute: function isAcute() {\n  \t\treturn Triangle$1.isAcute(this.p0, this.p1, this.p2);\n  \t},\n  \tcircumcentre: function circumcentre() {\n  \t\treturn Triangle$1.circumcentre(this.p0, this.p1, this.p2);\n  \t},\n  \tarea3D: function area3D() {\n  \t\treturn Triangle$1.area3D(this.p0, this.p1, this.p2);\n  \t},\n  \tcentroid: function centroid() {\n  \t\treturn Triangle$1.centroid(this.p0, this.p1, this.p2);\n  \t},\n  \tinCentre: function inCentre() {\n  \t\treturn Triangle$1.inCentre(this.p0, this.p1, this.p2);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Triangle$1;\n  \t}\n  });\n  Triangle$1.area = function (a, b, c) {\n  \treturn Math.abs(((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2);\n  };\n  Triangle$1.signedArea = function (a, b, c) {\n  \treturn ((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2;\n  };\n  Triangle$1.det = function (m00, m01, m10, m11) {\n  \treturn m00 * m11 - m01 * m10;\n  };\n  Triangle$1.interpolateZ = function (p, v0, v1, v2) {\n  \tvar x0 = v0.x;\n  \tvar y0 = v0.y;\n  \tvar a = v1.x - x0;\n  \tvar b = v2.x - x0;\n  \tvar c = v1.y - y0;\n  \tvar d = v2.y - y0;\n  \tvar det = a * d - b * c;\n  \tvar dx = p.x - x0;\n  \tvar dy = p.y - y0;\n  \tvar t = (d * dx - b * dy) / det;\n  \tvar u = (-c * dx + a * dy) / det;\n  \tvar z = v0.z + t * (v1.z - v0.z) + u * (v2.z - v0.z);\n  \treturn z;\n  };\n  Triangle$1.longestSideLength = function (a, b, c) {\n  \tvar lenAB = a.distance(b);\n  \tvar lenBC = b.distance(c);\n  \tvar lenCA = c.distance(a);\n  \tvar maxLen = lenAB;\n  \tif (lenBC > maxLen) maxLen = lenBC;\n  \tif (lenCA > maxLen) maxLen = lenCA;\n  \treturn maxLen;\n  };\n  Triangle$1.isAcute = function (a, b, c) {\n  \tif (!Angle.isAcute(a, b, c)) return false;\n  \tif (!Angle.isAcute(b, c, a)) return false;\n  \tif (!Angle.isAcute(c, a, b)) return false;\n  \treturn true;\n  };\n  Triangle$1.circumcentre = function (a, b, c) {\n  \tvar cx = c.x;\n  \tvar cy = c.y;\n  \tvar ax = a.x - cx;\n  \tvar ay = a.y - cy;\n  \tvar bx = b.x - cx;\n  \tvar by = b.y - cy;\n  \tvar denom = 2 * Triangle$1.det(ax, ay, bx, by);\n  \tvar numx = Triangle$1.det(ay, ax * ax + ay * ay, by, bx * bx + by * by);\n  \tvar numy = Triangle$1.det(ax, ax * ax + ay * ay, bx, bx * bx + by * by);\n  \tvar ccx = cx - numx / denom;\n  \tvar ccy = cy + numy / denom;\n  \treturn new Coordinate(ccx, ccy);\n  };\n  Triangle$1.perpendicularBisector = function (a, b) {\n  \tvar dx = b.x - a.x;\n  \tvar dy = b.y - a.y;\n  \tvar l1 = new HCoordinate(a.x + dx / 2.0, a.y + dy / 2.0, 1.0);\n  \tvar l2 = new HCoordinate(a.x - dy + dx / 2.0, a.y + dx + dy / 2.0, 1.0);\n  \treturn new HCoordinate(l1, l2);\n  };\n  Triangle$1.angleBisector = function (a, b, c) {\n  \tvar len0 = b.distance(a);\n  \tvar len2 = b.distance(c);\n  \tvar frac = len0 / (len0 + len2);\n  \tvar dx = c.x - a.x;\n  \tvar dy = c.y - a.y;\n  \tvar splitPt = new Coordinate(a.x + frac * dx, a.y + frac * dy);\n  \treturn splitPt;\n  };\n  Triangle$1.area3D = function (a, b, c) {\n  \tvar ux = b.x - a.x;\n  \tvar uy = b.y - a.y;\n  \tvar uz = b.z - a.z;\n  \tvar vx = c.x - a.x;\n  \tvar vy = c.y - a.y;\n  \tvar vz = c.z - a.z;\n  \tvar crossx = uy * vz - uz * vy;\n  \tvar crossy = uz * vx - ux * vz;\n  \tvar crossz = ux * vy - uy * vx;\n  \tvar absSq = crossx * crossx + crossy * crossy + crossz * crossz;\n  \tvar area3D = Math.sqrt(absSq) / 2;\n  \treturn area3D;\n  };\n  Triangle$1.centroid = function (a, b, c) {\n  \tvar x = (a.x + b.x + c.x) / 3;\n  \tvar y = (a.y + b.y + c.y) / 3;\n  \treturn new Coordinate(x, y);\n  };\n  Triangle$1.inCentre = function (a, b, c) {\n  \tvar len0 = b.distance(c);\n  \tvar len1 = a.distance(c);\n  \tvar len2 = a.distance(b);\n  \tvar circum = len0 + len1 + len2;\n  \tvar inCentreX = (len0 * a.x + len1 * b.x + len2 * c.x) / circum;\n  \tvar inCentreY = (len0 * a.y + len1 * b.y + len2 * c.y) / circum;\n  \treturn new Coordinate(inCentreX, inCentreY);\n  };\n\n  function MinimumBoundingCircle() {\n  \tthis._input = null;\n  \tthis._extremalPts = null;\n  \tthis._centre = null;\n  \tthis._radius = 0.0;\n  \tvar geom = arguments[0];\n  \tthis._input = geom;\n  }\n  extend(MinimumBoundingCircle.prototype, {\n  \tgetRadius: function getRadius() {\n  \t\tthis.compute();\n  \t\treturn this._radius;\n  \t},\n  \tgetDiameter: function getDiameter() {\n  \t\tthis.compute();\n  \t\tswitch (this._extremalPts.length) {\n  \t\t\tcase 0:\n  \t\t\t\treturn this._input.getFactory().createLineString();\n  \t\t\tcase 1:\n  \t\t\t\treturn this._input.getFactory().createPoint(this._centre);\n  \t\t}\n  \t\tvar p0 = this._extremalPts[0];\n  \t\tvar p1 = this._extremalPts[1];\n  \t\treturn this._input.getFactory().createLineString([p0, p1]);\n  \t},\n  \tgetExtremalPoints: function getExtremalPoints() {\n  \t\tthis.compute();\n  \t\treturn this._extremalPts;\n  \t},\n  \tcomputeCirclePoints: function computeCirclePoints() {\n  \t\tif (this._input.isEmpty()) {\n  \t\t\tthis._extremalPts = new Array(0).fill(null);\n  \t\t\treturn null;\n  \t\t}\n  \t\tif (this._input.getNumPoints() === 1) {\n  \t\t\tvar pts = this._input.getCoordinates();\n  \t\t\tthis._extremalPts = [new Coordinate(pts[0])];\n  \t\t\treturn null;\n  \t\t}\n  \t\tvar convexHull = this._input.convexHull();\n  \t\tvar hullPts = convexHull.getCoordinates();\n  \t\tvar pts = hullPts;\n  \t\tif (hullPts[0].equals2D(hullPts[hullPts.length - 1])) {\n  \t\t\tpts = new Array(hullPts.length - 1).fill(null);\n  \t\t\tCoordinateArrays.copyDeep(hullPts, 0, pts, 0, hullPts.length - 1);\n  \t\t}\n  \t\tif (pts.length <= 2) {\n  \t\t\tthis._extremalPts = CoordinateArrays.copyDeep(pts);\n  \t\t\treturn null;\n  \t\t}\n  \t\tvar P = MinimumBoundingCircle.lowestPoint(pts);\n  \t\tvar Q = MinimumBoundingCircle.pointWitMinAngleWithX(pts, P);\n  \t\tfor (var i = 0; i < pts.length; i++) {\n  \t\t\tvar R = MinimumBoundingCircle.pointWithMinAngleWithSegment(pts, P, Q);\n  \t\t\tif (Angle.isObtuse(P, R, Q)) {\n  \t\t\t\tthis._extremalPts = [new Coordinate(P), new Coordinate(Q)];\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t\tif (Angle.isObtuse(R, P, Q)) {\n  \t\t\t\tP = R;\n  \t\t\t\tcontinue;\n  \t\t\t}\n  \t\t\tif (Angle.isObtuse(R, Q, P)) {\n  \t\t\t\tQ = R;\n  \t\t\t\tcontinue;\n  \t\t\t}\n  \t\t\tthis._extremalPts = [new Coordinate(P), new Coordinate(Q), new Coordinate(R)];\n  \t\t\treturn null;\n  \t\t}\n  \t\tAssert.shouldNeverReachHere(\"Logic failure in Minimum Bounding Circle algorithm!\");\n  \t},\n  \tcompute: function compute() {\n  \t\tif (this._extremalPts !== null) return null;\n  \t\tthis.computeCirclePoints();\n  \t\tthis.computeCentre();\n  \t\tif (this._centre !== null) this._radius = this._centre.distance(this._extremalPts[0]);\n  \t},\n  \tgetFarthestPoints: function getFarthestPoints() {\n  \t\tthis.compute();\n  \t\tswitch (this._extremalPts.length) {\n  \t\t\tcase 0:\n  \t\t\t\treturn this._input.getFactory().createLineString();\n  \t\t\tcase 1:\n  \t\t\t\treturn this._input.getFactory().createPoint(this._centre);\n  \t\t}\n  \t\tvar p0 = this._extremalPts[0];\n  \t\tvar p1 = this._extremalPts[this._extremalPts.length - 1];\n  \t\treturn this._input.getFactory().createLineString([p0, p1]);\n  \t},\n  \tgetCircle: function getCircle() {\n  \t\tthis.compute();\n  \t\tif (this._centre === null) return this._input.getFactory().createPolygon();\n  \t\tvar centrePoint = this._input.getFactory().createPoint(this._centre);\n  \t\tif (this._radius === 0.0) return centrePoint;\n  \t\treturn centrePoint.buffer(this._radius);\n  \t},\n  \tgetCentre: function getCentre() {\n  \t\tthis.compute();\n  \t\treturn this._centre;\n  \t},\n  \tcomputeCentre: function computeCentre() {\n  \t\tswitch (this._extremalPts.length) {\n  \t\t\tcase 0:\n  \t\t\t\tthis._centre = null;\n  \t\t\t\tbreak;\n  \t\t\tcase 1:\n  \t\t\t\tthis._centre = this._extremalPts[0];\n  \t\t\t\tbreak;\n  \t\t\tcase 2:\n  \t\t\t\tthis._centre = new Coordinate((this._extremalPts[0].x + this._extremalPts[1].x) / 2.0, (this._extremalPts[0].y + this._extremalPts[1].y) / 2.0);\n  \t\t\t\tbreak;\n  \t\t\tcase 3:\n  \t\t\t\tthis._centre = Triangle$1.circumcentre(this._extremalPts[0], this._extremalPts[1], this._extremalPts[2]);\n  \t\t\t\tbreak;\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MinimumBoundingCircle;\n  \t}\n  });\n  MinimumBoundingCircle.pointWitMinAngleWithX = function (pts, P) {\n  \tvar minSin = Double.MAX_VALUE;\n  \tvar minAngPt = null;\n  \tfor (var i = 0; i < pts.length; i++) {\n  \t\tvar p = pts[i];\n  \t\tif (p === P) continue;\n  \t\tvar dx = p.x - P.x;\n  \t\tvar dy = p.y - P.y;\n  \t\tif (dy < 0) dy = -dy;\n  \t\tvar len = Math.sqrt(dx * dx + dy * dy);\n  \t\tvar sin = dy / len;\n  \t\tif (sin < minSin) {\n  \t\t\tminSin = sin;\n  \t\t\tminAngPt = p;\n  \t\t}\n  \t}\n  \treturn minAngPt;\n  };\n  MinimumBoundingCircle.lowestPoint = function (pts) {\n  \tvar min = pts[0];\n  \tfor (var i = 1; i < pts.length; i++) {\n  \t\tif (pts[i].y < min.y) min = pts[i];\n  \t}\n  \treturn min;\n  };\n  MinimumBoundingCircle.pointWithMinAngleWithSegment = function (pts, P, Q) {\n  \tvar minAng = Double.MAX_VALUE;\n  \tvar minAngPt = null;\n  \tfor (var i = 0; i < pts.length; i++) {\n  \t\tvar p = pts[i];\n  \t\tif (p === P) continue;\n  \t\tif (p === Q) continue;\n  \t\tvar ang = Angle.angleBetween(P, p, Q);\n  \t\tif (ang < minAng) {\n  \t\t\tminAng = ang;\n  \t\t\tminAngPt = p;\n  \t\t}\n  \t}\n  \treturn minAngPt;\n  };\n\n  function MinimumDiameter() {\n  \tthis._inputGeom = null;\n  \tthis._isConvex = null;\n  \tthis._convexHullPts = null;\n  \tthis._minBaseSeg = new LineSegment();\n  \tthis._minWidthPt = null;\n  \tthis._minPtIndex = null;\n  \tthis._minWidth = 0.0;\n  \tif (arguments.length === 1) {\n  \t\tvar inputGeom = arguments[0];\n  \t\tMinimumDiameter.call(this, inputGeom, false);\n  \t} else if (arguments.length === 2) {\n  \t\tvar inputGeom = arguments[0],\n  \t\t    isConvex = arguments[1];\n  \t\tthis._inputGeom = inputGeom;\n  \t\tthis._isConvex = isConvex;\n  \t}\n  }\n  extend(MinimumDiameter.prototype, {\n  \tgetWidthCoordinate: function getWidthCoordinate() {\n  \t\tthis.computeMinimumDiameter();\n  \t\treturn this._minWidthPt;\n  \t},\n  \tgetSupportingSegment: function getSupportingSegment() {\n  \t\tthis.computeMinimumDiameter();\n  \t\treturn this._inputGeom.getFactory().createLineString([this._minBaseSeg.p0, this._minBaseSeg.p1]);\n  \t},\n  \tgetDiameter: function getDiameter() {\n  \t\tthis.computeMinimumDiameter();\n  \t\tif (this._minWidthPt === null) return this._inputGeom.getFactory().createLineString(null);\n  \t\tvar basePt = this._minBaseSeg.project(this._minWidthPt);\n  \t\treturn this._inputGeom.getFactory().createLineString([basePt, this._minWidthPt]);\n  \t},\n  \tcomputeWidthConvex: function computeWidthConvex(convexGeom) {\n  \t\tif (convexGeom instanceof Polygon) this._convexHullPts = convexGeom.getExteriorRing().getCoordinates();else this._convexHullPts = convexGeom.getCoordinates();\n  \t\tif (this._convexHullPts.length === 0) {\n  \t\t\tthis._minWidth = 0.0;\n  \t\t\tthis._minWidthPt = null;\n  \t\t\tthis._minBaseSeg = null;\n  \t\t} else if (this._convexHullPts.length === 1) {\n  \t\t\tthis._minWidth = 0.0;\n  \t\t\tthis._minWidthPt = this._convexHullPts[0];\n  \t\t\tthis._minBaseSeg.p0 = this._convexHullPts[0];\n  \t\t\tthis._minBaseSeg.p1 = this._convexHullPts[0];\n  \t\t} else if (this._convexHullPts.length === 2 || this._convexHullPts.length === 3) {\n  \t\t\tthis._minWidth = 0.0;\n  \t\t\tthis._minWidthPt = this._convexHullPts[0];\n  \t\t\tthis._minBaseSeg.p0 = this._convexHullPts[0];\n  \t\t\tthis._minBaseSeg.p1 = this._convexHullPts[1];\n  \t\t} else this.computeConvexRingMinDiameter(this._convexHullPts);\n  \t},\n  \tcomputeConvexRingMinDiameter: function computeConvexRingMinDiameter(pts) {\n  \t\tthis._minWidth = Double.MAX_VALUE;\n  \t\tvar currMaxIndex = 1;\n  \t\tvar seg = new LineSegment();\n  \t\tfor (var i = 0; i < pts.length - 1; i++) {\n  \t\t\tseg.p0 = pts[i];\n  \t\t\tseg.p1 = pts[i + 1];\n  \t\t\tcurrMaxIndex = this.findMaxPerpDistance(pts, seg, currMaxIndex);\n  \t\t}\n  \t},\n  \tcomputeMinimumDiameter: function computeMinimumDiameter() {\n  \t\tif (this._minWidthPt !== null) return null;\n  \t\tif (this._isConvex) this.computeWidthConvex(this._inputGeom);else {\n  \t\t\tvar convexGeom = new ConvexHull(this._inputGeom).getConvexHull();\n  \t\t\tthis.computeWidthConvex(convexGeom);\n  \t\t}\n  \t},\n  \tgetLength: function getLength() {\n  \t\tthis.computeMinimumDiameter();\n  \t\treturn this._minWidth;\n  \t},\n  \tfindMaxPerpDistance: function findMaxPerpDistance(pts, seg, startIndex) {\n  \t\tvar maxPerpDistance = seg.distancePerpendicular(pts[startIndex]);\n  \t\tvar nextPerpDistance = maxPerpDistance;\n  \t\tvar maxIndex = startIndex;\n  \t\tvar nextIndex = maxIndex;\n  \t\twhile (nextPerpDistance >= maxPerpDistance) {\n  \t\t\tmaxPerpDistance = nextPerpDistance;\n  \t\t\tmaxIndex = nextIndex;\n  \t\t\tnextIndex = MinimumDiameter.nextIndex(pts, maxIndex);\n  \t\t\tnextPerpDistance = seg.distancePerpendicular(pts[nextIndex]);\n  \t\t}\n  \t\tif (maxPerpDistance < this._minWidth) {\n  \t\t\tthis._minPtIndex = maxIndex;\n  \t\t\tthis._minWidth = maxPerpDistance;\n  \t\t\tthis._minWidthPt = pts[this._minPtIndex];\n  \t\t\tthis._minBaseSeg = new LineSegment(seg);\n  \t\t}\n  \t\treturn maxIndex;\n  \t},\n  \tgetMinimumRectangle: function getMinimumRectangle() {\n  \t\tthis.computeMinimumDiameter();\n  \t\tif (this._minWidth === 0.0) {\n  \t\t\tif (this._minBaseSeg.p0.equals2D(this._minBaseSeg.p1)) {\n  \t\t\t\treturn this._inputGeom.getFactory().createPoint(this._minBaseSeg.p0);\n  \t\t\t}\n  \t\t\treturn this._minBaseSeg.toGeometry(this._inputGeom.getFactory());\n  \t\t}\n  \t\tvar dx = this._minBaseSeg.p1.x - this._minBaseSeg.p0.x;\n  \t\tvar dy = this._minBaseSeg.p1.y - this._minBaseSeg.p0.y;\n  \t\tvar minPara = Double.MAX_VALUE;\n  \t\tvar maxPara = -Double.MAX_VALUE;\n  \t\tvar minPerp = Double.MAX_VALUE;\n  \t\tvar maxPerp = -Double.MAX_VALUE;\n  \t\tfor (var i = 0; i < this._convexHullPts.length; i++) {\n  \t\t\tvar paraC = MinimumDiameter.computeC(dx, dy, this._convexHullPts[i]);\n  \t\t\tif (paraC > maxPara) maxPara = paraC;\n  \t\t\tif (paraC < minPara) minPara = paraC;\n  \t\t\tvar perpC = MinimumDiameter.computeC(-dy, dx, this._convexHullPts[i]);\n  \t\t\tif (perpC > maxPerp) maxPerp = perpC;\n  \t\t\tif (perpC < minPerp) minPerp = perpC;\n  \t\t}\n  \t\tvar maxPerpLine = MinimumDiameter.computeSegmentForLine(-dx, -dy, maxPerp);\n  \t\tvar minPerpLine = MinimumDiameter.computeSegmentForLine(-dx, -dy, minPerp);\n  \t\tvar maxParaLine = MinimumDiameter.computeSegmentForLine(-dy, dx, maxPara);\n  \t\tvar minParaLine = MinimumDiameter.computeSegmentForLine(-dy, dx, minPara);\n  \t\tvar p0 = maxParaLine.lineIntersection(maxPerpLine);\n  \t\tvar p1 = minParaLine.lineIntersection(maxPerpLine);\n  \t\tvar p2 = minParaLine.lineIntersection(minPerpLine);\n  \t\tvar p3 = maxParaLine.lineIntersection(minPerpLine);\n  \t\tvar shell = this._inputGeom.getFactory().createLinearRing([p0, p1, p2, p3, p0]);\n  \t\treturn this._inputGeom.getFactory().createPolygon(shell, null);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MinimumDiameter;\n  \t}\n  });\n  MinimumDiameter.nextIndex = function (pts, index) {\n  \tindex++;\n  \tif (index >= pts.length) index = 0;\n  \treturn index;\n  };\n  MinimumDiameter.computeC = function (a, b, p) {\n  \treturn a * p.y - b * p.x;\n  };\n  MinimumDiameter.getMinimumDiameter = function (geom) {\n  \treturn new MinimumDiameter(geom).getDiameter();\n  };\n  MinimumDiameter.getMinimumRectangle = function (geom) {\n  \treturn new MinimumDiameter(geom).getMinimumRectangle();\n  };\n  MinimumDiameter.computeSegmentForLine = function (a, b, c) {\n  \tvar p0 = null;\n  \tvar p1 = null;\n  \tif (Math.abs(b) > Math.abs(a)) {\n  \t\tp0 = new Coordinate(0.0, c / b);\n  \t\tp1 = new Coordinate(1.0, c / b - a / b);\n  \t} else {\n  \t\tp0 = new Coordinate(c / a, 0.0);\n  \t\tp1 = new Coordinate(c / a - b / a, 1.0);\n  \t}\n  \treturn new LineSegment(p0, p1);\n  };\n\n  function Densifier() {\n  \tthis._inputGeom = null;\n  \tthis._distanceTolerance = null;\n  \tvar inputGeom = arguments[0];\n  \tthis._inputGeom = inputGeom;\n  }\n  extend(Densifier.prototype, {\n  \tgetResultGeometry: function getResultGeometry() {\n  \t\treturn new DensifyTransformer(this._distanceTolerance).transform(this._inputGeom);\n  \t},\n  \tsetDistanceTolerance: function setDistanceTolerance(distanceTolerance) {\n  \t\tif (distanceTolerance <= 0.0) throw new IllegalArgumentException(\"Tolerance must be positive\");\n  \t\tthis._distanceTolerance = distanceTolerance;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Densifier;\n  \t}\n  });\n  Densifier.densifyPoints = function (pts, distanceTolerance, precModel) {\n  \tvar seg = new LineSegment();\n  \tvar coordList = new CoordinateList();\n  \tfor (var i = 0; i < pts.length - 1; i++) {\n  \t\tseg.p0 = pts[i];\n  \t\tseg.p1 = pts[i + 1];\n  \t\tcoordList.add(seg.p0, false);\n  \t\tvar len = seg.getLength();\n  \t\tvar densifiedSegCount = Math.trunc(len / distanceTolerance) + 1;\n  \t\tif (densifiedSegCount > 1) {\n  \t\t\tvar densifiedSegLen = len / densifiedSegCount;\n  \t\t\tfor (var j = 1; j < densifiedSegCount; j++) {\n  \t\t\t\tvar segFract = j * densifiedSegLen / len;\n  \t\t\t\tvar p = seg.pointAlong(segFract);\n  \t\t\t\tprecModel.makePrecise(p);\n  \t\t\t\tcoordList.add(p, false);\n  \t\t\t}\n  \t\t}\n  \t}\n  \tcoordList.add(pts[pts.length - 1], false);\n  \treturn coordList.toCoordinateArray();\n  };\n  Densifier.densify = function (geom, distanceTolerance) {\n  \tvar densifier = new Densifier(geom);\n  \tdensifier.setDistanceTolerance(distanceTolerance);\n  \treturn densifier.getResultGeometry();\n  };\n  function DensifyTransformer() {\n  \tGeometryTransformer.apply(this);\n  \tthis.distanceTolerance = null;\n  \tvar distanceTolerance = arguments[0];\n  \tthis.distanceTolerance = distanceTolerance;\n  }\n  inherits$1(DensifyTransformer, GeometryTransformer);\n  extend(DensifyTransformer.prototype, {\n  \ttransformMultiPolygon: function transformMultiPolygon(geom, parent) {\n  \t\tvar roughGeom = GeometryTransformer.prototype.transformMultiPolygon.call(this, geom, parent);\n  \t\treturn this.createValidArea(roughGeom);\n  \t},\n  \ttransformPolygon: function transformPolygon(geom, parent) {\n  \t\tvar roughGeom = GeometryTransformer.prototype.transformPolygon.call(this, geom, parent);\n  \t\tif (parent instanceof MultiPolygon) {\n  \t\t\treturn roughGeom;\n  \t\t}\n  \t\treturn this.createValidArea(roughGeom);\n  \t},\n  \ttransformCoordinates: function transformCoordinates(coords, parent) {\n  \t\tvar inputPts = coords.toCoordinateArray();\n  \t\tvar newPts = Densifier.densifyPoints(inputPts, this.distanceTolerance, parent.getPrecisionModel());\n  \t\tif (parent instanceof LineString && newPts.length === 1) {\n  \t\t\tnewPts = new Array(0).fill(null);\n  \t\t}\n  \t\treturn this._factory.getCoordinateSequenceFactory().create(newPts);\n  \t},\n  \tcreateValidArea: function createValidArea(roughAreaGeom) {\n  \t\treturn roughAreaGeom.buffer(0.0);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn DensifyTransformer;\n  \t}\n  });\n  Densifier.DensifyTransformer = DensifyTransformer;\n\n  function HalfEdge() {\n  \tthis._orig = null;\n  \tthis._sym = null;\n  \tthis._next = null;\n  \tvar orig = arguments[0];\n  \tthis._orig = orig;\n  }\n  extend(HalfEdge.prototype, {\n  \tfind: function find(dest) {\n  \t\tvar oNext = this;\n  \t\tdo {\n  \t\t\tif (oNext === null) return null;\n  \t\t\tif (oNext.dest().equals2D(dest)) return oNext;\n  \t\t\toNext = oNext.oNext();\n  \t\t} while (oNext !== this);\n  \t\treturn null;\n  \t},\n  \tdest: function dest() {\n  \t\treturn this._sym._orig;\n  \t},\n  \toNext: function oNext() {\n  \t\treturn this._sym._next;\n  \t},\n  \tinsert: function insert(e) {\n  \t\tif (this.oNext() === this) {\n  \t\t\tthis.insertAfter(e);\n  \t\t\treturn null;\n  \t\t}\n  \t\tvar ecmp = this.compareTo(e);\n  \t\tvar ePrev = this;\n  \t\tdo {\n  \t\t\tvar oNext = ePrev.oNext();\n  \t\t\tvar cmp = oNext.compareTo(e);\n  \t\t\tif (cmp !== ecmp || oNext === this) {\n  \t\t\t\tePrev.insertAfter(e);\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t\tePrev = oNext;\n  \t\t} while (ePrev !== this);\n  \t\tAssert.shouldNeverReachHere();\n  \t},\n  \tinsertAfter: function insertAfter(e) {\n  \t\tAssert.equals(this._orig, e.orig());\n  \t\tvar save = this.oNext();\n  \t\tthis._sym.setNext(e);\n  \t\te.sym().setNext(save);\n  \t},\n  \tdegree: function degree() {\n  \t\tvar degree = 0;\n  \t\tvar e = this;\n  \t\tdo {\n  \t\t\tdegree++;\n  \t\t\te = e.oNext();\n  \t\t} while (e !== this);\n  \t\treturn degree;\n  \t},\n  \tequals: function equals() {\n  \t\tif (arguments.length === 2) {\n  \t\t\tvar p0 = arguments[0],\n  \t\t\t    p1 = arguments[1];\n  \t\t\treturn this._orig.equals2D(p0) && this._sym._orig.equals(p1);\n  \t\t}\n  \t},\n  \tdeltaY: function deltaY() {\n  \t\treturn this._sym._orig.y - this._orig.y;\n  \t},\n  \tsym: function sym() {\n  \t\treturn this._sym;\n  \t},\n  \tprev: function prev() {\n  \t\treturn this._sym.next()._sym;\n  \t},\n  \tcompareAngularDirection: function compareAngularDirection(e) {\n  \t\tvar dx = this.deltaX();\n  \t\tvar dy = this.deltaY();\n  \t\tvar dx2 = e.deltaX();\n  \t\tvar dy2 = e.deltaY();\n  \t\tif (dx === dx2 && dy === dy2) return 0;\n  \t\tvar quadrant = Quadrant.quadrant(dx, dy);\n  \t\tvar quadrant2 = Quadrant.quadrant(dx2, dy2);\n  \t\tif (quadrant > quadrant2) return 1;\n  \t\tif (quadrant < quadrant2) return -1;\n  \t\treturn CGAlgorithms.computeOrientation(e._orig, e.dest(), this.dest());\n  \t},\n  \tprevNode: function prevNode() {\n  \t\tvar e = this;\n  \t\twhile (e.degree() === 2) {\n  \t\t\te = e.prev();\n  \t\t\tif (e === this) return null;\n  \t\t}\n  \t\treturn e;\n  \t},\n  \tcompareTo: function compareTo(obj) {\n  \t\tvar e = obj;\n  \t\tvar comp = this.compareAngularDirection(e);\n  \t\treturn comp;\n  \t},\n  \tnext: function next() {\n  \t\treturn this._next;\n  \t},\n  \tsetSym: function setSym(e) {\n  \t\tthis._sym = e;\n  \t},\n  \torig: function orig() {\n  \t\treturn this._orig;\n  \t},\n  \ttoString: function toString() {\n  \t\treturn \"HE(\" + this._orig.x + \" \" + this._orig.y + \", \" + this._sym._orig.x + \" \" + this._sym._orig.y + \")\";\n  \t},\n  \tsetNext: function setNext(e) {\n  \t\tthis._next = e;\n  \t},\n  \tinit: function init(e) {\n  \t\tthis.setSym(e);\n  \t\te.setSym(this);\n  \t\tthis.setNext(e);\n  \t\te.setNext(this);\n  \t},\n  \tdeltaX: function deltaX() {\n  \t\treturn this._sym._orig.x - this._orig.x;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn HalfEdge;\n  \t}\n  });\n  HalfEdge.init = function (e0, e1) {\n  \tif (e0._sym !== null || e1._sym !== null || e0._next !== null || e1._next !== null) throw new IllegalStateException(\"Edges are already initialized\");\n  \te0.init(e1);\n  \treturn e0;\n  };\n  HalfEdge.create = function (p0, p1) {\n  \tvar e0 = new HalfEdge(p0);\n  \tvar e1 = new HalfEdge(p1);\n  \te0.init(e1);\n  \treturn e0;\n  };\n\n  function MarkHalfEdge() {\n  \tthis._isMarked = false;\n  \tvar orig = arguments[0];\n  \tHalfEdge.call(this, orig);\n  }\n  inherits$1(MarkHalfEdge, HalfEdge);\n  extend(MarkHalfEdge.prototype, {\n  \tmark: function mark() {\n  \t\tthis._isMarked = true;\n  \t},\n  \tsetMark: function setMark(isMarked) {\n  \t\tthis._isMarked = isMarked;\n  \t},\n  \tisMarked: function isMarked() {\n  \t\treturn this._isMarked;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MarkHalfEdge;\n  \t}\n  });\n  MarkHalfEdge.setMarkBoth = function (e, isMarked) {\n  \te.setMark(isMarked);\n  \te.sym().setMark(isMarked);\n  };\n  MarkHalfEdge.isMarked = function (e) {\n  \treturn e.isMarked();\n  };\n  MarkHalfEdge.setMark = function (e, isMarked) {\n  \te.setMark(isMarked);\n  };\n  MarkHalfEdge.markBoth = function (e) {\n  \te.mark();\n  \te.sym().mark();\n  };\n  MarkHalfEdge.mark = function (e) {\n  \te.mark();\n  };\n\n  function EdgeGraph() {\n  \tthis._vertexMap = new HashMap();\n  }\n  extend(EdgeGraph.prototype, {\n  \tinsert: function insert(orig, dest, eAdj) {\n  \t\tvar e = this.create(orig, dest);\n  \t\tif (eAdj !== null) {\n  \t\t\teAdj.insert(e);\n  \t\t} else {\n  \t\t\tthis._vertexMap.put(orig, e);\n  \t\t}\n  \t\tvar eAdjDest = this._vertexMap.get(dest);\n  \t\tif (eAdjDest !== null) {\n  \t\t\teAdjDest.insert(e.sym());\n  \t\t} else {\n  \t\t\tthis._vertexMap.put(dest, e.sym());\n  \t\t}\n  \t\treturn e;\n  \t},\n  \tcreate: function create(p0, p1) {\n  \t\tvar e0 = this.createEdge(p0);\n  \t\tvar e1 = this.createEdge(p1);\n  \t\tHalfEdge.init(e0, e1);\n  \t\treturn e0;\n  \t},\n  \tcreateEdge: function createEdge(orig) {\n  \t\treturn new HalfEdge(orig);\n  \t},\n  \taddEdge: function addEdge(orig, dest) {\n  \t\tif (!EdgeGraph.isValidEdge(orig, dest)) return null;\n  \t\tvar eAdj = this._vertexMap.get(orig);\n  \t\tvar eSame = null;\n  \t\tif (eAdj !== null) {\n  \t\t\teSame = eAdj.find(dest);\n  \t\t}\n  \t\tif (eSame !== null) {\n  \t\t\treturn eSame;\n  \t\t}\n  \t\tvar e = this.insert(orig, dest, eAdj);\n  \t\treturn e;\n  \t},\n  \tgetVertexEdges: function getVertexEdges() {\n  \t\treturn this._vertexMap.values();\n  \t},\n  \tfindEdge: function findEdge(orig, dest) {\n  \t\tvar e = this._vertexMap.get(orig);\n  \t\tif (e === null) return null;\n  \t\treturn e.find(dest);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn EdgeGraph;\n  \t}\n  });\n  EdgeGraph.isValidEdge = function (orig, dest) {\n  \tvar cmp = dest.compareTo(orig);\n  \treturn cmp !== 0;\n  };\n\n  function DissolveHalfEdge() {\n  \tthis._isStart = false;\n  \tvar orig = arguments[0];\n  \tMarkHalfEdge.call(this, orig);\n  }\n  inherits$1(DissolveHalfEdge, MarkHalfEdge);\n  extend(DissolveHalfEdge.prototype, {\n  \tsetStart: function setStart() {\n  \t\tthis._isStart = true;\n  \t},\n  \tisStart: function isStart() {\n  \t\treturn this._isStart;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn DissolveHalfEdge;\n  \t}\n  });\n\n  function DissolveEdgeGraph() {\n  \tEdgeGraph.apply(this);\n  }\n  inherits$1(DissolveEdgeGraph, EdgeGraph);\n  extend(DissolveEdgeGraph.prototype, {\n  \tcreateEdge: function createEdge(p0) {\n  \t\treturn new DissolveHalfEdge(p0);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn DissolveEdgeGraph;\n  \t}\n  });\n\n  function LineDissolver() {\n  \tthis._result = null;\n  \tthis._factory = null;\n  \tthis._graph = null;\n  \tthis._lines = new ArrayList();\n  \tthis._nodeEdgeStack = new Stack$1();\n  \tthis._ringStartEdge = null;\n  \tthis._graph = new DissolveEdgeGraph();\n  }\n  extend(LineDissolver.prototype, {\n  \taddLine: function addLine(line) {\n  \t\tthis._lines.add(this._factory.createLineString(line.toCoordinateArray()));\n  \t},\n  \tupdateRingStartEdge: function updateRingStartEdge(e) {\n  \t\tif (!e.isStart()) {\n  \t\t\te = e.sym();\n  \t\t\tif (!e.isStart()) return null;\n  \t\t}\n  \t\tif (this._ringStartEdge === null) {\n  \t\t\tthis._ringStartEdge = e;\n  \t\t\treturn null;\n  \t\t}\n  \t\tif (e.orig().compareTo(this._ringStartEdge.orig()) < 0) {\n  \t\t\tthis._ringStartEdge = e;\n  \t\t}\n  \t},\n  \tgetResult: function getResult() {\n  \t\tif (this._result === null) this.computeResult();\n  \t\treturn this._result;\n  \t},\n  \tprocess: function process(e) {\n  \t\tvar eNode = e.prevNode();\n  \t\tif (eNode === null) eNode = e;\n  \t\tthis.stackEdges(eNode);\n  \t\tthis.buildLines();\n  \t},\n  \tbuildRing: function buildRing(eStartRing) {\n  \t\tvar line = new CoordinateList();\n  \t\tvar e = eStartRing;\n  \t\tline.add(e.orig().copy(), false);\n  \t\twhile (e.sym().degree() === 2) {\n  \t\t\tvar eNext = e.next();\n  \t\t\tif (eNext === eStartRing) break;\n  \t\t\tline.add(eNext.orig().copy(), false);\n  \t\t\te = eNext;\n  \t\t}\n  \t\tline.add(e.dest().copy(), false);\n  \t\tthis.addLine(line);\n  \t},\n  \tbuildLine: function buildLine(eStart) {\n  \t\tvar line = new CoordinateList();\n  \t\tvar e = eStart;\n  \t\tthis._ringStartEdge = null;\n  \t\tMarkHalfEdge.markBoth(e);\n  \t\tline.add(e.orig().copy(), false);\n  \t\twhile (e.sym().degree() === 2) {\n  \t\t\tthis.updateRingStartEdge(e);\n  \t\t\tvar eNext = e.next();\n  \t\t\tif (eNext === eStart) {\n  \t\t\t\tthis.buildRing(this._ringStartEdge);\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t\tline.add(eNext.orig().copy(), false);\n  \t\t\te = eNext;\n  \t\t\tMarkHalfEdge.markBoth(e);\n  \t\t}\n  \t\tline.add(e.dest().copy(), false);\n  \t\tthis.stackEdges(e.sym());\n  \t\tthis.addLine(line);\n  \t},\n  \tstackEdges: function stackEdges(node) {\n  \t\tvar e = node;\n  \t\tdo {\n  \t\t\tif (!MarkHalfEdge.isMarked(e)) this._nodeEdgeStack.add(e);\n  \t\t\te = e.oNext();\n  \t\t} while (e !== node);\n  \t},\n  \tcomputeResult: function computeResult() {\n  \t\tvar edges = this._graph.getVertexEdges();\n  \t\tfor (var i = edges.iterator(); i.hasNext();) {\n  \t\t\tvar e = i.next();\n  \t\t\tif (MarkHalfEdge.isMarked(e)) continue;\n  \t\t\tthis.process(e);\n  \t\t}\n  \t\tthis._result = this._factory.buildGeometry(this._lines);\n  \t},\n  \tbuildLines: function buildLines() {\n  \t\twhile (!this._nodeEdgeStack.empty()) {\n  \t\t\tvar e = this._nodeEdgeStack.pop();\n  \t\t\tif (MarkHalfEdge.isMarked(e)) continue;\n  \t\t\tthis.buildLine(e);\n  \t\t}\n  \t},\n  \tadd: function add() {\n  \t\tif (arguments[0] instanceof Geometry) {\n  \t\t\tvar geometry = arguments[0];\n  \t\t\tgeometry.apply({\n  \t\t\t\tinterfaces_: function interfaces_() {\n  \t\t\t\t\treturn [GeometryComponentFilter];\n  \t\t\t\t},\n  \t\t\t\tfilter: function filter(component) {\n  \t\t\t\t\tif (component instanceof LineString) {\n  \t\t\t\t\t\tthis.add(component);\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t});\n  \t\t} else if (hasInterface(arguments[0], Collection)) {\n  \t\t\tvar geometries = arguments[0];\n  \t\t\tfor (var i = geometries.iterator(); i.hasNext();) {\n  \t\t\t\tvar geometry = i.next();\n  \t\t\t\tthis.add(geometry);\n  \t\t\t}\n  \t\t} else if (arguments[0] instanceof LineString) {\n  \t\t\tvar lineString = arguments[0];\n  \t\t\tif (this._factory === null) {\n  \t\t\t\tthis._factory = lineString.getFactory();\n  \t\t\t}\n  \t\t\tvar seq = lineString.getCoordinateSequence();\n  \t\t\tvar doneStart = false;\n  \t\t\tfor (var i = 1; i < seq.size(); i++) {\n  \t\t\t\tvar e = this._graph.addEdge(seq.getCoordinate(i - 1), seq.getCoordinate(i));\n  \t\t\t\tif (e === null) continue;\n  \t\t\t\tif (!doneStart) {\n  \t\t\t\t\te.setStart();\n  \t\t\t\t\tdoneStart = true;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LineDissolver;\n  \t}\n  });\n  LineDissolver.dissolve = function (g) {\n  \tvar d = new LineDissolver();\n  \td.add(g);\n  \treturn d.getResult();\n  };\n\n  function NodeBase$1() {\n  \tthis._items = new ArrayList();\n  \tthis._subnode = new Array(4).fill(null);\n  }\n  extend(NodeBase$1.prototype, {\n  \thasChildren: function hasChildren() {\n  \t\tfor (var i = 0; i < 4; i++) {\n  \t\t\tif (this._subnode[i] !== null) return true;\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tisPrunable: function isPrunable() {\n  \t\treturn !(this.hasChildren() || this.hasItems());\n  \t},\n  \taddAllItems: function addAllItems(resultItems) {\n  \t\tresultItems.addAll(this._items);\n  \t\tfor (var i = 0; i < 4; i++) {\n  \t\t\tif (this._subnode[i] !== null) {\n  \t\t\t\tthis._subnode[i].addAllItems(resultItems);\n  \t\t\t}\n  \t\t}\n  \t\treturn resultItems;\n  \t},\n  \tgetNodeCount: function getNodeCount() {\n  \t\tvar subSize = 0;\n  \t\tfor (var i = 0; i < 4; i++) {\n  \t\t\tif (this._subnode[i] !== null) {\n  \t\t\t\tsubSize += this._subnode[i].size();\n  \t\t\t}\n  \t\t}\n  \t\treturn subSize + 1;\n  \t},\n  \tsize: function size() {\n  \t\tvar subSize = 0;\n  \t\tfor (var i = 0; i < 4; i++) {\n  \t\t\tif (this._subnode[i] !== null) {\n  \t\t\t\tsubSize += this._subnode[i].size();\n  \t\t\t}\n  \t\t}\n  \t\treturn subSize + this._items.size();\n  \t},\n  \taddAllItemsFromOverlapping: function addAllItemsFromOverlapping(searchEnv, resultItems) {\n  \t\tif (!this.isSearchMatch(searchEnv)) return null;\n  \t\tresultItems.addAll(this._items);\n  \t\tfor (var i = 0; i < 4; i++) {\n  \t\t\tif (this._subnode[i] !== null) {\n  \t\t\t\tthis._subnode[i].addAllItemsFromOverlapping(searchEnv, resultItems);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tvisitItems: function visitItems(searchEnv, visitor) {\n  \t\tfor (var i = this._items.iterator(); i.hasNext();) {\n  \t\t\tvisitor.visitItem(i.next());\n  \t\t}\n  \t},\n  \thasItems: function hasItems() {\n  \t\treturn !this._items.isEmpty();\n  \t},\n  \tremove: function remove(itemEnv, item) {\n  \t\tif (!this.isSearchMatch(itemEnv)) return false;\n  \t\tvar found = false;\n  \t\tfor (var i = 0; i < 4; i++) {\n  \t\t\tif (this._subnode[i] !== null) {\n  \t\t\t\tfound = this._subnode[i].remove(itemEnv, item);\n  \t\t\t\tif (found) {\n  \t\t\t\t\tif (this._subnode[i].isPrunable()) this._subnode[i] = null;\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\tif (found) return found;\n  \t\tfound = this._items.remove(item);\n  \t\treturn found;\n  \t},\n  \tvisit: function visit(searchEnv, visitor) {\n  \t\tif (!this.isSearchMatch(searchEnv)) return null;\n  \t\tthis.visitItems(searchEnv, visitor);\n  \t\tfor (var i = 0; i < 4; i++) {\n  \t\t\tif (this._subnode[i] !== null) {\n  \t\t\t\tthis._subnode[i].visit(searchEnv, visitor);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetItems: function getItems() {\n  \t\treturn this._items;\n  \t},\n  \tdepth: function depth() {\n  \t\tvar maxSubDepth = 0;\n  \t\tfor (var i = 0; i < 4; i++) {\n  \t\t\tif (this._subnode[i] !== null) {\n  \t\t\t\tvar sqd = this._subnode[i].depth();\n  \t\t\t\tif (sqd > maxSubDepth) maxSubDepth = sqd;\n  \t\t\t}\n  \t\t}\n  \t\treturn maxSubDepth + 1;\n  \t},\n  \tisEmpty: function isEmpty() {\n  \t\tvar isEmpty = true;\n  \t\tif (!this._items.isEmpty()) isEmpty = false;\n  \t\tfor (var i = 0; i < 4; i++) {\n  \t\t\tif (this._subnode[i] !== null) {\n  \t\t\t\tif (!this._subnode[i].isEmpty()) isEmpty = false;\n  \t\t\t}\n  \t\t}\n  \t\treturn isEmpty;\n  \t},\n  \tadd: function add(item) {\n  \t\tthis._items.add(item);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Serializable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn NodeBase$1;\n  \t}\n  });\n  NodeBase$1.getSubnodeIndex = function (env, centrex, centrey) {\n  \tvar subnodeIndex = -1;\n  \tif (env.getMinX() >= centrex) {\n  \t\tif (env.getMinY() >= centrey) subnodeIndex = 3;\n  \t\tif (env.getMaxY() <= centrey) subnodeIndex = 1;\n  \t}\n  \tif (env.getMaxX() <= centrex) {\n  \t\tif (env.getMinY() >= centrey) subnodeIndex = 2;\n  \t\tif (env.getMaxY() <= centrey) subnodeIndex = 0;\n  \t}\n  \treturn subnodeIndex;\n  };\n\n  function Key$1() {\n  \tthis._pt = new Coordinate();\n  \tthis._level = 0;\n  \tthis._env = null;\n  \tvar itemEnv = arguments[0];\n  \tthis.computeKey(itemEnv);\n  }\n  extend(Key$1.prototype, {\n  \tgetLevel: function getLevel() {\n  \t\treturn this._level;\n  \t},\n  \tcomputeKey: function computeKey() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar itemEnv = arguments[0];\n  \t\t\tthis._level = Key$1.computeQuadLevel(itemEnv);\n  \t\t\tthis._env = new Envelope();\n  \t\t\tthis.computeKey(this._level, itemEnv);\n  \t\t\twhile (!this._env.contains(itemEnv)) {\n  \t\t\t\tthis._level += 1;\n  \t\t\t\tthis.computeKey(this._level, itemEnv);\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar level = arguments[0],\n  \t\t\t    itemEnv = arguments[1];\n  \t\t\tvar quadSize = DoubleBits.powerOf2(level);\n  \t\t\tthis._pt.x = Math.floor(itemEnv.getMinX() / quadSize) * quadSize;\n  \t\t\tthis._pt.y = Math.floor(itemEnv.getMinY() / quadSize) * quadSize;\n  \t\t\tthis._env.init(this._pt.x, this._pt.x + quadSize, this._pt.y, this._pt.y + quadSize);\n  \t\t}\n  \t},\n  \tgetEnvelope: function getEnvelope() {\n  \t\treturn this._env;\n  \t},\n  \tgetCentre: function getCentre() {\n  \t\treturn new Coordinate((this._env.getMinX() + this._env.getMaxX()) / 2, (this._env.getMinY() + this._env.getMaxY()) / 2);\n  \t},\n  \tgetPoint: function getPoint() {\n  \t\treturn this._pt;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Key$1;\n  \t}\n  });\n  Key$1.computeQuadLevel = function (env) {\n  \tvar dx = env.getWidth();\n  \tvar dy = env.getHeight();\n  \tvar dMax = dx > dy ? dx : dy;\n  \tvar level = DoubleBits.exponent(dMax) + 1;\n  \treturn level;\n  };\n\n  function Node$2() {\n  \tNodeBase$1.apply(this);\n  \tthis._env = null;\n  \tthis._centrex = null;\n  \tthis._centrey = null;\n  \tthis._level = null;\n  \tvar env = arguments[0],\n  \t    level = arguments[1];\n  \tthis._env = env;\n  \tthis._level = level;\n  \tthis._centrex = (env.getMinX() + env.getMaxX()) / 2;\n  \tthis._centrey = (env.getMinY() + env.getMaxY()) / 2;\n  }\n  inherits$1(Node$2, NodeBase$1);\n  extend(Node$2.prototype, {\n  \tfind: function find(searchEnv) {\n  \t\tvar subnodeIndex = NodeBase$1.getSubnodeIndex(searchEnv, this._centrex, this._centrey);\n  \t\tif (subnodeIndex === -1) return this;\n  \t\tif (this._subnode[subnodeIndex] !== null) {\n  \t\t\tvar node = this._subnode[subnodeIndex];\n  \t\t\treturn node.find(searchEnv);\n  \t\t}\n  \t\treturn this;\n  \t},\n  \tisSearchMatch: function isSearchMatch(searchEnv) {\n  \t\treturn this._env.intersects(searchEnv);\n  \t},\n  \tgetSubnode: function getSubnode(index) {\n  \t\tif (this._subnode[index] === null) {\n  \t\t\tthis._subnode[index] = this.createSubnode(index);\n  \t\t}\n  \t\treturn this._subnode[index];\n  \t},\n  \tgetEnvelope: function getEnvelope() {\n  \t\treturn this._env;\n  \t},\n  \tgetNode: function getNode(searchEnv) {\n  \t\tvar subnodeIndex = NodeBase$1.getSubnodeIndex(searchEnv, this._centrex, this._centrey);\n  \t\tif (subnodeIndex !== -1) {\n  \t\t\tvar node = this.getSubnode(subnodeIndex);\n  \t\t\treturn node.getNode(searchEnv);\n  \t\t} else {\n  \t\t\treturn this;\n  \t\t}\n  \t},\n  \tcreateSubnode: function createSubnode(index) {\n  \t\tvar minx = 0.0;\n  \t\tvar maxx = 0.0;\n  \t\tvar miny = 0.0;\n  \t\tvar maxy = 0.0;\n  \t\tswitch (index) {\n  \t\t\tcase 0:\n  \t\t\t\tminx = this._env.getMinX();\n  \t\t\t\tmaxx = this._centrex;\n  \t\t\t\tminy = this._env.getMinY();\n  \t\t\t\tmaxy = this._centrey;\n  \t\t\t\tbreak;\n  \t\t\tcase 1:\n  \t\t\t\tminx = this._centrex;\n  \t\t\t\tmaxx = this._env.getMaxX();\n  \t\t\t\tminy = this._env.getMinY();\n  \t\t\t\tmaxy = this._centrey;\n  \t\t\t\tbreak;\n  \t\t\tcase 2:\n  \t\t\t\tminx = this._env.getMinX();\n  \t\t\t\tmaxx = this._centrex;\n  \t\t\t\tminy = this._centrey;\n  \t\t\t\tmaxy = this._env.getMaxY();\n  \t\t\t\tbreak;\n  \t\t\tcase 3:\n  \t\t\t\tminx = this._centrex;\n  \t\t\t\tmaxx = this._env.getMaxX();\n  \t\t\t\tminy = this._centrey;\n  \t\t\t\tmaxy = this._env.getMaxY();\n  \t\t\t\tbreak;\n  \t\t}\n  \t\tvar sqEnv = new Envelope(minx, maxx, miny, maxy);\n  \t\tvar node = new Node$2(sqEnv, this._level - 1);\n  \t\treturn node;\n  \t},\n  \tinsertNode: function insertNode(node) {\n  \t\tAssert.isTrue(this._env === null || this._env.contains(node._env));\n  \t\tvar index = NodeBase$1.getSubnodeIndex(node._env, this._centrex, this._centrey);\n  \t\tif (node._level === this._level - 1) {\n  \t\t\tthis._subnode[index] = node;\n  \t\t} else {\n  \t\t\tvar childNode = this.createSubnode(index);\n  \t\t\tchildNode.insertNode(node);\n  \t\t\tthis._subnode[index] = childNode;\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Node$2;\n  \t}\n  });\n  Node$2.createNode = function (env) {\n  \tvar key = new Key$1(env);\n  \tvar node = new Node$2(key.getEnvelope(), key.getLevel());\n  \treturn node;\n  };\n  Node$2.createExpanded = function (node, addEnv) {\n  \tvar expandEnv = new Envelope(addEnv);\n  \tif (node !== null) expandEnv.expandToInclude(node._env);\n  \tvar largerNode = Node$2.createNode(expandEnv);\n  \tif (node !== null) largerNode.insertNode(node);\n  \treturn largerNode;\n  };\n\n  function Root$1() {\n  \tNodeBase$1.apply(this);\n  }\n  inherits$1(Root$1, NodeBase$1);\n  extend(Root$1.prototype, {\n  \tinsert: function insert(itemEnv, item) {\n  \t\tvar index = NodeBase$1.getSubnodeIndex(itemEnv, Root$1.origin.x, Root$1.origin.y);\n  \t\tif (index === -1) {\n  \t\t\tthis.add(item);\n  \t\t\treturn null;\n  \t\t}\n  \t\tvar node = this._subnode[index];\n  \t\tif (node === null || !node.getEnvelope().contains(itemEnv)) {\n  \t\t\tvar largerNode = Node$2.createExpanded(node, itemEnv);\n  \t\t\tthis._subnode[index] = largerNode;\n  \t\t}\n  \t\tthis.insertContained(this._subnode[index], itemEnv, item);\n  \t},\n  \tisSearchMatch: function isSearchMatch(searchEnv) {\n  \t\treturn true;\n  \t},\n  \tinsertContained: function insertContained(tree, itemEnv, item) {\n  \t\tAssert.isTrue(tree.getEnvelope().contains(itemEnv));\n  \t\tvar isZeroX = IntervalSize.isZeroWidth(itemEnv.getMinX(), itemEnv.getMaxX());\n  \t\tvar isZeroY = IntervalSize.isZeroWidth(itemEnv.getMinY(), itemEnv.getMaxY());\n  \t\tvar node = null;\n  \t\tif (isZeroX || isZeroY) node = tree.find(itemEnv);else node = tree.getNode(itemEnv);\n  \t\tnode.add(item);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Root$1;\n  \t}\n  });\n  Root$1.origin = new Coordinate(0.0, 0.0);\n\n  function Quadtree() {\n  \tthis._root = null;\n  \tthis._minExtent = 1.0;\n  \tthis._root = new Root$1();\n  }\n  extend(Quadtree.prototype, {\n  \tsize: function size() {\n  \t\tif (this._root !== null) return this._root.size();\n  \t\treturn 0;\n  \t},\n  \tinsert: function insert(itemEnv, item) {\n  \t\tthis.collectStats(itemEnv);\n  \t\tvar insertEnv = Quadtree.ensureExtent(itemEnv, this._minExtent);\n  \t\tthis._root.insert(insertEnv, item);\n  \t},\n  \tquery: function query() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar searchEnv = arguments[0];\n  \t\t\tvar visitor = new ArrayListVisitor();\n  \t\t\tthis.query(searchEnv, visitor);\n  \t\t\treturn visitor.getItems();\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar searchEnv = arguments[0],\n  \t\t\t    visitor = arguments[1];\n  \t\t\tthis._root.visit(searchEnv, visitor);\n  \t\t}\n  \t},\n  \tqueryAll: function queryAll() {\n  \t\tvar foundItems = new ArrayList();\n  \t\tthis._root.addAllItems(foundItems);\n  \t\treturn foundItems;\n  \t},\n  \tremove: function remove(itemEnv, item) {\n  \t\tvar posEnv = Quadtree.ensureExtent(itemEnv, this._minExtent);\n  \t\treturn this._root.remove(posEnv, item);\n  \t},\n  \tcollectStats: function collectStats(itemEnv) {\n  \t\tvar delX = itemEnv.getWidth();\n  \t\tif (delX < this._minExtent && delX > 0.0) this._minExtent = delX;\n  \t\tvar delY = itemEnv.getHeight();\n  \t\tif (delY < this._minExtent && delY > 0.0) this._minExtent = delY;\n  \t},\n  \tdepth: function depth() {\n  \t\tif (this._root !== null) return this._root.depth();\n  \t\treturn 0;\n  \t},\n  \tisEmpty: function isEmpty() {\n  \t\tif (this._root === null) return true;\n  \t\treturn false;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [SpatialIndex, Serializable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Quadtree;\n  \t}\n  });\n  Quadtree.ensureExtent = function (itemEnv, minExtent) {\n  \tvar minx = itemEnv.getMinX();\n  \tvar maxx = itemEnv.getMaxX();\n  \tvar miny = itemEnv.getMinY();\n  \tvar maxy = itemEnv.getMaxY();\n  \tif (minx !== maxx && miny !== maxy) return itemEnv;\n  \tif (minx === maxx) {\n  \t\tminx = minx - minExtent / 2.0;\n  \t\tmaxx = minx + minExtent / 2.0;\n  \t}\n  \tif (miny === maxy) {\n  \t\tminy = miny - minExtent / 2.0;\n  \t\tmaxy = miny + minExtent / 2.0;\n  \t}\n  \treturn new Envelope(minx, maxx, miny, maxy);\n  };\n  Quadtree.serialVersionUID = -7461163625812743604;\n\n  var geometryTypes = ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon'];\n  function GeoJSONParser(geometryFactory) {\n    this.geometryFactory = geometryFactory || new GeometryFactory();\n  }\n  extend(GeoJSONParser.prototype, {\n    read: function read(json) {\n      var obj;\n      if (typeof json === 'string') {\n        obj = JSON.parse(json);\n      } else {\n        obj = json;\n      }\n      var type = obj.type;\n      if (!parse$1[type]) {\n        throw new Error('Unknown GeoJSON type: ' + obj.type);\n      }\n      if (geometryTypes.indexOf(type) !== -1) {\n        return parse$1[type].apply(this, [obj.coordinates]);\n      } else if (type === 'GeometryCollection') {\n        return parse$1[type].apply(this, [obj.geometries]);\n      }\n      return parse$1[type].apply(this, [obj]);\n    },\n    write: function write(geometry) {\n      var type = geometry.getGeometryType();\n      if (!extract$2[type]) {\n        throw new Error('Geometry is not supported');\n      }\n      return extract$2[type].apply(this, [geometry]);\n    }\n  });\n  var parse$1 = {\n    Feature: function Feature(obj) {\n      var feature = {};\n      for (var key in obj) {\n        feature[key] = obj[key];\n      }\n      if (obj.geometry) {\n        var type = obj.geometry.type;\n        if (!parse$1[type]) {\n          throw new Error('Unknown GeoJSON type: ' + obj.type);\n        }\n        feature.geometry = this.read(obj.geometry);\n      }\n      if (obj.bbox) {\n        feature.bbox = parse$1.bbox.apply(this, [obj.bbox]);\n      }\n      return feature;\n    },\n    FeatureCollection: function FeatureCollection(obj) {\n      var featureCollection = {};\n      if (obj.features) {\n        featureCollection.features = [];\n        for (var i = 0; i < obj.features.length; ++i) {\n          featureCollection.features.push(this.read(obj.features[i]));\n        }\n      }\n      if (obj.bbox) {\n        featureCollection.bbox = this.parse.bbox.apply(this, [obj.bbox]);\n      }\n      return featureCollection;\n    },\n    coordinates: function coordinates(array) {\n      var coordinates = [];\n      for (var i = 0; i < array.length; ++i) {\n        var sub = array[i];\n        coordinates.push(new Coordinate(sub[0], sub[1]));\n      }\n      return coordinates;\n    },\n    bbox: function bbox(array) {\n      return this.geometryFactory.createLinearRing([new Coordinate(array[0], array[1]), new Coordinate(array[2], array[1]), new Coordinate(array[2], array[3]), new Coordinate(array[0], array[3]), new Coordinate(array[0], array[1])]);\n    },\n    Point: function Point(array) {\n      var coordinate = new Coordinate(array[0], array[1]);\n      return this.geometryFactory.createPoint(coordinate);\n    },\n    MultiPoint: function MultiPoint(array) {\n      var points = [];\n      for (var i = 0; i < array.length; ++i) {\n        points.push(parse$1.Point.apply(this, [array[i]]));\n      }\n      return this.geometryFactory.createMultiPoint(points);\n    },\n    LineString: function LineString(array) {\n      var coordinates = parse$1.coordinates.apply(this, [array]);\n      return this.geometryFactory.createLineString(coordinates);\n    },\n    MultiLineString: function MultiLineString(array) {\n      var lineStrings = [];\n      for (var i = 0; i < array.length; ++i) {\n        lineStrings.push(parse$1.LineString.apply(this, [array[i]]));\n      }\n      return this.geometryFactory.createMultiLineString(lineStrings);\n    },\n    Polygon: function Polygon(array) {\n      var shellCoordinates = parse$1.coordinates.apply(this, [array[0]]);\n      var shell = this.geometryFactory.createLinearRing(shellCoordinates);\n      var holes = [];\n      for (var i = 1; i < array.length; ++i) {\n        var hole = array[i];\n        var coordinates = parse$1.coordinates.apply(this, [hole]);\n        var linearRing = this.geometryFactory.createLinearRing(coordinates);\n        holes.push(linearRing);\n      }\n      return this.geometryFactory.createPolygon(shell, holes);\n    },\n    MultiPolygon: function MultiPolygon(array) {\n      var polygons = [];\n      for (var i = 0; i < array.length; ++i) {\n        var polygon = array[i];\n        polygons.push(parse$1.Polygon.apply(this, [polygon]));\n      }\n      return this.geometryFactory.createMultiPolygon(polygons);\n    },\n    GeometryCollection: function GeometryCollection(array) {\n      var geometries = [];\n      for (var i = 0; i < array.length; ++i) {\n        var geometry = array[i];\n        geometries.push(this.read(geometry));\n      }\n      return this.geometryFactory.createGeometryCollection(geometries);\n    }\n  };\n  var extract$2 = {\n    coordinate: function coordinate(_coordinate) {\n      return [_coordinate.x, _coordinate.y];\n    },\n    Point: function Point(point) {\n      var array = extract$2.coordinate.apply(this, [point.getCoordinate()]);\n      return {\n        type: 'Point',\n        coordinates: array\n      };\n    },\n    MultiPoint: function MultiPoint(multipoint) {\n      var array = [];\n      for (var i = 0; i < multipoint._geometries.length; ++i) {\n        var point = multipoint._geometries[i];\n        var geoJson = extract$2.Point.apply(this, [point]);\n        array.push(geoJson.coordinates);\n      }\n      return {\n        type: 'MultiPoint',\n        coordinates: array\n      };\n    },\n    LineString: function LineString(linestring) {\n      var array = [];\n      var coordinates = linestring.getCoordinates();\n      for (var i = 0; i < coordinates.length; ++i) {\n        var coordinate = coordinates[i];\n        array.push(extract$2.coordinate.apply(this, [coordinate]));\n      }\n      return {\n        type: 'LineString',\n        coordinates: array\n      };\n    },\n    MultiLineString: function MultiLineString(multilinestring) {\n      var array = [];\n      for (var i = 0; i < multilinestring._geometries.length; ++i) {\n        var linestring = multilinestring._geometries[i];\n        var geoJson = extract$2.LineString.apply(this, [linestring]);\n        array.push(geoJson.coordinates);\n      }\n      return {\n        type: 'MultiLineString',\n        coordinates: array\n      };\n    },\n    Polygon: function Polygon(polygon) {\n      var array = [];\n      var shellGeoJson = extract$2.LineString.apply(this, [polygon._shell]);\n      array.push(shellGeoJson.coordinates);\n      for (var i = 0; i < polygon._holes.length; ++i) {\n        var hole = polygon._holes[i];\n        var holeGeoJson = extract$2.LineString.apply(this, [hole]);\n        array.push(holeGeoJson.coordinates);\n      }\n      return {\n        type: 'Polygon',\n        coordinates: array\n      };\n    },\n    MultiPolygon: function MultiPolygon(multipolygon) {\n      var array = [];\n      for (var i = 0; i < multipolygon._geometries.length; ++i) {\n        var polygon = multipolygon._geometries[i];\n        var geoJson = extract$2.Polygon.apply(this, [polygon]);\n        array.push(geoJson.coordinates);\n      }\n      return {\n        type: 'MultiPolygon',\n        coordinates: array\n      };\n    },\n    GeometryCollection: function GeometryCollection(collection) {\n      var array = [];\n      for (var i = 0; i < collection._geometries.length; ++i) {\n        var geometry = collection._geometries[i];\n        var type = geometry.getGeometryType();\n        array.push(extract$2[type].apply(this, [geometry]));\n      }\n      return {\n        type: 'GeometryCollection',\n        geometries: array\n      };\n    }\n  };\n\n  function GeoJSONReader(geometryFactory) {\n    this.geometryFactory = geometryFactory || new GeometryFactory();\n    this.precisionModel = this.geometryFactory.getPrecisionModel();\n    this.parser = new GeoJSONParser(this.geometryFactory);\n  }\n  extend(GeoJSONReader.prototype, {\n    read: function read(geoJson) {\n      var geometry = this.parser.read(geoJson);\n      if (this.precisionModel.getType() === PrecisionModel.FIXED) {\n        this.reducePrecision(geometry);\n      }\n      return geometry;\n    },\n    reducePrecision: function reducePrecision(geometry) {\n      var i, len;\n      if (geometry.coordinate) {\n        this.precisionModel.makePrecise(geometry.coordinate);\n      } else if (geometry.points) {\n        for (i = 0, len = geometry.points.length; i < len; i++) {\n          this.precisionModel.makePrecise(geometry.points[i]);\n        }\n      } else if (geometry.geometries) {\n        for (i = 0, len = geometry.geometries.length; i < len; i++) {\n          this.reducePrecision(geometry.geometries[i]);\n        }\n      }\n    }\n  });\n\n  function GeoJSONWriter() {\n    this.parser = new GeoJSONParser(this.geometryFactory);\n  }\n  extend(GeoJSONWriter.prototype, {\n    write: function write(geometry) {\n      return this.parser.write(geometry);\n    }\n  });\n\n  function WKTReader(geometryFactory) {\n    this.geometryFactory = geometryFactory || new GeometryFactory();\n    this.precisionModel = this.geometryFactory.getPrecisionModel();\n    this.parser = new WKTParser(this.geometryFactory);\n  }\n  extend(WKTReader.prototype, {\n    read: function read(wkt) {\n      var geometry = this.parser.read(wkt);\n      if (this.precisionModel.getType() === PrecisionModel.FIXED) {\n        this.reducePrecision(geometry);\n      }\n      return geometry;\n    },\n    reducePrecision: function reducePrecision(geometry) {\n      if (geometry.coordinate) {\n        this.precisionModel.makePrecise(geometry.coordinate);\n      } else if (geometry._points) {\n        for (var i = 0, len = geometry._points._coordinates.length; i < len; i++) {\n          this.precisionModel.makePrecise(geometry._points._coordinates[i]);\n        }\n      } else if (geometry._geometries) {\n        for (var i = 0, len = geometry._geometries.length; i < len; i++) {\n          this.reducePrecision(geometry._geometries[i]);\n        }\n      }\n    }\n  });\n\n  function p2c(p) {\n    return [p.x, p.y];\n  }\n  function OL3Parser(geometryFactory, olReference) {\n    this.geometryFactory = geometryFactory || new GeometryFactory();\n    this.ol = olReference || typeof ol !== 'undefined' && ol;\n  }\n  extend(OL3Parser.prototype, {\n    read: function read(geometry) {\n      var ol = this.ol;\n      if (geometry instanceof ol.geom.Point) {\n        return this.convertFromPoint(geometry);\n      } else if (geometry instanceof ol.geom.LineString) {\n        return this.convertFromLineString(geometry);\n      } else if (geometry instanceof ol.geom.LinearRing) {\n        return this.convertFromLinearRing(geometry);\n      } else if (geometry instanceof ol.geom.Polygon) {\n        return this.convertFromPolygon(geometry);\n      } else if (geometry instanceof ol.geom.MultiPoint) {\n        return this.convertFromMultiPoint(geometry);\n      } else if (geometry instanceof ol.geom.MultiLineString) {\n        return this.convertFromMultiLineString(geometry);\n      } else if (geometry instanceof ol.geom.MultiPolygon) {\n        return this.convertFromMultiPolygon(geometry);\n      } else if (geometry instanceof ol.geom.GeometryCollection) {\n        return this.convertFromCollection(geometry);\n      }\n    },\n    convertFromPoint: function convertFromPoint(point) {\n      var coordinates = point.getCoordinates();\n      return this.geometryFactory.createPoint(new Coordinate(coordinates[0], coordinates[1]));\n    },\n    convertFromLineString: function convertFromLineString(lineString) {\n      return this.geometryFactory.createLineString(lineString.getCoordinates().map(function (coordinates) {\n        return new Coordinate(coordinates[0], coordinates[1]);\n      }));\n    },\n    convertFromLinearRing: function convertFromLinearRing(linearRing) {\n      return this.geometryFactory.createLinearRing(linearRing.getCoordinates().map(function (coordinates) {\n        return new Coordinate(coordinates[0], coordinates[1]);\n      }));\n    },\n    convertFromPolygon: function convertFromPolygon(polygon) {\n      var linearRings = polygon.getLinearRings();\n      var shell = null;\n      var holes = [];\n      for (var i = 0; i < linearRings.length; i++) {\n        var linearRing = this.convertFromLinearRing(linearRings[i]);\n        if (i === 0) {\n          shell = linearRing;\n        } else {\n          holes.push(linearRing);\n        }\n      }\n      return this.geometryFactory.createPolygon(shell, holes);\n    },\n    convertFromMultiPoint: function convertFromMultiPoint(multiPoint) {\n      var points = multiPoint.getPoints().map(function (point) {\n        return this.convertFromPoint(point);\n      }, this);\n      return this.geometryFactory.createMultiPoint(points);\n    },\n    convertFromMultiLineString: function convertFromMultiLineString(multiLineString) {\n      var lineStrings = multiLineString.getLineStrings().map(function (lineString) {\n        return this.convertFromLineString(lineString);\n      }, this);\n      return this.geometryFactory.createMultiLineString(lineStrings);\n    },\n    convertFromMultiPolygon: function convertFromMultiPolygon(multiPolygon) {\n      var polygons = multiPolygon.getPolygons().map(function (polygon) {\n        return this.convertFromPolygon(polygon);\n      }, this);\n      return this.geometryFactory.createMultiPolygon(polygons);\n    },\n    convertFromCollection: function convertFromCollection(collection) {\n      var geometries = collection.getGeometries().map(function (geometry) {\n        return this.read(geometry);\n      }, this);\n      return this.geometryFactory.createGeometryCollection(geometries);\n    },\n    write: function write(geometry) {\n      if (geometry.getGeometryType() === 'Point') {\n        return this.convertToPoint(geometry.getCoordinate());\n      } else if (geometry.getGeometryType() === 'LineString') {\n        return this.convertToLineString(geometry);\n      } else if (geometry.getGeometryType() === 'LinearRing') {\n        return this.convertToLinearRing(geometry);\n      } else if (geometry.getGeometryType() === 'Polygon') {\n        return this.convertToPolygon(geometry);\n      } else if (geometry.getGeometryType() === 'MultiPoint') {\n        return this.convertToMultiPoint(geometry);\n      } else if (geometry.getGeometryType() === 'MultiLineString') {\n        return this.convertToMultiLineString(geometry);\n      } else if (geometry.getGeometryType() === 'MultiPolygon') {\n        return this.convertToMultiPolygon(geometry);\n      } else if (geometry.getGeometryType() === 'GeometryCollection') {\n        return this.convertToCollection(geometry);\n      }\n    },\n    convertToPoint: function convertToPoint(coordinate) {\n      return new this.ol.geom.Point([coordinate.x, coordinate.y]);\n    },\n    convertToLineString: function convertToLineString(lineString) {\n      var points = lineString.points.coordinates.map(p2c);\n      return new this.ol.geom.LineString(points);\n    },\n    convertToLinearRing: function convertToLinearRing(linearRing) {\n      var points = linearRing.points.coordinates.map(p2c);\n      return new this.ol.geom.LinearRing(points);\n    },\n    convertToPolygon: function convertToPolygon(polygon) {\n      var rings = [polygon.shell.points.coordinates.map(p2c)];\n      for (var i = 0; i < polygon.holes.length; i++) {\n        rings.push(polygon.holes[i].points.coordinates.map(p2c));\n      }\n      return new this.ol.geom.Polygon(rings);\n    },\n    convertToMultiPoint: function convertToMultiPoint(multiPoint) {\n      return new this.ol.geom.MultiPoint(multiPoint.getCoordinates().map(p2c));\n    },\n    convertToMultiLineString: function convertToMultiLineString(multiLineString) {\n      var lineStrings = [];\n      for (var i = 0; i < multiLineString.geometries.length; i++) {\n        lineStrings.push(this.convertToLineString(multiLineString.geometries[i]).getCoordinates());\n      }\n      return new this.ol.geom.MultiLineString(lineStrings);\n    },\n    convertToMultiPolygon: function convertToMultiPolygon(multiPolygon) {\n      var polygons = [];\n      for (var i = 0; i < multiPolygon.geometries.length; i++) {\n        polygons.push(this.convertToPolygon(multiPolygon.geometries[i]).getCoordinates());\n      }\n      return new this.ol.geom.MultiPolygon(polygons);\n    },\n    convertToCollection: function convertToCollection(geometryCollection) {\n      var geometries = [];\n      for (var i = 0; i < geometryCollection.geometries.length; i++) {\n        var geometry = geometryCollection.geometries[i];\n        geometries.push(this.write(geometry));\n      }\n      return new this.ol.geom.GeometryCollection(geometries);\n    }\n  });\n\n  function ScaledNoder() {\n  \tthis._noder = null;\n  \tthis._scaleFactor = null;\n  \tthis._offsetX = null;\n  \tthis._offsetY = null;\n  \tthis._isScaled = false;\n  \tif (arguments.length === 2) {\n  \t\tvar noder = arguments[0],\n  \t\t    scaleFactor = arguments[1];\n  \t\tScaledNoder.call(this, noder, scaleFactor, 0, 0);\n  \t} else if (arguments.length === 4) {\n  \t\tvar noder = arguments[0],\n  \t\t    scaleFactor = arguments[1];\n  \t\tthis._noder = noder;\n  \t\tthis._scaleFactor = scaleFactor;\n  \t\tthis._isScaled = !this.isIntegerPrecision();\n  \t}\n  }\n  extend(ScaledNoder.prototype, {\n  \trescale: function rescale() {\n  \t\tif (hasInterface(arguments[0], Collection)) {\n  \t\t\tvar segStrings = arguments[0];\n  \t\t\tfor (var i = segStrings.iterator(); i.hasNext();) {\n  \t\t\t\tvar ss = i.next();\n  \t\t\t\tthis.rescale(ss.getCoordinates());\n  \t\t\t}\n  \t\t} else if (arguments[0] instanceof Array) {\n  \t\t\tvar pts = arguments[0];\n  \t\t\tvar p0 = null;\n  \t\t\tvar p1 = null;\n  \t\t\tif (pts.length === 2) {\n  \t\t\t\tp0 = new Coordinate(pts[0]);\n  \t\t\t\tp1 = new Coordinate(pts[1]);\n  \t\t\t}\n  \t\t\tfor (var i = 0; i < pts.length; i++) {\n  \t\t\t\tpts[i].x = pts[i].x / this._scaleFactor + this._offsetX;\n  \t\t\t\tpts[i].y = pts[i].y / this._scaleFactor + this._offsetY;\n  \t\t\t}\n  \t\t\tif (pts.length === 2 && pts[0].equals2D(pts[1])) {\n  \t\t\t\tSystem.out.println(pts);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tscale: function scale() {\n  \t\tif (hasInterface(arguments[0], Collection)) {\n  \t\t\tvar segStrings = arguments[0];\n  \t\t\tvar nodedSegmentStrings = new ArrayList();\n  \t\t\tfor (var i = segStrings.iterator(); i.hasNext();) {\n  \t\t\t\tvar ss = i.next();\n  \t\t\t\tnodedSegmentStrings.add(new NodedSegmentString(this.scale(ss.getCoordinates()), ss.getData()));\n  \t\t\t}\n  \t\t\treturn nodedSegmentStrings;\n  \t\t} else if (arguments[0] instanceof Array) {\n  \t\t\tvar pts = arguments[0];\n  \t\t\tvar roundPts = new Array(pts.length).fill(null);\n  \t\t\tfor (var i = 0; i < pts.length; i++) {\n  \t\t\t\troundPts[i] = new Coordinate(Math.round((pts[i].x - this._offsetX) * this._scaleFactor), Math.round((pts[i].y - this._offsetY) * this._scaleFactor), pts[i].z);\n  \t\t\t}\n  \t\t\tvar roundPtsNoDup = CoordinateArrays.removeRepeatedPoints(roundPts);\n  \t\t\treturn roundPtsNoDup;\n  \t\t}\n  \t},\n  \tisIntegerPrecision: function isIntegerPrecision() {\n  \t\treturn this._scaleFactor === 1.0;\n  \t},\n  \tgetNodedSubstrings: function getNodedSubstrings() {\n  \t\tvar splitSS = this._noder.getNodedSubstrings();\n  \t\tif (this._isScaled) this.rescale(splitSS);\n  \t\treturn splitSS;\n  \t},\n  \tcomputeNodes: function computeNodes(inputSegStrings) {\n  \t\tvar intSegStrings = inputSegStrings;\n  \t\tif (this._isScaled) intSegStrings = this.scale(inputSegStrings);\n  \t\tthis._noder.computeNodes(intSegStrings);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Noder];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn ScaledNoder;\n  \t}\n  });\n\n  function IsSimpleOp() {\n  \tthis._inputGeom = null;\n  \tthis._isClosedEndpointsInInterior = true;\n  \tthis._nonSimpleLocation = null;\n  \tif (arguments.length === 1) {\n  \t\tvar geom = arguments[0];\n  \t\tthis._inputGeom = geom;\n  \t} else if (arguments.length === 2) {\n  \t\tvar geom = arguments[0],\n  \t\t    boundaryNodeRule = arguments[1];\n  \t\tthis._inputGeom = geom;\n  \t\tthis._isClosedEndpointsInInterior = !boundaryNodeRule.isInBoundary(2);\n  \t}\n  }\n  extend(IsSimpleOp.prototype, {\n  \tisSimpleMultiPoint: function isSimpleMultiPoint(mp) {\n  \t\tif (mp.isEmpty()) return true;\n  \t\tvar points = new TreeSet();\n  \t\tfor (var i = 0; i < mp.getNumGeometries(); i++) {\n  \t\t\tvar pt = mp.getGeometryN(i);\n  \t\t\tvar p = pt.getCoordinate();\n  \t\t\tif (points.contains(p)) {\n  \t\t\t\tthis._nonSimpleLocation = p;\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t\tpoints.add(p);\n  \t\t}\n  \t\treturn true;\n  \t},\n  \tisSimplePolygonal: function isSimplePolygonal(geom) {\n  \t\tvar rings = LinearComponentExtracter.getLines(geom);\n  \t\tfor (var i = rings.iterator(); i.hasNext();) {\n  \t\t\tvar ring = i.next();\n  \t\t\tif (!this.isSimpleLinearGeometry(ring)) return false;\n  \t\t}\n  \t\treturn true;\n  \t},\n  \thasClosedEndpointIntersection: function hasClosedEndpointIntersection(graph) {\n  \t\tvar endPoints = new TreeMap();\n  \t\tfor (var i = graph.getEdgeIterator(); i.hasNext();) {\n  \t\t\tvar e = i.next();\n  \t\t\tvar maxSegmentIndex = e.getMaximumSegmentIndex();\n  \t\t\tvar isClosed = e.isClosed();\n  \t\t\tvar p0 = e.getCoordinate(0);\n  \t\t\tthis.addEndpoint(endPoints, p0, isClosed);\n  \t\t\tvar p1 = e.getCoordinate(e.getNumPoints() - 1);\n  \t\t\tthis.addEndpoint(endPoints, p1, isClosed);\n  \t\t}\n  \t\tfor (var i = endPoints.values().iterator(); i.hasNext();) {\n  \t\t\tvar eiInfo = i.next();\n  \t\t\tif (eiInfo.isClosed && eiInfo.degree !== 2) {\n  \t\t\t\tthis._nonSimpleLocation = eiInfo.getCoordinate();\n  \t\t\t\treturn true;\n  \t\t\t}\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tgetNonSimpleLocation: function getNonSimpleLocation() {\n  \t\treturn this._nonSimpleLocation;\n  \t},\n  \tisSimpleLinearGeometry: function isSimpleLinearGeometry(geom) {\n  \t\tif (geom.isEmpty()) return true;\n  \t\tvar graph = new GeometryGraph(0, geom);\n  \t\tvar li = new RobustLineIntersector();\n  \t\tvar si = graph.computeSelfNodes(li, true);\n  \t\tif (!si.hasIntersection()) return true;\n  \t\tif (si.hasProperIntersection()) {\n  \t\t\tthis._nonSimpleLocation = si.getProperIntersectionPoint();\n  \t\t\treturn false;\n  \t\t}\n  \t\tif (this.hasNonEndpointIntersection(graph)) return false;\n  \t\tif (this._isClosedEndpointsInInterior) {\n  \t\t\tif (this.hasClosedEndpointIntersection(graph)) return false;\n  \t\t}\n  \t\treturn true;\n  \t},\n  \thasNonEndpointIntersection: function hasNonEndpointIntersection(graph) {\n  \t\tfor (var i = graph.getEdgeIterator(); i.hasNext();) {\n  \t\t\tvar e = i.next();\n  \t\t\tvar maxSegmentIndex = e.getMaximumSegmentIndex();\n  \t\t\tfor (var eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext();) {\n  \t\t\t\tvar ei = eiIt.next();\n  \t\t\t\tif (!ei.isEndPoint(maxSegmentIndex)) {\n  \t\t\t\t\tthis._nonSimpleLocation = ei.getCoordinate();\n  \t\t\t\t\treturn true;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\treturn false;\n  \t},\n  \taddEndpoint: function addEndpoint(endPoints, p, isClosed) {\n  \t\tvar eiInfo = endPoints.get(p);\n  \t\tif (eiInfo === null) {\n  \t\t\teiInfo = new EndpointInfo(p);\n  \t\t\tendPoints.put(p, eiInfo);\n  \t\t}\n  \t\teiInfo.addEndpoint(isClosed);\n  \t},\n  \tcomputeSimple: function computeSimple(geom) {\n  \t\tthis._nonSimpleLocation = null;\n  \t\tif (geom.isEmpty()) return true;\n  \t\tif (geom instanceof LineString) return this.isSimpleLinearGeometry(geom);\n  \t\tif (geom instanceof MultiLineString) return this.isSimpleLinearGeometry(geom);\n  \t\tif (geom instanceof MultiPoint) return this.isSimpleMultiPoint(geom);\n  \t\tif (hasInterface(geom, Polygonal)) return this.isSimplePolygonal(geom);\n  \t\tif (geom instanceof GeometryCollection) return this.isSimpleGeometryCollection(geom);\n  \t\treturn true;\n  \t},\n  \tisSimple: function isSimple() {\n  \t\tthis._nonSimpleLocation = null;\n  \t\treturn this.computeSimple(this._inputGeom);\n  \t},\n  \tisSimpleGeometryCollection: function isSimpleGeometryCollection(geom) {\n  \t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n  \t\t\tvar comp = geom.getGeometryN(i);\n  \t\t\tif (!this.computeSimple(comp)) return false;\n  \t\t}\n  \t\treturn true;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn IsSimpleOp;\n  \t}\n  });\n  function EndpointInfo() {\n  \tthis.pt = null;\n  \tthis.isClosed = null;\n  \tthis.degree = null;\n  \tvar pt = arguments[0];\n  \tthis.pt = pt;\n  \tthis.isClosed = false;\n  \tthis.degree = 0;\n  }\n  extend(EndpointInfo.prototype, {\n  \taddEndpoint: function addEndpoint(isClosed) {\n  \t\tthis.degree++;\n  \t\tthis.isClosed |= isClosed;\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\treturn this.pt;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn EndpointInfo;\n  \t}\n  });\n  IsSimpleOp.EndpointInfo = EndpointInfo;\n\n  function BufferParameters() {\n  \tthis._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;\n  \tthis._endCapStyle = BufferParameters.CAP_ROUND;\n  \tthis._joinStyle = BufferParameters.JOIN_ROUND;\n  \tthis._mitreLimit = BufferParameters.DEFAULT_MITRE_LIMIT;\n  \tthis._isSingleSided = false;\n  \tthis._simplifyFactor = BufferParameters.DEFAULT_SIMPLIFY_FACTOR;\n  \tif (arguments.length === 0) ; else if (arguments.length === 1) {\n  \t\tvar quadrantSegments = arguments[0];\n  \t\tthis.setQuadrantSegments(quadrantSegments);\n  \t} else if (arguments.length === 2) {\n  \t\tvar quadrantSegments = arguments[0],\n  \t\t    endCapStyle = arguments[1];\n  \t\tthis.setQuadrantSegments(quadrantSegments);\n  \t\tthis.setEndCapStyle(endCapStyle);\n  \t} else if (arguments.length === 4) {\n  \t\tvar quadrantSegments = arguments[0],\n  \t\t    endCapStyle = arguments[1],\n  \t\t    joinStyle = arguments[2],\n  \t\t    mitreLimit = arguments[3];\n  \t\tthis.setQuadrantSegments(quadrantSegments);\n  \t\tthis.setEndCapStyle(endCapStyle);\n  \t\tthis.setJoinStyle(joinStyle);\n  \t\tthis.setMitreLimit(mitreLimit);\n  \t}\n  }\n  extend(BufferParameters.prototype, {\n  \tgetEndCapStyle: function getEndCapStyle() {\n  \t\treturn this._endCapStyle;\n  \t},\n  \tisSingleSided: function isSingleSided() {\n  \t\treturn this._isSingleSided;\n  \t},\n  \tsetQuadrantSegments: function setQuadrantSegments(quadSegs) {\n  \t\tthis._quadrantSegments = quadSegs;\n  \t\tif (this._quadrantSegments === 0) this._joinStyle = BufferParameters.JOIN_BEVEL;\n  \t\tif (this._quadrantSegments < 0) {\n  \t\t\tthis._joinStyle = BufferParameters.JOIN_MITRE;\n  \t\t\tthis._mitreLimit = Math.abs(this._quadrantSegments);\n  \t\t}\n  \t\tif (quadSegs <= 0) {\n  \t\t\tthis._quadrantSegments = 1;\n  \t\t}\n  \t\tif (this._joinStyle !== BufferParameters.JOIN_ROUND) {\n  \t\t\tthis._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;\n  \t\t}\n  \t},\n  \tgetJoinStyle: function getJoinStyle() {\n  \t\treturn this._joinStyle;\n  \t},\n  \tsetJoinStyle: function setJoinStyle(joinStyle) {\n  \t\tthis._joinStyle = joinStyle;\n  \t},\n  \tsetSimplifyFactor: function setSimplifyFactor(simplifyFactor) {\n  \t\tthis._simplifyFactor = simplifyFactor < 0 ? 0 : simplifyFactor;\n  \t},\n  \tgetSimplifyFactor: function getSimplifyFactor() {\n  \t\treturn this._simplifyFactor;\n  \t},\n  \tgetQuadrantSegments: function getQuadrantSegments() {\n  \t\treturn this._quadrantSegments;\n  \t},\n  \tsetEndCapStyle: function setEndCapStyle(endCapStyle) {\n  \t\tthis._endCapStyle = endCapStyle;\n  \t},\n  \tgetMitreLimit: function getMitreLimit() {\n  \t\treturn this._mitreLimit;\n  \t},\n  \tsetMitreLimit: function setMitreLimit(mitreLimit) {\n  \t\tthis._mitreLimit = mitreLimit;\n  \t},\n  \tsetSingleSided: function setSingleSided(isSingleSided) {\n  \t\tthis._isSingleSided = isSingleSided;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn BufferParameters;\n  \t}\n  });\n  BufferParameters.bufferDistanceError = function (quadSegs) {\n  \tvar alpha = Math.PI / 2.0 / quadSegs;\n  \treturn 1 - Math.cos(alpha / 2.0);\n  };\n  BufferParameters.CAP_ROUND = 1;\n  BufferParameters.CAP_FLAT = 2;\n  BufferParameters.CAP_SQUARE = 3;\n  BufferParameters.JOIN_ROUND = 1;\n  BufferParameters.JOIN_MITRE = 2;\n  BufferParameters.JOIN_BEVEL = 3;\n  BufferParameters.DEFAULT_QUADRANT_SEGMENTS = 8;\n  BufferParameters.DEFAULT_MITRE_LIMIT = 5.0;\n  BufferParameters.DEFAULT_SIMPLIFY_FACTOR = 0.01;\n\n  function RightmostEdgeFinder() {\n  \tthis._minIndex = -1;\n  \tthis._minCoord = null;\n  \tthis._minDe = null;\n  \tthis._orientedDe = null;\n  }\n  extend(RightmostEdgeFinder.prototype, {\n  \tgetCoordinate: function getCoordinate() {\n  \t\treturn this._minCoord;\n  \t},\n  \tgetRightmostSide: function getRightmostSide(de, index) {\n  \t\tvar side = this.getRightmostSideOfSegment(de, index);\n  \t\tif (side < 0) side = this.getRightmostSideOfSegment(de, index - 1);\n  \t\tif (side < 0) {\n  \t\t\tthis._minCoord = null;\n  \t\t\tthis.checkForRightmostCoordinate(de);\n  \t\t}\n  \t\treturn side;\n  \t},\n  \tfindRightmostEdgeAtVertex: function findRightmostEdgeAtVertex() {\n  \t\tvar pts = this._minDe.getEdge().getCoordinates();\n  \t\tAssert.isTrue(this._minIndex > 0 && this._minIndex < pts.length, \"rightmost point expected to be interior vertex of edge\");\n  \t\tvar pPrev = pts[this._minIndex - 1];\n  \t\tvar pNext = pts[this._minIndex + 1];\n  \t\tvar orientation = CGAlgorithms.computeOrientation(this._minCoord, pNext, pPrev);\n  \t\tvar usePrev = false;\n  \t\tif (pPrev.y < this._minCoord.y && pNext.y < this._minCoord.y && orientation === CGAlgorithms.COUNTERCLOCKWISE) {\n  \t\t\tusePrev = true;\n  \t\t} else if (pPrev.y > this._minCoord.y && pNext.y > this._minCoord.y && orientation === CGAlgorithms.CLOCKWISE) {\n  \t\t\tusePrev = true;\n  \t\t}\n  \t\tif (usePrev) {\n  \t\t\tthis._minIndex = this._minIndex - 1;\n  \t\t}\n  \t},\n  \tgetRightmostSideOfSegment: function getRightmostSideOfSegment(de, i) {\n  \t\tvar e = de.getEdge();\n  \t\tvar coord = e.getCoordinates();\n  \t\tif (i < 0 || i + 1 >= coord.length) return -1;\n  \t\tif (coord[i].y === coord[i + 1].y) return -1;\n  \t\tvar pos = Position.LEFT;\n  \t\tif (coord[i].y < coord[i + 1].y) pos = Position.RIGHT;\n  \t\treturn pos;\n  \t},\n  \tgetEdge: function getEdge() {\n  \t\treturn this._orientedDe;\n  \t},\n  \tcheckForRightmostCoordinate: function checkForRightmostCoordinate(de) {\n  \t\tvar coord = de.getEdge().getCoordinates();\n  \t\tfor (var i = 0; i < coord.length - 1; i++) {\n  \t\t\tif (this._minCoord === null || coord[i].x > this._minCoord.x) {\n  \t\t\t\tthis._minDe = de;\n  \t\t\t\tthis._minIndex = i;\n  \t\t\t\tthis._minCoord = coord[i];\n  \t\t\t}\n  \t\t}\n  \t},\n  \tfindRightmostEdgeAtNode: function findRightmostEdgeAtNode() {\n  \t\tvar node = this._minDe.getNode();\n  \t\tvar star = node.getEdges();\n  \t\tthis._minDe = star.getRightmostEdge();\n  \t\tif (!this._minDe.isForward()) {\n  \t\t\tthis._minDe = this._minDe.getSym();\n  \t\t\tthis._minIndex = this._minDe.getEdge().getCoordinates().length - 1;\n  \t\t}\n  \t},\n  \tfindEdge: function findEdge(dirEdgeList) {\n  \t\tfor (var i = dirEdgeList.iterator(); i.hasNext();) {\n  \t\t\tvar de = i.next();\n  \t\t\tif (!de.isForward()) continue;\n  \t\t\tthis.checkForRightmostCoordinate(de);\n  \t\t}\n  \t\tAssert.isTrue(this._minIndex !== 0 || this._minCoord.equals(this._minDe.getCoordinate()), \"inconsistency in rightmost processing\");\n  \t\tif (this._minIndex === 0) {\n  \t\t\tthis.findRightmostEdgeAtNode();\n  \t\t} else {\n  \t\t\tthis.findRightmostEdgeAtVertex();\n  \t\t}\n  \t\tthis._orientedDe = this._minDe;\n  \t\tvar rightmostSide = this.getRightmostSide(this._minDe, this._minIndex);\n  \t\tif (rightmostSide === Position.LEFT) {\n  \t\t\tthis._orientedDe = this._minDe.getSym();\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn RightmostEdgeFinder;\n  \t}\n  });\n\n  function LinkedList() {\n    this.array_ = [];\n  }\n  LinkedList.prototype.addLast = function (e) {\n    this.array_.push(e);\n  };\n  LinkedList.prototype.removeFirst = function () {\n    return this.array_.shift();\n  };\n  LinkedList.prototype.isEmpty = function () {\n    return this.array_.length === 0;\n  };\n\n  function BufferSubgraph() {\n  \tthis._finder = null;\n  \tthis._dirEdgeList = new ArrayList();\n  \tthis._nodes = new ArrayList();\n  \tthis._rightMostCoord = null;\n  \tthis._env = null;\n  \tthis._finder = new RightmostEdgeFinder();\n  }\n  extend(BufferSubgraph.prototype, {\n  \tclearVisitedEdges: function clearVisitedEdges() {\n  \t\tfor (var it = this._dirEdgeList.iterator(); it.hasNext();) {\n  \t\t\tvar de = it.next();\n  \t\t\tde.setVisited(false);\n  \t\t}\n  \t},\n  \tgetRightmostCoordinate: function getRightmostCoordinate() {\n  \t\treturn this._rightMostCoord;\n  \t},\n  \tcomputeNodeDepth: function computeNodeDepth(n) {\n  \t\tvar startEdge = null;\n  \t\tfor (var i = n.getEdges().iterator(); i.hasNext();) {\n  \t\t\tvar de = i.next();\n  \t\t\tif (de.isVisited() || de.getSym().isVisited()) {\n  \t\t\t\tstartEdge = de;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t}\n  \t\tif (startEdge === null) throw new TopologyException(\"unable to find edge to compute depths at \" + n.getCoordinate());\n  \t\tn.getEdges().computeDepths(startEdge);\n  \t\tfor (var i = n.getEdges().iterator(); i.hasNext();) {\n  \t\t\tvar de = i.next();\n  \t\t\tde.setVisited(true);\n  \t\t\tthis.copySymDepths(de);\n  \t\t}\n  \t},\n  \tcomputeDepth: function computeDepth(outsideDepth) {\n  \t\tthis.clearVisitedEdges();\n  \t\tvar de = this._finder.getEdge();\n  \t\tvar n = de.getNode();\n  \t\tvar label = de.getLabel();\n  \t\tde.setEdgeDepths(Position.RIGHT, outsideDepth);\n  \t\tthis.copySymDepths(de);\n  \t\tthis.computeDepths(de);\n  \t},\n  \tcreate: function create(node) {\n  \t\tthis.addReachable(node);\n  \t\tthis._finder.findEdge(this._dirEdgeList);\n  \t\tthis._rightMostCoord = this._finder.getCoordinate();\n  \t},\n  \tfindResultEdges: function findResultEdges() {\n  \t\tfor (var it = this._dirEdgeList.iterator(); it.hasNext();) {\n  \t\t\tvar de = it.next();\n  \t\t\tif (de.getDepth(Position.RIGHT) >= 1 && de.getDepth(Position.LEFT) <= 0 && !de.isInteriorAreaEdge()) {\n  \t\t\t\tde.setInResult(true);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcomputeDepths: function computeDepths(startEdge) {\n  \t\tvar nodesVisited = new HashSet();\n  \t\tvar nodeQueue = new LinkedList();\n  \t\tvar startNode = startEdge.getNode();\n  \t\tnodeQueue.addLast(startNode);\n  \t\tnodesVisited.add(startNode);\n  \t\tstartEdge.setVisited(true);\n  \t\twhile (!nodeQueue.isEmpty()) {\n  \t\t\tvar n = nodeQueue.removeFirst();\n  \t\t\tnodesVisited.add(n);\n  \t\t\tthis.computeNodeDepth(n);\n  \t\t\tfor (var i = n.getEdges().iterator(); i.hasNext();) {\n  \t\t\t\tvar de = i.next();\n  \t\t\t\tvar sym = de.getSym();\n  \t\t\t\tif (sym.isVisited()) continue;\n  \t\t\t\tvar adjNode = sym.getNode();\n  \t\t\t\tif (!nodesVisited.contains(adjNode)) {\n  \t\t\t\t\tnodeQueue.addLast(adjNode);\n  \t\t\t\t\tnodesVisited.add(adjNode);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcompareTo: function compareTo(o) {\n  \t\tvar graph = o;\n  \t\tif (this._rightMostCoord.x < graph._rightMostCoord.x) {\n  \t\t\treturn -1;\n  \t\t}\n  \t\tif (this._rightMostCoord.x > graph._rightMostCoord.x) {\n  \t\t\treturn 1;\n  \t\t}\n  \t\treturn 0;\n  \t},\n  \tgetEnvelope: function getEnvelope() {\n  \t\tif (this._env === null) {\n  \t\t\tvar edgeEnv = new Envelope();\n  \t\t\tfor (var it = this._dirEdgeList.iterator(); it.hasNext();) {\n  \t\t\t\tvar dirEdge = it.next();\n  \t\t\t\tvar pts = dirEdge.getEdge().getCoordinates();\n  \t\t\t\tfor (var i = 0; i < pts.length - 1; i++) {\n  \t\t\t\t\tedgeEnv.expandToInclude(pts[i]);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\tthis._env = edgeEnv;\n  \t\t}\n  \t\treturn this._env;\n  \t},\n  \taddReachable: function addReachable(startNode) {\n  \t\tvar nodeStack = new Stack$1();\n  \t\tnodeStack.add(startNode);\n  \t\twhile (!nodeStack.empty()) {\n  \t\t\tvar node = nodeStack.pop();\n  \t\t\tthis.add(node, nodeStack);\n  \t\t}\n  \t},\n  \tcopySymDepths: function copySymDepths(de) {\n  \t\tvar sym = de.getSym();\n  \t\tsym.setDepth(Position.LEFT, de.getDepth(Position.RIGHT));\n  \t\tsym.setDepth(Position.RIGHT, de.getDepth(Position.LEFT));\n  \t},\n  \tadd: function add(node, nodeStack) {\n  \t\tnode.setVisited(true);\n  \t\tthis._nodes.add(node);\n  \t\tfor (var i = node.getEdges().iterator(); i.hasNext();) {\n  \t\t\tvar de = i.next();\n  \t\t\tthis._dirEdgeList.add(de);\n  \t\t\tvar sym = de.getSym();\n  \t\t\tvar symNode = sym.getNode();\n  \t\t\tif (!symNode.isVisited()) nodeStack.push(symNode);\n  \t\t}\n  \t},\n  \tgetNodes: function getNodes() {\n  \t\treturn this._nodes;\n  \t},\n  \tgetDirectedEdges: function getDirectedEdges() {\n  \t\treturn this._dirEdgeList;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn BufferSubgraph;\n  \t}\n  });\n\n  function BufferInputLineSimplifier() {\n  \tthis._inputLine = null;\n  \tthis._distanceTol = null;\n  \tthis._isDeleted = null;\n  \tthis._angleOrientation = CGAlgorithms.COUNTERCLOCKWISE;\n  \tvar inputLine = arguments[0];\n  \tthis._inputLine = inputLine;\n  }\n  extend(BufferInputLineSimplifier.prototype, {\n  \tisDeletable: function isDeletable(i0, i1, i2, distanceTol) {\n  \t\tvar p0 = this._inputLine[i0];\n  \t\tvar p1 = this._inputLine[i1];\n  \t\tvar p2 = this._inputLine[i2];\n  \t\tif (!this.isConcave(p0, p1, p2)) return false;\n  \t\tif (!this.isShallow(p0, p1, p2, distanceTol)) return false;\n  \t\treturn this.isShallowSampled(p0, p1, i0, i2, distanceTol);\n  \t},\n  \tdeleteShallowConcavities: function deleteShallowConcavities() {\n  \t\tvar index = 1;\n  \t\tvar maxIndex = this._inputLine.length - 1;\n  \t\tvar midIndex = this.findNextNonDeletedIndex(index);\n  \t\tvar lastIndex = this.findNextNonDeletedIndex(midIndex);\n  \t\tvar isChanged = false;\n  \t\twhile (lastIndex < this._inputLine.length) {\n  \t\t\tvar isMiddleVertexDeleted = false;\n  \t\t\tif (this.isDeletable(index, midIndex, lastIndex, this._distanceTol)) {\n  \t\t\t\tthis._isDeleted[midIndex] = BufferInputLineSimplifier.DELETE;\n  \t\t\t\tisMiddleVertexDeleted = true;\n  \t\t\t\tisChanged = true;\n  \t\t\t}\n  \t\t\tif (isMiddleVertexDeleted) index = lastIndex;else index = midIndex;\n  \t\t\tmidIndex = this.findNextNonDeletedIndex(index);\n  \t\t\tlastIndex = this.findNextNonDeletedIndex(midIndex);\n  \t\t}\n  \t\treturn isChanged;\n  \t},\n  \tisShallowConcavity: function isShallowConcavity(p0, p1, p2, distanceTol) {\n  \t\tvar orientation = CGAlgorithms.computeOrientation(p0, p1, p2);\n  \t\tvar isAngleToSimplify = orientation === this._angleOrientation;\n  \t\tif (!isAngleToSimplify) return false;\n  \t\tvar dist = CGAlgorithms.distancePointLine(p1, p0, p2);\n  \t\treturn dist < distanceTol;\n  \t},\n  \tisShallowSampled: function isShallowSampled(p0, p2, i0, i2, distanceTol) {\n  \t\tvar inc = Math.trunc((i2 - i0) / BufferInputLineSimplifier.NUM_PTS_TO_CHECK);\n  \t\tif (inc <= 0) inc = 1;\n  \t\tfor (var i = i0; i < i2; i += inc) {\n  \t\t\tif (!this.isShallow(p0, p2, this._inputLine[i], distanceTol)) return false;\n  \t\t}\n  \t\treturn true;\n  \t},\n  \tisConcave: function isConcave(p0, p1, p2) {\n  \t\tvar orientation = CGAlgorithms.computeOrientation(p0, p1, p2);\n  \t\tvar isConcave = orientation === this._angleOrientation;\n  \t\treturn isConcave;\n  \t},\n  \tsimplify: function simplify(distanceTol) {\n  \t\tthis._distanceTol = Math.abs(distanceTol);\n  \t\tif (distanceTol < 0) this._angleOrientation = CGAlgorithms.CLOCKWISE;\n  \t\tthis._isDeleted = new Array(this._inputLine.length).fill(null);\n  \t\tvar isChanged = false;\n  \t\tdo {\n  \t\t\tisChanged = this.deleteShallowConcavities();\n  \t\t} while (isChanged);\n  \t\treturn this.collapseLine();\n  \t},\n  \tfindNextNonDeletedIndex: function findNextNonDeletedIndex(index) {\n  \t\tvar next = index + 1;\n  \t\twhile (next < this._inputLine.length && this._isDeleted[next] === BufferInputLineSimplifier.DELETE) {\n  \t\t\tnext++;\n  \t\t}return next;\n  \t},\n  \tisShallow: function isShallow(p0, p1, p2, distanceTol) {\n  \t\tvar dist = CGAlgorithms.distancePointLine(p1, p0, p2);\n  \t\treturn dist < distanceTol;\n  \t},\n  \tcollapseLine: function collapseLine() {\n  \t\tvar coordList = new CoordinateList();\n  \t\tfor (var i = 0; i < this._inputLine.length; i++) {\n  \t\t\tif (this._isDeleted[i] !== BufferInputLineSimplifier.DELETE) coordList.add(this._inputLine[i]);\n  \t\t}\n  \t\treturn coordList.toCoordinateArray();\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn BufferInputLineSimplifier;\n  \t}\n  });\n  BufferInputLineSimplifier.simplify = function (inputLine, distanceTol) {\n  \tvar simp = new BufferInputLineSimplifier(inputLine);\n  \treturn simp.simplify(distanceTol);\n  };\n  BufferInputLineSimplifier.INIT = 0;\n  BufferInputLineSimplifier.DELETE = 1;\n  BufferInputLineSimplifier.KEEP = 1;\n  BufferInputLineSimplifier.NUM_PTS_TO_CHECK = 10;\n\n  function OffsetSegmentString() {\n  \tthis._ptList = null;\n  \tthis._precisionModel = null;\n  \tthis._minimimVertexDistance = 0.0;\n  \tthis._ptList = new ArrayList();\n  }\n  extend(OffsetSegmentString.prototype, {\n  \tgetCoordinates: function getCoordinates() {\n  \t\tvar coord = this._ptList.toArray(OffsetSegmentString.COORDINATE_ARRAY_TYPE);\n  \t\treturn coord;\n  \t},\n  \tsetPrecisionModel: function setPrecisionModel(precisionModel) {\n  \t\tthis._precisionModel = precisionModel;\n  \t},\n  \taddPt: function addPt(pt) {\n  \t\tvar bufPt = new Coordinate(pt);\n  \t\tthis._precisionModel.makePrecise(bufPt);\n  \t\tif (this.isRedundant(bufPt)) return null;\n  \t\tthis._ptList.add(bufPt);\n  \t},\n  \treverse: function reverse() {},\n  \taddPts: function addPts(pt, isForward) {\n  \t\tif (isForward) {\n  \t\t\tfor (var i = 0; i < pt.length; i++) {\n  \t\t\t\tthis.addPt(pt[i]);\n  \t\t\t}\n  \t\t} else {\n  \t\t\tfor (var i = pt.length - 1; i >= 0; i--) {\n  \t\t\t\tthis.addPt(pt[i]);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tisRedundant: function isRedundant(pt) {\n  \t\tif (this._ptList.size() < 1) return false;\n  \t\tvar lastPt = this._ptList.get(this._ptList.size() - 1);\n  \t\tvar ptDist = pt.distance(lastPt);\n  \t\tif (ptDist < this._minimimVertexDistance) return true;\n  \t\treturn false;\n  \t},\n  \ttoString: function toString() {\n  \t\tvar fact = new GeometryFactory();\n  \t\tvar line = fact.createLineString(this.getCoordinates());\n  \t\treturn line.toString();\n  \t},\n  \tcloseRing: function closeRing() {\n  \t\tif (this._ptList.size() < 1) return null;\n  \t\tvar startPt = new Coordinate(this._ptList.get(0));\n  \t\tvar lastPt = this._ptList.get(this._ptList.size() - 1);\n  \t\tvar last2Pt = null;\n  \t\tif (this._ptList.size() >= 2) last2Pt = this._ptList.get(this._ptList.size() - 2);\n  \t\tif (startPt.equals(lastPt)) return null;\n  \t\tthis._ptList.add(startPt);\n  \t},\n  \tsetMinimumVertexDistance: function setMinimumVertexDistance(minimimVertexDistance) {\n  \t\tthis._minimimVertexDistance = minimimVertexDistance;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn OffsetSegmentString;\n  \t}\n  });\n  OffsetSegmentString.COORDINATE_ARRAY_TYPE = new Array(0).fill(null);\n\n  function OffsetSegmentGenerator() {\n  \tthis._maxCurveSegmentError = 0.0;\n  \tthis._filletAngleQuantum = null;\n  \tthis._closingSegLengthFactor = 1;\n  \tthis._segList = null;\n  \tthis._distance = 0.0;\n  \tthis._precisionModel = null;\n  \tthis._bufParams = null;\n  \tthis._li = null;\n  \tthis._s0 = null;\n  \tthis._s1 = null;\n  \tthis._s2 = null;\n  \tthis._seg0 = new LineSegment();\n  \tthis._seg1 = new LineSegment();\n  \tthis._offset0 = new LineSegment();\n  \tthis._offset1 = new LineSegment();\n  \tthis._side = 0;\n  \tthis._hasNarrowConcaveAngle = false;\n  \tvar precisionModel = arguments[0],\n  \t    bufParams = arguments[1],\n  \t    distance = arguments[2];\n  \tthis._precisionModel = precisionModel;\n  \tthis._bufParams = bufParams;\n  \tthis._li = new RobustLineIntersector();\n  \tthis._filletAngleQuantum = Math.PI / 2.0 / bufParams.getQuadrantSegments();\n  \tif (bufParams.getQuadrantSegments() >= 8 && bufParams.getJoinStyle() === BufferParameters.JOIN_ROUND) this._closingSegLengthFactor = OffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR;\n  \tthis.init(distance);\n  }\n  extend(OffsetSegmentGenerator.prototype, {\n  \taddNextSegment: function addNextSegment(p, addStartPoint) {\n  \t\tthis._s0 = this._s1;\n  \t\tthis._s1 = this._s2;\n  \t\tthis._s2 = p;\n  \t\tthis._seg0.setCoordinates(this._s0, this._s1);\n  \t\tthis.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0);\n  \t\tthis._seg1.setCoordinates(this._s1, this._s2);\n  \t\tthis.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1);\n  \t\tif (this._s1.equals(this._s2)) return null;\n  \t\tvar orientation = CGAlgorithms.computeOrientation(this._s0, this._s1, this._s2);\n  \t\tvar outsideTurn = orientation === CGAlgorithms.CLOCKWISE && this._side === Position.LEFT || orientation === CGAlgorithms.COUNTERCLOCKWISE && this._side === Position.RIGHT;\n  \t\tif (orientation === 0) {\n  \t\t\tthis.addCollinear(addStartPoint);\n  \t\t} else if (outsideTurn) {\n  \t\t\tthis.addOutsideTurn(orientation, addStartPoint);\n  \t\t} else {\n  \t\t\tthis.addInsideTurn(orientation, addStartPoint);\n  \t\t}\n  \t},\n  \taddLineEndCap: function addLineEndCap(p0, p1) {\n  \t\tvar seg = new LineSegment(p0, p1);\n  \t\tvar offsetL = new LineSegment();\n  \t\tthis.computeOffsetSegment(seg, Position.LEFT, this._distance, offsetL);\n  \t\tvar offsetR = new LineSegment();\n  \t\tthis.computeOffsetSegment(seg, Position.RIGHT, this._distance, offsetR);\n  \t\tvar dx = p1.x - p0.x;\n  \t\tvar dy = p1.y - p0.y;\n  \t\tvar angle = Math.atan2(dy, dx);\n  \t\tswitch (this._bufParams.getEndCapStyle()) {\n  \t\t\tcase BufferParameters.CAP_ROUND:\n  \t\t\t\tthis._segList.addPt(offsetL.p1);\n  \t\t\t\tthis.addFilletArc(p1, angle + Math.PI / 2, angle - Math.PI / 2, CGAlgorithms.CLOCKWISE, this._distance);\n  \t\t\t\tthis._segList.addPt(offsetR.p1);\n  \t\t\t\tbreak;\n  \t\t\tcase BufferParameters.CAP_FLAT:\n  \t\t\t\tthis._segList.addPt(offsetL.p1);\n  \t\t\t\tthis._segList.addPt(offsetR.p1);\n  \t\t\t\tbreak;\n  \t\t\tcase BufferParameters.CAP_SQUARE:\n  \t\t\t\tvar squareCapSideOffset = new Coordinate();\n  \t\t\t\tsquareCapSideOffset.x = Math.abs(this._distance) * Math.cos(angle);\n  \t\t\t\tsquareCapSideOffset.y = Math.abs(this._distance) * Math.sin(angle);\n  \t\t\t\tvar squareCapLOffset = new Coordinate(offsetL.p1.x + squareCapSideOffset.x, offsetL.p1.y + squareCapSideOffset.y);\n  \t\t\t\tvar squareCapROffset = new Coordinate(offsetR.p1.x + squareCapSideOffset.x, offsetR.p1.y + squareCapSideOffset.y);\n  \t\t\t\tthis._segList.addPt(squareCapLOffset);\n  \t\t\t\tthis._segList.addPt(squareCapROffset);\n  \t\t\t\tbreak;\n  \t\t}\n  \t},\n  \tgetCoordinates: function getCoordinates() {\n  \t\tvar pts = this._segList.getCoordinates();\n  \t\treturn pts;\n  \t},\n  \taddMitreJoin: function addMitreJoin(p, offset0, offset1, distance) {\n  \t\tvar isMitreWithinLimit = true;\n  \t\tvar intPt = null;\n  \t\ttry {\n  \t\t\tintPt = HCoordinate.intersection(offset0.p0, offset0.p1, offset1.p0, offset1.p1);\n  \t\t\tvar mitreRatio = distance <= 0.0 ? 1.0 : intPt.distance(p) / Math.abs(distance);\n  \t\t\tif (mitreRatio > this._bufParams.getMitreLimit()) isMitreWithinLimit = false;\n  \t\t} catch (ex) {\n  \t\t\tif (ex instanceof NotRepresentableException) {\n  \t\t\t\tintPt = new Coordinate(0, 0);\n  \t\t\t\tisMitreWithinLimit = false;\n  \t\t\t} else throw ex;\n  \t\t} finally {}\n  \t\tif (isMitreWithinLimit) {\n  \t\t\tthis._segList.addPt(intPt);\n  \t\t} else {\n  \t\t\tthis.addLimitedMitreJoin(offset0, offset1, distance, this._bufParams.getMitreLimit());\n  \t\t}\n  \t},\n  \taddFilletCorner: function addFilletCorner(p, p0, p1, direction, radius) {\n  \t\tvar dx0 = p0.x - p.x;\n  \t\tvar dy0 = p0.y - p.y;\n  \t\tvar startAngle = Math.atan2(dy0, dx0);\n  \t\tvar dx1 = p1.x - p.x;\n  \t\tvar dy1 = p1.y - p.y;\n  \t\tvar endAngle = Math.atan2(dy1, dx1);\n  \t\tif (direction === CGAlgorithms.CLOCKWISE) {\n  \t\t\tif (startAngle <= endAngle) startAngle += 2.0 * Math.PI;\n  \t\t} else {\n  \t\t\tif (startAngle >= endAngle) startAngle -= 2.0 * Math.PI;\n  \t\t}\n  \t\tthis._segList.addPt(p0);\n  \t\tthis.addFilletArc(p, startAngle, endAngle, direction, radius);\n  \t\tthis._segList.addPt(p1);\n  \t},\n  \taddOutsideTurn: function addOutsideTurn(orientation, addStartPoint) {\n  \t\tif (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR) {\n  \t\t\tthis._segList.addPt(this._offset0.p1);\n  \t\t\treturn null;\n  \t\t}\n  \t\tif (this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {\n  \t\t\tthis.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance);\n  \t\t} else if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL) {\n  \t\t\tthis.addBevelJoin(this._offset0, this._offset1);\n  \t\t} else {\n  \t\t\tif (addStartPoint) this._segList.addPt(this._offset0.p1);\n  \t\t\tthis.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, orientation, this._distance);\n  \t\t\tthis._segList.addPt(this._offset1.p0);\n  \t\t}\n  \t},\n  \tcreateSquare: function createSquare(p) {\n  \t\tthis._segList.addPt(new Coordinate(p.x + this._distance, p.y + this._distance));\n  \t\tthis._segList.addPt(new Coordinate(p.x + this._distance, p.y - this._distance));\n  \t\tthis._segList.addPt(new Coordinate(p.x - this._distance, p.y - this._distance));\n  \t\tthis._segList.addPt(new Coordinate(p.x - this._distance, p.y + this._distance));\n  \t\tthis._segList.closeRing();\n  \t},\n  \taddSegments: function addSegments(pt, isForward) {\n  \t\tthis._segList.addPts(pt, isForward);\n  \t},\n  \taddFirstSegment: function addFirstSegment() {\n  \t\tthis._segList.addPt(this._offset1.p0);\n  \t},\n  \taddLastSegment: function addLastSegment() {\n  \t\tthis._segList.addPt(this._offset1.p1);\n  \t},\n  \tinitSideSegments: function initSideSegments(s1, s2, side) {\n  \t\tthis._s1 = s1;\n  \t\tthis._s2 = s2;\n  \t\tthis._side = side;\n  \t\tthis._seg1.setCoordinates(s1, s2);\n  \t\tthis.computeOffsetSegment(this._seg1, side, this._distance, this._offset1);\n  \t},\n  \taddLimitedMitreJoin: function addLimitedMitreJoin(offset0, offset1, distance, mitreLimit) {\n  \t\tvar basePt = this._seg0.p1;\n  \t\tvar ang0 = Angle.angle(basePt, this._seg0.p0);\n  \t\tvar ang1 = Angle.angle(basePt, this._seg1.p1);\n  \t\tvar angDiff = Angle.angleBetweenOriented(this._seg0.p0, basePt, this._seg1.p1);\n  \t\tvar angDiffHalf = angDiff / 2;\n  \t\tvar midAng = Angle.normalize(ang0 + angDiffHalf);\n  \t\tvar mitreMidAng = Angle.normalize(midAng + Math.PI);\n  \t\tvar mitreDist = mitreLimit * distance;\n  \t\tvar bevelDelta = mitreDist * Math.abs(Math.sin(angDiffHalf));\n  \t\tvar bevelHalfLen = distance - bevelDelta;\n  \t\tvar bevelMidX = basePt.x + mitreDist * Math.cos(mitreMidAng);\n  \t\tvar bevelMidY = basePt.y + mitreDist * Math.sin(mitreMidAng);\n  \t\tvar bevelMidPt = new Coordinate(bevelMidX, bevelMidY);\n  \t\tvar mitreMidLine = new LineSegment(basePt, bevelMidPt);\n  \t\tvar bevelEndLeft = mitreMidLine.pointAlongOffset(1.0, bevelHalfLen);\n  \t\tvar bevelEndRight = mitreMidLine.pointAlongOffset(1.0, -bevelHalfLen);\n  \t\tif (this._side === Position.LEFT) {\n  \t\t\tthis._segList.addPt(bevelEndLeft);\n  \t\t\tthis._segList.addPt(bevelEndRight);\n  \t\t} else {\n  \t\t\tthis._segList.addPt(bevelEndRight);\n  \t\t\tthis._segList.addPt(bevelEndLeft);\n  \t\t}\n  \t},\n  \tcomputeOffsetSegment: function computeOffsetSegment(seg, side, distance, offset) {\n  \t\tvar sideSign = side === Position.LEFT ? 1 : -1;\n  \t\tvar dx = seg.p1.x - seg.p0.x;\n  \t\tvar dy = seg.p1.y - seg.p0.y;\n  \t\tvar len = Math.sqrt(dx * dx + dy * dy);\n  \t\tvar ux = sideSign * distance * dx / len;\n  \t\tvar uy = sideSign * distance * dy / len;\n  \t\toffset.p0.x = seg.p0.x - uy;\n  \t\toffset.p0.y = seg.p0.y + ux;\n  \t\toffset.p1.x = seg.p1.x - uy;\n  \t\toffset.p1.y = seg.p1.y + ux;\n  \t},\n  \taddFilletArc: function addFilletArc(p, startAngle, endAngle, direction, radius) {\n  \t\tvar directionFactor = direction === CGAlgorithms.CLOCKWISE ? -1 : 1;\n  \t\tvar totalAngle = Math.abs(startAngle - endAngle);\n  \t\tvar nSegs = Math.trunc(totalAngle / this._filletAngleQuantum + 0.5);\n  \t\tif (nSegs < 1) return null;\n  \t\tvar initAngle = null,\n  \t\t    currAngleInc = null;\n  \t\tinitAngle = 0.0;\n  \t\tcurrAngleInc = totalAngle / nSegs;\n  \t\tvar currAngle = initAngle;\n  \t\tvar pt = new Coordinate();\n  \t\twhile (currAngle < totalAngle) {\n  \t\t\tvar angle = startAngle + directionFactor * currAngle;\n  \t\t\tpt.x = p.x + radius * Math.cos(angle);\n  \t\t\tpt.y = p.y + radius * Math.sin(angle);\n  \t\t\tthis._segList.addPt(pt);\n  \t\t\tcurrAngle += currAngleInc;\n  \t\t}\n  \t},\n  \taddInsideTurn: function addInsideTurn(orientation, addStartPoint) {\n  \t\tthis._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1);\n  \t\tif (this._li.hasIntersection()) {\n  \t\t\tthis._segList.addPt(this._li.getIntersection(0));\n  \t\t} else {\n  \t\t\tthis._hasNarrowConcaveAngle = true;\n  \t\t\tif (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) {\n  \t\t\t\tthis._segList.addPt(this._offset0.p1);\n  \t\t\t} else {\n  \t\t\t\tthis._segList.addPt(this._offset0.p1);\n  \t\t\t\tif (this._closingSegLengthFactor > 0) {\n  \t\t\t\t\tvar mid0 = new Coordinate((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));\n  \t\t\t\t\tthis._segList.addPt(mid0);\n  \t\t\t\t\tvar mid1 = new Coordinate((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));\n  \t\t\t\t\tthis._segList.addPt(mid1);\n  \t\t\t\t} else {\n  \t\t\t\t\tthis._segList.addPt(this._s1);\n  \t\t\t\t}\n  \t\t\t\tthis._segList.addPt(this._offset1.p0);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcreateCircle: function createCircle(p) {\n  \t\tvar pt = new Coordinate(p.x + this._distance, p.y);\n  \t\tthis._segList.addPt(pt);\n  \t\tthis.addFilletArc(p, 0.0, 2.0 * Math.PI, -1, this._distance);\n  \t\tthis._segList.closeRing();\n  \t},\n  \taddBevelJoin: function addBevelJoin(offset0, offset1) {\n  \t\tthis._segList.addPt(offset0.p1);\n  \t\tthis._segList.addPt(offset1.p0);\n  \t},\n  \tinit: function init(distance) {\n  \t\tthis._distance = distance;\n  \t\tthis._maxCurveSegmentError = distance * (1 - Math.cos(this._filletAngleQuantum / 2.0));\n  \t\tthis._segList = new OffsetSegmentString();\n  \t\tthis._segList.setPrecisionModel(this._precisionModel);\n  \t\tthis._segList.setMinimumVertexDistance(distance * OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);\n  \t},\n  \taddCollinear: function addCollinear(addStartPoint) {\n  \t\tthis._li.computeIntersection(this._s0, this._s1, this._s1, this._s2);\n  \t\tvar numInt = this._li.getIntersectionNum();\n  \t\tif (numInt >= 2) {\n  \t\t\tif (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL || this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {\n  \t\t\t\tif (addStartPoint) this._segList.addPt(this._offset0.p1);\n  \t\t\t\tthis._segList.addPt(this._offset1.p0);\n  \t\t\t} else {\n  \t\t\t\tthis.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, CGAlgorithms.CLOCKWISE, this._distance);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcloseRing: function closeRing() {\n  \t\tthis._segList.closeRing();\n  \t},\n  \thasNarrowConcaveAngle: function hasNarrowConcaveAngle() {\n  \t\treturn this._hasNarrowConcaveAngle;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn OffsetSegmentGenerator;\n  \t}\n  });\n  OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR = 1.0E-3;\n  OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = 1.0E-3;\n  OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1.0E-6;\n  OffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR = 80;\n\n  function OffsetCurveBuilder() {\n  \tthis._distance = 0.0;\n  \tthis._precisionModel = null;\n  \tthis._bufParams = null;\n  \tvar precisionModel = arguments[0],\n  \t    bufParams = arguments[1];\n  \tthis._precisionModel = precisionModel;\n  \tthis._bufParams = bufParams;\n  }\n  extend(OffsetCurveBuilder.prototype, {\n  \tgetOffsetCurve: function getOffsetCurve(inputPts, distance) {\n  \t\tthis._distance = distance;\n  \t\tif (distance === 0.0) return null;\n  \t\tvar isRightSide = distance < 0.0;\n  \t\tvar posDistance = Math.abs(distance);\n  \t\tvar segGen = this.getSegGen(posDistance);\n  \t\tif (inputPts.length <= 1) {\n  \t\t\tthis.computePointCurve(inputPts[0], segGen);\n  \t\t} else {\n  \t\t\tthis.computeOffsetCurve(inputPts, isRightSide, segGen);\n  \t\t}\n  \t\tvar curvePts = segGen.getCoordinates();\n  \t\tif (isRightSide) CoordinateArrays.reverse(curvePts);\n  \t\treturn curvePts;\n  \t},\n  \tcomputeSingleSidedBufferCurve: function computeSingleSidedBufferCurve(inputPts, isRightSide, segGen) {\n  \t\tvar distTol = this.simplifyTolerance(this._distance);\n  \t\tif (isRightSide) {\n  \t\t\tsegGen.addSegments(inputPts, true);\n  \t\t\tvar simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);\n  \t\t\tvar n2 = simp2.length - 1;\n  \t\t\tsegGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);\n  \t\t\tsegGen.addFirstSegment();\n  \t\t\tfor (var i = n2 - 2; i >= 0; i--) {\n  \t\t\t\tsegGen.addNextSegment(simp2[i], true);\n  \t\t\t}\n  \t\t} else {\n  \t\t\tsegGen.addSegments(inputPts, false);\n  \t\t\tvar simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);\n  \t\t\tvar n1 = simp1.length - 1;\n  \t\t\tsegGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);\n  \t\t\tsegGen.addFirstSegment();\n  \t\t\tfor (var i = 2; i <= n1; i++) {\n  \t\t\t\tsegGen.addNextSegment(simp1[i], true);\n  \t\t\t}\n  \t\t}\n  \t\tsegGen.addLastSegment();\n  \t\tsegGen.closeRing();\n  \t},\n  \tcomputeRingBufferCurve: function computeRingBufferCurve(inputPts, side, segGen) {\n  \t\tvar distTol = this.simplifyTolerance(this._distance);\n  \t\tif (side === Position.RIGHT) distTol = -distTol;\n  \t\tvar simp = BufferInputLineSimplifier.simplify(inputPts, distTol);\n  \t\tvar n = simp.length - 1;\n  \t\tsegGen.initSideSegments(simp[n - 1], simp[0], side);\n  \t\tfor (var i = 1; i <= n; i++) {\n  \t\t\tvar addStartPoint = i !== 1;\n  \t\t\tsegGen.addNextSegment(simp[i], addStartPoint);\n  \t\t}\n  \t\tsegGen.closeRing();\n  \t},\n  \tcomputeLineBufferCurve: function computeLineBufferCurve(inputPts, segGen) {\n  \t\tvar distTol = this.simplifyTolerance(this._distance);\n  \t\tvar simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);\n  \t\tvar n1 = simp1.length - 1;\n  \t\tsegGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);\n  \t\tfor (var i = 2; i <= n1; i++) {\n  \t\t\tsegGen.addNextSegment(simp1[i], true);\n  \t\t}\n  \t\tsegGen.addLastSegment();\n  \t\tsegGen.addLineEndCap(simp1[n1 - 1], simp1[n1]);\n  \t\tvar simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);\n  \t\tvar n2 = simp2.length - 1;\n  \t\tsegGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);\n  \t\tfor (var i = n2 - 2; i >= 0; i--) {\n  \t\t\tsegGen.addNextSegment(simp2[i], true);\n  \t\t}\n  \t\tsegGen.addLastSegment();\n  \t\tsegGen.addLineEndCap(simp2[1], simp2[0]);\n  \t\tsegGen.closeRing();\n  \t},\n  \tcomputePointCurve: function computePointCurve(pt, segGen) {\n  \t\tswitch (this._bufParams.getEndCapStyle()) {\n  \t\t\tcase BufferParameters.CAP_ROUND:\n  \t\t\t\tsegGen.createCircle(pt);\n  \t\t\t\tbreak;\n  \t\t\tcase BufferParameters.CAP_SQUARE:\n  \t\t\t\tsegGen.createSquare(pt);\n  \t\t\t\tbreak;\n  \t\t}\n  \t},\n  \tgetLineCurve: function getLineCurve(inputPts, distance) {\n  \t\tthis._distance = distance;\n  \t\tif (distance < 0.0 && !this._bufParams.isSingleSided()) return null;\n  \t\tif (distance === 0.0) return null;\n  \t\tvar posDistance = Math.abs(distance);\n  \t\tvar segGen = this.getSegGen(posDistance);\n  \t\tif (inputPts.length <= 1) {\n  \t\t\tthis.computePointCurve(inputPts[0], segGen);\n  \t\t} else {\n  \t\t\tif (this._bufParams.isSingleSided()) {\n  \t\t\t\tvar isRightSide = distance < 0.0;\n  \t\t\t\tthis.computeSingleSidedBufferCurve(inputPts, isRightSide, segGen);\n  \t\t\t} else this.computeLineBufferCurve(inputPts, segGen);\n  \t\t}\n  \t\tvar lineCoord = segGen.getCoordinates();\n  \t\treturn lineCoord;\n  \t},\n  \tgetBufferParameters: function getBufferParameters() {\n  \t\treturn this._bufParams;\n  \t},\n  \tsimplifyTolerance: function simplifyTolerance(bufDistance) {\n  \t\treturn bufDistance * this._bufParams.getSimplifyFactor();\n  \t},\n  \tgetRingCurve: function getRingCurve(inputPts, side, distance) {\n  \t\tthis._distance = distance;\n  \t\tif (inputPts.length <= 2) return this.getLineCurve(inputPts, distance);\n  \t\tif (distance === 0.0) {\n  \t\t\treturn OffsetCurveBuilder.copyCoordinates(inputPts);\n  \t\t}\n  \t\tvar segGen = this.getSegGen(distance);\n  \t\tthis.computeRingBufferCurve(inputPts, side, segGen);\n  \t\treturn segGen.getCoordinates();\n  \t},\n  \tcomputeOffsetCurve: function computeOffsetCurve(inputPts, isRightSide, segGen) {\n  \t\tvar distTol = this.simplifyTolerance(this._distance);\n  \t\tif (isRightSide) {\n  \t\t\tvar simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);\n  \t\t\tvar n2 = simp2.length - 1;\n  \t\t\tsegGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);\n  \t\t\tsegGen.addFirstSegment();\n  \t\t\tfor (var i = n2 - 2; i >= 0; i--) {\n  \t\t\t\tsegGen.addNextSegment(simp2[i], true);\n  \t\t\t}\n  \t\t} else {\n  \t\t\tvar simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);\n  \t\t\tvar n1 = simp1.length - 1;\n  \t\t\tsegGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);\n  \t\t\tsegGen.addFirstSegment();\n  \t\t\tfor (var i = 2; i <= n1; i++) {\n  \t\t\t\tsegGen.addNextSegment(simp1[i], true);\n  \t\t\t}\n  \t\t}\n  \t\tsegGen.addLastSegment();\n  \t},\n  \tgetSegGen: function getSegGen(distance) {\n  \t\treturn new OffsetSegmentGenerator(this._precisionModel, this._bufParams, distance);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn OffsetCurveBuilder;\n  \t}\n  });\n  OffsetCurveBuilder.copyCoordinates = function (pts) {\n  \tvar copy = new Array(pts.length).fill(null);\n  \tfor (var i = 0; i < copy.length; i++) {\n  \t\tcopy[i] = new Coordinate(pts[i]);\n  \t}\n  \treturn copy;\n  };\n\n  function SubgraphDepthLocater() {\n  \tthis._subgraphs = null;\n  \tthis._seg = new LineSegment();\n  \tthis._cga = new CGAlgorithms();\n  \tvar subgraphs = arguments[0];\n  \tthis._subgraphs = subgraphs;\n  }\n  extend(SubgraphDepthLocater.prototype, {\n  \tfindStabbedSegments: function findStabbedSegments() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar stabbingRayLeftPt = arguments[0];\n  \t\t\tvar stabbedSegments = new ArrayList();\n  \t\t\tfor (var i = this._subgraphs.iterator(); i.hasNext();) {\n  \t\t\t\tvar bsg = i.next();\n  \t\t\t\tvar env = bsg.getEnvelope();\n  \t\t\t\tif (stabbingRayLeftPt.y < env.getMinY() || stabbingRayLeftPt.y > env.getMaxY()) continue;\n  \t\t\t\tthis.findStabbedSegments(stabbingRayLeftPt, bsg.getDirectedEdges(), stabbedSegments);\n  \t\t\t}\n  \t\t\treturn stabbedSegments;\n  \t\t} else if (arguments.length === 3) {\n  \t\t\tif (hasInterface(arguments[2], List) && arguments[0] instanceof Coordinate && arguments[1] instanceof DirectedEdge) {\n  \t\t\t\tvar stabbingRayLeftPt = arguments[0],\n  \t\t\t\t    dirEdge = arguments[1],\n  \t\t\t\t    stabbedSegments = arguments[2];\n  \t\t\t\tvar pts = dirEdge.getEdge().getCoordinates();\n  \t\t\t\tfor (var i = 0; i < pts.length - 1; i++) {\n  \t\t\t\t\tthis._seg.p0 = pts[i];\n  \t\t\t\t\tthis._seg.p1 = pts[i + 1];\n  \t\t\t\t\tif (this._seg.p0.y > this._seg.p1.y) this._seg.reverse();\n  \t\t\t\t\tvar maxx = Math.max(this._seg.p0.x, this._seg.p1.x);\n  \t\t\t\t\tif (maxx < stabbingRayLeftPt.x) continue;\n  \t\t\t\t\tif (this._seg.isHorizontal()) continue;\n  \t\t\t\t\tif (stabbingRayLeftPt.y < this._seg.p0.y || stabbingRayLeftPt.y > this._seg.p1.y) continue;\n  \t\t\t\t\tif (CGAlgorithms.computeOrientation(this._seg.p0, this._seg.p1, stabbingRayLeftPt) === CGAlgorithms.RIGHT) continue;\n  \t\t\t\t\tvar depth = dirEdge.getDepth(Position.LEFT);\n  \t\t\t\t\tif (!this._seg.p0.equals(pts[i])) depth = dirEdge.getDepth(Position.RIGHT);\n  \t\t\t\t\tvar ds = new DepthSegment(this._seg, depth);\n  \t\t\t\t\tstabbedSegments.add(ds);\n  \t\t\t\t}\n  \t\t\t} else if (hasInterface(arguments[2], List) && arguments[0] instanceof Coordinate && hasInterface(arguments[1], List)) {\n  \t\t\t\tvar stabbingRayLeftPt = arguments[0],\n  \t\t\t\t    dirEdges = arguments[1],\n  \t\t\t\t    stabbedSegments = arguments[2];\n  \t\t\t\tfor (var i = dirEdges.iterator(); i.hasNext();) {\n  \t\t\t\t\tvar de = i.next();\n  \t\t\t\t\tif (!de.isForward()) continue;\n  \t\t\t\t\tthis.findStabbedSegments(stabbingRayLeftPt, de, stabbedSegments);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetDepth: function getDepth(p) {\n  \t\tvar stabbedSegments = this.findStabbedSegments(p);\n  \t\tif (stabbedSegments.size() === 0) return 0;\n  \t\tvar ds = Collections.min(stabbedSegments);\n  \t\treturn ds._leftDepth;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SubgraphDepthLocater;\n  \t}\n  });\n  function DepthSegment() {\n  \tthis._upwardSeg = null;\n  \tthis._leftDepth = null;\n  \tvar seg = arguments[0],\n  \t    depth = arguments[1];\n  \tthis._upwardSeg = new LineSegment(seg);\n  \tthis._leftDepth = depth;\n  }\n  extend(DepthSegment.prototype, {\n  \tcompareTo: function compareTo(obj) {\n  \t\tvar other = obj;\n  \t\tif (this._upwardSeg.minX() >= other._upwardSeg.maxX()) return 1;\n  \t\tif (this._upwardSeg.maxX() <= other._upwardSeg.minX()) return -1;\n  \t\tvar orientIndex = this._upwardSeg.orientationIndex(other._upwardSeg);\n  \t\tif (orientIndex !== 0) return orientIndex;\n  \t\torientIndex = -1 * other._upwardSeg.orientationIndex(this._upwardSeg);\n  \t\tif (orientIndex !== 0) return orientIndex;\n  \t\treturn this._upwardSeg.compareTo(other._upwardSeg);\n  \t},\n  \tcompareX: function compareX(seg0, seg1) {\n  \t\tvar compare0 = seg0.p0.compareTo(seg1.p0);\n  \t\tif (compare0 !== 0) return compare0;\n  \t\treturn seg0.p1.compareTo(seg1.p1);\n  \t},\n  \ttoString: function toString() {\n  \t\treturn this._upwardSeg.toString();\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn DepthSegment;\n  \t}\n  });\n  SubgraphDepthLocater.DepthSegment = DepthSegment;\n\n  function OffsetCurveSetBuilder() {\n  \tthis._inputGeom = null;\n  \tthis._distance = null;\n  \tthis._curveBuilder = null;\n  \tthis._curveList = new ArrayList();\n  \tvar inputGeom = arguments[0],\n  \t    distance = arguments[1],\n  \t    curveBuilder = arguments[2];\n  \tthis._inputGeom = inputGeom;\n  \tthis._distance = distance;\n  \tthis._curveBuilder = curveBuilder;\n  }\n  extend(OffsetCurveSetBuilder.prototype, {\n  \taddPoint: function addPoint(p) {\n  \t\tif (this._distance <= 0.0) return null;\n  \t\tvar coord = p.getCoordinates();\n  \t\tvar curve = this._curveBuilder.getLineCurve(coord, this._distance);\n  \t\tthis.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);\n  \t},\n  \taddPolygon: function addPolygon(p) {\n  \t\tvar offsetDistance = this._distance;\n  \t\tvar offsetSide = Position.LEFT;\n  \t\tif (this._distance < 0.0) {\n  \t\t\toffsetDistance = -this._distance;\n  \t\t\toffsetSide = Position.RIGHT;\n  \t\t}\n  \t\tvar shell = p.getExteriorRing();\n  \t\tvar shellCoord = CoordinateArrays.removeRepeatedPoints(shell.getCoordinates());\n  \t\tif (this._distance < 0.0 && this.isErodedCompletely(shell, this._distance)) return null;\n  \t\tif (this._distance <= 0.0 && shellCoord.length < 3) return null;\n  \t\tthis.addPolygonRing(shellCoord, offsetDistance, offsetSide, Location.EXTERIOR, Location.INTERIOR);\n  \t\tfor (var i = 0; i < p.getNumInteriorRing(); i++) {\n  \t\t\tvar hole = p.getInteriorRingN(i);\n  \t\t\tvar holeCoord = CoordinateArrays.removeRepeatedPoints(hole.getCoordinates());\n  \t\t\tif (this._distance > 0.0 && this.isErodedCompletely(hole, -this._distance)) continue;\n  \t\t\tthis.addPolygonRing(holeCoord, offsetDistance, Position.opposite(offsetSide), Location.INTERIOR, Location.EXTERIOR);\n  \t\t}\n  \t},\n  \tisTriangleErodedCompletely: function isTriangleErodedCompletely(triangleCoord, bufferDistance) {\n  \t\tvar tri = new Triangle$1(triangleCoord[0], triangleCoord[1], triangleCoord[2]);\n  \t\tvar inCentre = tri.inCentre();\n  \t\tvar distToCentre = CGAlgorithms.distancePointLine(inCentre, tri.p0, tri.p1);\n  \t\treturn distToCentre < Math.abs(bufferDistance);\n  \t},\n  \taddLineString: function addLineString(line) {\n  \t\tif (this._distance <= 0.0 && !this._curveBuilder.getBufferParameters().isSingleSided()) return null;\n  \t\tvar coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());\n  \t\tvar curve = this._curveBuilder.getLineCurve(coord, this._distance);\n  \t\tthis.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);\n  \t},\n  \taddCurve: function addCurve(coord, leftLoc, rightLoc) {\n  \t\tif (coord === null || coord.length < 2) return null;\n  \t\tvar e = new NodedSegmentString(coord, new Label(0, Location.BOUNDARY, leftLoc, rightLoc));\n  \t\tthis._curveList.add(e);\n  \t},\n  \tgetCurves: function getCurves() {\n  \t\tthis.add(this._inputGeom);\n  \t\treturn this._curveList;\n  \t},\n  \taddPolygonRing: function addPolygonRing(coord, offsetDistance, side, cwLeftLoc, cwRightLoc) {\n  \t\tif (offsetDistance === 0.0 && coord.length < LinearRing.MINIMUM_VALID_SIZE) return null;\n  \t\tvar leftLoc = cwLeftLoc;\n  \t\tvar rightLoc = cwRightLoc;\n  \t\tif (coord.length >= LinearRing.MINIMUM_VALID_SIZE && CGAlgorithms.isCCW(coord)) {\n  \t\t\tleftLoc = cwRightLoc;\n  \t\t\trightLoc = cwLeftLoc;\n  \t\t\tside = Position.opposite(side);\n  \t\t}\n  \t\tvar curve = this._curveBuilder.getRingCurve(coord, side, offsetDistance);\n  \t\tthis.addCurve(curve, leftLoc, rightLoc);\n  \t},\n  \tadd: function add(g) {\n  \t\tif (g.isEmpty()) return null;\n  \t\tif (g instanceof Polygon) this.addPolygon(g);else if (g instanceof LineString) this.addLineString(g);else if (g instanceof Point) this.addPoint(g);else if (g instanceof MultiPoint) this.addCollection(g);else if (g instanceof MultiLineString) this.addCollection(g);else if (g instanceof MultiPolygon) this.addCollection(g);else if (g instanceof GeometryCollection) this.addCollection(g);else throw new UnsupportedOperationException(g.getClass().getName());\n  \t},\n  \tisErodedCompletely: function isErodedCompletely(ring, bufferDistance) {\n  \t\tvar ringCoord = ring.getCoordinates();\n  \t\tif (ringCoord.length < 4) return bufferDistance < 0;\n  \t\tif (ringCoord.length === 4) return this.isTriangleErodedCompletely(ringCoord, bufferDistance);\n  \t\tvar env = ring.getEnvelopeInternal();\n  \t\tvar envMinDimension = Math.min(env.getHeight(), env.getWidth());\n  \t\tif (bufferDistance < 0.0 && 2 * Math.abs(bufferDistance) > envMinDimension) return true;\n  \t\treturn false;\n  \t},\n  \taddCollection: function addCollection(gc) {\n  \t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n  \t\t\tvar g = gc.getGeometryN(i);\n  \t\t\tthis.add(g);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn OffsetCurveSetBuilder;\n  \t}\n  });\n\n  function IntersectionAdder() {\n  \tthis._hasIntersection = false;\n  \tthis._hasProper = false;\n  \tthis._hasProperInterior = false;\n  \tthis._hasInterior = false;\n  \tthis._properIntersectionPoint = null;\n  \tthis._li = null;\n  \tthis._isSelfIntersection = null;\n  \tthis.numIntersections = 0;\n  \tthis.numInteriorIntersections = 0;\n  \tthis.numProperIntersections = 0;\n  \tthis.numTests = 0;\n  \tvar li = arguments[0];\n  \tthis._li = li;\n  }\n  extend(IntersectionAdder.prototype, {\n  \tisTrivialIntersection: function isTrivialIntersection(e0, segIndex0, e1, segIndex1) {\n  \t\tif (e0 === e1) {\n  \t\t\tif (this._li.getIntersectionNum() === 1) {\n  \t\t\t\tif (IntersectionAdder.isAdjacentSegments(segIndex0, segIndex1)) return true;\n  \t\t\t\tif (e0.isClosed()) {\n  \t\t\t\t\tvar maxSegIndex = e0.size() - 1;\n  \t\t\t\t\tif (segIndex0 === 0 && segIndex1 === maxSegIndex || segIndex1 === 0 && segIndex0 === maxSegIndex) {\n  \t\t\t\t\t\treturn true;\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tgetProperIntersectionPoint: function getProperIntersectionPoint() {\n  \t\treturn this._properIntersectionPoint;\n  \t},\n  \thasProperInteriorIntersection: function hasProperInteriorIntersection() {\n  \t\treturn this._hasProperInterior;\n  \t},\n  \tgetLineIntersector: function getLineIntersector() {\n  \t\treturn this._li;\n  \t},\n  \thasProperIntersection: function hasProperIntersection() {\n  \t\treturn this._hasProper;\n  \t},\n  \tprocessIntersections: function processIntersections(e0, segIndex0, e1, segIndex1) {\n  \t\tif (e0 === e1 && segIndex0 === segIndex1) return null;\n  \t\tthis.numTests++;\n  \t\tvar p00 = e0.getCoordinates()[segIndex0];\n  \t\tvar p01 = e0.getCoordinates()[segIndex0 + 1];\n  \t\tvar p10 = e1.getCoordinates()[segIndex1];\n  \t\tvar p11 = e1.getCoordinates()[segIndex1 + 1];\n  \t\tthis._li.computeIntersection(p00, p01, p10, p11);\n  \t\tif (this._li.hasIntersection()) {\n  \t\t\tthis.numIntersections++;\n  \t\t\tif (this._li.isInteriorIntersection()) {\n  \t\t\t\tthis.numInteriorIntersections++;\n  \t\t\t\tthis._hasInterior = true;\n  \t\t\t}\n  \t\t\tif (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {\n  \t\t\t\tthis._hasIntersection = true;\n  \t\t\t\te0.addIntersections(this._li, segIndex0, 0);\n  \t\t\t\te1.addIntersections(this._li, segIndex1, 1);\n  \t\t\t\tif (this._li.isProper()) {\n  \t\t\t\t\tthis.numProperIntersections++;\n  \t\t\t\t\tthis._hasProper = true;\n  \t\t\t\t\tthis._hasProperInterior = true;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \thasIntersection: function hasIntersection() {\n  \t\treturn this._hasIntersection;\n  \t},\n  \tisDone: function isDone() {\n  \t\treturn false;\n  \t},\n  \thasInteriorIntersection: function hasInteriorIntersection() {\n  \t\treturn this._hasInterior;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [SegmentIntersector];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn IntersectionAdder;\n  \t}\n  });\n  IntersectionAdder.isAdjacentSegments = function (i1, i2) {\n  \treturn Math.abs(i1 - i2) === 1;\n  };\n\n  function BufferBuilder() {\n  \tthis._bufParams = null;\n  \tthis._workingPrecisionModel = null;\n  \tthis._workingNoder = null;\n  \tthis._geomFact = null;\n  \tthis._graph = null;\n  \tthis._edgeList = new EdgeList();\n  \tvar bufParams = arguments[0];\n  \tthis._bufParams = bufParams;\n  }\n  extend(BufferBuilder.prototype, {\n  \tsetWorkingPrecisionModel: function setWorkingPrecisionModel(pm) {\n  \t\tthis._workingPrecisionModel = pm;\n  \t},\n  \tinsertUniqueEdge: function insertUniqueEdge(e) {\n  \t\tvar existingEdge = this._edgeList.findEqualEdge(e);\n  \t\tif (existingEdge !== null) {\n  \t\t\tvar existingLabel = existingEdge.getLabel();\n  \t\t\tvar labelToMerge = e.getLabel();\n  \t\t\tif (!existingEdge.isPointwiseEqual(e)) {\n  \t\t\t\tlabelToMerge = new Label(e.getLabel());\n  \t\t\t\tlabelToMerge.flip();\n  \t\t\t}\n  \t\t\texistingLabel.merge(labelToMerge);\n  \t\t\tvar mergeDelta = BufferBuilder.depthDelta(labelToMerge);\n  \t\t\tvar existingDelta = existingEdge.getDepthDelta();\n  \t\t\tvar newDelta = existingDelta + mergeDelta;\n  \t\t\texistingEdge.setDepthDelta(newDelta);\n  \t\t} else {\n  \t\t\tthis._edgeList.add(e);\n  \t\t\te.setDepthDelta(BufferBuilder.depthDelta(e.getLabel()));\n  \t\t}\n  \t},\n  \tbuildSubgraphs: function buildSubgraphs(subgraphList, polyBuilder) {\n  \t\tvar processedGraphs = new ArrayList();\n  \t\tfor (var i = subgraphList.iterator(); i.hasNext();) {\n  \t\t\tvar subgraph = i.next();\n  \t\t\tvar p = subgraph.getRightmostCoordinate();\n  \t\t\tvar locater = new SubgraphDepthLocater(processedGraphs);\n  \t\t\tvar outsideDepth = locater.getDepth(p);\n  \t\t\tsubgraph.computeDepth(outsideDepth);\n  \t\t\tsubgraph.findResultEdges();\n  \t\t\tprocessedGraphs.add(subgraph);\n  \t\t\tpolyBuilder.add(subgraph.getDirectedEdges(), subgraph.getNodes());\n  \t\t}\n  \t},\n  \tcreateSubgraphs: function createSubgraphs(graph) {\n  \t\tvar subgraphList = new ArrayList();\n  \t\tfor (var i = graph.getNodes().iterator(); i.hasNext();) {\n  \t\t\tvar node = i.next();\n  \t\t\tif (!node.isVisited()) {\n  \t\t\t\tvar subgraph = new BufferSubgraph();\n  \t\t\t\tsubgraph.create(node);\n  \t\t\t\tsubgraphList.add(subgraph);\n  \t\t\t}\n  \t\t}\n  \t\tCollections.sort(subgraphList, Collections.reverseOrder());\n  \t\treturn subgraphList;\n  \t},\n  \tcreateEmptyResultGeometry: function createEmptyResultGeometry() {\n  \t\tvar emptyGeom = this._geomFact.createPolygon();\n  \t\treturn emptyGeom;\n  \t},\n  \tgetNoder: function getNoder(precisionModel) {\n  \t\tif (this._workingNoder !== null) return this._workingNoder;\n  \t\tvar noder = new MCIndexNoder();\n  \t\tvar li = new RobustLineIntersector();\n  \t\tli.setPrecisionModel(precisionModel);\n  \t\tnoder.setSegmentIntersector(new IntersectionAdder(li));\n  \t\treturn noder;\n  \t},\n  \tbuffer: function buffer(g, distance) {\n  \t\tvar precisionModel = this._workingPrecisionModel;\n  \t\tif (precisionModel === null) precisionModel = g.getPrecisionModel();\n  \t\tthis._geomFact = g.getFactory();\n  \t\tvar curveBuilder = new OffsetCurveBuilder(precisionModel, this._bufParams);\n  \t\tvar curveSetBuilder = new OffsetCurveSetBuilder(g, distance, curveBuilder);\n  \t\tvar bufferSegStrList = curveSetBuilder.getCurves();\n  \t\tif (bufferSegStrList.size() <= 0) {\n  \t\t\treturn this.createEmptyResultGeometry();\n  \t\t}\n  \t\tthis.computeNodedEdges(bufferSegStrList, precisionModel);\n  \t\tthis._graph = new PlanarGraph(new OverlayNodeFactory());\n  \t\tthis._graph.addEdges(this._edgeList.getEdges());\n  \t\tvar subgraphList = this.createSubgraphs(this._graph);\n  \t\tvar polyBuilder = new PolygonBuilder(this._geomFact);\n  \t\tthis.buildSubgraphs(subgraphList, polyBuilder);\n  \t\tvar resultPolyList = polyBuilder.getPolygons();\n  \t\tif (resultPolyList.size() <= 0) {\n  \t\t\treturn this.createEmptyResultGeometry();\n  \t\t}\n  \t\tvar resultGeom = this._geomFact.buildGeometry(resultPolyList);\n  \t\treturn resultGeom;\n  \t},\n  \tcomputeNodedEdges: function computeNodedEdges(bufferSegStrList, precisionModel) {\n  \t\tvar noder = this.getNoder(precisionModel);\n  \t\tnoder.computeNodes(bufferSegStrList);\n  \t\tvar nodedSegStrings = noder.getNodedSubstrings();\n  \t\tfor (var i = nodedSegStrings.iterator(); i.hasNext();) {\n  \t\t\tvar segStr = i.next();\n  \t\t\tvar pts = segStr.getCoordinates();\n  \t\t\tif (pts.length === 2 && pts[0].equals2D(pts[1])) continue;\n  \t\t\tvar oldLabel = segStr.getData();\n  \t\t\tvar edge = new Edge(segStr.getCoordinates(), new Label(oldLabel));\n  \t\t\tthis.insertUniqueEdge(edge);\n  \t\t}\n  \t},\n  \tsetNoder: function setNoder(noder) {\n  \t\tthis._workingNoder = noder;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn BufferBuilder;\n  \t}\n  });\n  BufferBuilder.depthDelta = function (label) {\n  \tvar lLoc = label.getLocation(0, Position.LEFT);\n  \tvar rLoc = label.getLocation(0, Position.RIGHT);\n  \tif (lLoc === Location.INTERIOR && rLoc === Location.EXTERIOR) return 1;else if (lLoc === Location.EXTERIOR && rLoc === Location.INTERIOR) return -1;\n  \treturn 0;\n  };\n  BufferBuilder.convertSegStrings = function (it) {\n  \tvar fact = new GeometryFactory();\n  \tvar lines = new ArrayList();\n  \twhile (it.hasNext()) {\n  \t\tvar ss = it.next();\n  \t\tvar line = fact.createLineString(ss.getCoordinates());\n  \t\tlines.add(line);\n  \t}\n  \treturn fact.buildGeometry(lines);\n  };\n\n  function NodingValidator() {\n  \tthis._li = new RobustLineIntersector();\n  \tthis._segStrings = null;\n  \tvar segStrings = arguments[0];\n  \tthis._segStrings = segStrings;\n  }\n  extend(NodingValidator.prototype, {\n  \tcheckEndPtVertexIntersections: function checkEndPtVertexIntersections() {\n  \t\tif (arguments.length === 0) {\n  \t\t\tfor (var i = this._segStrings.iterator(); i.hasNext();) {\n  \t\t\t\tvar ss = i.next();\n  \t\t\t\tvar pts = ss.getCoordinates();\n  \t\t\t\tthis.checkEndPtVertexIntersections(pts[0], this._segStrings);\n  \t\t\t\tthis.checkEndPtVertexIntersections(pts[pts.length - 1], this._segStrings);\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar testPt = arguments[0],\n  \t\t\t    segStrings = arguments[1];\n  \t\t\tfor (var i = segStrings.iterator(); i.hasNext();) {\n  \t\t\t\tvar ss = i.next();\n  \t\t\t\tvar pts = ss.getCoordinates();\n  \t\t\t\tfor (var j = 1; j < pts.length - 1; j++) {\n  \t\t\t\t\tif (pts[j].equals(testPt)) throw new RuntimeException(\"found endpt/interior pt intersection at index \" + j + \" :pt \" + testPt);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcheckInteriorIntersections: function checkInteriorIntersections() {\n  \t\tif (arguments.length === 0) {\n  \t\t\tfor (var i = this._segStrings.iterator(); i.hasNext();) {\n  \t\t\t\tvar ss0 = i.next();\n  \t\t\t\tfor (var j = this._segStrings.iterator(); j.hasNext();) {\n  \t\t\t\t\tvar ss1 = j.next();\n  \t\t\t\t\tthis.checkInteriorIntersections(ss0, ss1);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar ss0 = arguments[0],\n  \t\t\t    ss1 = arguments[1];\n  \t\t\tvar pts0 = ss0.getCoordinates();\n  \t\t\tvar pts1 = ss1.getCoordinates();\n  \t\t\tfor (var i0 = 0; i0 < pts0.length - 1; i0++) {\n  \t\t\t\tfor (var i1 = 0; i1 < pts1.length - 1; i1++) {\n  \t\t\t\t\tthis.checkInteriorIntersections(ss0, i0, ss1, i1);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} else if (arguments.length === 4) {\n  \t\t\tvar e0 = arguments[0],\n  \t\t\t    segIndex0 = arguments[1],\n  \t\t\t    e1 = arguments[2],\n  \t\t\t    segIndex1 = arguments[3];\n  \t\t\tif (e0 === e1 && segIndex0 === segIndex1) return null;\n  \t\t\tvar p00 = e0.getCoordinates()[segIndex0];\n  \t\t\tvar p01 = e0.getCoordinates()[segIndex0 + 1];\n  \t\t\tvar p10 = e1.getCoordinates()[segIndex1];\n  \t\t\tvar p11 = e1.getCoordinates()[segIndex1 + 1];\n  \t\t\tthis._li.computeIntersection(p00, p01, p10, p11);\n  \t\t\tif (this._li.hasIntersection()) {\n  \t\t\t\tif (this._li.isProper() || this.hasInteriorIntersection(this._li, p00, p01) || this.hasInteriorIntersection(this._li, p10, p11)) {\n  \t\t\t\t\tthrow new RuntimeException(\"found non-noded intersection at \" + p00 + \"-\" + p01 + \" and \" + p10 + \"-\" + p11);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcheckValid: function checkValid() {\n  \t\tthis.checkEndPtVertexIntersections();\n  \t\tthis.checkInteriorIntersections();\n  \t\tthis.checkCollapses();\n  \t},\n  \tcheckCollapses: function checkCollapses() {\n  \t\tif (arguments.length === 0) {\n  \t\t\tfor (var i = this._segStrings.iterator(); i.hasNext();) {\n  \t\t\t\tvar ss = i.next();\n  \t\t\t\tthis.checkCollapses(ss);\n  \t\t\t}\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tvar ss = arguments[0];\n  \t\t\tvar pts = ss.getCoordinates();\n  \t\t\tfor (var i = 0; i < pts.length - 2; i++) {\n  \t\t\t\tthis.checkCollapse(pts[i], pts[i + 1], pts[i + 2]);\n  \t\t\t}\n  \t\t}\n  \t},\n  \thasInteriorIntersection: function hasInteriorIntersection(li, p0, p1) {\n  \t\tfor (var i = 0; i < li.getIntersectionNum(); i++) {\n  \t\t\tvar intPt = li.getIntersection(i);\n  \t\t\tif (!(intPt.equals(p0) || intPt.equals(p1))) return true;\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tcheckCollapse: function checkCollapse(p0, p1, p2) {\n  \t\tif (p0.equals(p2)) throw new RuntimeException(\"found non-noded collapse at \" + NodingValidator.fact.createLineString([p0, p1, p2]));\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn NodingValidator;\n  \t}\n  });\n  NodingValidator.fact = new GeometryFactory();\n\n  function HotPixel() {\n  \tthis._li = null;\n  \tthis._pt = null;\n  \tthis._originalPt = null;\n  \tthis._ptScaled = null;\n  \tthis._p0Scaled = null;\n  \tthis._p1Scaled = null;\n  \tthis._scaleFactor = null;\n  \tthis._minx = null;\n  \tthis._maxx = null;\n  \tthis._miny = null;\n  \tthis._maxy = null;\n  \tthis._corner = new Array(4).fill(null);\n  \tthis._safeEnv = null;\n  \tvar pt = arguments[0],\n  \t    scaleFactor = arguments[1],\n  \t    li = arguments[2];\n  \tthis._originalPt = pt;\n  \tthis._pt = pt;\n  \tthis._scaleFactor = scaleFactor;\n  \tthis._li = li;\n  \tif (scaleFactor <= 0) throw new IllegalArgumentException(\"Scale factor must be non-zero\");\n  \tif (scaleFactor !== 1.0) {\n  \t\tthis._pt = new Coordinate(this.scale(pt.x), this.scale(pt.y));\n  \t\tthis._p0Scaled = new Coordinate();\n  \t\tthis._p1Scaled = new Coordinate();\n  \t}\n  \tthis.initCorners(this._pt);\n  }\n  extend(HotPixel.prototype, {\n  \tintersectsScaled: function intersectsScaled(p0, p1) {\n  \t\tvar segMinx = Math.min(p0.x, p1.x);\n  \t\tvar segMaxx = Math.max(p0.x, p1.x);\n  \t\tvar segMiny = Math.min(p0.y, p1.y);\n  \t\tvar segMaxy = Math.max(p0.y, p1.y);\n  \t\tvar isOutsidePixelEnv = this._maxx < segMinx || this._minx > segMaxx || this._maxy < segMiny || this._miny > segMaxy;\n  \t\tif (isOutsidePixelEnv) return false;\n  \t\tvar intersects = this.intersectsToleranceSquare(p0, p1);\n  \t\tAssert.isTrue(!(isOutsidePixelEnv && intersects), \"Found bad envelope test\");\n  \t\treturn intersects;\n  \t},\n  \tinitCorners: function initCorners(pt) {\n  \t\tvar tolerance = 0.5;\n  \t\tthis._minx = pt.x - tolerance;\n  \t\tthis._maxx = pt.x + tolerance;\n  \t\tthis._miny = pt.y - tolerance;\n  \t\tthis._maxy = pt.y + tolerance;\n  \t\tthis._corner[0] = new Coordinate(this._maxx, this._maxy);\n  \t\tthis._corner[1] = new Coordinate(this._minx, this._maxy);\n  \t\tthis._corner[2] = new Coordinate(this._minx, this._miny);\n  \t\tthis._corner[3] = new Coordinate(this._maxx, this._miny);\n  \t},\n  \tintersects: function intersects(p0, p1) {\n  \t\tif (this._scaleFactor === 1.0) return this.intersectsScaled(p0, p1);\n  \t\tthis.copyScaled(p0, this._p0Scaled);\n  \t\tthis.copyScaled(p1, this._p1Scaled);\n  \t\treturn this.intersectsScaled(this._p0Scaled, this._p1Scaled);\n  \t},\n  \tscale: function scale(val) {\n  \t\treturn Math.round(val * this._scaleFactor);\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\treturn this._originalPt;\n  \t},\n  \tcopyScaled: function copyScaled(p, pScaled) {\n  \t\tpScaled.x = this.scale(p.x);\n  \t\tpScaled.y = this.scale(p.y);\n  \t},\n  \tgetSafeEnvelope: function getSafeEnvelope() {\n  \t\tif (this._safeEnv === null) {\n  \t\t\tvar safeTolerance = HotPixel.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;\n  \t\t\tthis._safeEnv = new Envelope(this._originalPt.x - safeTolerance, this._originalPt.x + safeTolerance, this._originalPt.y - safeTolerance, this._originalPt.y + safeTolerance);\n  \t\t}\n  \t\treturn this._safeEnv;\n  \t},\n  \tintersectsPixelClosure: function intersectsPixelClosure(p0, p1) {\n  \t\tthis._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);\n  \t\tif (this._li.hasIntersection()) return true;\n  \t\tthis._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);\n  \t\tif (this._li.hasIntersection()) return true;\n  \t\tthis._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);\n  \t\tif (this._li.hasIntersection()) return true;\n  \t\tthis._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);\n  \t\tif (this._li.hasIntersection()) return true;\n  \t\treturn false;\n  \t},\n  \tintersectsToleranceSquare: function intersectsToleranceSquare(p0, p1) {\n  \t\tvar intersectsLeft = false;\n  \t\tvar intersectsBottom = false;\n  \t\tthis._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);\n  \t\tif (this._li.isProper()) return true;\n  \t\tthis._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);\n  \t\tif (this._li.isProper()) return true;\n  \t\tif (this._li.hasIntersection()) intersectsLeft = true;\n  \t\tthis._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);\n  \t\tif (this._li.isProper()) return true;\n  \t\tif (this._li.hasIntersection()) intersectsBottom = true;\n  \t\tthis._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);\n  \t\tif (this._li.isProper()) return true;\n  \t\tif (intersectsLeft && intersectsBottom) return true;\n  \t\tif (p0.equals(this._pt)) return true;\n  \t\tif (p1.equals(this._pt)) return true;\n  \t\treturn false;\n  \t},\n  \taddSnappedNode: function addSnappedNode(segStr, segIndex) {\n  \t\tvar p0 = segStr.getCoordinate(segIndex);\n  \t\tvar p1 = segStr.getCoordinate(segIndex + 1);\n  \t\tif (this.intersects(p0, p1)) {\n  \t\t\tsegStr.addIntersection(this.getCoordinate(), segIndex);\n  \t\t\treturn true;\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn HotPixel;\n  \t}\n  });\n  HotPixel.SAFE_ENV_EXPANSION_FACTOR = 0.75;\n\n  function MCIndexPointSnapper() {\n  \tthis._index = null;\n  \tvar index = arguments[0];\n  \tthis._index = index;\n  }\n  extend(MCIndexPointSnapper.prototype, {\n  \tsnap: function snap() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar hotPixel = arguments[0];\n  \t\t\treturn this.snap(hotPixel, null, -1);\n  \t\t} else if (arguments.length === 3) {\n  \t\t\tvar hotPixel = arguments[0],\n  \t\t\t    parentEdge = arguments[1],\n  \t\t\t    hotPixelVertexIndex = arguments[2];\n  \t\t\tvar pixelEnv = hotPixel.getSafeEnvelope();\n  \t\t\tvar hotPixelSnapAction = new HotPixelSnapAction(hotPixel, parentEdge, hotPixelVertexIndex);\n  \t\t\tthis._index.query(pixelEnv, {\n  \t\t\t\tinterfaces_: function interfaces_() {\n  \t\t\t\t\treturn [ItemVisitor];\n  \t\t\t\t},\n  \t\t\t\tvisitItem: function visitItem(item) {\n  \t\t\t\t\tvar testChain = item;\n  \t\t\t\t\ttestChain.select(pixelEnv, hotPixelSnapAction);\n  \t\t\t\t}\n  \t\t\t});\n  \t\t\treturn hotPixelSnapAction.isNodeAdded();\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MCIndexPointSnapper;\n  \t}\n  });\n  function HotPixelSnapAction() {\n  \tMonotoneChainSelectAction.apply(this);\n  \tthis._hotPixel = null;\n  \tthis._parentEdge = null;\n  \tthis._hotPixelVertexIndex = null;\n  \tthis._isNodeAdded = false;\n  \tvar hotPixel = arguments[0],\n  \t    parentEdge = arguments[1],\n  \t    hotPixelVertexIndex = arguments[2];\n  \tthis._hotPixel = hotPixel;\n  \tthis._parentEdge = parentEdge;\n  \tthis._hotPixelVertexIndex = hotPixelVertexIndex;\n  }\n  inherits$1(HotPixelSnapAction, MonotoneChainSelectAction);\n  extend(HotPixelSnapAction.prototype, {\n  \tisNodeAdded: function isNodeAdded() {\n  \t\treturn this._isNodeAdded;\n  \t},\n  \tselect: function select() {\n  \t\tif (arguments.length === 2) {\n  \t\t\tvar mc = arguments[0],\n  \t\t\t    startIndex = arguments[1];\n  \t\t\tvar ss = mc.getContext();\n  \t\t\tif (this._parentEdge !== null) {\n  \t\t\t\tif (ss === this._parentEdge && startIndex === this._hotPixelVertexIndex) return null;\n  \t\t\t}\n  \t\t\tthis._isNodeAdded = this._hotPixel.addSnappedNode(ss, startIndex);\n  \t\t} else return MonotoneChainSelectAction.prototype.select.apply(this, arguments);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn HotPixelSnapAction;\n  \t}\n  });\n  MCIndexPointSnapper.HotPixelSnapAction = HotPixelSnapAction;\n\n  function InteriorIntersectionFinderAdder() {\n  \tthis._li = null;\n  \tthis._interiorIntersections = null;\n  \tvar li = arguments[0];\n  \tthis._li = li;\n  \tthis._interiorIntersections = new ArrayList();\n  }\n  extend(InteriorIntersectionFinderAdder.prototype, {\n  \tprocessIntersections: function processIntersections(e0, segIndex0, e1, segIndex1) {\n  \t\tif (e0 === e1 && segIndex0 === segIndex1) return null;\n  \t\tvar p00 = e0.getCoordinates()[segIndex0];\n  \t\tvar p01 = e0.getCoordinates()[segIndex0 + 1];\n  \t\tvar p10 = e1.getCoordinates()[segIndex1];\n  \t\tvar p11 = e1.getCoordinates()[segIndex1 + 1];\n  \t\tthis._li.computeIntersection(p00, p01, p10, p11);\n  \t\tif (this._li.hasIntersection()) {\n  \t\t\tif (this._li.isInteriorIntersection()) {\n  \t\t\t\tfor (var intIndex = 0; intIndex < this._li.getIntersectionNum(); intIndex++) {\n  \t\t\t\t\tthis._interiorIntersections.add(this._li.getIntersection(intIndex));\n  \t\t\t\t}\n  \t\t\t\te0.addIntersections(this._li, segIndex0, 0);\n  \t\t\t\te1.addIntersections(this._li, segIndex1, 1);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tisDone: function isDone() {\n  \t\treturn false;\n  \t},\n  \tgetInteriorIntersections: function getInteriorIntersections() {\n  \t\treturn this._interiorIntersections;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [SegmentIntersector];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn InteriorIntersectionFinderAdder;\n  \t}\n  });\n\n  function MCIndexSnapRounder() {\n  \tthis._pm = null;\n  \tthis._li = null;\n  \tthis._scaleFactor = null;\n  \tthis._noder = null;\n  \tthis._pointSnapper = null;\n  \tthis._nodedSegStrings = null;\n  \tvar pm = arguments[0];\n  \tthis._pm = pm;\n  \tthis._li = new RobustLineIntersector();\n  \tthis._li.setPrecisionModel(pm);\n  \tthis._scaleFactor = pm.getScale();\n  }\n  extend(MCIndexSnapRounder.prototype, {\n  \tcheckCorrectness: function checkCorrectness(inputSegmentStrings) {\n  \t\tvar resultSegStrings = NodedSegmentString.getNodedSubstrings(inputSegmentStrings);\n  \t\tvar nv = new NodingValidator(resultSegStrings);\n  \t\ttry {\n  \t\t\tnv.checkValid();\n  \t\t} catch (ex) {\n  \t\t\tif (ex instanceof Exception) {\n  \t\t\t\tex.printStackTrace();\n  \t\t\t} else throw ex;\n  \t\t} finally {}\n  \t},\n  \tgetNodedSubstrings: function getNodedSubstrings() {\n  \t\treturn NodedSegmentString.getNodedSubstrings(this._nodedSegStrings);\n  \t},\n  \tsnapRound: function snapRound(segStrings, li) {\n  \t\tvar intersections = this.findInteriorIntersections(segStrings, li);\n  \t\tthis.computeIntersectionSnaps(intersections);\n  \t\tthis.computeVertexSnaps(segStrings);\n  \t},\n  \tfindInteriorIntersections: function findInteriorIntersections(segStrings, li) {\n  \t\tvar intFinderAdder = new InteriorIntersectionFinderAdder(li);\n  \t\tthis._noder.setSegmentIntersector(intFinderAdder);\n  \t\tthis._noder.computeNodes(segStrings);\n  \t\treturn intFinderAdder.getInteriorIntersections();\n  \t},\n  \tcomputeVertexSnaps: function computeVertexSnaps() {\n  \t\tif (hasInterface(arguments[0], Collection)) {\n  \t\t\tvar edges = arguments[0];\n  \t\t\tfor (var i0 = edges.iterator(); i0.hasNext();) {\n  \t\t\t\tvar edge0 = i0.next();\n  \t\t\t\tthis.computeVertexSnaps(edge0);\n  \t\t\t}\n  \t\t} else if (arguments[0] instanceof NodedSegmentString) {\n  \t\t\tvar e = arguments[0];\n  \t\t\tvar pts0 = e.getCoordinates();\n  \t\t\tfor (var i = 0; i < pts0.length; i++) {\n  \t\t\t\tvar hotPixel = new HotPixel(pts0[i], this._scaleFactor, this._li);\n  \t\t\t\tvar isNodeAdded = this._pointSnapper.snap(hotPixel, e, i);\n  \t\t\t\tif (isNodeAdded) {\n  \t\t\t\t\te.addIntersection(pts0[i], i);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcomputeNodes: function computeNodes(inputSegmentStrings) {\n  \t\tthis._nodedSegStrings = inputSegmentStrings;\n  \t\tthis._noder = new MCIndexNoder();\n  \t\tthis._pointSnapper = new MCIndexPointSnapper(this._noder.getIndex());\n  \t\tthis.snapRound(inputSegmentStrings, this._li);\n  \t},\n  \tcomputeIntersectionSnaps: function computeIntersectionSnaps(snapPts) {\n  \t\tfor (var it = snapPts.iterator(); it.hasNext();) {\n  \t\t\tvar snapPt = it.next();\n  \t\t\tvar hotPixel = new HotPixel(snapPt, this._scaleFactor, this._li);\n  \t\t\tthis._pointSnapper.snap(hotPixel);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Noder];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn MCIndexSnapRounder;\n  \t}\n  });\n\n  function BufferOp() {\n  \tthis._argGeom = null;\n  \tthis._distance = null;\n  \tthis._bufParams = new BufferParameters();\n  \tthis._resultGeometry = null;\n  \tthis._saveException = null;\n  \tif (arguments.length === 1) {\n  \t\tvar g = arguments[0];\n  \t\tthis._argGeom = g;\n  \t} else if (arguments.length === 2) {\n  \t\tvar g = arguments[0],\n  \t\t    bufParams = arguments[1];\n  \t\tthis._argGeom = g;\n  \t\tthis._bufParams = bufParams;\n  \t}\n  }\n  extend(BufferOp.prototype, {\n  \tbufferFixedPrecision: function bufferFixedPrecision(fixedPM) {\n  \t\tvar noder = new ScaledNoder(new MCIndexSnapRounder(new PrecisionModel(1.0)), fixedPM.getScale());\n  \t\tvar bufBuilder = new BufferBuilder(this._bufParams);\n  \t\tbufBuilder.setWorkingPrecisionModel(fixedPM);\n  \t\tbufBuilder.setNoder(noder);\n  \t\tthis._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);\n  \t},\n  \tbufferReducedPrecision: function bufferReducedPrecision() {\n  \t\tif (arguments.length === 0) {\n  \t\t\tfor (var precDigits = BufferOp.MAX_PRECISION_DIGITS; precDigits >= 0; precDigits--) {\n  \t\t\t\ttry {\n  \t\t\t\t\tthis.bufferReducedPrecision(precDigits);\n  \t\t\t\t} catch (ex) {\n  \t\t\t\t\tif (ex instanceof TopologyException) {\n  \t\t\t\t\t\tthis._saveException = ex;\n  \t\t\t\t\t} else throw ex;\n  \t\t\t\t} finally {}\n  \t\t\t\tif (this._resultGeometry !== null) return null;\n  \t\t\t}\n  \t\t\tthrow this._saveException;\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tvar precisionDigits = arguments[0];\n  \t\t\tvar sizeBasedScaleFactor = BufferOp.precisionScaleFactor(this._argGeom, this._distance, precisionDigits);\n  \t\t\tvar fixedPM = new PrecisionModel(sizeBasedScaleFactor);\n  \t\t\tthis.bufferFixedPrecision(fixedPM);\n  \t\t}\n  \t},\n  \tcomputeGeometry: function computeGeometry() {\n  \t\tthis.bufferOriginalPrecision();\n  \t\tif (this._resultGeometry !== null) return null;\n  \t\tvar argPM = this._argGeom.getFactory().getPrecisionModel();\n  \t\tif (argPM.getType() === PrecisionModel.FIXED) this.bufferFixedPrecision(argPM);else this.bufferReducedPrecision();\n  \t},\n  \tsetQuadrantSegments: function setQuadrantSegments(quadrantSegments) {\n  \t\tthis._bufParams.setQuadrantSegments(quadrantSegments);\n  \t},\n  \tbufferOriginalPrecision: function bufferOriginalPrecision() {\n  \t\ttry {\n  \t\t\tvar bufBuilder = new BufferBuilder(this._bufParams);\n  \t\t\tthis._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);\n  \t\t} catch (ex) {\n  \t\t\tif (ex instanceof RuntimeException) {\n  \t\t\t\tthis._saveException = ex;\n  \t\t\t} else throw ex;\n  \t\t} finally {}\n  \t},\n  \tgetResultGeometry: function getResultGeometry(distance) {\n  \t\tthis._distance = distance;\n  \t\tthis.computeGeometry();\n  \t\treturn this._resultGeometry;\n  \t},\n  \tsetEndCapStyle: function setEndCapStyle(endCapStyle) {\n  \t\tthis._bufParams.setEndCapStyle(endCapStyle);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn BufferOp;\n  \t}\n  });\n  BufferOp.bufferOp = function () {\n  \tif (arguments.length === 2) {\n  \t\tvar g = arguments[0],\n  \t\t    distance = arguments[1];\n  \t\tvar gBuf = new BufferOp(g);\n  \t\tvar geomBuf = gBuf.getResultGeometry(distance);\n  \t\treturn geomBuf;\n  \t} else if (arguments.length === 3) {\n  \t\tif (Number.isInteger(arguments[2]) && arguments[0] instanceof Geometry && typeof arguments[1] === \"number\") {\n  \t\t\tvar g = arguments[0],\n  \t\t\t    distance = arguments[1],\n  \t\t\t    quadrantSegments = arguments[2];\n  \t\t\tvar bufOp = new BufferOp(g);\n  \t\t\tbufOp.setQuadrantSegments(quadrantSegments);\n  \t\t\tvar geomBuf = bufOp.getResultGeometry(distance);\n  \t\t\treturn geomBuf;\n  \t\t} else if (arguments[2] instanceof BufferParameters && arguments[0] instanceof Geometry && typeof arguments[1] === \"number\") {\n  \t\t\tvar g = arguments[0],\n  \t\t\t    distance = arguments[1],\n  \t\t\t    params = arguments[2];\n  \t\t\tvar bufOp = new BufferOp(g, params);\n  \t\t\tvar geomBuf = bufOp.getResultGeometry(distance);\n  \t\t\treturn geomBuf;\n  \t\t}\n  \t} else if (arguments.length === 4) {\n  \t\tvar g = arguments[0],\n  \t\t    distance = arguments[1],\n  \t\t    quadrantSegments = arguments[2],\n  \t\t    endCapStyle = arguments[3];\n  \t\tvar bufOp = new BufferOp(g);\n  \t\tbufOp.setQuadrantSegments(quadrantSegments);\n  \t\tbufOp.setEndCapStyle(endCapStyle);\n  \t\tvar geomBuf = bufOp.getResultGeometry(distance);\n  \t\treturn geomBuf;\n  \t}\n  };\n  BufferOp.precisionScaleFactor = function (g, distance, maxPrecisionDigits) {\n  \tvar env = g.getEnvelopeInternal();\n  \tvar envMax = MathUtil.max(Math.abs(env.getMaxX()), Math.abs(env.getMaxY()), Math.abs(env.getMinX()), Math.abs(env.getMinY()));\n  \tvar expandByDistance = distance > 0.0 ? distance : 0.0;\n  \tvar bufEnvMax = envMax + 2 * expandByDistance;\n  \tvar bufEnvPrecisionDigits = Math.trunc(Math.log(bufEnvMax) / Math.log(10) + 1.0);\n  \tvar minUnitLog10 = maxPrecisionDigits - bufEnvPrecisionDigits;\n  \tvar scaleFactor = Math.pow(10.0, minUnitLog10);\n  \treturn scaleFactor;\n  };\n  BufferOp.CAP_ROUND = BufferParameters.CAP_ROUND;\n  BufferOp.CAP_BUTT = BufferParameters.CAP_FLAT;\n  BufferOp.CAP_FLAT = BufferParameters.CAP_FLAT;\n  BufferOp.CAP_SQUARE = BufferParameters.CAP_SQUARE;\n  BufferOp.MAX_PRECISION_DIGITS = 12;\n\n  function PolygonExtracter() {\n  \tthis._comps = null;\n  \tvar comps = arguments[0];\n  \tthis._comps = comps;\n  }\n  extend(PolygonExtracter.prototype, {\n  \tfilter: function filter(geom) {\n  \t\tif (geom instanceof Polygon) this._comps.add(geom);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [GeometryFilter];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn PolygonExtracter;\n  \t}\n  });\n  PolygonExtracter.getPolygons = function () {\n  \tif (arguments.length === 1) {\n  \t\tvar geom = arguments[0];\n  \t\treturn PolygonExtracter.getPolygons(geom, new ArrayList());\n  \t} else if (arguments.length === 2) {\n  \t\tvar geom = arguments[0],\n  \t\t    list = arguments[1];\n  \t\tif (geom instanceof Polygon) {\n  \t\t\tlist.add(geom);\n  \t\t} else if (geom instanceof GeometryCollection) {\n  \t\t\tgeom.apply(new PolygonExtracter(list));\n  \t\t}\n  \t\treturn list;\n  \t}\n  };\n\n  function GeometryLocation() {\n  \tthis._component = null;\n  \tthis._segIndex = null;\n  \tthis._pt = null;\n  \tif (arguments.length === 2) {\n  \t\tvar component = arguments[0],\n  \t\t    pt = arguments[1];\n  \t\tGeometryLocation.call(this, component, GeometryLocation.INSIDE_AREA, pt);\n  \t} else if (arguments.length === 3) {\n  \t\tvar component = arguments[0],\n  \t\t    segIndex = arguments[1],\n  \t\t    pt = arguments[2];\n  \t\tthis._component = component;\n  \t\tthis._segIndex = segIndex;\n  \t\tthis._pt = pt;\n  \t}\n  }\n  extend(GeometryLocation.prototype, {\n  \tisInsideArea: function isInsideArea() {\n  \t\treturn this._segIndex === GeometryLocation.INSIDE_AREA;\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\treturn this._pt;\n  \t},\n  \tgetGeometryComponent: function getGeometryComponent() {\n  \t\treturn this._component;\n  \t},\n  \tgetSegmentIndex: function getSegmentIndex() {\n  \t\treturn this._segIndex;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn GeometryLocation;\n  \t}\n  });\n  GeometryLocation.INSIDE_AREA = -1;\n\n  function PointExtracter() {\n  \tthis._pts = null;\n  \tvar pts = arguments[0];\n  \tthis._pts = pts;\n  }\n  extend(PointExtracter.prototype, {\n  \tfilter: function filter(geom) {\n  \t\tif (geom instanceof Point) this._pts.add(geom);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [GeometryFilter];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn PointExtracter;\n  \t}\n  });\n  PointExtracter.getPoints = function () {\n  \tif (arguments.length === 1) {\n  \t\tvar geom = arguments[0];\n  \t\tif (geom instanceof Point) {\n  \t\t\treturn Collections.singletonList(geom);\n  \t\t}\n  \t\treturn PointExtracter.getPoints(geom, new ArrayList());\n  \t} else if (arguments.length === 2) {\n  \t\tvar geom = arguments[0],\n  \t\t    list = arguments[1];\n  \t\tif (geom instanceof Point) {\n  \t\t\tlist.add(geom);\n  \t\t} else if (geom instanceof GeometryCollection) {\n  \t\t\tgeom.apply(new PointExtracter(list));\n  \t\t}\n  \t\treturn list;\n  \t}\n  };\n\n  function ConnectedElementLocationFilter() {\n  \tthis._locations = null;\n  \tvar locations = arguments[0];\n  \tthis._locations = locations;\n  }\n  extend(ConnectedElementLocationFilter.prototype, {\n  \tfilter: function filter(geom) {\n  \t\tif (geom instanceof Point || geom instanceof LineString || geom instanceof Polygon) this._locations.add(new GeometryLocation(geom, 0, geom.getCoordinate()));\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [GeometryFilter];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn ConnectedElementLocationFilter;\n  \t}\n  });\n  ConnectedElementLocationFilter.getLocations = function (geom) {\n  \tvar locations = new ArrayList();\n  \tgeom.apply(new ConnectedElementLocationFilter(locations));\n  \treturn locations;\n  };\n\n  function DistanceOp() {\n  \tthis._geom = null;\n  \tthis._terminateDistance = 0.0;\n  \tthis._ptLocator = new PointLocator();\n  \tthis._minDistanceLocation = null;\n  \tthis._minDistance = Double.MAX_VALUE;\n  \tif (arguments.length === 2) {\n  \t\tvar g0 = arguments[0],\n  \t\t    g1 = arguments[1];\n  \t\tDistanceOp.call(this, g0, g1, 0.0);\n  \t} else if (arguments.length === 3) {\n  \t\tvar g0 = arguments[0],\n  \t\t    g1 = arguments[1],\n  \t\t    terminateDistance = arguments[2];\n  \t\tthis._geom = new Array(2).fill(null);\n  \t\tthis._geom[0] = g0;\n  \t\tthis._geom[1] = g1;\n  \t\tthis._terminateDistance = terminateDistance;\n  \t}\n  }\n  extend(DistanceOp.prototype, {\n  \tcomputeContainmentDistance: function computeContainmentDistance() {\n  \t\tif (arguments.length === 0) {\n  \t\t\tvar locPtPoly = new Array(2).fill(null);\n  \t\t\tthis.computeContainmentDistance(0, locPtPoly);\n  \t\t\tif (this._minDistance <= this._terminateDistance) return null;\n  \t\t\tthis.computeContainmentDistance(1, locPtPoly);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar polyGeomIndex = arguments[0],\n  \t\t\t    locPtPoly = arguments[1];\n  \t\t\tvar locationsIndex = 1 - polyGeomIndex;\n  \t\t\tvar polys = PolygonExtracter.getPolygons(this._geom[polyGeomIndex]);\n  \t\t\tif (polys.size() > 0) {\n  \t\t\t\tvar insideLocs = ConnectedElementLocationFilter.getLocations(this._geom[locationsIndex]);\n  \t\t\t\tthis.computeContainmentDistance(insideLocs, polys, locPtPoly);\n  \t\t\t\tif (this._minDistance <= this._terminateDistance) {\n  \t\t\t\t\tthis._minDistanceLocation[locationsIndex] = locPtPoly[0];\n  \t\t\t\t\tthis._minDistanceLocation[polyGeomIndex] = locPtPoly[1];\n  \t\t\t\t\treturn null;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} else if (arguments.length === 3) {\n  \t\t\tif (arguments[2] instanceof Array && hasInterface(arguments[0], List) && hasInterface(arguments[1], List)) {\n  \t\t\t\tvar locs = arguments[0],\n  \t\t\t\t    polys = arguments[1],\n  \t\t\t\t    locPtPoly = arguments[2];\n  \t\t\t\tfor (var i = 0; i < locs.size(); i++) {\n  \t\t\t\t\tvar loc = locs.get(i);\n  \t\t\t\t\tfor (var j = 0; j < polys.size(); j++) {\n  \t\t\t\t\t\tthis.computeContainmentDistance(loc, polys.get(j), locPtPoly);\n  \t\t\t\t\t\tif (this._minDistance <= this._terminateDistance) return null;\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t} else if (arguments[2] instanceof Array && arguments[0] instanceof GeometryLocation && arguments[1] instanceof Polygon) {\n  \t\t\t\tvar ptLoc = arguments[0],\n  \t\t\t\t    poly = arguments[1],\n  \t\t\t\t    locPtPoly = arguments[2];\n  \t\t\t\tvar pt = ptLoc.getCoordinate();\n  \t\t\t\tif (Location.EXTERIOR !== this._ptLocator.locate(pt, poly)) {\n  \t\t\t\t\tthis._minDistance = 0.0;\n  \t\t\t\t\tlocPtPoly[0] = ptLoc;\n  \t\t\t\t\tlocPtPoly[1] = new GeometryLocation(poly, pt);\n  \t\t\t\t\treturn null;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcomputeMinDistanceLinesPoints: function computeMinDistanceLinesPoints(lines, points, locGeom) {\n  \t\tfor (var i = 0; i < lines.size(); i++) {\n  \t\t\tvar line = lines.get(i);\n  \t\t\tfor (var j = 0; j < points.size(); j++) {\n  \t\t\t\tvar pt = points.get(j);\n  \t\t\t\tthis.computeMinDistance(line, pt, locGeom);\n  \t\t\t\tif (this._minDistance <= this._terminateDistance) return null;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcomputeFacetDistance: function computeFacetDistance() {\n  \t\tvar locGeom = new Array(2).fill(null);\n  \t\tvar lines0 = LinearComponentExtracter.getLines(this._geom[0]);\n  \t\tvar lines1 = LinearComponentExtracter.getLines(this._geom[1]);\n  \t\tvar pts0 = PointExtracter.getPoints(this._geom[0]);\n  \t\tvar pts1 = PointExtracter.getPoints(this._geom[1]);\n  \t\tthis.computeMinDistanceLines(lines0, lines1, locGeom);\n  \t\tthis.updateMinDistance(locGeom, false);\n  \t\tif (this._minDistance <= this._terminateDistance) return null;\n  \t\tlocGeom[0] = null;\n  \t\tlocGeom[1] = null;\n  \t\tthis.computeMinDistanceLinesPoints(lines0, pts1, locGeom);\n  \t\tthis.updateMinDistance(locGeom, false);\n  \t\tif (this._minDistance <= this._terminateDistance) return null;\n  \t\tlocGeom[0] = null;\n  \t\tlocGeom[1] = null;\n  \t\tthis.computeMinDistanceLinesPoints(lines1, pts0, locGeom);\n  \t\tthis.updateMinDistance(locGeom, true);\n  \t\tif (this._minDistance <= this._terminateDistance) return null;\n  \t\tlocGeom[0] = null;\n  \t\tlocGeom[1] = null;\n  \t\tthis.computeMinDistancePoints(pts0, pts1, locGeom);\n  \t\tthis.updateMinDistance(locGeom, false);\n  \t},\n  \tnearestLocations: function nearestLocations() {\n  \t\tthis.computeMinDistance();\n  \t\treturn this._minDistanceLocation;\n  \t},\n  \tupdateMinDistance: function updateMinDistance(locGeom, flip) {\n  \t\tif (locGeom[0] === null) return null;\n  \t\tif (flip) {\n  \t\t\tthis._minDistanceLocation[0] = locGeom[1];\n  \t\t\tthis._minDistanceLocation[1] = locGeom[0];\n  \t\t} else {\n  \t\t\tthis._minDistanceLocation[0] = locGeom[0];\n  \t\t\tthis._minDistanceLocation[1] = locGeom[1];\n  \t\t}\n  \t},\n  \tnearestPoints: function nearestPoints() {\n  \t\tthis.computeMinDistance();\n  \t\tvar nearestPts = [this._minDistanceLocation[0].getCoordinate(), this._minDistanceLocation[1].getCoordinate()];\n  \t\treturn nearestPts;\n  \t},\n  \tcomputeMinDistance: function computeMinDistance() {\n  \t\tif (arguments.length === 0) {\n  \t\t\tif (this._minDistanceLocation !== null) return null;\n  \t\t\tthis._minDistanceLocation = new Array(2).fill(null);\n  \t\t\tthis.computeContainmentDistance();\n  \t\t\tif (this._minDistance <= this._terminateDistance) return null;\n  \t\t\tthis.computeFacetDistance();\n  \t\t} else if (arguments.length === 3) {\n  \t\t\tif (arguments[2] instanceof Array && arguments[0] instanceof LineString && arguments[1] instanceof Point) {\n  \t\t\t\tvar line = arguments[0],\n  \t\t\t\t    pt = arguments[1],\n  \t\t\t\t    locGeom = arguments[2];\n  \t\t\t\tif (line.getEnvelopeInternal().distance(pt.getEnvelopeInternal()) > this._minDistance) return null;\n  \t\t\t\tvar coord0 = line.getCoordinates();\n  \t\t\t\tvar coord = pt.getCoordinate();\n  \t\t\t\tfor (var i = 0; i < coord0.length - 1; i++) {\n  \t\t\t\t\tvar dist = CGAlgorithms.distancePointLine(coord, coord0[i], coord0[i + 1]);\n  \t\t\t\t\tif (dist < this._minDistance) {\n  \t\t\t\t\t\tthis._minDistance = dist;\n  \t\t\t\t\t\tvar seg = new LineSegment(coord0[i], coord0[i + 1]);\n  \t\t\t\t\t\tvar segClosestPoint = seg.closestPoint(coord);\n  \t\t\t\t\t\tlocGeom[0] = new GeometryLocation(line, i, segClosestPoint);\n  \t\t\t\t\t\tlocGeom[1] = new GeometryLocation(pt, 0, coord);\n  \t\t\t\t\t}\n  \t\t\t\t\tif (this._minDistance <= this._terminateDistance) return null;\n  \t\t\t\t}\n  \t\t\t} else if (arguments[2] instanceof Array && arguments[0] instanceof LineString && arguments[1] instanceof LineString) {\n  \t\t\t\tvar line0 = arguments[0],\n  \t\t\t\t    line1 = arguments[1],\n  \t\t\t\t    locGeom = arguments[2];\n  \t\t\t\tif (line0.getEnvelopeInternal().distance(line1.getEnvelopeInternal()) > this._minDistance) return null;\n  \t\t\t\tvar coord0 = line0.getCoordinates();\n  \t\t\t\tvar coord1 = line1.getCoordinates();\n  \t\t\t\tfor (var i = 0; i < coord0.length - 1; i++) {\n  \t\t\t\t\tfor (var j = 0; j < coord1.length - 1; j++) {\n  \t\t\t\t\t\tvar dist = CGAlgorithms.distanceLineLine(coord0[i], coord0[i + 1], coord1[j], coord1[j + 1]);\n  \t\t\t\t\t\tif (dist < this._minDistance) {\n  \t\t\t\t\t\t\tthis._minDistance = dist;\n  \t\t\t\t\t\t\tvar seg0 = new LineSegment(coord0[i], coord0[i + 1]);\n  \t\t\t\t\t\t\tvar seg1 = new LineSegment(coord1[j], coord1[j + 1]);\n  \t\t\t\t\t\t\tvar closestPt = seg0.closestPoints(seg1);\n  \t\t\t\t\t\t\tlocGeom[0] = new GeometryLocation(line0, i, closestPt[0]);\n  \t\t\t\t\t\t\tlocGeom[1] = new GeometryLocation(line1, j, closestPt[1]);\n  \t\t\t\t\t\t}\n  \t\t\t\t\t\tif (this._minDistance <= this._terminateDistance) return null;\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcomputeMinDistancePoints: function computeMinDistancePoints(points0, points1, locGeom) {\n  \t\tfor (var i = 0; i < points0.size(); i++) {\n  \t\t\tvar pt0 = points0.get(i);\n  \t\t\tfor (var j = 0; j < points1.size(); j++) {\n  \t\t\t\tvar pt1 = points1.get(j);\n  \t\t\t\tvar dist = pt0.getCoordinate().distance(pt1.getCoordinate());\n  \t\t\t\tif (dist < this._minDistance) {\n  \t\t\t\t\tthis._minDistance = dist;\n  \t\t\t\t\tlocGeom[0] = new GeometryLocation(pt0, 0, pt0.getCoordinate());\n  \t\t\t\t\tlocGeom[1] = new GeometryLocation(pt1, 0, pt1.getCoordinate());\n  \t\t\t\t}\n  \t\t\t\tif (this._minDistance <= this._terminateDistance) return null;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tdistance: function distance() {\n  \t\tif (this._geom[0] === null || this._geom[1] === null) throw new IllegalArgumentException(\"null geometries are not supported\");\n  \t\tif (this._geom[0].isEmpty() || this._geom[1].isEmpty()) return 0.0;\n  \t\tthis.computeMinDistance();\n  \t\treturn this._minDistance;\n  \t},\n  \tcomputeMinDistanceLines: function computeMinDistanceLines(lines0, lines1, locGeom) {\n  \t\tfor (var i = 0; i < lines0.size(); i++) {\n  \t\t\tvar line0 = lines0.get(i);\n  \t\t\tfor (var j = 0; j < lines1.size(); j++) {\n  \t\t\t\tvar line1 = lines1.get(j);\n  \t\t\t\tthis.computeMinDistance(line0, line1, locGeom);\n  \t\t\t\tif (this._minDistance <= this._terminateDistance) return null;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn DistanceOp;\n  \t}\n  });\n  DistanceOp.distance = function (g0, g1) {\n  \tvar distOp = new DistanceOp(g0, g1);\n  \treturn distOp.distance();\n  };\n  DistanceOp.isWithinDistance = function (g0, g1, distance) {\n  \tvar distOp = new DistanceOp(g0, g1, distance);\n  \treturn distOp.distance() <= distance;\n  };\n  DistanceOp.nearestPoints = function (g0, g1) {\n  \tvar distOp = new DistanceOp(g0, g1);\n  \treturn distOp.nearestPoints();\n  };\n\n  function EdgeString() {\n  \tthis._factory = null;\n  \tthis._directedEdges = new ArrayList();\n  \tthis._coordinates = null;\n  \tvar factory = arguments[0];\n  \tthis._factory = factory;\n  }\n  extend(EdgeString.prototype, {\n  \tgetCoordinates: function getCoordinates() {\n  \t\tif (this._coordinates === null) {\n  \t\t\tvar forwardDirectedEdges = 0;\n  \t\t\tvar reverseDirectedEdges = 0;\n  \t\t\tvar coordinateList = new CoordinateList();\n  \t\t\tfor (var i = this._directedEdges.iterator(); i.hasNext();) {\n  \t\t\t\tvar directedEdge = i.next();\n  \t\t\t\tif (directedEdge.getEdgeDirection()) {\n  \t\t\t\t\tforwardDirectedEdges++;\n  \t\t\t\t} else {\n  \t\t\t\t\treverseDirectedEdges++;\n  \t\t\t\t}\n  \t\t\t\tcoordinateList.add(directedEdge.getEdge().getLine().getCoordinates(), false, directedEdge.getEdgeDirection());\n  \t\t\t}\n  \t\t\tthis._coordinates = coordinateList.toCoordinateArray();\n  \t\t\tif (reverseDirectedEdges > forwardDirectedEdges) {\n  \t\t\t\tCoordinateArrays.reverse(this._coordinates);\n  \t\t\t}\n  \t\t}\n  \t\treturn this._coordinates;\n  \t},\n  \ttoLineString: function toLineString() {\n  \t\treturn this._factory.createLineString(this.getCoordinates());\n  \t},\n  \tadd: function add(directedEdge) {\n  \t\tthis._directedEdges.add(directedEdge);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn EdgeString;\n  \t}\n  });\n\n  function GraphComponent$1() {\n  \tthis._isMarked = false;\n  \tthis._isVisited = false;\n  \tthis._data = null;\n  }\n  extend(GraphComponent$1.prototype, {\n  \tsetVisited: function setVisited(isVisited) {\n  \t\tthis._isVisited = isVisited;\n  \t},\n  \tisMarked: function isMarked() {\n  \t\treturn this._isMarked;\n  \t},\n  \tsetData: function setData(data) {\n  \t\tthis._data = data;\n  \t},\n  \tgetData: function getData() {\n  \t\treturn this._data;\n  \t},\n  \tsetMarked: function setMarked(isMarked) {\n  \t\tthis._isMarked = isMarked;\n  \t},\n  \tgetContext: function getContext() {\n  \t\treturn this._data;\n  \t},\n  \tisVisited: function isVisited() {\n  \t\treturn this._isVisited;\n  \t},\n  \tsetContext: function setContext(data) {\n  \t\tthis._data = data;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn GraphComponent$1;\n  \t}\n  });\n  GraphComponent$1.getComponentWithVisitedState = function (i, visitedState) {\n  \twhile (i.hasNext()) {\n  \t\tvar comp = i.next();\n  \t\tif (comp.isVisited() === visitedState) return comp;\n  \t}\n  \treturn null;\n  };\n  GraphComponent$1.setVisited = function (i, visited) {\n  \twhile (i.hasNext()) {\n  \t\tvar comp = i.next();\n  \t\tcomp.setVisited(visited);\n  \t}\n  };\n  GraphComponent$1.setMarked = function (i, marked) {\n  \twhile (i.hasNext()) {\n  \t\tvar comp = i.next();\n  \t\tcomp.setMarked(marked);\n  \t}\n  };\n\n  function DirectedEdge$1() {\n  \tGraphComponent$1.apply(this);\n  \tthis._parentEdge = null;\n  \tthis._from = null;\n  \tthis._to = null;\n  \tthis._p0 = null;\n  \tthis._p1 = null;\n  \tthis._sym = null;\n  \tthis._edgeDirection = null;\n  \tthis._quadrant = null;\n  \tthis._angle = null;\n  \tvar from = arguments[0],\n  \t    to = arguments[1],\n  \t    directionPt = arguments[2],\n  \t    edgeDirection = arguments[3];\n  \tthis._from = from;\n  \tthis._to = to;\n  \tthis._edgeDirection = edgeDirection;\n  \tthis._p0 = from.getCoordinate();\n  \tthis._p1 = directionPt;\n  \tvar dx = this._p1.x - this._p0.x;\n  \tvar dy = this._p1.y - this._p0.y;\n  \tthis._quadrant = Quadrant.quadrant(dx, dy);\n  \tthis._angle = Math.atan2(dy, dx);\n  }\n  inherits$1(DirectedEdge$1, GraphComponent$1);\n  extend(DirectedEdge$1.prototype, {\n  \tisRemoved: function isRemoved() {\n  \t\treturn this._parentEdge === null;\n  \t},\n  \tcompareDirection: function compareDirection(e) {\n  \t\tif (this._quadrant > e._quadrant) return 1;\n  \t\tif (this._quadrant < e._quadrant) return -1;\n  \t\treturn CGAlgorithms.computeOrientation(e._p0, e._p1, this._p1);\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\treturn this._from.getCoordinate();\n  \t},\n  \tprint: function print(out) {\n  \t\tvar className = this.getClass().getName();\n  \t\tvar lastDotPos = className.lastIndexOf('.');\n  \t\tvar name = className.substring(lastDotPos + 1);\n  \t\tout.print(\"  \" + name + \": \" + this._p0 + \" - \" + this._p1 + \" \" + this._quadrant + \":\" + this._angle);\n  \t},\n  \tgetDirectionPt: function getDirectionPt() {\n  \t\treturn this._p1;\n  \t},\n  \tgetAngle: function getAngle() {\n  \t\treturn this._angle;\n  \t},\n  \tcompareTo: function compareTo(obj) {\n  \t\tvar de = obj;\n  \t\treturn this.compareDirection(de);\n  \t},\n  \tgetFromNode: function getFromNode() {\n  \t\treturn this._from;\n  \t},\n  \tgetSym: function getSym() {\n  \t\treturn this._sym;\n  \t},\n  \tsetEdge: function setEdge(parentEdge) {\n  \t\tthis._parentEdge = parentEdge;\n  \t},\n  \tremove: function remove() {\n  \t\tthis._sym = null;\n  \t\tthis._parentEdge = null;\n  \t},\n  \tgetEdge: function getEdge() {\n  \t\treturn this._parentEdge;\n  \t},\n  \tgetQuadrant: function getQuadrant() {\n  \t\treturn this._quadrant;\n  \t},\n  \tsetSym: function setSym(sym) {\n  \t\tthis._sym = sym;\n  \t},\n  \tgetToNode: function getToNode() {\n  \t\treturn this._to;\n  \t},\n  \tgetEdgeDirection: function getEdgeDirection() {\n  \t\treturn this._edgeDirection;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn DirectedEdge$1;\n  \t}\n  });\n  DirectedEdge$1.toEdges = function (dirEdges) {\n  \tvar edges = new ArrayList();\n  \tfor (var i = dirEdges.iterator(); i.hasNext();) {\n  \t\tedges.add(i.next()._parentEdge);\n  \t}\n  \treturn edges;\n  };\n\n  function LineMergeDirectedEdge() {\n  \tvar from = arguments[0],\n  \t    to = arguments[1],\n  \t    directionPt = arguments[2],\n  \t    edgeDirection = arguments[3];\n  \tDirectedEdge$1.call(this, from, to, directionPt, edgeDirection);\n  }\n  inherits$1(LineMergeDirectedEdge, DirectedEdge$1);\n  extend(LineMergeDirectedEdge.prototype, {\n  \tgetNext: function getNext() {\n  \t\tif (this.getToNode().getDegree() !== 2) {\n  \t\t\treturn null;\n  \t\t}\n  \t\tif (this.getToNode().getOutEdges().getEdges().get(0) === this.getSym()) {\n  \t\t\treturn this.getToNode().getOutEdges().getEdges().get(1);\n  \t\t}\n  \t\tAssert.isTrue(this.getToNode().getOutEdges().getEdges().get(1) === this.getSym());\n  \t\treturn this.getToNode().getOutEdges().getEdges().get(0);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LineMergeDirectedEdge;\n  \t}\n  });\n\n  function Edge$1() {\n  \tGraphComponent$1.apply(this);\n  \tthis._dirEdge = null;\n  \tif (arguments.length === 0) ; else if (arguments.length === 2) {\n  \t\tvar de0 = arguments[0],\n  \t\t    de1 = arguments[1];\n  \t\tthis.setDirectedEdges(de0, de1);\n  \t}\n  }\n  inherits$1(Edge$1, GraphComponent$1);\n  extend(Edge$1.prototype, {\n  \tisRemoved: function isRemoved() {\n  \t\treturn this._dirEdge === null;\n  \t},\n  \tsetDirectedEdges: function setDirectedEdges(de0, de1) {\n  \t\tthis._dirEdge = [de0, de1];\n  \t\tde0.setEdge(this);\n  \t\tde1.setEdge(this);\n  \t\tde0.setSym(de1);\n  \t\tde1.setSym(de0);\n  \t\tde0.getFromNode().addOutEdge(de0);\n  \t\tde1.getFromNode().addOutEdge(de1);\n  \t},\n  \tgetDirEdge: function getDirEdge() {\n  \t\tif (Number.isInteger(arguments[0])) {\n  \t\t\tvar i = arguments[0];\n  \t\t\treturn this._dirEdge[i];\n  \t\t} else if (arguments[0] instanceof Node$3) {\n  \t\t\tvar fromNode = arguments[0];\n  \t\t\tif (this._dirEdge[0].getFromNode() === fromNode) return this._dirEdge[0];\n  \t\t\tif (this._dirEdge[1].getFromNode() === fromNode) return this._dirEdge[1];\n  \t\t\treturn null;\n  \t\t}\n  \t},\n  \tremove: function remove() {\n  \t\tthis._dirEdge = null;\n  \t},\n  \tgetOppositeNode: function getOppositeNode(node) {\n  \t\tif (this._dirEdge[0].getFromNode() === node) return this._dirEdge[0].getToNode();\n  \t\tif (this._dirEdge[1].getFromNode() === node) return this._dirEdge[1].getToNode();\n  \t\treturn null;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Edge$1;\n  \t}\n  });\n\n  function DirectedEdgeStar$1() {\n  \tthis._outEdges = new ArrayList();\n  \tthis._sorted = false;\n  }\n  extend(DirectedEdgeStar$1.prototype, {\n  \tgetNextEdge: function getNextEdge(dirEdge) {\n  \t\tvar i = this.getIndex(dirEdge);\n  \t\treturn this._outEdges.get(this.getIndex(i + 1));\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\tvar it = this.iterator();\n  \t\tif (!it.hasNext()) return null;\n  \t\tvar e = it.next();\n  \t\treturn e.getCoordinate();\n  \t},\n  \titerator: function iterator() {\n  \t\tthis.sortEdges();\n  \t\treturn this._outEdges.iterator();\n  \t},\n  \tsortEdges: function sortEdges() {\n  \t\tif (!this._sorted) {\n  \t\t\tCollections.sort(this._outEdges);\n  \t\t\tthis._sorted = true;\n  \t\t}\n  \t},\n  \tremove: function remove(de) {\n  \t\tthis._outEdges.remove(de);\n  \t},\n  \tgetEdges: function getEdges() {\n  \t\tthis.sortEdges();\n  \t\treturn this._outEdges;\n  \t},\n  \tgetNextCWEdge: function getNextCWEdge(dirEdge) {\n  \t\tvar i = this.getIndex(dirEdge);\n  \t\treturn this._outEdges.get(this.getIndex(i - 1));\n  \t},\n  \tgetIndex: function getIndex() {\n  \t\tif (arguments[0] instanceof Edge$1) {\n  \t\t\tvar edge = arguments[0];\n  \t\t\tthis.sortEdges();\n  \t\t\tfor (var i = 0; i < this._outEdges.size(); i++) {\n  \t\t\t\tvar de = this._outEdges.get(i);\n  \t\t\t\tif (de.getEdge() === edge) return i;\n  \t\t\t}\n  \t\t\treturn -1;\n  \t\t} else if (arguments[0] instanceof DirectedEdge$1) {\n  \t\t\tvar dirEdge = arguments[0];\n  \t\t\tthis.sortEdges();\n  \t\t\tfor (var i = 0; i < this._outEdges.size(); i++) {\n  \t\t\t\tvar de = this._outEdges.get(i);\n  \t\t\t\tif (de === dirEdge) return i;\n  \t\t\t}\n  \t\t\treturn -1;\n  \t\t} else if (Number.isInteger(arguments[0])) {\n  \t\t\tvar i = arguments[0];\n  \t\t\tvar modi = i % this._outEdges.size();\n  \t\t\tif (modi < 0) modi += this._outEdges.size();\n  \t\t\treturn modi;\n  \t\t}\n  \t},\n  \tadd: function add(de) {\n  \t\tthis._outEdges.add(de);\n  \t\tthis._sorted = false;\n  \t},\n  \tgetDegree: function getDegree() {\n  \t\treturn this._outEdges.size();\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn DirectedEdgeStar$1;\n  \t}\n  });\n\n  function Node$3() {\n  \tGraphComponent$1.apply(this);\n  \tthis._pt = null;\n  \tthis._deStar = null;\n  \tif (arguments.length === 1) {\n  \t\tvar pt = arguments[0];\n  \t\tNode$3.call(this, pt, new DirectedEdgeStar$1());\n  \t} else if (arguments.length === 2) {\n  \t\tvar pt = arguments[0],\n  \t\t    deStar = arguments[1];\n  \t\tthis._pt = pt;\n  \t\tthis._deStar = deStar;\n  \t}\n  }\n  inherits$1(Node$3, GraphComponent$1);\n  extend(Node$3.prototype, {\n  \tisRemoved: function isRemoved() {\n  \t\treturn this._pt === null;\n  \t},\n  \taddOutEdge: function addOutEdge(de) {\n  \t\tthis._deStar.add(de);\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\treturn this._pt;\n  \t},\n  \tgetOutEdges: function getOutEdges() {\n  \t\treturn this._deStar;\n  \t},\n  \tremove: function remove() {\n  \t\tif (arguments.length === 0) {\n  \t\t\tthis._pt = null;\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tvar de = arguments[0];\n  \t\t\tthis._deStar.remove(de);\n  \t\t}\n  \t},\n  \tgetIndex: function getIndex(edge) {\n  \t\treturn this._deStar.getIndex(edge);\n  \t},\n  \tgetDegree: function getDegree() {\n  \t\treturn this._deStar.getDegree();\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Node$3;\n  \t}\n  });\n  Node$3.getEdgesBetween = function (node0, node1) {\n  \tvar edges0 = DirectedEdge$1.toEdges(node0.getOutEdges().getEdges());\n  \tvar commonEdges = new HashSet(edges0);\n  \tvar edges1 = DirectedEdge$1.toEdges(node1.getOutEdges().getEdges());\n  \tcommonEdges.retainAll(edges1);\n  \treturn commonEdges;\n  };\n\n  function LineMergeEdge() {\n  \tEdge$1.apply(this);\n  \tthis._line = null;\n  \tvar line = arguments[0];\n  \tthis._line = line;\n  }\n  inherits$1(LineMergeEdge, Edge$1);\n  extend(LineMergeEdge.prototype, {\n  \tgetLine: function getLine() {\n  \t\treturn this._line;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LineMergeEdge;\n  \t}\n  });\n\n  function NodeMap$1() {\n  \tthis._nodeMap = new TreeMap();\n  }\n  extend(NodeMap$1.prototype, {\n  \tfind: function find(coord) {\n  \t\treturn this._nodeMap.get(coord);\n  \t},\n  \titerator: function iterator() {\n  \t\treturn this._nodeMap.values().iterator();\n  \t},\n  \tremove: function remove(pt) {\n  \t\treturn this._nodeMap.remove(pt);\n  \t},\n  \tvalues: function values() {\n  \t\treturn this._nodeMap.values();\n  \t},\n  \tadd: function add(n) {\n  \t\tthis._nodeMap.put(n.getCoordinate(), n);\n  \t\treturn n;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn NodeMap$1;\n  \t}\n  });\n\n  function PlanarGraph$1() {\n  \tthis._edges = new HashSet();\n  \tthis._dirEdges = new HashSet();\n  \tthis._nodeMap = new NodeMap$1();\n  }\n  extend(PlanarGraph$1.prototype, {\n  \tfindNodesOfDegree: function findNodesOfDegree(degree) {\n  \t\tvar nodesFound = new ArrayList();\n  \t\tfor (var i = this.nodeIterator(); i.hasNext();) {\n  \t\t\tvar node = i.next();\n  \t\t\tif (node.getDegree() === degree) nodesFound.add(node);\n  \t\t}\n  \t\treturn nodesFound;\n  \t},\n  \tdirEdgeIterator: function dirEdgeIterator() {\n  \t\treturn this._dirEdges.iterator();\n  \t},\n  \tedgeIterator: function edgeIterator() {\n  \t\treturn this._edges.iterator();\n  \t},\n  \tremove: function remove() {\n  \t\tif (arguments[0] instanceof Edge$1) {\n  \t\t\tvar edge = arguments[0];\n  \t\t\tthis.remove(edge.getDirEdge(0));\n  \t\t\tthis.remove(edge.getDirEdge(1));\n  \t\t\tthis._edges.remove(edge);\n  \t\t\tedge.remove();\n  \t\t} else if (arguments[0] instanceof DirectedEdge$1) {\n  \t\t\tvar de = arguments[0];\n  \t\t\tvar sym = de.getSym();\n  \t\t\tif (sym !== null) sym.setSym(null);\n  \t\t\tde.getFromNode().remove(de);\n  \t\t\tde.remove();\n  \t\t\tthis._dirEdges.remove(de);\n  \t\t} else if (arguments[0] instanceof Node$3) {\n  \t\t\tvar node = arguments[0];\n  \t\t\tvar outEdges = node.getOutEdges().getEdges();\n  \t\t\tfor (var i = outEdges.iterator(); i.hasNext();) {\n  \t\t\t\tvar de = i.next();\n  \t\t\t\tvar sym = de.getSym();\n  \t\t\t\tif (sym !== null) this.remove(sym);\n  \t\t\t\tthis._dirEdges.remove(de);\n  \t\t\t\tvar edge = de.getEdge();\n  \t\t\t\tif (edge !== null) {\n  \t\t\t\t\tthis._edges.remove(edge);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\tthis._nodeMap.remove(node.getCoordinate());\n  \t\t\tnode.remove();\n  \t\t}\n  \t},\n  \tfindNode: function findNode(pt) {\n  \t\treturn this._nodeMap.find(pt);\n  \t},\n  \tgetEdges: function getEdges() {\n  \t\treturn this._edges;\n  \t},\n  \tnodeIterator: function nodeIterator() {\n  \t\treturn this._nodeMap.iterator();\n  \t},\n  \tcontains: function contains() {\n  \t\tif (arguments[0] instanceof Edge$1) {\n  \t\t\tvar e = arguments[0];\n  \t\t\treturn this._edges.contains(e);\n  \t\t} else if (arguments[0] instanceof DirectedEdge$1) {\n  \t\t\tvar de = arguments[0];\n  \t\t\treturn this._dirEdges.contains(de);\n  \t\t}\n  \t},\n  \tadd: function add() {\n  \t\tif (arguments[0] instanceof Node$3) {\n  \t\t\tvar node = arguments[0];\n  \t\t\tthis._nodeMap.add(node);\n  \t\t} else if (arguments[0] instanceof Edge$1) {\n  \t\t\tvar edge = arguments[0];\n  \t\t\tthis._edges.add(edge);\n  \t\t\tthis.add(edge.getDirEdge(0));\n  \t\t\tthis.add(edge.getDirEdge(1));\n  \t\t} else if (arguments[0] instanceof DirectedEdge$1) {\n  \t\t\tvar dirEdge = arguments[0];\n  \t\t\tthis._dirEdges.add(dirEdge);\n  \t\t}\n  \t},\n  \tgetNodes: function getNodes() {\n  \t\treturn this._nodeMap.values();\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn PlanarGraph$1;\n  \t}\n  });\n\n  function LineMergeGraph() {\n  \tPlanarGraph$1.apply(this);\n  }\n  inherits$1(LineMergeGraph, PlanarGraph$1);\n  extend(LineMergeGraph.prototype, {\n  \taddEdge: function addEdge(lineString) {\n  \t\tif (lineString.isEmpty()) {\n  \t\t\treturn null;\n  \t\t}\n  \t\tvar coordinates = CoordinateArrays.removeRepeatedPoints(lineString.getCoordinates());\n  \t\tif (coordinates.length <= 1) return null;\n  \t\tvar startCoordinate = coordinates[0];\n  \t\tvar endCoordinate = coordinates[coordinates.length - 1];\n  \t\tvar startNode = this.getNode(startCoordinate);\n  \t\tvar endNode = this.getNode(endCoordinate);\n  \t\tvar directedEdge0 = new LineMergeDirectedEdge(startNode, endNode, coordinates[1], true);\n  \t\tvar directedEdge1 = new LineMergeDirectedEdge(endNode, startNode, coordinates[coordinates.length - 2], false);\n  \t\tvar edge = new LineMergeEdge(lineString);\n  \t\tedge.setDirectedEdges(directedEdge0, directedEdge1);\n  \t\tthis.add(edge);\n  \t},\n  \tgetNode: function getNode(coordinate) {\n  \t\tvar node = this.findNode(coordinate);\n  \t\tif (node === null) {\n  \t\t\tnode = new Node$3(coordinate);\n  \t\t\tthis.add(node);\n  \t\t}\n  \t\treturn node;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LineMergeGraph;\n  \t}\n  });\n\n  function LineMerger() {\n  \tthis._graph = new LineMergeGraph();\n  \tthis._mergedLineStrings = null;\n  \tthis._factory = null;\n  \tthis._edgeStrings = null;\n  }\n  extend(LineMerger.prototype, {\n  \tbuildEdgeStringsForUnprocessedNodes: function buildEdgeStringsForUnprocessedNodes() {\n  \t\tfor (var i = this._graph.getNodes().iterator(); i.hasNext();) {\n  \t\t\tvar node = i.next();\n  \t\t\tif (!node.isMarked()) {\n  \t\t\t\tAssert.isTrue(node.getDegree() === 2);\n  \t\t\t\tthis.buildEdgeStringsStartingAt(node);\n  \t\t\t\tnode.setMarked(true);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tbuildEdgeStringsForNonDegree2Nodes: function buildEdgeStringsForNonDegree2Nodes() {\n  \t\tfor (var i = this._graph.getNodes().iterator(); i.hasNext();) {\n  \t\t\tvar node = i.next();\n  \t\t\tif (node.getDegree() !== 2) {\n  \t\t\t\tthis.buildEdgeStringsStartingAt(node);\n  \t\t\t\tnode.setMarked(true);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tbuildEdgeStringsForObviousStartNodes: function buildEdgeStringsForObviousStartNodes() {\n  \t\tthis.buildEdgeStringsForNonDegree2Nodes();\n  \t},\n  \tgetMergedLineStrings: function getMergedLineStrings() {\n  \t\tthis.merge();\n  \t\treturn this._mergedLineStrings;\n  \t},\n  \tbuildEdgeStringsStartingAt: function buildEdgeStringsStartingAt(node) {\n  \t\tfor (var i = node.getOutEdges().iterator(); i.hasNext();) {\n  \t\t\tvar directedEdge = i.next();\n  \t\t\tif (directedEdge.getEdge().isMarked()) {\n  \t\t\t\tcontinue;\n  \t\t\t}\n  \t\t\tthis._edgeStrings.add(this.buildEdgeStringStartingWith(directedEdge));\n  \t\t}\n  \t},\n  \tmerge: function merge() {\n  \t\tif (this._mergedLineStrings !== null) {\n  \t\t\treturn null;\n  \t\t}\n  \t\tGraphComponent$1.setMarked(this._graph.nodeIterator(), false);\n  \t\tGraphComponent$1.setMarked(this._graph.edgeIterator(), false);\n  \t\tthis._edgeStrings = new ArrayList();\n  \t\tthis.buildEdgeStringsForObviousStartNodes();\n  \t\tthis.buildEdgeStringsForIsolatedLoops();\n  \t\tthis._mergedLineStrings = new ArrayList();\n  \t\tfor (var i = this._edgeStrings.iterator(); i.hasNext();) {\n  \t\t\tvar edgeString = i.next();\n  \t\t\tthis._mergedLineStrings.add(edgeString.toLineString());\n  \t\t}\n  \t},\n  \tbuildEdgeStringStartingWith: function buildEdgeStringStartingWith(start) {\n  \t\tvar edgeString = new EdgeString(this._factory);\n  \t\tvar current = start;\n  \t\tdo {\n  \t\t\tedgeString.add(current);\n  \t\t\tcurrent.getEdge().setMarked(true);\n  \t\t\tcurrent = current.getNext();\n  \t\t} while (current !== null && current !== start);\n  \t\treturn edgeString;\n  \t},\n  \tadd: function add() {\n  \t\tif (arguments[0] instanceof Geometry) {\n  \t\t\tvar geometry = arguments[0];\n  \t\t\tgeometry.apply({\n  \t\t\t\tinterfaces_: function interfaces_() {\n  \t\t\t\t\treturn [GeometryComponentFilter];\n  \t\t\t\t},\n  \t\t\t\tfilter: function filter(component) {\n  \t\t\t\t\tif (component instanceof LineString) {\n  \t\t\t\t\t\tthis.add(component);\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t});\n  \t\t} else if (hasInterface(arguments[0], Collection)) {\n  \t\t\tvar geometries = arguments[0];\n  \t\t\tthis._mergedLineStrings = null;\n  \t\t\tfor (var i = geometries.iterator(); i.hasNext();) {\n  \t\t\t\tvar geometry = i.next();\n  \t\t\t\tthis.add(geometry);\n  \t\t\t}\n  \t\t} else if (arguments[0] instanceof LineString) {\n  \t\t\tvar lineString = arguments[0];\n  \t\t\tif (this._factory === null) {\n  \t\t\t\tthis._factory = lineString.getFactory();\n  \t\t\t}\n  \t\t\tthis._graph.addEdge(lineString);\n  \t\t}\n  \t},\n  \tbuildEdgeStringsForIsolatedLoops: function buildEdgeStringsForIsolatedLoops() {\n  \t\tthis.buildEdgeStringsForUnprocessedNodes();\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LineMerger;\n  \t}\n  });\n\n  function PolygonizeDirectedEdge() {\n  \tthis._edgeRing = null;\n  \tthis._next = null;\n  \tthis._label = -1;\n  \tvar from = arguments[0],\n  \t    to = arguments[1],\n  \t    directionPt = arguments[2],\n  \t    edgeDirection = arguments[3];\n  \tDirectedEdge$1.call(this, from, to, directionPt, edgeDirection);\n  }\n  inherits$1(PolygonizeDirectedEdge, DirectedEdge$1);\n  extend(PolygonizeDirectedEdge.prototype, {\n  \tgetNext: function getNext() {\n  \t\treturn this._next;\n  \t},\n  \tisInRing: function isInRing() {\n  \t\treturn this._edgeRing !== null;\n  \t},\n  \tsetRing: function setRing(edgeRing) {\n  \t\tthis._edgeRing = edgeRing;\n  \t},\n  \tsetLabel: function setLabel(label) {\n  \t\tthis._label = label;\n  \t},\n  \tgetLabel: function getLabel() {\n  \t\treturn this._label;\n  \t},\n  \tsetNext: function setNext(next) {\n  \t\tthis._next = next;\n  \t},\n  \tgetRing: function getRing() {\n  \t\treturn this._edgeRing;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn PolygonizeDirectedEdge;\n  \t}\n  });\n\n  function PolygonizeEdge() {\n  \tEdge$1.apply(this);\n  \tthis._line = null;\n  \tvar line = arguments[0];\n  \tthis._line = line;\n  }\n  inherits$1(PolygonizeEdge, Edge$1);\n  extend(PolygonizeEdge.prototype, {\n  \tgetLine: function getLine() {\n  \t\treturn this._line;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn PolygonizeEdge;\n  \t}\n  });\n\n  function ConnectedInteriorTester() {\n  \tthis._geometryFactory = new GeometryFactory();\n  \tthis._geomGraph = null;\n  \tthis._disconnectedRingcoord = null;\n  \tvar geomGraph = arguments[0];\n  \tthis._geomGraph = geomGraph;\n  }\n  extend(ConnectedInteriorTester.prototype, {\n  \tvisitInteriorRing: function visitInteriorRing(ring, graph) {\n  \t\tvar pts = ring.getCoordinates();\n  \t\tvar pt0 = pts[0];\n  \t\tvar pt1 = ConnectedInteriorTester.findDifferentPoint(pts, pt0);\n  \t\tvar e = graph.findEdgeInSameDirection(pt0, pt1);\n  \t\tvar de = graph.findEdgeEnd(e);\n  \t\tvar intDe = null;\n  \t\tif (de.getLabel().getLocation(0, Position.RIGHT) === Location.INTERIOR) {\n  \t\t\tintDe = de;\n  \t\t} else if (de.getSym().getLabel().getLocation(0, Position.RIGHT) === Location.INTERIOR) {\n  \t\t\tintDe = de.getSym();\n  \t\t}\n  \t\tAssert.isTrue(intDe !== null, \"unable to find dirEdge with Interior on RHS\");\n  \t\tthis.visitLinkedDirectedEdges(intDe);\n  \t},\n  \tvisitShellInteriors: function visitShellInteriors(g, graph) {\n  \t\tif (g instanceof Polygon) {\n  \t\t\tvar p = g;\n  \t\t\tthis.visitInteriorRing(p.getExteriorRing(), graph);\n  \t\t}\n  \t\tif (g instanceof MultiPolygon) {\n  \t\t\tvar mp = g;\n  \t\t\tfor (var i = 0; i < mp.getNumGeometries(); i++) {\n  \t\t\t\tvar p = mp.getGeometryN(i);\n  \t\t\t\tthis.visitInteriorRing(p.getExteriorRing(), graph);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\treturn this._disconnectedRingcoord;\n  \t},\n  \tsetInteriorEdgesInResult: function setInteriorEdgesInResult(graph) {\n  \t\tfor (var it = graph.getEdgeEnds().iterator(); it.hasNext();) {\n  \t\t\tvar de = it.next();\n  \t\t\tif (de.getLabel().getLocation(0, Position.RIGHT) === Location.INTERIOR) {\n  \t\t\t\tde.setInResult(true);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tvisitLinkedDirectedEdges: function visitLinkedDirectedEdges(start) {\n  \t\tvar startDe = start;\n  \t\tvar de = start;\n  \t\tdo {\n  \t\t\tAssert.isTrue(de !== null, \"found null Directed Edge\");\n  \t\t\tde.setVisited(true);\n  \t\t\tde = de.getNext();\n  \t\t} while (de !== startDe);\n  \t},\n  \tbuildEdgeRings: function buildEdgeRings(dirEdges) {\n  \t\tvar edgeRings = new ArrayList();\n  \t\tfor (var it = dirEdges.iterator(); it.hasNext();) {\n  \t\t\tvar de = it.next();\n  \t\t\tif (de.isInResult() && de.getEdgeRing() === null) {\n  \t\t\t\tvar er = new MaximalEdgeRing(de, this._geometryFactory);\n  \t\t\t\ter.linkDirectedEdgesForMinimalEdgeRings();\n  \t\t\t\tvar minEdgeRings = er.buildMinimalRings();\n  \t\t\t\tedgeRings.addAll(minEdgeRings);\n  \t\t\t}\n  \t\t}\n  \t\treturn edgeRings;\n  \t},\n  \thasUnvisitedShellEdge: function hasUnvisitedShellEdge(edgeRings) {\n  \t\tfor (var i = 0; i < edgeRings.size(); i++) {\n  \t\t\tvar er = edgeRings.get(i);\n  \t\t\tif (er.isHole()) continue;\n  \t\t\tvar edges = er.getEdges();\n  \t\t\tvar de = edges.get(0);\n  \t\t\tif (de.getLabel().getLocation(0, Position.RIGHT) !== Location.INTERIOR) continue;\n  \t\t\tfor (var j = 0; j < edges.size(); j++) {\n  \t\t\t\tde = edges.get(j);\n  \t\t\t\tif (!de.isVisited()) {\n  \t\t\t\t\tthis._disconnectedRingcoord = de.getCoordinate();\n  \t\t\t\t\treturn true;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tisInteriorsConnected: function isInteriorsConnected() {\n  \t\tvar splitEdges = new ArrayList();\n  \t\tthis._geomGraph.computeSplitEdges(splitEdges);\n  \t\tvar graph = new PlanarGraph(new OverlayNodeFactory());\n  \t\tgraph.addEdges(splitEdges);\n  \t\tthis.setInteriorEdgesInResult(graph);\n  \t\tgraph.linkResultDirectedEdges();\n  \t\tvar edgeRings = this.buildEdgeRings(graph.getEdgeEnds());\n  \t\tthis.visitShellInteriors(this._geomGraph.getGeometry(), graph);\n  \t\treturn !this.hasUnvisitedShellEdge(edgeRings);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn ConnectedInteriorTester;\n  \t}\n  });\n  ConnectedInteriorTester.findDifferentPoint = function (coord, pt) {\n  \tfor (var i = 0; i < coord.length; i++) {\n  \t\tif (!coord[i].equals(pt)) return coord[i];\n  \t}\n  \treturn null;\n  };\n\n  function EdgeEndBuilder() {}\n  extend(EdgeEndBuilder.prototype, {\n  \tcreateEdgeEndForNext: function createEdgeEndForNext(edge, l, eiCurr, eiNext) {\n  \t\tvar iNext = eiCurr.segmentIndex + 1;\n  \t\tif (iNext >= edge.getNumPoints() && eiNext === null) return null;\n  \t\tvar pNext = edge.getCoordinate(iNext);\n  \t\tif (eiNext !== null && eiNext.segmentIndex === eiCurr.segmentIndex) pNext = eiNext.coord;\n  \t\tvar e = new EdgeEnd(edge, eiCurr.coord, pNext, new Label(edge.getLabel()));\n  \t\tl.add(e);\n  \t},\n  \tcreateEdgeEndForPrev: function createEdgeEndForPrev(edge, l, eiCurr, eiPrev) {\n  \t\tvar iPrev = eiCurr.segmentIndex;\n  \t\tif (eiCurr.dist === 0.0) {\n  \t\t\tif (iPrev === 0) return null;\n  \t\t\tiPrev--;\n  \t\t}\n  \t\tvar pPrev = edge.getCoordinate(iPrev);\n  \t\tif (eiPrev !== null && eiPrev.segmentIndex >= iPrev) pPrev = eiPrev.coord;\n  \t\tvar label = new Label(edge.getLabel());\n  \t\tlabel.flip();\n  \t\tvar e = new EdgeEnd(edge, eiCurr.coord, pPrev, label);\n  \t\tl.add(e);\n  \t},\n  \tcomputeEdgeEnds: function computeEdgeEnds() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar edges = arguments[0];\n  \t\t\tvar l = new ArrayList();\n  \t\t\tfor (var i = edges; i.hasNext();) {\n  \t\t\t\tvar e = i.next();\n  \t\t\t\tthis.computeEdgeEnds(e, l);\n  \t\t\t}\n  \t\t\treturn l;\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar edge = arguments[0],\n  \t\t\t    l = arguments[1];\n  \t\t\tvar eiList = edge.getEdgeIntersectionList();\n  \t\t\teiList.addEndpoints();\n  \t\t\tvar it = eiList.iterator();\n  \t\t\tvar eiPrev = null;\n  \t\t\tvar eiCurr = null;\n  \t\t\tif (!it.hasNext()) return null;\n  \t\t\tvar eiNext = it.next();\n  \t\t\tdo {\n  \t\t\t\teiPrev = eiCurr;\n  \t\t\t\teiCurr = eiNext;\n  \t\t\t\teiNext = null;\n  \t\t\t\tif (it.hasNext()) eiNext = it.next();\n  \t\t\t\tif (eiCurr !== null) {\n  \t\t\t\t\tthis.createEdgeEndForPrev(edge, l, eiCurr, eiPrev);\n  \t\t\t\t\tthis.createEdgeEndForNext(edge, l, eiCurr, eiNext);\n  \t\t\t\t}\n  \t\t\t} while (eiCurr !== null);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn EdgeEndBuilder;\n  \t}\n  });\n\n  function EdgeEndBundle() {\n  \tthis._edgeEnds = new ArrayList();\n  \tif (arguments.length === 1) {\n  \t\tvar e = arguments[0];\n  \t\tEdgeEndBundle.call(this, null, e);\n  \t} else if (arguments.length === 2) {\n  \t\tvar e = arguments[1];\n  \t\tEdgeEnd.call(this, e.getEdge(), e.getCoordinate(), e.getDirectedCoordinate(), new Label(e.getLabel()));\n  \t\tthis.insert(e);\n  \t}\n  }\n  inherits$1(EdgeEndBundle, EdgeEnd);\n  extend(EdgeEndBundle.prototype, {\n  \tinsert: function insert(e) {\n  \t\tthis._edgeEnds.add(e);\n  \t},\n  \tprint: function print(out) {\n  \t\tout.println(\"EdgeEndBundle--> Label: \" + this._label);\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar ee = it.next();\n  \t\t\tee.print(out);\n  \t\t\tout.println();\n  \t\t}\n  \t},\n  \titerator: function iterator() {\n  \t\treturn this._edgeEnds.iterator();\n  \t},\n  \tgetEdgeEnds: function getEdgeEnds() {\n  \t\treturn this._edgeEnds;\n  \t},\n  \tcomputeLabelOn: function computeLabelOn(geomIndex, boundaryNodeRule) {\n  \t\tvar boundaryCount = 0;\n  \t\tvar foundInterior = false;\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar e = it.next();\n  \t\t\tvar loc = e.getLabel().getLocation(geomIndex);\n  \t\t\tif (loc === Location.BOUNDARY) boundaryCount++;\n  \t\t\tif (loc === Location.INTERIOR) foundInterior = true;\n  \t\t}\n  \t\tvar loc = Location.NONE;\n  \t\tif (foundInterior) loc = Location.INTERIOR;\n  \t\tif (boundaryCount > 0) {\n  \t\t\tloc = GeometryGraph.determineBoundary(boundaryNodeRule, boundaryCount);\n  \t\t}\n  \t\tthis._label.setLocation(geomIndex, loc);\n  \t},\n  \tcomputeLabelSide: function computeLabelSide(geomIndex, side) {\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar e = it.next();\n  \t\t\tif (e.getLabel().isArea()) {\n  \t\t\t\tvar loc = e.getLabel().getLocation(geomIndex, side);\n  \t\t\t\tif (loc === Location.INTERIOR) {\n  \t\t\t\t\tthis._label.setLocation(geomIndex, side, Location.INTERIOR);\n  \t\t\t\t\treturn null;\n  \t\t\t\t} else if (loc === Location.EXTERIOR) this._label.setLocation(geomIndex, side, Location.EXTERIOR);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetLabel: function getLabel() {\n  \t\treturn this._label;\n  \t},\n  \tcomputeLabelSides: function computeLabelSides(geomIndex) {\n  \t\tthis.computeLabelSide(geomIndex, Position.LEFT);\n  \t\tthis.computeLabelSide(geomIndex, Position.RIGHT);\n  \t},\n  \tupdateIM: function updateIM(im) {\n  \t\tEdge.updateIM(this._label, im);\n  \t},\n  \tcomputeLabel: function computeLabel(boundaryNodeRule) {\n  \t\tvar isArea = false;\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar e = it.next();\n  \t\t\tif (e.getLabel().isArea()) isArea = true;\n  \t\t}\n  \t\tif (isArea) this._label = new Label(Location.NONE, Location.NONE, Location.NONE);else this._label = new Label(Location.NONE);\n  \t\tfor (var i = 0; i < 2; i++) {\n  \t\t\tthis.computeLabelOn(i, boundaryNodeRule);\n  \t\t\tif (isArea) this.computeLabelSides(i);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn EdgeEndBundle;\n  \t}\n  });\n\n  function EdgeEndBundleStar() {\n  \tEdgeEndStar.apply(this);\n  }\n  inherits$1(EdgeEndBundleStar, EdgeEndStar);\n  extend(EdgeEndBundleStar.prototype, {\n  \tupdateIM: function updateIM(im) {\n  \t\tfor (var it = this.iterator(); it.hasNext();) {\n  \t\t\tvar esb = it.next();\n  \t\t\tesb.updateIM(im);\n  \t\t}\n  \t},\n  \tinsert: function insert(e) {\n  \t\tvar eb = this._edgeMap.get(e);\n  \t\tif (eb === null) {\n  \t\t\teb = new EdgeEndBundle(e);\n  \t\t\tthis.insertEdgeEnd(e, eb);\n  \t\t} else {\n  \t\t\teb.insert(e);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn EdgeEndBundleStar;\n  \t}\n  });\n\n  function RelateNode() {\n  \tvar coord = arguments[0],\n  \t    edges = arguments[1];\n  \tNode.call(this, coord, edges);\n  }\n  inherits$1(RelateNode, Node);\n  extend(RelateNode.prototype, {\n  \tupdateIMFromEdges: function updateIMFromEdges(im) {\n  \t\tthis._edges.updateIM(im);\n  \t},\n  \tcomputeIM: function computeIM(im) {\n  \t\tim.setAtLeastIfValid(this._label.getLocation(0), this._label.getLocation(1), 0);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn RelateNode;\n  \t}\n  });\n\n  function RelateNodeFactory() {\n  \tNodeFactory.apply(this);\n  }\n  inherits$1(RelateNodeFactory, NodeFactory);\n  extend(RelateNodeFactory.prototype, {\n  \tcreateNode: function createNode(coord) {\n  \t\treturn new RelateNode(coord, new EdgeEndBundleStar());\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn RelateNodeFactory;\n  \t}\n  });\n\n  function RelateNodeGraph() {\n  \tthis._nodes = new NodeMap(new RelateNodeFactory());\n  }\n  extend(RelateNodeGraph.prototype, {\n  \tinsertEdgeEnds: function insertEdgeEnds(ee) {\n  \t\tfor (var i = ee.iterator(); i.hasNext();) {\n  \t\t\tvar e = i.next();\n  \t\t\tthis._nodes.add(e);\n  \t\t}\n  \t},\n  \tgetNodeIterator: function getNodeIterator() {\n  \t\treturn this._nodes.iterator();\n  \t},\n  \tcopyNodesAndLabels: function copyNodesAndLabels(geomGraph, argIndex) {\n  \t\tfor (var nodeIt = geomGraph.getNodeIterator(); nodeIt.hasNext();) {\n  \t\t\tvar graphNode = nodeIt.next();\n  \t\t\tvar newNode = this._nodes.addNode(graphNode.getCoordinate());\n  \t\t\tnewNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));\n  \t\t}\n  \t},\n  \tbuild: function build(geomGraph) {\n  \t\tthis.computeIntersectionNodes(geomGraph, 0);\n  \t\tthis.copyNodesAndLabels(geomGraph, 0);\n  \t\tvar eeBuilder = new EdgeEndBuilder();\n  \t\tvar eeList = eeBuilder.computeEdgeEnds(geomGraph.getEdgeIterator());\n  \t\tthis.insertEdgeEnds(eeList);\n  \t},\n  \tcomputeIntersectionNodes: function computeIntersectionNodes(geomGraph, argIndex) {\n  \t\tfor (var edgeIt = geomGraph.getEdgeIterator(); edgeIt.hasNext();) {\n  \t\t\tvar e = edgeIt.next();\n  \t\t\tvar eLoc = e.getLabel().getLocation(argIndex);\n  \t\t\tfor (var eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext();) {\n  \t\t\t\tvar ei = eiIt.next();\n  \t\t\t\tvar n = this._nodes.addNode(ei.coord);\n  \t\t\t\tif (eLoc === Location.BOUNDARY) n.setLabelBoundary(argIndex);else {\n  \t\t\t\t\tif (n.getLabel().isNull(argIndex)) n.setLabel(argIndex, Location.INTERIOR);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn RelateNodeGraph;\n  \t}\n  });\n\n  function ConsistentAreaTester() {\n  \tthis._li = new RobustLineIntersector();\n  \tthis._geomGraph = null;\n  \tthis._nodeGraph = new RelateNodeGraph();\n  \tthis._invalidPoint = null;\n  \tvar geomGraph = arguments[0];\n  \tthis._geomGraph = geomGraph;\n  }\n  extend(ConsistentAreaTester.prototype, {\n  \tisNodeEdgeAreaLabelsConsistent: function isNodeEdgeAreaLabelsConsistent() {\n  \t\tfor (var nodeIt = this._nodeGraph.getNodeIterator(); nodeIt.hasNext();) {\n  \t\t\tvar node = nodeIt.next();\n  \t\t\tif (!node.getEdges().isAreaLabelsConsistent(this._geomGraph)) {\n  \t\t\t\tthis._invalidPoint = node.getCoordinate().copy();\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t}\n  \t\treturn true;\n  \t},\n  \tgetInvalidPoint: function getInvalidPoint() {\n  \t\treturn this._invalidPoint;\n  \t},\n  \thasDuplicateRings: function hasDuplicateRings() {\n  \t\tfor (var nodeIt = this._nodeGraph.getNodeIterator(); nodeIt.hasNext();) {\n  \t\t\tvar node = nodeIt.next();\n  \t\t\tfor (var i = node.getEdges().iterator(); i.hasNext();) {\n  \t\t\t\tvar eeb = i.next();\n  \t\t\t\tif (eeb.getEdgeEnds().size() > 1) {\n  \t\t\t\t\tthis._invalidPoint = eeb.getEdge().getCoordinate(0);\n  \t\t\t\t\treturn true;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tisNodeConsistentArea: function isNodeConsistentArea() {\n  \t\tvar intersector = this._geomGraph.computeSelfNodes(this._li, true, true);\n  \t\tif (intersector.hasProperIntersection()) {\n  \t\t\tthis._invalidPoint = intersector.getProperIntersectionPoint();\n  \t\t\treturn false;\n  \t\t}\n  \t\tthis._nodeGraph.build(this._geomGraph);\n  \t\treturn this.isNodeEdgeAreaLabelsConsistent();\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn ConsistentAreaTester;\n  \t}\n  });\n\n  function IndexedNestedRingTester() {\n  \tthis._graph = null;\n  \tthis._rings = new ArrayList();\n  \tthis._totalEnv = new Envelope();\n  \tthis._index = null;\n  \tthis._nestedPt = null;\n  \tvar graph = arguments[0];\n  \tthis._graph = graph;\n  }\n  extend(IndexedNestedRingTester.prototype, {\n  \tbuildIndex: function buildIndex() {\n  \t\tthis._index = new STRtree();\n  \t\tfor (var i = 0; i < this._rings.size(); i++) {\n  \t\t\tvar ring = this._rings.get(i);\n  \t\t\tvar env = ring.getEnvelopeInternal();\n  \t\t\tthis._index.insert(env, ring);\n  \t\t}\n  \t},\n  \tgetNestedPoint: function getNestedPoint() {\n  \t\treturn this._nestedPt;\n  \t},\n  \tisNonNested: function isNonNested() {\n  \t\tthis.buildIndex();\n  \t\tfor (var i = 0; i < this._rings.size(); i++) {\n  \t\t\tvar innerRing = this._rings.get(i);\n  \t\t\tvar innerRingPts = innerRing.getCoordinates();\n  \t\t\tvar results = this._index.query(innerRing.getEnvelopeInternal());\n  \t\t\tfor (var j = 0; j < results.size(); j++) {\n  \t\t\t\tvar searchRing = results.get(j);\n  \t\t\t\tvar searchRingPts = searchRing.getCoordinates();\n  \t\t\t\tif (innerRing === searchRing) continue;\n  \t\t\t\tif (!innerRing.getEnvelopeInternal().intersects(searchRing.getEnvelopeInternal())) continue;\n  \t\t\t\tvar innerRingPt = IsValidOp.findPtNotNode(innerRingPts, searchRing, this._graph);\n  \t\t\t\tif (innerRingPt === null) continue;\n  \t\t\t\tvar isInside = CGAlgorithms.isPointInRing(innerRingPt, searchRingPts);\n  \t\t\t\tif (isInside) {\n  \t\t\t\t\tthis._nestedPt = innerRingPt;\n  \t\t\t\t\treturn false;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\treturn true;\n  \t},\n  \tadd: function add(ring) {\n  \t\tthis._rings.add(ring);\n  \t\tthis._totalEnv.expandToInclude(ring.getEnvelopeInternal());\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn IndexedNestedRingTester;\n  \t}\n  });\n\n  function TopologyValidationError() {\n  \tthis._errorType = null;\n  \tthis._pt = null;\n  \tif (arguments.length === 1) {\n  \t\tvar errorType = arguments[0];\n  \t\tTopologyValidationError.call(this, errorType, null);\n  \t} else if (arguments.length === 2) {\n  \t\tvar errorType = arguments[0],\n  \t\t    pt = arguments[1];\n  \t\tthis._errorType = errorType;\n  \t\tif (pt !== null) this._pt = pt.copy();\n  \t}\n  }\n  extend(TopologyValidationError.prototype, {\n  \tgetErrorType: function getErrorType() {\n  \t\treturn this._errorType;\n  \t},\n  \tgetMessage: function getMessage() {\n  \t\treturn TopologyValidationError.errMsg[this._errorType];\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\treturn this._pt;\n  \t},\n  \ttoString: function toString() {\n  \t\tvar locStr = \"\";\n  \t\tif (this._pt !== null) locStr = \" at or near point \" + this._pt;\n  \t\treturn this.getMessage() + locStr;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn TopologyValidationError;\n  \t}\n  });\n  TopologyValidationError.ERROR = 0;\n  TopologyValidationError.REPEATED_POINT = 1;\n  TopologyValidationError.HOLE_OUTSIDE_SHELL = 2;\n  TopologyValidationError.NESTED_HOLES = 3;\n  TopologyValidationError.DISCONNECTED_INTERIOR = 4;\n  TopologyValidationError.SELF_INTERSECTION = 5;\n  TopologyValidationError.RING_SELF_INTERSECTION = 6;\n  TopologyValidationError.NESTED_SHELLS = 7;\n  TopologyValidationError.DUPLICATE_RINGS = 8;\n  TopologyValidationError.TOO_FEW_POINTS = 9;\n  TopologyValidationError.INVALID_COORDINATE = 10;\n  TopologyValidationError.RING_NOT_CLOSED = 11;\n  TopologyValidationError.errMsg = [\"Topology Validation Error\", \"Repeated Point\", \"Hole lies outside shell\", \"Holes are nested\", \"Interior is disconnected\", \"Self-intersection\", \"Ring Self-intersection\", \"Nested shells\", \"Duplicate Rings\", \"Too few distinct points in geometry component\", \"Invalid Coordinate\", \"Ring is not closed\"];\n\n  function IsValidOp() {\n  \tthis._parentGeometry = null;\n  \tthis._isSelfTouchingRingFormingHoleValid = false;\n  \tthis._validErr = null;\n  \tvar parentGeometry = arguments[0];\n  \tthis._parentGeometry = parentGeometry;\n  }\n  extend(IsValidOp.prototype, {\n  \tcheckInvalidCoordinates: function checkInvalidCoordinates() {\n  \t\tif (arguments[0] instanceof Array) {\n  \t\t\tvar coords = arguments[0];\n  \t\t\tfor (var i = 0; i < coords.length; i++) {\n  \t\t\t\tif (!IsValidOp.isValid(coords[i])) {\n  \t\t\t\t\tthis._validErr = new TopologyValidationError(TopologyValidationError.INVALID_COORDINATE, coords[i]);\n  \t\t\t\t\treturn null;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} else if (arguments[0] instanceof Polygon) {\n  \t\t\tvar poly = arguments[0];\n  \t\t\tthis.checkInvalidCoordinates(poly.getExteriorRing().getCoordinates());\n  \t\t\tif (this._validErr !== null) return null;\n  \t\t\tfor (var i = 0; i < poly.getNumInteriorRing(); i++) {\n  \t\t\t\tthis.checkInvalidCoordinates(poly.getInteriorRingN(i).getCoordinates());\n  \t\t\t\tif (this._validErr !== null) return null;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcheckHolesNotNested: function checkHolesNotNested(p, graph) {\n  \t\tvar nestedTester = new IndexedNestedRingTester(graph);\n  \t\tfor (var i = 0; i < p.getNumInteriorRing(); i++) {\n  \t\t\tvar innerHole = p.getInteriorRingN(i);\n  \t\t\tnestedTester.add(innerHole);\n  \t\t}\n  \t\tvar isNonNested = nestedTester.isNonNested();\n  \t\tif (!isNonNested) {\n  \t\t\tthis._validErr = new TopologyValidationError(TopologyValidationError.NESTED_HOLES, nestedTester.getNestedPoint());\n  \t\t}\n  \t},\n  \tcheckConsistentArea: function checkConsistentArea(graph) {\n  \t\tvar cat = new ConsistentAreaTester(graph);\n  \t\tvar isValidArea = cat.isNodeConsistentArea();\n  \t\tif (!isValidArea) {\n  \t\t\tthis._validErr = new TopologyValidationError(TopologyValidationError.SELF_INTERSECTION, cat.getInvalidPoint());\n  \t\t\treturn null;\n  \t\t}\n  \t\tif (cat.hasDuplicateRings()) {\n  \t\t\tthis._validErr = new TopologyValidationError(TopologyValidationError.DUPLICATE_RINGS, cat.getInvalidPoint());\n  \t\t}\n  \t},\n  \tisValid: function isValid() {\n  \t\tthis.checkValid(this._parentGeometry);\n  \t\treturn this._validErr === null;\n  \t},\n  \tcheckShellInsideHole: function checkShellInsideHole(shell, hole, graph) {\n  \t\tvar shellPts = shell.getCoordinates();\n  \t\tvar holePts = hole.getCoordinates();\n  \t\tvar shellPt = IsValidOp.findPtNotNode(shellPts, hole, graph);\n  \t\tif (shellPt !== null) {\n  \t\t\tvar insideHole = CGAlgorithms.isPointInRing(shellPt, holePts);\n  \t\t\tif (!insideHole) {\n  \t\t\t\treturn shellPt;\n  \t\t\t}\n  \t\t}\n  \t\tvar holePt = IsValidOp.findPtNotNode(holePts, shell, graph);\n  \t\tif (holePt !== null) {\n  \t\t\tvar insideShell = CGAlgorithms.isPointInRing(holePt, shellPts);\n  \t\t\tif (insideShell) {\n  \t\t\t\treturn holePt;\n  \t\t\t}\n  \t\t\treturn null;\n  \t\t}\n  \t\tAssert.shouldNeverReachHere(\"points in shell and hole appear to be equal\");\n  \t\treturn null;\n  \t},\n  \tcheckNoSelfIntersectingRings: function checkNoSelfIntersectingRings(graph) {\n  \t\tfor (var i = graph.getEdgeIterator(); i.hasNext();) {\n  \t\t\tvar e = i.next();\n  \t\t\tthis.checkNoSelfIntersectingRing(e.getEdgeIntersectionList());\n  \t\t\tif (this._validErr !== null) return null;\n  \t\t}\n  \t},\n  \tcheckConnectedInteriors: function checkConnectedInteriors(graph) {\n  \t\tvar cit = new ConnectedInteriorTester(graph);\n  \t\tif (!cit.isInteriorsConnected()) this._validErr = new TopologyValidationError(TopologyValidationError.DISCONNECTED_INTERIOR, cit.getCoordinate());\n  \t},\n  \tcheckNoSelfIntersectingRing: function checkNoSelfIntersectingRing(eiList) {\n  \t\tvar nodeSet = new TreeSet();\n  \t\tvar isFirst = true;\n  \t\tfor (var i = eiList.iterator(); i.hasNext();) {\n  \t\t\tvar ei = i.next();\n  \t\t\tif (isFirst) {\n  \t\t\t\tisFirst = false;\n  \t\t\t\tcontinue;\n  \t\t\t}\n  \t\t\tif (nodeSet.contains(ei.coord)) {\n  \t\t\t\tthis._validErr = new TopologyValidationError(TopologyValidationError.RING_SELF_INTERSECTION, ei.coord);\n  \t\t\t\treturn null;\n  \t\t\t} else {\n  \t\t\t\tnodeSet.add(ei.coord);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcheckHolesInShell: function checkHolesInShell(p, graph) {\n  \t\tvar shell = p.getExteriorRing();\n  \t\tvar pir = new MCPointInRing(shell);\n  \t\tfor (var i = 0; i < p.getNumInteriorRing(); i++) {\n  \t\t\tvar hole = p.getInteriorRingN(i);\n  \t\t\tvar holePt = IsValidOp.findPtNotNode(hole.getCoordinates(), shell, graph);\n  \t\t\tif (holePt === null) return null;\n  \t\t\tvar outside = !pir.isInside(holePt);\n  \t\t\tif (outside) {\n  \t\t\t\tthis._validErr = new TopologyValidationError(TopologyValidationError.HOLE_OUTSIDE_SHELL, holePt);\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcheckTooFewPoints: function checkTooFewPoints(graph) {\n  \t\tif (graph.hasTooFewPoints()) {\n  \t\t\tthis._validErr = new TopologyValidationError(TopologyValidationError.TOO_FEW_POINTS, graph.getInvalidPoint());\n  \t\t\treturn null;\n  \t\t}\n  \t},\n  \tgetValidationError: function getValidationError() {\n  \t\tthis.checkValid(this._parentGeometry);\n  \t\treturn this._validErr;\n  \t},\n  \tcheckValid: function checkValid() {\n  \t\tif (arguments[0] instanceof Point) {\n  \t\t\tvar g = arguments[0];\n  \t\t\tthis.checkInvalidCoordinates(g.getCoordinates());\n  \t\t} else if (arguments[0] instanceof MultiPoint) {\n  \t\t\tvar g = arguments[0];\n  \t\t\tthis.checkInvalidCoordinates(g.getCoordinates());\n  \t\t} else if (arguments[0] instanceof LinearRing) {\n  \t\t\tvar g = arguments[0];\n  \t\t\tthis.checkInvalidCoordinates(g.getCoordinates());\n  \t\t\tif (this._validErr !== null) return null;\n  \t\t\tthis.checkClosedRing(g);\n  \t\t\tif (this._validErr !== null) return null;\n  \t\t\tvar graph = new GeometryGraph(0, g);\n  \t\t\tthis.checkTooFewPoints(graph);\n  \t\t\tif (this._validErr !== null) return null;\n  \t\t\tvar li = new RobustLineIntersector();\n  \t\t\tgraph.computeSelfNodes(li, true, true);\n  \t\t\tthis.checkNoSelfIntersectingRings(graph);\n  \t\t} else if (arguments[0] instanceof LineString) {\n  \t\t\tvar g = arguments[0];\n  \t\t\tthis.checkInvalidCoordinates(g.getCoordinates());\n  \t\t\tif (this._validErr !== null) return null;\n  \t\t\tvar graph = new GeometryGraph(0, g);\n  \t\t\tthis.checkTooFewPoints(graph);\n  \t\t} else if (arguments[0] instanceof Polygon) {\n  \t\t\tvar g = arguments[0];\n  \t\t\tthis.checkInvalidCoordinates(g);\n  \t\t\tif (this._validErr !== null) return null;\n  \t\t\tthis.checkClosedRings(g);\n  \t\t\tif (this._validErr !== null) return null;\n  \t\t\tvar graph = new GeometryGraph(0, g);\n  \t\t\tthis.checkTooFewPoints(graph);\n  \t\t\tif (this._validErr !== null) return null;\n  \t\t\tthis.checkConsistentArea(graph);\n  \t\t\tif (this._validErr !== null) return null;\n  \t\t\tif (!this._isSelfTouchingRingFormingHoleValid) {\n  \t\t\t\tthis.checkNoSelfIntersectingRings(graph);\n  \t\t\t\tif (this._validErr !== null) return null;\n  \t\t\t}\n  \t\t\tthis.checkHolesInShell(g, graph);\n  \t\t\tif (this._validErr !== null) return null;\n  \t\t\tthis.checkHolesNotNested(g, graph);\n  \t\t\tif (this._validErr !== null) return null;\n  \t\t\tthis.checkConnectedInteriors(graph);\n  \t\t} else if (arguments[0] instanceof MultiPolygon) {\n  \t\t\tvar g = arguments[0];\n  \t\t\tfor (var i = 0; i < g.getNumGeometries(); i++) {\n  \t\t\t\tvar p = g.getGeometryN(i);\n  \t\t\t\tthis.checkInvalidCoordinates(p);\n  \t\t\t\tif (this._validErr !== null) return null;\n  \t\t\t\tthis.checkClosedRings(p);\n  \t\t\t\tif (this._validErr !== null) return null;\n  \t\t\t}\n  \t\t\tvar graph = new GeometryGraph(0, g);\n  \t\t\tthis.checkTooFewPoints(graph);\n  \t\t\tif (this._validErr !== null) return null;\n  \t\t\tthis.checkConsistentArea(graph);\n  \t\t\tif (this._validErr !== null) return null;\n  \t\t\tif (!this._isSelfTouchingRingFormingHoleValid) {\n  \t\t\t\tthis.checkNoSelfIntersectingRings(graph);\n  \t\t\t\tif (this._validErr !== null) return null;\n  \t\t\t}\n  \t\t\tfor (var i = 0; i < g.getNumGeometries(); i++) {\n  \t\t\t\tvar p = g.getGeometryN(i);\n  \t\t\t\tthis.checkHolesInShell(p, graph);\n  \t\t\t\tif (this._validErr !== null) return null;\n  \t\t\t}\n  \t\t\tfor (var i = 0; i < g.getNumGeometries(); i++) {\n  \t\t\t\tvar p = g.getGeometryN(i);\n  \t\t\t\tthis.checkHolesNotNested(p, graph);\n  \t\t\t\tif (this._validErr !== null) return null;\n  \t\t\t}\n  \t\t\tthis.checkShellsNotNested(g, graph);\n  \t\t\tif (this._validErr !== null) return null;\n  \t\t\tthis.checkConnectedInteriors(graph);\n  \t\t} else if (arguments[0] instanceof GeometryCollection) {\n  \t\t\tvar gc = arguments[0];\n  \t\t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n  \t\t\t\tvar g = gc.getGeometryN(i);\n  \t\t\t\tthis.checkValid(g);\n  \t\t\t\tif (this._validErr !== null) return null;\n  \t\t\t}\n  \t\t} else if (arguments[0] instanceof Geometry) {\n  \t\t\tvar g = arguments[0];\n  \t\t\tthis._validErr = null;\n  \t\t\tif (g.isEmpty()) return null;\n  \t\t\tif (g instanceof Point) this.checkValid(g);else if (g instanceof MultiPoint) this.checkValid(g);else if (g instanceof LinearRing) this.checkValid(g);else if (g instanceof LineString) this.checkValid(g);else if (g instanceof Polygon) this.checkValid(g);else if (g instanceof MultiPolygon) this.checkValid(g);else if (g instanceof GeometryCollection) this.checkValid(g);else throw new UnsupportedOperationException(g.getClass().getName());\n  \t\t}\n  \t},\n  \tsetSelfTouchingRingFormingHoleValid: function setSelfTouchingRingFormingHoleValid(isValid) {\n  \t\tthis._isSelfTouchingRingFormingHoleValid = isValid;\n  \t},\n  \tcheckShellNotNested: function checkShellNotNested(shell, p, graph) {\n  \t\tvar shellPts = shell.getCoordinates();\n  \t\tvar polyShell = p.getExteriorRing();\n  \t\tvar polyPts = polyShell.getCoordinates();\n  \t\tvar shellPt = IsValidOp.findPtNotNode(shellPts, polyShell, graph);\n  \t\tif (shellPt === null) return null;\n  \t\tvar insidePolyShell = CGAlgorithms.isPointInRing(shellPt, polyPts);\n  \t\tif (!insidePolyShell) return null;\n  \t\tif (p.getNumInteriorRing() <= 0) {\n  \t\t\tthis._validErr = new TopologyValidationError(TopologyValidationError.NESTED_SHELLS, shellPt);\n  \t\t\treturn null;\n  \t\t}\n  \t\tvar badNestedPt = null;\n  \t\tfor (var i = 0; i < p.getNumInteriorRing(); i++) {\n  \t\t\tvar hole = p.getInteriorRingN(i);\n  \t\t\tbadNestedPt = this.checkShellInsideHole(shell, hole, graph);\n  \t\t\tif (badNestedPt === null) return null;\n  \t\t}\n  \t\tthis._validErr = new TopologyValidationError(TopologyValidationError.NESTED_SHELLS, badNestedPt);\n  \t},\n  \tcheckClosedRings: function checkClosedRings(poly) {\n  \t\tthis.checkClosedRing(poly.getExteriorRing());\n  \t\tif (this._validErr !== null) return null;\n  \t\tfor (var i = 0; i < poly.getNumInteriorRing(); i++) {\n  \t\t\tthis.checkClosedRing(poly.getInteriorRingN(i));\n  \t\t\tif (this._validErr !== null) return null;\n  \t\t}\n  \t},\n  \tcheckClosedRing: function checkClosedRing(ring) {\n  \t\tif (!ring.isClosed()) {\n  \t\t\tvar pt = null;\n  \t\t\tif (ring.getNumPoints() >= 1) pt = ring.getCoordinateN(0);\n  \t\t\tthis._validErr = new TopologyValidationError(TopologyValidationError.RING_NOT_CLOSED, pt);\n  \t\t}\n  \t},\n  \tcheckShellsNotNested: function checkShellsNotNested(mp, graph) {\n  \t\tfor (var i = 0; i < mp.getNumGeometries(); i++) {\n  \t\t\tvar p = mp.getGeometryN(i);\n  \t\t\tvar shell = p.getExteriorRing();\n  \t\t\tfor (var j = 0; j < mp.getNumGeometries(); j++) {\n  \t\t\t\tif (i === j) continue;\n  \t\t\t\tvar p2 = mp.getGeometryN(j);\n  \t\t\t\tthis.checkShellNotNested(shell, p2, graph);\n  \t\t\t\tif (this._validErr !== null) return null;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn IsValidOp;\n  \t}\n  });\n  IsValidOp.findPtNotNode = function (testCoords, searchRing, graph) {\n  \tvar searchEdge = graph.findEdge(searchRing);\n  \tvar eiList = searchEdge.getEdgeIntersectionList();\n  \tfor (var i = 0; i < testCoords.length; i++) {\n  \t\tvar pt = testCoords[i];\n  \t\tif (!eiList.isIntersection(pt)) return pt;\n  \t}\n  \treturn null;\n  };\n  IsValidOp.isValid = function () {\n  \tif (arguments[0] instanceof Geometry) {\n  \t\tvar geom = arguments[0];\n  \t\tvar isValidOp = new IsValidOp(geom);\n  \t\treturn isValidOp.isValid();\n  \t} else if (arguments[0] instanceof Coordinate) {\n  \t\tvar coord = arguments[0];\n  \t\tif (Double.isNaN(coord.x)) return false;\n  \t\tif (Double.isInfinite(coord.x)) return false;\n  \t\tif (Double.isNaN(coord.y)) return false;\n  \t\tif (Double.isInfinite(coord.y)) return false;\n  \t\treturn true;\n  \t}\n  };\n\n  function EdgeRing$1() {\n  \tthis._factory = null;\n  \tthis._deList = new ArrayList();\n  \tthis._lowestEdge = null;\n  \tthis._ring = null;\n  \tthis._ringPts = null;\n  \tthis._holes = null;\n  \tthis._shell = null;\n  \tthis._isHole = null;\n  \tthis._isProcessed = false;\n  \tthis._isIncludedSet = false;\n  \tthis._isIncluded = false;\n  \tvar factory = arguments[0];\n  \tthis._factory = factory;\n  }\n  extend(EdgeRing$1.prototype, {\n  \tisIncluded: function isIncluded() {\n  \t\treturn this._isIncluded;\n  \t},\n  \tgetCoordinates: function getCoordinates() {\n  \t\tif (this._ringPts === null) {\n  \t\t\tvar coordList = new CoordinateList();\n  \t\t\tfor (var i = this._deList.iterator(); i.hasNext();) {\n  \t\t\t\tvar de = i.next();\n  \t\t\t\tvar edge = de.getEdge();\n  \t\t\t\tEdgeRing$1.addEdge(edge.getLine().getCoordinates(), de.getEdgeDirection(), coordList);\n  \t\t\t}\n  \t\t\tthis._ringPts = coordList.toCoordinateArray();\n  \t\t}\n  \t\treturn this._ringPts;\n  \t},\n  \tisIncludedSet: function isIncludedSet() {\n  \t\treturn this._isIncludedSet;\n  \t},\n  \tisValid: function isValid() {\n  \t\tthis.getCoordinates();\n  \t\tif (this._ringPts.length <= 3) return false;\n  \t\tthis.getRing();\n  \t\treturn IsValidOp.isValid(this._ring);\n  \t},\n  \tbuild: function build(startDE) {\n  \t\tvar de = startDE;\n  \t\tdo {\n  \t\t\tthis.add(de);\n  \t\t\tde.setRing(this);\n  \t\t\tde = de.getNext();\n  \t\t\tAssert.isTrue(de !== null, \"found null DE in ring\");\n  \t\t\tAssert.isTrue(de === startDE || !de.isInRing(), \"found DE already in ring\");\n  \t\t} while (de !== startDE);\n  \t},\n  \tisOuterHole: function isOuterHole() {\n  \t\tif (!this._isHole) return false;\n  \t\treturn !this.hasShell();\n  \t},\n  \tgetPolygon: function getPolygon() {\n  \t\tvar holeLR = null;\n  \t\tif (this._holes !== null) {\n  \t\t\tholeLR = new Array(this._holes.size()).fill(null);\n  \t\t\tfor (var i = 0; i < this._holes.size(); i++) {\n  \t\t\t\tholeLR[i] = this._holes.get(i);\n  \t\t\t}\n  \t\t}\n  \t\tvar poly = this._factory.createPolygon(this._ring, holeLR);\n  \t\treturn poly;\n  \t},\n  \tisHole: function isHole() {\n  \t\treturn this._isHole;\n  \t},\n  \tisProcessed: function isProcessed() {\n  \t\treturn this._isProcessed;\n  \t},\n  \taddHole: function addHole() {\n  \t\tif (arguments[0] instanceof LinearRing) {\n  \t\t\tvar hole = arguments[0];\n  \t\t\tif (this._holes === null) this._holes = new ArrayList();\n  \t\t\tthis._holes.add(hole);\n  \t\t} else if (arguments[0] instanceof EdgeRing$1) {\n  \t\t\tvar holeER = arguments[0];\n  \t\t\tholeER.setShell(this);\n  \t\t\tvar hole = holeER.getRing();\n  \t\t\tif (this._holes === null) this._holes = new ArrayList();\n  \t\t\tthis._holes.add(hole);\n  \t\t}\n  \t},\n  \tsetIncluded: function setIncluded(isIncluded) {\n  \t\tthis._isIncluded = isIncluded;\n  \t\tthis._isIncludedSet = true;\n  \t},\n  \tgetOuterHole: function getOuterHole() {\n  \t\tif (this.isHole()) return null;\n  \t\tfor (var i = 0; i < this._deList.size(); i++) {\n  \t\t\tvar de = this._deList.get(i);\n  \t\t\tvar adjRing = de.getSym().getRing();\n  \t\t\tif (adjRing.isOuterHole()) return adjRing;\n  \t\t}\n  \t\treturn null;\n  \t},\n  \tcomputeHole: function computeHole() {\n  \t\tvar ring = this.getRing();\n  \t\tthis._isHole = CGAlgorithms.isCCW(ring.getCoordinates());\n  \t},\n  \thasShell: function hasShell() {\n  \t\treturn this._shell !== null;\n  \t},\n  \tisOuterShell: function isOuterShell() {\n  \t\treturn this.getOuterHole() !== null;\n  \t},\n  \tgetLineString: function getLineString() {\n  \t\tthis.getCoordinates();\n  \t\treturn this._factory.createLineString(this._ringPts);\n  \t},\n  \ttoString: function toString() {\n  \t\treturn WKTWriter.toLineString(new CoordinateArraySequence(this.getCoordinates()));\n  \t},\n  \tgetShell: function getShell() {\n  \t\tif (this.isHole()) return this._shell;\n  \t\treturn this;\n  \t},\n  \tadd: function add(de) {\n  \t\tthis._deList.add(de);\n  \t},\n  \tgetRing: function getRing() {\n  \t\tif (this._ring !== null) return this._ring;\n  \t\tthis.getCoordinates();\n  \t\tif (this._ringPts.length < 3) System.out.println(this._ringPts);\n  \t\ttry {\n  \t\t\tthis._ring = this._factory.createLinearRing(this._ringPts);\n  \t\t} catch (ex) {\n  \t\t\tif (ex instanceof Exception) {\n  \t\t\t\tSystem.out.println(this._ringPts);\n  \t\t\t} else throw ex;\n  \t\t} finally {}\n  \t\treturn this._ring;\n  \t},\n  \tupdateIncluded: function updateIncluded() {\n  \t\tif (this.isHole()) return null;\n  \t\tfor (var i = 0; i < this._deList.size(); i++) {\n  \t\t\tvar de = this._deList.get(i);\n  \t\t\tvar adjShell = de.getSym().getRing().getShell();\n  \t\t\tif (adjShell !== null && adjShell.isIncludedSet()) {\n  \t\t\t\tthis.setIncluded(!adjShell.isIncluded());\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tsetShell: function setShell(shell) {\n  \t\tthis._shell = shell;\n  \t},\n  \tsetProcessed: function setProcessed(isProcessed) {\n  \t\tthis._isProcessed = isProcessed;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn EdgeRing$1;\n  \t}\n  });\n  EdgeRing$1.findDirEdgesInRing = function (startDE) {\n  \tvar de = startDE;\n  \tvar edges = new ArrayList();\n  \tdo {\n  \t\tedges.add(de);\n  \t\tde = de.getNext();\n  \t\tAssert.isTrue(de !== null, \"found null DE in ring\");\n  \t\tAssert.isTrue(de === startDE || !de.isInRing(), \"found DE already in ring\");\n  \t} while (de !== startDE);\n  \treturn edges;\n  };\n  EdgeRing$1.addEdge = function (coords, isForward, coordList) {\n  \tif (isForward) {\n  \t\tfor (var i = 0; i < coords.length; i++) {\n  \t\t\tcoordList.add(coords[i], false);\n  \t\t}\n  \t} else {\n  \t\tfor (var i = coords.length - 1; i >= 0; i--) {\n  \t\t\tcoordList.add(coords[i], false);\n  \t\t}\n  \t}\n  };\n  EdgeRing$1.findEdgeRingContaining = function (testEr, shellList) {\n  \tvar testRing = testEr.getRing();\n  \tvar testEnv = testRing.getEnvelopeInternal();\n  \tvar testPt = testRing.getCoordinateN(0);\n  \tvar minShell = null;\n  \tvar minShellEnv = null;\n  \tfor (var it = shellList.iterator(); it.hasNext();) {\n  \t\tvar tryShell = it.next();\n  \t\tvar tryShellRing = tryShell.getRing();\n  \t\tvar tryShellEnv = tryShellRing.getEnvelopeInternal();\n  \t\tif (tryShellEnv.equals(testEnv)) continue;\n  \t\tif (!tryShellEnv.contains(testEnv)) continue;\n  \t\ttestPt = CoordinateArrays.ptNotInList(testRing.getCoordinates(), tryShellRing.getCoordinates());\n  \t\tvar isContained = false;\n  \t\tif (CGAlgorithms.isPointInRing(testPt, tryShellRing.getCoordinates())) isContained = true;\n  \t\tif (isContained) {\n  \t\t\tif (minShell === null || minShellEnv.contains(tryShellEnv)) {\n  \t\t\t\tminShell = tryShell;\n  \t\t\t\tminShellEnv = minShell.getRing().getEnvelopeInternal();\n  \t\t\t}\n  \t\t}\n  \t}\n  \treturn minShell;\n  };\n  function EnvelopeComparator() {}\n  extend(EnvelopeComparator.prototype, {\n  \tcompare: function compare(obj0, obj1) {\n  \t\tvar r0 = obj0;\n  \t\tvar r1 = obj1;\n  \t\treturn r0.getRing().getEnvelope().compareTo(r1.getRing().getEnvelope());\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparator];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn EnvelopeComparator;\n  \t}\n  });\n  EdgeRing$1.EnvelopeComparator = EnvelopeComparator;\n\n  function PolygonizeGraph() {\n  \tPlanarGraph$1.apply(this);\n  \tthis._factory = null;\n  \tvar factory = arguments[0];\n  \tthis._factory = factory;\n  }\n  inherits$1(PolygonizeGraph, PlanarGraph$1);\n  extend(PolygonizeGraph.prototype, {\n  \tfindEdgeRing: function findEdgeRing(startDE) {\n  \t\tvar er = new EdgeRing$1(this._factory);\n  \t\ter.build(startDE);\n  \t\treturn er;\n  \t},\n  \tcomputeDepthParity: function computeDepthParity() {\n  \t\tif (arguments.length === 0) {\n  \t\t\twhile (true) {\n  \t\t\t\tvar de = null;\n  \t\t\t\tif (de === null) return null;\n  \t\t\t\tthis.computeDepthParity(de);\n  \t\t\t}\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tvar de = arguments[0];\n  \t\t}\n  \t},\n  \tcomputeNextCWEdges: function computeNextCWEdges() {\n  \t\tfor (var iNode = this.nodeIterator(); iNode.hasNext();) {\n  \t\t\tvar node = iNode.next();\n  \t\t\tPolygonizeGraph.computeNextCWEdges(node);\n  \t\t}\n  \t},\n  \taddEdge: function addEdge(line) {\n  \t\tif (line.isEmpty()) {\n  \t\t\treturn null;\n  \t\t}\n  \t\tvar linePts = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());\n  \t\tif (linePts.length < 2) {\n  \t\t\treturn null;\n  \t\t}\n  \t\tvar startPt = linePts[0];\n  \t\tvar endPt = linePts[linePts.length - 1];\n  \t\tvar nStart = this.getNode(startPt);\n  \t\tvar nEnd = this.getNode(endPt);\n  \t\tvar de0 = new PolygonizeDirectedEdge(nStart, nEnd, linePts[1], true);\n  \t\tvar de1 = new PolygonizeDirectedEdge(nEnd, nStart, linePts[linePts.length - 2], false);\n  \t\tvar edge = new PolygonizeEdge(line);\n  \t\tedge.setDirectedEdges(de0, de1);\n  \t\tthis.add(edge);\n  \t},\n  \tdeleteCutEdges: function deleteCutEdges() {\n  \t\tthis.computeNextCWEdges();\n  \t\tPolygonizeGraph.findLabeledEdgeRings(this._dirEdges);\n  \t\tvar cutLines = new ArrayList();\n  \t\tfor (var i = this._dirEdges.iterator(); i.hasNext();) {\n  \t\t\tvar de = i.next();\n  \t\t\tif (de.isMarked()) continue;\n  \t\t\tvar sym = de.getSym();\n  \t\t\tif (de.getLabel() === sym.getLabel()) {\n  \t\t\t\tde.setMarked(true);\n  \t\t\t\tsym.setMarked(true);\n  \t\t\t\tvar e = de.getEdge();\n  \t\t\t\tcutLines.add(e.getLine());\n  \t\t\t}\n  \t\t}\n  \t\treturn cutLines;\n  \t},\n  \tgetEdgeRings: function getEdgeRings() {\n  \t\tthis.computeNextCWEdges();\n  \t\tPolygonizeGraph.label(this._dirEdges, -1);\n  \t\tvar maximalRings = PolygonizeGraph.findLabeledEdgeRings(this._dirEdges);\n  \t\tthis.convertMaximalToMinimalEdgeRings(maximalRings);\n  \t\tvar edgeRingList = new ArrayList();\n  \t\tfor (var i = this._dirEdges.iterator(); i.hasNext();) {\n  \t\t\tvar de = i.next();\n  \t\t\tif (de.isMarked()) continue;\n  \t\t\tif (de.isInRing()) continue;\n  \t\t\tvar er = this.findEdgeRing(de);\n  \t\t\tedgeRingList.add(er);\n  \t\t}\n  \t\treturn edgeRingList;\n  \t},\n  \tgetNode: function getNode(pt) {\n  \t\tvar node = this.findNode(pt);\n  \t\tif (node === null) {\n  \t\t\tnode = new Node$3(pt);\n  \t\t\tthis.add(node);\n  \t\t}\n  \t\treturn node;\n  \t},\n  \tconvertMaximalToMinimalEdgeRings: function convertMaximalToMinimalEdgeRings(ringEdges) {\n  \t\tfor (var i = ringEdges.iterator(); i.hasNext();) {\n  \t\t\tvar de = i.next();\n  \t\t\tvar label = de.getLabel();\n  \t\t\tvar intNodes = PolygonizeGraph.findIntersectionNodes(de, label);\n  \t\t\tif (intNodes === null) continue;\n  \t\t\tfor (var iNode = intNodes.iterator(); iNode.hasNext();) {\n  \t\t\t\tvar node = iNode.next();\n  \t\t\t\tPolygonizeGraph.computeNextCCWEdges(node, label);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tdeleteDangles: function deleteDangles() {\n  \t\tvar nodesToRemove = this.findNodesOfDegree(1);\n  \t\tvar dangleLines = new HashSet();\n  \t\tvar nodeStack = new Stack$1();\n  \t\tfor (var i = nodesToRemove.iterator(); i.hasNext();) {\n  \t\t\tnodeStack.push(i.next());\n  \t\t}\n  \t\twhile (!nodeStack.isEmpty()) {\n  \t\t\tvar node = nodeStack.pop();\n  \t\t\tPolygonizeGraph.deleteAllEdges(node);\n  \t\t\tvar nodeOutEdges = node.getOutEdges().getEdges();\n  \t\t\tfor (var i = nodeOutEdges.iterator(); i.hasNext();) {\n  \t\t\t\tvar de = i.next();\n  \t\t\t\tde.setMarked(true);\n  \t\t\t\tvar sym = de.getSym();\n  \t\t\t\tif (sym !== null) sym.setMarked(true);\n  \t\t\t\tvar e = de.getEdge();\n  \t\t\t\tdangleLines.add(e.getLine());\n  \t\t\t\tvar toNode = de.getToNode();\n  \t\t\t\tif (PolygonizeGraph.getDegreeNonDeleted(toNode) === 1) nodeStack.push(toNode);\n  \t\t\t}\n  \t\t}\n  \t\treturn dangleLines;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn PolygonizeGraph;\n  \t}\n  });\n  PolygonizeGraph.findLabeledEdgeRings = function (dirEdges) {\n  \tvar edgeRingStarts = new ArrayList();\n  \tvar currLabel = 1;\n  \tfor (var i = dirEdges.iterator(); i.hasNext();) {\n  \t\tvar de = i.next();\n  \t\tif (de.isMarked()) continue;\n  \t\tif (de.getLabel() >= 0) continue;\n  \t\tedgeRingStarts.add(de);\n  \t\tvar edges = EdgeRing$1.findDirEdgesInRing(de);\n  \t\tPolygonizeGraph.label(edges, currLabel);\n  \t\tcurrLabel++;\n  \t}\n  \treturn edgeRingStarts;\n  };\n  PolygonizeGraph.getDegreeNonDeleted = function (node) {\n  \tvar edges = node.getOutEdges().getEdges();\n  \tvar degree = 0;\n  \tfor (var i = edges.iterator(); i.hasNext();) {\n  \t\tvar de = i.next();\n  \t\tif (!de.isMarked()) degree++;\n  \t}\n  \treturn degree;\n  };\n  PolygonizeGraph.deleteAllEdges = function (node) {\n  \tvar edges = node.getOutEdges().getEdges();\n  \tfor (var i = edges.iterator(); i.hasNext();) {\n  \t\tvar de = i.next();\n  \t\tde.setMarked(true);\n  \t\tvar sym = de.getSym();\n  \t\tif (sym !== null) sym.setMarked(true);\n  \t}\n  };\n  PolygonizeGraph.label = function (dirEdges, label) {\n  \tfor (var i = dirEdges.iterator(); i.hasNext();) {\n  \t\tvar de = i.next();\n  \t\tde.setLabel(label);\n  \t}\n  };\n  PolygonizeGraph.computeNextCWEdges = function (node) {\n  \tvar deStar = node.getOutEdges();\n  \tvar startDE = null;\n  \tvar prevDE = null;\n  \tfor (var i = deStar.getEdges().iterator(); i.hasNext();) {\n  \t\tvar outDE = i.next();\n  \t\tif (outDE.isMarked()) continue;\n  \t\tif (startDE === null) startDE = outDE;\n  \t\tif (prevDE !== null) {\n  \t\t\tvar sym = prevDE.getSym();\n  \t\t\tsym.setNext(outDE);\n  \t\t}\n  \t\tprevDE = outDE;\n  \t}\n  \tif (prevDE !== null) {\n  \t\tvar sym = prevDE.getSym();\n  \t\tsym.setNext(startDE);\n  \t}\n  };\n  PolygonizeGraph.computeNextCCWEdges = function (node, label) {\n  \tvar deStar = node.getOutEdges();\n  \tvar firstOutDE = null;\n  \tvar prevInDE = null;\n  \tvar edges = deStar.getEdges();\n  \tfor (var i = edges.size() - 1; i >= 0; i--) {\n  \t\tvar de = edges.get(i);\n  \t\tvar sym = de.getSym();\n  \t\tvar outDE = null;\n  \t\tif (de.getLabel() === label) outDE = de;\n  \t\tvar inDE = null;\n  \t\tif (sym.getLabel() === label) inDE = sym;\n  \t\tif (outDE === null && inDE === null) continue;\n  \t\tif (inDE !== null) {\n  \t\t\tprevInDE = inDE;\n  \t\t}\n  \t\tif (outDE !== null) {\n  \t\t\tif (prevInDE !== null) {\n  \t\t\t\tprevInDE.setNext(outDE);\n  \t\t\t\tprevInDE = null;\n  \t\t\t}\n  \t\t\tif (firstOutDE === null) firstOutDE = outDE;\n  \t\t}\n  \t}\n  \tif (prevInDE !== null) {\n  \t\tAssert.isTrue(firstOutDE !== null);\n  \t\tprevInDE.setNext(firstOutDE);\n  \t}\n  };\n  PolygonizeGraph.getDegree = function (node, label) {\n  \tvar edges = node.getOutEdges().getEdges();\n  \tvar degree = 0;\n  \tfor (var i = edges.iterator(); i.hasNext();) {\n  \t\tvar de = i.next();\n  \t\tif (de.getLabel() === label) degree++;\n  \t}\n  \treturn degree;\n  };\n  PolygonizeGraph.findIntersectionNodes = function (startDE, label) {\n  \tvar de = startDE;\n  \tvar intNodes = null;\n  \tdo {\n  \t\tvar node = de.getFromNode();\n  \t\tif (PolygonizeGraph.getDegree(node, label) > 1) {\n  \t\t\tif (intNodes === null) intNodes = new ArrayList();\n  \t\t\tintNodes.add(node);\n  \t\t}\n  \t\tde = de.getNext();\n  \t\tAssert.isTrue(de !== null, \"found null DE in ring\");\n  \t\tAssert.isTrue(de === startDE || !de.isInRing(), \"found DE already in ring\");\n  \t} while (de !== startDE);\n  \treturn intNodes;\n  };\n\n  function Polygonizer() {\n  \tthis._lineStringAdder = new LineStringAdder(this);\n  \tthis._graph = null;\n  \tthis._dangles = new ArrayList();\n  \tthis._cutEdges = new ArrayList();\n  \tthis._invalidRingLines = new ArrayList();\n  \tthis._holeList = null;\n  \tthis._shellList = null;\n  \tthis._polyList = null;\n  \tthis._isCheckingRingsValid = true;\n  \tthis._extractOnlyPolygonal = null;\n  \tthis._geomFactory = null;\n  \tif (arguments.length === 0) {\n  \t\tPolygonizer.call(this, false);\n  \t} else if (arguments.length === 1) {\n  \t\tvar extractOnlyPolygonal = arguments[0];\n  \t\tthis._extractOnlyPolygonal = extractOnlyPolygonal;\n  \t}\n  }\n  extend(Polygonizer.prototype, {\n  \tgetGeometry: function getGeometry() {\n  \t\tif (this._geomFactory === null) this._geomFactory = new GeometryFactory();\n  \t\tthis.polygonize();\n  \t\tif (this._extractOnlyPolygonal) {\n  \t\t\treturn this._geomFactory.buildGeometry(this._polyList);\n  \t\t}\n  \t\treturn this._geomFactory.createGeometryCollection(GeometryFactory.toGeometryArray(this._polyList));\n  \t},\n  \tgetInvalidRingLines: function getInvalidRingLines() {\n  \t\tthis.polygonize();\n  \t\treturn this._invalidRingLines;\n  \t},\n  \tfindValidRings: function findValidRings(edgeRingList, validEdgeRingList, invalidRingList) {\n  \t\tfor (var i = edgeRingList.iterator(); i.hasNext();) {\n  \t\t\tvar er = i.next();\n  \t\t\tif (er.isValid()) validEdgeRingList.add(er);else invalidRingList.add(er.getLineString());\n  \t\t}\n  \t},\n  \tpolygonize: function polygonize() {\n  \t\tif (this._polyList !== null) return null;\n  \t\tthis._polyList = new ArrayList();\n  \t\tif (this._graph === null) return null;\n  \t\tthis._dangles = this._graph.deleteDangles();\n  \t\tthis._cutEdges = this._graph.deleteCutEdges();\n  \t\tvar edgeRingList = this._graph.getEdgeRings();\n  \t\tvar validEdgeRingList = new ArrayList();\n  \t\tthis._invalidRingLines = new ArrayList();\n  \t\tif (this._isCheckingRingsValid) {\n  \t\t\tthis.findValidRings(edgeRingList, validEdgeRingList, this._invalidRingLines);\n  \t\t} else {\n  \t\t\tvalidEdgeRingList = edgeRingList;\n  \t\t}\n  \t\tthis.findShellsAndHoles(validEdgeRingList);\n  \t\tPolygonizer.assignHolesToShells(this._holeList, this._shellList);\n  \t\tCollections.sort(this._shellList, new EdgeRing$1.EnvelopeComparator());\n  \t\tvar includeAll = true;\n  \t\tif (this._extractOnlyPolygonal) {\n  \t\t\tPolygonizer.findDisjointShells(this._shellList);\n  \t\t\tincludeAll = false;\n  \t\t}\n  \t\tthis._polyList = Polygonizer.extractPolygons(this._shellList, includeAll);\n  \t},\n  \tgetDangles: function getDangles() {\n  \t\tthis.polygonize();\n  \t\treturn this._dangles;\n  \t},\n  \tgetCutEdges: function getCutEdges() {\n  \t\tthis.polygonize();\n  \t\treturn this._cutEdges;\n  \t},\n  \tgetPolygons: function getPolygons() {\n  \t\tthis.polygonize();\n  \t\treturn this._polyList;\n  \t},\n  \tadd: function add() {\n  \t\tif (hasInterface(arguments[0], Collection)) {\n  \t\t\tvar geomList = arguments[0];\n  \t\t\tfor (var i = geomList.iterator(); i.hasNext();) {\n  \t\t\t\tvar geometry = i.next();\n  \t\t\t\tthis.add(geometry);\n  \t\t\t}\n  \t\t} else if (arguments[0] instanceof LineString) {\n  \t\t\tvar line = arguments[0];\n  \t\t\tthis._geomFactory = line.getFactory();\n  \t\t\tif (this._graph === null) this._graph = new PolygonizeGraph(this._geomFactory);\n  \t\t\tthis._graph.addEdge(line);\n  \t\t} else if (arguments[0] instanceof Geometry) {\n  \t\t\tvar g = arguments[0];\n  \t\t\tg.apply(this._lineStringAdder);\n  \t\t}\n  \t},\n  \tsetCheckRingsValid: function setCheckRingsValid(isCheckingRingsValid) {\n  \t\tthis._isCheckingRingsValid = isCheckingRingsValid;\n  \t},\n  \tfindShellsAndHoles: function findShellsAndHoles(edgeRingList) {\n  \t\tthis._holeList = new ArrayList();\n  \t\tthis._shellList = new ArrayList();\n  \t\tfor (var i = edgeRingList.iterator(); i.hasNext();) {\n  \t\t\tvar er = i.next();\n  \t\t\ter.computeHole();\n  \t\t\tif (er.isHole()) this._holeList.add(er);else this._shellList.add(er);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Polygonizer;\n  \t}\n  });\n  Polygonizer.findOuterShells = function (shellList) {\n  \tfor (var i = shellList.iterator(); i.hasNext();) {\n  \t\tvar er = i.next();\n  \t\tvar outerHoleER = er.getOuterHole();\n  \t\tif (outerHoleER !== null && !outerHoleER.isProcessed()) {\n  \t\t\ter.setIncluded(true);\n  \t\t\touterHoleER.setProcessed(true);\n  \t\t}\n  \t}\n  };\n  Polygonizer.extractPolygons = function (shellList, includeAll) {\n  \tvar polyList = new ArrayList();\n  \tfor (var i = shellList.iterator(); i.hasNext();) {\n  \t\tvar er = i.next();\n  \t\tif (includeAll || er.isIncluded()) {\n  \t\t\tpolyList.add(er.getPolygon());\n  \t\t}\n  \t}\n  \treturn polyList;\n  };\n  Polygonizer.assignHolesToShells = function (holeList, shellList) {\n  \tfor (var i = holeList.iterator(); i.hasNext();) {\n  \t\tvar holeER = i.next();\n  \t\tPolygonizer.assignHoleToShell(holeER, shellList);\n  \t}\n  };\n  Polygonizer.assignHoleToShell = function (holeER, shellList) {\n  \tvar shell = EdgeRing$1.findEdgeRingContaining(holeER, shellList);\n  \tif (shell !== null) {\n  \t\tshell.addHole(holeER);\n  \t}\n  };\n  Polygonizer.findDisjointShells = function (shellList) {\n  \tPolygonizer.findOuterShells(shellList);\n  \tvar isMoreToScan = null;\n  \tdo {\n  \t\tisMoreToScan = false;\n  \t\tfor (var i = shellList.iterator(); i.hasNext();) {\n  \t\t\tvar er = i.next();\n  \t\t\tif (er.isIncludedSet()) continue;\n  \t\t\ter.updateIncluded();\n  \t\t\tif (!er.isIncludedSet()) {\n  \t\t\t\tisMoreToScan = true;\n  \t\t\t}\n  \t\t}\n  \t} while (isMoreToScan);\n  };\n  function LineStringAdder() {\n  \tthis.p = null;\n  \tvar p = arguments[0];\n  \tthis.p = p;\n  }\n  extend(LineStringAdder.prototype, {\n  \tfilter: function filter(g) {\n  \t\tif (g instanceof LineString) this.p.add(g);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [GeometryComponentFilter];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LineStringAdder;\n  \t}\n  });\n  Polygonizer.LineStringAdder = LineStringAdder;\n\n  function RelateComputer() {\n  \tthis._li = new RobustLineIntersector();\n  \tthis._ptLocator = new PointLocator();\n  \tthis._arg = null;\n  \tthis._nodes = new NodeMap(new RelateNodeFactory());\n  \tthis._im = null;\n  \tthis._isolatedEdges = new ArrayList();\n  \tthis._invalidPoint = null;\n  \tvar arg = arguments[0];\n  \tthis._arg = arg;\n  }\n  extend(RelateComputer.prototype, {\n  \tinsertEdgeEnds: function insertEdgeEnds(ee) {\n  \t\tfor (var i = ee.iterator(); i.hasNext();) {\n  \t\t\tvar e = i.next();\n  \t\t\tthis._nodes.add(e);\n  \t\t}\n  \t},\n  \tcomputeProperIntersectionIM: function computeProperIntersectionIM(intersector, im) {\n  \t\tvar dimA = this._arg[0].getGeometry().getDimension();\n  \t\tvar dimB = this._arg[1].getGeometry().getDimension();\n  \t\tvar hasProper = intersector.hasProperIntersection();\n  \t\tvar hasProperInterior = intersector.hasProperInteriorIntersection();\n  \t\tif (dimA === 2 && dimB === 2) {\n  \t\t\tif (hasProper) im.setAtLeast(\"212101212\");\n  \t\t} else if (dimA === 2 && dimB === 1) {\n  \t\t\tif (hasProper) im.setAtLeast(\"FFF0FFFF2\");\n  \t\t\tif (hasProperInterior) im.setAtLeast(\"1FFFFF1FF\");\n  \t\t} else if (dimA === 1 && dimB === 2) {\n  \t\t\tif (hasProper) im.setAtLeast(\"F0FFFFFF2\");\n  \t\t\tif (hasProperInterior) im.setAtLeast(\"1F1FFFFFF\");\n  \t\t} else if (dimA === 1 && dimB === 1) {\n  \t\t\tif (hasProperInterior) im.setAtLeast(\"0FFFFFFFF\");\n  \t\t}\n  \t},\n  \tlabelIsolatedEdges: function labelIsolatedEdges(thisIndex, targetIndex) {\n  \t\tfor (var ei = this._arg[thisIndex].getEdgeIterator(); ei.hasNext();) {\n  \t\t\tvar e = ei.next();\n  \t\t\tif (e.isIsolated()) {\n  \t\t\t\tthis.labelIsolatedEdge(e, targetIndex, this._arg[targetIndex].getGeometry());\n  \t\t\t\tthis._isolatedEdges.add(e);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tlabelIsolatedEdge: function labelIsolatedEdge(e, targetIndex, target) {\n  \t\tif (target.getDimension() > 0) {\n  \t\t\tvar loc = this._ptLocator.locate(e.getCoordinate(), target);\n  \t\t\te.getLabel().setAllLocations(targetIndex, loc);\n  \t\t} else {\n  \t\t\te.getLabel().setAllLocations(targetIndex, Location.EXTERIOR);\n  \t\t}\n  \t},\n  \tcomputeIM: function computeIM() {\n  \t\tvar im = new IntersectionMatrix();\n  \t\tim.set(Location.EXTERIOR, Location.EXTERIOR, 2);\n  \t\tif (!this._arg[0].getGeometry().getEnvelopeInternal().intersects(this._arg[1].getGeometry().getEnvelopeInternal())) {\n  \t\t\tthis.computeDisjointIM(im);\n  \t\t\treturn im;\n  \t\t}\n  \t\tthis._arg[0].computeSelfNodes(this._li, false);\n  \t\tthis._arg[1].computeSelfNodes(this._li, false);\n  \t\tvar intersector = this._arg[0].computeEdgeIntersections(this._arg[1], this._li, false);\n  \t\tthis.computeIntersectionNodes(0);\n  \t\tthis.computeIntersectionNodes(1);\n  \t\tthis.copyNodesAndLabels(0);\n  \t\tthis.copyNodesAndLabels(1);\n  \t\tthis.labelIsolatedNodes();\n  \t\tthis.computeProperIntersectionIM(intersector, im);\n  \t\tvar eeBuilder = new EdgeEndBuilder();\n  \t\tvar ee0 = eeBuilder.computeEdgeEnds(this._arg[0].getEdgeIterator());\n  \t\tthis.insertEdgeEnds(ee0);\n  \t\tvar ee1 = eeBuilder.computeEdgeEnds(this._arg[1].getEdgeIterator());\n  \t\tthis.insertEdgeEnds(ee1);\n  \t\tthis.labelNodeEdges();\n  \t\tthis.labelIsolatedEdges(0, 1);\n  \t\tthis.labelIsolatedEdges(1, 0);\n  \t\tthis.updateIM(im);\n  \t\treturn im;\n  \t},\n  \tlabelNodeEdges: function labelNodeEdges() {\n  \t\tfor (var ni = this._nodes.iterator(); ni.hasNext();) {\n  \t\t\tvar node = ni.next();\n  \t\t\tnode.getEdges().computeLabelling(this._arg);\n  \t\t}\n  \t},\n  \tcopyNodesAndLabels: function copyNodesAndLabels(argIndex) {\n  \t\tfor (var i = this._arg[argIndex].getNodeIterator(); i.hasNext();) {\n  \t\t\tvar graphNode = i.next();\n  \t\t\tvar newNode = this._nodes.addNode(graphNode.getCoordinate());\n  \t\t\tnewNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));\n  \t\t}\n  \t},\n  \tlabelIntersectionNodes: function labelIntersectionNodes(argIndex) {\n  \t\tfor (var i = this._arg[argIndex].getEdgeIterator(); i.hasNext();) {\n  \t\t\tvar e = i.next();\n  \t\t\tvar eLoc = e.getLabel().getLocation(argIndex);\n  \t\t\tfor (var eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext();) {\n  \t\t\t\tvar ei = eiIt.next();\n  \t\t\t\tvar n = this._nodes.find(ei.coord);\n  \t\t\t\tif (n.getLabel().isNull(argIndex)) {\n  \t\t\t\t\tif (eLoc === Location.BOUNDARY) n.setLabelBoundary(argIndex);else n.setLabel(argIndex, Location.INTERIOR);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tlabelIsolatedNode: function labelIsolatedNode(n, targetIndex) {\n  \t\tvar loc = this._ptLocator.locate(n.getCoordinate(), this._arg[targetIndex].getGeometry());\n  \t\tn.getLabel().setAllLocations(targetIndex, loc);\n  \t},\n  \tcomputeIntersectionNodes: function computeIntersectionNodes(argIndex) {\n  \t\tfor (var i = this._arg[argIndex].getEdgeIterator(); i.hasNext();) {\n  \t\t\tvar e = i.next();\n  \t\t\tvar eLoc = e.getLabel().getLocation(argIndex);\n  \t\t\tfor (var eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext();) {\n  \t\t\t\tvar ei = eiIt.next();\n  \t\t\t\tvar n = this._nodes.addNode(ei.coord);\n  \t\t\t\tif (eLoc === Location.BOUNDARY) n.setLabelBoundary(argIndex);else {\n  \t\t\t\t\tif (n.getLabel().isNull(argIndex)) n.setLabel(argIndex, Location.INTERIOR);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tlabelIsolatedNodes: function labelIsolatedNodes() {\n  \t\tfor (var ni = this._nodes.iterator(); ni.hasNext();) {\n  \t\t\tvar n = ni.next();\n  \t\t\tvar label = n.getLabel();\n  \t\t\tAssert.isTrue(label.getGeometryCount() > 0, \"node with empty label found\");\n  \t\t\tif (n.isIsolated()) {\n  \t\t\t\tif (label.isNull(0)) this.labelIsolatedNode(n, 0);else this.labelIsolatedNode(n, 1);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tupdateIM: function updateIM(im) {\n  \t\tfor (var ei = this._isolatedEdges.iterator(); ei.hasNext();) {\n  \t\t\tvar e = ei.next();\n  \t\t\te.updateIM(im);\n  \t\t}\n  \t\tfor (var ni = this._nodes.iterator(); ni.hasNext();) {\n  \t\t\tvar node = ni.next();\n  \t\t\tnode.updateIM(im);\n  \t\t\tnode.updateIMFromEdges(im);\n  \t\t}\n  \t},\n  \tcomputeDisjointIM: function computeDisjointIM(im) {\n  \t\tvar ga = this._arg[0].getGeometry();\n  \t\tif (!ga.isEmpty()) {\n  \t\t\tim.set(Location.INTERIOR, Location.EXTERIOR, ga.getDimension());\n  \t\t\tim.set(Location.BOUNDARY, Location.EXTERIOR, ga.getBoundaryDimension());\n  \t\t}\n  \t\tvar gb = this._arg[1].getGeometry();\n  \t\tif (!gb.isEmpty()) {\n  \t\t\tim.set(Location.EXTERIOR, Location.INTERIOR, gb.getDimension());\n  \t\t\tim.set(Location.EXTERIOR, Location.BOUNDARY, gb.getBoundaryDimension());\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn RelateComputer;\n  \t}\n  });\n\n  function RectangleContains() {\n  \tthis._rectEnv = null;\n  \tvar rectangle = arguments[0];\n  \tthis._rectEnv = rectangle.getEnvelopeInternal();\n  }\n  extend(RectangleContains.prototype, {\n  \tisContainedInBoundary: function isContainedInBoundary(geom) {\n  \t\tif (geom instanceof Polygon) return false;\n  \t\tif (geom instanceof Point) return this.isPointContainedInBoundary(geom);\n  \t\tif (geom instanceof LineString) return this.isLineStringContainedInBoundary(geom);\n  \t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n  \t\t\tvar comp = geom.getGeometryN(i);\n  \t\t\tif (!this.isContainedInBoundary(comp)) return false;\n  \t\t}\n  \t\treturn true;\n  \t},\n  \tisLineSegmentContainedInBoundary: function isLineSegmentContainedInBoundary(p0, p1) {\n  \t\tif (p0.equals(p1)) return this.isPointContainedInBoundary(p0);\n  \t\tif (p0.x === p1.x) {\n  \t\t\tif (p0.x === this._rectEnv.getMinX() || p0.x === this._rectEnv.getMaxX()) return true;\n  \t\t} else if (p0.y === p1.y) {\n  \t\t\tif (p0.y === this._rectEnv.getMinY() || p0.y === this._rectEnv.getMaxY()) return true;\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tisLineStringContainedInBoundary: function isLineStringContainedInBoundary(line) {\n  \t\tvar seq = line.getCoordinateSequence();\n  \t\tvar p0 = new Coordinate();\n  \t\tvar p1 = new Coordinate();\n  \t\tfor (var i = 0; i < seq.size() - 1; i++) {\n  \t\t\tseq.getCoordinate(i, p0);\n  \t\t\tseq.getCoordinate(i + 1, p1);\n  \t\t\tif (!this.isLineSegmentContainedInBoundary(p0, p1)) return false;\n  \t\t}\n  \t\treturn true;\n  \t},\n  \tisPointContainedInBoundary: function isPointContainedInBoundary() {\n  \t\tif (arguments[0] instanceof Point) {\n  \t\t\tvar point = arguments[0];\n  \t\t\treturn this.isPointContainedInBoundary(point.getCoordinate());\n  \t\t} else if (arguments[0] instanceof Coordinate) {\n  \t\t\tvar pt = arguments[0];\n  \t\t\treturn pt.x === this._rectEnv.getMinX() || pt.x === this._rectEnv.getMaxX() || pt.y === this._rectEnv.getMinY() || pt.y === this._rectEnv.getMaxY();\n  \t\t}\n  \t},\n  \tcontains: function contains(geom) {\n  \t\tif (!this._rectEnv.contains(geom.getEnvelopeInternal())) return false;\n  \t\tif (this.isContainedInBoundary(geom)) return false;\n  \t\treturn true;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn RectangleContains;\n  \t}\n  });\n  RectangleContains.contains = function (rectangle, b) {\n  \tvar rc = new RectangleContains(rectangle);\n  \treturn rc.contains(b);\n  };\n\n  function RectangleLineIntersector() {\n  \tthis._li = new RobustLineIntersector();\n  \tthis._rectEnv = null;\n  \tthis._diagUp0 = null;\n  \tthis._diagUp1 = null;\n  \tthis._diagDown0 = null;\n  \tthis._diagDown1 = null;\n  \tvar rectEnv = arguments[0];\n  \tthis._rectEnv = rectEnv;\n  \tthis._diagUp0 = new Coordinate(rectEnv.getMinX(), rectEnv.getMinY());\n  \tthis._diagUp1 = new Coordinate(rectEnv.getMaxX(), rectEnv.getMaxY());\n  \tthis._diagDown0 = new Coordinate(rectEnv.getMinX(), rectEnv.getMaxY());\n  \tthis._diagDown1 = new Coordinate(rectEnv.getMaxX(), rectEnv.getMinY());\n  }\n  extend(RectangleLineIntersector.prototype, {\n  \tintersects: function intersects(p0, p1) {\n  \t\tvar segEnv = new Envelope(p0, p1);\n  \t\tif (!this._rectEnv.intersects(segEnv)) return false;\n  \t\tif (this._rectEnv.intersects(p0)) return true;\n  \t\tif (this._rectEnv.intersects(p1)) return true;\n  \t\tif (p0.compareTo(p1) > 0) {\n  \t\t\tvar tmp = p0;\n  \t\t\tp0 = p1;\n  \t\t\tp1 = tmp;\n  \t\t}\n  \t\tvar isSegUpwards = false;\n  \t\tif (p1.y > p0.y) isSegUpwards = true;\n  \t\tif (isSegUpwards) {\n  \t\t\tthis._li.computeIntersection(p0, p1, this._diagDown0, this._diagDown1);\n  \t\t} else {\n  \t\t\tthis._li.computeIntersection(p0, p1, this._diagUp0, this._diagUp1);\n  \t\t}\n  \t\tif (this._li.hasIntersection()) return true;\n  \t\treturn false;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn RectangleLineIntersector;\n  \t}\n  });\n\n  function ShortCircuitedGeometryVisitor() {\n  \tthis._isDone = false;\n  }\n  extend(ShortCircuitedGeometryVisitor.prototype, {\n  \tapplyTo: function applyTo(geom) {\n  \t\tfor (var i = 0; i < geom.getNumGeometries() && !this._isDone; i++) {\n  \t\t\tvar element = geom.getGeometryN(i);\n  \t\t\tif (!(element instanceof GeometryCollection)) {\n  \t\t\t\tthis.visit(element);\n  \t\t\t\tif (this.isDone()) {\n  \t\t\t\t\tthis._isDone = true;\n  \t\t\t\t\treturn null;\n  \t\t\t\t}\n  \t\t\t} else this.applyTo(element);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn ShortCircuitedGeometryVisitor;\n  \t}\n  });\n\n  function RectangleIntersects() {\n  \tthis._rectangle = null;\n  \tthis._rectEnv = null;\n  \tvar rectangle = arguments[0];\n  \tthis._rectangle = rectangle;\n  \tthis._rectEnv = rectangle.getEnvelopeInternal();\n  }\n  extend(RectangleIntersects.prototype, {\n  \tintersects: function intersects(geom) {\n  \t\tif (!this._rectEnv.intersects(geom.getEnvelopeInternal())) return false;\n  \t\tvar visitor = new EnvelopeIntersectsVisitor(this._rectEnv);\n  \t\tvisitor.applyTo(geom);\n  \t\tif (visitor.intersects()) return true;\n  \t\tvar ecpVisitor = new GeometryContainsPointVisitor(this._rectangle);\n  \t\tecpVisitor.applyTo(geom);\n  \t\tif (ecpVisitor.containsPoint()) return true;\n  \t\tvar riVisitor = new RectangleIntersectsSegmentVisitor(this._rectangle);\n  \t\triVisitor.applyTo(geom);\n  \t\tif (riVisitor.intersects()) return true;\n  \t\treturn false;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn RectangleIntersects;\n  \t}\n  });\n  RectangleIntersects.intersects = function (rectangle, b) {\n  \tvar rp = new RectangleIntersects(rectangle);\n  \treturn rp.intersects(b);\n  };\n  function EnvelopeIntersectsVisitor() {\n  \tShortCircuitedGeometryVisitor.apply(this);\n  \tthis._rectEnv = null;\n  \tthis._intersects = false;\n  \tvar rectEnv = arguments[0];\n  \tthis._rectEnv = rectEnv;\n  }\n  inherits$1(EnvelopeIntersectsVisitor, ShortCircuitedGeometryVisitor);\n  extend(EnvelopeIntersectsVisitor.prototype, {\n  \tisDone: function isDone() {\n  \t\treturn this._intersects === true;\n  \t},\n  \tvisit: function visit(element) {\n  \t\tvar elementEnv = element.getEnvelopeInternal();\n  \t\tif (!this._rectEnv.intersects(elementEnv)) {\n  \t\t\treturn null;\n  \t\t}\n  \t\tif (this._rectEnv.contains(elementEnv)) {\n  \t\t\tthis._intersects = true;\n  \t\t\treturn null;\n  \t\t}\n  \t\tif (elementEnv.getMinX() >= this._rectEnv.getMinX() && elementEnv.getMaxX() <= this._rectEnv.getMaxX()) {\n  \t\t\tthis._intersects = true;\n  \t\t\treturn null;\n  \t\t}\n  \t\tif (elementEnv.getMinY() >= this._rectEnv.getMinY() && elementEnv.getMaxY() <= this._rectEnv.getMaxY()) {\n  \t\t\tthis._intersects = true;\n  \t\t\treturn null;\n  \t\t}\n  \t},\n  \tintersects: function intersects() {\n  \t\treturn this._intersects;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn EnvelopeIntersectsVisitor;\n  \t}\n  });\n  function GeometryContainsPointVisitor() {\n  \tShortCircuitedGeometryVisitor.apply(this);\n  \tthis._rectSeq = null;\n  \tthis._rectEnv = null;\n  \tthis._containsPoint = false;\n  \tvar rectangle = arguments[0];\n  \tthis._rectSeq = rectangle.getExteriorRing().getCoordinateSequence();\n  \tthis._rectEnv = rectangle.getEnvelopeInternal();\n  }\n  inherits$1(GeometryContainsPointVisitor, ShortCircuitedGeometryVisitor);\n  extend(GeometryContainsPointVisitor.prototype, {\n  \tisDone: function isDone() {\n  \t\treturn this._containsPoint === true;\n  \t},\n  \tvisit: function visit(geom) {\n  \t\tif (!(geom instanceof Polygon)) return null;\n  \t\tvar elementEnv = geom.getEnvelopeInternal();\n  \t\tif (!this._rectEnv.intersects(elementEnv)) return null;\n  \t\tvar rectPt = new Coordinate();\n  \t\tfor (var i = 0; i < 4; i++) {\n  \t\t\tthis._rectSeq.getCoordinate(i, rectPt);\n  \t\t\tif (!elementEnv.contains(rectPt)) continue;\n  \t\t\tif (SimplePointInAreaLocator.containsPointInPolygon(rectPt, geom)) {\n  \t\t\t\tthis._containsPoint = true;\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tcontainsPoint: function containsPoint() {\n  \t\treturn this._containsPoint;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn GeometryContainsPointVisitor;\n  \t}\n  });\n  function RectangleIntersectsSegmentVisitor() {\n  \tShortCircuitedGeometryVisitor.apply(this);\n  \tthis._rectEnv = null;\n  \tthis._rectIntersector = null;\n  \tthis._hasIntersection = false;\n  \tthis._p0 = new Coordinate();\n  \tthis._p1 = new Coordinate();\n  \tvar rectangle = arguments[0];\n  \tthis._rectEnv = rectangle.getEnvelopeInternal();\n  \tthis._rectIntersector = new RectangleLineIntersector(this._rectEnv);\n  }\n  inherits$1(RectangleIntersectsSegmentVisitor, ShortCircuitedGeometryVisitor);\n  extend(RectangleIntersectsSegmentVisitor.prototype, {\n  \tintersects: function intersects() {\n  \t\treturn this._hasIntersection;\n  \t},\n  \tisDone: function isDone() {\n  \t\treturn this._hasIntersection === true;\n  \t},\n  \tvisit: function visit(geom) {\n  \t\tvar elementEnv = geom.getEnvelopeInternal();\n  \t\tif (!this._rectEnv.intersects(elementEnv)) return null;\n  \t\tvar lines = LinearComponentExtracter.getLines(geom);\n  \t\tthis.checkIntersectionWithLineStrings(lines);\n  \t},\n  \tcheckIntersectionWithLineStrings: function checkIntersectionWithLineStrings(lines) {\n  \t\tfor (var i = lines.iterator(); i.hasNext();) {\n  \t\t\tvar testLine = i.next();\n  \t\t\tthis.checkIntersectionWithSegments(testLine);\n  \t\t\tif (this._hasIntersection) return null;\n  \t\t}\n  \t},\n  \tcheckIntersectionWithSegments: function checkIntersectionWithSegments(testLine) {\n  \t\tvar seq1 = testLine.getCoordinateSequence();\n  \t\tfor (var j = 1; j < seq1.size(); j++) {\n  \t\t\tseq1.getCoordinate(j - 1, this._p0);\n  \t\t\tseq1.getCoordinate(j, this._p1);\n  \t\t\tif (this._rectIntersector.intersects(this._p0, this._p1)) {\n  \t\t\t\tthis._hasIntersection = true;\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn RectangleIntersectsSegmentVisitor;\n  \t}\n  });\n\n  function RelateOp() {\n  \tthis._relate = null;\n  \tif (arguments.length === 2) {\n  \t\tvar g0 = arguments[0],\n  \t\t    g1 = arguments[1];\n  \t\tGeometryGraphOperation.call(this, g0, g1);\n  \t\tthis._relate = new RelateComputer(this._arg);\n  \t} else if (arguments.length === 3) {\n  \t\tvar g0 = arguments[0],\n  \t\t    g1 = arguments[1],\n  \t\t    boundaryNodeRule = arguments[2];\n  \t\tGeometryGraphOperation.call(this, g0, g1, boundaryNodeRule);\n  \t\tthis._relate = new RelateComputer(this._arg);\n  \t}\n  }\n  inherits$1(RelateOp, GeometryGraphOperation);\n  extend(RelateOp.prototype, {\n  \tgetIntersectionMatrix: function getIntersectionMatrix() {\n  \t\treturn this._relate.computeIM();\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn RelateOp;\n  \t}\n  });\n  RelateOp.covers = function (g1, g2) {\n  \tif (!g1.getEnvelopeInternal().covers(g2.getEnvelopeInternal())) return false;\n  \tif (g1.isRectangle()) {\n  \t\treturn true;\n  \t}\n  \treturn RelateOp.relate(g1, g2).isCovers();\n  };\n  RelateOp.intersects = function (g1, g2) {\n  \tif (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;\n  \tif (g1.isRectangle()) {\n  \t\treturn RectangleIntersects.intersects(g1, g2);\n  \t}\n  \tif (g2.isRectangle()) {\n  \t\treturn RectangleIntersects.intersects(g2, g1);\n  \t}\n  \treturn RelateOp.relate(g1, g2).isIntersects();\n  };\n  RelateOp.touches = function (g1, g2) {\n  \tif (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;\n  \treturn RelateOp.relate(g1, g2).isTouches(g1.getDimension(), g2.getDimension());\n  };\n  RelateOp.within = function (g1, g2) {\n  \treturn g2.contains(g1);\n  };\n  RelateOp.coveredBy = function (g1, g2) {\n  \treturn RelateOp.covers(g2, g1);\n  };\n  RelateOp.relate = function () {\n  \tif (arguments.length === 2) {\n  \t\tvar a = arguments[0],\n  \t\t    b = arguments[1];\n  \t\tvar relOp = new RelateOp(a, b);\n  \t\tvar im = relOp.getIntersectionMatrix();\n  \t\treturn im;\n  \t} else if (arguments.length === 3) {\n  \t\tif (typeof arguments[2] === \"string\" && arguments[0] instanceof Geometry && arguments[1] instanceof Geometry) {\n  \t\t\tvar g1 = arguments[0],\n  \t\t\t    g2 = arguments[1],\n  \t\t\t    intersectionPattern = arguments[2];\n  \t\t\treturn RelateOp.relateWithCheck(g1, g2).matches(intersectionPattern);\n  \t\t} else if (hasInterface(arguments[2], BoundaryNodeRule) && arguments[0] instanceof Geometry && arguments[1] instanceof Geometry) {\n  \t\t\tvar a = arguments[0],\n  \t\t\t    b = arguments[1],\n  \t\t\t    boundaryNodeRule = arguments[2];\n  \t\t\tvar relOp = new RelateOp(a, b, boundaryNodeRule);\n  \t\t\tvar im = relOp.getIntersectionMatrix();\n  \t\t\treturn im;\n  \t\t}\n  \t}\n  };\n  RelateOp.overlaps = function (g1, g2) {\n  \tif (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;\n  \treturn RelateOp.relate(g1, g2).isOverlaps(g1.getDimension(), g2.getDimension());\n  };\n  RelateOp.disjoint = function (g1, g2) {\n  \treturn !g1.intersects(g2);\n  };\n  RelateOp.relateWithCheck = function (g1, g2) {\n  \tg1.checkNotGeometryCollection(g1);\n  \tg1.checkNotGeometryCollection(g2);\n  \treturn RelateOp.relate(g1, g2);\n  };\n  RelateOp.crosses = function (g1, g2) {\n  \tif (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;\n  \treturn RelateOp.relate(g1, g2).isCrosses(g1.getDimension(), g2.getDimension());\n  };\n  RelateOp.contains = function (g1, g2) {\n  \tif (!g1.getEnvelopeInternal().contains(g2.getEnvelopeInternal())) return false;\n  \tif (g1.isRectangle()) {\n  \t\treturn RectangleContains.contains(g1, g2);\n  \t}\n  \treturn RelateOp.relate(g1, g2).isContains();\n  };\n\n  function GeometryCombiner() {\n  \tthis._geomFactory = null;\n  \tthis._skipEmpty = false;\n  \tthis._inputGeoms = null;\n  \tvar geoms = arguments[0];\n  \tthis._geomFactory = GeometryCombiner.extractFactory(geoms);\n  \tthis._inputGeoms = geoms;\n  }\n  extend(GeometryCombiner.prototype, {\n  \textractElements: function extractElements(geom, elems) {\n  \t\tif (geom === null) return null;\n  \t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n  \t\t\tvar elemGeom = geom.getGeometryN(i);\n  \t\t\tif (this._skipEmpty && elemGeom.isEmpty()) continue;\n  \t\t\telems.add(elemGeom);\n  \t\t}\n  \t},\n  \tcombine: function combine() {\n  \t\tvar elems = new ArrayList();\n  \t\tfor (var i = this._inputGeoms.iterator(); i.hasNext();) {\n  \t\t\tvar g = i.next();\n  \t\t\tthis.extractElements(g, elems);\n  \t\t}\n  \t\tif (elems.size() === 0) {\n  \t\t\tif (this._geomFactory !== null) {\n  \t\t\t\treturn this._geomFactory.createGeometryCollection(null);\n  \t\t\t}\n  \t\t\treturn null;\n  \t\t}\n  \t\treturn this._geomFactory.buildGeometry(elems);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn GeometryCombiner;\n  \t}\n  });\n  GeometryCombiner.combine = function () {\n  \tif (arguments.length === 1) {\n  \t\tvar geoms = arguments[0];\n  \t\tvar combiner = new GeometryCombiner(geoms);\n  \t\treturn combiner.combine();\n  \t} else if (arguments.length === 2) {\n  \t\tvar g0 = arguments[0],\n  \t\t    g1 = arguments[1];\n  \t\tvar combiner = new GeometryCombiner(GeometryCombiner.createList(g0, g1));\n  \t\treturn combiner.combine();\n  \t} else if (arguments.length === 3) {\n  \t\tvar g0 = arguments[0],\n  \t\t    g1 = arguments[1],\n  \t\t    g2 = arguments[2];\n  \t\tvar combiner = new GeometryCombiner(GeometryCombiner.createList(g0, g1, g2));\n  \t\treturn combiner.combine();\n  \t}\n  };\n  GeometryCombiner.extractFactory = function (geoms) {\n  \tif (geoms.isEmpty()) return null;\n  \treturn geoms.iterator().next().getFactory();\n  };\n  GeometryCombiner.createList = function () {\n  \tif (arguments.length === 2) {\n  \t\tvar obj0 = arguments[0],\n  \t\t    obj1 = arguments[1];\n  \t\tvar list = new ArrayList();\n  \t\tlist.add(obj0);\n  \t\tlist.add(obj1);\n  \t\treturn list;\n  \t} else if (arguments.length === 3) {\n  \t\tvar obj0 = arguments[0],\n  \t\t    obj1 = arguments[1],\n  \t\t    obj2 = arguments[2];\n  \t\tvar list = new ArrayList();\n  \t\tlist.add(obj0);\n  \t\tlist.add(obj1);\n  \t\tlist.add(obj2);\n  \t\treturn list;\n  \t}\n  };\n\n  function CascadedPolygonUnion() {\n  \tthis._inputPolys = null;\n  \tthis._geomFactory = null;\n  \tvar polys = arguments[0];\n  \tthis._inputPolys = polys;\n  \tif (this._inputPolys === null) this._inputPolys = new ArrayList();\n  }\n  extend(CascadedPolygonUnion.prototype, {\n  \treduceToGeometries: function reduceToGeometries(geomTree) {\n  \t\tvar geoms = new ArrayList();\n  \t\tfor (var i = geomTree.iterator(); i.hasNext();) {\n  \t\t\tvar o = i.next();\n  \t\t\tvar geom = null;\n  \t\t\tif (hasInterface(o, List)) {\n  \t\t\t\tgeom = this.unionTree(o);\n  \t\t\t} else if (o instanceof Geometry) {\n  \t\t\t\tgeom = o;\n  \t\t\t}\n  \t\t\tgeoms.add(geom);\n  \t\t}\n  \t\treturn geoms;\n  \t},\n  \textractByEnvelope: function extractByEnvelope(env, geom, disjointGeoms) {\n  \t\tvar intersectingGeoms = new ArrayList();\n  \t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n  \t\t\tvar elem = geom.getGeometryN(i);\n  \t\t\tif (elem.getEnvelopeInternal().intersects(env)) intersectingGeoms.add(elem);else disjointGeoms.add(elem);\n  \t\t}\n  \t\treturn this._geomFactory.buildGeometry(intersectingGeoms);\n  \t},\n  \tunionOptimized: function unionOptimized(g0, g1) {\n  \t\tvar g0Env = g0.getEnvelopeInternal();\n  \t\tvar g1Env = g1.getEnvelopeInternal();\n  \t\tif (!g0Env.intersects(g1Env)) {\n  \t\t\tvar combo = GeometryCombiner.combine(g0, g1);\n  \t\t\treturn combo;\n  \t\t}\n  \t\tif (g0.getNumGeometries() <= 1 && g1.getNumGeometries() <= 1) return this.unionActual(g0, g1);\n  \t\tvar commonEnv = g0Env.intersection(g1Env);\n  \t\treturn this.unionUsingEnvelopeIntersection(g0, g1, commonEnv);\n  \t},\n  \tunion: function union() {\n  \t\tif (this._inputPolys === null) throw new IllegalStateException(\"union() method cannot be called twice\");\n  \t\tif (this._inputPolys.isEmpty()) return null;\n  \t\tthis._geomFactory = this._inputPolys.iterator().next().getFactory();\n  \t\tvar index = new STRtree(CascadedPolygonUnion.STRTREE_NODE_CAPACITY);\n  \t\tfor (var i = this._inputPolys.iterator(); i.hasNext();) {\n  \t\t\tvar item = i.next();\n  \t\t\tindex.insert(item.getEnvelopeInternal(), item);\n  \t\t}\n  \t\tthis._inputPolys = null;\n  \t\tvar itemTree = index.itemsTree();\n  \t\tvar unionAll = this.unionTree(itemTree);\n  \t\treturn unionAll;\n  \t},\n  \tbinaryUnion: function binaryUnion() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar geoms = arguments[0];\n  \t\t\treturn this.binaryUnion(geoms, 0, geoms.size());\n  \t\t} else if (arguments.length === 3) {\n  \t\t\tvar geoms = arguments[0],\n  \t\t\t    start = arguments[1],\n  \t\t\t    end = arguments[2];\n  \t\t\tif (end - start <= 1) {\n  \t\t\t\tvar g0 = CascadedPolygonUnion.getGeometry(geoms, start);\n  \t\t\t\treturn this.unionSafe(g0, null);\n  \t\t\t} else if (end - start === 2) {\n  \t\t\t\treturn this.unionSafe(CascadedPolygonUnion.getGeometry(geoms, start), CascadedPolygonUnion.getGeometry(geoms, start + 1));\n  \t\t\t} else {\n  \t\t\t\tvar mid = Math.trunc((end + start) / 2);\n  \t\t\t\tvar g0 = this.binaryUnion(geoms, start, mid);\n  \t\t\t\tvar g1 = this.binaryUnion(geoms, mid, end);\n  \t\t\t\treturn this.unionSafe(g0, g1);\n  \t\t\t}\n  \t\t}\n  \t},\n  \trepeatedUnion: function repeatedUnion(geoms) {\n  \t\tvar union = null;\n  \t\tfor (var i = geoms.iterator(); i.hasNext();) {\n  \t\t\tvar g = i.next();\n  \t\t\tif (union === null) union = g.copy();else union = union.union(g);\n  \t\t}\n  \t\treturn union;\n  \t},\n  \tunionSafe: function unionSafe(g0, g1) {\n  \t\tif (g0 === null && g1 === null) return null;\n  \t\tif (g0 === null) return g1.copy();\n  \t\tif (g1 === null) return g0.copy();\n  \t\treturn this.unionOptimized(g0, g1);\n  \t},\n  \tunionActual: function unionActual(g0, g1) {\n  \t\treturn CascadedPolygonUnion.restrictToPolygons(g0.union(g1));\n  \t},\n  \tunionTree: function unionTree(geomTree) {\n  \t\tvar geoms = this.reduceToGeometries(geomTree);\n  \t\tvar union = this.binaryUnion(geoms);\n  \t\treturn union;\n  \t},\n  \tunionUsingEnvelopeIntersection: function unionUsingEnvelopeIntersection(g0, g1, common) {\n  \t\tvar disjointPolys = new ArrayList();\n  \t\tvar g0Int = this.extractByEnvelope(common, g0, disjointPolys);\n  \t\tvar g1Int = this.extractByEnvelope(common, g1, disjointPolys);\n  \t\tvar union = this.unionActual(g0Int, g1Int);\n  \t\tdisjointPolys.add(union);\n  \t\tvar overallUnion = GeometryCombiner.combine(disjointPolys);\n  \t\treturn overallUnion;\n  \t},\n  \tbufferUnion: function bufferUnion() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar geoms = arguments[0];\n  \t\t\tvar factory = geoms.get(0).getFactory();\n  \t\t\tvar gColl = factory.buildGeometry(geoms);\n  \t\t\tvar unionAll = gColl.buffer(0.0);\n  \t\t\treturn unionAll;\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar g0 = arguments[0],\n  \t\t\t    g1 = arguments[1];\n  \t\t\tvar factory = g0.getFactory();\n  \t\t\tvar gColl = factory.createGeometryCollection([g0, g1]);\n  \t\t\tvar unionAll = gColl.buffer(0.0);\n  \t\t\treturn unionAll;\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn CascadedPolygonUnion;\n  \t}\n  });\n  CascadedPolygonUnion.restrictToPolygons = function (g) {\n  \tif (hasInterface(g, Polygonal)) {\n  \t\treturn g;\n  \t}\n  \tvar polygons = PolygonExtracter.getPolygons(g);\n  \tif (polygons.size() === 1) return polygons.get(0);\n  \treturn g.getFactory().createMultiPolygon(GeometryFactory.toPolygonArray(polygons));\n  };\n  CascadedPolygonUnion.getGeometry = function (list, index) {\n  \tif (index >= list.size()) return null;\n  \treturn list.get(index);\n  };\n  CascadedPolygonUnion.union = function (polys) {\n  \tvar op = new CascadedPolygonUnion(polys);\n  \treturn op.union();\n  };\n  CascadedPolygonUnion.STRTREE_NODE_CAPACITY = 4;\n\n  function PointGeometryUnion() {\n  \tthis._pointGeom = null;\n  \tthis._otherGeom = null;\n  \tthis._geomFact = null;\n  \tvar pointGeom = arguments[0],\n  \t    otherGeom = arguments[1];\n  \tthis._pointGeom = pointGeom;\n  \tthis._otherGeom = otherGeom;\n  \tthis._geomFact = otherGeom.getFactory();\n  }\n  extend(PointGeometryUnion.prototype, {\n  \tunion: function union() {\n  \t\tvar locater = new PointLocator();\n  \t\tvar exteriorCoords = new TreeSet();\n  \t\tfor (var i = 0; i < this._pointGeom.getNumGeometries(); i++) {\n  \t\t\tvar point = this._pointGeom.getGeometryN(i);\n  \t\t\tvar coord = point.getCoordinate();\n  \t\t\tvar loc = locater.locate(coord, this._otherGeom);\n  \t\t\tif (loc === Location.EXTERIOR) exteriorCoords.add(coord);\n  \t\t}\n  \t\tif (exteriorCoords.size() === 0) return this._otherGeom;\n  \t\tvar ptComp = null;\n  \t\tvar coords = CoordinateArrays.toCoordinateArray(exteriorCoords);\n  \t\tif (coords.length === 1) {\n  \t\t\tptComp = this._geomFact.createPoint(coords[0]);\n  \t\t} else {\n  \t\t\tptComp = this._geomFact.createMultiPointFromCoords(coords);\n  \t\t}\n  \t\treturn GeometryCombiner.combine(ptComp, this._otherGeom);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn PointGeometryUnion;\n  \t}\n  });\n  PointGeometryUnion.union = function (pointGeom, otherGeom) {\n  \tvar unioner = new PointGeometryUnion(pointGeom, otherGeom);\n  \treturn unioner.union();\n  };\n\n  function GeometryExtracter() {\n  \tthis._sortIndex = -1;\n  \tthis._comps = null;\n  \tvar sortIndex = arguments[0],\n  \t    comps = arguments[1];\n  \tthis._sortIndex = sortIndex;\n  \tthis._comps = comps;\n  }\n  extend(GeometryExtracter.prototype, {\n  \tfilter: function filter(geom) {\n  \t\tif (this._sortIndex === -1 || geom.getSortIndex() === this._sortIndex) this._comps.add(geom);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [GeometryFilter];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn GeometryExtracter;\n  \t}\n  });\n  GeometryExtracter.extract = function () {\n  \tif (arguments.length === 2) {\n  \t\tvar geom = arguments[0],\n  \t\t    sortIndex = arguments[1];\n  \t\treturn GeometryExtracter.extract(geom, sortIndex, new ArrayList());\n  \t} else if (arguments.length === 3) {\n  \t\tvar geom = arguments[0],\n  \t\t    sortIndex = arguments[1],\n  \t\t    list = arguments[2];\n  \t\tif (geom.getSortIndex() === sortIndex) {\n  \t\t\tlist.add(geom);\n  \t\t} else if (geom instanceof GeometryCollection) {\n  \t\t\tgeom.apply(new GeometryExtracter(sortIndex, list));\n  \t\t}\n  \t\treturn list;\n  \t}\n  };\n\n  function UnaryUnionOp() {\n  \tthis._polygons = new ArrayList();\n  \tthis._lines = new ArrayList();\n  \tthis._points = new ArrayList();\n  \tthis._geomFact = null;\n  \tif (arguments.length === 1) {\n  \t\tif (hasInterface(arguments[0], Collection)) {\n  \t\t\tvar geoms = arguments[0];\n  \t\t\tthis.extract(geoms);\n  \t\t} else if (arguments[0] instanceof Geometry) {\n  \t\t\tvar geom = arguments[0];\n  \t\t\tthis.extract(geom);\n  \t\t}\n  \t} else if (arguments.length === 2) {\n  \t\tvar geoms = arguments[0],\n  \t\t    geomFact = arguments[1];\n  \t\tthis._geomFact = geomFact;\n  \t\tthis.extract(geoms);\n  \t}\n  }\n  extend(UnaryUnionOp.prototype, {\n  \tunionNoOpt: function unionNoOpt(g0) {\n  \t\tvar empty = this._geomFact.createPoint();\n  \t\treturn SnapIfNeededOverlayOp.overlayOp(g0, empty, OverlayOp.UNION);\n  \t},\n  \tunionWithNull: function unionWithNull(g0, g1) {\n  \t\tif (g0 === null && g1 === null) return null;\n  \t\tif (g1 === null) return g0;\n  \t\tif (g0 === null) return g1;\n  \t\treturn g0.union(g1);\n  \t},\n  \textract: function extract() {\n  \t\tif (hasInterface(arguments[0], Collection)) {\n  \t\t\tvar geoms = arguments[0];\n  \t\t\tfor (var i = geoms.iterator(); i.hasNext();) {\n  \t\t\t\tvar geom = i.next();\n  \t\t\t\tthis.extract(geom);\n  \t\t\t}\n  \t\t} else if (arguments[0] instanceof Geometry) {\n  \t\t\tvar geom = arguments[0];\n  \t\t\tif (this._geomFact === null) this._geomFact = geom.getFactory();\n  \t\t\tGeometryExtracter.extract(geom, Geometry.SORTINDEX_POLYGON, this._polygons);\n  \t\t\tGeometryExtracter.extract(geom, Geometry.SORTINDEX_LINESTRING, this._lines);\n  \t\t\tGeometryExtracter.extract(geom, Geometry.SORTINDEX_POINT, this._points);\n  \t\t}\n  \t},\n  \tunion: function union() {\n  \t\tif (this._geomFact === null) {\n  \t\t\treturn null;\n  \t\t}\n  \t\tvar unionPoints = null;\n  \t\tif (this._points.size() > 0) {\n  \t\t\tvar ptGeom = this._geomFact.buildGeometry(this._points);\n  \t\t\tunionPoints = this.unionNoOpt(ptGeom);\n  \t\t}\n  \t\tvar unionLines = null;\n  \t\tif (this._lines.size() > 0) {\n  \t\t\tvar lineGeom = this._geomFact.buildGeometry(this._lines);\n  \t\t\tunionLines = this.unionNoOpt(lineGeom);\n  \t\t}\n  \t\tvar unionPolygons = null;\n  \t\tif (this._polygons.size() > 0) {\n  \t\t\tunionPolygons = CascadedPolygonUnion.union(this._polygons);\n  \t\t}\n  \t\tvar unionLA = this.unionWithNull(unionLines, unionPolygons);\n  \t\tvar union = null;\n  \t\tif (unionPoints === null) union = unionLA;else if (unionLA === null) union = unionPoints;else union = PointGeometryUnion.union(unionPoints, unionLA);\n  \t\tif (union === null) return this._geomFact.createGeometryCollection();\n  \t\treturn union;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn UnaryUnionOp;\n  \t}\n  });\n  UnaryUnionOp.union = function () {\n  \tif (arguments.length === 1) {\n  \t\tif (hasInterface(arguments[0], Collection)) {\n  \t\t\tvar geoms = arguments[0];\n  \t\t\tvar op = new UnaryUnionOp(geoms);\n  \t\t\treturn op.union();\n  \t\t} else if (arguments[0] instanceof Geometry) {\n  \t\t\tvar geom = arguments[0];\n  \t\t\tvar op = new UnaryUnionOp(geom);\n  \t\t\treturn op.union();\n  \t\t}\n  \t} else if (arguments.length === 2) {\n  \t\tvar geoms = arguments[0],\n  \t\t    geomFact = arguments[1];\n  \t\tvar op = new UnaryUnionOp(geoms, geomFact);\n  \t\treturn op.union();\n  \t}\n  };\n\n  function UnionInteracting() {\n  \tthis._geomFactory = null;\n  \tthis._g0 = null;\n  \tthis._g1 = null;\n  \tthis._interacts0 = null;\n  \tthis._interacts1 = null;\n  \tvar g0 = arguments[0],\n  \t    g1 = arguments[1];\n  \tthis._g0 = g0;\n  \tthis._g1 = g1;\n  \tthis._geomFactory = g0.getFactory();\n  \tthis._interacts0 = new Array(g0.getNumGeometries()).fill(null);\n  \tthis._interacts1 = new Array(g1.getNumGeometries()).fill(null);\n  }\n  extend(UnionInteracting.prototype, {\n  \textractElements: function extractElements(geom, interacts, isInteracting) {\n  \t\tvar extractedGeoms = new ArrayList();\n  \t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n  \t\t\tvar elem = geom.getGeometryN(i);\n  \t\t\tif (interacts[i] === isInteracting) extractedGeoms.add(elem);\n  \t\t}\n  \t\treturn this._geomFactory.buildGeometry(extractedGeoms);\n  \t},\n  \tcomputeInteracting: function computeInteracting() {\n  \t\tif (arguments.length === 0) {\n  \t\t\tfor (var i = 0; i < this._g0.getNumGeometries(); i++) {\n  \t\t\t\tvar elem = this._g0.getGeometryN(i);\n  \t\t\t\tthis._interacts0[i] = this.computeInteracting(elem);\n  \t\t\t}\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tvar elem0 = arguments[0];\n  \t\t\tvar interactsWithAny = false;\n  \t\t\tfor (var i = 0; i < this._g1.getNumGeometries(); i++) {\n  \t\t\t\tvar elem1 = this._g1.getGeometryN(i);\n  \t\t\t\tvar interacts = elem1.getEnvelopeInternal().intersects(elem0.getEnvelopeInternal());\n  \t\t\t\tif (interacts) this._interacts1[i] = true;\n  \t\t\t\tif (interacts) interactsWithAny = true;\n  \t\t\t}\n  \t\t\treturn interactsWithAny;\n  \t\t}\n  \t},\n  \tunion: function union() {\n  \t\tthis.computeInteracting();\n  \t\tvar int0 = this.extractElements(this._g0, this._interacts0, true);\n  \t\tvar int1 = this.extractElements(this._g1, this._interacts1, true);\n  \t\tif (int0.isEmpty() || int1.isEmpty()) {\n  \t\t\tSystem.out.println(\"found empty!\");\n  \t\t}\n  \t\tvar union = int0.union(int1);\n  \t\tvar disjoint0 = this.extractElements(this._g0, this._interacts0, false);\n  \t\tvar disjoint1 = this.extractElements(this._g1, this._interacts1, false);\n  \t\tvar overallUnion = GeometryCombiner.combine(union, disjoint0, disjoint1);\n  \t\treturn overallUnion;\n  \t},\n  \tbufferUnion: function bufferUnion(g0, g1) {\n  \t\tvar factory = g0.getFactory();\n  \t\tvar gColl = factory.createGeometryCollection([g0, g1]);\n  \t\tvar unionAll = gColl.buffer(0.0);\n  \t\treturn unionAll;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn UnionInteracting;\n  \t}\n  });\n  UnionInteracting.union = function (g0, g1) {\n  \tvar uue = new UnionInteracting(g0, g1);\n  \treturn uue.union();\n  };\n\n  function UnionOp() {}\n  extend(UnionOp.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn UnionOp;\n  \t}\n  });\n  UnionOp.union = function (g, other) {\n  \tif (g.isEmpty() || other.isEmpty()) {\n  \t\tif (g.isEmpty() && other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.UNION, g, other, g.getFactory());\n  \t\tif (g.isEmpty()) return other.copy();\n  \t\tif (other.isEmpty()) return g.copy();\n  \t}\n  \tg.checkNotGeometryCollection(g);\n  \tg.checkNotGeometryCollection(other);\n  \treturn SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.UNION);\n  };\n\n  function PrecisionReducerCoordinateOperation() {\n  \tGeometryEditor.CoordinateOperation.apply(this);\n  \tthis._targetPM = null;\n  \tthis._removeCollapsed = true;\n  \tvar targetPM = arguments[0],\n  \t    removeCollapsed = arguments[1];\n  \tthis._targetPM = targetPM;\n  \tthis._removeCollapsed = removeCollapsed;\n  }\n  inherits$1(PrecisionReducerCoordinateOperation, GeometryEditor.CoordinateOperation);\n  extend(PrecisionReducerCoordinateOperation.prototype, {\n  \teditCoordinates: function editCoordinates(coordinates, geom) {\n  \t\tif (coordinates.length === 0) return null;\n  \t\tvar reducedCoords = new Array(coordinates.length).fill(null);\n  \t\tfor (var i = 0; i < coordinates.length; i++) {\n  \t\t\tvar coord = new Coordinate(coordinates[i]);\n  \t\t\tthis._targetPM.makePrecise(coord);\n  \t\t\treducedCoords[i] = coord;\n  \t\t}\n  \t\tvar noRepeatedCoordList = new CoordinateList(reducedCoords, false);\n  \t\tvar noRepeatedCoords = noRepeatedCoordList.toCoordinateArray();\n  \t\tvar minLength = 0;\n  \t\tif (geom instanceof LineString) minLength = 2;\n  \t\tif (geom instanceof LinearRing) minLength = 4;\n  \t\tvar collapsedCoords = reducedCoords;\n  \t\tif (this._removeCollapsed) collapsedCoords = null;\n  \t\tif (noRepeatedCoords.length < minLength) {\n  \t\t\treturn collapsedCoords;\n  \t\t}\n  \t\treturn noRepeatedCoords;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn PrecisionReducerCoordinateOperation;\n  \t}\n  });\n\n  function GeometryPrecisionReducer() {\n  \tthis._targetPM = null;\n  \tthis._removeCollapsed = true;\n  \tthis._changePrecisionModel = false;\n  \tthis._isPointwise = false;\n  \tvar pm = arguments[0];\n  \tthis._targetPM = pm;\n  }\n  extend(GeometryPrecisionReducer.prototype, {\n  \tfixPolygonalTopology: function fixPolygonalTopology(geom) {\n  \t\tvar geomToBuffer = geom;\n  \t\tif (!this._changePrecisionModel) {\n  \t\t\tgeomToBuffer = this.changePM(geom, this._targetPM);\n  \t\t}\n  \t\tvar bufGeom = geomToBuffer.buffer(0);\n  \t\tvar finalGeom = bufGeom;\n  \t\tif (!this._changePrecisionModel) {\n  \t\t\tfinalGeom = this.changePM(bufGeom, geom.getPrecisionModel());\n  \t\t}\n  \t\treturn finalGeom;\n  \t},\n  \treducePointwise: function reducePointwise(geom) {\n  \t\tvar geomEdit = null;\n  \t\tif (this._changePrecisionModel) {\n  \t\t\tvar newFactory = this.createFactory(geom.getFactory(), this._targetPM);\n  \t\t\tgeomEdit = new GeometryEditor(newFactory);\n  \t\t} else geomEdit = new GeometryEditor();\n  \t\tvar finalRemoveCollapsed = this._removeCollapsed;\n  \t\tif (geom.getDimension() >= 2) finalRemoveCollapsed = true;\n  \t\tvar reduceGeom = geomEdit.edit(geom, new PrecisionReducerCoordinateOperation(this._targetPM, finalRemoveCollapsed));\n  \t\treturn reduceGeom;\n  \t},\n  \tchangePM: function changePM(geom, newPM) {\n  \t\tvar geomEditor = this.createEditor(geom.getFactory(), newPM);\n  \t\treturn geomEditor.edit(geom, new GeometryEditor.NoOpGeometryOperation());\n  \t},\n  \tsetRemoveCollapsedComponents: function setRemoveCollapsedComponents(removeCollapsed) {\n  \t\tthis._removeCollapsed = removeCollapsed;\n  \t},\n  \tcreateFactory: function createFactory(inputFactory, pm) {\n  \t\tvar newFactory = new GeometryFactory(pm, inputFactory.getSRID(), inputFactory.getCoordinateSequenceFactory());\n  \t\treturn newFactory;\n  \t},\n  \tsetChangePrecisionModel: function setChangePrecisionModel(changePrecisionModel) {\n  \t\tthis._changePrecisionModel = changePrecisionModel;\n  \t},\n  \treduce: function reduce(geom) {\n  \t\tvar reducePW = this.reducePointwise(geom);\n  \t\tif (this._isPointwise) return reducePW;\n  \t\tif (!hasInterface(reducePW, Polygonal)) return reducePW;\n  \t\tif (reducePW.isValid()) return reducePW;\n  \t\treturn this.fixPolygonalTopology(reducePW);\n  \t},\n  \tsetPointwise: function setPointwise(isPointwise) {\n  \t\tthis._isPointwise = isPointwise;\n  \t},\n  \tcreateEditor: function createEditor(geomFactory, newPM) {\n  \t\tif (geomFactory.getPrecisionModel() === newPM) return new GeometryEditor();\n  \t\tvar newFactory = this.createFactory(geomFactory, newPM);\n  \t\tvar geomEdit = new GeometryEditor(newFactory);\n  \t\treturn geomEdit;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn GeometryPrecisionReducer;\n  \t}\n  });\n  GeometryPrecisionReducer.reduce = function (g, precModel) {\n  \tvar reducer = new GeometryPrecisionReducer(precModel);\n  \treturn reducer.reduce(g);\n  };\n  GeometryPrecisionReducer.reducePointwise = function (g, precModel) {\n  \tvar reducer = new GeometryPrecisionReducer(precModel);\n  \treducer.setPointwise(true);\n  \treturn reducer.reduce(g);\n  };\n\n  function DouglasPeuckerLineSimplifier() {\n  \tthis._pts = null;\n  \tthis._usePt = null;\n  \tthis._distanceTolerance = null;\n  \tthis._seg = new LineSegment();\n  \tvar pts = arguments[0];\n  \tthis._pts = pts;\n  }\n  extend(DouglasPeuckerLineSimplifier.prototype, {\n  \tsimplifySection: function simplifySection(i, j) {\n  \t\tif (i + 1 === j) {\n  \t\t\treturn null;\n  \t\t}\n  \t\tthis._seg.p0 = this._pts[i];\n  \t\tthis._seg.p1 = this._pts[j];\n  \t\tvar maxDistance = -1.0;\n  \t\tvar maxIndex = i;\n  \t\tfor (var k = i + 1; k < j; k++) {\n  \t\t\tvar distance = this._seg.distance(this._pts[k]);\n  \t\t\tif (distance > maxDistance) {\n  \t\t\t\tmaxDistance = distance;\n  \t\t\t\tmaxIndex = k;\n  \t\t\t}\n  \t\t}\n  \t\tif (maxDistance <= this._distanceTolerance) {\n  \t\t\tfor (var k = i + 1; k < j; k++) {\n  \t\t\t\tthis._usePt[k] = false;\n  \t\t\t}\n  \t\t} else {\n  \t\t\tthis.simplifySection(i, maxIndex);\n  \t\t\tthis.simplifySection(maxIndex, j);\n  \t\t}\n  \t},\n  \tsetDistanceTolerance: function setDistanceTolerance(distanceTolerance) {\n  \t\tthis._distanceTolerance = distanceTolerance;\n  \t},\n  \tsimplify: function simplify() {\n  \t\tthis._usePt = new Array(this._pts.length).fill(null);\n  \t\tfor (var i = 0; i < this._pts.length; i++) {\n  \t\t\tthis._usePt[i] = true;\n  \t\t}\n  \t\tthis.simplifySection(0, this._pts.length - 1);\n  \t\tvar coordList = new CoordinateList();\n  \t\tfor (var i = 0; i < this._pts.length; i++) {\n  \t\t\tif (this._usePt[i]) coordList.add(new Coordinate(this._pts[i]));\n  \t\t}\n  \t\treturn coordList.toCoordinateArray();\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn DouglasPeuckerLineSimplifier;\n  \t}\n  });\n  DouglasPeuckerLineSimplifier.simplify = function (pts, distanceTolerance) {\n  \tvar simp = new DouglasPeuckerLineSimplifier(pts);\n  \tsimp.setDistanceTolerance(distanceTolerance);\n  \treturn simp.simplify();\n  };\n\n  function DouglasPeuckerSimplifier() {\n  \tthis._inputGeom = null;\n  \tthis._distanceTolerance = null;\n  \tthis._isEnsureValidTopology = true;\n  \tvar inputGeom = arguments[0];\n  \tthis._inputGeom = inputGeom;\n  }\n  extend(DouglasPeuckerSimplifier.prototype, {\n  \tsetEnsureValid: function setEnsureValid(isEnsureValidTopology) {\n  \t\tthis._isEnsureValidTopology = isEnsureValidTopology;\n  \t},\n  \tgetResultGeometry: function getResultGeometry() {\n  \t\tif (this._inputGeom.isEmpty()) return this._inputGeom.copy();\n  \t\treturn new DPTransformer(this._isEnsureValidTopology, this._distanceTolerance).transform(this._inputGeom);\n  \t},\n  \tsetDistanceTolerance: function setDistanceTolerance(distanceTolerance) {\n  \t\tif (distanceTolerance < 0.0) throw new IllegalArgumentException(\"Tolerance must be non-negative\");\n  \t\tthis._distanceTolerance = distanceTolerance;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn DouglasPeuckerSimplifier;\n  \t}\n  });\n  DouglasPeuckerSimplifier.simplify = function (geom, distanceTolerance) {\n  \tvar tss = new DouglasPeuckerSimplifier(geom);\n  \ttss.setDistanceTolerance(distanceTolerance);\n  \treturn tss.getResultGeometry();\n  };\n  function DPTransformer() {\n  \tGeometryTransformer.apply(this);\n  \tthis._isEnsureValidTopology = true;\n  \tthis._distanceTolerance = null;\n  \tvar isEnsureValidTopology = arguments[0],\n  \t    distanceTolerance = arguments[1];\n  \tthis._isEnsureValidTopology = isEnsureValidTopology;\n  \tthis._distanceTolerance = distanceTolerance;\n  }\n  inherits$1(DPTransformer, GeometryTransformer);\n  extend(DPTransformer.prototype, {\n  \ttransformPolygon: function transformPolygon(geom, parent) {\n  \t\tif (geom.isEmpty()) return null;\n  \t\tvar rawGeom = GeometryTransformer.prototype.transformPolygon.call(this, geom, parent);\n  \t\tif (parent instanceof MultiPolygon) {\n  \t\t\treturn rawGeom;\n  \t\t}\n  \t\treturn this.createValidArea(rawGeom);\n  \t},\n  \tcreateValidArea: function createValidArea(rawAreaGeom) {\n  \t\tif (this._isEnsureValidTopology) return rawAreaGeom.buffer(0.0);\n  \t\treturn rawAreaGeom;\n  \t},\n  \ttransformCoordinates: function transformCoordinates(coords, parent) {\n  \t\tvar inputPts = coords.toCoordinateArray();\n  \t\tvar newPts = null;\n  \t\tif (inputPts.length === 0) {\n  \t\t\tnewPts = new Array(0).fill(null);\n  \t\t} else {\n  \t\t\tnewPts = DouglasPeuckerLineSimplifier.simplify(inputPts, this._distanceTolerance);\n  \t\t}\n  \t\treturn this._factory.getCoordinateSequenceFactory().create(newPts);\n  \t},\n  \ttransformMultiPolygon: function transformMultiPolygon(geom, parent) {\n  \t\tvar rawGeom = GeometryTransformer.prototype.transformMultiPolygon.call(this, geom, parent);\n  \t\treturn this.createValidArea(rawGeom);\n  \t},\n  \ttransformLinearRing: function transformLinearRing(geom, parent) {\n  \t\tvar removeDegenerateRings = parent instanceof Polygon;\n  \t\tvar simpResult = GeometryTransformer.prototype.transformLinearRing.call(this, geom, parent);\n  \t\tif (removeDegenerateRings && !(simpResult instanceof LinearRing)) return null;\n  \t\treturn simpResult;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn DPTransformer;\n  \t}\n  });\n  DouglasPeuckerSimplifier.DPTransformer = DPTransformer;\n\n  function TaggedLineSegment() {\n  \tthis._parent = null;\n  \tthis._index = null;\n  \tif (arguments.length === 2) {\n  \t\tvar p0 = arguments[0],\n  \t\t    p1 = arguments[1];\n  \t\tTaggedLineSegment.call(this, p0, p1, null, -1);\n  \t} else if (arguments.length === 4) {\n  \t\tvar p0 = arguments[0],\n  \t\t    p1 = arguments[1],\n  \t\t    parent = arguments[2],\n  \t\t    index = arguments[3];\n  \t\tLineSegment.call(this, p0, p1);\n  \t\tthis._parent = parent;\n  \t\tthis._index = index;\n  \t}\n  }\n  inherits$1(TaggedLineSegment, LineSegment);\n  extend(TaggedLineSegment.prototype, {\n  \tgetIndex: function getIndex() {\n  \t\treturn this._index;\n  \t},\n  \tgetParent: function getParent() {\n  \t\treturn this._parent;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn TaggedLineSegment;\n  \t}\n  });\n\n  function TaggedLineString() {\n  \tthis._parentLine = null;\n  \tthis._segs = null;\n  \tthis._resultSegs = new ArrayList();\n  \tthis._minimumSize = null;\n  \tif (arguments.length === 1) {\n  \t\tvar parentLine = arguments[0];\n  \t\tTaggedLineString.call(this, parentLine, 2);\n  \t} else if (arguments.length === 2) {\n  \t\tvar parentLine = arguments[0],\n  \t\t    minimumSize = arguments[1];\n  \t\tthis._parentLine = parentLine;\n  \t\tthis._minimumSize = minimumSize;\n  \t\tthis.init();\n  \t}\n  }\n  extend(TaggedLineString.prototype, {\n  \taddToResult: function addToResult(seg) {\n  \t\tthis._resultSegs.add(seg);\n  \t},\n  \tasLineString: function asLineString() {\n  \t\treturn this._parentLine.getFactory().createLineString(TaggedLineString.extractCoordinates(this._resultSegs));\n  \t},\n  \tgetResultSize: function getResultSize() {\n  \t\tvar resultSegsSize = this._resultSegs.size();\n  \t\treturn resultSegsSize === 0 ? 0 : resultSegsSize + 1;\n  \t},\n  \tgetParent: function getParent() {\n  \t\treturn this._parentLine;\n  \t},\n  \tgetSegment: function getSegment(i) {\n  \t\treturn this._segs[i];\n  \t},\n  \tgetParentCoordinates: function getParentCoordinates() {\n  \t\treturn this._parentLine.getCoordinates();\n  \t},\n  \tgetMinimumSize: function getMinimumSize() {\n  \t\treturn this._minimumSize;\n  \t},\n  \tasLinearRing: function asLinearRing() {\n  \t\treturn this._parentLine.getFactory().createLinearRing(TaggedLineString.extractCoordinates(this._resultSegs));\n  \t},\n  \tgetSegments: function getSegments() {\n  \t\treturn this._segs;\n  \t},\n  \tinit: function init() {\n  \t\tvar pts = this._parentLine.getCoordinates();\n  \t\tthis._segs = new Array(pts.length - 1).fill(null);\n  \t\tfor (var i = 0; i < pts.length - 1; i++) {\n  \t\t\tvar seg = new TaggedLineSegment(pts[i], pts[i + 1], this._parentLine, i);\n  \t\t\tthis._segs[i] = seg;\n  \t\t}\n  \t},\n  \tgetResultCoordinates: function getResultCoordinates() {\n  \t\treturn TaggedLineString.extractCoordinates(this._resultSegs);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn TaggedLineString;\n  \t}\n  });\n  TaggedLineString.extractCoordinates = function (segs) {\n  \tvar pts = new Array(segs.size() + 1).fill(null);\n  \tvar seg = null;\n  \tfor (var i = 0; i < segs.size(); i++) {\n  \t\tseg = segs.get(i);\n  \t\tpts[i] = seg.p0;\n  \t}\n  \tpts[pts.length - 1] = seg.p1;\n  \treturn pts;\n  };\n\n  function LineSegmentIndex() {\n  \tthis._index = new Quadtree();\n  }\n  extend(LineSegmentIndex.prototype, {\n  \tremove: function remove(seg) {\n  \t\tthis._index.remove(new Envelope(seg.p0, seg.p1), seg);\n  \t},\n  \tadd: function add() {\n  \t\tif (arguments[0] instanceof TaggedLineString) {\n  \t\t\tvar line = arguments[0];\n  \t\t\tvar segs = line.getSegments();\n  \t\t\tfor (var i = 0; i < segs.length; i++) {\n  \t\t\t\tvar seg = segs[i];\n  \t\t\t\tthis.add(seg);\n  \t\t\t}\n  \t\t} else if (arguments[0] instanceof LineSegment) {\n  \t\t\tvar seg = arguments[0];\n  \t\t\tthis._index.insert(new Envelope(seg.p0, seg.p1), seg);\n  \t\t}\n  \t},\n  \tquery: function query(querySeg) {\n  \t\tvar env = new Envelope(querySeg.p0, querySeg.p1);\n  \t\tvar visitor = new LineSegmentVisitor(querySeg);\n  \t\tthis._index.query(env, visitor);\n  \t\tvar itemsFound = visitor.getItems();\n  \t\treturn itemsFound;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LineSegmentIndex;\n  \t}\n  });\n  function LineSegmentVisitor() {\n  \tthis._querySeg = null;\n  \tthis._items = new ArrayList();\n  \tvar querySeg = arguments[0];\n  \tthis._querySeg = querySeg;\n  }\n  extend(LineSegmentVisitor.prototype, {\n  \tvisitItem: function visitItem(item) {\n  \t\tvar seg = item;\n  \t\tif (Envelope.intersects(seg.p0, seg.p1, this._querySeg.p0, this._querySeg.p1)) this._items.add(item);\n  \t},\n  \tgetItems: function getItems() {\n  \t\treturn this._items;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [ItemVisitor];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LineSegmentVisitor;\n  \t}\n  });\n\n  function TaggedLineStringSimplifier() {\n  \tthis._li = new RobustLineIntersector();\n  \tthis._inputIndex = new LineSegmentIndex();\n  \tthis._outputIndex = new LineSegmentIndex();\n  \tthis._line = null;\n  \tthis._linePts = null;\n  \tthis._distanceTolerance = 0.0;\n  \tvar inputIndex = arguments[0],\n  \t    outputIndex = arguments[1];\n  \tthis._inputIndex = inputIndex;\n  \tthis._outputIndex = outputIndex;\n  }\n  extend(TaggedLineStringSimplifier.prototype, {\n  \tflatten: function flatten(start, end) {\n  \t\tvar p0 = this._linePts[start];\n  \t\tvar p1 = this._linePts[end];\n  \t\tvar newSeg = new LineSegment(p0, p1);\n  \t\tthis.remove(this._line, start, end);\n  \t\tthis._outputIndex.add(newSeg);\n  \t\treturn newSeg;\n  \t},\n  \thasBadIntersection: function hasBadIntersection(parentLine, sectionIndex, candidateSeg) {\n  \t\tif (this.hasBadOutputIntersection(candidateSeg)) return true;\n  \t\tif (this.hasBadInputIntersection(parentLine, sectionIndex, candidateSeg)) return true;\n  \t\treturn false;\n  \t},\n  \tsetDistanceTolerance: function setDistanceTolerance(distanceTolerance) {\n  \t\tthis._distanceTolerance = distanceTolerance;\n  \t},\n  \tsimplifySection: function simplifySection(i, j, depth) {\n  \t\tdepth += 1;\n  \t\tvar sectionIndex = new Array(2).fill(null);\n  \t\tif (i + 1 === j) {\n  \t\t\tvar newSeg = this._line.getSegment(i);\n  \t\t\tthis._line.addToResult(newSeg);\n  \t\t\treturn null;\n  \t\t}\n  \t\tvar isValidToSimplify = true;\n  \t\tif (this._line.getResultSize() < this._line.getMinimumSize()) {\n  \t\t\tvar worstCaseSize = depth + 1;\n  \t\t\tif (worstCaseSize < this._line.getMinimumSize()) isValidToSimplify = false;\n  \t\t}\n  \t\tvar distance = new Array(1).fill(null);\n  \t\tvar furthestPtIndex = this.findFurthestPoint(this._linePts, i, j, distance);\n  \t\tif (distance[0] > this._distanceTolerance) isValidToSimplify = false;\n  \t\tvar candidateSeg = new LineSegment();\n  \t\tcandidateSeg.p0 = this._linePts[i];\n  \t\tcandidateSeg.p1 = this._linePts[j];\n  \t\tsectionIndex[0] = i;\n  \t\tsectionIndex[1] = j;\n  \t\tif (this.hasBadIntersection(this._line, sectionIndex, candidateSeg)) isValidToSimplify = false;\n  \t\tif (isValidToSimplify) {\n  \t\t\tvar newSeg = this.flatten(i, j);\n  \t\t\tthis._line.addToResult(newSeg);\n  \t\t\treturn null;\n  \t\t}\n  \t\tthis.simplifySection(i, furthestPtIndex, depth);\n  \t\tthis.simplifySection(furthestPtIndex, j, depth);\n  \t},\n  \thasBadOutputIntersection: function hasBadOutputIntersection(candidateSeg) {\n  \t\tvar querySegs = this._outputIndex.query(candidateSeg);\n  \t\tfor (var i = querySegs.iterator(); i.hasNext();) {\n  \t\t\tvar querySeg = i.next();\n  \t\t\tif (this.hasInteriorIntersection(querySeg, candidateSeg)) {\n  \t\t\t\treturn true;\n  \t\t\t}\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tfindFurthestPoint: function findFurthestPoint(pts, i, j, maxDistance) {\n  \t\tvar seg = new LineSegment();\n  \t\tseg.p0 = pts[i];\n  \t\tseg.p1 = pts[j];\n  \t\tvar maxDist = -1.0;\n  \t\tvar maxIndex = i;\n  \t\tfor (var k = i + 1; k < j; k++) {\n  \t\t\tvar midPt = pts[k];\n  \t\t\tvar distance = seg.distance(midPt);\n  \t\t\tif (distance > maxDist) {\n  \t\t\t\tmaxDist = distance;\n  \t\t\t\tmaxIndex = k;\n  \t\t\t}\n  \t\t}\n  \t\tmaxDistance[0] = maxDist;\n  \t\treturn maxIndex;\n  \t},\n  \tsimplify: function simplify(line) {\n  \t\tthis._line = line;\n  \t\tthis._linePts = line.getParentCoordinates();\n  \t\tthis.simplifySection(0, this._linePts.length - 1, 0);\n  \t},\n  \tremove: function remove(line, start, end) {\n  \t\tfor (var i = start; i < end; i++) {\n  \t\t\tvar seg = line.getSegment(i);\n  \t\t\tthis._inputIndex.remove(seg);\n  \t\t}\n  \t},\n  \thasInteriorIntersection: function hasInteriorIntersection(seg0, seg1) {\n  \t\tthis._li.computeIntersection(seg0.p0, seg0.p1, seg1.p0, seg1.p1);\n  \t\treturn this._li.isInteriorIntersection();\n  \t},\n  \thasBadInputIntersection: function hasBadInputIntersection(parentLine, sectionIndex, candidateSeg) {\n  \t\tvar querySegs = this._inputIndex.query(candidateSeg);\n  \t\tfor (var i = querySegs.iterator(); i.hasNext();) {\n  \t\t\tvar querySeg = i.next();\n  \t\t\tif (this.hasInteriorIntersection(querySeg, candidateSeg)) {\n  \t\t\t\tif (TaggedLineStringSimplifier.isInLineSection(parentLine, sectionIndex, querySeg)) continue;\n  \t\t\t\treturn true;\n  \t\t\t}\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn TaggedLineStringSimplifier;\n  \t}\n  });\n  TaggedLineStringSimplifier.isInLineSection = function (line, sectionIndex, seg) {\n  \tif (seg.getParent() !== line.getParent()) return false;\n  \tvar segIndex = seg.getIndex();\n  \tif (segIndex >= sectionIndex[0] && segIndex < sectionIndex[1]) return true;\n  \treturn false;\n  };\n\n  function TaggedLinesSimplifier() {\n  \tthis._inputIndex = new LineSegmentIndex();\n  \tthis._outputIndex = new LineSegmentIndex();\n  \tthis._distanceTolerance = 0.0;\n  }\n  extend(TaggedLinesSimplifier.prototype, {\n  \tsetDistanceTolerance: function setDistanceTolerance(distanceTolerance) {\n  \t\tthis._distanceTolerance = distanceTolerance;\n  \t},\n  \tsimplify: function simplify(taggedLines) {\n  \t\tfor (var i = taggedLines.iterator(); i.hasNext();) {\n  \t\t\tthis._inputIndex.add(i.next());\n  \t\t}\n  \t\tfor (var i = taggedLines.iterator(); i.hasNext();) {\n  \t\t\tvar tlss = new TaggedLineStringSimplifier(this._inputIndex, this._outputIndex);\n  \t\t\ttlss.setDistanceTolerance(this._distanceTolerance);\n  \t\t\ttlss.simplify(i.next());\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn TaggedLinesSimplifier;\n  \t}\n  });\n\n  function TopologyPreservingSimplifier() {\n  \tthis._inputGeom = null;\n  \tthis._lineSimplifier = new TaggedLinesSimplifier();\n  \tthis._linestringMap = null;\n  \tvar inputGeom = arguments[0];\n  \tthis._inputGeom = inputGeom;\n  }\n  extend(TopologyPreservingSimplifier.prototype, {\n  \tgetResultGeometry: function getResultGeometry() {\n  \t\tif (this._inputGeom.isEmpty()) return this._inputGeom.copy();\n  \t\tthis._linestringMap = new HashMap();\n  \t\tthis._inputGeom.apply(new LineStringMapBuilderFilter(this));\n  \t\tthis._lineSimplifier.simplify(this._linestringMap.values());\n  \t\tvar result = new LineStringTransformer(this._linestringMap).transform(this._inputGeom);\n  \t\treturn result;\n  \t},\n  \tsetDistanceTolerance: function setDistanceTolerance(distanceTolerance) {\n  \t\tif (distanceTolerance < 0.0) throw new IllegalArgumentException(\"Tolerance must be non-negative\");\n  \t\tthis._lineSimplifier.setDistanceTolerance(distanceTolerance);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn TopologyPreservingSimplifier;\n  \t}\n  });\n  TopologyPreservingSimplifier.simplify = function (geom, distanceTolerance) {\n  \tvar tss = new TopologyPreservingSimplifier(geom);\n  \ttss.setDistanceTolerance(distanceTolerance);\n  \treturn tss.getResultGeometry();\n  };\n  function LineStringTransformer() {\n  \tGeometryTransformer.apply(this);\n  \tthis._linestringMap = null;\n  \tvar linestringMap = arguments[0];\n  \tthis._linestringMap = linestringMap;\n  }\n  inherits$1(LineStringTransformer, GeometryTransformer);\n  extend(LineStringTransformer.prototype, {\n  \ttransformCoordinates: function transformCoordinates(coords, parent) {\n  \t\tif (coords.size() === 0) return null;\n  \t\tif (parent instanceof LineString) {\n  \t\t\tvar taggedLine = this._linestringMap.get(parent);\n  \t\t\treturn this.createCoordinateSequence(taggedLine.getResultCoordinates());\n  \t\t}\n  \t\treturn GeometryTransformer.prototype.transformCoordinates.call(this, coords, parent);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LineStringTransformer;\n  \t}\n  });\n  function LineStringMapBuilderFilter() {\n  \tthis.tps = null;\n  \tvar tps = arguments[0];\n  \tthis.tps = tps;\n  }\n  extend(LineStringMapBuilderFilter.prototype, {\n  \tfilter: function filter(geom) {\n  \t\tif (geom instanceof LineString) {\n  \t\t\tvar line = geom;\n  \t\t\tif (line.isEmpty()) return null;\n  \t\t\tvar minSize = line.isClosed() ? 4 : 2;\n  \t\t\tvar taggedLine = new TaggedLineString(line, minSize);\n  \t\t\tthis.tps._linestringMap.put(line, taggedLine);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [GeometryComponentFilter];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LineStringMapBuilderFilter;\n  \t}\n  });\n  TopologyPreservingSimplifier.LineStringTransformer = LineStringTransformer;\n  TopologyPreservingSimplifier.LineStringMapBuilderFilter = LineStringMapBuilderFilter;\n\n  function SplitSegment() {\n  \tthis._seg = null;\n  \tthis._segLen = null;\n  \tthis._splitPt = null;\n  \tthis._minimumLen = 0.0;\n  \tvar seg = arguments[0];\n  \tthis._seg = seg;\n  \tthis._segLen = seg.getLength();\n  }\n  extend(SplitSegment.prototype, {\n  \tsplitAt: function splitAt() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar pt = arguments[0];\n  \t\t\tvar minFrac = this._minimumLen / this._segLen;\n  \t\t\tif (pt.distance(this._seg.p0) < this._minimumLen) {\n  \t\t\t\tthis._splitPt = this._seg.pointAlong(minFrac);\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t\tif (pt.distance(this._seg.p1) < this._minimumLen) {\n  \t\t\t\tthis._splitPt = SplitSegment.pointAlongReverse(this._seg, minFrac);\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t\tthis._splitPt = pt;\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar length = arguments[0],\n  \t\t\t    endPt = arguments[1];\n  \t\t\tvar actualLen = this.getConstrainedLength(length);\n  \t\t\tvar frac = actualLen / this._segLen;\n  \t\t\tif (endPt.equals2D(this._seg.p0)) this._splitPt = this._seg.pointAlong(frac);else this._splitPt = SplitSegment.pointAlongReverse(this._seg, frac);\n  \t\t}\n  \t},\n  \tsetMinimumLength: function setMinimumLength(minLen) {\n  \t\tthis._minimumLen = minLen;\n  \t},\n  \tgetConstrainedLength: function getConstrainedLength(len) {\n  \t\tif (len < this._minimumLen) return this._minimumLen;\n  \t\treturn len;\n  \t},\n  \tgetSplitPoint: function getSplitPoint() {\n  \t\treturn this._splitPt;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn SplitSegment;\n  \t}\n  });\n  SplitSegment.pointAlongReverse = function (seg, segmentLengthFraction) {\n  \tvar coord = new Coordinate();\n  \tcoord.x = seg.p1.x - segmentLengthFraction * (seg.p1.x - seg.p0.x);\n  \tcoord.y = seg.p1.y - segmentLengthFraction * (seg.p1.y - seg.p0.y);\n  \treturn coord;\n  };\n\n  function ConstraintSplitPointFinder() {}\n  extend(ConstraintSplitPointFinder.prototype, {\n  \tfindSplitPoint: function findSplitPoint(seg, encroachPt) {},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn ConstraintSplitPointFinder;\n  \t}\n  });\n\n  function NonEncroachingSplitPointFinder() {}\n  extend(NonEncroachingSplitPointFinder.prototype, {\n  \tfindSplitPoint: function findSplitPoint(seg, encroachPt) {\n  \t\tvar lineSeg = seg.getLineSegment();\n  \t\tvar segLen = lineSeg.getLength();\n  \t\tvar midPtLen = segLen / 2;\n  \t\tvar splitSeg = new SplitSegment(lineSeg);\n  \t\tvar projPt = NonEncroachingSplitPointFinder.projectedSplitPoint(seg, encroachPt);\n  \t\tvar nonEncroachDiam = projPt.distance(encroachPt) * 2 * 0.8;\n  \t\tvar maxSplitLen = nonEncroachDiam;\n  \t\tif (maxSplitLen > midPtLen) {\n  \t\t\tmaxSplitLen = midPtLen;\n  \t\t}\n  \t\tsplitSeg.setMinimumLength(maxSplitLen);\n  \t\tsplitSeg.splitAt(projPt);\n  \t\treturn splitSeg.getSplitPoint();\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [ConstraintSplitPointFinder];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn NonEncroachingSplitPointFinder;\n  \t}\n  });\n  NonEncroachingSplitPointFinder.projectedSplitPoint = function (seg, encroachPt) {\n  \tvar lineSeg = seg.getLineSegment();\n  \tvar projPt = lineSeg.project(encroachPt);\n  \treturn projPt;\n  };\n\n  function TrianglePredicate() {}\n  extend(TrianglePredicate.prototype, {\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn TrianglePredicate;\n  \t}\n  });\n  TrianglePredicate.triArea = function (a, b, c) {\n  \treturn (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n  };\n  TrianglePredicate.isInCircleDDNormalized = function (a, b, c, p) {\n  \tvar adx = DD.valueOf(a.x).selfSubtract(p.x);\n  \tvar ady = DD.valueOf(a.y).selfSubtract(p.y);\n  \tvar bdx = DD.valueOf(b.x).selfSubtract(p.x);\n  \tvar bdy = DD.valueOf(b.y).selfSubtract(p.y);\n  \tvar cdx = DD.valueOf(c.x).selfSubtract(p.x);\n  \tvar cdy = DD.valueOf(c.y).selfSubtract(p.y);\n  \tvar abdet = adx.multiply(bdy).selfSubtract(bdx.multiply(ady));\n  \tvar bcdet = bdx.multiply(cdy).selfSubtract(cdx.multiply(bdy));\n  \tvar cadet = cdx.multiply(ady).selfSubtract(adx.multiply(cdy));\n  \tvar alift = adx.multiply(adx).selfAdd(ady.multiply(ady));\n  \tvar blift = bdx.multiply(bdx).selfAdd(bdy.multiply(bdy));\n  \tvar clift = cdx.multiply(cdx).selfAdd(cdy.multiply(cdy));\n  \tvar sum = alift.selfMultiply(bcdet).selfAdd(blift.selfMultiply(cadet)).selfAdd(clift.selfMultiply(abdet));\n  \tvar isInCircle = sum.doubleValue() > 0;\n  \treturn isInCircle;\n  };\n  TrianglePredicate.checkRobustInCircle = function (a, b, c, p) {\n  \tvar nonRobustInCircle = TrianglePredicate.isInCircleNonRobust(a, b, c, p);\n  \tvar isInCircleDD = TrianglePredicate.isInCircleDDSlow(a, b, c, p);\n  \tvar isInCircleCC = TrianglePredicate.isInCircleCC(a, b, c, p);\n  \tvar circumCentre = Triangle$1.circumcentre(a, b, c);\n  \tSystem.out.println(\"p radius diff a = \" + Math.abs(p.distance(circumCentre) - a.distance(circumCentre)) / a.distance(circumCentre));\n  \tif (nonRobustInCircle !== isInCircleDD || nonRobustInCircle !== isInCircleCC) {\n  \t\tSystem.out.println(\"inCircle robustness failure (double result = \" + nonRobustInCircle + \", DD result = \" + isInCircleDD + \", CC result = \" + isInCircleCC + \")\");\n  \t\tSystem.out.println(WKTWriter.toLineString(new CoordinateArraySequence([a, b, c, p])));\n  \t\tSystem.out.println(\"Circumcentre = \" + WKTWriter.toPoint(circumCentre) + \" radius = \" + a.distance(circumCentre));\n  \t\tSystem.out.println(\"p radius diff a = \" + Math.abs(p.distance(circumCentre) / a.distance(circumCentre) - 1));\n  \t\tSystem.out.println(\"p radius diff b = \" + Math.abs(p.distance(circumCentre) / b.distance(circumCentre) - 1));\n  \t\tSystem.out.println(\"p radius diff c = \" + Math.abs(p.distance(circumCentre) / c.distance(circumCentre) - 1));\n  \t\tSystem.out.println();\n  \t}\n  };\n  TrianglePredicate.isInCircleDDFast = function (a, b, c, p) {\n  \tvar aTerm = DD.sqr(a.x).selfAdd(DD.sqr(a.y)).selfMultiply(TrianglePredicate.triAreaDDFast(b, c, p));\n  \tvar bTerm = DD.sqr(b.x).selfAdd(DD.sqr(b.y)).selfMultiply(TrianglePredicate.triAreaDDFast(a, c, p));\n  \tvar cTerm = DD.sqr(c.x).selfAdd(DD.sqr(c.y)).selfMultiply(TrianglePredicate.triAreaDDFast(a, b, p));\n  \tvar pTerm = DD.sqr(p.x).selfAdd(DD.sqr(p.y)).selfMultiply(TrianglePredicate.triAreaDDFast(a, b, c));\n  \tvar sum = aTerm.selfSubtract(bTerm).selfAdd(cTerm).selfSubtract(pTerm);\n  \tvar isInCircle = sum.doubleValue() > 0;\n  \treturn isInCircle;\n  };\n  TrianglePredicate.isInCircleCC = function (a, b, c, p) {\n  \tvar cc = Triangle$1.circumcentre(a, b, c);\n  \tvar ccRadius = a.distance(cc);\n  \tvar pRadiusDiff = p.distance(cc) - ccRadius;\n  \treturn pRadiusDiff <= 0;\n  };\n  TrianglePredicate.isInCircleNormalized = function (a, b, c, p) {\n  \tvar adx = a.x - p.x;\n  \tvar ady = a.y - p.y;\n  \tvar bdx = b.x - p.x;\n  \tvar bdy = b.y - p.y;\n  \tvar cdx = c.x - p.x;\n  \tvar cdy = c.y - p.y;\n  \tvar abdet = adx * bdy - bdx * ady;\n  \tvar bcdet = bdx * cdy - cdx * bdy;\n  \tvar cadet = cdx * ady - adx * cdy;\n  \tvar alift = adx * adx + ady * ady;\n  \tvar blift = bdx * bdx + bdy * bdy;\n  \tvar clift = cdx * cdx + cdy * cdy;\n  \tvar disc = alift * bcdet + blift * cadet + clift * abdet;\n  \treturn disc > 0;\n  };\n  TrianglePredicate.isInCircleDDSlow = function (a, b, c, p) {\n  \tvar px = DD.valueOf(p.x);\n  \tvar py = DD.valueOf(p.y);\n  \tvar ax = DD.valueOf(a.x);\n  \tvar ay = DD.valueOf(a.y);\n  \tvar bx = DD.valueOf(b.x);\n  \tvar by = DD.valueOf(b.y);\n  \tvar cx = DD.valueOf(c.x);\n  \tvar cy = DD.valueOf(c.y);\n  \tvar aTerm = ax.multiply(ax).add(ay.multiply(ay)).multiply(TrianglePredicate.triAreaDDSlow(bx, by, cx, cy, px, py));\n  \tvar bTerm = bx.multiply(bx).add(by.multiply(by)).multiply(TrianglePredicate.triAreaDDSlow(ax, ay, cx, cy, px, py));\n  \tvar cTerm = cx.multiply(cx).add(cy.multiply(cy)).multiply(TrianglePredicate.triAreaDDSlow(ax, ay, bx, by, px, py));\n  \tvar pTerm = px.multiply(px).add(py.multiply(py)).multiply(TrianglePredicate.triAreaDDSlow(ax, ay, bx, by, cx, cy));\n  \tvar sum = aTerm.subtract(bTerm).add(cTerm).subtract(pTerm);\n  \tvar isInCircle = sum.doubleValue() > 0;\n  \treturn isInCircle;\n  };\n  TrianglePredicate.isInCircleNonRobust = function (a, b, c, p) {\n  \tvar isInCircle = (a.x * a.x + a.y * a.y) * TrianglePredicate.triArea(b, c, p) - (b.x * b.x + b.y * b.y) * TrianglePredicate.triArea(a, c, p) + (c.x * c.x + c.y * c.y) * TrianglePredicate.triArea(a, b, p) - (p.x * p.x + p.y * p.y) * TrianglePredicate.triArea(a, b, c) > 0;\n  \treturn isInCircle;\n  };\n  TrianglePredicate.isInCircleRobust = function (a, b, c, p) {\n  \treturn TrianglePredicate.isInCircleNormalized(a, b, c, p);\n  };\n  TrianglePredicate.triAreaDDSlow = function (ax, ay, bx, by, cx, cy) {\n  \treturn bx.subtract(ax).multiply(cy.subtract(ay)).subtract(by.subtract(ay).multiply(cx.subtract(ax)));\n  };\n  TrianglePredicate.triAreaDDFast = function (a, b, c) {\n  \tvar t1 = DD.valueOf(b.x).selfSubtract(a.x).selfMultiply(DD.valueOf(c.y).selfSubtract(a.y));\n  \tvar t2 = DD.valueOf(b.y).selfSubtract(a.y).selfMultiply(DD.valueOf(c.x).selfSubtract(a.x));\n  \treturn t1.selfSubtract(t2);\n  };\n\n  function Vertex() {\n  \tthis._p = null;\n  \tif (arguments.length === 1) {\n  \t\tvar _p = arguments[0];\n  \t\tthis._p = new Coordinate(_p);\n  \t} else if (arguments.length === 2) {\n  \t\tvar _x = arguments[0],\n  \t\t    _y = arguments[1];\n  \t\tthis._p = new Coordinate(_x, _y);\n  \t} else if (arguments.length === 3) {\n  \t\tvar _x = arguments[0],\n  \t\t    _y = arguments[1],\n  \t\t    _z = arguments[2];\n  \t\tthis._p = new Coordinate(_x, _y, _z);\n  \t}\n  }\n  extend(Vertex.prototype, {\n  \tcircleCenter: function circleCenter(b, c) {\n  \t\tvar a = new Vertex(this.getX(), this.getY());\n  \t\tvar cab = this.bisector(a, b);\n  \t\tvar cbc = this.bisector(b, c);\n  \t\tvar hcc = new HCoordinate(cab, cbc);\n  \t\tvar cc = null;\n  \t\ttry {\n  \t\t\tcc = new Vertex(hcc.getX(), hcc.getY());\n  \t\t} catch (nre) {\n  \t\t\tif (nre instanceof NotRepresentableException) {\n  \t\t\t\tSystem.err.println(\"a: \" + a + \"  b: \" + b + \"  c: \" + c);\n  \t\t\t\tSystem.err.println(nre);\n  \t\t\t} else throw nre;\n  \t\t} finally {}\n  \t\treturn cc;\n  \t},\n  \tdot: function dot(v) {\n  \t\treturn this._p.x * v.getX() + this._p.y * v.getY();\n  \t},\n  \tmagn: function magn() {\n  \t\treturn Math.sqrt(this._p.x * this._p.x + this._p.y * this._p.y);\n  \t},\n  \tgetZ: function getZ() {\n  \t\treturn this._p.z;\n  \t},\n  \tbisector: function bisector(a, b) {\n  \t\tvar dx = b.getX() - a.getX();\n  \t\tvar dy = b.getY() - a.getY();\n  \t\tvar l1 = new HCoordinate(a.getX() + dx / 2.0, a.getY() + dy / 2.0, 1.0);\n  \t\tvar l2 = new HCoordinate(a.getX() - dy + dx / 2.0, a.getY() + dx + dy / 2.0, 1.0);\n  \t\treturn new HCoordinate(l1, l2);\n  \t},\n  \tequals: function equals() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar _x = arguments[0];\n  \t\t\tif (this._p.x === _x.getX() && this._p.y === _x.getY()) {\n  \t\t\t\treturn true;\n  \t\t\t} else {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar _x = arguments[0],\n  \t\t\t    tolerance = arguments[1];\n  \t\t\tif (this._p.distance(_x.getCoordinate()) < tolerance) {\n  \t\t\t\treturn true;\n  \t\t\t} else {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\treturn this._p;\n  \t},\n  \tisInCircle: function isInCircle(a, b, c) {\n  \t\treturn TrianglePredicate.isInCircleRobust(a._p, b._p, c._p, this._p);\n  \t},\n  \tinterpolateZValue: function interpolateZValue(v0, v1, v2) {\n  \t\tvar x0 = v0.getX();\n  \t\tvar y0 = v0.getY();\n  \t\tvar a = v1.getX() - x0;\n  \t\tvar b = v2.getX() - x0;\n  \t\tvar c = v1.getY() - y0;\n  \t\tvar d = v2.getY() - y0;\n  \t\tvar det = a * d - b * c;\n  \t\tvar dx = this.getX() - x0;\n  \t\tvar dy = this.getY() - y0;\n  \t\tvar t = (d * dx - b * dy) / det;\n  \t\tvar u = (-c * dx + a * dy) / det;\n  \t\tvar z = v0.getZ() + t * (v1.getZ() - v0.getZ()) + u * (v2.getZ() - v0.getZ());\n  \t\treturn z;\n  \t},\n  \tmidPoint: function midPoint(a) {\n  \t\tvar xm = (this._p.x + a.getX()) / 2.0;\n  \t\tvar ym = (this._p.y + a.getY()) / 2.0;\n  \t\tvar zm = (this._p.z + a.getZ()) / 2.0;\n  \t\treturn new Vertex(xm, ym, zm);\n  \t},\n  \trightOf: function rightOf(e) {\n  \t\treturn this.isCCW(e.dest(), e.orig());\n  \t},\n  \tisCCW: function isCCW(b, c) {\n  \t\treturn (b._p.x - this._p.x) * (c._p.y - this._p.y) - (b._p.y - this._p.y) * (c._p.x - this._p.x) > 0;\n  \t},\n  \tgetX: function getX() {\n  \t\treturn this._p.x;\n  \t},\n  \tcrossProduct: function crossProduct(v) {\n  \t\treturn this._p.x * v.getY() - this._p.y * v.getX();\n  \t},\n  \tsetZ: function setZ(_z) {\n  \t\tthis._p.z = _z;\n  \t},\n  \ttimes: function times(c) {\n  \t\treturn new Vertex(c * this._p.x, c * this._p.y);\n  \t},\n  \tcross: function cross() {\n  \t\treturn new Vertex(this._p.y, -this._p.x);\n  \t},\n  \tleftOf: function leftOf(e) {\n  \t\treturn this.isCCW(e.orig(), e.dest());\n  \t},\n  \ttoString: function toString() {\n  \t\treturn \"POINT (\" + this._p.x + \" \" + this._p.y + \")\";\n  \t},\n  \tsub: function sub(v) {\n  \t\treturn new Vertex(this._p.x - v.getX(), this._p.y - v.getY());\n  \t},\n  \tgetY: function getY() {\n  \t\treturn this._p.y;\n  \t},\n  \tclassify: function classify(p0, p1) {\n  \t\tvar p2 = this;\n  \t\tvar a = p1.sub(p0);\n  \t\tvar b = p2.sub(p0);\n  \t\tvar sa = a.crossProduct(b);\n  \t\tif (sa > 0.0) return Vertex.LEFT;\n  \t\tif (sa < 0.0) return Vertex.RIGHT;\n  \t\tif (a.getX() * b.getX() < 0.0 || a.getY() * b.getY() < 0.0) return Vertex.BEHIND;\n  \t\tif (a.magn() < b.magn()) return Vertex.BEYOND;\n  \t\tif (p0.equals(p2)) return Vertex.ORIGIN;\n  \t\tif (p1.equals(p2)) return Vertex.DESTINATION;\n  \t\treturn Vertex.BETWEEN;\n  \t},\n  \tsum: function sum(v) {\n  \t\treturn new Vertex(this._p.x + v.getX(), this._p.y + v.getY());\n  \t},\n  \tdistance: function distance(v1, v2) {\n  \t\treturn Math.sqrt(Math.pow(v2.getX() - v1.getX(), 2.0) + Math.pow(v2.getY() - v1.getY(), 2.0));\n  \t},\n  \tcircumRadiusRatio: function circumRadiusRatio(b, c) {\n  \t\tvar x = this.circleCenter(b, c);\n  \t\tvar radius = this.distance(x, b);\n  \t\tvar edgeLength = this.distance(this, b);\n  \t\tvar el = this.distance(b, c);\n  \t\tif (el < edgeLength) {\n  \t\t\tedgeLength = el;\n  \t\t}\n  \t\tel = this.distance(c, this);\n  \t\tif (el < edgeLength) {\n  \t\t\tedgeLength = el;\n  \t\t}\n  \t\treturn radius / edgeLength;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Vertex;\n  \t}\n  });\n  Vertex.interpolateZ = function () {\n  \tif (arguments.length === 3) {\n  \t\tvar p = arguments[0],\n  \t\t    p0 = arguments[1],\n  \t\t    p1 = arguments[2];\n  \t\tvar segLen = p0.distance(p1);\n  \t\tvar ptLen = p.distance(p0);\n  \t\tvar dz = p1.z - p0.z;\n  \t\tvar pz = p0.z + dz * (ptLen / segLen);\n  \t\treturn pz;\n  \t} else if (arguments.length === 4) {\n  \t\tvar p = arguments[0],\n  \t\t    v0 = arguments[1],\n  \t\t    v1 = arguments[2],\n  \t\t    v2 = arguments[3];\n  \t\tvar x0 = v0.x;\n  \t\tvar y0 = v0.y;\n  \t\tvar a = v1.x - x0;\n  \t\tvar b = v2.x - x0;\n  \t\tvar c = v1.y - y0;\n  \t\tvar d = v2.y - y0;\n  \t\tvar det = a * d - b * c;\n  \t\tvar dx = p.x - x0;\n  \t\tvar dy = p.y - y0;\n  \t\tvar t = (d * dx - b * dy) / det;\n  \t\tvar u = (-c * dx + a * dy) / det;\n  \t\tvar z = v0.z + t * (v1.z - v0.z) + u * (v2.z - v0.z);\n  \t\treturn z;\n  \t}\n  };\n  Vertex.LEFT = 0;\n  Vertex.RIGHT = 1;\n  Vertex.BEYOND = 2;\n  Vertex.BEHIND = 3;\n  Vertex.BETWEEN = 4;\n  Vertex.ORIGIN = 5;\n  Vertex.DESTINATION = 6;\n\n  function ConstraintVertex() {\n  \tthis._isOnConstraint = null;\n  \tthis._constraint = null;\n  \tvar p = arguments[0];\n  \tVertex.call(this, p);\n  }\n  inherits$1(ConstraintVertex, Vertex);\n  extend(ConstraintVertex.prototype, {\n  \tgetConstraint: function getConstraint() {\n  \t\treturn this._constraint;\n  \t},\n  \tsetOnConstraint: function setOnConstraint(isOnConstraint) {\n  \t\tthis._isOnConstraint = isOnConstraint;\n  \t},\n  \tmerge: function merge(other) {\n  \t\tif (other._isOnConstraint) {\n  \t\t\tthis._isOnConstraint = true;\n  \t\t\tthis._constraint = other._constraint;\n  \t\t}\n  \t},\n  \tisOnConstraint: function isOnConstraint() {\n  \t\treturn this._isOnConstraint;\n  \t},\n  \tsetConstraint: function setConstraint(constraint) {\n  \t\tthis._isOnConstraint = true;\n  \t\tthis._constraint = constraint;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn ConstraintVertex;\n  \t}\n  });\n\n  function QuadEdge() {\n  \tthis._rot = null;\n  \tthis._vertex = null;\n  \tthis._next = null;\n  \tthis._data = null;\n  }\n  extend(QuadEdge.prototype, {\n  \tequalsNonOriented: function equalsNonOriented(qe) {\n  \t\tif (this.equalsOriented(qe)) return true;\n  \t\tif (this.equalsOriented(qe.sym())) return true;\n  \t\treturn false;\n  \t},\n  \ttoLineSegment: function toLineSegment() {\n  \t\treturn new LineSegment(this._vertex.getCoordinate(), this.dest().getCoordinate());\n  \t},\n  \tdest: function dest() {\n  \t\treturn this.sym().orig();\n  \t},\n  \toNext: function oNext() {\n  \t\treturn this._next;\n  \t},\n  \tequalsOriented: function equalsOriented(qe) {\n  \t\tif (this.orig().getCoordinate().equals2D(qe.orig().getCoordinate()) && this.dest().getCoordinate().equals2D(qe.dest().getCoordinate())) return true;\n  \t\treturn false;\n  \t},\n  \tdNext: function dNext() {\n  \t\treturn this.sym().oNext().sym();\n  \t},\n  \tlPrev: function lPrev() {\n  \t\treturn this._next.sym();\n  \t},\n  \trPrev: function rPrev() {\n  \t\treturn this.sym().oNext();\n  \t},\n  \trot: function rot() {\n  \t\treturn this._rot;\n  \t},\n  \toPrev: function oPrev() {\n  \t\treturn this._rot._next._rot;\n  \t},\n  \tsym: function sym() {\n  \t\treturn this._rot._rot;\n  \t},\n  \tsetOrig: function setOrig(o) {\n  \t\tthis._vertex = o;\n  \t},\n  \tlNext: function lNext() {\n  \t\treturn this.invRot().oNext().rot();\n  \t},\n  \tgetLength: function getLength() {\n  \t\treturn this.orig().getCoordinate().distance(this.dest().getCoordinate());\n  \t},\n  \tinvRot: function invRot() {\n  \t\treturn this._rot.sym();\n  \t},\n  \tsetDest: function setDest(d) {\n  \t\tthis.sym().setOrig(d);\n  \t},\n  \tsetData: function setData(data) {\n  \t\tthis._data = data;\n  \t},\n  \tgetData: function getData() {\n  \t\treturn this._data;\n  \t},\n  \tdelete: function _delete() {\n  \t\tthis._rot = null;\n  \t},\n  \torig: function orig() {\n  \t\treturn this._vertex;\n  \t},\n  \trNext: function rNext() {\n  \t\treturn this._rot._next.invRot();\n  \t},\n  \ttoString: function toString() {\n  \t\tvar p0 = this._vertex.getCoordinate();\n  \t\tvar p1 = this.dest().getCoordinate();\n  \t\treturn WKTWriter.toLineString(p0, p1);\n  \t},\n  \tisLive: function isLive() {\n  \t\treturn this._rot !== null;\n  \t},\n  \tgetPrimary: function getPrimary() {\n  \t\tif (this.orig().getCoordinate().compareTo(this.dest().getCoordinate()) <= 0) return this;else return this.sym();\n  \t},\n  \tdPrev: function dPrev() {\n  \t\treturn this.invRot().oNext().invRot();\n  \t},\n  \tsetNext: function setNext(next) {\n  \t\tthis._next = next;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn QuadEdge;\n  \t}\n  });\n  QuadEdge.makeEdge = function (o, d) {\n  \tvar q0 = new QuadEdge();\n  \tvar q1 = new QuadEdge();\n  \tvar q2 = new QuadEdge();\n  \tvar q3 = new QuadEdge();\n  \tq0._rot = q1;\n  \tq1._rot = q2;\n  \tq2._rot = q3;\n  \tq3._rot = q0;\n  \tq0.setNext(q0);\n  \tq1.setNext(q3);\n  \tq2.setNext(q2);\n  \tq3.setNext(q1);\n  \tvar base = q0;\n  \tbase.setOrig(o);\n  \tbase.setDest(d);\n  \treturn base;\n  };\n  QuadEdge.swap = function (e) {\n  \tvar a = e.oPrev();\n  \tvar b = e.sym().oPrev();\n  \tQuadEdge.splice(e, a);\n  \tQuadEdge.splice(e.sym(), b);\n  \tQuadEdge.splice(e, a.lNext());\n  \tQuadEdge.splice(e.sym(), b.lNext());\n  \te.setOrig(a.dest());\n  \te.setDest(b.dest());\n  };\n  QuadEdge.splice = function (a, b) {\n  \tvar alpha = a.oNext().rot();\n  \tvar beta = b.oNext().rot();\n  \tvar t1 = b.oNext();\n  \tvar t2 = a.oNext();\n  \tvar t3 = beta.oNext();\n  \tvar t4 = alpha.oNext();\n  \ta.setNext(t1);\n  \tb.setNext(t2);\n  \talpha.setNext(t3);\n  \tbeta.setNext(t4);\n  };\n  QuadEdge.connect = function (a, b) {\n  \tvar e = QuadEdge.makeEdge(a.dest(), b.orig());\n  \tQuadEdge.splice(e, a.lNext());\n  \tQuadEdge.splice(e.sym(), b);\n  \treturn e;\n  };\n\n  function IncrementalDelaunayTriangulator() {\n  \tthis._subdiv = null;\n  \tthis._isUsingTolerance = false;\n  \tvar subdiv = arguments[0];\n  \tthis._subdiv = subdiv;\n  \tthis._isUsingTolerance = subdiv.getTolerance() > 0.0;\n  }\n  extend(IncrementalDelaunayTriangulator.prototype, {\n  \tinsertSite: function insertSite(v) {\n  \t\tvar e = this._subdiv.locate(v);\n  \t\tif (this._subdiv.isVertexOfEdge(e, v)) {\n  \t\t\treturn e;\n  \t\t} else if (this._subdiv.isOnEdge(e, v.getCoordinate())) {\n  \t\t\te = e.oPrev();\n  \t\t\tthis._subdiv.delete(e.oNext());\n  \t\t}\n  \t\tvar base = this._subdiv.makeEdge(e.orig(), v);\n  \t\tQuadEdge.splice(base, e);\n  \t\tvar startEdge = base;\n  \t\tdo {\n  \t\t\tbase = this._subdiv.connect(e, base.sym());\n  \t\t\te = base.oPrev();\n  \t\t} while (e.lNext() !== startEdge);\n  \t\tdo {\n  \t\t\tvar t = e.oPrev();\n  \t\t\tif (t.dest().rightOf(e) && v.isInCircle(e.orig(), t.dest(), e.dest())) {\n  \t\t\t\tQuadEdge.swap(e);\n  \t\t\t\te = e.oPrev();\n  \t\t\t} else if (e.oNext() === startEdge) {\n  \t\t\t\treturn base;\n  \t\t\t} else {\n  \t\t\t\te = e.oNext().lPrev();\n  \t\t\t}\n  \t\t} while (true);\n  \t},\n  \tinsertSites: function insertSites(vertices) {\n  \t\tfor (var i = vertices.iterator(); i.hasNext();) {\n  \t\t\tvar v = i.next();\n  \t\t\tthis.insertSite(v);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn IncrementalDelaunayTriangulator;\n  \t}\n  });\n\n  function QuadEdgeLocator() {}\n  extend(QuadEdgeLocator.prototype, {\n  \tlocate: function locate(v) {},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn QuadEdgeLocator;\n  \t}\n  });\n\n  function LastFoundQuadEdgeLocator() {\n  \tthis._subdiv = null;\n  \tthis._lastEdge = null;\n  \tvar subdiv = arguments[0];\n  \tthis._subdiv = subdiv;\n  \tthis.init();\n  }\n  extend(LastFoundQuadEdgeLocator.prototype, {\n  \tinit: function init() {\n  \t\tthis._lastEdge = this.findEdge();\n  \t},\n  \tlocate: function locate(v) {\n  \t\tif (!this._lastEdge.isLive()) {\n  \t\t\tthis.init();\n  \t\t}\n  \t\tvar e = this._subdiv.locateFromEdge(v, this._lastEdge);\n  \t\tthis._lastEdge = e;\n  \t\treturn e;\n  \t},\n  \tfindEdge: function findEdge() {\n  \t\tvar edges = this._subdiv.getEdges();\n  \t\treturn edges.iterator().next();\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [QuadEdgeLocator];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LastFoundQuadEdgeLocator;\n  \t}\n  });\n\n  function LocateFailureException() {\n  \tthis._seg = null;\n  \tif (arguments.length === 1) {\n  \t\tif (typeof arguments[0] === \"string\") {\n  \t\t\tvar msg = arguments[0];\n  \t\t\tRuntimeException.call(this, msg);\n  \t\t} else if (arguments[0] instanceof LineSegment) {\n  \t\t\tvar seg = arguments[0];\n  \t\t\tRuntimeException.call(this, \"Locate failed to converge (at edge: \" + seg + \").  Possible causes include invalid Subdivision topology or very close sites\");\n  \t\t\tthis._seg = new LineSegment(seg);\n  \t\t}\n  \t} else if (arguments.length === 2) {\n  \t\tvar msg = arguments[0],\n  \t\t    seg = arguments[1];\n  \t\tRuntimeException.call(this, LocateFailureException.msgWithSpatial(msg, seg));\n  \t\tthis._seg = new LineSegment(seg);\n  \t}\n  }\n  inherits$1(LocateFailureException, RuntimeException);\n  extend(LocateFailureException.prototype, {\n  \tgetSegment: function getSegment() {\n  \t\treturn this._seg;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LocateFailureException;\n  \t}\n  });\n  LocateFailureException.msgWithSpatial = function (msg, seg) {\n  \tif (seg !== null) return msg + \" [ \" + seg + \" ]\";\n  \treturn msg;\n  };\n\n  function TriangleVisitor() {}\n  extend(TriangleVisitor.prototype, {\n  \tvisit: function visit(triEdges) {},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn TriangleVisitor;\n  \t}\n  });\n\n  function QuadEdgeSubdivision() {\n  \tthis._visitedKey = 0;\n  \tthis._quadEdges = new ArrayList();\n  \tthis._startingEdge = null;\n  \tthis._tolerance = null;\n  \tthis._edgeCoincidenceTolerance = null;\n  \tthis._frameVertex = new Array(3).fill(null);\n  \tthis._frameEnv = null;\n  \tthis._locator = null;\n  \tthis._seg = new LineSegment();\n  \tthis._triEdges = new Array(3).fill(null);\n  \tvar env = arguments[0],\n  \t    tolerance = arguments[1];\n  \tthis._tolerance = tolerance;\n  \tthis._edgeCoincidenceTolerance = tolerance / QuadEdgeSubdivision.EDGE_COINCIDENCE_TOL_FACTOR;\n  \tthis.createFrame(env);\n  \tthis._startingEdge = this.initSubdiv();\n  \tthis._locator = new LastFoundQuadEdgeLocator(this);\n  }\n  extend(QuadEdgeSubdivision.prototype, {\n  \tgetTriangleVertices: function getTriangleVertices(includeFrame) {\n  \t\tvar visitor = new TriangleVertexListVisitor();\n  \t\tthis.visitTriangles(visitor, includeFrame);\n  \t\treturn visitor.getTriangleVertices();\n  \t},\n  \tisFrameVertex: function isFrameVertex(v) {\n  \t\tif (v.equals(this._frameVertex[0])) return true;\n  \t\tif (v.equals(this._frameVertex[1])) return true;\n  \t\tif (v.equals(this._frameVertex[2])) return true;\n  \t\treturn false;\n  \t},\n  \tisVertexOfEdge: function isVertexOfEdge(e, v) {\n  \t\tif (v.equals(e.orig(), this._tolerance) || v.equals(e.dest(), this._tolerance)) {\n  \t\t\treturn true;\n  \t\t}\n  \t\treturn false;\n  \t},\n  \tconnect: function connect(a, b) {\n  \t\tvar q = QuadEdge.connect(a, b);\n  \t\tthis._quadEdges.add(q);\n  \t\treturn q;\n  \t},\n  \tgetVoronoiCellPolygon: function getVoronoiCellPolygon(qe, geomFact) {\n  \t\tvar cellPts = new ArrayList();\n  \t\tvar startQE = qe;\n  \t\tdo {\n  \t\t\tvar cc = qe.rot().orig().getCoordinate();\n  \t\t\tcellPts.add(cc);\n  \t\t\tqe = qe.oPrev();\n  \t\t} while (qe !== startQE);\n  \t\tvar coordList = new CoordinateList();\n  \t\tcoordList.addAll(cellPts, false);\n  \t\tcoordList.closeRing();\n  \t\tif (coordList.size() < 4) {\n  \t\t\tSystem.out.println(coordList);\n  \t\t\tcoordList.add(coordList.get(coordList.size() - 1), true);\n  \t\t}\n  \t\tvar pts = coordList.toCoordinateArray();\n  \t\tvar cellPoly = geomFact.createPolygon(geomFact.createLinearRing(pts), null);\n  \t\tvar v = startQE.orig();\n  \t\tcellPoly.setUserData(v.getCoordinate());\n  \t\treturn cellPoly;\n  \t},\n  \tsetLocator: function setLocator(locator) {\n  \t\tthis._locator = locator;\n  \t},\n  \tinitSubdiv: function initSubdiv() {\n  \t\tvar ea = this.makeEdge(this._frameVertex[0], this._frameVertex[1]);\n  \t\tvar eb = this.makeEdge(this._frameVertex[1], this._frameVertex[2]);\n  \t\tQuadEdge.splice(ea.sym(), eb);\n  \t\tvar ec = this.makeEdge(this._frameVertex[2], this._frameVertex[0]);\n  \t\tQuadEdge.splice(eb.sym(), ec);\n  \t\tQuadEdge.splice(ec.sym(), ea);\n  \t\treturn ea;\n  \t},\n  \tisFrameBorderEdge: function isFrameBorderEdge(e) {\n  \t\tvar leftTri = new Array(3).fill(null);\n  \t\tQuadEdgeSubdivision.getTriangleEdges(e, leftTri);\n  \t\tvar rightTri = new Array(3).fill(null);\n  \t\tQuadEdgeSubdivision.getTriangleEdges(e.sym(), rightTri);\n  \t\tvar vLeftTriOther = e.lNext().dest();\n  \t\tif (this.isFrameVertex(vLeftTriOther)) return true;\n  \t\tvar vRightTriOther = e.sym().lNext().dest();\n  \t\tif (this.isFrameVertex(vRightTriOther)) return true;\n  \t\treturn false;\n  \t},\n  \tmakeEdge: function makeEdge(o, d) {\n  \t\tvar q = QuadEdge.makeEdge(o, d);\n  \t\tthis._quadEdges.add(q);\n  \t\treturn q;\n  \t},\n  \tvisitTriangles: function visitTriangles(triVisitor, includeFrame) {\n  \t\tthis._visitedKey++;\n  \t\tvar edgeStack = new Stack$1();\n  \t\tedgeStack.push(this._startingEdge);\n  \t\tvar visitedEdges = new HashSet();\n  \t\twhile (!edgeStack.empty()) {\n  \t\t\tvar edge = edgeStack.pop();\n  \t\t\tif (!visitedEdges.contains(edge)) {\n  \t\t\t\tvar triEdges = this.fetchTriangleToVisit(edge, edgeStack, includeFrame, visitedEdges);\n  \t\t\t\tif (triEdges !== null) triVisitor.visit(triEdges);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tisFrameEdge: function isFrameEdge(e) {\n  \t\tif (this.isFrameVertex(e.orig()) || this.isFrameVertex(e.dest())) return true;\n  \t\treturn false;\n  \t},\n  \tisOnEdge: function isOnEdge(e, p) {\n  \t\tthis._seg.setCoordinates(e.orig().getCoordinate(), e.dest().getCoordinate());\n  \t\tvar dist = this._seg.distance(p);\n  \t\treturn dist < this._edgeCoincidenceTolerance;\n  \t},\n  \tgetEnvelope: function getEnvelope() {\n  \t\treturn new Envelope(this._frameEnv);\n  \t},\n  \tcreateFrame: function createFrame(env) {\n  \t\tvar deltaX = env.getWidth();\n  \t\tvar deltaY = env.getHeight();\n  \t\tvar offset = 0.0;\n  \t\tif (deltaX > deltaY) {\n  \t\t\toffset = deltaX * 10.0;\n  \t\t} else {\n  \t\t\toffset = deltaY * 10.0;\n  \t\t}\n  \t\tthis._frameVertex[0] = new Vertex((env.getMaxX() + env.getMinX()) / 2.0, env.getMaxY() + offset);\n  \t\tthis._frameVertex[1] = new Vertex(env.getMinX() - offset, env.getMinY() - offset);\n  \t\tthis._frameVertex[2] = new Vertex(env.getMaxX() + offset, env.getMinY() - offset);\n  \t\tthis._frameEnv = new Envelope(this._frameVertex[0].getCoordinate(), this._frameVertex[1].getCoordinate());\n  \t\tthis._frameEnv.expandToInclude(this._frameVertex[2].getCoordinate());\n  \t},\n  \tgetTriangleCoordinates: function getTriangleCoordinates(includeFrame) {\n  \t\tvar visitor = new TriangleCoordinatesVisitor();\n  \t\tthis.visitTriangles(visitor, includeFrame);\n  \t\treturn visitor.getTriangles();\n  \t},\n  \tgetVertices: function getVertices(includeFrame) {\n  \t\tvar vertices = new HashSet();\n  \t\tfor (var i = this._quadEdges.iterator(); i.hasNext();) {\n  \t\t\tvar qe = i.next();\n  \t\t\tvar v = qe.orig();\n  \t\t\tif (includeFrame || !this.isFrameVertex(v)) vertices.add(v);\n  \t\t\tvar vd = qe.dest();\n  \t\t\tif (includeFrame || !this.isFrameVertex(vd)) vertices.add(vd);\n  \t\t}\n  \t\treturn vertices;\n  \t},\n  \tfetchTriangleToVisit: function fetchTriangleToVisit(edge, edgeStack, includeFrame, visitedEdges) {\n  \t\tvar curr = edge;\n  \t\tvar edgeCount = 0;\n  \t\tvar isFrame = false;\n  \t\tdo {\n  \t\t\tthis._triEdges[edgeCount] = curr;\n  \t\t\tif (this.isFrameEdge(curr)) isFrame = true;\n  \t\t\tvar sym = curr.sym();\n  \t\t\tif (!visitedEdges.contains(sym)) edgeStack.push(sym);\n  \t\t\tvisitedEdges.add(curr);\n  \t\t\tedgeCount++;\n  \t\t\tcurr = curr.lNext();\n  \t\t} while (curr !== edge);\n  \t\tif (isFrame && !includeFrame) return null;\n  \t\treturn this._triEdges;\n  \t},\n  \tgetEdges: function getEdges() {\n  \t\tif (arguments.length === 0) {\n  \t\t\treturn this._quadEdges;\n  \t\t} else if (arguments.length === 1) {\n  \t\t\tvar geomFact = arguments[0];\n  \t\t\tvar quadEdges = this.getPrimaryEdges(false);\n  \t\t\tvar edges = new Array(quadEdges.size()).fill(null);\n  \t\t\tvar i = 0;\n  \t\t\tfor (var it = quadEdges.iterator(); it.hasNext();) {\n  \t\t\t\tvar qe = it.next();\n  \t\t\t\tedges[i++] = geomFact.createLineString([qe.orig().getCoordinate(), qe.dest().getCoordinate()]);\n  \t\t\t}\n  \t\t\treturn geomFact.createMultiLineString(edges);\n  \t\t}\n  \t},\n  \tgetVertexUniqueEdges: function getVertexUniqueEdges(includeFrame) {\n  \t\tvar edges = new ArrayList();\n  \t\tvar visitedVertices = new HashSet();\n  \t\tfor (var i = this._quadEdges.iterator(); i.hasNext();) {\n  \t\t\tvar qe = i.next();\n  \t\t\tvar v = qe.orig();\n  \t\t\tif (!visitedVertices.contains(v)) {\n  \t\t\t\tvisitedVertices.add(v);\n  \t\t\t\tif (includeFrame || !this.isFrameVertex(v)) {\n  \t\t\t\t\tedges.add(qe);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\tvar qd = qe.sym();\n  \t\t\tvar vd = qd.orig();\n  \t\t\tif (!visitedVertices.contains(vd)) {\n  \t\t\t\tvisitedVertices.add(vd);\n  \t\t\t\tif (includeFrame || !this.isFrameVertex(vd)) {\n  \t\t\t\t\tedges.add(qd);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\treturn edges;\n  \t},\n  \tgetTriangleEdges: function getTriangleEdges(includeFrame) {\n  \t\tvar visitor = new TriangleEdgesListVisitor();\n  \t\tthis.visitTriangles(visitor, includeFrame);\n  \t\treturn visitor.getTriangleEdges();\n  \t},\n  \tgetPrimaryEdges: function getPrimaryEdges(includeFrame) {\n  \t\tthis._visitedKey++;\n  \t\tvar edges = new ArrayList();\n  \t\tvar edgeStack = new Stack$1();\n  \t\tedgeStack.push(this._startingEdge);\n  \t\tvar visitedEdges = new HashSet();\n  \t\twhile (!edgeStack.empty()) {\n  \t\t\tvar edge = edgeStack.pop();\n  \t\t\tif (!visitedEdges.contains(edge)) {\n  \t\t\t\tvar priQE = edge.getPrimary();\n  \t\t\t\tif (includeFrame || !this.isFrameEdge(priQE)) edges.add(priQE);\n  \t\t\t\tedgeStack.push(edge.oNext());\n  \t\t\t\tedgeStack.push(edge.sym().oNext());\n  \t\t\t\tvisitedEdges.add(edge);\n  \t\t\t\tvisitedEdges.add(edge.sym());\n  \t\t\t}\n  \t\t}\n  \t\treturn edges;\n  \t},\n  \tdelete: function _delete(e) {\n  \t\tQuadEdge.splice(e, e.oPrev());\n  \t\tQuadEdge.splice(e.sym(), e.sym().oPrev());\n  \t\tvar eSym = e.sym();\n  \t\tvar eRot = e.rot();\n  \t\tvar eRotSym = e.rot().sym();\n  \t\tthis._quadEdges.remove(e);\n  \t\tthis._quadEdges.remove(eSym);\n  \t\tthis._quadEdges.remove(eRot);\n  \t\tthis._quadEdges.remove(eRotSym);\n  \t\te.delete();\n  \t\teSym.delete();\n  \t\teRot.delete();\n  \t\teRotSym.delete();\n  \t},\n  \tlocateFromEdge: function locateFromEdge(v, startEdge) {\n  \t\tvar iter = 0;\n  \t\tvar maxIter = this._quadEdges.size();\n  \t\tvar e = startEdge;\n  \t\twhile (true) {\n  \t\t\titer++;\n  \t\t\tif (iter > maxIter) {\n  \t\t\t\tthrow new LocateFailureException(e.toLineSegment());\n  \t\t\t}\n  \t\t\tif (v.equals(e.orig()) || v.equals(e.dest())) {\n  \t\t\t\tbreak;\n  \t\t\t} else if (v.rightOf(e)) {\n  \t\t\t\te = e.sym();\n  \t\t\t} else if (!v.rightOf(e.oNext())) {\n  \t\t\t\te = e.oNext();\n  \t\t\t} else if (!v.rightOf(e.dPrev())) {\n  \t\t\t\te = e.dPrev();\n  \t\t\t} else {\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t}\n  \t\treturn e;\n  \t},\n  \tgetTolerance: function getTolerance() {\n  \t\treturn this._tolerance;\n  \t},\n  \tgetVoronoiCellPolygons: function getVoronoiCellPolygons(geomFact) {\n  \t\tthis.visitTriangles(new TriangleCircumcentreVisitor(), true);\n  \t\tvar cells = new ArrayList();\n  \t\tvar edges = this.getVertexUniqueEdges(false);\n  \t\tfor (var i = edges.iterator(); i.hasNext();) {\n  \t\t\tvar qe = i.next();\n  \t\t\tcells.add(this.getVoronoiCellPolygon(qe, geomFact));\n  \t\t}\n  \t\treturn cells;\n  \t},\n  \tgetVoronoiDiagram: function getVoronoiDiagram(geomFact) {\n  \t\tvar vorCells = this.getVoronoiCellPolygons(geomFact);\n  \t\treturn geomFact.createGeometryCollection(GeometryFactory.toGeometryArray(vorCells));\n  \t},\n  \tgetTriangles: function getTriangles(geomFact) {\n  \t\tvar triPtsList = this.getTriangleCoordinates(false);\n  \t\tvar tris = new Array(triPtsList.size()).fill(null);\n  \t\tvar i = 0;\n  \t\tfor (var it = triPtsList.iterator(); it.hasNext();) {\n  \t\t\tvar triPt = it.next();\n  \t\t\ttris[i++] = geomFact.createPolygon(geomFact.createLinearRing(triPt), null);\n  \t\t}\n  \t\treturn geomFact.createGeometryCollection(tris);\n  \t},\n  \tinsertSite: function insertSite(v) {\n  \t\tvar e = this.locate(v);\n  \t\tif (v.equals(e.orig(), this._tolerance) || v.equals(e.dest(), this._tolerance)) {\n  \t\t\treturn e;\n  \t\t}\n  \t\tvar base = this.makeEdge(e.orig(), v);\n  \t\tQuadEdge.splice(base, e);\n  \t\tvar startEdge = base;\n  \t\tdo {\n  \t\t\tbase = this.connect(e, base.sym());\n  \t\t\te = base.oPrev();\n  \t\t} while (e.lNext() !== startEdge);\n  \t\treturn startEdge;\n  \t},\n  \tlocate: function locate() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tif (arguments[0] instanceof Vertex) {\n  \t\t\t\tvar v = arguments[0];\n  \t\t\t\treturn this._locator.locate(v);\n  \t\t\t} else if (arguments[0] instanceof Coordinate) {\n  \t\t\t\tvar p = arguments[0];\n  \t\t\t\treturn this._locator.locate(new Vertex(p));\n  \t\t\t}\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar p0 = arguments[0],\n  \t\t\t    p1 = arguments[1];\n  \t\t\tvar e = this._locator.locate(new Vertex(p0));\n  \t\t\tif (e === null) return null;\n  \t\t\tvar base = e;\n  \t\t\tif (e.dest().getCoordinate().equals2D(p0)) base = e.sym();\n  \t\t\tvar locEdge = base;\n  \t\t\tdo {\n  \t\t\t\tif (locEdge.dest().getCoordinate().equals2D(p1)) return locEdge;\n  \t\t\t\tlocEdge = locEdge.oNext();\n  \t\t\t} while (locEdge !== base);\n  \t\t\treturn null;\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn QuadEdgeSubdivision;\n  \t}\n  });\n  QuadEdgeSubdivision.getTriangleEdges = function (startQE, triEdge) {\n  \ttriEdge[0] = startQE;\n  \ttriEdge[1] = triEdge[0].lNext();\n  \ttriEdge[2] = triEdge[1].lNext();\n  \tif (triEdge[2].lNext() !== triEdge[0]) throw new IllegalArgumentException(\"Edges do not form a triangle\");\n  };\n  function TriangleCircumcentreVisitor() {}\n  extend(TriangleCircumcentreVisitor.prototype, {\n  \tvisit: function visit(triEdges) {\n  \t\tvar a = triEdges[0].orig().getCoordinate();\n  \t\tvar b = triEdges[1].orig().getCoordinate();\n  \t\tvar c = triEdges[2].orig().getCoordinate();\n  \t\tvar cc = Triangle$1.circumcentre(a, b, c);\n  \t\tvar ccVertex = new Vertex(cc);\n  \t\tfor (var i = 0; i < 3; i++) {\n  \t\t\ttriEdges[i].rot().setOrig(ccVertex);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [TriangleVisitor];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn TriangleCircumcentreVisitor;\n  \t}\n  });\n  function TriangleEdgesListVisitor() {\n  \tthis._triList = new ArrayList();\n  }\n  extend(TriangleEdgesListVisitor.prototype, {\n  \tgetTriangleEdges: function getTriangleEdges() {\n  \t\treturn this._triList;\n  \t},\n  \tvisit: function visit(triEdges) {\n  \t\tthis._triList.add(triEdges.clone());\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [TriangleVisitor];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn TriangleEdgesListVisitor;\n  \t}\n  });\n  function TriangleVertexListVisitor() {\n  \tthis._triList = new ArrayList();\n  }\n  extend(TriangleVertexListVisitor.prototype, {\n  \tvisit: function visit(triEdges) {\n  \t\tthis._triList.add([triEdges[0].orig(), triEdges[1].orig(), triEdges[2].orig()]);\n  \t},\n  \tgetTriangleVertices: function getTriangleVertices() {\n  \t\treturn this._triList;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [TriangleVisitor];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn TriangleVertexListVisitor;\n  \t}\n  });\n  function TriangleCoordinatesVisitor() {\n  \tthis._coordList = new CoordinateList();\n  \tthis._triCoords = new ArrayList();\n  }\n  extend(TriangleCoordinatesVisitor.prototype, {\n  \tcheckTriangleSize: function checkTriangleSize(pts) {\n  \t\tvar loc = \"\";\n  \t\tif (pts.length >= 2) loc = WKTWriter.toLineString(pts[0], pts[1]);else {\n  \t\t\tif (pts.length >= 1) loc = WKTWriter.toPoint(pts[0]);\n  \t\t}\n  \t},\n  \tvisit: function visit(triEdges) {\n  \t\tthis._coordList.clear();\n  \t\tfor (var i = 0; i < 3; i++) {\n  \t\t\tvar v = triEdges[i].orig();\n  \t\t\tthis._coordList.add(v.getCoordinate());\n  \t\t}\n  \t\tif (this._coordList.size() > 0) {\n  \t\t\tthis._coordList.closeRing();\n  \t\t\tvar pts = this._coordList.toCoordinateArray();\n  \t\t\tif (pts.length !== 4) {\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t\tthis._triCoords.add(pts);\n  \t\t}\n  \t},\n  \tgetTriangles: function getTriangles() {\n  \t\treturn this._triCoords;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [TriangleVisitor];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn TriangleCoordinatesVisitor;\n  \t}\n  });\n  QuadEdgeSubdivision.TriangleCircumcentreVisitor = TriangleCircumcentreVisitor;\n  QuadEdgeSubdivision.TriangleEdgesListVisitor = TriangleEdgesListVisitor;\n  QuadEdgeSubdivision.TriangleVertexListVisitor = TriangleVertexListVisitor;\n  QuadEdgeSubdivision.TriangleCoordinatesVisitor = TriangleCoordinatesVisitor;\n  QuadEdgeSubdivision.EDGE_COINCIDENCE_TOL_FACTOR = 1000;\n\n  function Segment() {\n  \tthis._ls = null;\n  \tthis._data = null;\n  \tif (arguments.length === 2) {\n  \t\tvar p0 = arguments[0],\n  \t\t    p1 = arguments[1];\n  \t\tthis._ls = new LineSegment(p0, p1);\n  \t} else if (arguments.length === 3) {\n  \t\tvar p0 = arguments[0],\n  \t\t    p1 = arguments[1],\n  \t\t    data = arguments[2];\n  \t\tthis._ls = new LineSegment(p0, p1);\n  \t\tthis._data = data;\n  \t} else if (arguments.length === 6) {\n  \t\tvar x1 = arguments[0],\n  \t\t    y1 = arguments[1],\n  \t\t    z1 = arguments[2],\n  \t\t    x2 = arguments[3],\n  \t\t    y2 = arguments[4],\n  \t\t    z2 = arguments[5];\n  \t\tSegment.call(this, new Coordinate(x1, y1, z1), new Coordinate(x2, y2, z2));\n  \t} else if (arguments.length === 7) {\n  \t\tvar x1 = arguments[0],\n  \t\t    y1 = arguments[1],\n  \t\t    z1 = arguments[2],\n  \t\t    x2 = arguments[3],\n  \t\t    y2 = arguments[4],\n  \t\t    z2 = arguments[5],\n  \t\t    data = arguments[6];\n  \t\tSegment.call(this, new Coordinate(x1, y1, z1), new Coordinate(x2, y2, z2), data);\n  \t}\n  }\n  extend(Segment.prototype, {\n  \tgetLineSegment: function getLineSegment() {\n  \t\treturn this._ls;\n  \t},\n  \tgetEndZ: function getEndZ() {\n  \t\tvar p = this._ls.getCoordinate(1);\n  \t\treturn p.z;\n  \t},\n  \tgetStartZ: function getStartZ() {\n  \t\tvar p = this._ls.getCoordinate(0);\n  \t\treturn p.z;\n  \t},\n  \tintersection: function intersection(s) {\n  \t\treturn this._ls.intersection(s.getLineSegment());\n  \t},\n  \tgetStart: function getStart() {\n  \t\treturn this._ls.getCoordinate(0);\n  \t},\n  \tgetEnd: function getEnd() {\n  \t\treturn this._ls.getCoordinate(1);\n  \t},\n  \tgetEndY: function getEndY() {\n  \t\tvar p = this._ls.getCoordinate(1);\n  \t\treturn p.y;\n  \t},\n  \tgetStartX: function getStartX() {\n  \t\tvar p = this._ls.getCoordinate(0);\n  \t\treturn p.x;\n  \t},\n  \tequalsTopo: function equalsTopo(s) {\n  \t\treturn this._ls.equalsTopo(s.getLineSegment());\n  \t},\n  \tgetStartY: function getStartY() {\n  \t\tvar p = this._ls.getCoordinate(0);\n  \t\treturn p.y;\n  \t},\n  \tsetData: function setData(data) {\n  \t\tthis._data = data;\n  \t},\n  \tgetData: function getData() {\n  \t\treturn this._data;\n  \t},\n  \tgetEndX: function getEndX() {\n  \t\tvar p = this._ls.getCoordinate(1);\n  \t\treturn p.x;\n  \t},\n  \ttoString: function toString() {\n  \t\treturn this._ls.toString();\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn Segment;\n  \t}\n  });\n\n  function KdNodeVisitor() {}\n  extend(KdNodeVisitor.prototype, {\n  \tvisit: function visit(node) {},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn KdNodeVisitor;\n  \t}\n  });\n\n  function KdNode() {\n  \tthis._p = null;\n  \tthis._data = null;\n  \tthis._left = null;\n  \tthis._right = null;\n  \tthis._count = null;\n  \tif (arguments.length === 2) {\n  \t\tvar p = arguments[0],\n  \t\t    data = arguments[1];\n  \t\tthis._p = new Coordinate(p);\n  \t\tthis._left = null;\n  \t\tthis._right = null;\n  \t\tthis._count = 1;\n  \t\tthis._data = data;\n  \t} else if (arguments.length === 3) {\n  \t\tvar _x = arguments[0],\n  \t\t    _y = arguments[1],\n  \t\t    data = arguments[2];\n  \t\tthis._p = new Coordinate(_x, _y);\n  \t\tthis._left = null;\n  \t\tthis._right = null;\n  \t\tthis._count = 1;\n  \t\tthis._data = data;\n  \t}\n  }\n  extend(KdNode.prototype, {\n  \tisRepeated: function isRepeated() {\n  \t\treturn this._count > 1;\n  \t},\n  \tgetRight: function getRight() {\n  \t\treturn this._right;\n  \t},\n  \tgetCoordinate: function getCoordinate() {\n  \t\treturn this._p;\n  \t},\n  \tsetLeft: function setLeft(_left) {\n  \t\tthis._left = _left;\n  \t},\n  \tgetX: function getX() {\n  \t\treturn this._p.x;\n  \t},\n  \tgetData: function getData() {\n  \t\treturn this._data;\n  \t},\n  \tgetCount: function getCount() {\n  \t\treturn this._count;\n  \t},\n  \tgetLeft: function getLeft() {\n  \t\treturn this._left;\n  \t},\n  \tgetY: function getY() {\n  \t\treturn this._p.y;\n  \t},\n  \tincrement: function increment() {\n  \t\tthis._count = this._count + 1;\n  \t},\n  \tsetRight: function setRight(_right) {\n  \t\tthis._right = _right;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn KdNode;\n  \t}\n  });\n\n  function KdTree() {\n  \tthis._root = null;\n  \tthis._numberOfNodes = null;\n  \tthis._tolerance = null;\n  \tif (arguments.length === 0) {\n  \t\tKdTree.call(this, 0.0);\n  \t} else if (arguments.length === 1) {\n  \t\tvar tolerance = arguments[0];\n  \t\tthis._tolerance = tolerance;\n  \t}\n  }\n  extend(KdTree.prototype, {\n  \tinsert: function insert() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar p = arguments[0];\n  \t\t\treturn this.insert(p, null);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar p = arguments[0],\n  \t\t\t    data = arguments[1];\n  \t\t\tif (this._root === null) {\n  \t\t\t\tthis._root = new KdNode(p, data);\n  \t\t\t\treturn this._root;\n  \t\t\t}\n  \t\t\tif (this._tolerance > 0) {\n  \t\t\t\tvar matchNode = this.findBestMatchNode(p);\n  \t\t\t\tif (matchNode !== null) {\n  \t\t\t\t\tmatchNode.increment();\n  \t\t\t\t\treturn matchNode;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\treturn this.insertExact(p, data);\n  \t\t}\n  \t},\n  \tquery: function query() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar queryEnv = arguments[0];\n  \t\t\tvar result = new ArrayList();\n  \t\t\tthis.query(queryEnv, result);\n  \t\t\treturn result;\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tif (arguments[0] instanceof Envelope && hasInterface(arguments[1], List)) {\n  \t\t\t\tvar queryEnv = arguments[0],\n  \t\t\t\t    result = arguments[1];\n  \t\t\t\tthis.queryNode(this._root, queryEnv, true, {\n  \t\t\t\t\tinterfaces_: function interfaces_() {\n  \t\t\t\t\t\treturn [KdNodeVisitor];\n  \t\t\t\t\t},\n  \t\t\t\t\tvisit: function visit(node) {\n  \t\t\t\t\t\tresult.add(node);\n  \t\t\t\t\t}\n  \t\t\t\t});\n  \t\t\t} else if (arguments[0] instanceof Envelope && hasInterface(arguments[1], KdNodeVisitor)) {\n  \t\t\t\tvar queryEnv = arguments[0],\n  \t\t\t\t    visitor = arguments[1];\n  \t\t\t\tthis.queryNode(this._root, queryEnv, true, visitor);\n  \t\t\t}\n  \t\t}\n  \t},\n  \tqueryNode: function queryNode(currentNode, queryEnv, odd, visitor) {\n  \t\tif (currentNode === null) return null;\n  \t\tvar min = null;\n  \t\tvar max = null;\n  \t\tvar discriminant = null;\n  \t\tif (odd) {\n  \t\t\tmin = queryEnv.getMinX();\n  \t\t\tmax = queryEnv.getMaxX();\n  \t\t\tdiscriminant = currentNode.getX();\n  \t\t} else {\n  \t\t\tmin = queryEnv.getMinY();\n  \t\t\tmax = queryEnv.getMaxY();\n  \t\t\tdiscriminant = currentNode.getY();\n  \t\t}\n  \t\tvar searchLeft = min < discriminant;\n  \t\tvar searchRight = discriminant <= max;\n  \t\tif (searchLeft) {\n  \t\t\tthis.queryNode(currentNode.getLeft(), queryEnv, !odd, visitor);\n  \t\t}\n  \t\tif (queryEnv.contains(currentNode.getCoordinate())) {\n  \t\t\tvisitor.visit(currentNode);\n  \t\t}\n  \t\tif (searchRight) {\n  \t\t\tthis.queryNode(currentNode.getRight(), queryEnv, !odd, visitor);\n  \t\t}\n  \t},\n  \tfindBestMatchNode: function findBestMatchNode(p) {\n  \t\tvar visitor = new BestMatchVisitor(p, this._tolerance);\n  \t\tthis.query(visitor.queryEnvelope(), visitor);\n  \t\treturn visitor.getNode();\n  \t},\n  \tisEmpty: function isEmpty() {\n  \t\tif (this._root === null) return true;\n  \t\treturn false;\n  \t},\n  \tinsertExact: function insertExact(p, data) {\n  \t\tvar currentNode = this._root;\n  \t\tvar leafNode = this._root;\n  \t\tvar isOddLevel = true;\n  \t\tvar isLessThan = true;\n  \t\twhile (currentNode !== null) {\n  \t\t\tif (currentNode !== null) {\n  \t\t\t\tvar isInTolerance = p.distance(currentNode.getCoordinate()) <= this._tolerance;\n  \t\t\t\tif (isInTolerance) {\n  \t\t\t\t\tcurrentNode.increment();\n  \t\t\t\t\treturn currentNode;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\tif (isOddLevel) {\n  \t\t\t\tisLessThan = p.x < currentNode.getX();\n  \t\t\t} else {\n  \t\t\t\tisLessThan = p.y < currentNode.getY();\n  \t\t\t}\n  \t\t\tleafNode = currentNode;\n  \t\t\tif (isLessThan) {\n  \t\t\t\tcurrentNode = currentNode.getLeft();\n  \t\t\t} else {\n  \t\t\t\tcurrentNode = currentNode.getRight();\n  \t\t\t}\n  \t\t\tisOddLevel = !isOddLevel;\n  \t\t}\n  \t\tthis._numberOfNodes = this._numberOfNodes + 1;\n  \t\tvar node = new KdNode(p, data);\n  \t\tif (isLessThan) {\n  \t\t\tleafNode.setLeft(node);\n  \t\t} else {\n  \t\t\tleafNode.setRight(node);\n  \t\t}\n  \t\treturn node;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn KdTree;\n  \t}\n  });\n  KdTree.toCoordinates = function () {\n  \tif (arguments.length === 1) {\n  \t\tvar kdnodes = arguments[0];\n  \t\treturn KdTree.toCoordinates(kdnodes, false);\n  \t} else if (arguments.length === 2) {\n  \t\tvar kdnodes = arguments[0],\n  \t\t    includeRepeated = arguments[1];\n  \t\tvar coord = new CoordinateList();\n  \t\tfor (var it = kdnodes.iterator(); it.hasNext();) {\n  \t\t\tvar node = it.next();\n  \t\t\tvar count = includeRepeated ? node.getCount() : 1;\n  \t\t\tfor (var i = 0; i < count; i++) {\n  \t\t\t\tcoord.add(node.getCoordinate(), true);\n  \t\t\t}\n  \t\t}\n  \t\treturn coord.toCoordinateArray();\n  \t}\n  };\n  function BestMatchVisitor() {\n  \tthis._tolerance = null;\n  \tthis._matchNode = null;\n  \tthis._matchDist = 0.0;\n  \tthis._p = null;\n  \tvar p = arguments[0],\n  \t    tolerance = arguments[1];\n  \tthis._p = p;\n  \tthis._tolerance = tolerance;\n  }\n  extend(BestMatchVisitor.prototype, {\n  \tvisit: function visit(node) {\n  \t\tvar dist = this._p.distance(node.getCoordinate());\n  \t\tvar isInTolerance = dist <= this._tolerance;\n  \t\tif (!isInTolerance) return null;\n  \t\tvar update = false;\n  \t\tif (this._matchNode === null || dist < this._matchDist || this._matchNode !== null && dist === this._matchDist && node.getCoordinate().compareTo(this._matchNode.getCoordinate()) < 1) update = true;\n  \t\tif (update) {\n  \t\t\tthis._matchNode = node;\n  \t\t\tthis._matchDist = dist;\n  \t\t}\n  \t},\n  \tqueryEnvelope: function queryEnvelope() {\n  \t\tvar queryEnv = new Envelope(this._p);\n  \t\tqueryEnv.expandBy(this._tolerance);\n  \t\treturn queryEnv;\n  \t},\n  \tgetNode: function getNode() {\n  \t\treturn this._matchNode;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [KdNodeVisitor];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn BestMatchVisitor;\n  \t}\n  });\n  KdTree.BestMatchVisitor = BestMatchVisitor;\n\n  function ConformingDelaunayTriangulator() {\n  \tthis._initialVertices = null;\n  \tthis._segVertices = null;\n  \tthis._segments = new ArrayList();\n  \tthis._subdiv = null;\n  \tthis._incDel = null;\n  \tthis._convexHull = null;\n  \tthis._splitFinder = new NonEncroachingSplitPointFinder();\n  \tthis._kdt = null;\n  \tthis._vertexFactory = null;\n  \tthis._computeAreaEnv = null;\n  \tthis._splitPt = null;\n  \tthis._tolerance = null;\n  \tvar initialVertices = arguments[0],\n  \t    tolerance = arguments[1];\n  \tthis._initialVertices = new ArrayList(initialVertices);\n  \tthis._tolerance = tolerance;\n  \tthis._kdt = new KdTree(tolerance);\n  }\n  extend(ConformingDelaunayTriangulator.prototype, {\n  \tgetInitialVertices: function getInitialVertices() {\n  \t\treturn this._initialVertices;\n  \t},\n  \tgetKDT: function getKDT() {\n  \t\treturn this._kdt;\n  \t},\n  \tenforceConstraints: function enforceConstraints() {\n  \t\tthis.addConstraintVertices();\n  \t\tvar count = 0;\n  \t\tvar splits = 0;\n  \t\tdo {\n  \t\t\tsplits = this.enforceGabriel(this._segments);\n  \t\t\tcount++;\n  \t\t} while (splits > 0 && count < ConformingDelaunayTriangulator.MAX_SPLIT_ITER);\n  \t},\n  \tinsertSites: function insertSites(vertices) {\n  \t\tfor (var i = vertices.iterator(); i.hasNext();) {\n  \t\t\tvar v = i.next();\n  \t\t\tthis.insertSite(v);\n  \t\t}\n  \t},\n  \tgetVertexFactory: function getVertexFactory() {\n  \t\treturn this._vertexFactory;\n  \t},\n  \tgetPointArray: function getPointArray() {\n  \t\tvar pts = new Array(this._initialVertices.size() + this._segVertices.size()).fill(null);\n  \t\tvar index = 0;\n  \t\tfor (var i = this._initialVertices.iterator(); i.hasNext();) {\n  \t\t\tvar v = i.next();\n  \t\t\tpts[index++] = v.getCoordinate();\n  \t\t}\n  \t\tfor (var i2 = this._segVertices.iterator(); i2.hasNext();) {\n  \t\t\tvar v = i2.next();\n  \t\t\tpts[index++] = v.getCoordinate();\n  \t\t}\n  \t\treturn pts;\n  \t},\n  \tsetConstraints: function setConstraints(segments, segVertices) {\n  \t\tthis._segments = segments;\n  \t\tthis._segVertices = segVertices;\n  \t},\n  \tcomputeConvexHull: function computeConvexHull() {\n  \t\tvar fact = new GeometryFactory();\n  \t\tvar coords = this.getPointArray();\n  \t\tvar hull = new ConvexHull(coords, fact);\n  \t\tthis._convexHull = hull.getConvexHull();\n  \t},\n  \taddConstraintVertices: function addConstraintVertices() {\n  \t\tthis.computeConvexHull();\n  \t\tthis.insertSites(this._segVertices);\n  \t},\n  \tfindNonGabrielPoint: function findNonGabrielPoint(seg) {\n  \t\tvar p = seg.getStart();\n  \t\tvar q = seg.getEnd();\n  \t\tvar midPt = new Coordinate((p.x + q.x) / 2.0, (p.y + q.y) / 2.0);\n  \t\tvar segRadius = p.distance(midPt);\n  \t\tvar env = new Envelope(midPt);\n  \t\tenv.expandBy(segRadius);\n  \t\tvar result = this._kdt.query(env);\n  \t\tvar closestNonGabriel = null;\n  \t\tvar minDist = Double.MAX_VALUE;\n  \t\tfor (var i = result.iterator(); i.hasNext();) {\n  \t\t\tvar nextNode = i.next();\n  \t\t\tvar testPt = nextNode.getCoordinate();\n  \t\t\tif (testPt.equals2D(p) || testPt.equals2D(q)) continue;\n  \t\t\tvar testRadius = midPt.distance(testPt);\n  \t\t\tif (testRadius < segRadius) {\n  \t\t\t\tvar testDist = testRadius;\n  \t\t\t\tif (closestNonGabriel === null || testDist < minDist) {\n  \t\t\t\t\tclosestNonGabriel = testPt;\n  \t\t\t\t\tminDist = testDist;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\treturn closestNonGabriel;\n  \t},\n  \tgetConstraintSegments: function getConstraintSegments() {\n  \t\treturn this._segments;\n  \t},\n  \tsetSplitPointFinder: function setSplitPointFinder(splitFinder) {\n  \t\tthis._splitFinder = splitFinder;\n  \t},\n  \tgetConvexHull: function getConvexHull() {\n  \t\treturn this._convexHull;\n  \t},\n  \tgetTolerance: function getTolerance() {\n  \t\treturn this._tolerance;\n  \t},\n  \tenforceGabriel: function enforceGabriel(segsToInsert) {\n  \t\tvar newSegments = new ArrayList();\n  \t\tvar splits = 0;\n  \t\tvar segsToRemove = new ArrayList();\n  \t\tfor (var i = segsToInsert.iterator(); i.hasNext();) {\n  \t\t\tvar seg = i.next();\n  \t\t\tvar encroachPt = this.findNonGabrielPoint(seg);\n  \t\t\tif (encroachPt === null) continue;\n  \t\t\tthis._splitPt = this._splitFinder.findSplitPoint(seg, encroachPt);\n  \t\t\tvar splitVertex = this.createVertex(this._splitPt, seg);\n  \t\t\tvar insertedVertex = this.insertSite(splitVertex);\n  \t\t\tvar s1 = new Segment(seg.getStartX(), seg.getStartY(), seg.getStartZ(), splitVertex.getX(), splitVertex.getY(), splitVertex.getZ(), seg.getData());\n  \t\t\tvar s2 = new Segment(splitVertex.getX(), splitVertex.getY(), splitVertex.getZ(), seg.getEndX(), seg.getEndY(), seg.getEndZ(), seg.getData());\n  \t\t\tnewSegments.add(s1);\n  \t\t\tnewSegments.add(s2);\n  \t\t\tsegsToRemove.add(seg);\n  \t\t\tsplits = splits + 1;\n  \t\t}\n  \t\tsegsToInsert.removeAll(segsToRemove);\n  \t\tsegsToInsert.addAll(newSegments);\n  \t\treturn splits;\n  \t},\n  \tcreateVertex: function createVertex() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar p = arguments[0];\n  \t\t\tvar v = null;\n  \t\t\tif (this._vertexFactory !== null) v = this._vertexFactory.createVertex(p, null);else v = new ConstraintVertex(p);\n  \t\t\treturn v;\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar p = arguments[0],\n  \t\t\t    seg = arguments[1];\n  \t\t\tvar v = null;\n  \t\t\tif (this._vertexFactory !== null) v = this._vertexFactory.createVertex(p, seg);else v = new ConstraintVertex(p);\n  \t\t\tv.setOnConstraint(true);\n  \t\t\treturn v;\n  \t\t}\n  \t},\n  \tgetSubdivision: function getSubdivision() {\n  \t\treturn this._subdiv;\n  \t},\n  \tcomputeBoundingBox: function computeBoundingBox() {\n  \t\tvar vertexEnv = ConformingDelaunayTriangulator.computeVertexEnvelope(this._initialVertices);\n  \t\tvar segEnv = ConformingDelaunayTriangulator.computeVertexEnvelope(this._segVertices);\n  \t\tvar allPointsEnv = new Envelope(vertexEnv);\n  \t\tallPointsEnv.expandToInclude(segEnv);\n  \t\tvar deltaX = allPointsEnv.getWidth() * 0.2;\n  \t\tvar deltaY = allPointsEnv.getHeight() * 0.2;\n  \t\tvar delta = Math.max(deltaX, deltaY);\n  \t\tthis._computeAreaEnv = new Envelope(allPointsEnv);\n  \t\tthis._computeAreaEnv.expandBy(delta);\n  \t},\n  \tsetVertexFactory: function setVertexFactory(vertexFactory) {\n  \t\tthis._vertexFactory = vertexFactory;\n  \t},\n  \tformInitialDelaunay: function formInitialDelaunay() {\n  \t\tthis.computeBoundingBox();\n  \t\tthis._subdiv = new QuadEdgeSubdivision(this._computeAreaEnv, this._tolerance);\n  \t\tthis._subdiv.setLocator(new LastFoundQuadEdgeLocator(this._subdiv));\n  \t\tthis._incDel = new IncrementalDelaunayTriangulator(this._subdiv);\n  \t\tthis.insertSites(this._initialVertices);\n  \t},\n  \tinsertSite: function insertSite() {\n  \t\tif (arguments[0] instanceof ConstraintVertex) {\n  \t\t\tvar v = arguments[0];\n  \t\t\tvar kdnode = this._kdt.insert(v.getCoordinate(), v);\n  \t\t\tif (!kdnode.isRepeated()) {\n  \t\t\t\tthis._incDel.insertSite(v);\n  \t\t\t} else {\n  \t\t\t\tvar snappedV = kdnode.getData();\n  \t\t\t\tsnappedV.merge(v);\n  \t\t\t\treturn snappedV;\n  \t\t\t}\n  \t\t\treturn v;\n  \t\t} else if (arguments[0] instanceof Coordinate) {\n  \t\t\tvar p = arguments[0];\n  \t\t\tthis.insertSite(this.createVertex(p));\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn ConformingDelaunayTriangulator;\n  \t}\n  });\n  ConformingDelaunayTriangulator.computeVertexEnvelope = function (vertices) {\n  \tvar env = new Envelope();\n  \tfor (var i = vertices.iterator(); i.hasNext();) {\n  \t\tvar v = i.next();\n  \t\tenv.expandToInclude(v.getCoordinate());\n  \t}\n  \treturn env;\n  };\n  ConformingDelaunayTriangulator.MAX_SPLIT_ITER = 99;\n\n  function DelaunayTriangulationBuilder() {\n  \tthis._siteCoords = null;\n  \tthis._tolerance = 0.0;\n  \tthis._subdiv = null;\n  }\n  extend(DelaunayTriangulationBuilder.prototype, {\n  \tcreate: function create() {\n  \t\tif (this._subdiv !== null) return null;\n  \t\tvar siteEnv = DelaunayTriangulationBuilder.envelope(this._siteCoords);\n  \t\tvar vertices = DelaunayTriangulationBuilder.toVertices(this._siteCoords);\n  \t\tthis._subdiv = new QuadEdgeSubdivision(siteEnv, this._tolerance);\n  \t\tvar triangulator = new IncrementalDelaunayTriangulator(this._subdiv);\n  \t\ttriangulator.insertSites(vertices);\n  \t},\n  \tsetTolerance: function setTolerance(tolerance) {\n  \t\tthis._tolerance = tolerance;\n  \t},\n  \tsetSites: function setSites() {\n  \t\tif (arguments[0] instanceof Geometry) {\n  \t\t\tvar geom = arguments[0];\n  \t\t\tthis._siteCoords = DelaunayTriangulationBuilder.extractUniqueCoordinates(geom);\n  \t\t} else if (hasInterface(arguments[0], Collection)) {\n  \t\t\tvar coords = arguments[0];\n  \t\t\tthis._siteCoords = DelaunayTriangulationBuilder.unique(CoordinateArrays.toCoordinateArray(coords));\n  \t\t}\n  \t},\n  \tgetEdges: function getEdges(geomFact) {\n  \t\tthis.create();\n  \t\treturn this._subdiv.getEdges(geomFact);\n  \t},\n  \tgetSubdivision: function getSubdivision() {\n  \t\tthis.create();\n  \t\treturn this._subdiv;\n  \t},\n  \tgetTriangles: function getTriangles(geomFact) {\n  \t\tthis.create();\n  \t\treturn this._subdiv.getTriangles(geomFact);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn DelaunayTriangulationBuilder;\n  \t}\n  });\n  DelaunayTriangulationBuilder.extractUniqueCoordinates = function (geom) {\n  \tif (geom === null) return new CoordinateList();\n  \tvar coords = geom.getCoordinates();\n  \treturn DelaunayTriangulationBuilder.unique(coords);\n  };\n  DelaunayTriangulationBuilder.envelope = function (coords) {\n  \tvar env = new Envelope();\n  \tfor (var i = coords.iterator(); i.hasNext();) {\n  \t\tvar coord = i.next();\n  \t\tenv.expandToInclude(coord);\n  \t}\n  \treturn env;\n  };\n  DelaunayTriangulationBuilder.unique = function (coords) {\n  \tvar coordsCopy = CoordinateArrays.copyDeep(coords);\n  \tArrays.sort(coordsCopy);\n  \tvar coordList = new CoordinateList(coordsCopy, false);\n  \treturn coordList;\n  };\n  DelaunayTriangulationBuilder.toVertices = function (coords) {\n  \tvar verts = new ArrayList();\n  \tfor (var i = coords.iterator(); i.hasNext();) {\n  \t\tvar coord = i.next();\n  \t\tverts.add(new Vertex(coord));\n  \t}\n  \treturn verts;\n  };\n\n  function ConformingDelaunayTriangulationBuilder() {\n  \tthis._siteCoords = null;\n  \tthis._constraintLines = null;\n  \tthis._tolerance = 0.0;\n  \tthis._subdiv = null;\n  \tthis._constraintVertexMap = new TreeMap();\n  }\n  extend(ConformingDelaunayTriangulationBuilder.prototype, {\n  \tcreateSiteVertices: function createSiteVertices(coords) {\n  \t\tvar verts = new ArrayList();\n  \t\tfor (var i = coords.iterator(); i.hasNext();) {\n  \t\t\tvar coord = i.next();\n  \t\t\tif (this._constraintVertexMap.containsKey(coord)) continue;\n  \t\t\tverts.add(new ConstraintVertex(coord));\n  \t\t}\n  \t\treturn verts;\n  \t},\n  \tcreate: function create() {\n  \t\tif (this._subdiv !== null) return null;\n  \t\tvar siteEnv = DelaunayTriangulationBuilder.envelope(this._siteCoords);\n  \t\tvar segments = new ArrayList();\n  \t\tif (this._constraintLines !== null) {\n  \t\t\tsiteEnv.expandToInclude(this._constraintLines.getEnvelopeInternal());\n  \t\t\tthis.createVertices(this._constraintLines);\n  \t\t\tsegments = ConformingDelaunayTriangulationBuilder.createConstraintSegments(this._constraintLines);\n  \t\t}\n  \t\tvar sites = this.createSiteVertices(this._siteCoords);\n  \t\tvar cdt = new ConformingDelaunayTriangulator(sites, this._tolerance);\n  \t\tcdt.setConstraints(segments, new ArrayList(this._constraintVertexMap.values()));\n  \t\tcdt.formInitialDelaunay();\n  \t\tcdt.enforceConstraints();\n  \t\tthis._subdiv = cdt.getSubdivision();\n  \t},\n  \tsetTolerance: function setTolerance(tolerance) {\n  \t\tthis._tolerance = tolerance;\n  \t},\n  \tsetConstraints: function setConstraints(constraintLines) {\n  \t\tthis._constraintLines = constraintLines;\n  \t},\n  \tsetSites: function setSites(geom) {\n  \t\tthis._siteCoords = DelaunayTriangulationBuilder.extractUniqueCoordinates(geom);\n  \t},\n  \tgetEdges: function getEdges(geomFact) {\n  \t\tthis.create();\n  \t\treturn this._subdiv.getEdges(geomFact);\n  \t},\n  \tgetSubdivision: function getSubdivision() {\n  \t\tthis.create();\n  \t\treturn this._subdiv;\n  \t},\n  \tgetTriangles: function getTriangles(geomFact) {\n  \t\tthis.create();\n  \t\treturn this._subdiv.getTriangles(geomFact);\n  \t},\n  \tcreateVertices: function createVertices(geom) {\n  \t\tvar coords = geom.getCoordinates();\n  \t\tfor (var i = 0; i < coords.length; i++) {\n  \t\t\tvar v = new ConstraintVertex(coords[i]);\n  \t\t\tthis._constraintVertexMap.put(coords[i], v);\n  \t\t}\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn ConformingDelaunayTriangulationBuilder;\n  \t}\n  });\n  ConformingDelaunayTriangulationBuilder.createConstraintSegments = function () {\n  \tif (arguments.length === 1) {\n  \t\tvar geom = arguments[0];\n  \t\tvar lines = LinearComponentExtracter.getLines(geom);\n  \t\tvar constraintSegs = new ArrayList();\n  \t\tfor (var i = lines.iterator(); i.hasNext();) {\n  \t\t\tvar line = i.next();\n  \t\t\tConformingDelaunayTriangulationBuilder.createConstraintSegments(line, constraintSegs);\n  \t\t}\n  \t\treturn constraintSegs;\n  \t} else if (arguments.length === 2) {\n  \t\tvar line = arguments[0],\n  \t\t    constraintSegs = arguments[1];\n  \t\tvar coords = line.getCoordinates();\n  \t\tfor (var i = 1; i < coords.length; i++) {\n  \t\t\tconstraintSegs.add(new Segment(coords[i - 1], coords[i]));\n  \t\t}\n  \t}\n  };\n\n  function VoronoiDiagramBuilder() {\n  \tthis._siteCoords = null;\n  \tthis._tolerance = 0.0;\n  \tthis._subdiv = null;\n  \tthis._clipEnv = null;\n  \tthis._diagramEnv = null;\n  }\n  extend(VoronoiDiagramBuilder.prototype, {\n  \tcreate: function create() {\n  \t\tif (this._subdiv !== null) return null;\n  \t\tvar siteEnv = DelaunayTriangulationBuilder.envelope(this._siteCoords);\n  \t\tthis._diagramEnv = siteEnv;\n  \t\tvar expandBy = Math.max(this._diagramEnv.getWidth(), this._diagramEnv.getHeight());\n  \t\tthis._diagramEnv.expandBy(expandBy);\n  \t\tif (this._clipEnv !== null) this._diagramEnv.expandToInclude(this._clipEnv);\n  \t\tvar vertices = DelaunayTriangulationBuilder.toVertices(this._siteCoords);\n  \t\tthis._subdiv = new QuadEdgeSubdivision(siteEnv, this._tolerance);\n  \t\tvar triangulator = new IncrementalDelaunayTriangulator(this._subdiv);\n  \t\ttriangulator.insertSites(vertices);\n  \t},\n  \tgetDiagram: function getDiagram(geomFact) {\n  \t\tthis.create();\n  \t\tvar polys = this._subdiv.getVoronoiDiagram(geomFact);\n  \t\treturn VoronoiDiagramBuilder.clipGeometryCollection(polys, this._diagramEnv);\n  \t},\n  \tsetTolerance: function setTolerance(tolerance) {\n  \t\tthis._tolerance = tolerance;\n  \t},\n  \tsetSites: function setSites() {\n  \t\tif (arguments[0] instanceof Geometry) {\n  \t\t\tvar geom = arguments[0];\n  \t\t\tthis._siteCoords = DelaunayTriangulationBuilder.extractUniqueCoordinates(geom);\n  \t\t} else if (hasInterface(arguments[0], Collection)) {\n  \t\t\tvar coords = arguments[0];\n  \t\t\tthis._siteCoords = DelaunayTriangulationBuilder.unique(CoordinateArrays.toCoordinateArray(coords));\n  \t\t}\n  \t},\n  \tsetClipEnvelope: function setClipEnvelope(clipEnv) {\n  \t\tthis._clipEnv = clipEnv;\n  \t},\n  \tgetSubdivision: function getSubdivision() {\n  \t\tthis.create();\n  \t\treturn this._subdiv;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn VoronoiDiagramBuilder;\n  \t}\n  });\n  VoronoiDiagramBuilder.clipGeometryCollection = function (geom, clipEnv) {\n  \tvar clipPoly = geom.getFactory().toGeometry(clipEnv);\n  \tvar clipped = new ArrayList();\n  \tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n  \t\tvar g = geom.getGeometryN(i);\n  \t\tvar result = null;\n  \t\tif (clipEnv.contains(g.getEnvelopeInternal())) result = g;else if (clipEnv.intersects(g.getEnvelopeInternal())) {\n  \t\t\tresult = clipPoly.intersection(g);\n  \t\t\tresult.setUserData(g.getUserData());\n  \t\t}\n  \t\tif (result !== null && !result.isEmpty()) {\n  \t\t\tclipped.add(result);\n  \t\t}\n  \t}\n  \treturn geom.getFactory().createGeometryCollection(GeometryFactory.toGeometryArray(clipped));\n  };\n\n  function LinearLocation() {\n  \tthis._componentIndex = 0;\n  \tthis._segmentIndex = 0;\n  \tthis._segmentFraction = 0.0;\n  \tif (arguments.length === 0) ; else if (arguments.length === 1) {\n  \t\tvar loc = arguments[0];\n  \t\tthis._componentIndex = loc._componentIndex;\n  \t\tthis._segmentIndex = loc._segmentIndex;\n  \t\tthis._segmentFraction = loc._segmentFraction;\n  \t} else if (arguments.length === 2) {\n  \t\tvar segmentIndex = arguments[0],\n  \t\t    segmentFraction = arguments[1];\n  \t\tLinearLocation.call(this, 0, segmentIndex, segmentFraction);\n  \t} else if (arguments.length === 3) {\n  \t\tvar componentIndex = arguments[0],\n  \t\t    segmentIndex = arguments[1],\n  \t\t    segmentFraction = arguments[2];\n  \t\tthis._componentIndex = componentIndex;\n  \t\tthis._segmentIndex = segmentIndex;\n  \t\tthis._segmentFraction = segmentFraction;\n  \t\tthis.normalize();\n  \t} else if (arguments.length === 4) {\n  \t\tvar componentIndex = arguments[0],\n  \t\t    segmentIndex = arguments[1],\n  \t\t    segmentFraction = arguments[2],\n  \t\t    doNormalize = arguments[3];\n  \t\tthis._componentIndex = componentIndex;\n  \t\tthis._segmentIndex = segmentIndex;\n  \t\tthis._segmentFraction = segmentFraction;\n  \t\tif (doNormalize) this.normalize();\n  \t}\n  }\n  extend(LinearLocation.prototype, {\n  \tgetSegmentIndex: function getSegmentIndex() {\n  \t\treturn this._segmentIndex;\n  \t},\n  \tgetComponentIndex: function getComponentIndex() {\n  \t\treturn this._componentIndex;\n  \t},\n  \tisEndpoint: function isEndpoint(linearGeom) {\n  \t\tvar lineComp = linearGeom.getGeometryN(this._componentIndex);\n  \t\tvar nseg = lineComp.getNumPoints() - 1;\n  \t\treturn this._segmentIndex >= nseg || this._segmentIndex === nseg && this._segmentFraction >= 1.0;\n  \t},\n  \tisValid: function isValid(linearGeom) {\n  \t\tif (this._componentIndex < 0 || this._componentIndex >= linearGeom.getNumGeometries()) return false;\n  \t\tvar lineComp = linearGeom.getGeometryN(this._componentIndex);\n  \t\tif (this._segmentIndex < 0 || this._segmentIndex > lineComp.getNumPoints()) return false;\n  \t\tif (this._segmentIndex === lineComp.getNumPoints() && this._segmentFraction !== 0.0) return false;\n  \t\tif (this._segmentFraction < 0.0 || this._segmentFraction > 1.0) return false;\n  \t\treturn true;\n  \t},\n  \tnormalize: function normalize() {\n  \t\tif (this._segmentFraction < 0.0) {\n  \t\t\tthis._segmentFraction = 0.0;\n  \t\t}\n  \t\tif (this._segmentFraction > 1.0) {\n  \t\t\tthis._segmentFraction = 1.0;\n  \t\t}\n  \t\tif (this._componentIndex < 0) {\n  \t\t\tthis._componentIndex = 0;\n  \t\t\tthis._segmentIndex = 0;\n  \t\t\tthis._segmentFraction = 0.0;\n  \t\t}\n  \t\tif (this._segmentIndex < 0) {\n  \t\t\tthis._segmentIndex = 0;\n  \t\t\tthis._segmentFraction = 0.0;\n  \t\t}\n  \t\tif (this._segmentFraction === 1.0) {\n  \t\t\tthis._segmentFraction = 0.0;\n  \t\t\tthis._segmentIndex += 1;\n  \t\t}\n  \t},\n  \ttoLowest: function toLowest(linearGeom) {\n  \t\tvar lineComp = linearGeom.getGeometryN(this._componentIndex);\n  \t\tvar nseg = lineComp.getNumPoints() - 1;\n  \t\tif (this._segmentIndex < nseg) return this;\n  \t\treturn new LinearLocation(this._componentIndex, nseg, 1.0, false);\n  \t},\n  \tgetCoordinate: function getCoordinate(linearGeom) {\n  \t\tvar lineComp = linearGeom.getGeometryN(this._componentIndex);\n  \t\tvar p0 = lineComp.getCoordinateN(this._segmentIndex);\n  \t\tif (this._segmentIndex >= lineComp.getNumPoints() - 1) return p0;\n  \t\tvar p1 = lineComp.getCoordinateN(this._segmentIndex + 1);\n  \t\treturn LinearLocation.pointAlongSegmentByFraction(p0, p1, this._segmentFraction);\n  \t},\n  \tgetSegmentFraction: function getSegmentFraction() {\n  \t\treturn this._segmentFraction;\n  \t},\n  \tgetSegment: function getSegment(linearGeom) {\n  \t\tvar lineComp = linearGeom.getGeometryN(this._componentIndex);\n  \t\tvar p0 = lineComp.getCoordinateN(this._segmentIndex);\n  \t\tif (this._segmentIndex >= lineComp.getNumPoints() - 1) {\n  \t\t\tvar prev = lineComp.getCoordinateN(lineComp.getNumPoints() - 2);\n  \t\t\treturn new LineSegment(prev, p0);\n  \t\t}\n  \t\tvar p1 = lineComp.getCoordinateN(this._segmentIndex + 1);\n  \t\treturn new LineSegment(p0, p1);\n  \t},\n  \tclamp: function clamp(linear) {\n  \t\tif (this._componentIndex >= linear.getNumGeometries()) {\n  \t\t\tthis.setToEnd(linear);\n  \t\t\treturn null;\n  \t\t}\n  \t\tif (this._segmentIndex >= linear.getNumPoints()) {\n  \t\t\tvar line = linear.getGeometryN(this._componentIndex);\n  \t\t\tthis._segmentIndex = line.getNumPoints() - 1;\n  \t\t\tthis._segmentFraction = 1.0;\n  \t\t}\n  \t},\n  \tsetToEnd: function setToEnd(linear) {\n  \t\tthis._componentIndex = linear.getNumGeometries() - 1;\n  \t\tvar lastLine = linear.getGeometryN(this._componentIndex);\n  \t\tthis._segmentIndex = lastLine.getNumPoints() - 1;\n  \t\tthis._segmentFraction = 1.0;\n  \t},\n  \tcompareTo: function compareTo(o) {\n  \t\tvar other = o;\n  \t\tif (this._componentIndex < other._componentIndex) return -1;\n  \t\tif (this._componentIndex > other._componentIndex) return 1;\n  \t\tif (this._segmentIndex < other._segmentIndex) return -1;\n  \t\tif (this._segmentIndex > other._segmentIndex) return 1;\n  \t\tif (this._segmentFraction < other._segmentFraction) return -1;\n  \t\tif (this._segmentFraction > other._segmentFraction) return 1;\n  \t\treturn 0;\n  \t},\n  \tclone: function clone() {\n  \t\treturn new LinearLocation(this._componentIndex, this._segmentIndex, this._segmentFraction);\n  \t},\n  \ttoString: function toString() {\n  \t\treturn \"LinearLoc[\" + this._componentIndex + \", \" + this._segmentIndex + \", \" + this._segmentFraction + \"]\";\n  \t},\n  \tisOnSameSegment: function isOnSameSegment(loc) {\n  \t\tif (this._componentIndex !== loc._componentIndex) return false;\n  \t\tif (this._segmentIndex === loc._segmentIndex) return true;\n  \t\tif (loc._segmentIndex - this._segmentIndex === 1 && loc._segmentFraction === 0.0) return true;\n  \t\tif (this._segmentIndex - loc._segmentIndex === 1 && this._segmentFraction === 0.0) return true;\n  \t\treturn false;\n  \t},\n  \tsnapToVertex: function snapToVertex(linearGeom, minDistance) {\n  \t\tif (this._segmentFraction <= 0.0 || this._segmentFraction >= 1.0) return null;\n  \t\tvar segLen = this.getSegmentLength(linearGeom);\n  \t\tvar lenToStart = this._segmentFraction * segLen;\n  \t\tvar lenToEnd = segLen - lenToStart;\n  \t\tif (lenToStart <= lenToEnd && lenToStart < minDistance) {\n  \t\t\tthis._segmentFraction = 0.0;\n  \t\t} else if (lenToEnd <= lenToStart && lenToEnd < minDistance) {\n  \t\t\tthis._segmentFraction = 1.0;\n  \t\t}\n  \t},\n  \tcompareLocationValues: function compareLocationValues(componentIndex1, segmentIndex1, segmentFraction1) {\n  \t\tif (this._componentIndex < componentIndex1) return -1;\n  \t\tif (this._componentIndex > componentIndex1) return 1;\n  \t\tif (this._segmentIndex < segmentIndex1) return -1;\n  \t\tif (this._segmentIndex > segmentIndex1) return 1;\n  \t\tif (this._segmentFraction < segmentFraction1) return -1;\n  \t\tif (this._segmentFraction > segmentFraction1) return 1;\n  \t\treturn 0;\n  \t},\n  \tgetSegmentLength: function getSegmentLength(linearGeom) {\n  \t\tvar lineComp = linearGeom.getGeometryN(this._componentIndex);\n  \t\tvar segIndex = this._segmentIndex;\n  \t\tif (this._segmentIndex >= lineComp.getNumPoints() - 1) segIndex = lineComp.getNumPoints() - 2;\n  \t\tvar p0 = lineComp.getCoordinateN(segIndex);\n  \t\tvar p1 = lineComp.getCoordinateN(segIndex + 1);\n  \t\treturn p0.distance(p1);\n  \t},\n  \tisVertex: function isVertex() {\n  \t\treturn this._segmentFraction <= 0.0 || this._segmentFraction >= 1.0;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [Comparable];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LinearLocation;\n  \t}\n  });\n  LinearLocation.getEndLocation = function (linear) {\n  \tvar loc = new LinearLocation();\n  \tloc.setToEnd(linear);\n  \treturn loc;\n  };\n  LinearLocation.pointAlongSegmentByFraction = function (p0, p1, frac) {\n  \tif (frac <= 0.0) return p0;\n  \tif (frac >= 1.0) return p1;\n  \tvar x = (p1.x - p0.x) * frac + p0.x;\n  \tvar y = (p1.y - p0.y) * frac + p0.y;\n  \tvar z = (p1.z - p0.z) * frac + p0.z;\n  \treturn new Coordinate(x, y, z);\n  };\n  LinearLocation.compareLocationValues = function (componentIndex0, segmentIndex0, segmentFraction0, componentIndex1, segmentIndex1, segmentFraction1) {\n  \tif (componentIndex0 < componentIndex1) return -1;\n  \tif (componentIndex0 > componentIndex1) return 1;\n  \tif (segmentIndex0 < segmentIndex1) return -1;\n  \tif (segmentIndex0 > segmentIndex1) return 1;\n  \tif (segmentFraction0 < segmentFraction1) return -1;\n  \tif (segmentFraction0 > segmentFraction1) return 1;\n  \treturn 0;\n  };\n\n  function LinearIterator() {\n  \tthis._linearGeom = null;\n  \tthis._numLines = null;\n  \tthis._currentLine = null;\n  \tthis._componentIndex = 0;\n  \tthis._vertexIndex = 0;\n  \tif (arguments.length === 1) {\n  \t\tvar linear = arguments[0];\n  \t\tLinearIterator.call(this, linear, 0, 0);\n  \t} else if (arguments.length === 2) {\n  \t\tvar linear = arguments[0],\n  \t\t    start = arguments[1];\n  \t\tLinearIterator.call(this, linear, start.getComponentIndex(), LinearIterator.segmentEndVertexIndex(start));\n  \t} else if (arguments.length === 3) {\n  \t\tvar linearGeom = arguments[0],\n  \t\t    componentIndex = arguments[1],\n  \t\t    vertexIndex = arguments[2];\n  \t\tif (!hasInterface(linearGeom, Lineal)) throw new IllegalArgumentException(\"Lineal geometry is required\");\n  \t\tthis._linearGeom = linearGeom;\n  \t\tthis._numLines = linearGeom.getNumGeometries();\n  \t\tthis._componentIndex = componentIndex;\n  \t\tthis._vertexIndex = vertexIndex;\n  \t\tthis.loadCurrentLine();\n  \t}\n  }\n  extend(LinearIterator.prototype, {\n  \tgetComponentIndex: function getComponentIndex() {\n  \t\treturn this._componentIndex;\n  \t},\n  \tgetLine: function getLine() {\n  \t\treturn this._currentLine;\n  \t},\n  \tgetVertexIndex: function getVertexIndex() {\n  \t\treturn this._vertexIndex;\n  \t},\n  \tgetSegmentEnd: function getSegmentEnd() {\n  \t\tif (this._vertexIndex < this.getLine().getNumPoints() - 1) return this._currentLine.getCoordinateN(this._vertexIndex + 1);\n  \t\treturn null;\n  \t},\n  \tnext: function next() {\n  \t\tif (!this.hasNext()) return null;\n  \t\tthis._vertexIndex++;\n  \t\tif (this._vertexIndex >= this._currentLine.getNumPoints()) {\n  \t\t\tthis._componentIndex++;\n  \t\t\tthis.loadCurrentLine();\n  \t\t\tthis._vertexIndex = 0;\n  \t\t}\n  \t},\n  \tloadCurrentLine: function loadCurrentLine() {\n  \t\tif (this._componentIndex >= this._numLines) {\n  \t\t\tthis._currentLine = null;\n  \t\t\treturn null;\n  \t\t}\n  \t\tthis._currentLine = this._linearGeom.getGeometryN(this._componentIndex);\n  \t},\n  \tgetSegmentStart: function getSegmentStart() {\n  \t\treturn this._currentLine.getCoordinateN(this._vertexIndex);\n  \t},\n  \tisEndOfLine: function isEndOfLine() {\n  \t\tif (this._componentIndex >= this._numLines) return false;\n  \t\tif (this._vertexIndex < this._currentLine.getNumPoints() - 1) return false;\n  \t\treturn true;\n  \t},\n  \thasNext: function hasNext() {\n  \t\tif (this._componentIndex >= this._numLines) return false;\n  \t\tif (this._componentIndex === this._numLines - 1 && this._vertexIndex >= this._currentLine.getNumPoints()) return false;\n  \t\treturn true;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LinearIterator;\n  \t}\n  });\n  LinearIterator.segmentEndVertexIndex = function (loc) {\n  \tif (loc.getSegmentFraction() > 0.0) return loc.getSegmentIndex() + 1;\n  \treturn loc.getSegmentIndex();\n  };\n\n  function LocationIndexOfPoint() {\n  \tthis._linearGeom = null;\n  \tvar linearGeom = arguments[0];\n  \tthis._linearGeom = linearGeom;\n  }\n  extend(LocationIndexOfPoint.prototype, {\n  \tindexOf: function indexOf(inputPt) {\n  \t\treturn this.indexOfFromStart(inputPt, null);\n  \t},\n  \tindexOfFromStart: function indexOfFromStart(inputPt, minIndex) {\n  \t\tvar minDistance = Double.MAX_VALUE;\n  \t\tvar minComponentIndex = 0;\n  \t\tvar minSegmentIndex = 0;\n  \t\tvar minFrac = -1.0;\n  \t\tvar seg = new LineSegment();\n  \t\tfor (var it = new LinearIterator(this._linearGeom); it.hasNext(); it.next()) {\n  \t\t\tif (!it.isEndOfLine()) {\n  \t\t\t\tseg.p0 = it.getSegmentStart();\n  \t\t\t\tseg.p1 = it.getSegmentEnd();\n  \t\t\t\tvar segDistance = seg.distance(inputPt);\n  \t\t\t\tvar segFrac = seg.segmentFraction(inputPt);\n  \t\t\t\tvar candidateComponentIndex = it.getComponentIndex();\n  \t\t\t\tvar candidateSegmentIndex = it.getVertexIndex();\n  \t\t\t\tif (segDistance < minDistance) {\n  \t\t\t\t\tif (minIndex === null || minIndex.compareLocationValues(candidateComponentIndex, candidateSegmentIndex, segFrac) < 0) {\n  \t\t\t\t\t\tminComponentIndex = candidateComponentIndex;\n  \t\t\t\t\t\tminSegmentIndex = candidateSegmentIndex;\n  \t\t\t\t\t\tminFrac = segFrac;\n  \t\t\t\t\t\tminDistance = segDistance;\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\tif (minDistance === Double.MAX_VALUE) {\n  \t\t\treturn new LinearLocation(minIndex);\n  \t\t}\n  \t\tvar loc = new LinearLocation(minComponentIndex, minSegmentIndex, minFrac);\n  \t\treturn loc;\n  \t},\n  \tindexOfAfter: function indexOfAfter(inputPt, minIndex) {\n  \t\tif (minIndex === null) return this.indexOf(inputPt);\n  \t\tvar endLoc = LinearLocation.getEndLocation(this._linearGeom);\n  \t\tif (endLoc.compareTo(minIndex) <= 0) return endLoc;\n  \t\tvar closestAfter = this.indexOfFromStart(inputPt, minIndex);\n  \t\tAssert.isTrue(closestAfter.compareTo(minIndex) >= 0, \"computed location is before specified minimum location\");\n  \t\treturn closestAfter;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LocationIndexOfPoint;\n  \t}\n  });\n  LocationIndexOfPoint.indexOf = function (linearGeom, inputPt) {\n  \tvar locater = new LocationIndexOfPoint(linearGeom);\n  \treturn locater.indexOf(inputPt);\n  };\n  LocationIndexOfPoint.indexOfAfter = function (linearGeom, inputPt, minIndex) {\n  \tvar locater = new LocationIndexOfPoint(linearGeom);\n  \treturn locater.indexOfAfter(inputPt, minIndex);\n  };\n\n  function LocationIndexOfLine() {\n  \tthis._linearGeom = null;\n  \tvar linearGeom = arguments[0];\n  \tthis._linearGeom = linearGeom;\n  }\n  extend(LocationIndexOfLine.prototype, {\n  \tindicesOf: function indicesOf(subLine) {\n  \t\tvar startPt = subLine.getGeometryN(0).getCoordinateN(0);\n  \t\tvar lastLine = subLine.getGeometryN(subLine.getNumGeometries() - 1);\n  \t\tvar endPt = lastLine.getCoordinateN(lastLine.getNumPoints() - 1);\n  \t\tvar locPt = new LocationIndexOfPoint(this._linearGeom);\n  \t\tvar subLineLoc = new Array(2).fill(null);\n  \t\tsubLineLoc[0] = locPt.indexOf(startPt);\n  \t\tif (subLine.getLength() === 0.0) {\n  \t\t\tsubLineLoc[1] = subLineLoc[0].clone();\n  \t\t} else {\n  \t\t\tsubLineLoc[1] = locPt.indexOfAfter(endPt, subLineLoc[0]);\n  \t\t}\n  \t\treturn subLineLoc;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LocationIndexOfLine;\n  \t}\n  });\n  LocationIndexOfLine.indicesOf = function (linearGeom, subLine) {\n  \tvar locater = new LocationIndexOfLine(linearGeom);\n  \treturn locater.indicesOf(subLine);\n  };\n\n  function LinearGeometryBuilder() {\n  \tthis._geomFact = null;\n  \tthis._lines = new ArrayList();\n  \tthis._coordList = null;\n  \tthis._ignoreInvalidLines = false;\n  \tthis._fixInvalidLines = false;\n  \tthis._lastPt = null;\n  \tvar geomFact = arguments[0];\n  \tthis._geomFact = geomFact;\n  }\n  extend(LinearGeometryBuilder.prototype, {\n  \tgetGeometry: function getGeometry() {\n  \t\tthis.endLine();\n  \t\treturn this._geomFact.buildGeometry(this._lines);\n  \t},\n  \tgetLastCoordinate: function getLastCoordinate() {\n  \t\treturn this._lastPt;\n  \t},\n  \tendLine: function endLine() {\n  \t\tif (this._coordList === null) {\n  \t\t\treturn null;\n  \t\t}\n  \t\tif (this._ignoreInvalidLines && this._coordList.size() < 2) {\n  \t\t\tthis._coordList = null;\n  \t\t\treturn null;\n  \t\t}\n  \t\tvar rawPts = this._coordList.toCoordinateArray();\n  \t\tvar pts = rawPts;\n  \t\tif (this._fixInvalidLines) pts = this.validCoordinateSequence(rawPts);\n  \t\tthis._coordList = null;\n  \t\tvar line = null;\n  \t\ttry {\n  \t\t\tline = this._geomFact.createLineString(pts);\n  \t\t} catch (ex) {\n  \t\t\tif (ex instanceof IllegalArgumentException) {\n  \t\t\t\tif (!this._ignoreInvalidLines) throw ex;\n  \t\t\t} else throw ex;\n  \t\t} finally {}\n  \t\tif (line !== null) this._lines.add(line);\n  \t},\n  \tsetFixInvalidLines: function setFixInvalidLines(fixInvalidLines) {\n  \t\tthis._fixInvalidLines = fixInvalidLines;\n  \t},\n  \tadd: function add() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar pt = arguments[0];\n  \t\t\tthis.add(pt, true);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar pt = arguments[0],\n  \t\t\t    allowRepeatedPoints = arguments[1];\n  \t\t\tif (this._coordList === null) this._coordList = new CoordinateList();\n  \t\t\tthis._coordList.add(pt, allowRepeatedPoints);\n  \t\t\tthis._lastPt = pt;\n  \t\t}\n  \t},\n  \tsetIgnoreInvalidLines: function setIgnoreInvalidLines(ignoreInvalidLines) {\n  \t\tthis._ignoreInvalidLines = ignoreInvalidLines;\n  \t},\n  \tvalidCoordinateSequence: function validCoordinateSequence(pts) {\n  \t\tif (pts.length >= 2) return pts;\n  \t\tvar validPts = [pts[0], pts[0]];\n  \t\treturn validPts;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LinearGeometryBuilder;\n  \t}\n  });\n\n  function ExtractLineByLocation() {\n  \tthis._line = null;\n  \tvar line = arguments[0];\n  \tthis._line = line;\n  }\n  extend(ExtractLineByLocation.prototype, {\n  \tcomputeLinear: function computeLinear(start, end) {\n  \t\tvar builder = new LinearGeometryBuilder(this._line.getFactory());\n  \t\tbuilder.setFixInvalidLines(true);\n  \t\tif (!start.isVertex()) builder.add(start.getCoordinate(this._line));\n  \t\tfor (var it = new LinearIterator(this._line, start); it.hasNext(); it.next()) {\n  \t\t\tif (end.compareLocationValues(it.getComponentIndex(), it.getVertexIndex(), 0.0) < 0) break;\n  \t\t\tvar pt = it.getSegmentStart();\n  \t\t\tbuilder.add(pt);\n  \t\t\tif (it.isEndOfLine()) builder.endLine();\n  \t\t}\n  \t\tif (!end.isVertex()) builder.add(end.getCoordinate(this._line));\n  \t\treturn builder.getGeometry();\n  \t},\n  \tcomputeLine: function computeLine(start, end) {\n  \t\tvar coordinates = this._line.getCoordinates();\n  \t\tvar newCoordinates = new CoordinateList();\n  \t\tvar startSegmentIndex = start.getSegmentIndex();\n  \t\tif (start.getSegmentFraction() > 0.0) startSegmentIndex += 1;\n  \t\tvar lastSegmentIndex = end.getSegmentIndex();\n  \t\tif (end.getSegmentFraction() === 1.0) lastSegmentIndex += 1;\n  \t\tif (lastSegmentIndex >= coordinates.length) lastSegmentIndex = coordinates.length - 1;\n  \t\tif (!start.isVertex()) newCoordinates.add(start.getCoordinate(this._line));\n  \t\tfor (var i = startSegmentIndex; i <= lastSegmentIndex; i++) {\n  \t\t\tnewCoordinates.add(coordinates[i]);\n  \t\t}\n  \t\tif (!end.isVertex()) newCoordinates.add(end.getCoordinate(this._line));\n  \t\tif (newCoordinates.size() <= 0) newCoordinates.add(start.getCoordinate(this._line));\n  \t\tvar newCoordinateArray = newCoordinates.toCoordinateArray();\n  \t\tif (newCoordinateArray.length <= 1) {\n  \t\t\tnewCoordinateArray = [newCoordinateArray[0], newCoordinateArray[0]];\n  \t\t}\n  \t\treturn this._line.getFactory().createLineString(newCoordinateArray);\n  \t},\n  \textract: function extract(start, end) {\n  \t\tif (end.compareTo(start) < 0) {\n  \t\t\treturn this.reverse(this.computeLinear(end, start));\n  \t\t}\n  \t\treturn this.computeLinear(start, end);\n  \t},\n  \treverse: function reverse(linear) {\n  \t\tif (linear instanceof LineString) return linear.reverse();\n  \t\tif (linear instanceof MultiLineString) return linear.reverse();\n  \t\tAssert.shouldNeverReachHere(\"non-linear geometry encountered\");\n  \t\treturn null;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn ExtractLineByLocation;\n  \t}\n  });\n  ExtractLineByLocation.extract = function (line, start, end) {\n  \tvar ls = new ExtractLineByLocation(line);\n  \treturn ls.extract(start, end);\n  };\n\n  function LocationIndexedLine() {\n  \tthis._linearGeom = null;\n  \tvar linearGeom = arguments[0];\n  \tthis._linearGeom = linearGeom;\n  \tthis.checkGeometryType();\n  }\n  extend(LocationIndexedLine.prototype, {\n  \tclampIndex: function clampIndex(index) {\n  \t\tvar loc = index.clone();\n  \t\tloc.clamp(this._linearGeom);\n  \t\treturn loc;\n  \t},\n  \tproject: function project(pt) {\n  \t\treturn LocationIndexOfPoint.indexOf(this._linearGeom, pt);\n  \t},\n  \tcheckGeometryType: function checkGeometryType() {\n  \t\tif (!(this._linearGeom instanceof LineString || this._linearGeom instanceof MultiLineString)) throw new IllegalArgumentException(\"Input geometry must be linear\");\n  \t},\n  \textractPoint: function extractPoint() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar index = arguments[0];\n  \t\t\treturn index.getCoordinate(this._linearGeom);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar index = arguments[0],\n  \t\t\t    offsetDistance = arguments[1];\n  \t\t\tvar indexLow = index.toLowest(this._linearGeom);\n  \t\t\treturn indexLow.getSegment(this._linearGeom).pointAlongOffset(indexLow.getSegmentFraction(), offsetDistance);\n  \t\t}\n  \t},\n  \tisValidIndex: function isValidIndex(index) {\n  \t\treturn index.isValid(this._linearGeom);\n  \t},\n  \tgetEndIndex: function getEndIndex() {\n  \t\treturn LinearLocation.getEndLocation(this._linearGeom);\n  \t},\n  \tgetStartIndex: function getStartIndex() {\n  \t\treturn new LinearLocation();\n  \t},\n  \tindexOfAfter: function indexOfAfter(pt, minIndex) {\n  \t\treturn LocationIndexOfPoint.indexOfAfter(this._linearGeom, pt, minIndex);\n  \t},\n  \textractLine: function extractLine(startIndex, endIndex) {\n  \t\treturn ExtractLineByLocation.extract(this._linearGeom, startIndex, endIndex);\n  \t},\n  \tindexOf: function indexOf(pt) {\n  \t\treturn LocationIndexOfPoint.indexOf(this._linearGeom, pt);\n  \t},\n  \tindicesOf: function indicesOf(subLine) {\n  \t\treturn LocationIndexOfLine.indicesOf(this._linearGeom, subLine);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LocationIndexedLine;\n  \t}\n  });\n\n  function LengthIndexOfPoint() {\n  \tthis._linearGeom = null;\n  \tvar linearGeom = arguments[0];\n  \tthis._linearGeom = linearGeom;\n  }\n  extend(LengthIndexOfPoint.prototype, {\n  \tindexOf: function indexOf(inputPt) {\n  \t\treturn this.indexOfFromStart(inputPt, -1.0);\n  \t},\n  \tindexOfFromStart: function indexOfFromStart(inputPt, minIndex) {\n  \t\tvar minDistance = Double.MAX_VALUE;\n  \t\tvar ptMeasure = minIndex;\n  \t\tvar segmentStartMeasure = 0.0;\n  \t\tvar seg = new LineSegment();\n  \t\tvar it = new LinearIterator(this._linearGeom);\n  \t\twhile (it.hasNext()) {\n  \t\t\tif (!it.isEndOfLine()) {\n  \t\t\t\tseg.p0 = it.getSegmentStart();\n  \t\t\t\tseg.p1 = it.getSegmentEnd();\n  \t\t\t\tvar segDistance = seg.distance(inputPt);\n  \t\t\t\tvar segMeasureToPt = this.segmentNearestMeasure(seg, inputPt, segmentStartMeasure);\n  \t\t\t\tif (segDistance < minDistance && segMeasureToPt > minIndex) {\n  \t\t\t\t\tptMeasure = segMeasureToPt;\n  \t\t\t\t\tminDistance = segDistance;\n  \t\t\t\t}\n  \t\t\t\tsegmentStartMeasure += seg.getLength();\n  \t\t\t}\n  \t\t\tit.next();\n  \t\t}\n  \t\treturn ptMeasure;\n  \t},\n  \tindexOfAfter: function indexOfAfter(inputPt, minIndex) {\n  \t\tif (minIndex < 0.0) return this.indexOf(inputPt);\n  \t\tvar endIndex = this._linearGeom.getLength();\n  \t\tif (endIndex < minIndex) return endIndex;\n  \t\tvar closestAfter = this.indexOfFromStart(inputPt, minIndex);\n  \t\tAssert.isTrue(closestAfter >= minIndex, \"computed index is before specified minimum index\");\n  \t\treturn closestAfter;\n  \t},\n  \tsegmentNearestMeasure: function segmentNearestMeasure(seg, inputPt, segmentStartMeasure) {\n  \t\tvar projFactor = seg.projectionFactor(inputPt);\n  \t\tif (projFactor <= 0.0) return segmentStartMeasure;\n  \t\tif (projFactor <= 1.0) return segmentStartMeasure + projFactor * seg.getLength();\n  \t\treturn segmentStartMeasure + seg.getLength();\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LengthIndexOfPoint;\n  \t}\n  });\n  LengthIndexOfPoint.indexOf = function (linearGeom, inputPt) {\n  \tvar locater = new LengthIndexOfPoint(linearGeom);\n  \treturn locater.indexOf(inputPt);\n  };\n  LengthIndexOfPoint.indexOfAfter = function (linearGeom, inputPt, minIndex) {\n  \tvar locater = new LengthIndexOfPoint(linearGeom);\n  \treturn locater.indexOfAfter(inputPt, minIndex);\n  };\n\n  function LengthLocationMap() {\n  \tthis._linearGeom = null;\n  \tvar linearGeom = arguments[0];\n  \tthis._linearGeom = linearGeom;\n  }\n  extend(LengthLocationMap.prototype, {\n  \tgetLength: function getLength(loc) {\n  \t\tvar totalLength = 0.0;\n  \t\tvar it = new LinearIterator(this._linearGeom);\n  \t\twhile (it.hasNext()) {\n  \t\t\tif (!it.isEndOfLine()) {\n  \t\t\t\tvar p0 = it.getSegmentStart();\n  \t\t\t\tvar p1 = it.getSegmentEnd();\n  \t\t\t\tvar segLen = p1.distance(p0);\n  \t\t\t\tif (loc.getComponentIndex() === it.getComponentIndex() && loc.getSegmentIndex() === it.getVertexIndex()) {\n  \t\t\t\t\treturn totalLength + segLen * loc.getSegmentFraction();\n  \t\t\t\t}\n  \t\t\t\ttotalLength += segLen;\n  \t\t\t}\n  \t\t\tit.next();\n  \t\t}\n  \t\treturn totalLength;\n  \t},\n  \tresolveHigher: function resolveHigher(loc) {\n  \t\tif (!loc.isEndpoint(this._linearGeom)) return loc;\n  \t\tvar compIndex = loc.getComponentIndex();\n  \t\tif (compIndex >= this._linearGeom.getNumGeometries() - 1) return loc;\n  \t\tdo {\n  \t\t\tcompIndex++;\n  \t\t} while (compIndex < this._linearGeom.getNumGeometries() - 1 && this._linearGeom.getGeometryN(compIndex).getLength() === 0);\n  \t\treturn new LinearLocation(compIndex, 0, 0.0);\n  \t},\n  \tgetLocation: function getLocation() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar length = arguments[0];\n  \t\t\treturn this.getLocation(length, true);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar length = arguments[0],\n  \t\t\t    resolveLower = arguments[1];\n  \t\t\tvar forwardLength = length;\n  \t\t\tif (length < 0.0) {\n  \t\t\t\tvar lineLen = this._linearGeom.getLength();\n  \t\t\t\tforwardLength = lineLen + length;\n  \t\t\t}\n  \t\t\tvar loc = this.getLocationForward(forwardLength);\n  \t\t\tif (resolveLower) {\n  \t\t\t\treturn loc;\n  \t\t\t}\n  \t\t\treturn this.resolveHigher(loc);\n  \t\t}\n  \t},\n  \tgetLocationForward: function getLocationForward(length) {\n  \t\tif (length <= 0.0) return new LinearLocation();\n  \t\tvar totalLength = 0.0;\n  \t\tvar it = new LinearIterator(this._linearGeom);\n  \t\twhile (it.hasNext()) {\n  \t\t\tif (it.isEndOfLine()) {\n  \t\t\t\tif (totalLength === length) {\n  \t\t\t\t\tvar compIndex = it.getComponentIndex();\n  \t\t\t\t\tvar segIndex = it.getVertexIndex();\n  \t\t\t\t\treturn new LinearLocation(compIndex, segIndex, 0.0);\n  \t\t\t\t}\n  \t\t\t} else {\n  \t\t\t\tvar p0 = it.getSegmentStart();\n  \t\t\t\tvar p1 = it.getSegmentEnd();\n  \t\t\t\tvar segLen = p1.distance(p0);\n  \t\t\t\tif (totalLength + segLen > length) {\n  \t\t\t\t\tvar frac = (length - totalLength) / segLen;\n  \t\t\t\t\tvar compIndex = it.getComponentIndex();\n  \t\t\t\t\tvar segIndex = it.getVertexIndex();\n  \t\t\t\t\treturn new LinearLocation(compIndex, segIndex, frac);\n  \t\t\t\t}\n  \t\t\t\ttotalLength += segLen;\n  \t\t\t}\n  \t\t\tit.next();\n  \t\t}\n  \t\treturn LinearLocation.getEndLocation(this._linearGeom);\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LengthLocationMap;\n  \t}\n  });\n  LengthLocationMap.getLength = function (linearGeom, loc) {\n  \tvar locater = new LengthLocationMap(linearGeom);\n  \treturn locater.getLength(loc);\n  };\n  LengthLocationMap.getLocation = function () {\n  \tif (arguments.length === 2) {\n  \t\tvar linearGeom = arguments[0],\n  \t\t    length = arguments[1];\n  \t\tvar locater = new LengthLocationMap(linearGeom);\n  \t\treturn locater.getLocation(length);\n  \t} else if (arguments.length === 3) {\n  \t\tvar linearGeom = arguments[0],\n  \t\t    length = arguments[1],\n  \t\t    resolveLower = arguments[2];\n  \t\tvar locater = new LengthLocationMap(linearGeom);\n  \t\treturn locater.getLocation(length, resolveLower);\n  \t}\n  };\n\n  function LengthIndexedLine() {\n  \tthis._linearGeom = null;\n  \tvar linearGeom = arguments[0];\n  \tthis._linearGeom = linearGeom;\n  }\n  extend(LengthIndexedLine.prototype, {\n  \tclampIndex: function clampIndex(index) {\n  \t\tvar posIndex = this.positiveIndex(index);\n  \t\tvar startIndex = this.getStartIndex();\n  \t\tif (posIndex < startIndex) return startIndex;\n  \t\tvar endIndex = this.getEndIndex();\n  \t\tif (posIndex > endIndex) return endIndex;\n  \t\treturn posIndex;\n  \t},\n  \tlocationOf: function locationOf() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar index = arguments[0];\n  \t\t\treturn LengthLocationMap.getLocation(this._linearGeom, index);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar index = arguments[0],\n  \t\t\t    resolveLower = arguments[1];\n  \t\t\treturn LengthLocationMap.getLocation(this._linearGeom, index, resolveLower);\n  \t\t}\n  \t},\n  \tproject: function project(pt) {\n  \t\treturn LengthIndexOfPoint.indexOf(this._linearGeom, pt);\n  \t},\n  \tpositiveIndex: function positiveIndex(index) {\n  \t\tif (index >= 0.0) return index;\n  \t\treturn this._linearGeom.getLength() + index;\n  \t},\n  \textractPoint: function extractPoint() {\n  \t\tif (arguments.length === 1) {\n  \t\t\tvar index = arguments[0];\n  \t\t\tvar loc = LengthLocationMap.getLocation(this._linearGeom, index);\n  \t\t\treturn loc.getCoordinate(this._linearGeom);\n  \t\t} else if (arguments.length === 2) {\n  \t\t\tvar index = arguments[0],\n  \t\t\t    offsetDistance = arguments[1];\n  \t\t\tvar loc = LengthLocationMap.getLocation(this._linearGeom, index);\n  \t\t\tvar locLow = loc.toLowest(this._linearGeom);\n  \t\t\treturn locLow.getSegment(this._linearGeom).pointAlongOffset(locLow.getSegmentFraction(), offsetDistance);\n  \t\t}\n  \t},\n  \tisValidIndex: function isValidIndex(index) {\n  \t\treturn index >= this.getStartIndex() && index <= this.getEndIndex();\n  \t},\n  \tgetEndIndex: function getEndIndex() {\n  \t\treturn this._linearGeom.getLength();\n  \t},\n  \tgetStartIndex: function getStartIndex() {\n  \t\treturn 0.0;\n  \t},\n  \tindexOfAfter: function indexOfAfter(pt, minIndex) {\n  \t\treturn LengthIndexOfPoint.indexOfAfter(this._linearGeom, pt, minIndex);\n  \t},\n  \textractLine: function extractLine(startIndex, endIndex) {\n  \t\tvar lil = new LocationIndexedLine(this._linearGeom);\n  \t\tvar startIndex2 = this.clampIndex(startIndex);\n  \t\tvar endIndex2 = this.clampIndex(endIndex);\n  \t\tvar resolveStartLower = startIndex2 === endIndex2;\n  \t\tvar startLoc = this.locationOf(startIndex2, resolveStartLower);\n  \t\tvar endLoc = this.locationOf(endIndex2);\n  \t\treturn ExtractLineByLocation.extract(this._linearGeom, startLoc, endLoc);\n  \t},\n  \tindexOf: function indexOf(pt) {\n  \t\treturn LengthIndexOfPoint.indexOf(this._linearGeom, pt);\n  \t},\n  \tindicesOf: function indicesOf(subLine) {\n  \t\tvar locIndex = LocationIndexOfLine.indicesOf(this._linearGeom, subLine);\n  \t\tvar index = [LengthLocationMap.getLength(this._linearGeom, locIndex[0]), LengthLocationMap.getLength(this._linearGeom, locIndex[1])];\n  \t\treturn index;\n  \t},\n  \tinterfaces_: function interfaces_() {\n  \t\treturn [];\n  \t},\n  \tgetClass: function getClass() {\n  \t\treturn LengthIndexedLine;\n  \t}\n  });\n\n  function union() {\n      var reader = new GeoJSONReader();\n      var result = reader.read(JSON.stringify(arguments[0].geometry));\n      for (var i = 1; i < arguments.length; i++) {\n          result = UnionOp.union(result, reader.read(JSON.stringify(arguments[i].geometry)));\n      }\n      var writer = new GeoJSONWriter();\n      result = writer.write(result);\n      return {\n          type: 'Feature',\n          geometry: result,\n          properties: arguments[0].properties\n      };\n  }\n\n  function union$1(poly1, poly2) {\n    var featurePolygon1 = polygonToFeaturePolygon(poly1),\n        featurePolygon2 = polygonToFeaturePolygon(poly2),\n        FeatureUnion = union(featurePolygon1, featurePolygon2);\n    return FeatureUnion;\n  }\n\n  function bbox$1(geojson) {\n      var BBox = [Infinity, Infinity, -Infinity, -Infinity];\n      coordEach$1(geojson, function (coord) {\n          if (BBox[0] > coord[0]) BBox[0] = coord[0];\n          if (BBox[1] > coord[1]) BBox[1] = coord[1];\n          if (BBox[2] < coord[0]) BBox[2] = coord[0];\n          if (BBox[3] < coord[1]) BBox[3] = coord[1];\n      });\n      return BBox;\n  }\n\n  function center(geojson, properties) {\n    var ext = bbox$1(geojson);\n    var x = (ext[0] + ext[2]) / 2;\n    var y = (ext[1] + ext[3]) / 2;\n    return point$1([x, y], properties);\n  }\n\n  function toMercator(geojson, options) {\n      return convert(geojson, 'mercator', options);\n  }\n  function toWgs84(geojson, options) {\n      return convert(geojson, 'wgs84', options);\n  }\n  function convert(geojson, projection, options) {\n      options = options || {};\n      if (!isObject$2(options)) throw new Error('options is invalid');\n      var mutate = options.mutate;\n      if (!geojson) throw new Error('geojson is required');\n      if (Array.isArray(geojson) && isNumber$1(geojson[0])) geojson = projection === 'mercator' ? convertToMercator(geojson) : convertToWgs84(geojson);\n      else {\n              if (mutate !== true) geojson = clone(geojson);\n              coordEach$1(geojson, function (coord) {\n                  var newCoord = projection === 'mercator' ? convertToMercator(coord) : convertToWgs84(coord);\n                  coord[0] = newCoord[0];\n                  coord[1] = newCoord[1];\n              });\n          }\n      return geojson;\n  }\n  function convertToMercator(lonLat) {\n      var D2R = Math.PI / 180,\n      A = 6378137.0,\n          MAXEXTENT = 20037508.342789244;\n      var adjusted = Math.abs(lonLat[0]) <= 180 ? lonLat[0] : lonLat[0] - sign(lonLat[0]) * 360;\n      var xy = [A * adjusted * D2R, A * Math.log(Math.tan(Math.PI * 0.25 + 0.5 * lonLat[1] * D2R))];\n      if (xy[0] > MAXEXTENT) xy[0] = MAXEXTENT;\n      if (xy[0] < -MAXEXTENT) xy[0] = -MAXEXTENT;\n      if (xy[1] > MAXEXTENT) xy[1] = MAXEXTENT;\n      if (xy[1] < -MAXEXTENT) xy[1] = -MAXEXTENT;\n      return xy;\n  }\n  function convertToWgs84(xy) {\n      var R2D = 180 / Math.PI;\n      var A = 6378137.0;\n      return [xy[0] * R2D / A, (Math.PI * 0.5 - 2.0 * Math.atan(Math.exp(-xy[1] / A))) * R2D];\n  }\n  function sign(x) {\n      return x < 0 ? -1 : x > 0 ? 1 : 0;\n  }\n\n  function adder () {\n    return new Adder();\n  }\n  function Adder() {\n    this.reset();\n  }\n  Adder.prototype = {\n    constructor: Adder,\n    reset: function reset() {\n      this.s =\n      this.t = 0;\n    },\n    add: function add(y) {\n      _add(temp, y, this.t);\n      _add(this, temp.s, this.s);\n      if (this.s) this.t += temp.t;else this.s = temp.t;\n    },\n    valueOf: function valueOf() {\n      return this.s;\n    }\n  };\n  var temp = new Adder();\n  function _add(adder, a, b) {\n    var x = adder.s = a + b,\n        bv = x - a,\n        av = x - bv;\n    adder.t = a - av + (b - bv);\n  }\n\n  var epsilon = 1e-6;\n  var pi = Math.PI;\n  var halfPi = pi / 2;\n  var quarterPi = pi / 4;\n  var tau = pi * 2;\n  var degrees = 180 / pi;\n  var radians = pi / 180;\n  var abs = Math.abs;\n  var atan = Math.atan;\n  var atan2 = Math.atan2;\n  var cos = Math.cos;\n  var exp = Math.exp;\n  var log = Math.log;\n  var sin = Math.sin;\n  var sqrt = Math.sqrt;\n  var tan = Math.tan;\n  function acos(x) {\n    return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);\n  }\n  function asin(x) {\n    return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);\n  }\n\n  function noop() {}\n\n  function streamGeometry(geometry, stream) {\n    if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {\n      streamGeometryType[geometry.type](geometry, stream);\n    }\n  }\n  var streamObjectType = {\n    Feature: function Feature(object, stream) {\n      streamGeometry(object.geometry, stream);\n    },\n    FeatureCollection: function FeatureCollection(object, stream) {\n      var features = object.features,\n          i = -1,\n          n = features.length;\n      while (++i < n) {\n        streamGeometry(features[i].geometry, stream);\n      }\n    }\n  };\n  var streamGeometryType = {\n    Sphere: function Sphere(object, stream) {\n      stream.sphere();\n    },\n    Point: function Point(object, stream) {\n      object = object.coordinates;\n      stream.point(object[0], object[1], object[2]);\n    },\n    MultiPoint: function MultiPoint(object, stream) {\n      var coordinates = object.coordinates,\n          i = -1,\n          n = coordinates.length;\n      while (++i < n) {\n        object = coordinates[i], stream.point(object[0], object[1], object[2]);\n      }\n    },\n    LineString: function LineString(object, stream) {\n      streamLine(object.coordinates, stream, 0);\n    },\n    MultiLineString: function MultiLineString(object, stream) {\n      var coordinates = object.coordinates,\n          i = -1,\n          n = coordinates.length;\n      while (++i < n) {\n        streamLine(coordinates[i], stream, 0);\n      }\n    },\n    Polygon: function Polygon(object, stream) {\n      streamPolygon(object.coordinates, stream);\n    },\n    MultiPolygon: function MultiPolygon(object, stream) {\n      var coordinates = object.coordinates,\n          i = -1,\n          n = coordinates.length;\n      while (++i < n) {\n        streamPolygon(coordinates[i], stream);\n      }\n    },\n    GeometryCollection: function GeometryCollection(object, stream) {\n      var geometries = object.geometries,\n          i = -1,\n          n = geometries.length;\n      while (++i < n) {\n        streamGeometry(geometries[i], stream);\n      }\n    }\n  };\n  function streamLine(coordinates, stream, closed) {\n    var i = -1,\n        n = coordinates.length - closed,\n        coordinate;\n    stream.lineStart();\n    while (++i < n) {\n      coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);\n    }stream.lineEnd();\n  }\n  function streamPolygon(coordinates, stream) {\n    var i = -1,\n        n = coordinates.length;\n    stream.polygonStart();\n    while (++i < n) {\n      streamLine(coordinates[i], stream, 1);\n    }stream.polygonEnd();\n  }\n  function geoStream (object, stream) {\n    if (object && streamObjectType.hasOwnProperty(object.type)) {\n      streamObjectType[object.type](object, stream);\n    } else {\n      streamGeometry(object, stream);\n    }\n  }\n\n  var areaRingSum = adder();\n  var areaSum = adder();\n\n  function spherical(cartesian) {\n    return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];\n  }\n  function cartesian(spherical) {\n    var lambda = spherical[0],\n        phi = spherical[1],\n        cosPhi = cos(phi);\n    return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];\n  }\n  function cartesianDot(a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n  }\n  function cartesianCross(a, b) {\n    return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];\n  }\n  function cartesianAddInPlace(a, b) {\n    a[0] += b[0], a[1] += b[1], a[2] += b[2];\n  }\n  function cartesianScale(vector, k) {\n    return [vector[0] * k, vector[1] * k, vector[2] * k];\n  }\n  function cartesianNormalizeInPlace(d) {\n    var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);\n    d[0] /= l, d[1] /= l, d[2] /= l;\n  }\n\n  var deltaSum = adder();\n\n  function compose (a, b) {\n    function compose(x, y) {\n      return x = a(x, y), b(x[0], x[1]);\n    }\n    if (a.invert && b.invert) compose.invert = function (x, y) {\n      return x = b.invert(x, y), x && a.invert(x[0], x[1]);\n    };\n    return compose;\n  }\n\n  function rotationIdentity(lambda, phi) {\n    return [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];\n  }\n  rotationIdentity.invert = rotationIdentity;\n  function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {\n    return (deltaLambda %= tau) ? deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;\n  }\n  function forwardRotationLambda(deltaLambda) {\n    return function (lambda, phi) {\n      return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];\n    };\n  }\n  function rotationLambda(deltaLambda) {\n    var rotation = forwardRotationLambda(deltaLambda);\n    rotation.invert = forwardRotationLambda(-deltaLambda);\n    return rotation;\n  }\n  function rotationPhiGamma(deltaPhi, deltaGamma) {\n    var cosDeltaPhi = cos(deltaPhi),\n        sinDeltaPhi = sin(deltaPhi),\n        cosDeltaGamma = cos(deltaGamma),\n        sinDeltaGamma = sin(deltaGamma);\n    function rotation(lambda, phi) {\n      var cosPhi = cos(phi),\n          x = cos(lambda) * cosPhi,\n          y = sin(lambda) * cosPhi,\n          z = sin(phi),\n          k = z * cosDeltaPhi + x * sinDeltaPhi;\n      return [atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi), asin(k * cosDeltaGamma + y * sinDeltaGamma)];\n    }\n    rotation.invert = function (lambda, phi) {\n      var cosPhi = cos(phi),\n          x = cos(lambda) * cosPhi,\n          y = sin(lambda) * cosPhi,\n          z = sin(phi),\n          k = z * cosDeltaGamma - y * sinDeltaGamma;\n      return [atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi), asin(k * cosDeltaPhi - x * sinDeltaPhi)];\n    };\n    return rotation;\n  }\n  function rotation (rotate) {\n    rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);\n    function forward(coordinates) {\n      coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);\n      return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;\n    }\n    forward.invert = function (coordinates) {\n      coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);\n      return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;\n    };\n    return forward;\n  }\n\n  function circleStream(stream, radius, delta, direction, t0, t1) {\n    if (!delta) return;\n    var cosRadius = cos(radius),\n        sinRadius = sin(radius),\n        step = direction * delta;\n    if (t0 == null) {\n      t0 = radius + direction * tau;\n      t1 = radius - step / 2;\n    } else {\n      t0 = circleRadius(cosRadius, t0);\n      t1 = circleRadius(cosRadius, t1);\n      if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau;\n    }\n    for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {\n      point = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);\n      stream.point(point[0], point[1]);\n    }\n  }\n  function circleRadius(cosRadius, point) {\n    point = cartesian(point), point[0] -= cosRadius;\n    cartesianNormalizeInPlace(point);\n    var radius = acos(-point[1]);\n    return ((-point[2] < 0 ? -radius : radius) + tau - epsilon) % tau;\n  }\n\n  function clipBuffer () {\n    var lines = [],\n        line;\n    return {\n      point: function point(x, y) {\n        line.push([x, y]);\n      },\n      lineStart: function lineStart() {\n        lines.push(line = []);\n      },\n      lineEnd: noop,\n      rejoin: function rejoin() {\n        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));\n      },\n      result: function result() {\n        var result = lines;\n        lines = [];\n        line = null;\n        return result;\n      }\n    };\n  }\n\n  function clipLine (a, b, x0, y0, x1, y1) {\n    var ax = a[0],\n        ay = a[1],\n        bx = b[0],\n        by = b[1],\n        t0 = 0,\n        t1 = 1,\n        dx = bx - ax,\n        dy = by - ay,\n        r;\n    r = x0 - ax;\n    if (!dx && r > 0) return;\n    r /= dx;\n    if (dx < 0) {\n      if (r < t0) return;\n      if (r < t1) t1 = r;\n    } else if (dx > 0) {\n      if (r > t1) return;\n      if (r > t0) t0 = r;\n    }\n    r = x1 - ax;\n    if (!dx && r < 0) return;\n    r /= dx;\n    if (dx < 0) {\n      if (r > t1) return;\n      if (r > t0) t0 = r;\n    } else if (dx > 0) {\n      if (r < t0) return;\n      if (r < t1) t1 = r;\n    }\n    r = y0 - ay;\n    if (!dy && r > 0) return;\n    r /= dy;\n    if (dy < 0) {\n      if (r < t0) return;\n      if (r < t1) t1 = r;\n    } else if (dy > 0) {\n      if (r > t1) return;\n      if (r > t0) t0 = r;\n    }\n    r = y1 - ay;\n    if (!dy && r < 0) return;\n    r /= dy;\n    if (dy < 0) {\n      if (r > t1) return;\n      if (r > t0) t0 = r;\n    } else if (dy > 0) {\n      if (r < t0) return;\n      if (r < t1) t1 = r;\n    }\n    if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;\n    if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;\n    return true;\n  }\n\n  function pointEqual (a, b) {\n    return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;\n  }\n\n  function Intersection(point, points, other, entry) {\n    this.x = point;\n    this.z = points;\n    this.o = other;\n    this.e = entry;\n    this.v = false;\n    this.n = this.p = null;\n  }\n  function clipPolygon (segments, compareIntersection, startInside, interpolate, stream) {\n    var subject = [],\n        clip = [],\n        i,\n        n;\n    segments.forEach(function (segment) {\n      if ((n = segment.length - 1) <= 0) return;\n      var n,\n          p0 = segment[0],\n          p1 = segment[n],\n          x;\n      if (pointEqual(p0, p1)) {\n        stream.lineStart();\n        for (i = 0; i < n; ++i) {\n          stream.point((p0 = segment[i])[0], p0[1]);\n        }stream.lineEnd();\n        return;\n      }\n      subject.push(x = new Intersection(p0, segment, null, true));\n      clip.push(x.o = new Intersection(p0, null, x, false));\n      subject.push(x = new Intersection(p1, segment, null, false));\n      clip.push(x.o = new Intersection(p1, null, x, true));\n    });\n    if (!subject.length) return;\n    clip.sort(compareIntersection);\n    link(subject);\n    link(clip);\n    for (i = 0, n = clip.length; i < n; ++i) {\n      clip[i].e = startInside = !startInside;\n    }\n    var start = subject[0],\n        points,\n        point;\n    while (1) {\n      var current = start,\n          isSubject = true;\n      while (current.v) {\n        if ((current = current.n) === start) return;\n      }points = current.z;\n      stream.lineStart();\n      do {\n        current.v = current.o.v = true;\n        if (current.e) {\n          if (isSubject) {\n            for (i = 0, n = points.length; i < n; ++i) {\n              stream.point((point = points[i])[0], point[1]);\n            }\n          } else {\n            interpolate(current.x, current.n.x, 1, stream);\n          }\n          current = current.n;\n        } else {\n          if (isSubject) {\n            points = current.p.z;\n            for (i = points.length - 1; i >= 0; --i) {\n              stream.point((point = points[i])[0], point[1]);\n            }\n          } else {\n            interpolate(current.x, current.p.x, -1, stream);\n          }\n          current = current.p;\n        }\n        current = current.o;\n        points = current.z;\n        isSubject = !isSubject;\n      } while (!current.v);\n      stream.lineEnd();\n    }\n  }\n  function link(array) {\n    if (!(n = array.length)) return;\n    var n,\n        i = 0,\n        a = array[0],\n        b;\n    while (++i < n) {\n      a.n = b = array[i];\n      b.p = a;\n      a = b;\n    }\n    a.n = b = array[0];\n    b.p = a;\n  }\n\n  function ascending (a, b) {\n    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n  }\n\n  function bisector (compare) {\n    if (compare.length === 1) compare = ascendingComparator(compare);\n    return {\n      left: function left(a, x, lo, hi) {\n        if (lo == null) lo = 0;\n        if (hi == null) hi = a.length;\n        while (lo < hi) {\n          var mid = lo + hi >>> 1;\n          if (compare(a[mid], x) < 0) lo = mid + 1;else hi = mid;\n        }\n        return lo;\n      },\n      right: function right(a, x, lo, hi) {\n        if (lo == null) lo = 0;\n        if (hi == null) hi = a.length;\n        while (lo < hi) {\n          var mid = lo + hi >>> 1;\n          if (compare(a[mid], x) > 0) hi = mid;else lo = mid + 1;\n        }\n        return lo;\n      }\n    };\n  }\n  function ascendingComparator(f) {\n    return function (d, x) {\n      return ascending(f(d), x);\n    };\n  }\n\n  var ascendingBisect = bisector(ascending);\n\n  function merge$1 (arrays) {\n    var n = arrays.length,\n        m,\n        i = -1,\n        j = 0,\n        merged,\n        array;\n    while (++i < n) {\n      j += arrays[i].length;\n    }merged = new Array(j);\n    while (--n >= 0) {\n      array = arrays[n];\n      m = array.length;\n      while (--m >= 0) {\n        merged[--j] = array[m];\n      }\n    }\n    return merged;\n  }\n\n  var clipMax = 1e9,\n      clipMin = -clipMax;\n  function clipExtent(x0, y0, x1, y1) {\n    function visible(x, y) {\n      return x0 <= x && x <= x1 && y0 <= y && y <= y1;\n    }\n    function interpolate(from, to, direction, stream) {\n      var a = 0,\n          a1 = 0;\n      if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {\n        do {\n          stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);\n        } while ((a = (a + direction + 4) % 4) !== a1);\n      } else {\n        stream.point(to[0], to[1]);\n      }\n    }\n    function corner(p, direction) {\n      return abs(p[0] - x0) < epsilon ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < epsilon ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < epsilon ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;\n    }\n    function compareIntersection(a, b) {\n      return comparePoint(a.x, b.x);\n    }\n    function comparePoint(a, b) {\n      var ca = corner(a, 1),\n          cb = corner(b, 1);\n      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];\n    }\n    return function (stream) {\n      var activeStream = stream,\n          bufferStream = clipBuffer(),\n          segments,\n          polygon,\n          ring,\n          x__,\n          y__,\n          v__,\n      x_,\n          y_,\n          v_,\n      first,\n          clean;\n      var clipStream = {\n        point: point,\n        lineStart: lineStart,\n        lineEnd: lineEnd,\n        polygonStart: polygonStart,\n        polygonEnd: polygonEnd\n      };\n      function point(x, y) {\n        if (visible(x, y)) activeStream.point(x, y);\n      }\n      function polygonInside() {\n        var winding = 0;\n        for (var i = 0, n = polygon.length; i < n; ++i) {\n          for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {\n            a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];\n            if (a1 <= y1) {\n              if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding;\n            } else {\n              if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding;\n            }\n          }\n        }\n        return winding;\n      }\n      function polygonStart() {\n        activeStream = bufferStream, segments = [], polygon = [], clean = true;\n      }\n      function polygonEnd() {\n        var startInside = polygonInside(),\n            cleanInside = clean && startInside,\n            visible = (segments = merge$1(segments)).length;\n        if (cleanInside || visible) {\n          stream.polygonStart();\n          if (cleanInside) {\n            stream.lineStart();\n            interpolate(null, null, 1, stream);\n            stream.lineEnd();\n          }\n          if (visible) {\n            clipPolygon(segments, compareIntersection, startInside, interpolate, stream);\n          }\n          stream.polygonEnd();\n        }\n        activeStream = stream, segments = polygon = ring = null;\n      }\n      function lineStart() {\n        clipStream.point = linePoint;\n        if (polygon) polygon.push(ring = []);\n        first = true;\n        v_ = false;\n        x_ = y_ = NaN;\n      }\n      function lineEnd() {\n        if (segments) {\n          linePoint(x__, y__);\n          if (v__ && v_) bufferStream.rejoin();\n          segments.push(bufferStream.result());\n        }\n        clipStream.point = point;\n        if (v_) activeStream.lineEnd();\n      }\n      function linePoint(x, y) {\n        var v = visible(x, y);\n        if (polygon) ring.push([x, y]);\n        if (first) {\n          x__ = x, y__ = y, v__ = v;\n          first = false;\n          if (v) {\n            activeStream.lineStart();\n            activeStream.point(x, y);\n          }\n        } else {\n          if (v && v_) activeStream.point(x, y);else {\n            var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],\n                b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];\n            if (clipLine(a, b, x0, y0, x1, y1)) {\n              if (!v_) {\n                activeStream.lineStart();\n                activeStream.point(a[0], a[1]);\n              }\n              activeStream.point(b[0], b[1]);\n              if (!v) activeStream.lineEnd();\n              clean = false;\n            } else if (v) {\n              activeStream.lineStart();\n              activeStream.point(x, y);\n              clean = false;\n            }\n          }\n        }\n        x_ = x, y_ = y, v_ = v;\n      }\n      return clipStream;\n    };\n  }\n\n  var sum$1 = adder();\n  function polygonContains (polygon, point) {\n    var lambda = point[0],\n        phi = point[1],\n        normal = [sin(lambda), -cos(lambda), 0],\n        angle = 0,\n        winding = 0;\n    sum$1.reset();\n    for (var i = 0, n = polygon.length; i < n; ++i) {\n      if (!(m = (ring = polygon[i]).length)) continue;\n      var ring,\n          m,\n          point0 = ring[m - 1],\n          lambda0 = point0[0],\n          phi0 = point0[1] / 2 + quarterPi,\n          sinPhi0 = sin(phi0),\n          cosPhi0 = cos(phi0);\n      for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {\n        var point1 = ring[j],\n            lambda1 = point1[0],\n            phi1 = point1[1] / 2 + quarterPi,\n            sinPhi1 = sin(phi1),\n            cosPhi1 = cos(phi1),\n            delta = lambda1 - lambda0,\n            sign = delta >= 0 ? 1 : -1,\n            absDelta = sign * delta,\n            antimeridian = absDelta > pi,\n            k = sinPhi0 * sinPhi1;\n        sum$1.add(atan2(k * sign * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta)));\n        angle += antimeridian ? delta + sign * tau : delta;\n        if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {\n          var arc = cartesianCross(cartesian(point0), cartesian(point1));\n          cartesianNormalizeInPlace(arc);\n          var intersection = cartesianCross(normal, arc);\n          cartesianNormalizeInPlace(intersection);\n          var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);\n          if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {\n            winding += antimeridian ^ delta >= 0 ? 1 : -1;\n          }\n        }\n      }\n    }\n    return (angle < -epsilon || angle < epsilon && sum$1 < -epsilon) ^ winding & 1;\n  }\n\n  var lengthSum = adder();\n\n  function identity$3 (x) {\n    return x;\n  }\n\n  var areaSum$1 = adder(),\n      areaRingSum$1 = adder();\n\n  var x0$2 = Infinity,\n      y0$2 = x0$2,\n      x1 = -x0$2,\n      y1 = x1;\n  var boundsStream$1 = {\n    point: boundsPoint$1,\n    lineStart: noop,\n    lineEnd: noop,\n    polygonStart: noop,\n    polygonEnd: noop,\n    result: function result() {\n      var bounds = [[x0$2, y0$2], [x1, y1]];\n      x1 = y1 = -(y0$2 = x0$2 = Infinity);\n      return bounds;\n    }\n  };\n  function boundsPoint$1(x, y) {\n    if (x < x0$2) x0$2 = x;\n    if (x > x1) x1 = x;\n    if (y < y0$2) y0$2 = y;\n    if (y > y1) y1 = y;\n  }\n\n  var lengthSum$1 = adder();\n\n  function clip (pointVisible, clipLine, interpolate, start) {\n    return function (rotate, sink) {\n      var line = clipLine(sink),\n          rotatedStart = rotate.invert(start[0], start[1]),\n          ringBuffer = clipBuffer(),\n          ringSink = clipLine(ringBuffer),\n          polygonStarted = false,\n          polygon,\n          segments,\n          ring;\n      var clip = {\n        point: point,\n        lineStart: lineStart,\n        lineEnd: lineEnd,\n        polygonStart: function polygonStart() {\n          clip.point = pointRing;\n          clip.lineStart = ringStart;\n          clip.lineEnd = ringEnd;\n          segments = [];\n          polygon = [];\n        },\n        polygonEnd: function polygonEnd() {\n          clip.point = point;\n          clip.lineStart = lineStart;\n          clip.lineEnd = lineEnd;\n          segments = merge$1(segments);\n          var startInside = polygonContains(polygon, rotatedStart);\n          if (segments.length) {\n            if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n            clipPolygon(segments, compareIntersection, startInside, interpolate, sink);\n          } else if (startInside) {\n            if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n            sink.lineStart();\n            interpolate(null, null, 1, sink);\n            sink.lineEnd();\n          }\n          if (polygonStarted) sink.polygonEnd(), polygonStarted = false;\n          segments = polygon = null;\n        },\n        sphere: function sphere() {\n          sink.polygonStart();\n          sink.lineStart();\n          interpolate(null, null, 1, sink);\n          sink.lineEnd();\n          sink.polygonEnd();\n        }\n      };\n      function point(lambda, phi) {\n        var point = rotate(lambda, phi);\n        if (pointVisible(lambda = point[0], phi = point[1])) sink.point(lambda, phi);\n      }\n      function pointLine(lambda, phi) {\n        var point = rotate(lambda, phi);\n        line.point(point[0], point[1]);\n      }\n      function lineStart() {\n        clip.point = pointLine;\n        line.lineStart();\n      }\n      function lineEnd() {\n        clip.point = point;\n        line.lineEnd();\n      }\n      function pointRing(lambda, phi) {\n        ring.push([lambda, phi]);\n        var point = rotate(lambda, phi);\n        ringSink.point(point[0], point[1]);\n      }\n      function ringStart() {\n        ringSink.lineStart();\n        ring = [];\n      }\n      function ringEnd() {\n        pointRing(ring[0][0], ring[0][1]);\n        ringSink.lineEnd();\n        var clean = ringSink.clean(),\n            ringSegments = ringBuffer.result(),\n            i,\n            n = ringSegments.length,\n            m,\n            segment,\n            point;\n        ring.pop();\n        polygon.push(ring);\n        ring = null;\n        if (!n) return;\n        if (clean & 1) {\n          segment = ringSegments[0];\n          if ((m = segment.length - 1) > 0) {\n            if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n            sink.lineStart();\n            for (i = 0; i < m; ++i) {\n              sink.point((point = segment[i])[0], point[1]);\n            }sink.lineEnd();\n          }\n          return;\n        }\n        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n        segments.push(ringSegments.filter(validSegment));\n      }\n      return clip;\n    };\n  }\n  function validSegment(segment) {\n    return segment.length > 1;\n  }\n  function compareIntersection(a, b) {\n    return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);\n  }\n\n  var clipAntimeridian = clip(function () {\n    return true;\n  }, clipAntimeridianLine, clipAntimeridianInterpolate, [-pi, -halfPi]);\n  function clipAntimeridianLine(stream) {\n    var lambda0 = NaN,\n        phi0 = NaN,\n        sign0 = NaN,\n        _clean;\n    return {\n      lineStart: function lineStart() {\n        stream.lineStart();\n        _clean = 1;\n      },\n      point: function point(lambda1, phi1) {\n        var sign1 = lambda1 > 0 ? pi : -pi,\n            delta = abs(lambda1 - lambda0);\n        if (abs(delta - pi) < epsilon) {\n          stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);\n          stream.point(sign0, phi0);\n          stream.lineEnd();\n          stream.lineStart();\n          stream.point(sign1, phi0);\n          stream.point(lambda1, phi0);\n          _clean = 0;\n        } else if (sign0 !== sign1 && delta >= pi) {\n          if (abs(lambda0 - sign0) < epsilon) lambda0 -= sign0 * epsilon;\n          if (abs(lambda1 - sign1) < epsilon) lambda1 -= sign1 * epsilon;\n          phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);\n          stream.point(sign0, phi0);\n          stream.lineEnd();\n          stream.lineStart();\n          stream.point(sign1, phi0);\n          _clean = 0;\n        }\n        stream.point(lambda0 = lambda1, phi0 = phi1);\n        sign0 = sign1;\n      },\n      lineEnd: function lineEnd() {\n        stream.lineEnd();\n        lambda0 = phi0 = NaN;\n      },\n      clean: function clean() {\n        return 2 - _clean;\n      }\n    };\n  }\n  function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {\n    var cosPhi0,\n        cosPhi1,\n        sinLambda0Lambda1 = sin(lambda0 - lambda1);\n    return abs(sinLambda0Lambda1) > epsilon ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1) - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;\n  }\n  function clipAntimeridianInterpolate(from, to, direction, stream) {\n    var phi;\n    if (from == null) {\n      phi = direction * halfPi;\n      stream.point(-pi, phi);\n      stream.point(0, phi);\n      stream.point(pi, phi);\n      stream.point(pi, 0);\n      stream.point(pi, -phi);\n      stream.point(0, -phi);\n      stream.point(-pi, -phi);\n      stream.point(-pi, 0);\n      stream.point(-pi, phi);\n    } else if (abs(from[0] - to[0]) > epsilon) {\n      var lambda = from[0] < to[0] ? pi : -pi;\n      phi = direction * lambda / 2;\n      stream.point(-lambda, phi);\n      stream.point(0, phi);\n      stream.point(lambda, phi);\n    } else {\n      stream.point(to[0], to[1]);\n    }\n  }\n\n  function clipCircle (radius, delta) {\n    var cr = cos(radius),\n        smallRadius = cr > 0,\n        notHemisphere = abs(cr) > epsilon;\n    function interpolate(from, to, direction, stream) {\n      circleStream(stream, radius, delta, direction, from, to);\n    }\n    function visible(lambda, phi) {\n      return cos(lambda) * cos(phi) > cr;\n    }\n    function clipLine(stream) {\n      var point0,\n      c0,\n      v0,\n      v00,\n      _clean;\n      return {\n        lineStart: function lineStart() {\n          v00 = v0 = false;\n          _clean = 1;\n        },\n        point: function point(lambda, phi) {\n          var point1 = [lambda, phi],\n              point2,\n              v = visible(lambda, phi),\n              c = smallRadius ? v ? 0 : code(lambda, phi) : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;\n          if (!point0 && (v00 = v0 = v)) stream.lineStart();\n          if (v !== v0) {\n            point2 = intersect(point0, point1);\n            if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {\n              point1[0] += epsilon;\n              point1[1] += epsilon;\n              v = visible(point1[0], point1[1]);\n            }\n          }\n          if (v !== v0) {\n            _clean = 0;\n            if (v) {\n              stream.lineStart();\n              point2 = intersect(point1, point0);\n              stream.point(point2[0], point2[1]);\n            } else {\n              point2 = intersect(point0, point1);\n              stream.point(point2[0], point2[1]);\n              stream.lineEnd();\n            }\n            point0 = point2;\n          } else if (notHemisphere && point0 && smallRadius ^ v) {\n            var t;\n            if (!(c & c0) && (t = intersect(point1, point0, true))) {\n              _clean = 0;\n              if (smallRadius) {\n                stream.lineStart();\n                stream.point(t[0][0], t[0][1]);\n                stream.point(t[1][0], t[1][1]);\n                stream.lineEnd();\n              } else {\n                stream.point(t[1][0], t[1][1]);\n                stream.lineEnd();\n                stream.lineStart();\n                stream.point(t[0][0], t[0][1]);\n              }\n            }\n          }\n          if (v && (!point0 || !pointEqual(point0, point1))) {\n            stream.point(point1[0], point1[1]);\n          }\n          point0 = point1, v0 = v, c0 = c;\n        },\n        lineEnd: function lineEnd() {\n          if (v0) stream.lineEnd();\n          point0 = null;\n        },\n        clean: function clean() {\n          return _clean | (v00 && v0) << 1;\n        }\n      };\n    }\n    function intersect(a, b, two) {\n      var pa = cartesian(a),\n          pb = cartesian(b);\n      var n1 = [1, 0, 0],\n      n2 = cartesianCross(pa, pb),\n          n2n2 = cartesianDot(n2, n2),\n          n1n2 = n2[0],\n      determinant = n2n2 - n1n2 * n1n2;\n      if (!determinant) return !two && a;\n      var c1 = cr * n2n2 / determinant,\n          c2 = -cr * n1n2 / determinant,\n          n1xn2 = cartesianCross(n1, n2),\n          A = cartesianScale(n1, c1),\n          B = cartesianScale(n2, c2);\n      cartesianAddInPlace(A, B);\n      var u = n1xn2,\n          w = cartesianDot(A, u),\n          uu = cartesianDot(u, u),\n          t2 = w * w - uu * (cartesianDot(A, A) - 1);\n      if (t2 < 0) return;\n      var t = sqrt(t2),\n          q = cartesianScale(u, (-w - t) / uu);\n      cartesianAddInPlace(q, A);\n      q = spherical(q);\n      if (!two) return q;\n      var lambda0 = a[0],\n          lambda1 = b[0],\n          phi0 = a[1],\n          phi1 = b[1],\n          z;\n      if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;\n      var delta = lambda1 - lambda0,\n          polar = abs(delta - pi) < epsilon,\n          meridian = polar || delta < epsilon;\n      if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;\n      if (meridian ? polar ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {\n        var q1 = cartesianScale(u, (-w + t) / uu);\n        cartesianAddInPlace(q1, A);\n        return [q, spherical(q1)];\n      }\n    }\n    function code(lambda, phi) {\n      var r = smallRadius ? radius : pi - radius,\n          code = 0;\n      if (lambda < -r) code |= 1;\n      else if (lambda > r) code |= 2;\n      if (phi < -r) code |= 4;\n      else if (phi > r) code |= 8;\n      return code;\n    }\n    return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);\n  }\n\n  function transformer(methods) {\n    return function (stream) {\n      var s = new TransformStream();\n      for (var key in methods) {\n        s[key] = methods[key];\n      }s.stream = stream;\n      return s;\n    };\n  }\n  function TransformStream() {}\n  TransformStream.prototype = {\n    constructor: TransformStream,\n    point: function point(x, y) {\n      this.stream.point(x, y);\n    },\n    sphere: function sphere() {\n      this.stream.sphere();\n    },\n    lineStart: function lineStart() {\n      this.stream.lineStart();\n    },\n    lineEnd: function lineEnd() {\n      this.stream.lineEnd();\n    },\n    polygonStart: function polygonStart() {\n      this.stream.polygonStart();\n    },\n    polygonEnd: function polygonEnd() {\n      this.stream.polygonEnd();\n    }\n  };\n\n  function fitExtent(projection, extent, object) {\n      var w = extent[1][0] - extent[0][0],\n          h = extent[1][1] - extent[0][1],\n          clip = projection.clipExtent && projection.clipExtent();\n      projection.scale(150).translate([0, 0]);\n      if (clip != null) projection.clipExtent(null);\n      geoStream(object, projection.stream(boundsStream$1));\n      var b = boundsStream$1.result(),\n          k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),\n          x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,\n          y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;\n      if (clip != null) projection.clipExtent(clip);\n      return projection.scale(k * 150).translate([x, y]);\n  }\n  function fitSize(projection, size, object) {\n      return fitExtent(projection, [[0, 0], size], object);\n  }\n\n  var maxDepth = 16,\n  cosMinDistance = cos(30 * radians);\n  function resample (project, delta2) {\n    return +delta2 ? resample$1(project, delta2) : resampleNone(project);\n  }\n  function resampleNone(project) {\n    return transformer({\n      point: function point(x, y) {\n        x = project(x, y);\n        this.stream.point(x[0], x[1]);\n      }\n    });\n  }\n  function resample$1(project, delta2) {\n    function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {\n      var dx = x1 - x0,\n          dy = y1 - y0,\n          d2 = dx * dx + dy * dy;\n      if (d2 > 4 * delta2 && depth--) {\n        var a = a0 + a1,\n            b = b0 + b1,\n            c = c0 + c1,\n            m = sqrt(a * a + b * b + c * c),\n            phi2 = asin(c /= m),\n            lambda2 = abs(abs(c) - 1) < epsilon || abs(lambda0 - lambda1) < epsilon ? (lambda0 + lambda1) / 2 : atan2(b, a),\n            p = project(lambda2, phi2),\n            x2 = p[0],\n            y2 = p[1],\n            dx2 = x2 - x0,\n            dy2 = y2 - y0,\n            dz = dy * dx2 - dx * dy2;\n        if (dz * dz / d2 > delta2\n        || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3\n        || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {\n          resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);\n          stream.point(x2, y2);\n          resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);\n        }\n      }\n    }\n    return function (stream) {\n      var lambda00, x00, y00, a00, b00, c00,\n      lambda0, x0, y0, a0, b0, c0;\n      var resampleStream = {\n        point: point,\n        lineStart: lineStart,\n        lineEnd: lineEnd,\n        polygonStart: function polygonStart() {\n          stream.polygonStart();resampleStream.lineStart = ringStart;\n        },\n        polygonEnd: function polygonEnd() {\n          stream.polygonEnd();resampleStream.lineStart = lineStart;\n        }\n      };\n      function point(x, y) {\n        x = project(x, y);\n        stream.point(x[0], x[1]);\n      }\n      function lineStart() {\n        x0 = NaN;\n        resampleStream.point = linePoint;\n        stream.lineStart();\n      }\n      function linePoint(lambda, phi) {\n        var c = cartesian([lambda, phi]),\n            p = project(lambda, phi);\n        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);\n        stream.point(x0, y0);\n      }\n      function lineEnd() {\n        resampleStream.point = point;\n        stream.lineEnd();\n      }\n      function ringStart() {\n        lineStart();\n        resampleStream.point = ringPoint;\n        resampleStream.lineEnd = ringEnd;\n      }\n      function ringPoint(lambda, phi) {\n        linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;\n        resampleStream.point = linePoint;\n      }\n      function ringEnd() {\n        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);\n        resampleStream.lineEnd = lineEnd;\n        lineEnd();\n      }\n      return resampleStream;\n    };\n  }\n\n  var transformRadians = transformer({\n    point: function point(x, y) {\n      this.stream.point(x * radians, y * radians);\n    }\n  });\n  function projection(project) {\n    return projectionMutator(function () {\n      return project;\n    })();\n  }\n  function projectionMutator(projectAt) {\n    var project,\n        k = 150,\n    x = 480,\n        y = 250,\n    dx,\n        dy,\n        lambda = 0,\n        phi = 0,\n    deltaLambda = 0,\n        deltaPhi = 0,\n        deltaGamma = 0,\n        rotate,\n        projectRotate,\n    theta = null,\n        preclip = clipAntimeridian,\n    x0 = null,\n        y0,\n        x1,\n        y1,\n        postclip = identity$3,\n    delta2 = 0.5,\n        projectResample = resample(projectTransform, delta2),\n    cache,\n        cacheStream;\n    function projection(point) {\n      point = projectRotate(point[0] * radians, point[1] * radians);\n      return [point[0] * k + dx, dy - point[1] * k];\n    }\n    function invert(point) {\n      point = projectRotate.invert((point[0] - dx) / k, (dy - point[1]) / k);\n      return point && [point[0] * degrees, point[1] * degrees];\n    }\n    function projectTransform(x, y) {\n      return x = project(x, y), [x[0] * k + dx, dy - x[1] * k];\n    }\n    projection.stream = function (stream) {\n      return cache && cacheStream === stream ? cache : cache = transformRadians(preclip(rotate, projectResample(postclip(cacheStream = stream))));\n    };\n    projection.clipAngle = function (_) {\n      return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians, 6 * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;\n    };\n    projection.clipExtent = function (_) {\n      return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$3) : clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n    };\n    projection.scale = function (_) {\n      return arguments.length ? (k = +_, recenter()) : k;\n    };\n    projection.translate = function (_) {\n      return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];\n    };\n    projection.center = function (_) {\n      return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];\n    };\n    projection.rotate = function (_) {\n      return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];\n    };\n    projection.precision = function (_) {\n      return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);\n    };\n    projection.fitExtent = function (extent, object) {\n      return fitExtent(projection, extent, object);\n    };\n    projection.fitSize = function (size, object) {\n      return fitSize(projection, size, object);\n    };\n    function recenter() {\n      projectRotate = compose(rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma), project);\n      var center = project(lambda, phi);\n      dx = x - center[0] * k;\n      dy = y + center[1] * k;\n      return reset();\n    }\n    function reset() {\n      cache = cacheStream = null;\n      return projection;\n    }\n    return function () {\n      project = projectAt.apply(this, arguments);\n      projection.invert = project.invert && invert;\n      return recenter();\n    };\n  }\n\n  function mercatorRaw(lambda, phi) {\n    return [lambda, log(tan((halfPi + phi) / 2))];\n  }\n  mercatorRaw.invert = function (x, y) {\n    return [x, 2 * atan(exp(y)) - halfPi];\n  };\n  function mercatorProjection(project) {\n    var m = projection(project),\n        center = m.center,\n        scale = m.scale,\n        translate = m.translate,\n        clipExtent = m.clipExtent,\n        x0 = null,\n        y0,\n        x1,\n        y1;\n    m.scale = function (_) {\n      return arguments.length ? (scale(_), reclip()) : scale();\n    };\n    m.translate = function (_) {\n      return arguments.length ? (translate(_), reclip()) : translate();\n    };\n    m.center = function (_) {\n      return arguments.length ? (center(_), reclip()) : center();\n    };\n    m.clipExtent = function (_) {\n      return arguments.length ? (_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n    };\n    function reclip() {\n      var k = pi * scale(),\n          t = m(rotation(m.rotate()).invert([0, 0]));\n      return clipExtent(x0 == null ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]] : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);\n    }\n    return reclip();\n  }\n\n  function transverseMercatorRaw(lambda, phi) {\n    return [log(tan((halfPi + phi) / 2)), -lambda];\n  }\n  transverseMercatorRaw.invert = function (x, y) {\n    return [-y, 2 * atan(exp(x)) - halfPi];\n  };\n  function geoTransverseMercator () {\n    var m = mercatorProjection(transverseMercatorRaw),\n        center = m.center,\n        rotate = m.rotate;\n    m.center = function (_) {\n      return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);\n    };\n    m.rotate = function (_) {\n      return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);\n    };\n    return rotate([0, 0, 90]).scale(159.155);\n  }\n\n  function buffer$1(geojson, radius, options) {\n      options = options || {};\n      var units = options.units;\n      var steps = options.steps || 64;\n      if (!geojson) throw new Error('geojson is required');\n      if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object') throw new Error('options must be an object');\n      if (typeof steps !== 'number') throw new Error('steps must be an number');\n      if (radius === undefined) throw new Error('radius is required');\n      if (steps <= 0) throw new Error('steps must be greater than 0');\n      steps = steps || 64;\n      units = units || 'kilometers';\n      var results = [];\n      switch (geojson.type) {\n          case 'GeometryCollection':\n              geomEach$1(geojson, function (geometry) {\n                  var buffered = bufferFeature(geometry, radius, units, steps);\n                  if (buffered) results.push(buffered);\n              });\n              return featureCollection$1(results);\n          case 'FeatureCollection':\n              featureEach$1(geojson, function (feature) {\n                  var multiBuffered = bufferFeature(feature, radius, units, steps);\n                  if (multiBuffered) {\n                      featureEach$1(multiBuffered, function (buffered) {\n                          if (buffered) results.push(buffered);\n                      });\n                  }\n              });\n              return featureCollection$1(results);\n      }\n      return bufferFeature(geojson, radius, units, steps);\n  }\n  function bufferFeature(geojson, radius, units, steps) {\n      var properties = geojson.properties || {};\n      var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson;\n      if (geometry.type === 'GeometryCollection') {\n          var results = [];\n          geomEach$1(geojson, function (geometry) {\n              var buffered = bufferFeature(geometry, radius, units, steps);\n              if (buffered) results.push(buffered);\n          });\n          return featureCollection$1(results);\n      }\n      var projected;\n      var bbox = bbox$1(geojson);\n      var needsTransverseMercator = bbox[1] > 50 && bbox[3] > 50;\n      if (needsTransverseMercator) {\n          projected = {\n              type: geometry.type,\n              coordinates: projectCoords(geometry.coordinates, defineProjection(geometry))\n          };\n      } else {\n          projected = toMercator(geometry);\n      }\n      var reader = new GeoJSONReader();\n      var geom = reader.read(projected);\n      var distance = radiansToLength$1(lengthToRadians$1(radius, units), 'meters');\n      var buffered = BufferOp.bufferOp(geom, distance);\n      var writer = new GeoJSONWriter();\n      buffered = writer.write(buffered);\n      if (coordsIsNaN(buffered.coordinates)) return undefined;\n      var result;\n      if (needsTransverseMercator) {\n          result = {\n              type: buffered.type,\n              coordinates: unprojectCoords(buffered.coordinates, defineProjection(geometry))\n          };\n      } else {\n          result = toWgs84(buffered);\n      }\n      return result.geometry ? result : feature$1(result, properties);\n  }\n  function coordsIsNaN(coords) {\n      if (Array.isArray(coords[0])) return coordsIsNaN(coords[0]);\n      return isNaN(coords[0]);\n  }\n  function projectCoords(coords, proj) {\n      if (_typeof(coords[0]) !== 'object') return proj(coords);\n      return coords.map(function (coord) {\n          return projectCoords(coord, proj);\n      });\n  }\n  function unprojectCoords(coords, proj) {\n      if (_typeof(coords[0]) !== 'object') return proj.invert(coords);\n      return coords.map(function (coord) {\n          return unprojectCoords(coord, proj);\n      });\n  }\n  function defineProjection(geojson) {\n      var coords = center(geojson).geometry.coordinates.reverse();\n      var rotate = coords.map(function (coord) {\n          return -coord;\n      });\n      return geoTransverseMercator().center(coords).rotate(rotate).scale(earthRadius$1);\n  }\n\n  function createbuffer(object, output, distance, units, comment, steps) {\n      units = units || 'meters';\n      output = (output || 'feature').toLowerCase();\n      var Feature;\n      if (object instanceof google.maps.Polyline || object instanceof google.maps.Polygon || object instanceof google.maps.Marker || object instanceof google.maps.LatLng) {\n          var geometry = Wicket$1().fromObject(object).toJson();\n          Feature = {\n              type: \"Feature\",\n              properties: {},\n              geometry: geometry\n          };\n      } else if (object.type && object.type === 'Feature' && object.geometry) {\n          Feature = object;\n      } else {\n          Feature = polygonToFeaturePolygon(object);\n      }\n      var buffered = buffer$1(Feature, distance, {\n          units: units,\n          steps: steps\n      });\n      if (buffered.type === 'FeatureCollection') {\n          buffered = buffered.features[0];\n      }\n      if (output === 'geometry') {\n          return buffered.geometry;\n      } else if (output === 'object') {\n          return Wicket$1().fromJson(buffered.geometry).toObject();\n      } else {\n          return buffered;\n      }\n  }\n\n  function booleanPointInPolygon(point, polygon, options) {\n      options = options || {};\n      if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object') throw new Error('options is invalid');\n      var ignoreBoundary = options.ignoreBoundary;\n      if (!point) throw new Error('point is required');\n      if (!polygon) throw new Error('polygon is required');\n      var pt = getCoord(point);\n      var polys = getCoords(polygon);\n      var type = polygon.geometry ? polygon.geometry.type : polygon.type;\n      var bbox = polygon.bbox;\n      if (bbox && inBBox(pt, bbox) === false) return false;\n      if (type === 'Polygon') polys = [polys];\n      for (var i = 0, insidePoly = false; i < polys.length && !insidePoly; i++) {\n          if (inRing(pt, polys[i][0], ignoreBoundary)) {\n              var inHole = false;\n              var k = 1;\n              while (k < polys[i].length && !inHole) {\n                  if (inRing(pt, polys[i][k], !ignoreBoundary)) {\n                      inHole = true;\n                  }\n                  k++;\n              }\n              if (!inHole) insidePoly = true;\n          }\n      }\n      return insidePoly;\n  }\n  function inRing(pt, ring, ignoreBoundary) {\n      var isInside = false;\n      if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) ring = ring.slice(0, ring.length - 1);\n      for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n          var xi = ring[i][0],\n              yi = ring[i][1];\n          var xj = ring[j][0],\n              yj = ring[j][1];\n          var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 && (xi - pt[0]) * (xj - pt[0]) <= 0 && (yi - pt[1]) * (yj - pt[1]) <= 0;\n          if (onBoundary) return !ignoreBoundary;\n          var intersect = yi > pt[1] !== yj > pt[1] && pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi;\n          if (intersect) isInside = !isInside;\n      }\n      return isInside;\n  }\n  function inBBox(pt, bbox) {\n      return bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1];\n  }\n\n  function pointInPolygon(sourceArray, geojsonPolygon) {\n  \tvar pointsInside = [];\n  \tvar pointsOutside = [];\n  \tif (geojsonPolygon.type !== 'Feature') {\n  \t\tgeojsonPolygon = {\n  \t\t\t\"type\": \"Feature\",\n  \t\t\t\"properties\": {},\n  \t\t\t\"geometry\": geojsonPolygon\n  \t\t};\n  \t}\n  \tif (geojsonPolygon.geometry.type === 'Polygon' || geojsonPolygon.geometry.type === 'Multipolygon') {\n  \t\tforEach(sourceArray, function (item) {\n  \t\t\tvar Point = markerToFeaturePoint(item);\n  \t\t\tif (booleanPointInPolygon(Point, geojsonPolygon)) {\n  \t\t\t\tpointsInside.push(item);\n  \t\t\t} else {\n  \t\t\t\tpointsOutside.push(item);\n  \t\t\t}\n  \t\t});\n  \t}\n  \treturn {\n  \t\tpointsInside: pointsInside,\n  \t\tpointsOutside: pointsOutside\n  \t};\n  }\n\n  function kinks(featureIn) {\n      var coordinates;\n      var feature;\n      var results = {\n          type: 'FeatureCollection',\n          features: []\n      };\n      if (featureIn.type === 'Feature') {\n          feature = featureIn.geometry;\n      } else {\n          feature = featureIn;\n      }\n      if (feature.type === 'LineString') {\n          coordinates = [feature.coordinates];\n      } else if (feature.type === 'MultiLineString') {\n          coordinates = feature.coordinates;\n      } else if (feature.type === 'MultiPolygon') {\n          coordinates = [].concat.apply([], feature.coordinates);\n      } else if (feature.type === 'Polygon') {\n          coordinates = feature.coordinates;\n      } else {\n          throw new Error('Input must be a LineString, MultiLineString, ' + 'Polygon, or MultiPolygon Feature or Geometry');\n      }\n      coordinates.forEach(function (line1) {\n          coordinates.forEach(function (line2) {\n              for (var i = 0; i < line1.length - 1; i++) {\n                  for (var k = i; k < line2.length - 1; k++) {\n                      if (line1 === line2) {\n                          if (Math.abs(i - k) === 1) {\n                              continue;\n                          }\n                          if (\n                          i === 0 && k === line1.length - 2 &&\n                          line1[i][0] === line1[line1.length - 1][0] && line1[i][1] === line1[line1.length - 1][1]) {\n                              continue;\n                          }\n                      }\n                      var intersection = lineIntersects(line1[i][0], line1[i][1], line1[i + 1][0], line1[i + 1][1], line2[k][0], line2[k][1], line2[k + 1][0], line2[k + 1][1]);\n                      if (intersection) {\n                          results.features.push(point$1([intersection[0], intersection[1]]));\n                      }\n                  }\n              }\n          });\n      });\n      return results;\n  }\n  function lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {\n      var denominator,\n          a,\n          b,\n          numerator1,\n          numerator2,\n          result = {\n          x: null,\n          y: null,\n          onLine1: false,\n          onLine2: false\n      };\n      denominator = (line2EndY - line2StartY) * (line1EndX - line1StartX) - (line2EndX - line2StartX) * (line1EndY - line1StartY);\n      if (denominator === 0) {\n          if (result.x !== null && result.y !== null) {\n              return result;\n          } else {\n              return false;\n          }\n      }\n      a = line1StartY - line2StartY;\n      b = line1StartX - line2StartX;\n      numerator1 = (line2EndX - line2StartX) * a - (line2EndY - line2StartY) * b;\n      numerator2 = (line1EndX - line1StartX) * a - (line1EndY - line1StartY) * b;\n      a = numerator1 / denominator;\n      b = numerator2 / denominator;\n      result.x = line1StartX + a * (line1EndX - line1StartX);\n      result.y = line1StartY + a * (line1EndY - line1StartY);\n      if (a >= 0 && a <= 1) {\n          result.onLine1 = true;\n      }\n      if (b >= 0 && b <= 1) {\n          result.onLine2 = true;\n      }\n      if (result.onLine1 && result.onLine2) {\n          return [result.x, result.y];\n      } else {\n          return false;\n      }\n  }\n\n  function kinks$1(object) {\n    var Feature;\n    if (object instanceof google.maps.Polyline || object instanceof google.maps.Polygon) {\n      var geometry = Wicket().fromObject(object).toJson();\n      Feature = {\n        type: \"Feature\",\n        properties: {},\n        geometry: geometry\n      };\n    } else if (object.type && object.type === 'Feature' && object.geometry) {\n      Feature = object;\n    } else {\n      Feature = polygonToFeaturePolygon(object);\n    }\n    return kinks(Feature);\n  }\n\n  function feature$6(geometry, properties, options) {\n      options = options || {};\n      if (!isObject$5(options)) throw new Error('options is invalid');\n      var bbox = options.bbox;\n      var id = options.id;\n      if (geometry === undefined) throw new Error('geometry is required');\n      if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n      if (bbox) validateBBox$3(bbox);\n      if (id) validateId$3(id);\n      var feat = { type: 'Feature' };\n      if (id) feat.id = id;\n      if (bbox) feat.bbox = bbox;\n      feat.properties = properties || {};\n      feat.geometry = geometry;\n      return feat;\n  }\n  function polygon$4(coordinates, properties, options) {\n      if (!coordinates) throw new Error('coordinates is required');\n      for (var i = 0; i < coordinates.length; i++) {\n          var ring = coordinates[i];\n          if (ring.length < 4) {\n              throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n          }\n          for (var j = 0; j < ring[ring.length - 1].length; j++) {\n              if (i === 0 && j === 0 && !isNumber$4(ring[0][0]) || !isNumber$4(ring[0][1])) throw new Error('coordinates must contain numbers');\n              if (ring[ring.length - 1][j] !== ring[0][j]) {\n                  throw new Error('First and last Position are not equivalent.');\n              }\n          }\n      }\n      return feature$6({\n          type: 'Polygon',\n          coordinates: coordinates\n      }, properties, options);\n  }\n  function featureCollection$4(features, options) {\n      options = options || {};\n      if (!isObject$5(options)) throw new Error('options is invalid');\n      var bbox = options.bbox;\n      var id = options.id;\n      if (!features) throw new Error('No features passed');\n      if (!Array.isArray(features)) throw new Error('features must be an Array');\n      if (bbox) validateBBox$3(bbox);\n      if (id) validateId$3(id);\n      var fc = { type: 'FeatureCollection' };\n      if (id) fc.id = id;\n      if (bbox) fc.bbox = bbox;\n      fc.features = features;\n      return fc;\n  }\n  function isNumber$4(num) {\n      return !isNaN(num) && num !== null && !Array.isArray(num);\n  }\n  function isObject$5(input) {\n      return !!input && input.constructor === Object;\n  }\n  function validateBBox$3(bbox) {\n      if (!bbox) throw new Error('bbox is required');\n      if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n      if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n      bbox.forEach(function (num) {\n          if (!isNumber$4(num)) throw new Error('bbox must only contain numbers');\n      });\n  }\n  function validateId$3(id) {\n      if (!id) throw new Error('id is required');\n      if (['string', 'number'].indexOf(typeof id === 'undefined' ? 'undefined' : _typeof(id)) === -1) throw new Error('id must be a number or a string');\n  }\n\n  function featureEach$3(geojson, callback) {\n      if (geojson.type === 'Feature') {\n          callback(geojson, 0);\n      } else if (geojson.type === 'FeatureCollection') {\n          for (var i = 0; i < geojson.features.length; i++) {\n              if (callback(geojson.features[i], i) === false) break;\n          }\n      }\n  }\n  function geomEach$3(geojson, callback) {\n      var i,\n          j,\n          g,\n          geometry,\n          stopG,\n          geometryMaybeCollection,\n          isGeometryCollection,\n          featureProperties,\n          featureBBox,\n          featureId,\n          featureIndex = 0,\n          isFeatureCollection = geojson.type === 'FeatureCollection',\n          isFeature = geojson.type === 'Feature',\n          stop = isFeatureCollection ? geojson.features.length : 1;\n      for (i = 0; i < stop; i++) {\n          geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;\n          featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};\n          featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : undefined;\n          featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : undefined;\n          isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n          stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n          for (g = 0; g < stopG; g++) {\n              geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n              if (geometry === null) {\n                  if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                  continue;\n              }\n              switch (geometry.type) {\n                  case 'Point':\n                  case 'LineString':\n                  case 'MultiPoint':\n                  case 'Polygon':\n                  case 'MultiLineString':\n                  case 'MultiPolygon':\n                      {\n                          if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                          break;\n                      }\n                  case 'GeometryCollection':\n                      {\n                          for (j = 0; j < geometry.geometries.length; j++) {\n                              if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                          }\n                          break;\n                      }\n                  default:\n                      throw new Error('Unknown Geometry Type');\n              }\n          }\n          featureIndex++;\n      }\n  }\n  function flattenEach$3(geojson, callback) {\n      geomEach$3(geojson, function (geometry, featureIndex, properties, bbox, id) {\n          var type = geometry === null ? null : geometry.type;\n          switch (type) {\n              case null:\n              case 'Point':\n              case 'LineString':\n              case 'Polygon':\n                  if (callback(feature$6(geometry, properties, { bbox: bbox, id: id }), featureIndex, 0) === false) return false;\n                  return;\n          }\n          var geomType;\n          switch (type) {\n              case 'MultiPoint':\n                  geomType = 'Point';\n                  break;\n              case 'MultiLineString':\n                  geomType = 'LineString';\n                  break;\n              case 'MultiPolygon':\n                  geomType = 'Polygon';\n                  break;\n          }\n          for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n              var coordinate = geometry.coordinates[multiFeatureIndex];\n              var geom = {\n                  type: geomType,\n                  coordinates: coordinate\n              };\n              if (callback(feature$6(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n          }\n      });\n  }\n\n  var quickselect = partialSort;\n  function partialSort(arr, k, left, right, compare) {\n      left = left || 0;\n      right = right || arr.length - 1;\n      compare = compare || defaultCompare;\n      while (right > left) {\n          if (right - left > 600) {\n              var n = right - left + 1;\n              var m = k - left + 1;\n              var z = Math.log(n);\n              var s = 0.5 * Math.exp(2 * z / 3);\n              var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n              var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n              var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n              partialSort(arr, k, newLeft, newRight, compare);\n          }\n          var t = arr[k];\n          var i = left;\n          var j = right;\n          swap(arr, left, k);\n          if (compare(arr[right], t) > 0) swap(arr, left, right);\n          while (i < j) {\n              swap(arr, i, j);\n              i++;\n              j--;\n              while (compare(arr[i], t) < 0) {\n                  i++;\n              }while (compare(arr[j], t) > 0) {\n                  j--;\n              }\n          }\n          if (compare(arr[left], t) === 0) swap(arr, left, j);else {\n              j++;\n              swap(arr, j, right);\n          }\n          if (j <= k) left = j + 1;\n          if (k <= j) right = j - 1;\n      }\n  }\n  function swap(arr, i, j) {\n      var tmp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = tmp;\n  }\n  function defaultCompare(a, b) {\n      return a < b ? -1 : a > b ? 1 : 0;\n  }\n\n  var quickselect$1 = /*#__PURE__*/Object.freeze({\n    default: quickselect,\n    __moduleExports: quickselect\n  });\n\n  var quickselect$2 = ( quickselect$1 && quickselect ) || quickselect$1;\n\n  var rbush_1 = rbush;\n  function rbush(maxEntries, format) {\n      if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n      this._maxEntries = Math.max(4, maxEntries || 9);\n      this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n      if (format) {\n          this._initFormat(format);\n      }\n      this.clear();\n  }\n  rbush.prototype = {\n      all: function all() {\n          return this._all(this.data, []);\n      },\n      search: function search(bbox) {\n          var node = this.data,\n              result = [],\n              toBBox = this.toBBox;\n          if (!intersects(bbox, node)) return result;\n          var nodesToSearch = [],\n              i,\n              len,\n              child,\n              childBBox;\n          while (node) {\n              for (i = 0, len = node.children.length; i < len; i++) {\n                  child = node.children[i];\n                  childBBox = node.leaf ? toBBox(child) : child;\n                  if (intersects(bbox, childBBox)) {\n                      if (node.leaf) result.push(child);else if (contains$1(bbox, childBBox)) this._all(child, result);else nodesToSearch.push(child);\n                  }\n              }\n              node = nodesToSearch.pop();\n          }\n          return result;\n      },\n      collides: function collides(bbox) {\n          var node = this.data,\n              toBBox = this.toBBox;\n          if (!intersects(bbox, node)) return false;\n          var nodesToSearch = [],\n              i,\n              len,\n              child,\n              childBBox;\n          while (node) {\n              for (i = 0, len = node.children.length; i < len; i++) {\n                  child = node.children[i];\n                  childBBox = node.leaf ? toBBox(child) : child;\n                  if (intersects(bbox, childBBox)) {\n                      if (node.leaf || contains$1(bbox, childBBox)) return true;\n                      nodesToSearch.push(child);\n                  }\n              }\n              node = nodesToSearch.pop();\n          }\n          return false;\n      },\n      load: function load(data) {\n          if (!(data && data.length)) return this;\n          if (data.length < this._minEntries) {\n              for (var i = 0, len = data.length; i < len; i++) {\n                  this.insert(data[i]);\n              }\n              return this;\n          }\n          var node = this._build(data.slice(), 0, data.length - 1, 0);\n          if (!this.data.children.length) {\n              this.data = node;\n          } else if (this.data.height === node.height) {\n              this._splitRoot(this.data, node);\n          } else {\n              if (this.data.height < node.height) {\n                  var tmpNode = this.data;\n                  this.data = node;\n                  node = tmpNode;\n              }\n              this._insert(node, this.data.height - node.height - 1, true);\n          }\n          return this;\n      },\n      insert: function insert(item) {\n          if (item) this._insert(item, this.data.height - 1);\n          return this;\n      },\n      clear: function clear() {\n          this.data = createNode([]);\n          return this;\n      },\n      remove: function remove(item, equalsFn) {\n          if (!item) return this;\n          var node = this.data,\n              bbox = this.toBBox(item),\n              path = [],\n              indexes = [],\n              i,\n              parent,\n              index,\n              goingUp;\n          while (node || path.length) {\n              if (!node) {\n                  node = path.pop();\n                  parent = path[path.length - 1];\n                  i = indexes.pop();\n                  goingUp = true;\n              }\n              if (node.leaf) {\n                  index = findItem(item, node.children, equalsFn);\n                  if (index !== -1) {\n                      node.children.splice(index, 1);\n                      path.push(node);\n                      this._condense(path);\n                      return this;\n                  }\n              }\n              if (!goingUp && !node.leaf && contains$1(node, bbox)) {\n                  path.push(node);\n                  indexes.push(i);\n                  i = 0;\n                  parent = node;\n                  node = node.children[0];\n              } else if (parent) {\n                  i++;\n                  node = parent.children[i];\n                  goingUp = false;\n              } else node = null;\n          }\n          return this;\n      },\n      toBBox: function toBBox(item) {\n          return item;\n      },\n      compareMinX: compareNodeMinX,\n      compareMinY: compareNodeMinY,\n      toJSON: function toJSON() {\n          return this.data;\n      },\n      fromJSON: function fromJSON(data) {\n          this.data = data;\n          return this;\n      },\n      _all: function _all(node, result) {\n          var nodesToSearch = [];\n          while (node) {\n              if (node.leaf) result.push.apply(result, node.children);else nodesToSearch.push.apply(nodesToSearch, node.children);\n              node = nodesToSearch.pop();\n          }\n          return result;\n      },\n      _build: function _build(items, left, right, height) {\n          var N = right - left + 1,\n              M = this._maxEntries,\n              node;\n          if (N <= M) {\n              node = createNode(items.slice(left, right + 1));\n              calcBBox(node, this.toBBox);\n              return node;\n          }\n          if (!height) {\n              height = Math.ceil(Math.log(N) / Math.log(M));\n              M = Math.ceil(N / Math.pow(M, height - 1));\n          }\n          node = createNode([]);\n          node.leaf = false;\n          node.height = height;\n          var N2 = Math.ceil(N / M),\n              N1 = N2 * Math.ceil(Math.sqrt(M)),\n              i,\n              j,\n              right2,\n              right3;\n          multiSelect(items, left, right, N1, this.compareMinX);\n          for (i = left; i <= right; i += N1) {\n              right2 = Math.min(i + N1 - 1, right);\n              multiSelect(items, i, right2, N2, this.compareMinY);\n              for (j = i; j <= right2; j += N2) {\n                  right3 = Math.min(j + N2 - 1, right2);\n                  node.children.push(this._build(items, j, right3, height - 1));\n              }\n          }\n          calcBBox(node, this.toBBox);\n          return node;\n      },\n      _chooseSubtree: function _chooseSubtree(bbox, node, level, path) {\n          var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n          while (true) {\n              path.push(node);\n              if (node.leaf || path.length - 1 === level) break;\n              minArea = minEnlargement = Infinity;\n              for (i = 0, len = node.children.length; i < len; i++) {\n                  child = node.children[i];\n                  area = bboxArea(child);\n                  enlargement = enlargedArea(bbox, child) - area;\n                  if (enlargement < minEnlargement) {\n                      minEnlargement = enlargement;\n                      minArea = area < minArea ? area : minArea;\n                      targetNode = child;\n                  } else if (enlargement === minEnlargement) {\n                      if (area < minArea) {\n                          minArea = area;\n                          targetNode = child;\n                      }\n                  }\n              }\n              node = targetNode || node.children[0];\n          }\n          return node;\n      },\n      _insert: function _insert(item, level, isNode) {\n          var toBBox = this.toBBox,\n              bbox = isNode ? item : toBBox(item),\n              insertPath = [];\n          var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n          node.children.push(item);\n          extend$1(node, bbox);\n          while (level >= 0) {\n              if (insertPath[level].children.length > this._maxEntries) {\n                  this._split(insertPath, level);\n                  level--;\n              } else break;\n          }\n          this._adjustParentBBoxes(bbox, insertPath, level);\n      },\n      _split: function _split(insertPath, level) {\n          var node = insertPath[level],\n              M = node.children.length,\n              m = this._minEntries;\n          this._chooseSplitAxis(node, m, M);\n          var splitIndex = this._chooseSplitIndex(node, m, M);\n          var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n          newNode.height = node.height;\n          newNode.leaf = node.leaf;\n          calcBBox(node, this.toBBox);\n          calcBBox(newNode, this.toBBox);\n          if (level) insertPath[level - 1].children.push(newNode);else this._splitRoot(node, newNode);\n      },\n      _splitRoot: function _splitRoot(node, newNode) {\n          this.data = createNode([node, newNode]);\n          this.data.height = node.height + 1;\n          this.data.leaf = false;\n          calcBBox(this.data, this.toBBox);\n      },\n      _chooseSplitIndex: function _chooseSplitIndex(node, m, M) {\n          var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n          minOverlap = minArea = Infinity;\n          for (i = m; i <= M - m; i++) {\n              bbox1 = distBBox(node, 0, i, this.toBBox);\n              bbox2 = distBBox(node, i, M, this.toBBox);\n              overlap = intersectionArea(bbox1, bbox2);\n              area = bboxArea(bbox1) + bboxArea(bbox2);\n              if (overlap < minOverlap) {\n                  minOverlap = overlap;\n                  index = i;\n                  minArea = area < minArea ? area : minArea;\n              } else if (overlap === minOverlap) {\n                  if (area < minArea) {\n                      minArea = area;\n                      index = i;\n                  }\n              }\n          }\n          return index;\n      },\n      _chooseSplitAxis: function _chooseSplitAxis(node, m, M) {\n          var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n              compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n              xMargin = this._allDistMargin(node, m, M, compareMinX),\n              yMargin = this._allDistMargin(node, m, M, compareMinY);\n          if (xMargin < yMargin) node.children.sort(compareMinX);\n      },\n      _allDistMargin: function _allDistMargin(node, m, M, compare) {\n          node.children.sort(compare);\n          var toBBox = this.toBBox,\n              leftBBox = distBBox(node, 0, m, toBBox),\n              rightBBox = distBBox(node, M - m, M, toBBox),\n              margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n              i,\n              child;\n          for (i = m; i < M - m; i++) {\n              child = node.children[i];\n              extend$1(leftBBox, node.leaf ? toBBox(child) : child);\n              margin += bboxMargin(leftBBox);\n          }\n          for (i = M - m - 1; i >= m; i--) {\n              child = node.children[i];\n              extend$1(rightBBox, node.leaf ? toBBox(child) : child);\n              margin += bboxMargin(rightBBox);\n          }\n          return margin;\n      },\n      _adjustParentBBoxes: function _adjustParentBBoxes(bbox, path, level) {\n          for (var i = level; i >= 0; i--) {\n              extend$1(path[i], bbox);\n          }\n      },\n      _condense: function _condense(path) {\n          for (var i = path.length - 1, siblings; i >= 0; i--) {\n              if (path[i].children.length === 0) {\n                  if (i > 0) {\n                      siblings = path[i - 1].children;\n                      siblings.splice(siblings.indexOf(path[i]), 1);\n                  } else this.clear();\n              } else calcBBox(path[i], this.toBBox);\n          }\n      },\n      _initFormat: function _initFormat(format) {\n          var compareArr = ['return a', ' - b', ';'];\n          this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n          this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n          this.toBBox = new Function('a', 'return {minX: a' + format[0] + ', minY: a' + format[1] + ', maxX: a' + format[2] + ', maxY: a' + format[3] + '};');\n      }\n  };\n  function findItem(item, items, equalsFn) {\n      if (!equalsFn) return items.indexOf(item);\n      for (var i = 0; i < items.length; i++) {\n          if (equalsFn(item, items[i])) return i;\n      }\n      return -1;\n  }\n  function calcBBox(node, toBBox) {\n      distBBox(node, 0, node.children.length, toBBox, node);\n  }\n  function distBBox(node, k, p, toBBox, destNode) {\n      if (!destNode) destNode = createNode(null);\n      destNode.minX = Infinity;\n      destNode.minY = Infinity;\n      destNode.maxX = -Infinity;\n      destNode.maxY = -Infinity;\n      for (var i = k, child; i < p; i++) {\n          child = node.children[i];\n          extend$1(destNode, node.leaf ? toBBox(child) : child);\n      }\n      return destNode;\n  }\n  function extend$1(a, b) {\n      a.minX = Math.min(a.minX, b.minX);\n      a.minY = Math.min(a.minY, b.minY);\n      a.maxX = Math.max(a.maxX, b.maxX);\n      a.maxY = Math.max(a.maxY, b.maxY);\n      return a;\n  }\n  function compareNodeMinX(a, b) {\n      return a.minX - b.minX;\n  }\n  function compareNodeMinY(a, b) {\n      return a.minY - b.minY;\n  }\n  function bboxArea(a) {\n      return (a.maxX - a.minX) * (a.maxY - a.minY);\n  }\n  function bboxMargin(a) {\n      return a.maxX - a.minX + (a.maxY - a.minY);\n  }\n  function enlargedArea(a, b) {\n      return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n  }\n  function intersectionArea(a, b) {\n      var minX = Math.max(a.minX, b.minX),\n          minY = Math.max(a.minY, b.minY),\n          maxX = Math.min(a.maxX, b.maxX),\n          maxY = Math.min(a.maxY, b.maxY);\n      return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);\n  }\n  function contains$1(a, b) {\n      return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;\n  }\n  function intersects(a, b) {\n      return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;\n  }\n  function createNode(children) {\n      return {\n          children: children,\n          height: 1,\n          leaf: true,\n          minX: Infinity,\n          minY: Infinity,\n          maxX: -Infinity,\n          maxY: -Infinity\n      };\n  }\n  function multiSelect(arr, left, right, n, compare) {\n      var stack = [left, right],\n          mid;\n      while (stack.length) {\n          right = stack.pop();\n          left = stack.pop();\n          if (right - left <= n) continue;\n          mid = left + Math.ceil((right - left) / n / 2) * n;\n          quickselect$2(arr, mid, left, right, compare);\n          stack.push(left, mid, mid, right);\n      }\n  }\n\n  function getCoord$2(coord) {\n      if (!coord) throw new Error('coord is required');\n      if (coord.type === 'Feature' && coord.geometry !== null && coord.geometry.type === 'Point') return coord.geometry.coordinates;\n      if (coord.type === 'Point') return coord.coordinates;\n      if (Array.isArray(coord) && coord.length >= 2 && coord[0].length === undefined && coord[1].length === undefined) return coord;\n      throw new Error('coord must be GeoJSON Point or an Array of numbers');\n  }\n  function getCoords$2(coords) {\n      if (!coords) throw new Error('coords is required');\n      if (coords.type === 'Feature' && coords.geometry !== null) return coords.geometry.coordinates;\n      if (coords.coordinates) return coords.coordinates;\n      if (Array.isArray(coords)) return coords;\n      throw new Error('coords must be GeoJSON Feature, Geometry Object or an Array');\n  }\n\n  function booleanPointInPolygon$1(point, polygon, options) {\n      options = options || {};\n      if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object') throw new Error('options is invalid');\n      var ignoreBoundary = options.ignoreBoundary;\n      if (!point) throw new Error('point is required');\n      if (!polygon) throw new Error('polygon is required');\n      var pt = getCoord$2(point);\n      var polys = getCoords$2(polygon);\n      var type = polygon.geometry ? polygon.geometry.type : polygon.type;\n      var bbox = polygon.bbox;\n      if (bbox && inBBox$1(pt, bbox) === false) return false;\n      if (type === 'Polygon') polys = [polys];\n      for (var i = 0, insidePoly = false; i < polys.length && !insidePoly; i++) {\n          if (inRing$1(pt, polys[i][0], ignoreBoundary)) {\n              var inHole = false;\n              var k = 1;\n              while (k < polys[i].length && !inHole) {\n                  if (inRing$1(pt, polys[i][k], !ignoreBoundary)) {\n                      inHole = true;\n                  }\n                  k++;\n              }\n              if (!inHole) insidePoly = true;\n          }\n      }\n      return insidePoly;\n  }\n  function inRing$1(pt, ring, ignoreBoundary) {\n      var isInside = false;\n      if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) ring = ring.slice(0, ring.length - 1);\n      for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n          var xi = ring[i][0],\n              yi = ring[i][1];\n          var xj = ring[j][0],\n              yj = ring[j][1];\n          var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 && (xi - pt[0]) * (xj - pt[0]) <= 0 && (yi - pt[1]) * (yj - pt[1]) <= 0;\n          if (onBoundary) return !ignoreBoundary;\n          var intersect = yi > pt[1] !== yj > pt[1] && pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi;\n          if (intersect) isInside = !isInside;\n      }\n      return isInside;\n  }\n  function inBBox$1(pt, bbox) {\n      return bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1];\n  }\n\n  var isects = function isects(feature, filterFn, useSpatialIndex) {\n      if (feature.geometry.type !== 'Polygon') throw new Error('The input feature must be a Polygon');\n      if (useSpatialIndex === undefined) useSpatialIndex = 1;\n      var coord = feature.geometry.coordinates;\n      var output = [];\n      var seen = {};\n      if (useSpatialIndex) {\n          var allEdgesAsRbushTreeItems = [];\n          for (var ring0 = 0; ring0 < coord.length; ring0++) {\n              for (var edge0 = 0; edge0 < coord[ring0].length - 1; edge0++) {\n                  allEdgesAsRbushTreeItems.push(rbushTreeItem(ring0, edge0));\n              }\n          }\n          var tree = rbush_1();\n          tree.load(allEdgesAsRbushTreeItems);\n      }\n      for (var ringA = 0; ringA < coord.length; ringA++) {\n          for (var edgeA = 0; edgeA < coord[ringA].length - 1; edgeA++) {\n              if (useSpatialIndex) {\n                  var bboxOverlaps = tree.search(rbushTreeItem(ringA, edgeA));\n                  bboxOverlaps.forEach(function (bboxIsect) {\n                      var ring1 = bboxIsect.ring;\n                      var edge1 = bboxIsect.edge;\n                      ifIsectAddToOutput(ringA, edgeA, ring1, edge1);\n                  });\n              } else {\n                  for (var ring1 = 0; ring1 < coord.length; ring1++) {\n                      for (var edge1 = 0; edge1 < coord[ring1].length - 1; edge1++) {\n                          ifIsectAddToOutput(ringA, edgeA, ring1, edge1);\n                      }\n                  }\n              }\n          }\n      }\n      if (!filterFn) output = { type: 'Feature', geometry: { type: 'MultiPoint', coordinates: output } };\n      return output;\n      function ifIsectAddToOutput(ring0, edge0, ring1, edge1) {\n          var start0 = coord[ring0][edge0];\n          var end0 = coord[ring0][edge0 + 1];\n          var start1 = coord[ring1][edge1];\n          var end1 = coord[ring1][edge1 + 1];\n          var isect = intersect(start0, end0, start1, end1);\n          if (isect === null) return;\n          var frac0;\n          var frac1;\n          if (end0[0] !== start0[0]) {\n              frac0 = (isect[0] - start0[0]) / (end0[0] - start0[0]);\n          } else {\n              frac0 = (isect[1] - start0[1]) / (end0[1] - start0[1]);\n          }\n          if (end1[0] !== start1[0]) {\n              frac1 = (isect[0] - start1[0]) / (end1[0] - start1[0]);\n          } else {\n              frac1 = (isect[1] - start1[1]) / (end1[1] - start1[1]);\n          }\n          if (frac0 >= 1 || frac0 <= 0 || frac1 >= 1 || frac1 <= 0) return;\n          var key = isect;\n          var unique = !seen[key];\n          if (unique) {\n              seen[key] = true;\n          }\n          if (filterFn) {\n              output.push(filterFn(isect, ring0, edge0, start0, end0, frac0, ring1, edge1, start1, end1, frac1, unique));\n          } else {\n              output.push(isect);\n          }\n      }\n      function rbushTreeItem(ring, edge) {\n          var start = coord[ring][edge];\n          var end = coord[ring][edge + 1];\n          var minX;\n          var maxX;\n          var minY;\n          var maxY;\n          if (start[0] < end[0]) {\n              minX = start[0];\n              maxX = end[0];\n          } else {\n              minX = end[0];\n              maxX = start[0];\n          }\n          if (start[1] < end[1]) {\n              minY = start[1];\n              maxY = end[1];\n          } else {\n              minY = end[1];\n              maxY = start[1];\n          }\n          return { minX: minX, minY: minY, maxX: maxX, maxY: maxY, ring: ring, edge: edge };\n      }\n  };\n  function intersect(start0, end0, start1, end1) {\n      if (equalArrays$1(start0, start1) || equalArrays$1(start0, end1) || equalArrays$1(end0, start1) || equalArrays$1(end1, start1)) return null;\n      var x0 = start0[0],\n          y0 = start0[1],\n          x1 = end0[0],\n          y1 = end0[1],\n          x2 = start1[0],\n          y2 = start1[1],\n          x3 = end1[0],\n          y3 = end1[1];\n      var denom = (x0 - x1) * (y2 - y3) - (y0 - y1) * (x2 - x3);\n      if (denom === 0) return null;\n      var x4 = ((x0 * y1 - y0 * x1) * (x2 - x3) - (x0 - x1) * (x2 * y3 - y2 * x3)) / denom;\n      var y4 = ((x0 * y1 - y0 * x1) * (y2 - y3) - (y0 - y1) * (x2 * y3 - y2 * x3)) / denom;\n      return [x4, y4];\n  }\n  function equalArrays$1(array1, array2) {\n      if (!array1 || !array2) return false;\n      if (array1.length !== array2.length) return false;\n      for (var i = 0, l = array1.length; i < l; i++) {\n          if (array1[i] instanceof Array && array2[i] instanceof Array) {\n              if (!equalArrays$1(array1[i], array2[i])) return false;\n          } else if (array1[i] !== array2[i]) {\n              return false;\n          }\n      }\n      return true;\n  }\n  var simplepolygon = function simplepolygon(feature) {\n      if (feature.type != 'Feature') throw new Error('The input must a geojson object of type Feature');\n      if (feature.geometry === undefined || feature.geometry == null) throw new Error('The input must a geojson object with a non-empty geometry');\n      if (feature.geometry.type != 'Polygon') throw new Error('The input must be a geojson Polygon');\n      var numRings = feature.geometry.coordinates.length;\n      var vertices = [];\n      for (var i = 0; i < numRings; i++) {\n          var ring = feature.geometry.coordinates[i];\n          if (!equalArrays$2(ring[0], ring[ring.length - 1])) {\n              ring.push(ring[0]);\n          }\n          vertices.push.apply(vertices, ring.slice(0, ring.length - 1));\n      }\n      if (!isUnique(vertices)) throw new Error('The input polygon may not have duplicate vertices (except for the first and last vertex of each ring)');\n      var numvertices = vertices.length;\n      var selfIsectsData = isects(feature, function filterFn(isect, ring0, edge0, start0, end0, frac0, ring1, edge1, start1, end1, frac1, unique) {\n          return [isect, ring0, edge0, start0, end0, frac0, ring1, edge1, start1, end1, frac1, unique];\n      });\n      var numSelfIsect = selfIsectsData.length;\n      if (numSelfIsect == 0) {\n          var outputFeatureArray = [];\n          for (var i = 0; i < numRings; i++) {\n              outputFeatureArray.push(polygon$4([feature.geometry.coordinates[i]], { parent: -1, winding: windingOfRing(feature.geometry.coordinates[i]) }));\n          }\n          var output = featureCollection$4(outputFeatureArray);\n          determineParents();\n          setNetWinding();\n          return output;\n      }\n      var pseudoVtxListByRingAndEdge = [];\n      var isectList = [];\n      for (var i = 0; i < numRings; i++) {\n          pseudoVtxListByRingAndEdge.push([]);\n          for (var j = 0; j < feature.geometry.coordinates[i].length - 1; j++) {\n              pseudoVtxListByRingAndEdge[i].push([new PseudoVtx(feature.geometry.coordinates[i][(j + 1).modulo(feature.geometry.coordinates[i].length - 1)], 1, [i, j], [i, (j + 1).modulo(feature.geometry.coordinates[i].length - 1)], undefined)]);\n              isectList.push(new Isect(feature.geometry.coordinates[i][j], [i, (j - 1).modulo(feature.geometry.coordinates[i].length - 1)], [i, j], undefined, undefined, false, true));\n          }\n      }\n      for (var i = 0; i < numSelfIsect; i++) {\n          pseudoVtxListByRingAndEdge[selfIsectsData[i][1]][selfIsectsData[i][2]].push(new PseudoVtx(selfIsectsData[i][0], selfIsectsData[i][5], [selfIsectsData[i][1], selfIsectsData[i][2]], [selfIsectsData[i][6], selfIsectsData[i][7]], undefined));\n          if (selfIsectsData[i][11]) isectList.push(new Isect(selfIsectsData[i][0], [selfIsectsData[i][1], selfIsectsData[i][2]], [selfIsectsData[i][6], selfIsectsData[i][7]], undefined, undefined, true, true));\n      }\n      var numIsect = isectList.length;\n      for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {\n          for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {\n              pseudoVtxListByRingAndEdge[i][j].sort(function (a, b) {\n                  return a.param < b.param ? -1 : 1;\n              });\n          }\n      }\n      var allIsectsAsIsectRbushTreeItem = [];\n      for (var i = 0; i < numIsect; i++) {\n          allIsectsAsIsectRbushTreeItem.push({ minX: isectList[i].coord[0], minY: isectList[i].coord[1], maxX: isectList[i].coord[0], maxY: isectList[i].coord[1], index: i });\n      }\n      var isectRbushTree = rbush_1();\n      isectRbushTree.load(allIsectsAsIsectRbushTreeItem);\n      for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {\n          for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {\n              for (var k = 0; k < pseudoVtxListByRingAndEdge[i][j].length; k++) {\n                  var coordToFind;\n                  if (k == pseudoVtxListByRingAndEdge[i][j].length - 1) {\n                      coordToFind = pseudoVtxListByRingAndEdge[i][(j + 1).modulo(feature.geometry.coordinates[i].length - 1)][0].coord;\n                  } else {\n                      coordToFind = pseudoVtxListByRingAndEdge[i][j][k + 1].coord;\n                  }\n                  var IsectRbushTreeItemFound = isectRbushTree.search({ minX: coordToFind[0], minY: coordToFind[1], maxX: coordToFind[0], maxY: coordToFind[1] })[0];\n                  pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn = IsectRbushTreeItemFound.index;\n              }\n          }\n      }\n      for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {\n          for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {\n              for (var k = 0; k < pseudoVtxListByRingAndEdge[i][j].length; k++) {\n                  var coordToFind = pseudoVtxListByRingAndEdge[i][j][k].coord;\n                  var IsectRbushTreeItemFound = isectRbushTree.search({ minX: coordToFind[0], minY: coordToFind[1], maxX: coordToFind[0], maxY: coordToFind[1] })[0];\n                  var l = IsectRbushTreeItemFound.index;\n                  if (l < numvertices) {\n                      isectList[l].nxtIsectAlongRingAndEdge2 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;\n                  } else {\n                      if (equalArrays$2(isectList[l].ringAndEdge1, pseudoVtxListByRingAndEdge[i][j][k].ringAndEdgeIn)) {\n                          isectList[l].nxtIsectAlongRingAndEdge1 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;\n                      } else {\n                          isectList[l].nxtIsectAlongRingAndEdge2 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;\n                      }\n                  }\n              }\n          }\n      }\n      var queue = [];\n      var i = 0;\n      for (var j = 0; j < numRings; j++) {\n          var leftIsect = i;\n          for (var k = 0; k < feature.geometry.coordinates[j].length - 1; k++) {\n              if (isectList[i].coord[0] < isectList[leftIsect].coord[0]) {\n                  leftIsect = i;\n              }\n              i++;\n          }\n          var isectAfterLeftIsect = isectList[leftIsect].nxtIsectAlongRingAndEdge2;\n          for (var k = 0; k < isectList.length; k++) {\n              if (isectList[k].nxtIsectAlongRingAndEdge1 == leftIsect || isectList[k].nxtIsectAlongRingAndEdge2 == leftIsect) {\n                  var isectBeforeLeftIsect = k;\n                  break;\n              }\n          }\n          var windingAtIsect = isConvex([isectList[isectBeforeLeftIsect].coord, isectList[leftIsect].coord, isectList[isectAfterLeftIsect].coord], true) ? 1 : -1;\n          queue.push({ isect: leftIsect, parent: -1, winding: windingAtIsect });\n      }\n      queue.sort(function (a, b) {\n          return isectList[a.isect].coord > isectList[b.isect].coord ? -1 : 1;\n      });\n      var outputFeatureArray = [];\n      while (queue.length > 0) {\n          var popped = queue.pop();\n          var startIsect = popped.isect;\n          var currentOutputRingParent = popped.parent;\n          var currentOutputRingWinding = popped.winding;\n          var currentOutputRing = outputFeatureArray.length;\n          var currentOutputRingCoords = [isectList[startIsect].coord];\n          var currentIsect = startIsect;\n          if (isectList[startIsect].ringAndEdge1Walkable) {\n              var walkingRingAndEdge = isectList[startIsect].ringAndEdge1;\n              var nxtIsect = isectList[startIsect].nxtIsectAlongRingAndEdge1;\n          } else {\n              var walkingRingAndEdge = isectList[startIsect].ringAndEdge2;\n              var nxtIsect = isectList[startIsect].nxtIsectAlongRingAndEdge2;\n          }\n          while (!equalArrays$2(isectList[startIsect].coord, isectList[nxtIsect].coord)) {\n              currentOutputRingCoords.push(isectList[nxtIsect].coord);\n              var nxtIsectInQueue = undefined;\n              for (var i = 0; i < queue.length; i++) {\n                  if (queue[i].isect == nxtIsect) {\n                      nxtIsectInQueue = i;break;\n                  }\n              }\n              if (nxtIsectInQueue != undefined) {\n                  queue.splice(nxtIsectInQueue, 1);\n              }\n              if (equalArrays$2(walkingRingAndEdge, isectList[nxtIsect].ringAndEdge1)) {\n                  walkingRingAndEdge = isectList[nxtIsect].ringAndEdge2;\n                  isectList[nxtIsect].ringAndEdge2Walkable = false;\n                  if (isectList[nxtIsect].ringAndEdge1Walkable) {\n                      var pushing = { isect: nxtIsect };\n                      if (isConvex([isectList[currentIsect].coord, isectList[nxtIsect].coord, isectList[isectList[nxtIsect].nxtIsectAlongRingAndEdge2].coord], currentOutputRingWinding == 1)) {\n                          pushing.parent = currentOutputRingParent;\n                          pushing.winding = -currentOutputRingWinding;\n                      } else {\n                          pushing.parent = currentOutputRing;\n                          pushing.winding = currentOutputRingWinding;\n                      }\n                      queue.push(pushing);\n                  }\n                  currentIsect = nxtIsect;\n                  nxtIsect = isectList[nxtIsect].nxtIsectAlongRingAndEdge2;\n              } else {\n                  walkingRingAndEdge = isectList[nxtIsect].ringAndEdge1;\n                  isectList[nxtIsect].ringAndEdge1Walkable = false;\n                  if (isectList[nxtIsect].ringAndEdge2Walkable) {\n                      var pushing = { isect: nxtIsect };\n                      if (isConvex([isectList[currentIsect].coord, isectList[nxtIsect].coord, isectList[isectList[nxtIsect].nxtIsectAlongRingAndEdge1].coord], currentOutputRingWinding == 1)) {\n                          pushing.parent = currentOutputRingParent;\n                          pushing.winding = -currentOutputRingWinding;\n                      } else {\n                          pushing.parent = currentOutputRing;\n                          pushing.winding = currentOutputRingWinding;\n                      }\n                      queue.push(pushing);\n                  }\n                  currentIsect = nxtIsect;\n                  nxtIsect = isectList[nxtIsect].nxtIsectAlongRingAndEdge1;\n              }\n          }\n          currentOutputRingCoords.push(isectList[nxtIsect].coord);\n          outputFeatureArray.push(polygon$4([currentOutputRingCoords], { index: currentOutputRing, parent: currentOutputRingParent, winding: currentOutputRingWinding, netWinding: undefined }));\n      }\n      var output = featureCollection$4(outputFeatureArray);\n      determineParents();\n      setNetWinding();\n      function determineParents() {\n          var featuresWithoutParent = [];\n          for (var i = 0; i < output.features.length; i++) {\n              if (output.features[i].properties.parent == -1) featuresWithoutParent.push(i);\n          }\n          if (featuresWithoutParent.length > 1) {\n              for (var i = 0; i < featuresWithoutParent.length; i++) {\n                  var parent = -1;\n                  var parentArea = Infinity;\n                  for (var j = 0; j < output.features.length; j++) {\n                      if (featuresWithoutParent[i] == j) continue;\n                      if (booleanPointInPolygon$1(output.features[featuresWithoutParent[i]].geometry.coordinates[0][0], output.features[j], { ignoreBoundary: true })) {\n                          if (area(output.features[j]) < parentArea) {\n                              parent = j;\n                          }\n                      }\n                  }\n                  output.features[featuresWithoutParent[i]].properties.parent = parent;\n              }\n          }\n      }\n      function setNetWinding() {\n          for (var i = 0; i < output.features.length; i++) {\n              if (output.features[i].properties.parent == -1) {\n                  var netWinding = output.features[i].properties.winding;\n                  output.features[i].properties.netWinding = netWinding;\n                  setNetWindingOfChildren(i, netWinding);\n              }\n          }\n      }\n      function setNetWindingOfChildren(parent, ParentNetWinding) {\n          for (var i = 0; i < output.features.length; i++) {\n              if (output.features[i].properties.parent == parent) {\n                  var netWinding = ParentNetWinding + output.features[i].properties.winding;\n                  output.features[i].properties.netWinding = netWinding;\n                  setNetWindingOfChildren(i, netWinding);\n              }\n          }\n      }\n      return output;\n  };\n  var PseudoVtx = function PseudoVtx(coord, param, ringAndEdgeIn, ringAndEdgeOut, nxtIsectAlongEdgeIn) {\n      this.coord = coord;\n      this.param = param;\n      this.ringAndEdgeIn = ringAndEdgeIn;\n      this.ringAndEdgeOut = ringAndEdgeOut;\n      this.nxtIsectAlongEdgeIn = nxtIsectAlongEdgeIn;\n  };\n  var Isect = function Isect(coord, ringAndEdge1, ringAndEdge2, nxtIsectAlongRingAndEdge1, nxtIsectAlongRingAndEdge2, ringAndEdge1Walkable, ringAndEdge2Walkable) {\n      this.coord = coord;\n      this.ringAndEdge1 = ringAndEdge1;\n      this.ringAndEdge2 = ringAndEdge2;\n      this.nxtIsectAlongRingAndEdge1 = nxtIsectAlongRingAndEdge1;\n      this.nxtIsectAlongRingAndEdge2 = nxtIsectAlongRingAndEdge2;\n      this.ringAndEdge1Walkable = ringAndEdge1Walkable;\n      this.ringAndEdge2Walkable = ringAndEdge2Walkable;\n  };\n  function isConvex(pts, righthanded) {\n      if (typeof righthanded === 'undefined') righthanded = true;\n      if (pts.length != 3) throw new Error('This function requires an array of three points [x,y]');\n      var d = (pts[1][0] - pts[0][0]) * (pts[2][1] - pts[0][1]) - (pts[1][1] - pts[0][1]) * (pts[2][0] - pts[0][0]);\n      return d >= 0 == righthanded;\n  }\n  function windingOfRing(ring) {\n      var leftVtx = 0;\n      for (var i = 0; i < ring.length - 1; i++) {\n          if (ring[i][0] < ring[leftVtx][0]) leftVtx = i;\n      }\n      if (isConvex([ring[(leftVtx - 1).modulo(ring.length - 1)], ring[leftVtx], ring[(leftVtx + 1).modulo(ring.length - 1)]], true)) {\n          var winding = 1;\n      } else {\n          var winding = -1;\n      }\n      return winding;\n  }\n  function equalArrays$2(array1, array2) {\n      if (!array1 || !array2) return false;\n      if (array1.length != array2.length) return false;\n      for (var i = 0, l = array1.length; i < l; i++) {\n          if (array1[i] instanceof Array && array2[i] instanceof Array) {\n              if (!equalArrays$2(array1[i], array2[i])) return false;\n          } else if (array1[i] != array2[i]) {\n              return false;\n          }\n      }\n      return true;\n  }\n  Number.prototype.modulo = function (n) {\n      return (this % n + n) % n;\n  };\n  function isUnique(array) {\n      var u = {};\n      var isUnique = 1;\n      for (var i = 0, l = array.length; i < l; ++i) {\n          if (u.hasOwnProperty(array[i])) {\n              isUnique = 0;\n              break;\n          }\n          u[array[i]] = 1;\n      }\n      return isUnique;\n  }\n  function unkinkPolygon(geojson) {\n      var features = [];\n      flattenEach$3(geojson, function (feature) {\n          if (feature.geometry.type !== 'Polygon') return;\n          featureEach$3(simplepolygon(feature), function (poly) {\n              features.push(polygon$4(poly.geometry.coordinates, feature.properties));\n          });\n      });\n      return featureCollection$4(features);\n  }\n\n  function unkink(object) {\n    var polygonFeature = polygonToFeaturePolygon(object);\n    return unkinkPolygon(polygonFeature);\n  }\n\n  function baseFilter(collection, predicate) {\n    var result = [];\n    baseEach(collection, function (value, index, collection) {\n      if (predicate(value, index, collection)) {\n        result.push(value);\n      }\n    });\n    return result;\n  }\n\n  function filter(collection, predicate) {\n    var func = isArray(collection) ? arrayFilter : baseFilter;\n    return func(collection, baseIteratee(predicate, 3));\n  }\n\n  function baseExtremum(array, iteratee, comparator) {\n    var index = -1,\n        length = array.length;\n    while (++index < length) {\n      var value = array[index],\n          current = iteratee(value);\n      if (current != null && (computed === undefined ? current === current && !isSymbol(current) : comparator(current, computed))) {\n        var computed = current,\n            result = value;\n      }\n    }\n    return result;\n  }\n\n  function baseGt(value, other) {\n    return value > other;\n  }\n\n  function max$1(array) {\n    return array && array.length ? baseExtremum(array, identity, baseGt) : undefined;\n  }\n\n  function baseLt(value, other) {\n    return value < other;\n  }\n\n  function min$1(array) {\n    return array && array.length ? baseExtremum(array, identity, baseLt) : undefined;\n  }\n\n  function quickselect$3(arr, k, left, right, compare) {\n      quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare$1);\n  }\n  function quickselectStep(arr, k, left, right, compare) {\n      while (right > left) {\n          if (right - left > 600) {\n              var n = right - left + 1;\n              var m = k - left + 1;\n              var z = Math.log(n);\n              var s = 0.5 * Math.exp(2 * z / 3);\n              var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n              var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n              var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n              quickselectStep(arr, k, newLeft, newRight, compare);\n          }\n          var t = arr[k];\n          var i = left;\n          var j = right;\n          swap$1(arr, left, k);\n          if (compare(arr[right], t) > 0) swap$1(arr, left, right);\n          while (i < j) {\n              swap$1(arr, i, j);\n              i++;\n              j--;\n              while (compare(arr[i], t) < 0) {\n                  i++;\n              }while (compare(arr[j], t) > 0) {\n                  j--;\n              }\n          }\n          if (compare(arr[left], t) === 0) swap$1(arr, left, j);else {\n              j++;\n              swap$1(arr, j, right);\n          }\n          if (j <= k) left = j + 1;\n          if (k <= j) right = j - 1;\n      }\n  }\n  function swap$1(arr, i, j) {\n      var tmp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = tmp;\n  }\n  function defaultCompare$1(a, b) {\n      return a < b ? -1 : a > b ? 1 : 0;\n  }\n\n  function rbush$1(maxEntries, format) {\n      if (!(this instanceof rbush$1)) return new rbush$1(maxEntries, format);\n      this._maxEntries = Math.max(4, maxEntries || 9);\n      this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n      if (format) {\n          this._initFormat(format);\n      }\n      this.clear();\n  }\n  rbush$1.prototype = {\n      all: function all() {\n          return this._all(this.data, []);\n      },\n      search: function search(bbox) {\n          var node = this.data,\n              result = [],\n              toBBox = this.toBBox;\n          if (!intersects$1(bbox, node)) return result;\n          var nodesToSearch = [],\n              i,\n              len,\n              child,\n              childBBox;\n          while (node) {\n              for (i = 0, len = node.children.length; i < len; i++) {\n                  child = node.children[i];\n                  childBBox = node.leaf ? toBBox(child) : child;\n                  if (intersects$1(bbox, childBBox)) {\n                      if (node.leaf) result.push(child);else if (contains$2(bbox, childBBox)) this._all(child, result);else nodesToSearch.push(child);\n                  }\n              }\n              node = nodesToSearch.pop();\n          }\n          return result;\n      },\n      collides: function collides(bbox) {\n          var node = this.data,\n              toBBox = this.toBBox;\n          if (!intersects$1(bbox, node)) return false;\n          var nodesToSearch = [],\n              i,\n              len,\n              child,\n              childBBox;\n          while (node) {\n              for (i = 0, len = node.children.length; i < len; i++) {\n                  child = node.children[i];\n                  childBBox = node.leaf ? toBBox(child) : child;\n                  if (intersects$1(bbox, childBBox)) {\n                      if (node.leaf || contains$2(bbox, childBBox)) return true;\n                      nodesToSearch.push(child);\n                  }\n              }\n              node = nodesToSearch.pop();\n          }\n          return false;\n      },\n      load: function load(data) {\n          if (!(data && data.length)) return this;\n          if (data.length < this._minEntries) {\n              for (var i = 0, len = data.length; i < len; i++) {\n                  this.insert(data[i]);\n              }\n              return this;\n          }\n          var node = this._build(data.slice(), 0, data.length - 1, 0);\n          if (!this.data.children.length) {\n              this.data = node;\n          } else if (this.data.height === node.height) {\n              this._splitRoot(this.data, node);\n          } else {\n              if (this.data.height < node.height) {\n                  var tmpNode = this.data;\n                  this.data = node;\n                  node = tmpNode;\n              }\n              this._insert(node, this.data.height - node.height - 1, true);\n          }\n          return this;\n      },\n      insert: function insert(item) {\n          if (item) this._insert(item, this.data.height - 1);\n          return this;\n      },\n      clear: function clear() {\n          this.data = createNode$1([]);\n          return this;\n      },\n      remove: function remove(item, equalsFn) {\n          if (!item) return this;\n          var node = this.data,\n              bbox = this.toBBox(item),\n              path = [],\n              indexes = [],\n              i,\n              parent,\n              index,\n              goingUp;\n          while (node || path.length) {\n              if (!node) {\n                  node = path.pop();\n                  parent = path[path.length - 1];\n                  i = indexes.pop();\n                  goingUp = true;\n              }\n              if (node.leaf) {\n                  index = findItem$1(item, node.children, equalsFn);\n                  if (index !== -1) {\n                      node.children.splice(index, 1);\n                      path.push(node);\n                      this._condense(path);\n                      return this;\n                  }\n              }\n              if (!goingUp && !node.leaf && contains$2(node, bbox)) {\n                  path.push(node);\n                  indexes.push(i);\n                  i = 0;\n                  parent = node;\n                  node = node.children[0];\n              } else if (parent) {\n                  i++;\n                  node = parent.children[i];\n                  goingUp = false;\n              } else node = null;\n          }\n          return this;\n      },\n      toBBox: function toBBox(item) {\n          return item;\n      },\n      compareMinX: compareNodeMinX$1,\n      compareMinY: compareNodeMinY$1,\n      toJSON: function toJSON() {\n          return this.data;\n      },\n      fromJSON: function fromJSON(data) {\n          this.data = data;\n          return this;\n      },\n      _all: function _all(node, result) {\n          var nodesToSearch = [];\n          while (node) {\n              if (node.leaf) result.push.apply(result, node.children);else nodesToSearch.push.apply(nodesToSearch, node.children);\n              node = nodesToSearch.pop();\n          }\n          return result;\n      },\n      _build: function _build(items, left, right, height) {\n          var N = right - left + 1,\n              M = this._maxEntries,\n              node;\n          if (N <= M) {\n              node = createNode$1(items.slice(left, right + 1));\n              calcBBox$1(node, this.toBBox);\n              return node;\n          }\n          if (!height) {\n              height = Math.ceil(Math.log(N) / Math.log(M));\n              M = Math.ceil(N / Math.pow(M, height - 1));\n          }\n          node = createNode$1([]);\n          node.leaf = false;\n          node.height = height;\n          var N2 = Math.ceil(N / M),\n              N1 = N2 * Math.ceil(Math.sqrt(M)),\n              i,\n              j,\n              right2,\n              right3;\n          multiSelect$1(items, left, right, N1, this.compareMinX);\n          for (i = left; i <= right; i += N1) {\n              right2 = Math.min(i + N1 - 1, right);\n              multiSelect$1(items, i, right2, N2, this.compareMinY);\n              for (j = i; j <= right2; j += N2) {\n                  right3 = Math.min(j + N2 - 1, right2);\n                  node.children.push(this._build(items, j, right3, height - 1));\n              }\n          }\n          calcBBox$1(node, this.toBBox);\n          return node;\n      },\n      _chooseSubtree: function _chooseSubtree(bbox, node, level, path) {\n          var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n          while (true) {\n              path.push(node);\n              if (node.leaf || path.length - 1 === level) break;\n              minArea = minEnlargement = Infinity;\n              for (i = 0, len = node.children.length; i < len; i++) {\n                  child = node.children[i];\n                  area = bboxArea$1(child);\n                  enlargement = enlargedArea$1(bbox, child) - area;\n                  if (enlargement < minEnlargement) {\n                      minEnlargement = enlargement;\n                      minArea = area < minArea ? area : minArea;\n                      targetNode = child;\n                  } else if (enlargement === minEnlargement) {\n                      if (area < minArea) {\n                          minArea = area;\n                          targetNode = child;\n                      }\n                  }\n              }\n              node = targetNode || node.children[0];\n          }\n          return node;\n      },\n      _insert: function _insert(item, level, isNode) {\n          var toBBox = this.toBBox,\n              bbox = isNode ? item : toBBox(item),\n              insertPath = [];\n          var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n          node.children.push(item);\n          extend$2(node, bbox);\n          while (level >= 0) {\n              if (insertPath[level].children.length > this._maxEntries) {\n                  this._split(insertPath, level);\n                  level--;\n              } else break;\n          }\n          this._adjustParentBBoxes(bbox, insertPath, level);\n      },\n      _split: function _split(insertPath, level) {\n          var node = insertPath[level],\n              M = node.children.length,\n              m = this._minEntries;\n          this._chooseSplitAxis(node, m, M);\n          var splitIndex = this._chooseSplitIndex(node, m, M);\n          var newNode = createNode$1(node.children.splice(splitIndex, node.children.length - splitIndex));\n          newNode.height = node.height;\n          newNode.leaf = node.leaf;\n          calcBBox$1(node, this.toBBox);\n          calcBBox$1(newNode, this.toBBox);\n          if (level) insertPath[level - 1].children.push(newNode);else this._splitRoot(node, newNode);\n      },\n      _splitRoot: function _splitRoot(node, newNode) {\n          this.data = createNode$1([node, newNode]);\n          this.data.height = node.height + 1;\n          this.data.leaf = false;\n          calcBBox$1(this.data, this.toBBox);\n      },\n      _chooseSplitIndex: function _chooseSplitIndex(node, m, M) {\n          var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n          minOverlap = minArea = Infinity;\n          for (i = m; i <= M - m; i++) {\n              bbox1 = distBBox$1(node, 0, i, this.toBBox);\n              bbox2 = distBBox$1(node, i, M, this.toBBox);\n              overlap = intersectionArea$1(bbox1, bbox2);\n              area = bboxArea$1(bbox1) + bboxArea$1(bbox2);\n              if (overlap < minOverlap) {\n                  minOverlap = overlap;\n                  index = i;\n                  minArea = area < minArea ? area : minArea;\n              } else if (overlap === minOverlap) {\n                  if (area < minArea) {\n                      minArea = area;\n                      index = i;\n                  }\n              }\n          }\n          return index;\n      },\n      _chooseSplitAxis: function _chooseSplitAxis(node, m, M) {\n          var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX$1,\n              compareMinY = node.leaf ? this.compareMinY : compareNodeMinY$1,\n              xMargin = this._allDistMargin(node, m, M, compareMinX),\n              yMargin = this._allDistMargin(node, m, M, compareMinY);\n          if (xMargin < yMargin) node.children.sort(compareMinX);\n      },\n      _allDistMargin: function _allDistMargin(node, m, M, compare) {\n          node.children.sort(compare);\n          var toBBox = this.toBBox,\n              leftBBox = distBBox$1(node, 0, m, toBBox),\n              rightBBox = distBBox$1(node, M - m, M, toBBox),\n              margin = bboxMargin$1(leftBBox) + bboxMargin$1(rightBBox),\n              i,\n              child;\n          for (i = m; i < M - m; i++) {\n              child = node.children[i];\n              extend$2(leftBBox, node.leaf ? toBBox(child) : child);\n              margin += bboxMargin$1(leftBBox);\n          }\n          for (i = M - m - 1; i >= m; i--) {\n              child = node.children[i];\n              extend$2(rightBBox, node.leaf ? toBBox(child) : child);\n              margin += bboxMargin$1(rightBBox);\n          }\n          return margin;\n      },\n      _adjustParentBBoxes: function _adjustParentBBoxes(bbox, path, level) {\n          for (var i = level; i >= 0; i--) {\n              extend$2(path[i], bbox);\n          }\n      },\n      _condense: function _condense(path) {\n          for (var i = path.length - 1, siblings; i >= 0; i--) {\n              if (path[i].children.length === 0) {\n                  if (i > 0) {\n                      siblings = path[i - 1].children;\n                      siblings.splice(siblings.indexOf(path[i]), 1);\n                  } else this.clear();\n              } else calcBBox$1(path[i], this.toBBox);\n          }\n      },\n      _initFormat: function _initFormat(format) {\n          var compareArr = ['return a', ' - b', ';'];\n          this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n          this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n          this.toBBox = new Function('a', 'return {minX: a' + format[0] + ', minY: a' + format[1] + ', maxX: a' + format[2] + ', maxY: a' + format[3] + '};');\n      }\n  };\n  function findItem$1(item, items, equalsFn) {\n      if (!equalsFn) return items.indexOf(item);\n      for (var i = 0; i < items.length; i++) {\n          if (equalsFn(item, items[i])) return i;\n      }\n      return -1;\n  }\n  function calcBBox$1(node, toBBox) {\n      distBBox$1(node, 0, node.children.length, toBBox, node);\n  }\n  function distBBox$1(node, k, p, toBBox, destNode) {\n      if (!destNode) destNode = createNode$1(null);\n      destNode.minX = Infinity;\n      destNode.minY = Infinity;\n      destNode.maxX = -Infinity;\n      destNode.maxY = -Infinity;\n      for (var i = k, child; i < p; i++) {\n          child = node.children[i];\n          extend$2(destNode, node.leaf ? toBBox(child) : child);\n      }\n      return destNode;\n  }\n  function extend$2(a, b) {\n      a.minX = Math.min(a.minX, b.minX);\n      a.minY = Math.min(a.minY, b.minY);\n      a.maxX = Math.max(a.maxX, b.maxX);\n      a.maxY = Math.max(a.maxY, b.maxY);\n      return a;\n  }\n  function compareNodeMinX$1(a, b) {\n      return a.minX - b.minX;\n  }\n  function compareNodeMinY$1(a, b) {\n      return a.minY - b.minY;\n  }\n  function bboxArea$1(a) {\n      return (a.maxX - a.minX) * (a.maxY - a.minY);\n  }\n  function bboxMargin$1(a) {\n      return a.maxX - a.minX + (a.maxY - a.minY);\n  }\n  function enlargedArea$1(a, b) {\n      return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n  }\n  function intersectionArea$1(a, b) {\n      var minX = Math.max(a.minX, b.minX),\n          minY = Math.max(a.minY, b.minY),\n          maxX = Math.min(a.maxX, b.maxX),\n          maxY = Math.min(a.maxY, b.maxY);\n      return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);\n  }\n  function contains$2(a, b) {\n      return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;\n  }\n  function intersects$1(a, b) {\n      return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;\n  }\n  function createNode$1(children) {\n      return {\n          children: children,\n          height: 1,\n          leaf: true,\n          minX: Infinity,\n          minY: Infinity,\n          maxX: -Infinity,\n          maxY: -Infinity\n      };\n  }\n  function multiSelect$1(arr, left, right, n, compare) {\n      var stack = [left, right],\n          mid;\n      while (stack.length) {\n          right = stack.pop();\n          left = stack.pop();\n          if (right - left <= n) continue;\n          mid = left + Math.ceil((right - left) / n / 2) * n;\n          quickselect$3(arr, mid, left, right, compare);\n          stack.push(left, mid, mid, right);\n      }\n  }\n\n  function geojsonRbush(maxEntries) {\n      var tree = rbush$1(maxEntries);\n      tree.insert = function (feature) {\n          if (Array.isArray(feature)) {\n              var bbox = feature;\n              feature = bboxPolygon(bbox);\n              feature.bbox = bbox;\n          } else {\n              feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n          }\n          return rbush$1.prototype.insert.call(this, feature);\n      };\n      tree.load = function (features) {\n          var load = [];\n          if (Array.isArray(features)) {\n              features.forEach(function (bbox) {\n                  var feature = bboxPolygon(bbox);\n                  feature.bbox = bbox;\n                  load.push(feature);\n              });\n          } else {\n              featureEach$1(features, function (feature) {\n                  feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n                  load.push(feature);\n              });\n          }\n          return rbush$1.prototype.load.call(this, load);\n      };\n      tree.remove = function (feature) {\n          if (Array.isArray(feature)) {\n              var bbox = feature;\n              feature = bboxPolygon(bbox);\n              feature.bbox = bbox;\n          }\n          return rbush$1.prototype.remove.call(this, feature);\n      };\n      tree.clear = function () {\n          return rbush$1.prototype.clear.call(this);\n      };\n      tree.search = function (geojson) {\n          var features = rbush$1.prototype.search.call(this, this.toBBox(geojson));\n          return {\n              type: 'FeatureCollection',\n              features: features\n          };\n      };\n      tree.collides = function (geojson) {\n          return rbush$1.prototype.collides.call(this, this.toBBox(geojson));\n      };\n      tree.all = function () {\n          var features = rbush$1.prototype.all.call(this);\n          return {\n              type: 'FeatureCollection',\n              features: features\n          };\n      };\n      tree.toJSON = function () {\n          return rbush$1.prototype.toJSON.call(this);\n      };\n      tree.fromJSON = function (json) {\n          return rbush$1.prototype.fromJSON.call(this, json);\n      };\n      tree.toBBox = function (geojson) {\n          var bbox;\n          if (geojson.bbox) bbox = geojson.bbox;else if (Array.isArray(geojson) && geojson.length === 4) bbox = geojson;else bbox = turfBBox(geojson);\n          return {\n              minX: bbox[0],\n              minY: bbox[1],\n              maxX: bbox[2],\n              maxY: bbox[3]\n          };\n      };\n      return tree;\n  }\n  function bboxPolygon(bbox) {\n      var lowLeft = [bbox[0], bbox[1]];\n      var topLeft = [bbox[0], bbox[3]];\n      var topRight = [bbox[2], bbox[3]];\n      var lowRight = [bbox[2], bbox[1]];\n      var coordinates = [[lowLeft, lowRight, topRight, topLeft, lowLeft]];\n      return {\n          type: 'Feature',\n          bbox: bbox,\n          properties: {},\n          geometry: {\n              type: 'Polygon',\n              coordinates: coordinates\n          }\n      };\n  }\n  function turfBBox(geojson) {\n      var bbox = [Infinity, Infinity, -Infinity, -Infinity];\n      coordEach$1(geojson, function (coord) {\n          if (bbox[0] > coord[0]) bbox[0] = coord[0];\n          if (bbox[1] > coord[1]) bbox[1] = coord[1];\n          if (bbox[2] < coord[0]) bbox[2] = coord[0];\n          if (bbox[3] < coord[1]) bbox[3] = coord[1];\n      });\n      return bbox;\n  }\n\n  function feature$7(geometry, properties, options) {\n      options = options || {};\n      if (!isObject$6(options)) throw new Error('options is invalid');\n      var bbox = options.bbox;\n      var id = options.id;\n      if (geometry === undefined) throw new Error('geometry is required');\n      if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n      if (bbox) validateBBox$4(bbox);\n      if (id) validateId$4(id);\n      var feat = { type: 'Feature' };\n      if (id) feat.id = id;\n      if (bbox) feat.bbox = bbox;\n      feat.properties = properties || {};\n      feat.geometry = geometry;\n      return feat;\n  }\n  function lineString$5(coordinates, properties, options) {\n      if (!coordinates) throw new Error('coordinates is required');\n      if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions');\n      if (!isNumber$5(coordinates[0][1]) || !isNumber$5(coordinates[0][1])) throw new Error('coordinates must contain numbers');\n      return feature$7({\n          type: 'LineString',\n          coordinates: coordinates\n      }, properties, options);\n  }\n  function featureCollection$5(features, options) {\n      options = options || {};\n      if (!isObject$6(options)) throw new Error('options is invalid');\n      var bbox = options.bbox;\n      var id = options.id;\n      if (!features) throw new Error('No features passed');\n      if (!Array.isArray(features)) throw new Error('features must be an Array');\n      if (bbox) validateBBox$4(bbox);\n      if (id) validateId$4(id);\n      var fc = { type: 'FeatureCollection' };\n      if (id) fc.id = id;\n      if (bbox) fc.bbox = bbox;\n      fc.features = features;\n      return fc;\n  }\n  function isNumber$5(num) {\n      return !isNaN(num) && num !== null && !Array.isArray(num);\n  }\n  function isObject$6(input) {\n      return !!input && input.constructor === Object;\n  }\n  function validateBBox$4(bbox) {\n      if (!bbox) throw new Error('bbox is required');\n      if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n      if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n      bbox.forEach(function (num) {\n          if (!isNumber$5(num)) throw new Error('bbox must only contain numbers');\n      });\n  }\n  function validateId$4(id) {\n      if (!id) throw new Error('id is required');\n      if (['string', 'number'].indexOf(typeof id === 'undefined' ? 'undefined' : _typeof(id)) === -1) throw new Error('id must be a number or a string');\n  }\n\n  function getCoords$3(coords) {\n      if (!coords) throw new Error('coords is required');\n      if (coords.type === 'Feature' && coords.geometry !== null) return coords.geometry.coordinates;\n      if (coords.coordinates) return coords.coordinates;\n      if (Array.isArray(coords)) return coords;\n      throw new Error('coords must be GeoJSON Feature, Geometry Object or an Array');\n  }\n\n  function geomEach$4(geojson, callback) {\n      var i,\n          j,\n          g,\n          geometry,\n          stopG,\n          geometryMaybeCollection,\n          isGeometryCollection,\n          featureProperties,\n          featureBBox,\n          featureId,\n          featureIndex = 0,\n          isFeatureCollection = geojson.type === 'FeatureCollection',\n          isFeature = geojson.type === 'Feature',\n          stop = isFeatureCollection ? geojson.features.length : 1;\n      for (i = 0; i < stop; i++) {\n          geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;\n          featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};\n          featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : undefined;\n          featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : undefined;\n          isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n          stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n          for (g = 0; g < stopG; g++) {\n              geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n              if (geometry === null) {\n                  if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                  continue;\n              }\n              switch (geometry.type) {\n                  case 'Point':\n                  case 'LineString':\n                  case 'MultiPoint':\n                  case 'Polygon':\n                  case 'MultiLineString':\n                  case 'MultiPolygon':\n                      {\n                          if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                          break;\n                      }\n                  case 'GeometryCollection':\n                      {\n                          for (j = 0; j < geometry.geometries.length; j++) {\n                              if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                          }\n                          break;\n                      }\n                  default:\n                      throw new Error('Unknown Geometry Type');\n              }\n          }\n          featureIndex++;\n      }\n  }\n  function flattenEach$4(geojson, callback) {\n      geomEach$4(geojson, function (geometry, featureIndex, properties, bbox, id) {\n          var type = geometry === null ? null : geometry.type;\n          switch (type) {\n              case null:\n              case 'Point':\n              case 'LineString':\n              case 'Polygon':\n                  if (callback(feature$7(geometry, properties, { bbox: bbox, id: id }), featureIndex, 0) === false) return false;\n                  return;\n          }\n          var geomType;\n          switch (type) {\n              case 'MultiPoint':\n                  geomType = 'Point';\n                  break;\n              case 'MultiLineString':\n                  geomType = 'LineString';\n                  break;\n              case 'MultiPolygon':\n                  geomType = 'Polygon';\n                  break;\n          }\n          for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n              var coordinate = geometry.coordinates[multiFeatureIndex];\n              var geom = {\n                  type: geomType,\n                  coordinates: coordinate\n              };\n              if (callback(feature$7(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n          }\n      });\n  }\n\n  function lineSegment(geojson) {\n      if (!geojson) throw new Error('geojson is required');\n      var results = [];\n      flattenEach$4(geojson, function (feature) {\n          lineSegmentFeature(feature, results);\n      });\n      return featureCollection$5(results);\n  }\n  function lineSegmentFeature(geojson, results) {\n      var coords = [];\n      var geometry = geojson.geometry;\n      switch (geometry.type) {\n          case 'Polygon':\n              coords = getCoords$3(geometry);\n              break;\n          case 'LineString':\n              coords = [getCoords$3(geometry)];\n      }\n      coords.forEach(function (coord) {\n          var segments = createSegments(coord, geojson.properties);\n          segments.forEach(function (segment) {\n              segment.id = results.length;\n              results.push(segment);\n          });\n      });\n  }\n  function createSegments(coords, properties) {\n      var segments = [];\n      coords.reduce(function (previousCoords, currentCoords) {\n          var segment = lineString$5([previousCoords, currentCoords], properties);\n          segment.bbox = bbox$2(previousCoords, currentCoords);\n          segments.push(segment);\n          return currentCoords;\n      });\n      return segments;\n  }\n  function bbox$2(coords1, coords2) {\n      var x1 = coords1[0];\n      var y1 = coords1[1];\n      var x2 = coords2[0];\n      var y2 = coords2[1];\n      var west = x1 < x2 ? x1 : x2;\n      var south = y1 < y2 ? y1 : y2;\n      var east = x1 > x2 ? x1 : x2;\n      var north = y1 > y2 ? y1 : y2;\n      return [west, south, east, north];\n  }\n\n  function feature$8(geometry, properties, options) {\n      options = options || {};\n      if (!isObject$7(options)) throw new Error('options is invalid');\n      var bbox = options.bbox;\n      var id = options.id;\n      if (geometry === undefined) throw new Error('geometry is required');\n      if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n      if (bbox) validateBBox$5(bbox);\n      if (id) validateId$5(id);\n      var feat = { type: 'Feature' };\n      if (id) feat.id = id;\n      if (bbox) feat.bbox = bbox;\n      feat.properties = properties || {};\n      feat.geometry = geometry;\n      return feat;\n  }\n  function point$6(coordinates, properties, options) {\n      if (!coordinates) throw new Error('coordinates is required');\n      if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n      if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');\n      if (!isNumber$6(coordinates[0]) || !isNumber$6(coordinates[1])) throw new Error('coordinates must contain numbers');\n      return feature$8({\n          type: 'Point',\n          coordinates: coordinates\n      }, properties, options);\n  }\n  function featureCollection$6(features, options) {\n      options = options || {};\n      if (!isObject$7(options)) throw new Error('options is invalid');\n      var bbox = options.bbox;\n      var id = options.id;\n      if (!features) throw new Error('No features passed');\n      if (!Array.isArray(features)) throw new Error('features must be an Array');\n      if (bbox) validateBBox$5(bbox);\n      if (id) validateId$5(id);\n      var fc = { type: 'FeatureCollection' };\n      if (id) fc.id = id;\n      if (bbox) fc.bbox = bbox;\n      fc.features = features;\n      return fc;\n  }\n  function isNumber$6(num) {\n      return !isNaN(num) && num !== null && !Array.isArray(num);\n  }\n  function isObject$7(input) {\n      return !!input && input.constructor === Object;\n  }\n  function validateBBox$5(bbox) {\n      if (!bbox) throw new Error('bbox is required');\n      if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n      if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n      bbox.forEach(function (num) {\n          if (!isNumber$6(num)) throw new Error('bbox must only contain numbers');\n      });\n  }\n  function validateId$5(id) {\n      if (!id) throw new Error('id is required');\n      if (['string', 'number'].indexOf(typeof id === 'undefined' ? 'undefined' : _typeof(id)) === -1) throw new Error('id must be a number or a string');\n  }\n\n  function getCoords$4(coords) {\n      if (!coords) throw new Error('coords is required');\n      if (coords.type === 'Feature' && coords.geometry !== null) return coords.geometry.coordinates;\n      if (coords.coordinates) return coords.coordinates;\n      if (Array.isArray(coords)) return coords;\n      throw new Error('coords must be GeoJSON Feature, Geometry Object or an Array');\n  }\n\n  function featureEach$5(geojson, callback) {\n      if (geojson.type === 'Feature') {\n          callback(geojson, 0);\n      } else if (geojson.type === 'FeatureCollection') {\n          for (var i = 0; i < geojson.features.length; i++) {\n              if (callback(geojson.features[i], i) === false) break;\n          }\n      }\n  }\n\n  function lineIntersect(line1, line2) {\n      var unique = {};\n      var results = [];\n      if (line1.type === 'LineString') line1 = feature$8(line1);\n      if (line2.type === 'LineString') line2 = feature$8(line2);\n      if (line1.type === 'Feature' && line2.type === 'Feature' && line1.geometry.type === 'LineString' && line2.geometry.type === 'LineString' && line1.geometry.coordinates.length === 2 && line2.geometry.coordinates.length === 2) {\n          var intersect = intersects$2(line1, line2);\n          if (intersect) results.push(intersect);\n          return featureCollection$6(results);\n      }\n      var tree = geojsonRbush();\n      tree.load(lineSegment(line2));\n      featureEach$5(lineSegment(line1), function (segment) {\n          featureEach$5(tree.search(segment), function (match) {\n              var intersect = intersects$2(segment, match);\n              if (intersect) {\n                  var key = getCoords$4(intersect).join(',');\n                  if (!unique[key]) {\n                      unique[key] = true;\n                      results.push(intersect);\n                  }\n              }\n          });\n      });\n      return featureCollection$6(results);\n  }\n  function intersects$2(line1, line2) {\n      var coords1 = getCoords$4(line1);\n      var coords2 = getCoords$4(line2);\n      if (coords1.length !== 2) {\n          throw new Error('<intersects> line1 must only contain 2 coordinates');\n      }\n      if (coords2.length !== 2) {\n          throw new Error('<intersects> line2 must only contain 2 coordinates');\n      }\n      var x1 = coords1[0][0];\n      var y1 = coords1[0][1];\n      var x2 = coords1[1][0];\n      var y2 = coords1[1][1];\n      var x3 = coords2[0][0];\n      var y3 = coords2[0][1];\n      var x4 = coords2[1][0];\n      var y4 = coords2[1][1];\n      var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n      var numeA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n      var numeB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n      if (denom === 0) {\n          if (numeA === 0 && numeB === 0) {\n              return null;\n          }\n          return null;\n      }\n      var uA = numeA / denom;\n      var uB = numeB / denom;\n      if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\n          var x = x1 + uA * (x2 - x1);\n          var y = y1 + uA * (y2 - y1);\n          return point$6([x, y]);\n      }\n      return null;\n  }\n\n  function nearestPointOnLine(lines, pt, options) {\n      options = options || {};\n      if (!isObject$2(options)) throw new Error('options is invalid');\n      var type = lines.geometry ? lines.geometry.type : lines.type;\n      if (type !== 'LineString' && type !== 'MultiLineString') {\n          throw new Error('lines must be LineString or MultiLineString');\n      }\n      var closestPt = point$1([Infinity, Infinity], {\n          dist: Infinity\n      });\n      var length = 0.0;\n      flattenEach$1(lines, function (line) {\n          var coords = getCoords(line);\n          for (var i = 0; i < coords.length - 1; i++) {\n              var start = point$1(coords[i]);\n              start.properties.dist = distance(pt, start, options);\n              var stop = point$1(coords[i + 1]);\n              stop.properties.dist = distance(pt, stop, options);\n              var sectionLength = distance(start, stop, options);\n              var heightDistance = Math.max(start.properties.dist, stop.properties.dist);\n              var direction = bearing(start, stop);\n              var perpendicularPt1 = destination(pt, heightDistance, direction + 90, options);\n              var perpendicularPt2 = destination(pt, heightDistance, direction - 90, options);\n              var intersect = lineIntersect(lineString$1([perpendicularPt1.geometry.coordinates, perpendicularPt2.geometry.coordinates]), lineString$1([start.geometry.coordinates, stop.geometry.coordinates]));\n              var intersectPt = null;\n              if (intersect.features.length > 0) {\n                  intersectPt = intersect.features[0];\n                  intersectPt.properties.dist = distance(pt, intersectPt, options);\n                  intersectPt.properties.location = length + distance(start, intersectPt, options);\n              }\n              if (start.properties.dist < closestPt.properties.dist) {\n                  closestPt = start;\n                  closestPt.properties.index = i;\n                  closestPt.properties.location = length;\n              }\n              if (stop.properties.dist < closestPt.properties.dist) {\n                  closestPt = stop;\n                  closestPt.properties.index = i + 1;\n                  closestPt.properties.location = length + sectionLength;\n              }\n              if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {\n                  closestPt = intersectPt;\n                  closestPt.properties.index = i;\n              }\n              length += sectionLength;\n          }\n      });\n      return closestPt;\n  }\n\n  function lineSlice(startPt, stopPt, line) {\n      var coords;\n      if (line.type === 'Feature') {\n          coords = line.geometry.coordinates;\n      } else if (line.type === 'LineString') {\n          coords = line.coordinates;\n      } else {\n          throw new Error('input must be a LineString Feature or Geometry');\n      }\n      var startVertex = nearestPointOnLine(line, startPt);\n      var stopVertex = nearestPointOnLine(line, stopPt);\n      var ends;\n      if (startVertex.properties.index <= stopVertex.properties.index) {\n          ends = [startVertex, stopVertex];\n      } else {\n          ends = [stopVertex, startVertex];\n      }\n      var clipCoords = [ends[0].geometry.coordinates];\n      for (var i = ends[0].properties.index + 1; i < ends[1].properties.index + 1; i++) {\n          clipCoords.push(coords[i]);\n      }\n      clipCoords.push(ends[1].geometry.coordinates);\n      return lineString$1(clipCoords, line.properties);\n  }\n\n  function isEqual(value, other) {\n    return baseIsEqual(value, other);\n  }\n\n  function diffCoords(coord1, coord2) {\n  \tvar vector = [Math.abs(coord1[0] - coord2[0]), Math.abs(coord1[1] - coord2[1])];\n  \treturn Math.sqrt(Math.pow(vector[0], 2) + Math.pow(vector[1], 2));\n  }\n  function findLineIntersection(line1Start, line1End, line2Start, line2End) {\n  \tvar line1 = lineString$1([line1Start, line1End]),\n  \t    line2 = lineString$1([line2Start, line2End]),\n  \t    intersectionFC = lineIntersect(line1, line2);\n  \tif (intersectionFC.features.length) {\n  \t\tvar intersection = intersectionFC.features[0].geometry.coordinates;\n  \t\tintersection[0] = Math.round(intersection[0] * 100000000) / 100000000;\n  \t\tintersection[1] = Math.round(intersection[1] * 100000000) / 100000000;\n  \t\treturn intersection;\n  \t} else {\n  \t\treturn false;\n  \t}\n  }\n  function traverseRings(ring1, ring2) {\n  \tvar intersections = featureCollection$1([]);\n  \tvar samering = false;\n  \tif (isEqual(ring1, ring2)) {\n  \t\tsamering = true;\n  \t}\n  \tfor (var i = 0; i < ring1.length - 1; i++) {\n  \t\tvar startK = samering ? i : 0;\n  \t\tfor (var k = startK; k < ring2.length - 1; k++) {\n  \t\t\tif (ring1 === ring2 && (Math.abs(i - k) === 1 || Math.abs(i - k) === ring1.length - 2)) {\n  \t\t\t\tcontinue;\n  \t\t\t}\n  \t\t\tvar intersection = findLineIntersection(ring1[i], ring1[i + 1], ring2[k], ring2[k + 1]);\n  \t\t\tif (!intersection) {\n  \t\t\t\tcontinue;\n  \t\t\t}\n  \t\t\tif ((diffCoords(intersection, ring1[0]) < 0.000005 || diffCoords(intersection, ring1[ring1.length - 1]) < 0.000005) && (diffCoords(intersection, ring2[0]) < 0.000005 || diffCoords(intersection, ring2[ring2.length - 1]) < 0.000005)) {\n  \t\t\t\tcontinue;\n  \t\t\t}\n  \t\t\tvar FeatureIntersection = point$1([intersection[0], intersection[1]]);\n  \t\t\tFeatureIntersection.properties = {\n  \t\t\t\tposition1: i,\n  \t\t\t\tposition2: k\n  \t\t\t};\n  \t\t\tintersections.features.push(FeatureIntersection);\n  \t\t}\n  \t}\n  \treturn intersections;\n  }function trimPaths(arrayLatLng1, arrayLatLng2) {\n  \tvar ring1 = toCoords(arrayLatLng1);\n  \tvar ring2 = toCoords(arrayLatLng2);\n  \tvar intersections = traverseRings(ring1, ring2);\n  \tif (intersections.features.length > 0) {\n  \t\tvar line1 = lineString$1(ring1);\n  \t\tvar line2 = lineString$1(ring2);\n  \t\tvar line1Start = point$1(ring1[0]);\n  \t\tvar line2End = point$1(ring2.slice(-1)[0]);\n  \t\tvar sliced1, sliced2;\n  \t\tvar first_segment_with_kinks = min$1(intersections.features, function (kink) {\n  \t\t\treturn kink.properties.position1;\n  \t\t});\n  \t\tvar kinks_in_first_segment = filter(intersections.features, function (kink) {\n  \t\t\treturn kink.properties.position1 === first_segment_with_kinks.properties.position1;\n  \t\t});\n  \t\tvar chosenIntersection = max$1(kinks_in_first_segment, function (kink) {\n  \t\t\treturn kink.properties.position2;\n  \t\t});\n  \t\tvar intersectLatLng = toLatLngs([chosenIntersection.geometry.coordinates])[0];\n  \t\tif (chosenIntersection.properties.position1 === 0) {\n  \t\t\tsliced1 = line1;\n  \t\t} else {\n  \t\t\tsliced1 = lineSlice(line1Start, chosenIntersection, line1);\n  \t\t}\n  \t\tif (chosenIntersection.properties.position2 >= ring2.length - 1) {\n  \t\t\tsliced2 = line2;\n  \t\t} else {\n  \t\t\tsliced2 = lineSlice(chosenIntersection, line2End, line2);\n  \t\t}\n  \t\treturn [toLatLngs(sliced1.geometry.coordinates), toLatLngs(sliced2.geometry.coordinates), intersectLatLng];\n  \t}\n  \treturn [];\n  }\n\n  var ig_turfhelper = {\n      along: along$1,\n      arrayToFeaturePoints: arrayToFeaturePoints,\n      createbuffer: createbuffer,\n      pointInPolygon: pointInPolygon,\n      polygonToFeaturePolygon: polygonToFeaturePolygon,\n      polylineToFeatureLinestring: polylineToFeatureLinestring,\n      simplifyFeature: simplifyFeature,\n      simplifyPointArray: simplifyPointArray,\n      toLatLngs: toLatLngs,\n      toCoords: toCoords,\n      trimPaths: trimPaths,\n      union: union$1,\n      kinks: kinks$1,\n      unkink: unkink,\n      concave: concave$1\n  };\n\n  exports.along = along$1;\n  exports.arrayToFeaturePoints = arrayToFeaturePoints;\n  exports.createbuffer = createbuffer;\n  exports.pointInPolygon = pointInPolygon;\n  exports.polygonToFeaturePolygon = polygonToFeaturePolygon;\n  exports.polylineToFeatureLinestring = polylineToFeatureLinestring;\n  exports.simplifyFeature = simplifyFeature;\n  exports.simplifyPointArray = simplifyPointArray;\n  exports.toLatLngs = toLatLngs;\n  exports.toCoords = toCoords;\n  exports.trimPaths = trimPaths;\n  exports.kinks = kinks$1;\n  exports.unkink = unkink;\n  exports.union = union$1;\n  exports.concave = concave$1;\n  exports.default = ig_turfhelper;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"],"names":["global","factory","exports","module","define","amd","turfHelper","this","Wicket$1","Wkt","arrayMap","array","iteratee","index","length","result","Array","eq","value","other","assocIndexOf","key","ListCache","entries","clear","entry","set","baseGetTag","undefined","undefinedTag","nullTag","symToStringTag$1","Object","isOwn","hasOwnProperty","call","symToStringTag","tag","unmasked","e","nativeObjectToString","getRawTag","nativeObjectToString$1","objectToString","isObject","type","_typeof","isFunction","funcTag","genTag","asyncTag","proxyTag","toSource","func","funcToString","baseIsNative","maskSrcKey","isMasked","reIsNative","reIsHostCtor","test","getNative","object","getValue","Hash","getMapData","map","data","__data__","isKeyable","MapCache","Stack","size","SetCache","values","add","arraySome","predicate","cacheHas","cache","has","equalArrays","bitmask","customizer","equalFunc","stack","isPartial","COMPARE_PARTIAL_FLAG","arrLength","othLength","stacked","get","seen","COMPARE_UNORDERED_FLAG","arrValue","othValue","compared","othIndex","push","mapToArray","forEach","setToArray","arrayFilter","resIndex","isObjectLike","baseIsArguments","argsTag","isIndex","MAX_SAFE_INTEGER","reIsUint","isLength","MAX_SAFE_INTEGER$1","arrayLikeKeys","inherited","isArr","isArray","isArg","isArguments","isBuff","isBuffer","isType","isTypedArray","skipIndexes","n","baseTimes","String","hasOwnProperty$5","baseKeys","Ctor","constructor","prototype","objectProto$8","isPrototype","nativeKeys","hasOwnProperty$6","isArrayLike","keys","getAllKeys","keysFunc","symbolsFunc","offset","arrayPush","baseGetAllKeys","getSymbols","baseIsEqualDeep","objIsArr","othIsArr","objTag","arrayTag$1","getTag$1","othTag","objIsObj","argsTag$2","objectTag$2","othIsObj","isSameTag","dataViewTag","byteLength","byteOffset","buffer","arrayBufferTag","Uint8Array","boolTag","dateTag","numberTag","errorTag","name","message","regexpTag","stringTag","mapTag","convert","setTag","COMPARE_PARTIAL_FLAG$1","COMPARE_UNORDERED_FLAG$1","symbolTag","symbolValueOf","equalByTag","COMPARE_PARTIAL_FLAG$3","objIsWrapped","hasOwnProperty$8","othIsWrapped","objUnwrapped","othUnwrapped","COMPARE_PARTIAL_FLAG$2","objProps","objLength","hasOwnProperty$7","skipCtor","objValue","objCtor","othCtor","equalObjects","baseIsEqual","isStrictComparable","matchesStrictComparable","srcValue","baseMatches","source","matchData","getMatchData","noCustomizer","COMPARE_PARTIAL_FLAG$4","COMPARE_UNORDERED_FLAG$2","baseIsMatch","isSymbol","symbolTag$1","isKey","reIsPlainProp","reIsDeepProp","memoize","resolver","TypeError","FUNC_ERROR_TEXT","memoized","args","arguments","apply","Cache","baseToString","symbolToString","INFINITY","castPath","stringToPath","toString","toKey","INFINITY$1","baseGet","path","baseHasIn","hasIn","hasFunc","hasPath","baseMatchesProperty","defaultValue","get$1","COMPARE_PARTIAL_FLAG$5","COMPARE_UNORDERED_FLAG$3","identity","property","baseProperty","basePropertyDeep","baseIteratee","collection","baseEach","castFunction","toLatLng","position","google","maps","LatLng","lat","lng","toLatLngs","coordinates","toCoord","Error","toCoords","arrayLatLng","closeRing","ring","last_coord","pop","geomReduce","geojson","callback","initialValue","previousValue","i","j","g","geometry$$1","stopG","geometryMaybeCollection","isGeometryCollection","featureProperties","featureBBox","featureId","featureIndex","isFeatureCollection","isFeature","stop","features","geometry","properties","bbox","id","geometries","geomEach","currentGeometry","area","geom","calculateArea","polygonArea","coords","Math","abs","ringArea","p1","p2","lowerIndex","middleIndex","upperIndex","coordsLength","rad","sin","RADIUS","_","PI","feature$1","indexOf","feat","point$1","isNumber$1","lineString$1","featureCollection$1","fc","radiansToLength$1","radians","units","factor","factors$1","lengthToRadians$1","distance","radiansToDegrees$1","degreesToRadians$1","degrees","num","isNaN","isObject$2","input","arrayToFeaturePolygon","LatLngArray","polylineToFeatureLinestring","objeto","vertices","Polyline","getPath","getArray","polygonToFeaturePolygon","polygonFeature","Polygon","arrayToFeaturePoints","latLngArray","FeatureCollection","latLng","Feature","tin","points","z","isPointZ","sort","byX","a","b","c","A","B","G","xmin","x","xmax","ymin","y","ymax","dx","dy","dmax","xmid","ymid","open","Triangle","__sentinel","closed","edges","r","splice","dedup","triangulate","p","point","triangle","polygon$1","C","D","E","F","m","outer","clone","cloneFeature","cloned","feature","cloneFeatureCollection","cloneGeometry","cloneProperties","item","deepSlice","slice","coord","getCoord","obj","getCoords","containsNumber","getType","coordEach$1","excludeWrapCoord","geometryIndex","k","l","wrapShrink","coordIndex","featureSubIndex","geomType","featureEach$1","geomEach$1","flattenEach$1","coordinate","lineReduce$1","lineIndex","lineEach$1","currentLine","lineDissolve","options","mutate","lastLine","previousLine","merged","coords1","coords2","s1","coordId","e1","s2","e2","concat","reverse","mergeLineStrings","multiLineString$1","line","identity$1","topology","o","arc","arcs","transformPoint","t","polygon","transform","x0","y0","kx","scale","ky","translate","output","stitch","flush","fragmentByEnd","fragmentByStart","f","start","end","stitchedArcs","fragments","emptyIndex","p0","dp","ends","fg","unshift","gf","merge","objects","extract","polygonsByArc","polygons","planarRingArea","groups","group","neighbors","ki","hashmap","hash","equal","keyType","keyEmpty","valueType","keystore","max","ceil","log","LN2","valstore","mask","matchKey","collisions","maybeSet","missingValue","equalPoint","pointA","pointB","hashPoint","floats","uints","join","sequence","previousIndex","currentIndex","nextIndex","visitedByIndex","leftIndex","leftByIndex","rightIndex","rightByIndex","junctionCount","junctionByIndex","hashIndex","equalIndex","lines","rings","indexes","indexByPoint","Int32Array","Int8Array","lineStart","lineEnd","ringStart","ringEnd","junctionByPoint","empty","store","match","hashset","cut","next","junctions","lineMid","0","1","ringMid","ringFixed","reverse$1","rotateArray","mid","dedup$1","dedupLine","startPoint","endPoint","startArcs","startArc","endArcs","endArc","arcsByEnd","arcA","arcB","ia","ib","ja","jb","equalLine","reverseEqualLine","equalRing","ka","findMinimumOffset","kb","reverseEqualRing","minimum","minimumPoint","arcCount","dedupRing","geometry$2","inputs","outputs","geomifyFeature","geomifyGeometry","geomifyObject","quantization","indexGeometry","indexGeometryType","indexArcs","indexByArc","indexMultiArcs","boundGeometry","boundGeometryType","boundPoint","x1","y1","boundLine","boundMultiLine","Infinity","GeometryCollection","Point","MultiPoint","LineString","MultiLineString","MultiPolygon","bounds","quantizePoint","round","quantizePoints","pi","px","py","quantizeLine","quantizeRing","quantizePolygon","quantizeGeometry","quantizeGeometryType","prequantize","extractGeometry","extractGeometryType","extractLine","extractRing","extractMultiRing","hashArc","equalArc","delta","polygonDissolve","geoms","topo","geometryCollection$1","dissolve","types","getHomogenousType","from","to","coordinates1","coordinates2","dLat","dLon","lat1","lat2","pow","cos","atan2","sqrt","concave","maxEdge","tinPolys","cleaned","existing","pt","removeDuplicates","filter","pt1","pt2","pt3","dist1","dist2","dist3","dissolved","concave$1","feature$4","isObject$3","isNumber$2","validateBBox$1","validateId$1","getCoords$1","cleanCoords","getType$1","newCoords","cleanLine","polyPoints","equals","prevPoint","nextPoint","newPoints","secondToLast","startX","startY","endX","endY","dxl","dyl","isPointOnLineSegment","clone$1","cloneFeature$1","cloneFeatureCollection$1","cloneGeometry$1","cloneProperties$1","deepSlice$1","getSqDist","getSqSegDist","simplifyDPStep","first","last","sqTolerance","simplified","maxSqDist","sqDist","simplify$2","tolerance","highestQuality","len","simplifyRadialDist","simplifyDouglasPeucker","simplify","isObject$4","highQuality","geomEach$2","simplifyLine","simplifyPolygon","simplifyGeom","pts","simpleRing","checkValidity","simplifyPointArray","coordArray","simplifyFeature","toLowerCase","fromObject","toJson","simplifiedgeom","warn","fromJson","toObject","bearing","final","bear","calculateFinalBearing","lon1","lon2","destination","origin","longitude1","latitude1","bearing_rad","latitude2","asin","along","distance$$1","travelled","overshot","direction","along$1","extend","target","NumberUtil","IllegalArgumentException","Double","Comparable","Clonable","Comparator","Serializable","RuntimeException","inherits$1","create","AssertionFailedException","Assert","Coordinate","NULL_ORDINATE","DimensionalComparator","_dimensionsToTest","dimensionsToTest","Iterator","Collection","IndexOutOfBoundsException$1","List","NoSuchElementException","OperationNotSupported","ArrayList","array_","addAll","CoordinateList","ensureCapacity","allowRepeated","Envelope","_minx","_maxx","_miny","_maxy","init","env","x2","y2","Exception","NotRepresentableException","Location","hasInterface","interfaces_","MathUtil","StringBuffer","str","Integer","Character","DD","_hi","_lo","dd","parse","hi","lo","CGAlgorithmsDD","CoordinateSequence","System","HCoordinate","w","_x","_y","_w","q1","q2","pw","qx","qy","qw","CoordinateSequenceFactory","GeometryComponentFilter","Geometry","_envelope","_factory","_SRID","_userData","getSRID","CoordinateFilter","BoundaryNodeRule","Mod2BoundaryNodeRule","EndPointBoundaryNodeRule","MultiValentEndPointBoundaryNodeRule","MonoValentEndPointBoundaryNodeRule","CoordinateArrays","ForwardComparator","BidirectionalComparator","Map$2","SortedMap","Set$1","HashSet","colorOf","BLACK","color","parentOf","parent","setColor","leftOf","left","rightOf","right","TreeMap","root_","size_","Lineal","SortedSet","TreeSet","Arrays","Dimension","GeometryFilter","CoordinateSequenceFilter","_geometries","hasNullElements","lineStrings","BoundaryOp","_geom","_geomFact","_bnRule","_endpointMap","MOD2_BOUNDARY_RULE","bnRule","getFactory","Counter","count","IOException","StringUtil","CoordinateSequences","_points","Puntal","_coordinates","Polygonal","_shell","_holes","shell","holes","createLinearRing","isEmpty","hasNonEmptyElements","LinearRing","GeometryFactory","getCoordinateSequenceFactory","validateConstruction","GeometryEditor","_isUserDataCopied","GeometryEditorOperation","NoOpGeometryOperation","CoordinateOperation","CoordinateSequenceOperation","CoordinateArraySequence","_dimension","Number","isInteger","fill","coordSeq","getDimension","getCoordinateCopy","dimension","CoordinateArraySequenceFactory","is","sharedIterator","itp","array2","done","v","sharedSize","_values","HashMap","map_","MapImpl","PrecisionModel","_modelType","_scale","FLOATING","Type","modelType","FIXED","setScale","pm","_name","nameToTypeMap","put","_precisionModel","_coordinateSequenceFactory","coordinateSequenceFactory","precisionModel","getDefaultCoordinateSequenceFactory","SRID","WKTParser","geometryFactory","WKTWriter","parser","LineIntersector","_result","_inputLines","_intPt","_intLineIndex","_isProper","_pa","_pb","RobustLineIntersector","RobustDeterminant","RayCrossingCounter","_p","_crossingCount","_isPointOnSegment","CGAlgorithms","LineSegment","ls","IntersectionMatrix","_matrix","setAll","FALSE","elements","INTERIOR","BOUNDARY","EXTERIOR","Centroid","_areaBasePt","_triangleCent3","_areasum2","_cg3","_lineCentSum","_totalLength","_ptCount","_ptCentSum","EmptyStackException","Stack$1","UniqueCoordinateArrayFilter","treeSet","list","ConvexHull","_geomFactory","_inputPts","extractCoordinates","geomFactory","filterCoordinates","RadialComparator","_origin","GeometryTransformer","_inputGeom","_pruneEmptyGeometry","_preserveGeometryCollectionType","_preserveCollections","_preserveType","LineStringSnapper","_snapTolerance","_srcPts","_seg","_allowSnappingToSourceVertices","_isClosed","srcLine","snapTolerance","getCoordinates","srcPts","isClosed","GeometrySnapper","_srcGeom","srcGeom","SnapTransformer","_snapPts","_isSelfSnap","snapPts","isSelfSnap","CommonBits","_isFirst","_commonMantissaBitsCount","_commonBits","_commonSignExp","CommonBitsRemover","_commonCoord","_ccFilter","CommonCoordinateFilter","_commonBitsX","_commonBitsY","Translater","trans","GeometryCollectionIterator","_parent","_atStart","_max","_index","_subcollectionIterator","getNumGeometries","PointLocator","_boundaryRule","OGC_SFS_BOUNDARY_RULE","_isIn","_numBoundaries","boundaryRule","Octant","SegmentString","BasicSegmentString","_pts","_data","Boundable","ItemBoundable","_bounds","_item","PriorityQueue","_size","_items","ItemVisitor","SpatialIndex","AbstractNode","_childBoundables","_level","level","BoundablePair","_boundable1","_boundable2","_distance","_itemDistance","boundable1","boundable2","itemDistance","AbstractSTRtree","_root","_built","_itemBoundables","_nodeCapacity","DEFAULT_NODE_CAPACITY","nodeCapacity","isTrue","ItemDistance","STRtree","STRtreeNode","SegmentPointComparator","SegmentNode","_segString","segmentIndex","_segmentOctant","_isInterior","segString","segmentOctant","equals2D","getCoordinate","SegmentNodeList","_nodeMap","_edge","edge","NodeVertexIterator","_nodeList","_nodeIt","_currNode","_nextNode","_currSegIndex","nodeList","getEdge","iterator","readNextNode","NodableSegmentString","NodedSegmentString","MonotoneChainOverlapAction","tempEnv1","tempEnv2","_overlapSeg1","_overlapSeg2","MonotoneChain","_start","_end","_env","_context","_id","context","Quadrant","MonotoneChainBuilder","Noder","SinglePassNoder","_segInt","segInt","setSegmentIntersector","MCIndexNoder","_monoChains","_idCounter","_nodedSegStrings","_nOverlaps","si","SegmentOverlapAction","_si","TopologyException","msg","msgWithCoord","SegmentIntersector","InteriorIntersectionFinder","_findAllIntersections","_isCheckEndSegmentsOnly","_li","_interiorIntersection","_intSegments","_intersections","_intersectionCount","_keepIntersections","li","FastNodingValidator","_segStrings","_isValid","segStrings","EdgeNodingValidator","_nv","toSegmentStrings","GeometryCollectionMapper","_mapOp","mapOp","Position","TopologyLocation","location","on","ON","gl","LEFT","RIGHT","Label","elt","onLoc","lbl","geomIndex","NONE","setLocation","leftLoc","rightLoc","setLocations","EdgeRing","_startDe","_maxNodeDegree","_edges","_label","_ring","_isHole","_geometryFactory","computePoints","computeRing","MinimalEdgeRing","MaximalEdgeRing","GraphComponent","_isInResult","_isCovered","_isCoveredSet","_isVisited","label","Node","_coord","NodeMap","nodeMap","nodeFact","EdgeEnd","_node","_p0","_p1","_dx","_dy","_quadrant","DirectedEdge","_isForward","_sym","_next","_nextMin","_edgeRing","_minEdgeRing","_depth","isForward","getNumPoints","computeDirectedLabel","NodeFactory","PlanarGraph","_nodes","_edgeEndList","PolygonBuilder","_shellList","LineBuilder","_op","_ptLocator","_lineEdgesList","_resultLineList","op","ptLocator","PointBuilder","_resultPointList","PointOnGeometryLocator","SimplePointInAreaLocator","EdgeEndStar","_edgeMap","_edgeList","_ptInAreaLocation","DirectedEdgeStar","_resultAreaEdgeList","_SCANNING_FOR_INCOMING","_LINKING_TO_OUTGOING","OverlayNodeFactory","MonotoneChain$1","mce","chainIndex","SweepLineEvent","_xValue","_eventType","_insertEvent","_deleteEventIndex","_obj","insertEvent","DELETE","INSERT","EdgeSetIntersector","SegmentIntersector$1","_hasIntersection","_hasProper","_hasProperInterior","_properIntersectionPoint","_includeProper","_recordIsolated","_isSelfIntersection","_numIntersections","numTests","_bdyNodes","_isDone","_isDoneWhenProperInt","includeProper","recordIsolated","SimpleMCSweepLineIntersector","events","nOverlaps","IntervalRTreeNode$1","_min","POSITIVE_INFINITY","NEGATIVE_INFINITY","NodeComparator","IntervalRTreeLeafNode","min","IntervalRTreeBranchNode","_node1","_node2","n1","n2","buildExtent","SortedPackedIntervalRTree","_leaves","LinearComponentExtracter","_lines","_isForcedToLineString","isForcedToLineString","ArrayListVisitor","IndexedPointInAreaLocator","IntervalIndexedGeometry","SegmentVisitor","_counter","counter","EdgeIntersection","dist","EdgeIntersectionList","MonotoneChainIndexer","MonotoneChainEdge","startIndex","env1","env2","mcb","getChainStartIndices","Depth","NULL_VALUE","Edge","eiList","_mce","_isIsolated","_depthDelta","GeometryGraph","_parentGeom","_lineEdgeMap","_boundaryNodeRule","_useBoundaryDeterminationRule","_argIndex","_boundaryNodes","_hasTooFewPoints","_invalidPoint","_areaPtLocator","argIndex","parentGeom","boundaryNodeRule","GeometryGraphOperation","_resultPrecisionModel","_arg","g0","setComputationPrecision","getPrecisionModel","g1","compareTo","OrientedCoordinateArray","_orientation","orientation","EdgeList","_ocaMap","OverlayOp","_resultGeom","_graph","_resultPolyList","SnapOverlayOp","_cbr","g2","computeSnapTolerance","SnapIfNeededOverlayOp","InteriorPointArea","_interiorPoint","_maxWidth","SafeBisectorFinder","_poly","_centreY","_hiY","MAX_VALUE","_loY","poly","getEnvelopeInternal","getMaxY","getMinY","avg","InteriorPointLine","_centroid","_minDistance","getCentroid","addInterior","addEndpoints","InteriorPointPoint","MonotoneChainSelectAction","selectedSegment","NodeBase","_subnode","Interval","interval","DoubleBits","Key","_pt","_interval","computeKey","Node$1","_centre","getMin","getMax","IntervalSize","Root","Bintree","_minExtent","PointInRing","MCPointInRing","_tree","_crossings","buildIndex","MCSelecter","mcp","Angle","Triangle$1","MinimumBoundingCircle","_input","_extremalPts","_radius","MinimumDiameter","_isConvex","_convexHullPts","_minBaseSeg","_minWidthPt","_minPtIndex","_minWidth","inputGeom","isConvex","Densifier","_distanceTolerance","DensifyTransformer","distanceTolerance","HalfEdge","_orig","orig","MarkHalfEdge","_isMarked","EdgeGraph","_vertexMap","DissolveHalfEdge","_isStart","DissolveEdgeGraph","LineDissolver","_nodeEdgeStack","_ringStartEdge","NodeBase$1","Key$1","itemEnv","Node$2","_centrex","_centrey","getMinX","getMaxX","Root$1","Quadtree","GeoJSONParser","GeoJSONReader","GeoJSONWriter","p2c","ScaledNoder","_noder","_scaleFactor","_offsetX","_offsetY","_isScaled","noder","scaleFactor","isIntegerPrecision","IsSimpleOp","_isClosedEndpointsInInterior","_nonSimpleLocation","isInBoundary","EndpointInfo","degree","BufferParameters","_quadrantSegments","DEFAULT_QUADRANT_SEGMENTS","_endCapStyle","CAP_ROUND","_joinStyle","JOIN_ROUND","_mitreLimit","DEFAULT_MITRE_LIMIT","_isSingleSided","_simplifyFactor","DEFAULT_SIMPLIFY_FACTOR","quadrantSegments","setQuadrantSegments","endCapStyle","setEndCapStyle","joinStyle","mitreLimit","setJoinStyle","setMitreLimit","RightmostEdgeFinder","_minIndex","_minCoord","_minDe","_orientedDe","LinkedList","BufferSubgraph","_finder","_dirEdgeList","_rightMostCoord","BufferInputLineSimplifier","_inputLine","_distanceTol","_isDeleted","_angleOrientation","COUNTERCLOCKWISE","inputLine","OffsetSegmentString","_ptList","_minimimVertexDistance","OffsetSegmentGenerator","_maxCurveSegmentError","_filletAngleQuantum","_closingSegLengthFactor","_segList","_bufParams","_s0","_s1","_s2","_seg0","_seg1","_offset0","_offset1","_side","_hasNarrowConcaveAngle","bufParams","getQuadrantSegments","getJoinStyle","MAX_CLOSING_SEG_LEN_FACTOR","OffsetCurveBuilder","SubgraphDepthLocater","_subgraphs","_cga","subgraphs","DepthSegment","_upwardSeg","_leftDepth","seg","depth","OffsetCurveSetBuilder","_curveBuilder","_curveList","curveBuilder","IntersectionAdder","_hasInterior","numIntersections","numInteriorIntersections","numProperIntersections","BufferBuilder","_workingPrecisionModel","_workingNoder","NodingValidator","HotPixel","_originalPt","_ptScaled","_p0Scaled","_p1Scaled","_corner","_safeEnv","initCorners","MCIndexPointSnapper","HotPixelSnapAction","_hotPixel","_parentEdge","_hotPixelVertexIndex","_isNodeAdded","hotPixel","parentEdge","hotPixelVertexIndex","InteriorIntersectionFinderAdder","_interiorIntersections","MCIndexSnapRounder","_pm","_pointSnapper","setPrecisionModel","getScale","BufferOp","_argGeom","_resultGeometry","_saveException","PolygonExtracter","_comps","comps","GeometryLocation","_component","_segIndex","component","INSIDE_AREA","segIndex","PointExtracter","ConnectedElementLocationFilter","_locations","locations","DistanceOp","_terminateDistance","_minDistanceLocation","terminateDistance","EdgeString","_directedEdges","GraphComponent$1","DirectedEdge$1","_from","_to","_edgeDirection","_angle","directionPt","edgeDirection","quadrant","LineMergeDirectedEdge","Edge$1","_dirEdge","de0","de1","setDirectedEdges","DirectedEdgeStar$1","_outEdges","_sorted","Node$3","_deStar","deStar","LineMergeEdge","_line","NodeMap$1","PlanarGraph$1","_dirEdges","LineMergeGraph","LineMerger","_mergedLineStrings","_edgeStrings","PolygonizeDirectedEdge","PolygonizeEdge","ConnectedInteriorTester","_geomGraph","_disconnectedRingcoord","geomGraph","EdgeEndBuilder","EdgeEndBundle","_edgeEnds","getDirectedCoordinate","getLabel","insert","EdgeEndBundleStar","RelateNode","RelateNodeFactory","RelateNodeGraph","ConsistentAreaTester","_nodeGraph","IndexedNestedRingTester","_rings","_totalEnv","_nestedPt","graph","TopologyValidationError","_errorType","errorType","copy","IsValidOp","_parentGeometry","_isSelfTouchingRingFormingHoleValid","_validErr","parentGeometry","EdgeRing$1","_deList","_lowestEdge","_ringPts","_isProcessed","_isIncludedSet","_isIncluded","EnvelopeComparator","PolygonizeGraph","Polygonizer","_lineStringAdder","LineStringAdder","_dangles","_cutEdges","_invalidRingLines","_holeList","_polyList","_isCheckingRingsValid","_extractOnlyPolygonal","extractOnlyPolygonal","RelateComputer","_im","_isolatedEdges","arg","RectangleContains","_rectEnv","rectangle","RectangleLineIntersector","_diagUp0","_diagUp1","_diagDown0","_diagDown1","rectEnv","ShortCircuitedGeometryVisitor","RectangleIntersects","_rectangle","EnvelopeIntersectsVisitor","_intersects","GeometryContainsPointVisitor","_rectSeq","_containsPoint","getExteriorRing","getCoordinateSequence","RectangleIntersectsSegmentVisitor","_rectIntersector","RelateOp","_relate","GeometryCombiner","_skipEmpty","_inputGeoms","extractFactory","CascadedPolygonUnion","_inputPolys","polys","PointGeometryUnion","_pointGeom","_otherGeom","pointGeom","otherGeom","GeometryExtracter","_sortIndex","sortIndex","UnaryUnionOp","_polygons","geomFact","UnionInteracting","_g0","_g1","_interacts0","_interacts1","UnionOp","PrecisionReducerCoordinateOperation","_targetPM","_removeCollapsed","targetPM","removeCollapsed","GeometryPrecisionReducer","_changePrecisionModel","_isPointwise","DouglasPeuckerLineSimplifier","_usePt","DouglasPeuckerSimplifier","_isEnsureValidTopology","DPTransformer","isEnsureValidTopology","TaggedLineSegment","TaggedLineString","_parentLine","_segs","_resultSegs","_minimumSize","parentLine","minimumSize","LineSegmentIndex","LineSegmentVisitor","_querySeg","querySeg","TaggedLineStringSimplifier","_inputIndex","_outputIndex","_linePts","inputIndex","outputIndex","TaggedLinesSimplifier","TopologyPreservingSimplifier","_lineSimplifier","_linestringMap","LineStringTransformer","linestringMap","LineStringMapBuilderFilter","tps","SplitSegment","_segLen","_splitPt","_minimumLen","getLength","ConstraintSplitPointFinder","NonEncroachingSplitPointFinder","TrianglePredicate","Vertex","_z","ConstraintVertex","_isOnConstraint","_constraint","QuadEdge","_rot","_vertex","IncrementalDelaunayTriangulator","_subdiv","_isUsingTolerance","subdiv","getTolerance","QuadEdgeLocator","LastFoundQuadEdgeLocator","_lastEdge","LocateFailureException","msgWithSpatial","TriangleVisitor","QuadEdgeSubdivision","_visitedKey","_quadEdges","_startingEdge","_tolerance","_edgeCoincidenceTolerance","_frameVertex","_frameEnv","_locator","_triEdges","EDGE_COINCIDENCE_TOL_FACTOR","createFrame","initSubdiv","TriangleCircumcentreVisitor","TriangleEdgesListVisitor","_triList","TriangleVertexListVisitor","TriangleCoordinatesVisitor","_coordList","_triCoords","Segment","_ls","z1","z2","KdNodeVisitor","KdNode","_left","_right","_count","KdTree","_numberOfNodes","BestMatchVisitor","_matchNode","_matchDist","ConformingDelaunayTriangulator","_initialVertices","_segVertices","_segments","_incDel","_convexHull","_splitFinder","_kdt","_vertexFactory","_computeAreaEnv","initialVertices","DelaunayTriangulationBuilder","_siteCoords","ConformingDelaunayTriangulationBuilder","_constraintLines","_constraintVertexMap","VoronoiDiagramBuilder","_clipEnv","_diagramEnv","LinearLocation","_componentIndex","_segmentIndex","_segmentFraction","loc","segmentFraction","componentIndex","normalize","doNormalize","LinearIterator","_linearGeom","_numLines","_currentLine","_vertexIndex","linear","getComponentIndex","segmentEndVertexIndex","linearGeom","vertexIndex","loadCurrentLine","LocationIndexOfPoint","LocationIndexOfLine","LinearGeometryBuilder","_ignoreInvalidLines","_fixInvalidLines","_lastPt","ExtractLineByLocation","LocationIndexedLine","checkGeometryType","LengthIndexOfPoint","LengthLocationMap","LengthIndexedLine","union$1","poly1","poly2","reader","read","JSON","stringify","union","write","bbox$1","BBox","projection","convertToMercator","convertToWgs84","newCoord","lonLat","D2R","MAXEXTENT","xy","sign","tan","R2D","atan","exp","adder","Adder","reset","_add","s","bv","av","halfPi","noop","streamGeometry","stream","streamGeometryType","streamLine","streamPolygon","polygonStart","polygonEnd","spherical","cartesian","lambda","phi","cosPhi","cartesianDot","cartesianCross","cartesianAddInPlace","cartesianScale","vector","cartesianNormalizeInPlace","d","compose","invert","rotationIdentity","tau","rotateRadians","deltaLambda","deltaPhi","deltaGamma","rotationLambda","rotationPhiGamma","forwardRotationLambda","rotation","cosDeltaPhi","sinDeltaPhi","cosDeltaGamma","sinDeltaGamma","circleRadius","cosRadius","radius","acos","epsilon","clipBuffer","rejoin","shift","pointEqual","Intersection","clipPolygon","segments","compareIntersection","startInside","interpolate","subject","clip","segment","link","current","isSubject","ascending","NaN","merge$1","arrays","clipExtent","visible","a1","corner","comparePoint","ca","cb","activeStream","linePoint","x__","y__","v__","v_","x_","clipMin","clipMax","y_","ax","ay","t0","t1","clipLine","clean","bufferStream","clipStream","winding","a0","b0","b1","polygonInside","cleanInside","identity$3","pointVisible","rotate","sink","pointLine","pointRing","ringSink","ringSegments","ringBuffer","polygonStarted","validSegment","rotatedStart","normal","angle","sum$1","point0","lambda0","phi0","quarterPi","sinPhi0","cosPhi0","lambda1","sinPhi1","cosPhi1","point1","phi1","absDelta","antimeridian","intersection","phiArc","polygonContains","sphere","clipCircle","cr","intersect","two","n2n2","n1n2","determinant","c1","c2","n1xn2","u","uu","t2","q","polar","code","smallRadius","notHemisphere","c0","v0","v00","_clean","point2","sinRadius","step","circleStream","transformer","methods","TransformStream","fitExtent","extent","h","streamObjectType","geoStream","boundsStream$1","resample","project","delta2","resampleLineTo","d2","phi2","lambda2","dx2","dy2","dz","cosMinDistance","resampleStream","maxDepth","ringPoint","lambda00","x00","y00","a00","b00","c00","resample$1","resampleNone","projectAt","projectRotate","projectTransform","recenter","center","cacheStream","theta","preclip","clipAntimeridian","postclip","projectResample","transformRadians","clipAngle","precision","fitSize","projectionMutator","mercatorRaw","mercatorProjection","reclip","forward","transverseMercatorRaw","bufferFeature","steps","results","buffered","projected","needsTransverseMercator","projectCoords","defineProjection","toMercator","bufferOp","coordsIsNaN","unprojectCoords","toWgs84","proj","ext","geoTransverseMercator","earthRadius$1","createbuffer","comment","Marker","multiBuffered","buffer$1","inRing","ignoreBoundary","isInside","xi","yi","xj","yj","pointInPolygon","sourceArray","geojsonPolygon","pointsInside","pointsOutside","inBBox","insidePoly","inHole","booleanPointInPolygon","marker","getPosition","markerToFeaturePoint","kinks$1","Wicket","featureIn","line1","line2","line1StartX","line1StartY","line1EndX","line1EndY","line2StartX","line2StartY","line2EndX","line2EndY","denominator","numerator1","numerator2","onLine1","onLine2","lineIntersects","kinks","feature$6","isObject$5","validateBBox$3","validateId$3","polygon$4","isNumber$4","featureCollection$4","flattenEach$3","geomEach$3","multiFeatureIndex","partialSort","arr","compare","sd","floor","swap","tmp","rbush","maxEntries","format","_maxEntries","_minEntries","_initFormat","calcBBox","node","toBBox","distBBox","children","destNode","createNode","minX","minY","maxX","maxY","child","extend$1","leaf","compareNodeMinX","compareNodeMinY","bboxArea","bboxMargin","contains$1","intersects","height","multiSelect","quickselect$2","booleanPointInPolygon$1","getCoord$2","getCoords$2","inBBox$1","inRing$1","equalArrays$1","array1","righthanded","equalArrays$2","unkink","featureEach$3","simplepolygon","unkinkPolygon","baseExtremum","comparator","computed","baseGt","baseLt","quickselect$3","quickselectStep","swap$1","rbush$1","calcBBox$1","distBBox$1","createNode$1","extend$2","compareNodeMinX$1","compareNodeMinY$1","bboxArea$1","bboxMargin$1","contains$2","intersects$1","multiSelect$1","bboxPolygon","lowLeft","topLeft","topRight","turfBBox","feature$7","isObject$6","validateBBox$4","validateId$4","isNumber$5","getCoords$3","flattenEach$4","geomEach$4","lineSegment","reduce","previousCoords","currentCoords","lineString$5","bbox$2","createSegments","lineSegmentFeature","featureCollection$5","feature$8","isObject$7","validateBBox$5","validateId$5","featureCollection$6","isNumber$6","getCoords$4","featureEach$5","lineIntersect","unique","intersects$2","tree","load","remove","search","collides","all","toJSON","fromJSON","json","geojsonRbush","x3","y3","x4","y4","denom","numeA","numeB","uA","uB","point$6","nearestPointOnLine","closestPt","sectionLength","heightDistance","perpendicularPt1","perpendicularPt2","intersectPt","lineSlice","startPt","stopPt","startVertex","stopVertex","clipCoords","diffCoords","coord1","coord2","findLineIntersection","line1Start","line1End","line2Start","line2End","intersectionFC","traverseRings","ring1","ring2","intersections","samering","isEqual","FeatureIntersection","position1","position2","trimPaths","arrayLatLng1","arrayLatLng2","sliced1","sliced2","first_segment_with_kinks","min$1","chosenIntersection","max$1","kink","intersectLatLng","beginsWith","endsWith","Symbol","_wrapped","sub","substring","delimiter","trim","initializer","wrapVertices","regExes","typeStr","spaces","numeric","comma","parenComma","doubleParenComma","trimParens","ogcTypes","crudeJson","components","isCollection","sameCoords","deconstruct","isRectangle","config","construct","iring","oring","cs","exec","toUpperCase","wkt","prefix","matches","base","ingest","console","pieces","_point","multipoint","_multipoint","parts","linestring","_linestring","multilinestring","_multilinestring","_polygon","multipolygon","_multipolygon","box","_box","geometrycollection","split","parseFloat","multipoints","replace","subcomponents","x_cord","y_cord","optimized","editable","LatLngBounds","Rectangle","verts","paths","reverseInnerPolygons","multiFlag","response","vertex","linestrings","computeSignedArea","getAt","areas","getPaths","lastIndexOf","Circle","getCenter","getRadius","d2r","rlat","rlng","getSouthWest","getNorthEast","getBounds","Data","getGeometry","freeGlobal","freeSelf","self","root","Function","_Symbol","objectProto","toStringTag","coreJsData","uid","IE_PROTO","funcProto$1","objectProto$2","funcToString$1","hasOwnProperty$1","RegExp","Map$1","nativeCreate","HASH_UNDEFINED","hasOwnProperty$2","hasOwnProperty$3","HASH_UNDEFINED$1","string","LARGE_ARRAY_SIZE","pairs","HASH_UNDEFINED$2","symbolProto","valueOf","propertyIsEnumerable","nativeGetSymbols","getOwnPropertySymbols","symbol","objectProto$6","hasOwnProperty$4","propertyIsEnumerable$1","freeExports","nodeType","freeModule","Buffer","typedArrayTags","freeExports$1","freeModule$1","freeProcess","process","nodeUtil","binding","nodeIsTypedArray","baseUnary","overArg","DataView","Promise$1","Set","WeakMap","dataViewCtorString","mapCtorString","promiseCtorString","setCtorString","weakMapCtorString","getTag","ArrayBuffer","resolve","ctorString","MAX_MEMOIZE_SIZE","reLeadingDot","rePropName","reEscapeChar","memoizeCapped","number","quote","symbolProto$1","baseFor","fromRight","iterable","props","createBaseFor","eachFunc","createBaseEach","meters","metres","millimeters","millimetres","centimeters","centimetres","kilometers","kilometres","miles","nauticalmiles","inches","yards","feet","debug","bind","Float64Array","Uint32Array","getClass","equalsWithTolerance","doubleToLongBits","longBitsToDouble","isInfinite","isFinite","shouldNeverReachHere","assertion","expectedValue","actualValue","setOrdinate","ordinateIndex","X","Y","Z","getOrdinate","equals3D","equalInZ","CloneNotSupportedException","distance3D","hashCode","setCoordinate","trunc","o1","o2","compX","compY","serialVersionUID","hasNext","toArray","element","oldElement","Iterator_","found","arrayList","arrayList_","position_","coll","isChanged","toCoordinateArray","coordArrayType","inc","getArea","getWidth","getHeight","otherEnvelope","isNull","intMinX","intMinY","covers","expandToInclude","minExtent","transX","transY","setToNull","maxExtent","expandBy","deltaX","deltaY","contains","centre","minq","maxq","minp","maxp","toLocationSymbol","locationValue","log10","ln","LOG_10","v1","v2","v3","v4","clamp","wrap","average","append","setCharAt","substr","intValue","isWhitespace","le","extractSignificantDigits","insertDecimalPoint","magnitude","mag","TEN","divide","gt","lt","ONE","multiply","decimalPointPos","buf","numDigits","MAX_PRINT_DIGITS","digit","rebiasBy10","digitChar","subtract","selfAdd","continueExtractingDigits","remMag","sqr","doubleValue","negate","isZero","selfSubtract","getSpecialNumberString","selfDivide","yhi","ylo","hc","tc","hy","ty","U","SPLIT","dump","createNaN","ge","selfMultiply","reciprocal","fhi","flo","rint","setValue","isNegative","axdd","H","S","T","zhi","zlo","hx","tx","selfSqr","ex","toStandardNotation","toSciNotation","specialStr","sigDigits","charAt","stringOfChar","numZeroes","SCI_NOT_ZERO","digits","expStr","SCI_NOT_EXPONENT_CHAR","IllegalStateException","trailingDigits","digitsWithDecimal","isPositive","signum","strlen","signCh","val","numBeforeDec","ch","isDigit","parseInt","NumberFormatException","val2","numDecPlaces","xAbs","xLog10","xMag","TWO_PI","PI_2","EPS","orientationIndex","orientationIndexFilter","dx1","dy1","signOfDet2x2","denom1","denom2","numx1","numx2","fracP","numy1","numy2","fracQ","pa","pb","pc","detsum","detleft","detright","det","errbound","DP_SAFE_EPSILON","getX","expandEnvelope","getY","M","arraycopy","src","srcPos","dest","destPos","getProperty","line.separator","xInt","yInt","getSortIndex","SORTINDEX_GEOMETRYCOLLECTION","getGeometryN","equalsTopo","equalsExact","geometryChanged","geometryChangedFilter","geometryChangedAction","equalsNorm","norm","compareToSameClass","comp","getUserData","getEnvelope","toGeometry","checkNotGeometryCollection","computeEnvelopeInternal","setSRID","setUserData","userData","aElement","bElement","comparison","isGeometryCollectionOrDerived","SORTINDEX_MULTIPOINT","SORTINDEX_MULTILINESTRING","SORTINDEX_MULTIPOLYGON","SORTINDEX_POINT","SORTINDEX_LINESTRING","SORTINDEX_LINEARRING","SORTINDEX_POLYGON","boundaryCount","ENDPOINT_BOUNDARY_RULE","MULTIVALENT_ENDPOINT_BOUNDARY_RULE","MONOVALENT_ENDPOINT_BOUNDARY_RULE","isRing","ptNotInList","testPts","testPt","scroll","firstCoordinate","newCoordinates","coordinateComparator","coordList","hasRepeatedPoints","removeRepeatedPoints","removeNull","nonNull","copyDeep","srcStart","destStart","isEqualReversed","pts1","pts2","envelope","atLeastNCoordinatesOrNothing","increasingDirection","minCoordinate","minCoord","npts","extractPts","iPts","forwardComp","OLDcompare","dir1","dir2","i1","i2","comparePt","entrySet","javascript","util","Iterator_$1","hashSet","hashSet_","cmp","getKey","oldValue","fixAfterInsertion","rotateLeft","rotateRight","getFirstEntry","successor","Iterator_$2","treeSet_","asList","toDimensionSymbol","dimensionValue","SYM_FALSE","TRUE","SYM_TRUE","DONTCARE","SYM_DONTCARE","P","SYM_P","L","SYM_L","SYM_A","toDimensionValue","dimensionSymbol","seq","isDone","isGeometryChanged","childCoordinates","isEquivalentClass","otherCollection","getBoundaryDimension","sum","numPoints","revGeoms","createGeometryCollection","theseElements","otherElements","gc","thisGeom","holeComp","getBoundary","getGeometryType","nLines","revLines","createMultiLineString","boundaryMultiLineString","mLine","getEmptyMultiPoint","bdyPts","computeBoundaryCoordinates","createPoint","createMultiPointFromCoords","boundaryLineString","getStartPoint","createMultiPoint","getEndPoint","addEndpoint","getCoordinateN","it","valence","bop","chars","getStackTrace","os","ps","printStackTrace","stackTrace","lineNumberReader","readLine","NEWLINE","separator","separatorlen","tokenList","tmpString","pos","token","res","SIMPLE_ORDINATE_FORMAT","copyCoord","minDim","dim","cs1","cs2","cs1Size","fact","newseq","ensureValidRing","createClosedRing","isSimple","otherLineString","getPointN","computeLength","createLineString","isCoordinate","shellCoordinates","signedArea","getNumInteriorRing","prevX","prevY","otherPolygon","thisShell","otherPolygonShell","clockwise","uniqueCoordinates","isCCW","convexHull","otherShell","shellComp","nHole1","nHole2","thisHole","getInteriorRingN","otherHole","isValid","MINIMUM_VALID_SIZE","createMultiPolygon","allRings","allRingsArray","setCopyUserData","isUserDataCopied","edit","operation","editInternal","editGeometryCollection","editPolygon","getName","collectionForType","newPolygon","createPolygon","hole","editCoordinates","cloneCoordinates","strBuf","readResolve","instance","instanceObject","defineProperty$1","defineProperty","MapPolyfill","proto","objectOnly","_keys","_itp","createCollection","delete","Map","otherPrecisionModel","getMaximumSignificantDigits","otherSigDigits","isFloating","FLOATING_SINGLE","description","makePrecise","maxSigDigits","mostPrecise","pm1","pm2","maximumPreciseValue","buildGeometry","geomList","geomClass","isHeterogeneous","hasGeometryCollection","partClass","toGeometryArray","geom0","toPolygonArray","toLineStringArray","toPointArray","createGeometry","ptSeq","toMultiPolygonArray","multiPolygons","multiPolygonArray","geometryArray","toMultiLineStringArray","multiLineStrings","multiLineStringArray","lineStringArray","toMultiPointArray","multiPoints","multiPointArray","toLinearRingArray","linearRings","linearRingArray","pointArray","polygonArray","createPointFromInternalCoord","exemplar","emptyTypeStr","extract$1","wktType","_coordinate","linearring","_linearring","wktArray","toLineString","getIndexAlongSegment","intIndex","computeIntLineIndex","getTopologySummary","catBuf","isEndPoint","isCollinear","computeIntersection","p3","p4","computeIntersect","getIntersectionNum","getEdgeDistance","isProper","hasIntersection","isInteriorIntersection","inputLineIndex","getIntersection","NO_INTERSECTION","computeEdgeDistance","COLLINEAR_INTERSECTION","getEndpoint","ptIndex","isIntersection","getIntersectionAlongSegment","pdx","pdy","nonRobustComputeEdgeDistance","DONT_INTERSECT","DO_INTERSECT","COLLINEAR","POINT_INTERSECTION","isInSegmentEnvelopes","intPt","env0","normalizeToMinimum","n3","n4","normPt","smallestInAbsValue","safeHCoordinateIntersection","nearestEndpoint","intersectionWithNormalization","xabs","checkDD","intPtDD","isIn","out","println","normalizeToEnvCentre","computeCollinearIntersection","p1q1p2","p1q2p2","q1p1q2","q1p2q2","n00","n01","n10","n11","minX0","minY0","maxX0","maxY0","minX1","minY1","maxX1","maxY1","intMidX","intMidY","Pq1","Pq2","Qp1","Qp2","nearestPt","minDist","distancePointLine","countSegment","minx","maxx","xIntSign","isPointInPolygon","getLocation","isOnSegment","locatePointInRing","distanceLineLine","noIntersection","r_num","isPointInRing","nPts","hiPt","hiIndex","iPrev","iNext","prev","disc","computeOrientation","distancePointLinePerpendicular","len2","minDistance","isOnLine","lineIntersector","CLOCKWISE","STRAIGHT","orient0","orient1","isVertical","projectionFactor","pf0","pf1","newp0","newp1","distancePerpendicular","midPoint","closestPoints","close00","closestPoint","close01","close10","close11","comp0","temp","lineIntersection","pointAlongOffset","segmentLengthFraction","offsetDistance","segx","segy","ux","uy","setCoordinates","inputPt","segFrac","isHorizontal","pointAlong","bits0","java","lang","hash0","bits1","isIntersects","isDisjoint","isCovers","isCoveredBy","dimensionSymbols","row","col","column","isContains","setAtLeast","minimumDimensionSymbols","minimumDimensionValue","setAtLeastIfValid","isWithin","isTouches","dimensionOfGeometryA","dimensionOfGeometryB","isOverlaps","isEquals","ai","bi","transpose","requiredDimensionSymbols","im","isCrosses","actualDimensionValue","requiredDimensionSymbol","actualDimensionSymbols","addPoint","setBasePoint","basePt","addLineSegments","lineLen","segmentLen","midx","midy","addHole","isPositiveArea","addTriangle","cent","addShell","centroid3","area2","IndexOutOfBoundsException","peek","preSort","computeOctRing","inputPts","octPts","computeOctPts","lineOrPolygon","cleanRing","linearRing","original","cleanedRing","previousDistinctCoordinate","currentCoordinate","nextCoordinate","isBetween","cleanedRingCoordinates","c3","polyPts","reducedSet","reducedPts","padArray3","getConvexHull","sortedPts","cHS","grahamScan","cH","pad","polarCompare","dxp","dyp","dxq","dyq","orient","oq","transformCoordinates","transformPolygon","isAllValidLinearRings","transformLinearRing","createCoordinateSequence","getInputGeometry","transformMultiLineString","transGeomList","transformGeom","transformLineString","transformMultiPoint","transformMultiPolygon","transformGeometryCollection","seqSize","snapVertices","srcCoords","srcPt","snapVert","findSnapForVertex","snapTo","snapSegments","distinctPtCount","snapPt","findSegmentIndexToSnap","snapIndex","setAllowSnappingToSourceVertices","allowSnappingToSourceVertices","snapGeom","extractTargetCoordinates","snapToSelf","cleanResult","snappedGeom","ringPts","computeMinimumSegmentLength","ptSet","minSegLen","segLen","snap","snapper0","snapper1","computeOverlaySnapTolerance","computeSizeBasedSnapTolerance","fixedSnapTol","SNAP_PRECISION_FACTOR","snapLine","snapper","newPts","getCommon","numBits","signExpBits","numCommonMostSigMantissaBits","zeroLowerBits","bits","padStr","Long","toBinaryString","bitStr","getBit","nBits","num1","num2","addCommonBits","removeCommonBits","invCoord","getCommonCoordinate","xp","yp","isAtomic","UnsupportedOperationException","locateInternal","shellLoc","locateInPolygonRing","holeLoc","locate","updateLocationInfo","computeLocation","ml","mpoly","geomi","octant","adx","ady","setData","getData","getSegmentOctant","getItem","poll","minItem","reorder","visitItem","query","getLevel","getChildBoundables","addChildBoundable","childBoundable","computeBounds","Collections","reverseOrder","alen","singletonList","expandToQueue","priQ","isComp1","isComposite","isComp2","expand","isLeaves","nd","bndComposite","bndOther","bp","getDistance","getBoundable","getNodeCapacity","lastNode","nodes","build","removeItem","childToRemove","itemsTree","valuesTree","valuesTreeForNode","valuesTreeForChild","boundablesAtLevel","boundables","top","boundable","searchBounds","getIntersectsOp","visitor","childBoundables","createHigherLevels","getRoot","childToPrune","boundablesOfALevel","parentBoundables","createParentBoundables","maxChildDepth","childDepth","newLevel","sortedChildBoundables","getComparator","compareDoubles","IntersectsOp","item1","item2","createParentBoundablesFromVerticalSlices","verticalSlices","createParentBoundablesFromVerticalSlice","intersectsOp","sliceCount","sliceCapacity","slices","boundablesAddedToSlice","searchEnv","yComparator","minLeafCount","xComparator","nearestNeighbour","itemDist","initBndPair","distanceLowerBound","minPair","bndPair","currentDistance","bnd","centreX","centreY","aBounds","bBounds","relativeSign","xSign","ySign","compareValue","compareSign0","compareSign1","print","maxSegmentIndex","isInterior","getSplitCoordinates","eiPrev","ei","addEdgeCoordinates","addCollapsedNodes","collapsedVertexIndexes","findCollapsesFromInsertedNodes","findCollapsesFromExistingVertices","ei0","ei1","lastSegStartPt","useIntPt1","addSplitEdges","edgeList","newEdge","createSplitEdge","findCollapseIndex","collapsedVertexIndex","numVerticesBetween","maxSegIndex","ipt","eiNew","checkSplitEdgesCorrectness","splitEdges","edgePts","pt0","splitnPts","ptn","addIntersection","safeOctant","addIntersectionNode","getNodeList","normalizedSegmentIndex","nextSegIndex","nextPt","addIntersections","getNodedSubstrings","resultEdgelist","overlap","mc1","start1","mc2","start2","getLineSegment","computeSelect","start0","end0","mcs","select","computeOverlaps","mc","mco","computeOverlapsInternal","setId","getEndIndex","getStartIndex","getContext","getId","end1","p00","p01","p10","p11","mid0","mid1","isNorthern","quad","NE","NW","isOpposite","quad1","quad2","commonHalfPlane","isInHalfPlane","halfPlane","SE","SW","startIndexList","findChainEnd","toIntArray","safeStart","chainQuad","getChains","mcList","computeNodes","getMonotoneChains","getIndex","segStr","inputSegStrings","intersectChains","overlapAction","queryChain","testChain","ss1","ss2","processIntersections","e0","segIndex0","segIndex1","getInteriorIntersection","setCheckEndSegmentsOnly","isCheckEndSegmentsOnly","getIntersectionSegments","getIntersections","setFindAllIntersections","findAllIntersections","setKeepIntersections","keepIntersections","isEndSegment","createAllIntersectionsFinder","finder","createAnyIntersectionFinder","createIntersectionCounter","execute","checkInteriorIntersections","checkValid","getErrorMessage","intSegs","computeIntersections","nv","mapped","opposite","setAllLocations","locValue","setAllLocationsIfNull","isLine","newLoc","getLocations","flip","posIndex","isArea","isAnyNull","locIndex","isEqualOnSide","allPositionsEqual","getGeometryCount","side","toLine","toLineLabel","lineLabel","isIsolated","de","isFirstEdge","getEdgeRing","mergeLabel","addPoints","setEdgeRing","getNext","getLinearRing","computeMaxNodeDegree","getNode","getEdges","getOutgoingDegree","isHole","setInResult","containsPoint","isShell","getMaxNodeDegree","getShell","deLabel","setShell","toPolygon","holeLR","er","setMinEdgeRing","getNextMin","buildMinimalRings","minEdgeRings","getMinEdgeRing","minEr","linkDirectedEdgesForMinimalEdgeRings","linkMinimalDirectedEdges","setVisited","isVisited","isInResult","isCovered","isCoveredSet","setLabel","setCovered","updateIM","computeIM","isIncidentEdgeInResult","computeMergedLocation","label2","eltIndex","nLoc","onLocation","setNode","setLabelBoundary","find","addNode","getBoundaryNodes","bdyNodes","compareDirection","getDy","className","lastDotPos","getDx","getQuadrant","computeLabel","getDepth","setDepth","depthVal","isInteriorAreaEdge","setNextMin","nextMin","getDepthDelta","minEdgeRing","isLineEdge","isExteriorIfArea0","isExteriorIfArea1","edgeRing","depthDelta","getSym","printEdge","printReverse","setSym","setVisitedEdge","setEdgeDepths","directionFactor","oppositePos","oppositeDepth","setNext","depthFactor","currLocation","nextLocation","printEdges","getNodeIterator","linkResultDirectedEdges","nodeit","debugPrintln","isBoundaryNode","linkAllDirectedEdges","matchInSameDirection","ep0","ep1","getEdgeEnds","debugPrint","getEdgeIterator","findEdgeInSameDirection","eCoord","insertEdge","findEdgeEnd","ee","addEdges","edgesToAdd","de2","getNodes","findEdge","sortShellsAndHoles","edgeRings","shellList","freeHoleList","computePolygons","resultPolyList","placeFreeHoles","findEdgeRingContaining","buildMinimalEdgeRings","maxEdgeRings","findShell","placePolygonHoles","buildMaximalEdgeRings","dirEdges","getPolygons","testEr","testRing","testEnv","minShell","minEnv","tryShell","tryRing","tryEnv","isContained","shellCount","collectLines","opCode","getGraph","collectLineEdge","collectBoundaryTouchEdge","labelIsolatedLine","targetIndex","getArgGeometry","findCoveredLineEdges","buildLines","isResultOfOp","isCoveredByA","labelIsolatedLines","edgesList","INTERSECTION","filterCoveredNodeToPoint","isCoveredByLA","extractNonCoveredResultNodes","getDegree","containsPointInPolygon","getNextCW","iNextCW","propagateSideLabels","startLoc","currLoc","isAreaLabelsConsistent","computeEdgeEndLabels","getBoundaryNodeRule","checkAreaLabelsConsistent","lastEdgeIndex","findIndex","eSearch","computeLabelling","hasDimensionalCollapseEdge","insertEdgeEnd","getResultAreaEdges","firstOut","incoming","state","nextOut","nextIn","getRightmostEdge","deLast","quad0","updateLabelling","nodeLabel","prevOut","firstIn","computeDepths","edgeIndex","startDepth","targetLastDepth","nextDepth","endIndex","currDepth","nextDe","mergeSymLabels","eLabel","eLoc","computeIntersectsForChain","isDelete","setDeleteEventIndex","deleteEventIndex","getObject","pe","getInsertEvent","isInsert","isSameLabel","ev","getDeleteEventIndex","isTrivialIntersection","isAdjacentSegments","getProperIntersectionPoint","setIsDoneIfProperInt","isDoneWhenProperInt","hasProperInteriorIntersection","isBoundaryPointInternal","hasProperIntersection","isBoundaryPoint","setBoundaryNodes","bdyNodes0","bdyNodes1","setIsolated","prepareEvents","processOverlaps","edges0","edges1","addEdge","edgeSet","getMonotoneChainEdge","getStartIndexes","ev0","mc0","ev1","queryMin","queryMax","mid2","buildTree","IntervalRTreeNode","buildLevel","buildRoot","printNode","setForceToLineString","getLines","forceToLineString","getItems","rcc","addLine","getSegmentIndex","chainIndex0","chainIndex1","computeIntersects","depthValue","minDepth","newValue","getDelta","depthAtLocation","getCollapsedEdge","setName","isEqualForward","isEqualReverse","iRev","isCollapsed","getMaximumSegmentIndex","isPointwiseEqual","setDepthDelta","getEdgeIntersectionList","insertBoundaryPoint","determineBoundary","computeSelfNodes","computeRingSelfNodes","isDoneIfProperInt","esi","createEdgeSetIntersector","isRings","computeAllSegments","addSelfIntersectionNodes","computeSplitEdges","edgelist","computeEdgeIntersections","hasTooFewPoints","insertPoint","addPolygon","addPolygonRing","addLineString","getInvalidPoint","getBoundaryPoints","addSelfIntersectionNode","lr","cwLeft","cwRight","eiIt","addCollection","oca","compareOriented","orientation1","orientation2","limit1","limit2","compPt","done1","done2","edgeColl","findEdgeIndex","findEqualEdge","insertUniqueEdge","existingEdge","existingLabel","labelToMerge","cancelDuplicateResultEdges","sym","computeGeometry","resultPointList","resultLineList","opcode","createEmptyResult","replaceCollapsedEdges","newEdges","updateNodeLabelling","getResultGeometry","overlayOpCode","computeOverlay","insertUniqueEdges","copyPoints","baseSplitEdges","computeLabelsFromDepths","labelIncompleteNodes","findResultAreaEdges","polyBuilder","lineBuilder","pointBuilder","labelIncompleteNode","graphNode","ni","overlayOp","geom1","MapOp","symDifference","SYMDIFFERENCE","resultDimension","dim0","dim1","UNION","DIFFERENCE","difference","loc0","loc1","selfSnap","remGeom","prepareResult","prepGeom","isSuccess","savedException","width","bisector","horizontalBisector","widestIntersection","widestGeometry","getInteriorPoint","bisectY","getBisectorY","updateInterval","hasChildren","isPrunable","hasItems","addAllItems","items","subSize","addAllItemsFromOverlapping","resultItems","isSearchMatch","itemInterval","maxSubDepth","sqd","nodeSize","getSubnodeIndex","subnodeIndex","overlaps","exponent","NumW","Qty","Sign","Expo","Mant","Bin","ExW","32","64","CVTFWD","powerOf2","getInterval","computeLevel","computeInterval","getPoint","searchInterval","childNode","createSubnode","getSubnode","createExpanded","addInterval","expandInt","largerNode","isZeroWidth","maxAbs","MIN_BINARY_EXPONENT","insertContained","collectStats","insertInterval","ensureExtent","foundItems","del","testLineSegment","mcEnv","testMonotoneChain","rayEnv","mcSelecter","segs","toDegrees","PI_TIMES_2","isAcute","dx0","dy0","isObtuse","interiorAngle","anglePrev","angleNext","normalizePositive","angleBetween","tip1","tail","tip2","a2","diff","ang1","ang2","delAngle","toRadians","angleDegrees","getTurn","crossproduct","angleBetweenOriented","angDel","PI_OVER_2","PI_OVER_4","interpolateZ","longestSideLength","circumcentre","area3D","centroid","inCentre","m00","m01","m10","m11","lenAB","lenBC","lenCA","maxLen","cx","cy","bx","by","perpendicularBisector","angleBisector","len0","frac","uz","vx","vy","vz","crossx","crossy","crossz","absSq","len1","circum","compute","getDiameter","getExtremalPoints","computeCirclePoints","hullPts","lowestPoint","Q","pointWitMinAngleWithX","R","pointWithMinAngleWithSegment","computeCentre","getFarthestPoints","getCircle","centrePoint","getCentre","minSin","minAngPt","minAng","ang","getWidthCoordinate","computeMinimumDiameter","getSupportingSegment","computeWidthConvex","convexGeom","computeConvexRingMinDiameter","currMaxIndex","findMaxPerpDistance","maxPerpDistance","nextPerpDistance","maxIndex","getMinimumRectangle","minPara","maxPara","minPerp","maxPerp","paraC","computeC","perpC","maxPerpLine","computeSegmentForLine","minPerpLine","maxParaLine","minParaLine","getMinimumDiameter","setDistanceTolerance","densifyPoints","precModel","densifiedSegCount","densifiedSegLen","segFract","densify","densifier","roughGeom","createValidArea","roughAreaGeom","oNext","insertAfter","ecmp","ePrev","save","compareAngularDirection","quadrant2","prevNode","mark","setMark","isMarked","setMarkBoth","markBoth","eAdj","eAdjDest","createEdge","isValidEdge","eSame","getVertexEdges","setStart","isStart","updateRingStartEdge","getResult","computeResult","eNode","stackEdges","buildRing","eStartRing","eNext","buildLine","eStart","lineString","doneStart","getNodeCount","visitItems","visit","centrex","centrey","computeQuadLevel","quadSize","miny","maxy","insertNode","addEnv","expandEnv","isZeroX","isZeroY","insertEnv","queryAll","posEnv","delX","delY","geometryTypes","parse$1","extract$2","featureCollection","geoJson","shellGeoJson","holeGeoJson","reducePrecision","olReference","ol","convertFromPoint","convertFromLineString","convertFromLinearRing","convertFromPolygon","convertFromMultiPoint","convertFromMultiLineString","convertFromMultiPolygon","convertFromCollection","getLinearRings","multiPoint","getPoints","multiLineString","getLineStrings","multiPolygon","getGeometries","convertToPoint","convertToLineString","convertToLinearRing","convertToPolygon","convertToMultiPoint","convertToMultiLineString","convertToMultiPolygon","convertToCollection","geometryCollection","rescale","ss","nodedSegmentStrings","roundPts","splitSS","intSegStrings","isSimpleMultiPoint","mp","isSimplePolygonal","isSimpleLinearGeometry","hasClosedEndpointIntersection","endPoints","eiInfo","getNonSimpleLocation","hasNonEndpointIntersection","computeSimple","isSimpleGeometryCollection","getEndCapStyle","isSingleSided","quadSegs","JOIN_BEVEL","JOIN_MITRE","setSimplifyFactor","simplifyFactor","getSimplifyFactor","getMitreLimit","setSingleSided","bufferDistanceError","alpha","CAP_FLAT","CAP_SQUARE","getRightmostSide","getRightmostSideOfSegment","checkForRightmostCoordinate","findRightmostEdgeAtVertex","pPrev","pNext","usePrev","findRightmostEdgeAtNode","star","dirEdgeList","addLast","removeFirst","clearVisitedEdges","getRightmostCoordinate","computeNodeDepth","startEdge","copySymDepths","computeDepth","outsideDepth","addReachable","findResultEdges","nodesVisited","nodeQueue","startNode","adjNode","edgeEnv","nodeStack","symNode","getDirectedEdges","isDeletable","i0","distanceTol","isConcave","isShallow","isShallowSampled","deleteShallowConcavities","midIndex","findNextNonDeletedIndex","lastIndex","isMiddleVertexDeleted","isShallowConcavity","NUM_PTS_TO_CHECK","collapseLine","INIT","KEEP","COORDINATE_ARRAY_TYPE","addPt","bufPt","isRedundant","addPts","lastPt","setMinimumVertexDistance","minimimVertexDistance","addNextSegment","addStartPoint","computeOffsetSegment","outsideTurn","addCollinear","addOutsideTurn","addInsideTurn","addLineEndCap","offsetL","offsetR","addFilletArc","squareCapSideOffset","squareCapLOffset","squareCapROffset","addMitreJoin","offset0","offset1","isMitreWithinLimit","addLimitedMitreJoin","addFilletCorner","startAngle","endAngle","OFFSET_SEGMENT_SEPARATION_FACTOR","addBevelJoin","createSquare","addSegments","addFirstSegment","addLastSegment","initSideSegments","ang0","angDiffHalf","midAng","mitreMidAng","mitreDist","bevelHalfLen","mitreMidLine","bevelEndLeft","bevelEndRight","sideSign","totalAngle","nSegs","currAngleInc","currAngle","INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR","createCircle","CURVE_VERTEX_SNAP_DISTANCE_FACTOR","hasNarrowConcaveAngle","getOffsetCurve","isRightSide","posDistance","segGen","getSegGen","computePointCurve","computeOffsetCurve","curvePts","computeSingleSidedBufferCurve","distTol","simplifyTolerance","simp2","simp1","computeRingBufferCurve","simp","computeLineBufferCurve","getLineCurve","getBufferParameters","bufDistance","getRingCurve","copyCoordinates","findStabbedSegments","stabbingRayLeftPt","stabbedSegments","bsg","dirEdge","ds","orientIndex","compareX","seg0","seg1","compare0","curve","addCurve","offsetSide","shellCoord","isErodedCompletely","holeCoord","isTriangleErodedCompletely","triangleCoord","bufferDistance","tri","getCurves","cwLeftLoc","cwRightLoc","ringCoord","envMinDimension","getLineIntersector","hasInteriorIntersection","setWorkingPrecisionModel","mergeDelta","newDelta","buildSubgraphs","subgraphList","processedGraphs","subgraph","createSubgraphs","createEmptyResultGeometry","getNoder","bufferSegStrList","computeNodedEdges","oldLabel","setNoder","lLoc","rLoc","convertSegStrings","checkEndPtVertexIntersections","ss0","pts0","checkCollapses","checkCollapse","intersectsScaled","segMinx","segMaxx","segMiny","segMaxy","isOutsidePixelEnv","intersectsToleranceSquare","copyScaled","pScaled","getSafeEnvelope","safeTolerance","SAFE_ENV_EXPANSION_FACTOR","intersectsPixelClosure","intersectsLeft","intersectsBottom","addSnappedNode","pixelEnv","hotPixelSnapAction","isNodeAdded","getInteriorIntersections","checkCorrectness","inputSegmentStrings","snapRound","findInteriorIntersections","computeIntersectionSnaps","computeVertexSnaps","intFinderAdder","edge0","bufferFixedPrecision","fixedPM","bufBuilder","bufferReducedPrecision","precDigits","MAX_PRECISION_DIGITS","precisionDigits","precisionScaleFactor","bufferOriginalPrecision","argPM","geomBuf","bufOp","maxPrecisionDigits","bufEnvMax","minUnitLog10","CAP_BUTT","isInsideArea","getGeometryComponent","computeContainmentDistance","locPtPoly","polyGeomIndex","locationsIndex","insideLocs","locs","ptLoc","computeMinDistanceLinesPoints","locGeom","computeMinDistance","computeFacetDistance","lines0","lines1","computeMinDistanceLines","updateMinDistance","computeMinDistancePoints","nearestLocations","nearestPoints","coord0","segClosestPoint","line0","points0","points1","isWithinDistance","forwardDirectedEdges","reverseDirectedEdges","coordinateList","directedEdge","getEdgeDirection","getLine","setMarked","setContext","getComponentWithVisitedState","visitedState","visited","marked","isRemoved","getDirectionPt","getAngle","getFromNode","setEdge","getToNode","toEdges","getOutEdges","addOutEdge","getDirEdge","fromNode","getOppositeNode","getNextEdge","sortEdges","getNextCWEdge","modi","getEdgesBetween","node0","node1","commonEdges","retainAll","findNodesOfDegree","nodesFound","nodeIterator","dirEdgeIterator","edgeIterator","findNode","startCoordinate","endCoordinate","endNode","directedEdge0","directedEdge1","buildEdgeStringsForUnprocessedNodes","buildEdgeStringsStartingAt","buildEdgeStringsForNonDegree2Nodes","buildEdgeStringsForObviousStartNodes","getMergedLineStrings","buildEdgeStringStartingWith","buildEdgeStringsForIsolatedLoops","edgeString","isInRing","setRing","getRing","visitInteriorRing","findDifferentPoint","intDe","visitLinkedDirectedEdges","visitShellInteriors","setInteriorEdgesInResult","startDe","buildEdgeRings","hasUnvisitedShellEdge","isInteriorsConnected","createEdgeEndForNext","eiCurr","eiNext","createEdgeEndForPrev","computeEdgeEnds","computeLabelOn","foundInterior","computeLabelSide","computeLabelSides","eb","updateIMFromEdges","insertEdgeEnds","copyNodesAndLabels","nodeIt","computeIntersectionNodes","eeList","edgeIt","isNodeEdgeAreaLabelsConsistent","hasDuplicateRings","eeb","isNodeConsistentArea","intersector","getNestedPoint","isNonNested","innerRing","innerRingPts","searchRing","searchRingPts","innerRingPt","findPtNotNode","getErrorType","getMessage","errMsg","locStr","ERROR","REPEATED_POINT","HOLE_OUTSIDE_SHELL","NESTED_HOLES","DISCONNECTED_INTERIOR","SELF_INTERSECTION","RING_SELF_INTERSECTION","NESTED_SHELLS","DUPLICATE_RINGS","TOO_FEW_POINTS","INVALID_COORDINATE","RING_NOT_CLOSED","checkInvalidCoordinates","checkHolesNotNested","nestedTester","innerHole","checkConsistentArea","cat","checkShellInsideHole","shellPts","holePts","shellPt","holePt","checkNoSelfIntersectingRings","checkNoSelfIntersectingRing","checkConnectedInteriors","cit","nodeSet","isFirst","checkHolesInShell","pir","checkTooFewPoints","getValidationError","checkClosedRing","checkClosedRings","checkShellsNotNested","setSelfTouchingRingFormingHoleValid","checkShellNotNested","polyShell","badNestedPt","testCoords","isIncluded","isIncludedSet","startDE","isOuterHole","hasShell","getPolygon","isProcessed","holeER","setIncluded","getOuterHole","adjRing","computeHole","isOuterShell","getLineString","updateIncluded","adjShell","setProcessed","findDirEdgesInRing","minShellEnv","tryShellRing","tryShellEnv","obj0","obj1","r1","findEdgeRing","computeDepthParity","computeNextCWEdges","iNode","linePts","endPt","nStart","nEnd","deleteCutEdges","findLabeledEdgeRings","cutLines","getEdgeRings","maximalRings","convertMaximalToMinimalEdgeRings","edgeRingList","ringEdges","intNodes","findIntersectionNodes","computeNextCCWEdges","deleteDangles","nodesToRemove","dangleLines","deleteAllEdges","toNode","getDegreeNonDeleted","edgeRingStarts","currLabel","prevDE","outDE","firstOutDE","prevInDE","inDE","polygonize","getInvalidRingLines","findValidRings","validEdgeRingList","invalidRingList","findShellsAndHoles","assignHolesToShells","includeAll","findDisjointShells","extractPolygons","getDangles","getCutEdges","setCheckRingsValid","isCheckingRingsValid","findOuterShells","outerHoleER","polyList","holeList","assignHoleToShell","isMoreToScan","computeProperIntersectionIM","dimA","dimB","hasProper","hasProperInterior","labelIsolatedEdges","thisIndex","labelIsolatedEdge","computeDisjointIM","labelIsolatedNodes","eeBuilder","ee0","ee1","labelNodeEdges","labelIntersectionNodes","labelIsolatedNode","ga","gb","isContainedInBoundary","isPointContainedInBoundary","isLineStringContainedInBoundary","isLineSegmentContainedInBoundary","segEnv","isSegUpwards","applyTo","ecpVisitor","riVisitor","elementEnv","rectPt","checkIntersectionWithLineStrings","testLine","checkIntersectionWithSegments","seq1","getIntersectionMatrix","relate","touches","within","coveredBy","relOp","intersectionPattern","relateWithCheck","disjoint","crosses","extractElements","elems","elemGeom","combine","combiner","createList","obj2","reduceToGeometries","geomTree","unionTree","extractByEnvelope","disjointGeoms","intersectingGeoms","elem","unionOptimized","g0Env","g1Env","unionActual","commonEnv","unionUsingEnvelopeIntersection","STRTREE_NODE_CAPACITY","itemTree","binaryUnion","unionSafe","repeatedUnion","restrictToPolygons","common","disjointPolys","g0Int","g1Int","bufferUnion","unionAll","gColl","locater","exteriorCoords","ptComp","unionNoOpt","unionWithNull","unionPoints","ptGeom","unionLines","lineGeom","unionPolygons","unionLA","interacts","isInteracting","extractedGeoms","computeInteracting","elem0","interactsWithAny","int0","int1","disjoint0","disjoint1","reducedCoords","noRepeatedCoords","minLength","collapsedCoords","fixPolygonalTopology","geomToBuffer","changePM","bufGeom","finalGeom","reducePointwise","geomEdit","createFactory","finalRemoveCollapsed","newPM","createEditor","setRemoveCollapsedComponents","inputFactory","setChangePrecisionModel","changePrecisionModel","reducePW","setPointwise","isPointwise","reducer","simplifySection","maxDistance","setEnsureValid","tss","rawGeom","rawAreaGeom","removeDegenerateRings","simpResult","getParent","addToResult","asLineString","getResultSize","resultSegsSize","getSegment","getParentCoordinates","getMinimumSize","asLinearRing","getSegments","getResultCoordinates","flatten","newSeg","hasBadIntersection","sectionIndex","candidateSeg","hasBadOutputIntersection","hasBadInputIntersection","isValidToSimplify","furthestPtIndex","findFurthestPoint","maxDist","midPt","isInLineSection","taggedLines","tlss","taggedLine","splitAt","minFrac","pointAlongReverse","getConstrainedLength","setMinimumLength","minLen","getSplitPoint","findSplitPoint","encroachPt","lineSeg","midPtLen","splitSeg","projPt","projectedSplitPoint","maxSplitLen","triArea","isInCircleDDNormalized","bdx","bdy","cdx","cdy","abdet","bcdet","cadet","alift","blift","clift","checkRobustInCircle","nonRobustInCircle","isInCircleNonRobust","isInCircleDD","isInCircleDDSlow","isInCircleCC","circumCentre","toPoint","isInCircleDDFast","aTerm","triAreaDDFast","bTerm","cTerm","pTerm","cc","ccRadius","isInCircleNormalized","triAreaDDSlow","isInCircleRobust","circleCenter","hcc","nre","err","dot","magn","getZ","isInCircle","interpolateZValue","crossProduct","setZ","times","cross","classify","sa","BEHIND","BEYOND","ORIGIN","DESTINATION","BETWEEN","circumRadiusRatio","edgeLength","el","ptLen","getConstraint","setOnConstraint","isOnConstraint","setConstraint","constraint","equalsNonOriented","qe","equalsOriented","toLineSegment","dNext","lPrev","rPrev","rot","oPrev","setOrig","lNext","invRot","setDest","rNext","isLive","getPrimary","dPrev","makeEdge","q0","q3","beta","t3","t4","connect","insertSite","isVertexOfEdge","isOnEdge","insertSites","locateFromEdge","triEdges","getTriangleVertices","includeFrame","visitTriangles","isFrameVertex","getVoronoiCellPolygon","cellPts","startQE","cellPoly","setLocator","locator","ea","ec","isFrameBorderEdge","leftTri","getTriangleEdges","rightTri","vLeftTriOther","vRightTriOther","triVisitor","edgeStack","visitedEdges","fetchTriangleToVisit","isFrameEdge","getTriangleCoordinates","getTriangles","getVertices","vd","curr","edgeCount","isFrame","quadEdges","getPrimaryEdges","getVertexUniqueEdges","visitedVertices","qd","priQE","eSym","eRot","eRotSym","iter","maxIter","getVoronoiCellPolygons","cells","getVoronoiDiagram","vorCells","triPtsList","tris","triPt","locEdge","triEdge","ccVertex","checkTriangleSize","getEndZ","getStartZ","getStart","getEnd","getEndY","getStartX","getStartY","getEndX","isRepeated","getRight","setLeft","getCount","getLeft","increment","setRight","matchNode","findBestMatchNode","insertExact","queryEnv","queryNode","currentNode","odd","discriminant","searchRight","queryEnvelope","leafNode","isOddLevel","isLessThan","toCoordinates","kdnodes","includeRepeated","update","getInitialVertices","getKDT","enforceConstraints","addConstraintVertices","splits","enforceGabriel","MAX_SPLIT_ITER","getVertexFactory","getPointArray","setConstraints","segVertices","computeConvexHull","hull","findNonGabrielPoint","segRadius","closestNonGabriel","testRadius","getConstraintSegments","setSplitPointFinder","splitFinder","segsToInsert","newSegments","segsToRemove","splitVertex","createVertex","removeAll","getSubdivision","computeBoundingBox","vertexEnv","computeVertexEnvelope","allPointsEnv","setVertexFactory","vertexFactory","formInitialDelaunay","kdnode","snappedV","siteEnv","toVertices","setTolerance","setSites","extractUniqueCoordinates","coordsCopy","createSiteVertices","containsKey","createVertices","createConstraintSegments","cdt","constraintLines","constraintSegs","getDiagram","clipGeometryCollection","setClipEnvelope","clipEnv","clipPoly","clipped","isEndpoint","nseg","lineComp","toLowest","pointAlongSegmentByFraction","getSegmentFraction","setToEnd","isOnSameSegment","snapToVertex","getSegmentLength","lenToStart","lenToEnd","compareLocationValues","componentIndex1","segmentIndex1","segmentFraction1","isVertex","getEndLocation","componentIndex0","segmentIndex0","segmentFraction0","getVertexIndex","getSegmentEnd","getSegmentStart","isEndOfLine","indexOfFromStart","minIndex","minComponentIndex","minSegmentIndex","segDistance","candidateComponentIndex","candidateSegmentIndex","indexOfAfter","endLoc","closestAfter","indicesOf","subLine","locPt","subLineLoc","endLine","getLastCoordinate","rawPts","validCoordinateSequence","setFixInvalidLines","fixInvalidLines","allowRepeatedPoints","setIgnoreInvalidLines","ignoreInvalidLines","computeLinear","builder","computeLine","startSegmentIndex","lastSegmentIndex","newCoordinateArray","clampIndex","extractPoint","indexLow","isValidIndex","ptMeasure","segmentStartMeasure","segMeasureToPt","segmentNearestMeasure","projFactor","totalLength","resolveHigher","compIndex","resolveLower","forwardLength","getLocationForward","positiveIndex","locationOf","locLow","startIndex2","endIndex2","resolveStartLower","Sphere","ascendingComparator","x0$2","y0$2","sign0","sign1","sinLambda0Lambda1","clipAntimeridianIntersect","quickselect","quickselect$1","freeze","default","__moduleExports","rbush_1","_all","childBBox","nodesToSearch","_build","_splitRoot","tmpNode","_insert","equalsFn","goingUp","findItem","_condense","compareMinX","compareMinY","N","right2","right3","N2","N1","_chooseSubtree","targetNode","enlargement","minArea","minEnlargement","enlargedArea","isNode","insertPath","_split","_adjustParentBBoxes","_chooseSplitAxis","splitIndex","_chooseSplitIndex","newNode","bbox1","bbox2","minOverlap","intersectionArea","_allDistMargin","leftBBox","rightBBox","margin","siblings","compareArr","isects","filterFn","useSpatialIndex","ifIsectAddToOutput","ring0","edge1","isect","frac0","frac1","rbushTreeItem","allEdgesAsRbushTreeItems","ringA","edgeA","bboxIsect","determineParents","featuresWithoutParent","setNetWinding","netWinding","setNetWindingOfChildren","ParentNetWinding","numRings","isUnique","numvertices","selfIsectsData","numSelfIsect","outputFeatureArray","leftVtx","modulo","windingOfRing","pseudoVtxListByRingAndEdge","isectList","PseudoVtx","Isect","numIsect","param","allIsectsAsIsectRbushTreeItem","isectRbushTree","coordToFind","IsectRbushTreeItemFound","nxtIsectAlongEdgeIn","nxtIsectAlongRingAndEdge2","ringAndEdge1","ringAndEdgeIn","nxtIsectAlongRingAndEdge1","queue","leftIsect","isectAfterLeftIsect","isectBeforeLeftIsect","windingAtIsect","popped","startIsect","currentOutputRingParent","currentOutputRingWinding","currentOutputRing","currentOutputRingCoords","currentIsect","ringAndEdge1Walkable","walkingRingAndEdge","nxtIsect","ringAndEdge2","nxtIsectInQueue","ringAndEdge2Walkable","pushing","ringAndEdgeOut","findItem$1","enlargedArea$1","intersectionArea$1","ig_turfhelper"],"mappings":"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"}