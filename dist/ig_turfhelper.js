!function(e){function t(e){Object.defineProperty(this,e,{enumerable:!0,get:function(){return this[m][e]}})}function r(e){var t;if(e&&e.__esModule){t={};for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);t.__useDefault&&delete t.__useDefault,t.__esModule=!0}else{if("[object Module]"===Object.prototype.toString.call(e)||"undefined"!=typeof System&&System.isModule&&System.isModule(e))return e;t={default:e,__useDefault:!0}}return new o(t)}function o(e){Object.defineProperty(this,m,{value:e}),Object.keys(e).forEach(t,this)}function n(e){return"@node/"===e.substr(0,6)?c(e,r(v(e.substr(6))),{}):p[e]}function u(e){var t=n(e);if(!t)throw new Error('Module "'+e+'" expected, but not contained in build.');if(t.module)return t.module;var r=t.linkRecord;return d(t,r),a(t,r,[]),t.module}function d(e,t){if(!t.depLoads){t.declare&&i(e,t),t.depLoads=[];for(var r=0;r<t.deps.length;r++){var o=n(t.deps[r]);t.depLoads.push(o),o.linkRecord&&d(o,o.linkRecord);var u=t.setters&&t.setters[r];u&&(u(o.module||o.linkRecord.moduleObj),o.importerSetters.push(u))}return e}}function i(t,r){var o=r.moduleObj,n=t.importerSetters,u=!1,d=r.declare.call(e,function(e,t){if(!u){if("object"==typeof e)for(var r in e)"__useDefault"!==r&&(o[r]=e[r]);else o[e]=t;u=!0;for(var d=0;d<n.length;d++)n[d](o);return u=!1,t}},{id:t.key});"function"!=typeof d?(r.setters=d.setters,r.execute=d.execute):(r.setters=[],r.execute=d)}function l(e,t,r){return p[e]={key:e,module:void 0,importerSetters:[],linkRecord:{deps:t,depLoads:void 0,declare:r,setters:void 0,execute:void 0,moduleObj:{}}}}function f(e,t,r,o){return p[e]={key:e,module:void 0,importerSetters:[],linkRecord:{deps:t,depLoads:void 0,declare:void 0,execute:o,executingRequire:r,moduleObj:{default:{},__useDefault:!0},setters:void 0}}}function s(e,t,r){return function(o){for(var n=0;n<e.length;n++)if(e[n]===o){var u,d=t[n],i=d.linkRecord;return u=i?-1===r.indexOf(d)?a(d,i,r):i.moduleObj:d.module,u.__useDefault?u.default:u}}}function a(t,r,n){if(n.push(t),t.module)return t.module;var u;if(r.setters){for(var d=0;d<r.deps.length;d++){var i=r.depLoads[d],l=i.linkRecord;l&&-1===n.indexOf(i)&&(u=a(i,l,l.setters?n:[]))}r.execute.call(y)}else{var f={id:t.key},c=r.moduleObj;Object.defineProperty(f,"exports",{configurable:!0,set:function(e){c.default=e},get:function(){return c.default}});var p=s(r.deps,r.depLoads,n);if(!r.executingRequire)for(var d=0;d<r.deps.length;d++)p(r.deps[d]);var m=r.execute.call(e,p,c.default,f);if(void 0!==m?c.default=m:f.exports!==c.default&&(c.default=f.exports),c.default&&c.default.__esModule)for(var v in c.default)Object.hasOwnProperty.call(c.default,v)&&"default"!==v&&(c[v]=c.default[v])}var f=t.module=new o(r.moduleObj);if(!r.setters)for(var d=0;d<t.importerSetters.length;d++)t.importerSetters[d](f);return f}function c(e,t){return p[e]={key:e,module:t,importerSetters:[],linkRecord:void 0}}var p={},m="undefined"!=typeof Symbol?Symbol():"@@baseObject";o.prototype=Object.create(null),"undefined"!=typeof Symbol&&Symbol.toStringTag&&(o.prototype[Symbol.toStringTag]="Module");var v="undefined"!=typeof System&&System._nodeRequire||"undefined"!=typeof require&&"undefined"!=typeof require.resolve&&"undefined"!=typeof process&&process.platform&&require,y={};return Object.freeze&&Object.freeze(y),function(e,t,n,d){return function(i){i(function(i){var s={_nodeRequire:v,register:l,registerDynamic:f,registry:{get:function(e){return p[e].module},set:c},newModule:function(e){return new o(e)}};c("@empty",new o({}));for(var a=0;a<t.length;a++)c(t[a],r(arguments[a],{}));d(s);var m=u(e[0]);if(e.length>1)for(var a=1;a<e.length;a++)u(e[a]);return n?m.default:(m instanceof o&&Object.defineProperty(m,"__esModule",{value:!0}),m)})}}}("undefined"!=typeof self?self:global)

(["a"], [], false, function($__System) {
var require = this.require, exports = this.exports, module = this.module;
$__System.registerDynamic('b', ['c'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    //http://en.wikipedia.org/wiki/Delaunay_triangulation
    //https://github.com/ironwallaby/delaunay
    var helpers = $__require('c');
    var polygon = helpers.polygon;
    var featurecollection = helpers.featureCollection;

    /**
     * Takes a set of {@link Point|points} and creates a
     * [Triangulated Irregular Network](http://en.wikipedia.org/wiki/Triangulated_irregular_network),
     * or a TIN for short, returned as a collection of Polygons. These are often used
     * for developing elevation contour maps or stepped heat visualizations.
     *
     * If an optional z-value property is provided then it is added as properties called `a`, `b`,
     * and `c` representing its value at each of the points that represent the corners of the
     * triangle.
     *
     * @name tin
     * @param {FeatureCollection<Point>} points input points
     * @param {String} [z] name of the property from which to pull z values
     * This is optional: if not given, then there will be no extra data added to the derived triangles.
     * @returns {FeatureCollection<Polygon>} TIN output
     * @example
     * // generate some random point data
     * var points = turf.random('points', 30, {
     *   bbox: [50, 30, 70, 50]
     * });
     * // add a random property to each point between 0 and 9
     * for (var i = 0; i < points.features.length; i++) {
     *   points.features[i].properties.z = ~~(Math.random() * 9);
     * }
     * var tin = turf.tin(points, 'z');
     *
     * //addToMap
     * var addToMap = [tin, points]
     * for (var i = 0; i < tin.features.length; i++) {
     *   var properties  = tin.features[i].properties;
     *   properties.fill = '#' + properties.a + properties.b + properties.c;
     * }
     */
    module.exports = function (points, z) {
        if (points.type !== 'FeatureCollection') throw new Error('points must be a FeatureCollection');
        //break down points
        var isPointZ = false;
        return featurecollection(triangulate(points.features.map(function (p) {
            var point = {
                x: p.geometry.coordinates[0],
                y: p.geometry.coordinates[1]
            };
            if (z) {
                point.z = p.properties[z];
            } else if (p.geometry.coordinates.length === 3) {
                isPointZ = true;
                point.z = p.geometry.coordinates[2];
            }
            return point;
        })).map(function (triangle) {

            var a = [triangle.a.x, triangle.a.y];
            var b = [triangle.b.x, triangle.b.y];
            var c = [triangle.c.x, triangle.c.y];
            var properties = {};

            // Add z coordinates to triangle points if user passed
            // them in that way otherwise add it as a property.
            if (isPointZ) {
                a.push(triangle.a.z);
                b.push(triangle.b.z);
                c.push(triangle.c.z);
            } else {
                properties = {
                    a: triangle.a.z,
                    b: triangle.b.z,
                    c: triangle.c.z
                };
            }

            return polygon([[a, b, c, a]], properties);
        }));
    };

    function Triangle(a, b, c) {
        this.a = a;
        this.b = b;
        this.c = c;

        var A = b.x - a.x,
            B = b.y - a.y,
            C = c.x - a.x,
            D = c.y - a.y,
            E = A * (a.x + b.x) + B * (a.y + b.y),
            F = C * (a.x + c.x) + D * (a.y + c.y),
            G = 2 * (A * (c.y - b.y) - B * (c.x - b.x)),
            dx,
            dy;

        // If the points of the triangle are collinear, then just find the
        // extremes and use the midpoint as the center of the circumcircle.
        this.x = (D * E - B * F) / G;
        this.y = (A * F - C * E) / G;
        dx = this.x - a.x;
        dy = this.y - a.y;
        this.r = dx * dx + dy * dy;
    }

    function byX(a, b) {
        return b.x - a.x;
    }

    function dedup(edges) {
        var j = edges.length,
            a,
            b,
            i,
            m,
            n;

        outer: while (j) {
            b = edges[--j];
            a = edges[--j];
            i = j;
            while (i) {
                n = edges[--i];
                m = edges[--i];
                if (a === m && b === n || a === n && b === m) {
                    edges.splice(j, 2);
                    edges.splice(i, 2);
                    j -= 2;
                    continue outer;
                }
            }
        }
    }

    function triangulate(vertices) {
        // Bail if there aren't enough vertices to form any triangles.
        if (vertices.length < 3) return [];

        // Ensure the vertex array is in order of descending X coordinate
        // (which is needed to ensure a subquadratic runtime), and then find
        // the bounding box around the points.
        vertices.sort(byX);

        var i = vertices.length - 1,
            xmin = vertices[i].x,
            xmax = vertices[0].x,
            ymin = vertices[i].y,
            ymax = ymin,
            epsilon = 1e-12;

        var a, b, c, A, B, G;

        while (i--) {
            if (vertices[i].y < ymin) ymin = vertices[i].y;
            if (vertices[i].y > ymax) ymax = vertices[i].y;
        }

        //Find a supertriangle, which is a triangle that surrounds all the
        //vertices. This is used like something of a sentinel value to remove
        //cases in the main algorithm, and is removed before we return any
        // results.

        // Once found, put it in the "open" list. (The "open" list is for
        // triangles who may still need to be considered; the "closed" list is
        // for triangles which do not.)
        var dx = xmax - xmin,
            dy = ymax - ymin,
            dmax = dx > dy ? dx : dy,
            xmid = (xmax + xmin) * 0.5,
            ymid = (ymax + ymin) * 0.5,
            open = [new Triangle({
            x: xmid - 20 * dmax,
            y: ymid - dmax,
            __sentinel: true
        }, {
            x: xmid,
            y: ymid + 20 * dmax,
            __sentinel: true
        }, {
            x: xmid + 20 * dmax,
            y: ymid - dmax,
            __sentinel: true
        })],
            closed = [],
            edges = [],
            j;

        // Incrementally add each vertex to the mesh.
        i = vertices.length;
        while (i--) {
            // For each open triangle, check to see if the current point is
            // inside it's circumcircle. If it is, remove the triangle and add
            // it's edges to an edge list.
            edges.length = 0;
            j = open.length;
            while (j--) {
                // If this point is to the right of this triangle's circumcircle,
                // then this triangle should never get checked again. Remove it
                // from the open list, add it to the closed list, and skip.
                dx = vertices[i].x - open[j].x;
                if (dx > 0 && dx * dx > open[j].r) {
                    closed.push(open[j]);
                    open.splice(j, 1);
                    continue;
                }

                // If not, skip this triangle.
                dy = vertices[i].y - open[j].y;
                if (dx * dx + dy * dy > open[j].r) continue;

                // Remove the triangle and add it's edges to the edge list.
                edges.push(open[j].a, open[j].b, open[j].b, open[j].c, open[j].c, open[j].a);
                open.splice(j, 1);
            }

            // Remove any doubled edges.
            dedup(edges);

            // Add a new triangle for each edge.
            j = edges.length;
            while (j) {
                b = edges[--j];
                a = edges[--j];
                c = vertices[i];
                // Avoid adding colinear triangles (which have error-prone
                // circumcircles)
                A = b.x - a.x;
                B = b.y - a.y;
                G = 2 * (A * (c.y - b.y) - B * (c.x - b.x));
                if (Math.abs(G) > epsilon) {
                    open.push(new Triangle(a, b, c));
                }
            }
        }

        // Copy any remaining open triangles to the closed list, and then
        // remove any triangles that share a vertex with the supertriangle.
        Array.prototype.push.apply(closed, open);

        i = closed.length;
        while (i--) if (closed[i].a.__sentinel || closed[i].b.__sentinel || closed[i].c.__sentinel) closed.splice(i, 1);

        return closed;
    }
});
$__System.registerDynamic('d', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  // https://github.com/topojson/topojson-server Version 3.0.0. Copyright 2017 Mike Bostock.
  (function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof undefined === 'function' && define.amd ? define(['exports'], factory) : factory(global.topojson = global.topojson || {});
  })(exports, function (exports) {
    'use strict';

    // Computes the bounding box of the specified hash of GeoJSON objects.

    var bounds = function (objects) {
      var x0 = Infinity,
          y0 = Infinity,
          x1 = -Infinity,
          y1 = -Infinity;

      function boundGeometry(geometry) {
        if (geometry != null && boundGeometryType.hasOwnProperty(geometry.type)) boundGeometryType[geometry.type](geometry);
      }

      var boundGeometryType = {
        GeometryCollection: function (o) {
          o.geometries.forEach(boundGeometry);
        },
        Point: function (o) {
          boundPoint(o.coordinates);
        },
        MultiPoint: function (o) {
          o.coordinates.forEach(boundPoint);
        },
        LineString: function (o) {
          boundLine(o.arcs);
        },
        MultiLineString: function (o) {
          o.arcs.forEach(boundLine);
        },
        Polygon: function (o) {
          o.arcs.forEach(boundLine);
        },
        MultiPolygon: function (o) {
          o.arcs.forEach(boundMultiLine);
        }
      };

      function boundPoint(coordinates) {
        var x = coordinates[0],
            y = coordinates[1];
        if (x < x0) x0 = x;
        if (x > x1) x1 = x;
        if (y < y0) y0 = y;
        if (y > y1) y1 = y;
      }

      function boundLine(coordinates) {
        coordinates.forEach(boundPoint);
      }

      function boundMultiLine(coordinates) {
        coordinates.forEach(boundLine);
      }

      for (var key in objects) {
        boundGeometry(objects[key]);
      }

      return x1 >= x0 && y1 >= y0 ? [x0, y0, x1, y1] : undefined;
    };

    var hashset = function (size, hash, equal, type, empty) {
      if (arguments.length === 3) {
        type = Array;
        empty = null;
      }

      var store = new type(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))),
          mask = size - 1;

      for (var i = 0; i < size; ++i) {
        store[i] = empty;
      }

      function add(value) {
        var index = hash(value) & mask,
            match = store[index],
            collisions = 0;
        while (match != empty) {
          if (equal(match, value)) return true;
          if (++collisions >= size) throw new Error("full hashset");
          match = store[index = index + 1 & mask];
        }
        store[index] = value;
        return true;
      }

      function has(value) {
        var index = hash(value) & mask,
            match = store[index],
            collisions = 0;
        while (match != empty) {
          if (equal(match, value)) return true;
          if (++collisions >= size) break;
          match = store[index = index + 1 & mask];
        }
        return false;
      }

      function values() {
        var values = [];
        for (var i = 0, n = store.length; i < n; ++i) {
          var match = store[i];
          if (match != empty) values.push(match);
        }
        return values;
      }

      return {
        add: add,
        has: has,
        values: values
      };
    };

    var hashmap = function (size, hash, equal, keyType, keyEmpty, valueType) {
      if (arguments.length === 3) {
        keyType = valueType = Array;
        keyEmpty = null;
      }

      var keystore = new keyType(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))),
          valstore = new valueType(size),
          mask = size - 1;

      for (var i = 0; i < size; ++i) {
        keystore[i] = keyEmpty;
      }

      function set(key, value) {
        var index = hash(key) & mask,
            matchKey = keystore[index],
            collisions = 0;
        while (matchKey != keyEmpty) {
          if (equal(matchKey, key)) return valstore[index] = value;
          if (++collisions >= size) throw new Error("full hashmap");
          matchKey = keystore[index = index + 1 & mask];
        }
        keystore[index] = key;
        valstore[index] = value;
        return value;
      }

      function maybeSet(key, value) {
        var index = hash(key) & mask,
            matchKey = keystore[index],
            collisions = 0;
        while (matchKey != keyEmpty) {
          if (equal(matchKey, key)) return valstore[index];
          if (++collisions >= size) throw new Error("full hashmap");
          matchKey = keystore[index = index + 1 & mask];
        }
        keystore[index] = key;
        valstore[index] = value;
        return value;
      }

      function get(key, missingValue) {
        var index = hash(key) & mask,
            matchKey = keystore[index],
            collisions = 0;
        while (matchKey != keyEmpty) {
          if (equal(matchKey, key)) return valstore[index];
          if (++collisions >= size) break;
          matchKey = keystore[index = index + 1 & mask];
        }
        return missingValue;
      }

      function keys() {
        var keys = [];
        for (var i = 0, n = keystore.length; i < n; ++i) {
          var matchKey = keystore[i];
          if (matchKey != keyEmpty) keys.push(matchKey);
        }
        return keys;
      }

      return {
        set: set,
        maybeSet: maybeSet, // set if unset
        get: get,
        keys: keys
      };
    };

    var equalPoint = function (pointA, pointB) {
      return pointA[0] === pointB[0] && pointA[1] === pointB[1];
    };

    // TODO if quantized, use simpler Int32 hashing?

    var buffer = new ArrayBuffer(16);
    var floats = new Float64Array(buffer);
    var uints = new Uint32Array(buffer);

    var hashPoint = function (point) {
      floats[0] = point[0];
      floats[1] = point[1];
      var hash = uints[0] ^ uints[1];
      hash = hash << 5 ^ hash >> 7 ^ uints[2] ^ uints[3];
      return hash & 0x7fffffff;
    };

    // Given an extracted (pre-)topology, identifies all of the junctions. These are
    // the points at which arcs (lines or rings) will need to be cut so that each
    // arc is represented uniquely.
    //
    // A junction is a point where at least one arc deviates from another arc going
    // through the same point. For example, consider the point B. If there is a arc
    // through ABC and another arc through CBA, then B is not a junction because in
    // both cases the adjacent point pairs are {A,C}. However, if there is an
    // additional arc ABD, then {A,D} != {A,C}, and thus B becomes a junction.
    //
    // For a closed ring ABCA, the first point Aâ€™s adjacent points are the second
    // and last point {B,C}. For a line, the first and last point are always
    // considered junctions, even if the line is closed; this ensures that a closed
    // line is never rotated.
    var join = function (topology) {
      var coordinates = topology.coordinates,
          lines = topology.lines,
          rings = topology.rings,
          indexes = index(),
          visitedByIndex = new Int32Array(coordinates.length),
          leftByIndex = new Int32Array(coordinates.length),
          rightByIndex = new Int32Array(coordinates.length),
          junctionByIndex = new Int8Array(coordinates.length),
          junctionCount = 0,
          // upper bound on number of junctions
      i,
          n,
          previousIndex,
          currentIndex,
          nextIndex;

      for (i = 0, n = coordinates.length; i < n; ++i) {
        visitedByIndex[i] = leftByIndex[i] = rightByIndex[i] = -1;
      }

      for (i = 0, n = lines.length; i < n; ++i) {
        var line = lines[i],
            lineStart = line[0],
            lineEnd = line[1];
        currentIndex = indexes[lineStart];
        nextIndex = indexes[++lineStart];
        ++junctionCount, junctionByIndex[currentIndex] = 1; // start
        while (++lineStart <= lineEnd) {
          sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[lineStart]);
        }
        ++junctionCount, junctionByIndex[nextIndex] = 1; // end
      }

      for (i = 0, n = coordinates.length; i < n; ++i) {
        visitedByIndex[i] = -1;
      }

      for (i = 0, n = rings.length; i < n; ++i) {
        var ring = rings[i],
            ringStart = ring[0] + 1,
            ringEnd = ring[1];
        previousIndex = indexes[ringEnd - 1];
        currentIndex = indexes[ringStart - 1];
        nextIndex = indexes[ringStart];
        sequence(i, previousIndex, currentIndex, nextIndex);
        while (++ringStart <= ringEnd) {
          sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[ringStart]);
        }
      }

      function sequence(i, previousIndex, currentIndex, nextIndex) {
        if (visitedByIndex[currentIndex] === i) return; // ignore self-intersection
        visitedByIndex[currentIndex] = i;
        var leftIndex = leftByIndex[currentIndex];
        if (leftIndex >= 0) {
          var rightIndex = rightByIndex[currentIndex];
          if ((leftIndex !== previousIndex || rightIndex !== nextIndex) && (leftIndex !== nextIndex || rightIndex !== previousIndex)) {
            ++junctionCount, junctionByIndex[currentIndex] = 1;
          }
        } else {
          leftByIndex[currentIndex] = previousIndex;
          rightByIndex[currentIndex] = nextIndex;
        }
      }

      function index() {
        var indexByPoint = hashmap(coordinates.length * 1.4, hashIndex, equalIndex, Int32Array, -1, Int32Array),
            indexes = new Int32Array(coordinates.length);

        for (var i = 0, n = coordinates.length; i < n; ++i) {
          indexes[i] = indexByPoint.maybeSet(i, i);
        }

        return indexes;
      }

      function hashIndex(i) {
        return hashPoint(coordinates[i]);
      }

      function equalIndex(i, j) {
        return equalPoint(coordinates[i], coordinates[j]);
      }

      visitedByIndex = leftByIndex = rightByIndex = null;

      var junctionByPoint = hashset(junctionCount * 1.4, hashPoint, equalPoint),
          j;

      // Convert back to a standard hashset by point for caller convenience.
      for (i = 0, n = coordinates.length; i < n; ++i) {
        if (junctionByIndex[j = indexes[i]]) {
          junctionByPoint.add(coordinates[j]);
        }
      }

      return junctionByPoint;
    };

    // Given an extracted (pre-)topology, cuts (or rotates) arcs so that all shared
    // point sequences are identified. The topology can then be subsequently deduped
    // to remove exact duplicate arcs.
    var cut = function (topology) {
      var junctions = join(topology),
          coordinates = topology.coordinates,
          lines = topology.lines,
          rings = topology.rings,
          next,
          i,
          n;

      for (i = 0, n = lines.length; i < n; ++i) {
        var line = lines[i],
            lineMid = line[0],
            lineEnd = line[1];
        while (++lineMid < lineEnd) {
          if (junctions.has(coordinates[lineMid])) {
            next = { 0: lineMid, 1: line[1] };
            line[1] = lineMid;
            line = line.next = next;
          }
        }
      }

      for (i = 0, n = rings.length; i < n; ++i) {
        var ring = rings[i],
            ringStart = ring[0],
            ringMid = ringStart,
            ringEnd = ring[1],
            ringFixed = junctions.has(coordinates[ringStart]);
        while (++ringMid < ringEnd) {
          if (junctions.has(coordinates[ringMid])) {
            if (ringFixed) {
              next = { 0: ringMid, 1: ring[1] };
              ring[1] = ringMid;
              ring = ring.next = next;
            } else {
              // For the first junction, we can rotate rather than cut.
              rotateArray(coordinates, ringStart, ringEnd, ringEnd - ringMid);
              coordinates[ringEnd] = coordinates[ringStart];
              ringFixed = true;
              ringMid = ringStart; // restart; we may have skipped junctions
            }
          }
        }
      }

      return topology;
    };

    function rotateArray(array, start, end, offset) {
      reverse(array, start, end);
      reverse(array, start, start + offset);
      reverse(array, start + offset, end);
    }

    function reverse(array, start, end) {
      for (var mid = start + (end-- - start >> 1), t; start < mid; ++start, --end) {
        t = array[start], array[start] = array[end], array[end] = t;
      }
    }

    // Given a cut topology, combines duplicate arcs.
    var dedup = function (topology) {
      var coordinates = topology.coordinates,
          lines = topology.lines,
          line,
          rings = topology.rings,
          ring,
          arcCount = lines.length + rings.length,
          i,
          n;

      delete topology.lines;
      delete topology.rings;

      // Count the number of (non-unique) arcs to initialize the hashmap safely.
      for (i = 0, n = lines.length; i < n; ++i) {
        line = lines[i];while (line = line.next) ++arcCount;
      }
      for (i = 0, n = rings.length; i < n; ++i) {
        ring = rings[i];while (ring = ring.next) ++arcCount;
      }

      var arcsByEnd = hashmap(arcCount * 2 * 1.4, hashPoint, equalPoint),
          arcs = topology.arcs = [];

      for (i = 0, n = lines.length; i < n; ++i) {
        line = lines[i];
        do {
          dedupLine(line);
        } while (line = line.next);
      }

      for (i = 0, n = rings.length; i < n; ++i) {
        ring = rings[i];
        if (ring.next) {
          // arc is no longer closed
          do {
            dedupLine(ring);
          } while (ring = ring.next);
        } else {
          dedupRing(ring);
        }
      }

      function dedupLine(arc) {
        var startPoint, endPoint, startArcs, startArc, endArcs, endArc, i, n;

        // Does this arc match an existing arc in order?
        if (startArcs = arcsByEnd.get(startPoint = coordinates[arc[0]])) {
          for (i = 0, n = startArcs.length; i < n; ++i) {
            startArc = startArcs[i];
            if (equalLine(startArc, arc)) {
              arc[0] = startArc[0];
              arc[1] = startArc[1];
              return;
            }
          }
        }

        // Does this arc match an existing arc in reverse order?
        if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[1]])) {
          for (i = 0, n = endArcs.length; i < n; ++i) {
            endArc = endArcs[i];
            if (reverseEqualLine(endArc, arc)) {
              arc[1] = endArc[0];
              arc[0] = endArc[1];
              return;
            }
          }
        }

        if (startArcs) startArcs.push(arc);else arcsByEnd.set(startPoint, [arc]);
        if (endArcs) endArcs.push(arc);else arcsByEnd.set(endPoint, [arc]);
        arcs.push(arc);
      }

      function dedupRing(arc) {
        var endPoint, endArcs, endArc, i, n;

        // Does this arc match an existing line in order, or reverse order?
        // Rings are closed, so their start point and end point is the same.
        if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0]])) {
          for (i = 0, n = endArcs.length; i < n; ++i) {
            endArc = endArcs[i];
            if (equalRing(endArc, arc)) {
              arc[0] = endArc[0];
              arc[1] = endArc[1];
              return;
            }
            if (reverseEqualRing(endArc, arc)) {
              arc[0] = endArc[1];
              arc[1] = endArc[0];
              return;
            }
          }
        }

        // Otherwise, does this arc match an existing ring in order, or reverse order?
        if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0] + findMinimumOffset(arc)])) {
          for (i = 0, n = endArcs.length; i < n; ++i) {
            endArc = endArcs[i];
            if (equalRing(endArc, arc)) {
              arc[0] = endArc[0];
              arc[1] = endArc[1];
              return;
            }
            if (reverseEqualRing(endArc, arc)) {
              arc[0] = endArc[1];
              arc[1] = endArc[0];
              return;
            }
          }
        }

        if (endArcs) endArcs.push(arc);else arcsByEnd.set(endPoint, [arc]);
        arcs.push(arc);
      }

      function equalLine(arcA, arcB) {
        var ia = arcA[0],
            ib = arcB[0],
            ja = arcA[1],
            jb = arcB[1];
        if (ia - ja !== ib - jb) return false;
        for (; ia <= ja; ++ia, ++ib) if (!equalPoint(coordinates[ia], coordinates[ib])) return false;
        return true;
      }

      function reverseEqualLine(arcA, arcB) {
        var ia = arcA[0],
            ib = arcB[0],
            ja = arcA[1],
            jb = arcB[1];
        if (ia - ja !== ib - jb) return false;
        for (; ia <= ja; ++ia, --jb) if (!equalPoint(coordinates[ia], coordinates[jb])) return false;
        return true;
      }

      function equalRing(arcA, arcB) {
        var ia = arcA[0],
            ib = arcB[0],
            ja = arcA[1],
            jb = arcB[1],
            n = ja - ia;
        if (n !== jb - ib) return false;
        var ka = findMinimumOffset(arcA),
            kb = findMinimumOffset(arcB);
        for (var i = 0; i < n; ++i) {
          if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[ib + (i + kb) % n])) return false;
        }
        return true;
      }

      function reverseEqualRing(arcA, arcB) {
        var ia = arcA[0],
            ib = arcB[0],
            ja = arcA[1],
            jb = arcB[1],
            n = ja - ia;
        if (n !== jb - ib) return false;
        var ka = findMinimumOffset(arcA),
            kb = n - findMinimumOffset(arcB);
        for (var i = 0; i < n; ++i) {
          if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[jb - (i + kb) % n])) return false;
        }
        return true;
      }

      // Rings are rotated to a consistent, but arbitrary, start point.
      // This is necessary to detect when a ring and a rotated copy are dupes.
      function findMinimumOffset(arc) {
        var start = arc[0],
            end = arc[1],
            mid = start,
            minimum = mid,
            minimumPoint = coordinates[mid];
        while (++mid < end) {
          var point = coordinates[mid];
          if (point[0] < minimumPoint[0] || point[0] === minimumPoint[0] && point[1] < minimumPoint[1]) {
            minimum = mid;
            minimumPoint = point;
          }
        }
        return minimum - start;
      }

      return topology;
    };

    // Given an array of arcs in absolute (but already quantized!) coordinates,
    // converts to fixed-point delta encoding.
    // This is a destructive operation that modifies the given arcs!
    var delta = function (arcs) {
      var i = -1,
          n = arcs.length;

      while (++i < n) {
        var arc = arcs[i],
            j = 0,
            k = 1,
            m = arc.length,
            point = arc[0],
            x0 = point[0],
            y0 = point[1],
            x1,
            y1;

        while (++j < m) {
          point = arc[j], x1 = point[0], y1 = point[1];
          if (x1 !== x0 || y1 !== y0) arc[k++] = [x1 - x0, y1 - y0], x0 = x1, y0 = y1;
        }

        if (k === 1) arc[k++] = [0, 0]; // Each arc must be an array of two or more positions.

        arc.length = k;
      }

      return arcs;
    };

    // Extracts the lines and rings from the specified hash of geometry objects.
    //
    // Returns an object with three properties:
    //
    // * coordinates - shared buffer of [x, y] coordinates
    // * lines - lines extracted from the hash, of the form [start, end]
    // * rings - rings extracted from the hash, of the form [start, end]
    //
    // For each ring or line, start and end represent inclusive indexes into the
    // coordinates buffer. For rings (and closed lines), coordinates[start] equals
    // coordinates[end].
    //
    // For each line or polygon geometry in the input hash, including nested
    // geometries as in geometry collections, the `coordinates` array is replaced
    // with an equivalent `arcs` array that, for each line (for line string
    // geometries) or ring (for polygon geometries), points to one of the above
    // lines or rings.
    var extract = function (objects) {
      var index = -1,
          lines = [],
          rings = [],
          coordinates = [];

      function extractGeometry(geometry) {
        if (geometry && extractGeometryType.hasOwnProperty(geometry.type)) extractGeometryType[geometry.type](geometry);
      }

      var extractGeometryType = {
        GeometryCollection: function (o) {
          o.geometries.forEach(extractGeometry);
        },
        LineString: function (o) {
          o.arcs = extractLine(o.arcs);
        },
        MultiLineString: function (o) {
          o.arcs = o.arcs.map(extractLine);
        },
        Polygon: function (o) {
          o.arcs = o.arcs.map(extractRing);
        },
        MultiPolygon: function (o) {
          o.arcs = o.arcs.map(extractMultiRing);
        }
      };

      function extractLine(line) {
        for (var i = 0, n = line.length; i < n; ++i) coordinates[++index] = line[i];
        var arc = { 0: index - n + 1, 1: index };
        lines.push(arc);
        return arc;
      }

      function extractRing(ring) {
        for (var i = 0, n = ring.length; i < n; ++i) coordinates[++index] = ring[i];
        var arc = { 0: index - n + 1, 1: index };
        rings.push(arc);
        return arc;
      }

      function extractMultiRing(rings) {
        return rings.map(extractRing);
      }

      for (var key in objects) {
        extractGeometry(objects[key]);
      }

      return {
        type: "Topology",
        coordinates: coordinates,
        lines: lines,
        rings: rings,
        objects: objects
      };
    };

    // Given a hash of GeoJSON objects, returns a hash of GeoJSON geometry objects.
    // Any null input geometry objects are represented as {type: null} in the output.
    // Any feature.{id,properties,bbox} are transferred to the output geometry object.
    // Each output geometry object is a shallow copy of the input (e.g., properties, coordinates)!
    var geometry = function (inputs) {
      var outputs = {},
          key;
      for (key in inputs) outputs[key] = geomifyObject(inputs[key]);
      return outputs;
    };

    function geomifyObject(input) {
      return input == null ? { type: null } : (input.type === "FeatureCollection" ? geomifyFeatureCollection : input.type === "Feature" ? geomifyFeature : geomifyGeometry)(input);
    }

    function geomifyFeatureCollection(input) {
      var output = { type: "GeometryCollection", geometries: input.features.map(geomifyFeature) };
      if (input.bbox != null) output.bbox = input.bbox;
      return output;
    }

    function geomifyFeature(input) {
      var output = geomifyGeometry(input.geometry),
          key; // eslint-disable-line no-unused-vars
      if (input.id != null) output.id = input.id;
      if (input.bbox != null) output.bbox = input.bbox;
      for (key in input.properties) {
        output.properties = input.properties;break;
      }
      return output;
    }

    function geomifyGeometry(input) {
      if (input == null) return { type: null };
      var output = input.type === "GeometryCollection" ? { type: "GeometryCollection", geometries: input.geometries.map(geomifyGeometry) } : input.type === "Point" || input.type === "MultiPoint" ? { type: input.type, coordinates: input.coordinates } : { type: input.type, arcs: input.coordinates }; // TODO Check for unknown types?
      if (input.bbox != null) output.bbox = input.bbox;
      return output;
    }

    var prequantize = function (objects, bbox, n) {
      var x0 = bbox[0],
          y0 = bbox[1],
          x1 = bbox[2],
          y1 = bbox[3],
          kx = x1 - x0 ? (n - 1) / (x1 - x0) : 1,
          ky = y1 - y0 ? (n - 1) / (y1 - y0) : 1;

      function quantizePoint(input) {
        return [Math.round((input[0] - x0) * kx), Math.round((input[1] - y0) * ky)];
      }

      function quantizePoints(input, m) {
        var i = -1,
            j = 0,
            n = input.length,
            output = new Array(n),
            // pessimistic
        pi,
            px,
            py,
            x,
            y;

        while (++i < n) {
          pi = input[i];
          x = Math.round((pi[0] - x0) * kx);
          y = Math.round((pi[1] - y0) * ky);
          if (x !== px || y !== py) output[j++] = [px = x, py = y]; // non-coincident points
        }

        output.length = j;
        while (j < m) j = output.push([output[0][0], output[0][1]]);
        return output;
      }

      function quantizeLine(input) {
        return quantizePoints(input, 2);
      }

      function quantizeRing(input) {
        return quantizePoints(input, 4);
      }

      function quantizePolygon(input) {
        return input.map(quantizeRing);
      }

      function quantizeGeometry(o) {
        if (o != null && quantizeGeometryType.hasOwnProperty(o.type)) quantizeGeometryType[o.type](o);
      }

      var quantizeGeometryType = {
        GeometryCollection: function (o) {
          o.geometries.forEach(quantizeGeometry);
        },
        Point: function (o) {
          o.coordinates = quantizePoint(o.coordinates);
        },
        MultiPoint: function (o) {
          o.coordinates = o.coordinates.map(quantizePoint);
        },
        LineString: function (o) {
          o.arcs = quantizeLine(o.arcs);
        },
        MultiLineString: function (o) {
          o.arcs = o.arcs.map(quantizeLine);
        },
        Polygon: function (o) {
          o.arcs = quantizePolygon(o.arcs);
        },
        MultiPolygon: function (o) {
          o.arcs = o.arcs.map(quantizePolygon);
        }
      };

      for (var key in objects) {
        quantizeGeometry(objects[key]);
      }

      return {
        scale: [1 / kx, 1 / ky],
        translate: [x0, y0]
      };
    };

    // Constructs the TopoJSON Topology for the specified hash of features.
    // Each object in the specified hash must be a GeoJSON object,
    // meaning FeatureCollection, a Feature or a geometry object.
    var topology = function (objects, quantization) {
      var bbox = bounds(objects = geometry(objects)),
          transform = quantization > 0 && bbox && prequantize(objects, bbox, quantization),
          topology = dedup(cut(extract(objects))),
          coordinates = topology.coordinates,
          indexByArc = hashmap(topology.arcs.length * 1.4, hashArc, equalArc);

      objects = topology.objects; // for garbage collection
      topology.bbox = bbox;
      topology.arcs = topology.arcs.map(function (arc, i) {
        indexByArc.set(arc, i);
        return coordinates.slice(arc[0], arc[1] + 1);
      });

      delete topology.coordinates;
      coordinates = null;

      function indexGeometry(geometry$$1) {
        if (geometry$$1 && indexGeometryType.hasOwnProperty(geometry$$1.type)) indexGeometryType[geometry$$1.type](geometry$$1);
      }

      var indexGeometryType = {
        GeometryCollection: function (o) {
          o.geometries.forEach(indexGeometry);
        },
        LineString: function (o) {
          o.arcs = indexArcs(o.arcs);
        },
        MultiLineString: function (o) {
          o.arcs = o.arcs.map(indexArcs);
        },
        Polygon: function (o) {
          o.arcs = o.arcs.map(indexArcs);
        },
        MultiPolygon: function (o) {
          o.arcs = o.arcs.map(indexMultiArcs);
        }
      };

      function indexArcs(arc) {
        var indexes = [];
        do {
          var index = indexByArc.get(arc);
          indexes.push(arc[0] < arc[1] ? index : ~index);
        } while (arc = arc.next);
        return indexes;
      }

      function indexMultiArcs(arcs) {
        return arcs.map(indexArcs);
      }

      for (var key in objects) {
        indexGeometry(objects[key]);
      }

      if (transform) {
        topology.transform = transform;
        topology.arcs = delta(topology.arcs);
      }

      return topology;
    };

    function hashArc(arc) {
      var i = arc[0],
          j = arc[1],
          t;
      if (j < i) t = i, i = j, j = t;
      return i + 31 * j;
    }

    function equalArc(arcA, arcB) {
      var ia = arcA[0],
          ja = arcA[1],
          ib = arcB[0],
          jb = arcB[1],
          t;
      if (ja < ia) t = ia, ia = ja, ja = t;
      if (jb < ib) t = ib, ib = jb, jb = t;
      return ia === ib && ja === jb;
    }

    exports.topology = topology;

    Object.defineProperty(exports, '__esModule', { value: true });
  });
});
$__System.registerDynamic('e', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  // https://github.com/topojson/topojson-client Version 3.0.0. Copyright 2017 Mike Bostock.
  (function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof undefined === 'function' && define.amd ? define(['exports'], factory) : factory(global.topojson = global.topojson || {});
  })(exports, function (exports) {
    'use strict';

    var identity = function (x) {
      return x;
    };

    var transform = function (transform) {
      if (transform == null) return identity;
      var x0,
          y0,
          kx = transform.scale[0],
          ky = transform.scale[1],
          dx = transform.translate[0],
          dy = transform.translate[1];
      return function (input, i) {
        if (!i) x0 = y0 = 0;
        var j = 2,
            n = input.length,
            output = new Array(n);
        output[0] = (x0 += input[0]) * kx + dx;
        output[1] = (y0 += input[1]) * ky + dy;
        while (j < n) output[j] = input[j], ++j;
        return output;
      };
    };

    var bbox = function (topology) {
      var t = transform(topology.transform),
          key,
          x0 = Infinity,
          y0 = x0,
          x1 = -x0,
          y1 = -x0;

      function bboxPoint(p) {
        p = t(p);
        if (p[0] < x0) x0 = p[0];
        if (p[0] > x1) x1 = p[0];
        if (p[1] < y0) y0 = p[1];
        if (p[1] > y1) y1 = p[1];
      }

      function bboxGeometry(o) {
        switch (o.type) {
          case "GeometryCollection":
            o.geometries.forEach(bboxGeometry);break;
          case "Point":
            bboxPoint(o.coordinates);break;
          case "MultiPoint":
            o.coordinates.forEach(bboxPoint);break;
        }
      }

      topology.arcs.forEach(function (arc) {
        var i = -1,
            n = arc.length,
            p;
        while (++i < n) {
          p = t(arc[i], i);
          if (p[0] < x0) x0 = p[0];
          if (p[0] > x1) x1 = p[0];
          if (p[1] < y0) y0 = p[1];
          if (p[1] > y1) y1 = p[1];
        }
      });

      for (key in topology.objects) {
        bboxGeometry(topology.objects[key]);
      }

      return [x0, y0, x1, y1];
    };

    var reverse = function (array, n) {
      var t,
          j = array.length,
          i = j - n;
      while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;
    };

    var feature = function (topology, o) {
      return o.type === "GeometryCollection" ? { type: "FeatureCollection", features: o.geometries.map(function (o) {
          return feature$1(topology, o);
        }) } : feature$1(topology, o);
    };

    function feature$1(topology, o) {
      var id = o.id,
          bbox = o.bbox,
          properties = o.properties == null ? {} : o.properties,
          geometry = object(topology, o);
      return id == null && bbox == null ? { type: "Feature", properties: properties, geometry: geometry } : bbox == null ? { type: "Feature", id: id, properties: properties, geometry: geometry } : { type: "Feature", id: id, bbox: bbox, properties: properties, geometry: geometry };
    }

    function object(topology, o) {
      var transformPoint = transform(topology.transform),
          arcs = topology.arcs;

      function arc(i, points) {
        if (points.length) points.pop();
        for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {
          points.push(transformPoint(a[k], k));
        }
        if (i < 0) reverse(points, n);
      }

      function point(p) {
        return transformPoint(p);
      }

      function line(arcs) {
        var points = [];
        for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);
        if (points.length < 2) points.push(points[0]); // This should never happen per the specification.
        return points;
      }

      function ring(arcs) {
        var points = line(arcs);
        while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.
        return points;
      }

      function polygon(arcs) {
        return arcs.map(ring);
      }

      function geometry(o) {
        var type = o.type,
            coordinates;
        switch (type) {
          case "GeometryCollection":
            return { type: type, geometries: o.geometries.map(geometry) };
          case "Point":
            coordinates = point(o.coordinates);break;
          case "MultiPoint":
            coordinates = o.coordinates.map(point);break;
          case "LineString":
            coordinates = line(o.arcs);break;
          case "MultiLineString":
            coordinates = o.arcs.map(line);break;
          case "Polygon":
            coordinates = polygon(o.arcs);break;
          case "MultiPolygon":
            coordinates = o.arcs.map(polygon);break;
          default:
            return null;
        }
        return { type: type, coordinates: coordinates };
      }

      return geometry(o);
    }

    var stitch = function (topology, arcs) {
      var stitchedArcs = {},
          fragmentByStart = {},
          fragmentByEnd = {},
          fragments = [],
          emptyIndex = -1;

      // Stitch empty arcs first, since they may be subsumed by other arcs.
      arcs.forEach(function (i, j) {
        var arc = topology.arcs[i < 0 ? ~i : i],
            t;
        if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
          t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
        }
      });

      arcs.forEach(function (i) {
        var e = ends(i),
            start = e[0],
            end = e[1],
            f,
            g;

        if (f = fragmentByEnd[start]) {
          delete fragmentByEnd[f.end];
          f.push(i);
          f.end = end;
          if (g = fragmentByStart[end]) {
            delete fragmentByStart[g.start];
            var fg = g === f ? f : f.concat(g);
            fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
          } else {
            fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
          }
        } else if (f = fragmentByStart[end]) {
          delete fragmentByStart[f.start];
          f.unshift(i);
          f.start = start;
          if (g = fragmentByEnd[start]) {
            delete fragmentByEnd[g.end];
            var gf = g === f ? f : g.concat(f);
            fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
          } else {
            fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
          }
        } else {
          f = [i];
          fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
        }
      });

      function ends(i) {
        var arc = topology.arcs[i < 0 ? ~i : i],
            p0 = arc[0],
            p1;
        if (topology.transform) p1 = [0, 0], arc.forEach(function (dp) {
          p1[0] += dp[0], p1[1] += dp[1];
        });else p1 = arc[arc.length - 1];
        return i < 0 ? [p1, p0] : [p0, p1];
      }

      function flush(fragmentByEnd, fragmentByStart) {
        for (var k in fragmentByEnd) {
          var f = fragmentByEnd[k];
          delete fragmentByStart[f.start];
          delete f.start;
          delete f.end;
          f.forEach(function (i) {
            stitchedArcs[i < 0 ? ~i : i] = 1;
          });
          fragments.push(f);
        }
      }

      flush(fragmentByEnd, fragmentByStart);
      flush(fragmentByStart, fragmentByEnd);
      arcs.forEach(function (i) {
        if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]);
      });

      return fragments;
    };

    var mesh = function (topology) {
      return object(topology, meshArcs.apply(this, arguments));
    };

    function meshArcs(topology, object$$1, filter) {
      var arcs, i, n;
      if (arguments.length > 1) arcs = extractArcs(topology, object$$1, filter);else for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) arcs[i] = i;
      return { type: "MultiLineString", arcs: stitch(topology, arcs) };
    }

    function extractArcs(topology, object$$1, filter) {
      var arcs = [],
          geomsByArc = [],
          geom;

      function extract0(i) {
        var j = i < 0 ? ~i : i;
        (geomsByArc[j] || (geomsByArc[j] = [])).push({ i: i, g: geom });
      }

      function extract1(arcs) {
        arcs.forEach(extract0);
      }

      function extract2(arcs) {
        arcs.forEach(extract1);
      }

      function extract3(arcs) {
        arcs.forEach(extract2);
      }

      function geometry(o) {
        switch (geom = o, o.type) {
          case "GeometryCollection":
            o.geometries.forEach(geometry);break;
          case "LineString":
            extract1(o.arcs);break;
          case "MultiLineString":case "Polygon":
            extract2(o.arcs);break;
          case "MultiPolygon":
            extract3(o.arcs);break;
        }
      }

      geometry(object$$1);

      geomsByArc.forEach(filter == null ? function (geoms) {
        arcs.push(geoms[0].i);
      } : function (geoms) {
        if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i);
      });

      return arcs;
    }

    function planarRingArea(ring) {
      var i = -1,
          n = ring.length,
          a,
          b = ring[n - 1],
          area = 0;
      while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];
      return Math.abs(area); // Note: doubled area!
    }

    var merge = function (topology) {
      return object(topology, mergeArcs.apply(this, arguments));
    };

    function mergeArcs(topology, objects) {
      var polygonsByArc = {},
          polygons = [],
          groups = [];

      objects.forEach(geometry);

      function geometry(o) {
        switch (o.type) {
          case "GeometryCollection":
            o.geometries.forEach(geometry);break;
          case "Polygon":
            extract(o.arcs);break;
          case "MultiPolygon":
            o.arcs.forEach(extract);break;
        }
      }

      function extract(polygon) {
        polygon.forEach(function (ring) {
          ring.forEach(function (arc) {
            (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
          });
        });
        polygons.push(polygon);
      }

      function area(ring) {
        return planarRingArea(object(topology, { type: "Polygon", arcs: [ring] }).coordinates[0]);
      }

      polygons.forEach(function (polygon) {
        if (!polygon._) {
          var group = [],
              neighbors = [polygon];
          polygon._ = 1;
          groups.push(group);
          while (polygon = neighbors.pop()) {
            group.push(polygon);
            polygon.forEach(function (ring) {
              ring.forEach(function (arc) {
                polygonsByArc[arc < 0 ? ~arc : arc].forEach(function (polygon) {
                  if (!polygon._) {
                    polygon._ = 1;
                    neighbors.push(polygon);
                  }
                });
              });
            });
          }
        }
      });

      polygons.forEach(function (polygon) {
        delete polygon._;
      });

      return {
        type: "MultiPolygon",
        arcs: groups.map(function (polygons) {
          var arcs = [],
              n;

          // Extract the exterior (unique) arcs.
          polygons.forEach(function (polygon) {
            polygon.forEach(function (ring) {
              ring.forEach(function (arc) {
                if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
                  arcs.push(arc);
                }
              });
            });
          });

          // Stitch the arcs into one or more rings.
          arcs = stitch(topology, arcs);

          // If more than one ring is returned,
          // at most one of these rings can be the exterior;
          // choose the one with the greatest absolute area.
          if ((n = arcs.length) > 1) {
            for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {
              if ((ki = area(arcs[i])) > k) {
                t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;
              }
            }
          }

          return arcs;
        })
      };
    }

    var bisect = function (a, x) {
      var lo = 0,
          hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (a[mid] < x) lo = mid + 1;else hi = mid;
      }
      return lo;
    };

    var neighbors = function (objects) {
      var indexesByArc = {},
          // arc index -> array of object indexes
      neighbors = objects.map(function () {
        return [];
      });

      function line(arcs, i) {
        arcs.forEach(function (a) {
          if (a < 0) a = ~a;
          var o = indexesByArc[a];
          if (o) o.push(i);else indexesByArc[a] = [i];
        });
      }

      function polygon(arcs, i) {
        arcs.forEach(function (arc) {
          line(arc, i);
        });
      }

      function geometry(o, i) {
        if (o.type === "GeometryCollection") o.geometries.forEach(function (o) {
          geometry(o, i);
        });else if (o.type in geometryType) geometryType[o.type](o.arcs, i);
      }

      var geometryType = {
        LineString: line,
        MultiLineString: polygon,
        Polygon: polygon,
        MultiPolygon: function (arcs, i) {
          arcs.forEach(function (arc) {
            polygon(arc, i);
          });
        }
      };

      objects.forEach(geometry);

      for (var i in indexesByArc) {
        for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {
          for (var k = j + 1; k < m; ++k) {
            var ij = indexes[j],
                ik = indexes[k],
                n;
            if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);
            if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);
          }
        }
      }

      return neighbors;
    };

    var untransform = function (transform) {
      if (transform == null) return identity;
      var x0,
          y0,
          kx = transform.scale[0],
          ky = transform.scale[1],
          dx = transform.translate[0],
          dy = transform.translate[1];
      return function (input, i) {
        if (!i) x0 = y0 = 0;
        var j = 2,
            n = input.length,
            output = new Array(n),
            x1 = Math.round((input[0] - dx) / kx),
            y1 = Math.round((input[1] - dy) / ky);
        output[0] = x1 - x0, x0 = x1;
        output[1] = y1 - y0, y0 = y1;
        while (j < n) output[j] = input[j], ++j;
        return output;
      };
    };

    var quantize = function (topology, transform) {
      if (topology.transform) throw new Error("already quantized");

      if (!transform || !transform.scale) {
        if (!((n = Math.floor(transform)) >= 2)) throw new Error("n must be â‰¥2");
        box = topology.bbox || bbox(topology);
        var x0 = box[0],
            y0 = box[1],
            x1 = box[2],
            y1 = box[3],
            n;
        transform = { scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1], translate: [x0, y0] };
      } else {
        box = topology.bbox;
      }

      var t = untransform(transform),
          box,
          key,
          inputs = topology.objects,
          outputs = {};

      function quantizePoint(point) {
        return t(point);
      }

      function quantizeGeometry(input) {
        var output;
        switch (input.type) {
          case "GeometryCollection":
            output = { type: "GeometryCollection", geometries: input.geometries.map(quantizeGeometry) };break;
          case "Point":
            output = { type: "Point", coordinates: quantizePoint(input.coordinates) };break;
          case "MultiPoint":
            output = { type: "MultiPoint", coordinates: input.coordinates.map(quantizePoint) };break;
          default:
            return input;
        }
        if (input.id != null) output.id = input.id;
        if (input.bbox != null) output.bbox = input.bbox;
        if (input.properties != null) output.properties = input.properties;
        return output;
      }

      function quantizeArc(input) {
        var i = 0,
            j = 1,
            n = input.length,
            p,
            output = new Array(n); // pessimistic
        output[0] = t(input[0], 0);
        while (++i < n) if ((p = t(input[i], i))[0] || p[1]) output[j++] = p; // non-coincident points
        if (j === 1) output[j++] = [0, 0]; // an arc must have at least two points
        output.length = j;
        return output;
      }

      for (key in inputs) outputs[key] = quantizeGeometry(inputs[key]);

      return {
        type: "Topology",
        bbox: box,
        transform: transform,
        objects: outputs,
        arcs: topology.arcs.map(quantizeArc)
      };
    };

    exports.bbox = bbox;
    exports.feature = feature;
    exports.mesh = mesh;
    exports.meshArcs = meshArcs;
    exports.merge = merge;
    exports.mergeArcs = mergeArcs;
    exports.neighbors = neighbors;
    exports.quantize = quantize;
    exports.transform = transform;
    exports.untransform = untransform;

    Object.defineProperty(exports, '__esModule', { value: true });
  });
});
$__System.registerDynamic('f', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = mergeViableLineStrings;

  // [Number, Number] -> String
  function coordId(coord) {
    return coord[0].toString() + ',' + coord[1].toString();
  }

  // LineString, LineString -> LineString
  function mergeLineStrings(a, b) {
    var s1 = coordId(a.coordinates[0]);
    var e1 = coordId(a.coordinates[a.coordinates.length - 1]);
    var s2 = coordId(b.coordinates[0]);
    var e2 = coordId(b.coordinates[b.coordinates.length - 1]);

    // TODO: handle case where more than one of these is true!

    var coords;
    if (s1 === e2) {
      coords = b.coordinates.concat(a.coordinates.slice(1));
    } else if (s2 === e1) {
      coords = a.coordinates.concat(b.coordinates.slice(1));
    } else if (s1 === s2) {
      coords = a.coordinates.slice(1).reverse().concat(b.coordinates);
    } else if (e1 === e2) {
      coords = a.coordinates.concat(b.coordinates.reverse().slice(1));
    } else {
      return null;
    }

    return {
      type: 'LineString',
      coordinates: coords
    };
  }

  // Merges all connected (non-forking, non-junctioning) line strings into single
  // line strings.
  // [LineString] -> LineString|MultiLineString
  function mergeViableLineStrings(geoms) {
    // TODO: assert all are linestrings

    var lineStrings = geoms.slice();
    var result = [];
    while (lineStrings.length > 0) {
      var ls = lineStrings.shift();

      // Attempt to merge this LineString with the other LineStrings, updating
      // the reference as it is merged with others and grows.
      lineStrings = lineStrings.reduce(function (accum, cur) {
        var merged = mergeLineStrings(ls, cur);
        if (merged) {
          // Accumulate the merged LineString
          ls = merged;
        } else {
          // Put the unmerged LineString back into the list
          accum.push(cur);
        }
        return accum;
      }, []);

      result.push(ls);
    }

    if (result.length === 1) {
      result = result[0];
    } else {
      result = {
        type: 'MultiLineString',
        coordinates: result.map(function (ls) {
          return ls.coordinates;
        })
      };
    }
    return result;
  }
});
$__System.registerDynamic('10', [], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    function flatten(gj) {
        switch (gj && gj.type || null) {
            case 'FeatureCollection':
                gj.features = gj.features.reduce(function (mem, feature) {
                    return mem.concat(flatten(feature));
                }, []);
                return gj;
            case 'Feature':
                if (!gj.geometry) return gj;
                return flatten(gj.geometry).map(function (geom) {
                    return {
                        type: 'Feature',
                        properties: JSON.parse(JSON.stringify(gj.properties)),
                        geometry: geom
                    };
                });
            case 'MultiPoint':
                return gj.coordinates.map(function (_) {
                    return { type: 'Point', coordinates: _ };
                });
            case 'MultiPolygon':
                return gj.coordinates.map(function (_) {
                    return { type: 'Polygon', coordinates: _ };
                });
            case 'MultiLineString':
                return gj.coordinates.map(function (_) {
                    return { type: 'LineString', coordinates: _ };
                });
            case 'GeometryCollection':
                return gj.geometries.map(flatten).reduce(function (memo, geoms) {
                    return memo.concat(geoms);
                }, []);
            case 'Point':
            case 'Polygon':
            case 'LineString':
                return [gj];
        }
    }

    module.exports = flatten;
});
$__System.registerDynamic("@system-env", [], true, function() {
  return {
    "default": true
  };
});

$__System.registerDynamic('11', ['@system-env'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    // From https://github.com/defunctzombie/node-process/blob/master/browser.js
    // shim for using process in browser

    var productionEnv = $__require('@system-env').production;

    var process = module.exports = {};
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }

    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = setTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        clearTimeout(timeout);
    }

    process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            setTimeout(drainQueue, 0);
        }
    };

    // v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    process.title = 'browser';
    process.browser = true;
    process.env = {
        NODE_ENV: productionEnv ? 'production' : 'development'
    };
    process.argv = [];
    process.version = ''; // empty string to avoid regexp issues
    process.versions = {};

    function noop() {}

    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;

    process.binding = function (name) {
        throw new Error('process.binding is not supported');
    };

    process.cwd = function () {
        return '/';
    };
    process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
    };
    process.umask = function () {
        return 0;
    };
});
$__System.registerDynamic('12', ['d', 'e', 'f', '13', '10', '11'], true, function ($__require, exports, module) {
  var process = $__require('11');
  var global = this || self,
      GLOBAL = global;
  var createTopology = $__require('d').topology;
  var mergeTopology = $__require('e').merge;
  var dissolveLineStrings = $__require('f');
  var geomEach = $__require('13').geomEach;
  var flatten = $__require('10');

  module.exports = dissolve;

  function toArray(args) {
    if (!args.length) return [];
    return Array.isArray(args[0]) ? args[0] : Array.prototype.slice.call(args);
  }

  function dissolvePolygons(geoms) {
    // Topojson modifies in place, so we need to deep clone first
    var objects = {
      geoms: {
        type: 'GeometryCollection',
        geometries: JSON.parse(JSON.stringify(geoms))
      }
    };
    var topo = createTopology(objects);
    return mergeTopology(topo, topo.objects.geoms.geometries);
  }

  // [GeoJSON] -> String|Null
  function getHomogenousType(geoms) {
    var type = null;
    for (var i = 0; i < geoms.length; i++) {
      if (!type) {
        type = geoms[i].type;
      } else if (type !== geoms[i].type) {
        return null;
      }
    }
    return type;
  }

  // Transform function: attempts to dissolve geojson objects where possible
  // [GeoJSON] -> GeoJSON geometry
  function dissolve() {
    // accept an array of geojson objects, or an argument list
    var objects = toArray(arguments);
    var geoms = objects.reduce(function (acc, o) {
      // flatten any Multi-geom into features of simple types
      var flat = flatten(o);
      if (!Array.isArray(flat)) flat = [flat];
      for (var i = 0; i < flat.length; i++) {
        // get an array of all flatten geometry objects
        geomEach(flat[i], function (geom) {
          acc.push(geom);
        });
      }
      return acc;
    }, []);
    // Assert homogenity
    var type = getHomogenousType(geoms);
    if (!type) {
      throw new Error('List does not contain only homoegenous GeoJSON');
    }

    switch (type) {
      case 'LineString':
        return dissolveLineStrings(geoms);
      case 'Polygon':
        return dissolvePolygons(geoms);
      default:
        return geoms;
    }
  }
});
$__System.registerDynamic('14', ['b', 'c', '15', '12', '16'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    var tin = $__require('b');
    var helpers = $__require('c');
    var distance = $__require('15');
    var dissolve = $__require('12');
    var featureEach = $__require('16').featureEach;
    var feature = helpers.feature;
    var featureCollection = helpers.featureCollection;

    /**
     * Takes a set of {@link Point|points} and returns a concave hull Polygon or MultiPolygon.
     * Internally, this uses [turf-tin](https://github.com/Turfjs/turf-tin) to generate geometries.
     *
     * @name concave
     * @param {FeatureCollection<Point>} points input points
     * @param {number} maxEdge the length (in 'units') of an edge necessary for part of the hull to become concave
     * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers
     * @returns {Feature<(Polygon|MultiPolygon)>} a concave hull
     * @throws {Error} if maxEdge parameter is missing or unable to compute hull
     * @example
     * var points = turf.featureCollection([
     *   turf.point([-63.601226, 44.642643]),
     *   turf.point([-63.591442, 44.651436]),
     *   turf.point([-63.580799, 44.648749]),
     *   turf.point([-63.573589, 44.641788]),
     *   turf.point([-63.587665, 44.64533]),
     *   turf.point([-63.595218, 44.64765])
     * ]);
     *
     * var hull = turf.concave(points, 1, 'miles');
     *
     * //addToMap
     * var addToMap = [points, hull]
     */
    module.exports = function (points, maxEdge, units) {
        // validation
        if (!points) throw new Error('points is required');
        if (maxEdge === undefined || maxEdge === null) throw new Error('maxEdge is required');
        if (typeof maxEdge !== 'number') throw new Error('invalid maxEdge');

        var cleaned = removeDuplicates(points);

        var tinPolys = tin(cleaned);
        // calculate length of all edges and area of all triangles
        // and remove triangles that fail the max length test
        tinPolys.features = tinPolys.features.filter(function (triangle) {
            var pt1 = triangle.geometry.coordinates[0][0];
            var pt2 = triangle.geometry.coordinates[0][1];
            var pt3 = triangle.geometry.coordinates[0][2];
            var dist1 = distance(pt1, pt2, units);
            var dist2 = distance(pt2, pt3, units);
            var dist3 = distance(pt1, pt3, units);
            return dist1 <= maxEdge && dist2 <= maxEdge && dist3 <= maxEdge;
        });

        if (tinPolys.features.length < 1) throw new Error('too few polygons found to compute concave hull');

        // merge the adjacent triangles
        var dissolved = dissolve(tinPolys.features);
        // geojson-dissolve always returns a MultiPolygon
        if (dissolved.coordinates.length === 1) {
            dissolved.coordinates = dissolved.coordinates[0];
            dissolved.type = 'Polygon';
        }
        return feature(dissolved);
    };

    /**
     * Removes duplicated points in a collection returning a new collection
     *
     * @private
     * @param {FeatureCollection<Point>} points to be cleaned
     * @returns {FeatureCollection<Point>} cleaned set of points
     */
    function removeDuplicates(points) {
        var cleaned = [];
        var existing = {};

        featureEach(points, function (pt) {
            if (!pt.geometry) return;
            var key = pt.geometry.coordinates.join('-');
            if (!existing.hasOwnProperty(key)) {
                cleaned.push(pt);
                existing[key] = true;
            }
        });
        return featureCollection(cleaned);
    }
});
$__System.registerDynamic('17', [], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /*
     (c) 2013, Vladimir Agafonkin
     Simplify.js, a high-performance JS polyline simplification library
     mourner.github.io/simplify-js
    */

    (function () {
        'use strict';

        // to suit your point format, run search/replace for '.x' and '.y';
        // for 3D version, see 3d branch (configurability would draw significant performance overhead)

        // square distance between 2 points

        function getSqDist(p1, p2) {

            var dx = p1.x - p2.x,
                dy = p1.y - p2.y;

            return dx * dx + dy * dy;
        }

        // square distance from a point to a segment
        function getSqSegDist(p, p1, p2) {

            var x = p1.x,
                y = p1.y,
                dx = p2.x - x,
                dy = p2.y - y;

            if (dx !== 0 || dy !== 0) {

                var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);

                if (t > 1) {
                    x = p2.x;
                    y = p2.y;
                } else if (t > 0) {
                    x += dx * t;
                    y += dy * t;
                }
            }

            dx = p.x - x;
            dy = p.y - y;

            return dx * dx + dy * dy;
        }
        // rest of the code doesn't care about point format

        // basic distance-based simplification
        function simplifyRadialDist(points, sqTolerance) {

            var prevPoint = points[0],
                newPoints = [prevPoint],
                point;

            for (var i = 1, len = points.length; i < len; i++) {
                point = points[i];

                if (getSqDist(point, prevPoint) > sqTolerance) {
                    newPoints.push(point);
                    prevPoint = point;
                }
            }

            if (prevPoint !== point) newPoints.push(point);

            return newPoints;
        }

        // simplification using optimized Douglas-Peucker algorithm with recursion elimination
        function simplifyDouglasPeucker(points, sqTolerance) {

            var len = points.length,
                MarkerArray = typeof Uint8Array !== 'undefined' ? Uint8Array : Array,
                markers = new MarkerArray(len),
                first = 0,
                last = len - 1,
                stack = [],
                newPoints = [],
                i,
                maxSqDist,
                sqDist,
                index;

            markers[first] = markers[last] = 1;

            while (last) {

                maxSqDist = 0;

                for (i = first + 1; i < last; i++) {
                    sqDist = getSqSegDist(points[i], points[first], points[last]);

                    if (sqDist > maxSqDist) {
                        index = i;
                        maxSqDist = sqDist;
                    }
                }

                if (maxSqDist > sqTolerance) {
                    markers[index] = 1;
                    stack.push(first, index, index, last);
                }

                last = stack.pop();
                first = stack.pop();
            }

            for (i = 0; i < len; i++) {
                if (markers[i]) newPoints.push(points[i]);
            }

            return newPoints;
        }

        // both algorithms combined for awesome performance
        function simplify(points, tolerance, highestQuality) {

            var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;

            points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
            points = simplifyDouglasPeucker(points, sqTolerance);

            return points;
        }

        // export as AMD module / Node module / browser or worker variable
        if (typeof undefined === 'function' && define.amd) define(function () {
            return simplify;
        });else if (typeof module !== 'undefined') module.exports = simplify;else if (typeof self !== 'undefined') self.simplify = simplify;else window.simplify = simplify;
    })();
});
$__System.registerDynamic('18', ['c', '19'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    var helpers = $__require('c');
    var invariant = $__require('19');
    var getCoords = invariant.getCoords;
    var getGeomType = invariant.getGeomType;

    /**
     * Removes redundant coordinates from any GeoJSON Geometry.
     *
     * @name cleanCoords
     * @param {Geometry|Feature} geojson Feature or Geometry
     * @param {boolean} [mutate=false] allows GeoJSON input to be mutated
     * @returns {Geometry|Feature} the cleaned input Feature/Geometry
     * @example
     * var line = turf.lineString([[0, 0], [0, 2], [0, 5], [0, 8], [0, 8], [0, 10]]);
     * var multiPoint = turf.multiPoint([[0, 0], [0, 0], [2, 2]]);
     *
     * turf.cleanCoords(line).geometry.coordinates;
     * //= [[0, 0], [0, 10]]
     *
     * turf.cleanCoords(multiPoint).geometry.coordinates;
     * //= [[0, 0], [2, 2]]
     */
    module.exports = function (geojson, mutate) {
        if (!geojson) throw new Error('geojson is required');
        var type = getGeomType(geojson);

        // Store new "clean" points in this Array
        var newCoords = [];

        switch (type) {
            case 'LineString':
                newCoords = cleanCoords(geojson);
                break;
            case 'MultiLineString':
            case 'Polygon':
                getCoords(geojson).forEach(function (line) {
                    newCoords.push(cleanCoords(line));
                });
                break;
            case 'MultiPolygon':
                getCoords(geojson).forEach(function (polygons) {
                    var polyPoints = [];
                    polygons.forEach(function (ring) {
                        polyPoints.push(cleanCoords(ring));
                    });
                    newCoords.push(polyPoints);
                });
                break;
            case 'Point':
                return geojson;
            case 'MultiPoint':
                var existing = {};
                getCoords(geojson).forEach(function (coord) {
                    var key = coord.join('-');
                    if (!existing.hasOwnProperty(key)) {
                        newCoords.push(coord);
                        existing[key] = true;
                    }
                });
                break;
            default:
                throw new Error(type + ' geometry not supported');
        }

        // Support input mutation
        if (geojson.coordinates) {
            if (mutate === true) {
                geojson.coordinates = newCoords;
                return geojson;
            }
            return geometry(geojson, type, newCoords);
        } else {
            if (mutate === true) {
                geojson.geometry.coordinates = newCoords;
                return geojson;
            }
            return feature(geojson, type, newCoords);
        }
    };

    /**
     * Create Geometry from existing Geometry
     *
     * @private
     * @param {Geometry} geojson Existing Geometry
     * @param {string} type Geometry Type
     * @param {Array<number>} coordinates Coordinates
     * @returns {Geometry} Geometry
     */
    function geometry(geojson, type, coordinates) {
        var geom = {
            type: type,
            coordinates: coordinates
        };
        if (geojson.bbox) geom.bbox = geojson.bbox;
        return geom;
    }

    /**
     * Create Feature from existing Feature
     *
     * @private
     * @param {Feature} geojson Existing Feature
     * @param {string} type Feature Type
     * @param {Array<number>} coordinates Coordinates
     * @returns {Feature} Feature
     */
    function feature(geojson, type, coordinates) {
        var feat = helpers.feature(geometry(geojson.geometry, type, coordinates), geojson.properties);
        if (geojson.id) feat.id = geojson.id;
        if (geojson.bbox) feat.bbox = geojson.bbox;
        return feat;
    }

    /**
     * Clean Coords
     *
     * @private
     * @param {Array<number>|LineString} line Line
     * @returns {Array<number>} Cleaned coordinates
     */
    function cleanCoords(line) {
        var points = getCoords(line);
        // handle "clean" segment
        if (points.length === 2 && !equals(points[0], points[1])) return points;

        var prevPoint, point, nextPoint;
        var newPoints = [];
        var secondToLast = points.length - 1;

        newPoints.push(points[0]);
        for (var i = 1; i < secondToLast; i++) {
            prevPoint = points[i - 1];
            point = points[i];
            nextPoint = points[i + 1];

            if (!isPointOnLineSegment(prevPoint, nextPoint, point)) {
                newPoints.push(point);
            }
        }
        newPoints.push(nextPoint);
        return newPoints;
    }

    /**
     * Compares two points and returns if they are equals
     *
     * @private
     * @param {Array<number>} pt1 point
     * @param {Array<number>} pt2 point
     * @returns {boolean} true if they are equals
     */
    function equals(pt1, pt2) {
        return pt1[0] === pt2[0] && pt1[1] === pt2[1];
    }

    /**
     * Returns if `point` is on the segment between `start` and `end`.
     * Borrowed from `@turf/boolean-point-on-line` to speed up the evaluation (instead of using the module as dependency)
     *
     * @private
     * @param {Array<number>} start coord pair of start of line
     * @param {Array<number>} end coord pair of end of line
     * @param {Array<number>} point coord pair of point to check
     * @returns {boolean} true/false
     */
    function isPointOnLineSegment(start, end, point) {
        var x = point[0],
            y = point[1];
        var startX = start[0],
            startY = start[1];
        var endX = end[0],
            endY = end[1];

        var dxc = x - startX;
        var dyc = y - startY;
        var dxl = endX - startX;
        var dyl = endY - startY;
        var cross = dxc * dyl - dyc * dxl;

        if (cross !== 0) return false;else if (Math.abs(dxl) >= Math.abs(dyl)) return dxl > 0 ? startX <= x && x <= endX : endX <= x && x <= startX;else return dyl > 0 ? startY <= y && y <= endY : endY <= y && y <= startY;
    }
});
$__System.registerDynamic('1a', [], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /**
     * Returns a cloned copy of the passed GeoJSON Object, including possible 'Foreign Members'.
     * ~3-5x faster than the common JSON.parse + JSON.stringify combo method.
     *
     * @name clone
     * @param {GeoJSON} geojson GeoJSON Object
     * @returns {GeoJSON} cloned GeoJSON Object
     * @example
     * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]], {color: 'red'});
     *
     * var lineCloned = turf.clone(line);
     */
    module.exports = function (geojson) {
        if (!geojson) throw new Error('geojson is required');

        switch (geojson.type) {
            case 'Feature':
                return cloneFeature(geojson);
            case 'FeatureCollection':
                return cloneFeatureCollection(geojson);
            case 'Point':
            case 'LineString':
            case 'Polygon':
            case 'MultiPoint':
            case 'MultiLineString':
            case 'MultiPolygon':
            case 'GeometryCollection':
                return cloneGeometry(geojson);
            default:
                throw new Error('unknown GeoJSON type');
        }
    };

    /**
     * Clone Feature
     *
     * @private
     * @param {Feature<any>} geojson GeoJSON Feature
     * @returns {Feature<any>} cloned Feature
     */
    function cloneFeature(geojson) {
        var cloned = { type: 'Feature' };
        // Preserve Foreign Members
        Object.keys(geojson).forEach(function (key) {
            switch (key) {
                case 'type':
                case 'properties':
                case 'geometry':
                    return;
                default:
                    cloned[key] = geojson[key];
            }
        });
        // Add properties & geometry last
        cloned.properties = cloneProperties(geojson.properties);
        cloned.geometry = cloneGeometry(geojson.geometry);
        return cloned;
    }

    /**
     * Clone Properties
     *
     * @private
     * @param {Object} properties GeoJSON Properties
     * @returns {Object} cloned Properties
     */
    function cloneProperties(properties) {
        var cloned = {};
        if (!properties) return cloned;
        Object.keys(properties).forEach(function (key) {
            var value = properties[key];
            if (typeof value === 'object') {
                // handle Array
                if (value.length) cloned[key] = value.map(function (item) {
                    return item;
                });
                // handle Object
                cloned[key] = cloneProperties(value);
            } else cloned[key] = value;
        });
        return cloned;
    }

    /**
     * Clone Feature Collection
     *
     * @private
     * @param {FeatureCollection<any>} geojson GeoJSON Feature Collection
     * @returns {FeatureCollection<any>} cloned Feature Collection
     */
    function cloneFeatureCollection(geojson) {
        var cloned = { type: 'FeatureCollection' };

        // Preserve Foreign Members
        Object.keys(geojson).forEach(function (key) {
            switch (key) {
                case 'type':
                case 'features':
                    return;
                default:
                    cloned[key] = geojson[key];
            }
        });
        // Add features
        cloned.features = geojson.features.map(function (feature) {
            return cloneFeature(feature);
        });
        return cloned;
    }

    /**
     * Clone Geometry
     *
     * @private
     * @param {Geometry<any>} geometry GeoJSON Geometry
     * @returns {Geometry<any>} cloned Geometry
     */
    function cloneGeometry(geometry) {
        var geom = { type: geometry.type };
        if (geometry.bbox) geom.bbox = geometry.bbox;

        if (geometry.type === 'GeometryCollection') {
            geom.geometries = geometry.geometries.map(function (geom) {
                return cloneGeometry(geom);
            });
            return geom;
        }
        geom.coordinates = deepSlice(geometry.coordinates);
        return geom;
    }

    /**
     * Deep Slice coordinates
     *
     * @private
     * @param {Coordinates} coords Coordinates
     * @returns {Coordinates} all coordinates sliced
     */
    function deepSlice(coords) {
        if (typeof coords[0] !== 'object') {
            return coords.slice();
        }
        return coords.map(function (coord) {
            return deepSlice(coord);
        });
    }
});
$__System.registerDynamic('1b', ['17', '18', '16', '1a'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    var simplifyJS = $__require('17');
    var cleanCoords = $__require('18');
    var geomEach = $__require('16').geomEach;
    var clone = $__require('1a');

    /**
     * Takes a {@link GeoJSON} object and returns a simplified version. Internally uses
     * [simplify-js](http://mourner.github.io/simplify-js/) to perform simplification.
     *
     * @name simplify
     * @param {GeoJSON} geojson object to be simplified
     * @param {number} [tolerance=1] simplification tolerance
     * @param {boolean} [highQuality=false] whether or not to spend more time to create a higher-quality simplification with a different algorithm
     * @param {boolean} [mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)
     * @returns {GeoJSON} a simplified GeoJSON
     * @example
     * var geojson = turf.polygon([[
     *   [-70.603637, -33.399918],
     *   [-70.614624, -33.395332],
     *   [-70.639343, -33.392466],
     *   [-70.659942, -33.394759],
     *   [-70.683975, -33.404504],
     *   [-70.697021, -33.419406],
     *   [-70.701141, -33.434306],
     *   [-70.700454, -33.446339],
     *   [-70.694274, -33.458369],
     *   [-70.682601, -33.465816],
     *   [-70.668869, -33.472117],
     *   [-70.646209, -33.473835],
     *   [-70.624923, -33.472117],
     *   [-70.609817, -33.468107],
     *   [-70.595397, -33.458369],
     *   [-70.587158, -33.442901],
     *   [-70.587158, -33.426283],
     *   [-70.590591, -33.414248],
     *   [-70.594711, -33.406224],
     *   [-70.603637, -33.399918]
     * ]]);
     * var tolerance = 0.01;
     *
     * var simplified = turf.simplify(geojson, tolerance, false);
     *
     * //addToMap
     * var addToMap = [geojson, simplified]
     */
    module.exports = function (geojson, tolerance, highQuality, mutate) {
        if (!geojson) throw new Error('geojson is required');
        if (tolerance && tolerance < 0) throw new Error('invalid tolerance');

        // Clone geojson to avoid side effects
        if (mutate !== true) geojson = clone(geojson);

        geomEach(geojson, function (geom) {
            simplify(geom, tolerance, highQuality);
        });
        return geojson;
    };

    /**
     * Simplifies a feature's coordinates
     *
     * @private
     * @param {Geometry} geometry to be simplified
     * @param {number} [tolerance=1] simplification tolerance
     * @param {boolean} [highQuality=false] whether or not to spend more time to create a higher-quality simplification with a different algorithm
     * @returns {Geometry} output
     */
    function simplify(geometry, tolerance, highQuality) {
        var type = geometry.type;

        // "unsimplyfiable" geometry types
        if (type === 'Point' || type === 'MultiPoint') return geometry;

        // Remove any extra coordinates
        cleanCoords(geometry, true);

        var coordinates = geometry.coordinates;
        switch (type) {
            case 'LineString':
                geometry['coordinates'] = simplifyLine(coordinates, tolerance, highQuality);
                break;
            case 'MultiLineString':
                geometry['coordinates'] = coordinates.map(function (lines) {
                    return simplifyLine(lines, tolerance, highQuality);
                });
                break;
            case 'Polygon':
                geometry['coordinates'] = simplifyPolygon(coordinates, tolerance, highQuality);
                break;
            case 'MultiPolygon':
                geometry['coordinates'] = coordinates.map(function (rings) {
                    return simplifyPolygon(rings, tolerance, highQuality);
                });
        }
        return geometry;
    }

    /**
     * Simplifies the coordinates of a LineString with simplify-js
     *
     * @private
     * @param {Array<number>} coordinates to be processed
     * @param {number} tolerance simplification tolerance
     * @param {boolean} highQuality whether or not to spend more time to create a higher-quality
     * @returns {Array<Array<number>>} simplified coords
     */
    function simplifyLine(coordinates, tolerance, highQuality) {
        return simplifyJS(coordinates.map(function (coord) {
            return { x: coord[0], y: coord[1], z: coord[2] };
        }), tolerance, highQuality).map(function (coords) {
            return coords.z ? [coords.x, coords.y, coords.z] : [coords.x, coords.y];
        });
    }

    /**
     * Simplifies the coordinates of a Polygon with simplify-js
     *
     * @private
     * @param {Array<number>} coordinates to be processed
     * @param {number} tolerance simplification tolerance
     * @param {boolean} highQuality whether or not to spend more time to create a higher-quality
     * @returns {Array<Array<Array<number>>>} simplified coords
     */
    function simplifyPolygon(coordinates, tolerance, highQuality) {
        return coordinates.map(function (ring) {
            var pts = ring.map(function (coord) {
                return { x: coord[0], y: coord[1] };
            });
            if (pts.length < 4) {
                throw new Error('invalid polygon');
            }
            var simpleRing = simplifyJS(pts, tolerance, highQuality).map(function (coords) {
                return [coords.x, coords.y];
            });
            //remove 1 percent of tolerance until enough points to make a triangle
            while (!checkValidity(simpleRing)) {
                tolerance -= tolerance * 0.01;
                simpleRing = simplifyJS(pts, tolerance, highQuality).map(function (coords) {
                    return [coords.x, coords.y];
                });
            }
            if (simpleRing[simpleRing.length - 1][0] !== simpleRing[0][0] || simpleRing[simpleRing.length - 1][1] !== simpleRing[0][1]) {
                simpleRing.push(simpleRing[0]);
            }
            return simpleRing;
        });
    }

    /**
     * Returns true if ring has at least 3 coordinates and its first coordinate is the same as its last
     *
     * @private
     * @param {Array<number>} ring coordinates to be checked
     * @returns {boolean} true if valid
     */
    function checkValidity(ring) {
        if (ring.length < 3) return false;
        //if the last point is the same as the first, it's not a triangle
        return !(ring.length === 3 && ring[2][0] === ring[0][0] && ring[2][1] === ring[0][1]);
    }
});
$__System.registerDynamic('1c', ['15', 'c', '1d', '1e'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    var measureDistance = $__require('15');
    var point = $__require('c').point;
    var bearing = $__require('1d');
    var destination = $__require('1e');

    /**
     * Takes a {@link LineString|line} and returns a {@link Point|point} at a specified distance along the line.
     *
     * @name along
     * @param {Feature<LineString>} line input line
     * @param {number} distance distance along the line
     * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers
     * @returns {Feature<Point>} Point `distance` `units` along the line
     * @example
     * var line = turf.lineString([[-83, 30], [-84, 36], [-78, 41]]);
     *
     * var along = turf.along(line, 200, 'miles');
     *
     * //addToMap
     * var addToMap = [along, line]
     */
    module.exports = function (line, distance, units) {
        var coords;
        if (line.type === 'Feature') coords = line.geometry.coordinates;else if (line.type === 'LineString') coords = line.coordinates;else throw new Error('input must be a LineString Feature or Geometry');

        var travelled = 0;
        for (var i = 0; i < coords.length; i++) {
            if (distance >= travelled && i === coords.length - 1) break;else if (travelled >= distance) {
                var overshot = distance - travelled;
                if (!overshot) return point(coords[i]);else {
                    var direction = bearing(coords[i], coords[i - 1]) - 180;
                    var interpolated = destination(coords[i], overshot, direction, units);
                    return interpolated;
                }
            } else {
                travelled += measureDistance(coords[i], coords[i + 1], units);
            }
        }
        return point(coords[coords.length - 1]);
    };
});
$__System.registerDynamic('1f', ['20'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    var jsts = $__require('20');

    /**
     * Takes two or more {@link Polygon|polygons} and returns a combined polygon. If the input polygons are not contiguous, this function returns a {@link MultiPolygon} feature.
     *
     * @name union
     * @param {...Feature<Polygon>} A polygon to combine
     * @returns {Feature<(Polygon|MultiPolygon)>} a combined {@link Polygon} or {@link MultiPolygon} feature
     * @example
     * var poly1 = turf.polygon([[
     *     [-82.574787, 35.594087],
     *     [-82.574787, 35.615581],
     *     [-82.545261, 35.615581],
     *     [-82.545261, 35.594087],
     *     [-82.574787, 35.594087]
     * ]], {"fill": "#0f0"});
     * var poly2 = turf.polygon([[
     *     [-82.560024, 35.585153],
     *     [-82.560024, 35.602602],
     *     [-82.52964, 35.602602],
     *     [-82.52964, 35.585153],
     *     [-82.560024, 35.585153]
     * ]], {"fill": "#00f"});
     *
     * var union = turf.union(poly1, poly2);
     *
     * //addToMap
     * var addToMap = [poly1, poly2, union];
     */
    module.exports = function () {
        var reader = new jsts.io.GeoJSONReader();
        var result = reader.read(JSON.stringify(arguments[0].geometry));

        for (var i = 1; i < arguments.length; i++) {
            result = result.union(reader.read(JSON.stringify(arguments[i].geometry)));
        }

        var writer = new jsts.io.GeoJSONWriter();
        result = writer.write(result);

        return {
            type: 'Feature',
            geometry: result,
            properties: arguments[0].properties
        };
    };
});
$__System.registerDynamic('21', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  // https://d3js.org/d3-array/ Version 1.2.0. Copyright 2017 Mike Bostock.
  (function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof undefined === 'function' && define.amd ? define(['exports'], factory) : factory(global.d3 = global.d3 || {});
  })(exports, function (exports) {
    'use strict';

    var ascending = function (a, b) {
      return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    };

    var bisector = function (compare) {
      if (compare.length === 1) compare = ascendingComparator(compare);
      return {
        left: function (a, x, lo, hi) {
          if (lo == null) lo = 0;
          if (hi == null) hi = a.length;
          while (lo < hi) {
            var mid = lo + hi >>> 1;
            if (compare(a[mid], x) < 0) lo = mid + 1;else hi = mid;
          }
          return lo;
        },
        right: function (a, x, lo, hi) {
          if (lo == null) lo = 0;
          if (hi == null) hi = a.length;
          while (lo < hi) {
            var mid = lo + hi >>> 1;
            if (compare(a[mid], x) > 0) hi = mid;else lo = mid + 1;
          }
          return lo;
        }
      };
    };

    function ascendingComparator(f) {
      return function (d, x) {
        return ascending(f(d), x);
      };
    }

    var ascendingBisect = bisector(ascending);
    var bisectRight = ascendingBisect.right;
    var bisectLeft = ascendingBisect.left;

    var pairs = function (array, f) {
      if (f == null) f = pair;
      var i = 0,
          n = array.length - 1,
          p = array[0],
          pairs = new Array(n < 0 ? 0 : n);
      while (i < n) pairs[i] = f(p, p = array[++i]);
      return pairs;
    };

    function pair(a, b) {
      return [a, b];
    }

    var cross = function (values0, values1, reduce) {
      var n0 = values0.length,
          n1 = values1.length,
          values = new Array(n0 * n1),
          i0,
          i1,
          i,
          value0;

      if (reduce == null) reduce = pair;

      for (i0 = i = 0; i0 < n0; ++i0) {
        for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
          values[i] = reduce(value0, values1[i1]);
        }
      }

      return values;
    };

    var descending = function (a, b) {
      return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
    };

    var number = function (x) {
      return x === null ? NaN : +x;
    };

    var variance = function (values, valueof) {
      var n = values.length,
          m = 0,
          i = -1,
          mean = 0,
          value,
          delta,
          sum = 0;

      if (valueof == null) {
        while (++i < n) {
          if (!isNaN(value = number(values[i]))) {
            delta = value - mean;
            mean += delta / ++m;
            sum += delta * (value - mean);
          }
        }
      } else {
        while (++i < n) {
          if (!isNaN(value = number(valueof(values[i], i, values)))) {
            delta = value - mean;
            mean += delta / ++m;
            sum += delta * (value - mean);
          }
        }
      }

      if (m > 1) return sum / (m - 1);
    };

    var deviation = function (array, f) {
      var v = variance(array, f);
      return v ? Math.sqrt(v) : v;
    };

    var extent = function (values, valueof) {
      var n = values.length,
          i = -1,
          value,
          min,
          max;

      if (valueof == null) {
        while (++i < n) {
          // Find the first comparable value.
          if ((value = values[i]) != null && value >= value) {
            min = max = value;
            while (++i < n) {
              // Compare the remaining values.
              if ((value = values[i]) != null) {
                if (min > value) min = value;
                if (max < value) max = value;
              }
            }
          }
        }
      } else {
        while (++i < n) {
          // Find the first comparable value.
          if ((value = valueof(values[i], i, values)) != null && value >= value) {
            min = max = value;
            while (++i < n) {
              // Compare the remaining values.
              if ((value = valueof(values[i], i, values)) != null) {
                if (min > value) min = value;
                if (max < value) max = value;
              }
            }
          }
        }
      }

      return [min, max];
    };

    var array = Array.prototype;

    var slice = array.slice;
    var map = array.map;

    var constant = function (x) {
      return function () {
        return x;
      };
    };

    var identity = function (x) {
      return x;
    };

    var range = function (start, stop, step) {
      start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

      var i = -1,
          n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
          range = new Array(n);

      while (++i < n) {
        range[i] = start + i * step;
      }

      return range;
    };

    var e10 = Math.sqrt(50);
    var e5 = Math.sqrt(10);
    var e2 = Math.sqrt(2);

    var ticks = function (start, stop, count) {
      var reverse = stop < start,
          i = -1,
          n,
          ticks,
          step;

      if (reverse) n = start, start = stop, stop = n;

      if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

      if (step > 0) {
        start = Math.ceil(start / step);
        stop = Math.floor(stop / step);
        ticks = new Array(n = Math.ceil(stop - start + 1));
        while (++i < n) ticks[i] = (start + i) * step;
      } else {
        start = Math.floor(start * step);
        stop = Math.ceil(stop * step);
        ticks = new Array(n = Math.ceil(start - stop + 1));
        while (++i < n) ticks[i] = (start - i) / step;
      }

      if (reverse) ticks.reverse();

      return ticks;
    };

    function tickIncrement(start, stop, count) {
      var step = (stop - start) / Math.max(0, count),
          power = Math.floor(Math.log(step) / Math.LN10),
          error = step / Math.pow(10, power);
      return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
    }

    function tickStep(start, stop, count) {
      var step0 = Math.abs(stop - start) / Math.max(0, count),
          step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
          error = step0 / step1;
      if (error >= e10) step1 *= 10;else if (error >= e5) step1 *= 5;else if (error >= e2) step1 *= 2;
      return stop < start ? -step1 : step1;
    }

    var sturges = function (values) {
      return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
    };

    var histogram = function () {
      var value = identity,
          domain = extent,
          threshold = sturges;

      function histogram(data) {
        var i,
            n = data.length,
            x,
            values = new Array(n);

        for (i = 0; i < n; ++i) {
          values[i] = value(data[i], i, data);
        }

        var xz = domain(values),
            x0 = xz[0],
            x1 = xz[1],
            tz = threshold(values, x0, x1);

        // Convert number of thresholds into uniform thresholds.
        if (!Array.isArray(tz)) {
          tz = tickStep(x0, x1, tz);
          tz = range(Math.ceil(x0 / tz) * tz, Math.floor(x1 / tz) * tz, tz); // exclusive
        }

        // Remove any thresholds outside the domain.
        var m = tz.length;
        while (tz[0] <= x0) tz.shift(), --m;
        while (tz[m - 1] > x1) tz.pop(), --m;

        var bins = new Array(m + 1),
            bin;

        // Initialize bins.
        for (i = 0; i <= m; ++i) {
          bin = bins[i] = [];
          bin.x0 = i > 0 ? tz[i - 1] : x0;
          bin.x1 = i < m ? tz[i] : x1;
        }

        // Assign data to bins by value, ignoring any outside the domain.
        for (i = 0; i < n; ++i) {
          x = values[i];
          if (x0 <= x && x <= x1) {
            bins[bisectRight(tz, x, 0, m)].push(data[i]);
          }
        }

        return bins;
      }

      histogram.value = function (_) {
        return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
      };

      histogram.domain = function (_) {
        return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
      };

      histogram.thresholds = function (_) {
        return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
      };

      return histogram;
    };

    var quantile = function (values, p, valueof) {
      if (valueof == null) valueof = number;
      if (!(n = values.length)) return;
      if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
      if (p >= 1) return +valueof(values[n - 1], n - 1, values);
      var n,
          i = (n - 1) * p,
          i0 = Math.floor(i),
          value0 = +valueof(values[i0], i0, values),
          value1 = +valueof(values[i0 + 1], i0 + 1, values);
      return value0 + (value1 - value0) * (i - i0);
    };

    var freedmanDiaconis = function (values, min, max) {
      values = map.call(values, number).sort(ascending);
      return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));
    };

    var scott = function (values, min, max) {
      return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
    };

    var max = function (values, valueof) {
      var n = values.length,
          i = -1,
          value,
          max;

      if (valueof == null) {
        while (++i < n) {
          // Find the first comparable value.
          if ((value = values[i]) != null && value >= value) {
            max = value;
            while (++i < n) {
              // Compare the remaining values.
              if ((value = values[i]) != null && value > max) {
                max = value;
              }
            }
          }
        }
      } else {
        while (++i < n) {
          // Find the first comparable value.
          if ((value = valueof(values[i], i, values)) != null && value >= value) {
            max = value;
            while (++i < n) {
              // Compare the remaining values.
              if ((value = valueof(values[i], i, values)) != null && value > max) {
                max = value;
              }
            }
          }
        }
      }

      return max;
    };

    var mean = function (values, valueof) {
      var n = values.length,
          m = n,
          i = -1,
          value,
          sum = 0;

      if (valueof == null) {
        while (++i < n) {
          if (!isNaN(value = number(values[i]))) sum += value;else --m;
        }
      } else {
        while (++i < n) {
          if (!isNaN(value = number(valueof(values[i], i, values)))) sum += value;else --m;
        }
      }

      if (m) return sum / m;
    };

    var median = function (values, valueof) {
      var n = values.length,
          i = -1,
          value,
          numbers = [];

      if (valueof == null) {
        while (++i < n) {
          if (!isNaN(value = number(values[i]))) {
            numbers.push(value);
          }
        }
      } else {
        while (++i < n) {
          if (!isNaN(value = number(valueof(values[i], i, values)))) {
            numbers.push(value);
          }
        }
      }

      return quantile(numbers.sort(ascending), 0.5);
    };

    var merge = function (arrays) {
      var n = arrays.length,
          m,
          i = -1,
          j = 0,
          merged,
          array;

      while (++i < n) j += arrays[i].length;
      merged = new Array(j);

      while (--n >= 0) {
        array = arrays[n];
        m = array.length;
        while (--m >= 0) {
          merged[--j] = array[m];
        }
      }

      return merged;
    };

    var min = function (values, valueof) {
      var n = values.length,
          i = -1,
          value,
          min;

      if (valueof == null) {
        while (++i < n) {
          // Find the first comparable value.
          if ((value = values[i]) != null && value >= value) {
            min = value;
            while (++i < n) {
              // Compare the remaining values.
              if ((value = values[i]) != null && min > value) {
                min = value;
              }
            }
          }
        }
      } else {
        while (++i < n) {
          // Find the first comparable value.
          if ((value = valueof(values[i], i, values)) != null && value >= value) {
            min = value;
            while (++i < n) {
              // Compare the remaining values.
              if ((value = valueof(values[i], i, values)) != null && min > value) {
                min = value;
              }
            }
          }
        }
      }

      return min;
    };

    var permute = function (array, indexes) {
      var i = indexes.length,
          permutes = new Array(i);
      while (i--) permutes[i] = array[indexes[i]];
      return permutes;
    };

    var scan = function (values, compare) {
      if (!(n = values.length)) return;
      var n,
          i = 0,
          j = 0,
          xi,
          xj = values[j];

      if (compare == null) compare = ascending;

      while (++i < n) {
        if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
          xj = xi, j = i;
        }
      }

      if (compare(xj, xj) === 0) return j;
    };

    var shuffle = function (array, i0, i1) {
      var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
          t,
          i;

      while (m) {
        i = Math.random() * m-- | 0;
        t = array[m + i0];
        array[m + i0] = array[i + i0];
        array[i + i0] = t;
      }

      return array;
    };

    var sum = function (values, valueof) {
      var n = values.length,
          i = -1,
          value,
          sum = 0;

      if (valueof == null) {
        while (++i < n) {
          if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
        }
      } else {
        while (++i < n) {
          if (value = +valueof(values[i], i, values)) sum += value;
        }
      }

      return sum;
    };

    var transpose = function (matrix) {
      if (!(n = matrix.length)) return [];
      for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {
        for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
          row[j] = matrix[j][i];
        }
      }
      return transpose;
    };

    function length(d) {
      return d.length;
    }

    var zip = function () {
      return transpose(arguments);
    };

    exports.bisect = bisectRight;
    exports.bisectRight = bisectRight;
    exports.bisectLeft = bisectLeft;
    exports.ascending = ascending;
    exports.bisector = bisector;
    exports.cross = cross;
    exports.descending = descending;
    exports.deviation = deviation;
    exports.extent = extent;
    exports.histogram = histogram;
    exports.thresholdFreedmanDiaconis = freedmanDiaconis;
    exports.thresholdScott = scott;
    exports.thresholdSturges = sturges;
    exports.max = max;
    exports.mean = mean;
    exports.median = median;
    exports.merge = merge;
    exports.min = min;
    exports.pairs = pairs;
    exports.permute = permute;
    exports.quantile = quantile;
    exports.range = range;
    exports.scan = scan;
    exports.shuffle = shuffle;
    exports.sum = sum;
    exports.ticks = ticks;
    exports.tickIncrement = tickIncrement;
    exports.tickStep = tickStep;
    exports.transpose = transpose;
    exports.variance = variance;
    exports.zip = zip;

    Object.defineProperty(exports, '__esModule', { value: true });
  });
});
$__System.registerDynamic('22', ['21'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  // https://d3js.org/d3-geo/ Version 1.6.4. Copyright 2017 Mike Bostock.
  (function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, $__require('21')) : typeof undefined === 'function' && define.amd ? define(['exports', 'd3-array'], factory) : factory(global.d3 = global.d3 || {}, global.d3);
  })(exports, function (exports, d3Array) {
    'use strict';

    // Adds floating point numbers with twice the normal precision.
    // Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
    // Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
    // 305â€“363 (1997).
    // Code adapted from GeographicLib by Charles F. F. Karney,
    // http://geographiclib.sourceforge.net/

    var adder = function () {
      return new Adder();
    };

    function Adder() {
      this.reset();
    }

    Adder.prototype = {
      constructor: Adder,
      reset: function () {
        this.s = // rounded value
        this.t = 0; // exact error
      },
      add: function (y) {
        add(temp, y, this.t);
        add(this, temp.s, this.s);
        if (this.s) this.t += temp.t;else this.s = temp.t;
      },
      valueOf: function () {
        return this.s;
      }
    };

    var temp = new Adder();

    function add(adder, a, b) {
      var x = adder.s = a + b,
          bv = x - a,
          av = x - bv;
      adder.t = a - av + (b - bv);
    }

    var epsilon = 1e-6;
    var epsilon2 = 1e-12;
    var pi = Math.PI;
    var halfPi = pi / 2;
    var quarterPi = pi / 4;
    var tau = pi * 2;

    var degrees = 180 / pi;
    var radians = pi / 180;

    var abs = Math.abs;
    var atan = Math.atan;
    var atan2 = Math.atan2;
    var cos = Math.cos;
    var ceil = Math.ceil;
    var exp = Math.exp;

    var log = Math.log;
    var pow = Math.pow;
    var sin = Math.sin;
    var sign = Math.sign || function (x) {
      return x > 0 ? 1 : x < 0 ? -1 : 0;
    };
    var sqrt = Math.sqrt;
    var tan = Math.tan;

    function acos(x) {
      return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
    }

    function asin(x) {
      return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
    }

    function haversin(x) {
      return (x = sin(x / 2)) * x;
    }

    function noop() {}

    function streamGeometry(geometry, stream) {
      if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
        streamGeometryType[geometry.type](geometry, stream);
      }
    }

    var streamObjectType = {
      Feature: function (object, stream) {
        streamGeometry(object.geometry, stream);
      },
      FeatureCollection: function (object, stream) {
        var features = object.features,
            i = -1,
            n = features.length;
        while (++i < n) streamGeometry(features[i].geometry, stream);
      }
    };

    var streamGeometryType = {
      Sphere: function (object, stream) {
        stream.sphere();
      },
      Point: function (object, stream) {
        object = object.coordinates;
        stream.point(object[0], object[1], object[2]);
      },
      MultiPoint: function (object, stream) {
        var coordinates = object.coordinates,
            i = -1,
            n = coordinates.length;
        while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
      },
      LineString: function (object, stream) {
        streamLine(object.coordinates, stream, 0);
      },
      MultiLineString: function (object, stream) {
        var coordinates = object.coordinates,
            i = -1,
            n = coordinates.length;
        while (++i < n) streamLine(coordinates[i], stream, 0);
      },
      Polygon: function (object, stream) {
        streamPolygon(object.coordinates, stream);
      },
      MultiPolygon: function (object, stream) {
        var coordinates = object.coordinates,
            i = -1,
            n = coordinates.length;
        while (++i < n) streamPolygon(coordinates[i], stream);
      },
      GeometryCollection: function (object, stream) {
        var geometries = object.geometries,
            i = -1,
            n = geometries.length;
        while (++i < n) streamGeometry(geometries[i], stream);
      }
    };

    function streamLine(coordinates, stream, closed) {
      var i = -1,
          n = coordinates.length - closed,
          coordinate;
      stream.lineStart();
      while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
      stream.lineEnd();
    }

    function streamPolygon(coordinates, stream) {
      var i = -1,
          n = coordinates.length;
      stream.polygonStart();
      while (++i < n) streamLine(coordinates[i], stream, 1);
      stream.polygonEnd();
    }

    var geoStream = function (object, stream) {
      if (object && streamObjectType.hasOwnProperty(object.type)) {
        streamObjectType[object.type](object, stream);
      } else {
        streamGeometry(object, stream);
      }
    };

    var areaRingSum = adder();

    var areaSum = adder();
    var lambda00;
    var phi00;
    var lambda0;
    var cosPhi0;
    var sinPhi0;

    var areaStream = {
      point: noop,
      lineStart: noop,
      lineEnd: noop,
      polygonStart: function () {
        areaRingSum.reset();
        areaStream.lineStart = areaRingStart;
        areaStream.lineEnd = areaRingEnd;
      },
      polygonEnd: function () {
        var areaRing = +areaRingSum;
        areaSum.add(areaRing < 0 ? tau + areaRing : areaRing);
        this.lineStart = this.lineEnd = this.point = noop;
      },
      sphere: function () {
        areaSum.add(tau);
      }
    };

    function areaRingStart() {
      areaStream.point = areaPointFirst;
    }

    function areaRingEnd() {
      areaPoint(lambda00, phi00);
    }

    function areaPointFirst(lambda, phi) {
      areaStream.point = areaPoint;
      lambda00 = lambda, phi00 = phi;
      lambda *= radians, phi *= radians;
      lambda0 = lambda, cosPhi0 = cos(phi = phi / 2 + quarterPi), sinPhi0 = sin(phi);
    }

    function areaPoint(lambda, phi) {
      lambda *= radians, phi *= radians;
      phi = phi / 2 + quarterPi; // half the angular distance from south pole

      // Spherical excess E for a spherical triangle with vertices: south pole,
      // previous point, current point.  Uses a formula derived from Cagnoliâ€™s
      // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).
      var dLambda = lambda - lambda0,
          sdLambda = dLambda >= 0 ? 1 : -1,
          adLambda = sdLambda * dLambda,
          cosPhi = cos(phi),
          sinPhi = sin(phi),
          k = sinPhi0 * sinPhi,
          u = cosPhi0 * cosPhi + k * cos(adLambda),
          v = k * sdLambda * sin(adLambda);
      areaRingSum.add(atan2(v, u));

      // Advance the previous points.
      lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
    }

    var area = function (object) {
      areaSum.reset();
      geoStream(object, areaStream);
      return areaSum * 2;
    };

    function spherical(cartesian) {
      return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];
    }

    function cartesian(spherical) {
      var lambda = spherical[0],
          phi = spherical[1],
          cosPhi = cos(phi);
      return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];
    }

    function cartesianDot(a, b) {
      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }

    function cartesianCross(a, b) {
      return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
    }

    // TODO return a
    function cartesianAddInPlace(a, b) {
      a[0] += b[0], a[1] += b[1], a[2] += b[2];
    }

    function cartesianScale(vector, k) {
      return [vector[0] * k, vector[1] * k, vector[2] * k];
    }

    // TODO return d
    function cartesianNormalizeInPlace(d) {
      var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
      d[0] /= l, d[1] /= l, d[2] /= l;
    }

    var lambda0$1;
    var phi0;
    var lambda1;
    var phi1;
    var lambda2;
    var lambda00$1;
    var phi00$1;
    var p0;
    var deltaSum = adder();
    var ranges;
    var range$1;

    var boundsStream = {
      point: boundsPoint,
      lineStart: boundsLineStart,
      lineEnd: boundsLineEnd,
      polygonStart: function () {
        boundsStream.point = boundsRingPoint;
        boundsStream.lineStart = boundsRingStart;
        boundsStream.lineEnd = boundsRingEnd;
        deltaSum.reset();
        areaStream.polygonStart();
      },
      polygonEnd: function () {
        areaStream.polygonEnd();
        boundsStream.point = boundsPoint;
        boundsStream.lineStart = boundsLineStart;
        boundsStream.lineEnd = boundsLineEnd;
        if (areaRingSum < 0) lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);else if (deltaSum > epsilon) phi1 = 90;else if (deltaSum < -epsilon) phi0 = -90;
        range$1[0] = lambda0$1, range$1[1] = lambda1;
      }
    };

    function boundsPoint(lambda, phi) {
      ranges.push(range$1 = [lambda0$1 = lambda, lambda1 = lambda]);
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
    }

    function linePoint(lambda, phi) {
      var p = cartesian([lambda * radians, phi * radians]);
      if (p0) {
        var normal = cartesianCross(p0, p),
            equatorial = [normal[1], -normal[0], 0],
            inflection = cartesianCross(equatorial, normal);
        cartesianNormalizeInPlace(inflection);
        inflection = spherical(inflection);
        var delta = lambda - lambda2,
            sign$$1 = delta > 0 ? 1 : -1,
            lambdai = inflection[0] * degrees * sign$$1,
            phii,
            antimeridian = abs(delta) > 180;
        if (antimeridian ^ (sign$$1 * lambda2 < lambdai && lambdai < sign$$1 * lambda)) {
          phii = inflection[1] * degrees;
          if (phii > phi1) phi1 = phii;
        } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign$$1 * lambda2 < lambdai && lambdai < sign$$1 * lambda)) {
          phii = -inflection[1] * degrees;
          if (phii < phi0) phi0 = phii;
        } else {
          if (phi < phi0) phi0 = phi;
          if (phi > phi1) phi1 = phi;
        }
        if (antimeridian) {
          if (lambda < lambda2) {
            if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
          } else {
            if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
          }
        } else {
          if (lambda1 >= lambda0$1) {
            if (lambda < lambda0$1) lambda0$1 = lambda;
            if (lambda > lambda1) lambda1 = lambda;
          } else {
            if (lambda > lambda2) {
              if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
            } else {
              if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
            }
          }
        }
      } else {
        ranges.push(range$1 = [lambda0$1 = lambda, lambda1 = lambda]);
      }
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
      p0 = p, lambda2 = lambda;
    }

    function boundsLineStart() {
      boundsStream.point = linePoint;
    }

    function boundsLineEnd() {
      range$1[0] = lambda0$1, range$1[1] = lambda1;
      boundsStream.point = boundsPoint;
      p0 = null;
    }

    function boundsRingPoint(lambda, phi) {
      if (p0) {
        var delta = lambda - lambda2;
        deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
      } else {
        lambda00$1 = lambda, phi00$1 = phi;
      }
      areaStream.point(lambda, phi);
      linePoint(lambda, phi);
    }

    function boundsRingStart() {
      areaStream.lineStart();
    }

    function boundsRingEnd() {
      boundsRingPoint(lambda00$1, phi00$1);
      areaStream.lineEnd();
      if (abs(deltaSum) > epsilon) lambda0$1 = -(lambda1 = 180);
      range$1[0] = lambda0$1, range$1[1] = lambda1;
      p0 = null;
    }

    // Finds the left-right distance between two longitudes.
    // This is almost the same as (lambda1 - lambda0 + 360Â°) % 360Â°, except that we want
    // the distance between Â±180Â° to be 360Â°.
    function angle(lambda0, lambda1) {
      return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
    }

    function rangeCompare(a, b) {
      return a[0] - b[0];
    }

    function rangeContains(range$$1, x) {
      return range$$1[0] <= range$$1[1] ? range$$1[0] <= x && x <= range$$1[1] : x < range$$1[0] || range$$1[1] < x;
    }

    var bounds = function (feature) {
      var i, n, a, b, merged, deltaMax, delta;

      phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
      ranges = [];
      geoStream(feature, boundsStream);

      // First, sort ranges by their minimum longitudes.
      if (n = ranges.length) {
        ranges.sort(rangeCompare);

        // Then, merge any ranges that overlap.
        for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
          b = ranges[i];
          if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
          } else {
            merged.push(a = b);
          }
        }

        // Finally, find the largest gap between the merged ranges.
        // The final bounding box will be the inverse of this gap.
        for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
          b = merged[i];
          if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];
        }
      }

      ranges = range$1 = null;

      return lambda0$1 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda0$1, phi0], [lambda1, phi1]];
    };

    var W0;
    var W1;
    var X0;
    var Y0;
    var Z0;
    var X1;
    var Y1;
    var Z1;
    var X2;
    var Y2;
    var Z2;
    var lambda00$2;
    var phi00$2;
    var x0;
    var y0;
    var z0; // previous point

    var centroidStream = {
      sphere: noop,
      point: centroidPoint,
      lineStart: centroidLineStart,
      lineEnd: centroidLineEnd,
      polygonStart: function () {
        centroidStream.lineStart = centroidRingStart;
        centroidStream.lineEnd = centroidRingEnd;
      },
      polygonEnd: function () {
        centroidStream.lineStart = centroidLineStart;
        centroidStream.lineEnd = centroidLineEnd;
      }
    };

    // Arithmetic mean of Cartesian vectors.
    function centroidPoint(lambda, phi) {
      lambda *= radians, phi *= radians;
      var cosPhi = cos(phi);
      centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi));
    }

    function centroidPointCartesian(x, y, z) {
      ++W0;
      X0 += (x - X0) / W0;
      Y0 += (y - Y0) / W0;
      Z0 += (z - Z0) / W0;
    }

    function centroidLineStart() {
      centroidStream.point = centroidLinePointFirst;
    }

    function centroidLinePointFirst(lambda, phi) {
      lambda *= radians, phi *= radians;
      var cosPhi = cos(phi);
      x0 = cosPhi * cos(lambda);
      y0 = cosPhi * sin(lambda);
      z0 = sin(phi);
      centroidStream.point = centroidLinePoint;
      centroidPointCartesian(x0, y0, z0);
    }

    function centroidLinePoint(lambda, phi) {
      lambda *= radians, phi *= radians;
      var cosPhi = cos(phi),
          x = cosPhi * cos(lambda),
          y = cosPhi * sin(lambda),
          z = sin(phi),
          w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
      W1 += w;
      X1 += w * (x0 + (x0 = x));
      Y1 += w * (y0 + (y0 = y));
      Z1 += w * (z0 + (z0 = z));
      centroidPointCartesian(x0, y0, z0);
    }

    function centroidLineEnd() {
      centroidStream.point = centroidPoint;
    }

    // See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
    // J. Applied Mechanics 42, 239 (1975).
    function centroidRingStart() {
      centroidStream.point = centroidRingPointFirst;
    }

    function centroidRingEnd() {
      centroidRingPoint(lambda00$2, phi00$2);
      centroidStream.point = centroidPoint;
    }

    function centroidRingPointFirst(lambda, phi) {
      lambda00$2 = lambda, phi00$2 = phi;
      lambda *= radians, phi *= radians;
      centroidStream.point = centroidRingPoint;
      var cosPhi = cos(phi);
      x0 = cosPhi * cos(lambda);
      y0 = cosPhi * sin(lambda);
      z0 = sin(phi);
      centroidPointCartesian(x0, y0, z0);
    }

    function centroidRingPoint(lambda, phi) {
      lambda *= radians, phi *= radians;
      var cosPhi = cos(phi),
          x = cosPhi * cos(lambda),
          y = cosPhi * sin(lambda),
          z = sin(phi),
          cx = y0 * z - z0 * y,
          cy = z0 * x - x0 * z,
          cz = x0 * y - y0 * x,
          m = sqrt(cx * cx + cy * cy + cz * cz),
          w = asin(m),
          // line weight = angle
      v = m && -w / m; // area weight multiplier
      X2 += v * cx;
      Y2 += v * cy;
      Z2 += v * cz;
      W1 += w;
      X1 += w * (x0 + (x0 = x));
      Y1 += w * (y0 + (y0 = y));
      Z1 += w * (z0 + (z0 = z));
      centroidPointCartesian(x0, y0, z0);
    }

    var centroid = function (object) {
      W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
      geoStream(object, centroidStream);

      var x = X2,
          y = Y2,
          z = Z2,
          m = x * x + y * y + z * z;

      // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
      if (m < epsilon2) {
        x = X1, y = Y1, z = Z1;
        // If the feature has zero length, fall back to arithmetic mean of point vectors.
        if (W1 < epsilon) x = X0, y = Y0, z = Z0;
        m = x * x + y * y + z * z;
        // If the feature still has an undefined ccentroid, then return.
        if (m < epsilon2) return [NaN, NaN];
      }

      return [atan2(y, x) * degrees, asin(z / sqrt(m)) * degrees];
    };

    var constant = function (x) {
      return function () {
        return x;
      };
    };

    var compose = function (a, b) {

      function compose(x, y) {
        return x = a(x, y), b(x[0], x[1]);
      }

      if (a.invert && b.invert) compose.invert = function (x, y) {
        return x = b.invert(x, y), x && a.invert(x[0], x[1]);
      };

      return compose;
    };

    function rotationIdentity(lambda, phi) {
      return [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
    }

    rotationIdentity.invert = rotationIdentity;

    function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
      return (deltaLambda %= tau) ? deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
    }

    function forwardRotationLambda(deltaLambda) {
      return function (lambda, phi) {
        return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
      };
    }

    function rotationLambda(deltaLambda) {
      var rotation = forwardRotationLambda(deltaLambda);
      rotation.invert = forwardRotationLambda(-deltaLambda);
      return rotation;
    }

    function rotationPhiGamma(deltaPhi, deltaGamma) {
      var cosDeltaPhi = cos(deltaPhi),
          sinDeltaPhi = sin(deltaPhi),
          cosDeltaGamma = cos(deltaGamma),
          sinDeltaGamma = sin(deltaGamma);

      function rotation(lambda, phi) {
        var cosPhi = cos(phi),
            x = cos(lambda) * cosPhi,
            y = sin(lambda) * cosPhi,
            z = sin(phi),
            k = z * cosDeltaPhi + x * sinDeltaPhi;
        return [atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi), asin(k * cosDeltaGamma + y * sinDeltaGamma)];
      }

      rotation.invert = function (lambda, phi) {
        var cosPhi = cos(phi),
            x = cos(lambda) * cosPhi,
            y = sin(lambda) * cosPhi,
            z = sin(phi),
            k = z * cosDeltaGamma - y * sinDeltaGamma;
        return [atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi), asin(k * cosDeltaPhi - x * sinDeltaPhi)];
      };

      return rotation;
    }

    var rotation = function (rotate) {
      rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);

      function forward(coordinates) {
        coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);
        return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
      }

      forward.invert = function (coordinates) {
        coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);
        return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
      };

      return forward;
    };

    // Generates a circle centered at [0Â°, 0Â°], with a given radius and precision.
    function circleStream(stream, radius, delta, direction, t0, t1) {
      if (!delta) return;
      var cosRadius = cos(radius),
          sinRadius = sin(radius),
          step = direction * delta;
      if (t0 == null) {
        t0 = radius + direction * tau;
        t1 = radius - step / 2;
      } else {
        t0 = circleRadius(cosRadius, t0);
        t1 = circleRadius(cosRadius, t1);
        if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau;
      }
      for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
        point = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);
        stream.point(point[0], point[1]);
      }
    }

    // Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
    function circleRadius(cosRadius, point) {
      point = cartesian(point), point[0] -= cosRadius;
      cartesianNormalizeInPlace(point);
      var radius = acos(-point[1]);
      return ((-point[2] < 0 ? -radius : radius) + tau - epsilon) % tau;
    }

    var circle = function () {
      var center = constant([0, 0]),
          radius = constant(90),
          precision = constant(6),
          ring,
          rotate,
          stream = { point: point };

      function point(x, y) {
        ring.push(x = rotate(x, y));
        x[0] *= degrees, x[1] *= degrees;
      }

      function circle() {
        var c = center.apply(this, arguments),
            r = radius.apply(this, arguments) * radians,
            p = precision.apply(this, arguments) * radians;
        ring = [];
        rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;
        circleStream(stream, r, p, 1);
        c = { type: "Polygon", coordinates: [ring] };
        ring = rotate = null;
        return c;
      }

      circle.center = function (_) {
        return arguments.length ? (center = typeof _ === "function" ? _ : constant([+_[0], +_[1]]), circle) : center;
      };

      circle.radius = function (_) {
        return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), circle) : radius;
      };

      circle.precision = function (_) {
        return arguments.length ? (precision = typeof _ === "function" ? _ : constant(+_), circle) : precision;
      };

      return circle;
    };

    var clipBuffer = function () {
      var lines = [],
          line;
      return {
        point: function (x, y) {
          line.push([x, y]);
        },
        lineStart: function () {
          lines.push(line = []);
        },
        lineEnd: noop,
        rejoin: function () {
          if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
        },
        result: function () {
          var result = lines;
          lines = [];
          line = null;
          return result;
        }
      };
    };

    var clipLine = function (a, b, x0, y0, x1, y1) {
      var ax = a[0],
          ay = a[1],
          bx = b[0],
          by = b[1],
          t0 = 0,
          t1 = 1,
          dx = bx - ax,
          dy = by - ay,
          r;

      r = x0 - ax;
      if (!dx && r > 0) return;
      r /= dx;
      if (dx < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dx > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }

      r = x1 - ax;
      if (!dx && r < 0) return;
      r /= dx;
      if (dx < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dx > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }

      r = y0 - ay;
      if (!dy && r > 0) return;
      r /= dy;
      if (dy < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dy > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }

      r = y1 - ay;
      if (!dy && r < 0) return;
      r /= dy;
      if (dy < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dy > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }

      if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
      if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
      return true;
    };

    var pointEqual = function (a, b) {
      return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;
    };

    function Intersection(point, points, other, entry) {
      this.x = point;
      this.z = points;
      this.o = other; // another intersection
      this.e = entry; // is an entry?
      this.v = false; // visited
      this.n = this.p = null; // next & previous
    }

    // A generalized polygon clipping algorithm: given a polygon that has been cut
    // into its visible line segments, and rejoins the segments by interpolating
    // along the clip edge.
    var clipPolygon = function (segments, compareIntersection, startInside, interpolate, stream) {
      var subject = [],
          clip = [],
          i,
          n;

      segments.forEach(function (segment) {
        if ((n = segment.length - 1) <= 0) return;
        var n,
            p0 = segment[0],
            p1 = segment[n],
            x;

        // If the first and last points of a segment are coincident, then treat as a
        // closed ring. TODO if all rings are closed, then the winding order of the
        // exterior ring should be checked.
        if (pointEqual(p0, p1)) {
          stream.lineStart();
          for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
          stream.lineEnd();
          return;
        }

        subject.push(x = new Intersection(p0, segment, null, true));
        clip.push(x.o = new Intersection(p0, null, x, false));
        subject.push(x = new Intersection(p1, segment, null, false));
        clip.push(x.o = new Intersection(p1, null, x, true));
      });

      if (!subject.length) return;

      clip.sort(compareIntersection);
      link(subject);
      link(clip);

      for (i = 0, n = clip.length; i < n; ++i) {
        clip[i].e = startInside = !startInside;
      }

      var start = subject[0],
          points,
          point;

      while (1) {
        // Find first unvisited intersection.
        var current = start,
            isSubject = true;
        while (current.v) if ((current = current.n) === start) return;
        points = current.z;
        stream.lineStart();
        do {
          current.v = current.o.v = true;
          if (current.e) {
            if (isSubject) {
              for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
            } else {
              interpolate(current.x, current.n.x, 1, stream);
            }
            current = current.n;
          } else {
            if (isSubject) {
              points = current.p.z;
              for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
            } else {
              interpolate(current.x, current.p.x, -1, stream);
            }
            current = current.p;
          }
          current = current.o;
          points = current.z;
          isSubject = !isSubject;
        } while (!current.v);
        stream.lineEnd();
      }
    };

    function link(array) {
      if (!(n = array.length)) return;
      var n,
          i = 0,
          a = array[0],
          b;
      while (++i < n) {
        a.n = b = array[i];
        b.p = a;
        a = b;
      }
      a.n = b = array[0];
      b.p = a;
    }

    var clipMax = 1e9;
    var clipMin = -clipMax;

    // TODO Use d3-polygonâ€™s polygonContains here for the ring check?
    // TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

    function clipExtent(x0, y0, x1, y1) {

      function visible(x, y) {
        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
      }

      function interpolate(from, to, direction, stream) {
        var a = 0,
            a1 = 0;
        if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
          do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0); while ((a = (a + direction + 4) % 4) !== a1);
        } else {
          stream.point(to[0], to[1]);
        }
      }

      function corner(p, direction) {
        return abs(p[0] - x0) < epsilon ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < epsilon ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < epsilon ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
      }

      function compareIntersection(a, b) {
        return comparePoint(a.x, b.x);
      }

      function comparePoint(a, b) {
        var ca = corner(a, 1),
            cb = corner(b, 1);
        return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
      }

      return function (stream) {
        var activeStream = stream,
            bufferStream = clipBuffer(),
            segments,
            polygon,
            ring,
            x__,
            y__,
            v__,
            // first point
        x_,
            y_,
            v_,
            // previous point
        first,
            clean;

        var clipStream = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: polygonStart,
          polygonEnd: polygonEnd
        };

        function point(x, y) {
          if (visible(x, y)) activeStream.point(x, y);
        }

        function polygonInside() {
          var winding = 0;

          for (var i = 0, n = polygon.length; i < n; ++i) {
            for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
              a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
              if (a1 <= y1) {
                if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding;
              } else {
                if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding;
              }
            }
          }

          return winding;
        }

        // Buffer geometry within a polygon and then clip it en masse.
        function polygonStart() {
          activeStream = bufferStream, segments = [], polygon = [], clean = true;
        }

        function polygonEnd() {
          var startInside = polygonInside(),
              cleanInside = clean && startInside,
              visible = (segments = d3Array.merge(segments)).length;
          if (cleanInside || visible) {
            stream.polygonStart();
            if (cleanInside) {
              stream.lineStart();
              interpolate(null, null, 1, stream);
              stream.lineEnd();
            }
            if (visible) {
              clipPolygon(segments, compareIntersection, startInside, interpolate, stream);
            }
            stream.polygonEnd();
          }
          activeStream = stream, segments = polygon = ring = null;
        }

        function lineStart() {
          clipStream.point = linePoint;
          if (polygon) polygon.push(ring = []);
          first = true;
          v_ = false;
          x_ = y_ = NaN;
        }

        // TODO rather than special-case polygons, simply handle them separately.
        // Ideally, coincident intersection points should be jittered to avoid
        // clipping issues.
        function lineEnd() {
          if (segments) {
            linePoint(x__, y__);
            if (v__ && v_) bufferStream.rejoin();
            segments.push(bufferStream.result());
          }
          clipStream.point = point;
          if (v_) activeStream.lineEnd();
        }

        function linePoint(x, y) {
          var v = visible(x, y);
          if (polygon) ring.push([x, y]);
          if (first) {
            x__ = x, y__ = y, v__ = v;
            first = false;
            if (v) {
              activeStream.lineStart();
              activeStream.point(x, y);
            }
          } else {
            if (v && v_) activeStream.point(x, y);else {
              var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
                  b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
              if (clipLine(a, b, x0, y0, x1, y1)) {
                if (!v_) {
                  activeStream.lineStart();
                  activeStream.point(a[0], a[1]);
                }
                activeStream.point(b[0], b[1]);
                if (!v) activeStream.lineEnd();
                clean = false;
              } else if (v) {
                activeStream.lineStart();
                activeStream.point(x, y);
                clean = false;
              }
            }
          }
          x_ = x, y_ = y, v_ = v;
        }

        return clipStream;
      };
    }

    var extent = function () {
      var x0 = 0,
          y0 = 0,
          x1 = 960,
          y1 = 500,
          cache,
          cacheStream,
          clip;

      return clip = {
        stream: function (stream) {
          return cache && cacheStream === stream ? cache : cache = clipExtent(x0, y0, x1, y1)(cacheStream = stream);
        },
        extent: function (_) {
          return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];
        }
      };
    };

    var sum = adder();

    var polygonContains = function (polygon, point) {
      var lambda = point[0],
          phi = point[1],
          normal = [sin(lambda), -cos(lambda), 0],
          angle = 0,
          winding = 0;

      sum.reset();

      for (var i = 0, n = polygon.length; i < n; ++i) {
        if (!(m = (ring = polygon[i]).length)) continue;
        var ring,
            m,
            point0 = ring[m - 1],
            lambda0 = point0[0],
            phi0 = point0[1] / 2 + quarterPi,
            sinPhi0 = sin(phi0),
            cosPhi0 = cos(phi0);

        for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
          var point1 = ring[j],
              lambda1 = point1[0],
              phi1 = point1[1] / 2 + quarterPi,
              sinPhi1 = sin(phi1),
              cosPhi1 = cos(phi1),
              delta = lambda1 - lambda0,
              sign$$1 = delta >= 0 ? 1 : -1,
              absDelta = sign$$1 * delta,
              antimeridian = absDelta > pi,
              k = sinPhi0 * sinPhi1;

          sum.add(atan2(k * sign$$1 * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta)));
          angle += antimeridian ? delta + sign$$1 * tau : delta;

          // Are the longitudes either side of the pointâ€™s meridian (lambda),
          // and are the latitudes smaller than the parallel (phi)?
          if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
            var arc = cartesianCross(cartesian(point0), cartesian(point1));
            cartesianNormalizeInPlace(arc);
            var intersection = cartesianCross(normal, arc);
            cartesianNormalizeInPlace(intersection);
            var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
            if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
              winding += antimeridian ^ delta >= 0 ? 1 : -1;
            }
          }
        }
      }

      // First, determine whether the South pole is inside or outside:
      //
      // It is inside if:
      // * the polygon winds around it in a clockwise direction.
      // * the polygon does not (cumulatively) wind around it, but has a negative
      //   (counter-clockwise) area.
      //
      // Second, count the (signed) number of times a segment crosses a lambda
      // from the point to the South pole.  If it is zero, then the point is the
      // same side as the South pole.

      return (angle < -epsilon || angle < epsilon && sum < -epsilon) ^ winding & 1;
    };

    var lengthSum = adder();
    var lambda0$2;
    var sinPhi0$1;
    var cosPhi0$1;

    var lengthStream = {
      sphere: noop,
      point: noop,
      lineStart: lengthLineStart,
      lineEnd: noop,
      polygonStart: noop,
      polygonEnd: noop
    };

    function lengthLineStart() {
      lengthStream.point = lengthPointFirst;
      lengthStream.lineEnd = lengthLineEnd;
    }

    function lengthLineEnd() {
      lengthStream.point = lengthStream.lineEnd = noop;
    }

    function lengthPointFirst(lambda, phi) {
      lambda *= radians, phi *= radians;
      lambda0$2 = lambda, sinPhi0$1 = sin(phi), cosPhi0$1 = cos(phi);
      lengthStream.point = lengthPoint;
    }

    function lengthPoint(lambda, phi) {
      lambda *= radians, phi *= radians;
      var sinPhi = sin(phi),
          cosPhi = cos(phi),
          delta = abs(lambda - lambda0$2),
          cosDelta = cos(delta),
          sinDelta = sin(delta),
          x = cosPhi * sinDelta,
          y = cosPhi0$1 * sinPhi - sinPhi0$1 * cosPhi * cosDelta,
          z = sinPhi0$1 * sinPhi + cosPhi0$1 * cosPhi * cosDelta;
      lengthSum.add(atan2(sqrt(x * x + y * y), z));
      lambda0$2 = lambda, sinPhi0$1 = sinPhi, cosPhi0$1 = cosPhi;
    }

    var length = function (object) {
      lengthSum.reset();
      geoStream(object, lengthStream);
      return +lengthSum;
    };

    var coordinates = [null, null];
    var object = { type: "LineString", coordinates: coordinates };

    var distance = function (a, b) {
      coordinates[0] = a;
      coordinates[1] = b;
      return length(object);
    };

    var containsObjectType = {
      Feature: function (object, point) {
        return containsGeometry(object.geometry, point);
      },
      FeatureCollection: function (object, point) {
        var features = object.features,
            i = -1,
            n = features.length;
        while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;
        return false;
      }
    };

    var containsGeometryType = {
      Sphere: function () {
        return true;
      },
      Point: function (object, point) {
        return containsPoint(object.coordinates, point);
      },
      MultiPoint: function (object, point) {
        var coordinates = object.coordinates,
            i = -1,
            n = coordinates.length;
        while (++i < n) if (containsPoint(coordinates[i], point)) return true;
        return false;
      },
      LineString: function (object, point) {
        return containsLine(object.coordinates, point);
      },
      MultiLineString: function (object, point) {
        var coordinates = object.coordinates,
            i = -1,
            n = coordinates.length;
        while (++i < n) if (containsLine(coordinates[i], point)) return true;
        return false;
      },
      Polygon: function (object, point) {
        return containsPolygon(object.coordinates, point);
      },
      MultiPolygon: function (object, point) {
        var coordinates = object.coordinates,
            i = -1,
            n = coordinates.length;
        while (++i < n) if (containsPolygon(coordinates[i], point)) return true;
        return false;
      },
      GeometryCollection: function (object, point) {
        var geometries = object.geometries,
            i = -1,
            n = geometries.length;
        while (++i < n) if (containsGeometry(geometries[i], point)) return true;
        return false;
      }
    };

    function containsGeometry(geometry, point) {
      return geometry && containsGeometryType.hasOwnProperty(geometry.type) ? containsGeometryType[geometry.type](geometry, point) : false;
    }

    function containsPoint(coordinates, point) {
      return distance(coordinates, point) === 0;
    }

    function containsLine(coordinates, point) {
      var ab = distance(coordinates[0], coordinates[1]),
          ao = distance(coordinates[0], point),
          ob = distance(point, coordinates[1]);
      return ao + ob <= ab + epsilon;
    }

    function containsPolygon(coordinates, point) {
      return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));
    }

    function ringRadians(ring) {
      return ring = ring.map(pointRadians), ring.pop(), ring;
    }

    function pointRadians(point) {
      return [point[0] * radians, point[1] * radians];
    }

    var contains = function (object, point) {
      return (object && containsObjectType.hasOwnProperty(object.type) ? containsObjectType[object.type] : containsGeometry)(object, point);
    };

    function graticuleX(y0, y1, dy) {
      var y = d3Array.range(y0, y1 - epsilon, dy).concat(y1);
      return function (x) {
        return y.map(function (y) {
          return [x, y];
        });
      };
    }

    function graticuleY(x0, x1, dx) {
      var x = d3Array.range(x0, x1 - epsilon, dx).concat(x1);
      return function (y) {
        return x.map(function (x) {
          return [x, y];
        });
      };
    }

    function graticule() {
      var x1,
          x0,
          X1,
          X0,
          y1,
          y0,
          Y1,
          Y0,
          dx = 10,
          dy = dx,
          DX = 90,
          DY = 360,
          x,
          y,
          X,
          Y,
          precision = 2.5;

      function graticule() {
        return { type: "MultiLineString", coordinates: lines() };
      }

      function lines() {
        return d3Array.range(ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3Array.range(ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3Array.range(ceil(x0 / dx) * dx, x1, dx).filter(function (x) {
          return abs(x % DX) > epsilon;
        }).map(x)).concat(d3Array.range(ceil(y0 / dy) * dy, y1, dy).filter(function (y) {
          return abs(y % DY) > epsilon;
        }).map(y));
      }

      graticule.lines = function () {
        return lines().map(function (coordinates) {
          return { type: "LineString", coordinates: coordinates };
        });
      };

      graticule.outline = function () {
        return {
          type: "Polygon",
          coordinates: [X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1))]
        };
      };

      graticule.extent = function (_) {
        if (!arguments.length) return graticule.extentMinor();
        return graticule.extentMajor(_).extentMinor(_);
      };

      graticule.extentMajor = function (_) {
        if (!arguments.length) return [[X0, Y0], [X1, Y1]];
        X0 = +_[0][0], X1 = +_[1][0];
        Y0 = +_[0][1], Y1 = +_[1][1];
        if (X0 > X1) _ = X0, X0 = X1, X1 = _;
        if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
        return graticule.precision(precision);
      };

      graticule.extentMinor = function (_) {
        if (!arguments.length) return [[x0, y0], [x1, y1]];
        x0 = +_[0][0], x1 = +_[1][0];
        y0 = +_[0][1], y1 = +_[1][1];
        if (x0 > x1) _ = x0, x0 = x1, x1 = _;
        if (y0 > y1) _ = y0, y0 = y1, y1 = _;
        return graticule.precision(precision);
      };

      graticule.step = function (_) {
        if (!arguments.length) return graticule.stepMinor();
        return graticule.stepMajor(_).stepMinor(_);
      };

      graticule.stepMajor = function (_) {
        if (!arguments.length) return [DX, DY];
        DX = +_[0], DY = +_[1];
        return graticule;
      };

      graticule.stepMinor = function (_) {
        if (!arguments.length) return [dx, dy];
        dx = +_[0], dy = +_[1];
        return graticule;
      };

      graticule.precision = function (_) {
        if (!arguments.length) return precision;
        precision = +_;
        x = graticuleX(y0, y1, 90);
        y = graticuleY(x0, x1, precision);
        X = graticuleX(Y0, Y1, 90);
        Y = graticuleY(X0, X1, precision);
        return graticule;
      };

      return graticule.extentMajor([[-180, -90 + epsilon], [180, 90 - epsilon]]).extentMinor([[-180, -80 - epsilon], [180, 80 + epsilon]]);
    }

    function graticule10() {
      return graticule()();
    }

    var interpolate = function (a, b) {
      var x0 = a[0] * radians,
          y0 = a[1] * radians,
          x1 = b[0] * radians,
          y1 = b[1] * radians,
          cy0 = cos(y0),
          sy0 = sin(y0),
          cy1 = cos(y1),
          sy1 = sin(y1),
          kx0 = cy0 * cos(x0),
          ky0 = cy0 * sin(x0),
          kx1 = cy1 * cos(x1),
          ky1 = cy1 * sin(x1),
          d = 2 * asin(sqrt(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),
          k = sin(d);

      var interpolate = d ? function (t) {
        var B = sin(t *= d) / k,
            A = sin(d - t) / k,
            x = A * kx0 + B * kx1,
            y = A * ky0 + B * ky1,
            z = A * sy0 + B * sy1;
        return [atan2(y, x) * degrees, atan2(z, sqrt(x * x + y * y)) * degrees];
      } : function () {
        return [x0 * degrees, y0 * degrees];
      };

      interpolate.distance = d;

      return interpolate;
    };

    var identity = function (x) {
      return x;
    };

    var areaSum$1 = adder();
    var areaRingSum$1 = adder();
    var x00;
    var y00;
    var x0$1;
    var y0$1;

    var areaStream$1 = {
      point: noop,
      lineStart: noop,
      lineEnd: noop,
      polygonStart: function () {
        areaStream$1.lineStart = areaRingStart$1;
        areaStream$1.lineEnd = areaRingEnd$1;
      },
      polygonEnd: function () {
        areaStream$1.lineStart = areaStream$1.lineEnd = areaStream$1.point = noop;
        areaSum$1.add(abs(areaRingSum$1));
        areaRingSum$1.reset();
      },
      result: function () {
        var area = areaSum$1 / 2;
        areaSum$1.reset();
        return area;
      }
    };

    function areaRingStart$1() {
      areaStream$1.point = areaPointFirst$1;
    }

    function areaPointFirst$1(x, y) {
      areaStream$1.point = areaPoint$1;
      x00 = x0$1 = x, y00 = y0$1 = y;
    }

    function areaPoint$1(x, y) {
      areaRingSum$1.add(y0$1 * x - x0$1 * y);
      x0$1 = x, y0$1 = y;
    }

    function areaRingEnd$1() {
      areaPoint$1(x00, y00);
    }

    var x0$2 = Infinity;
    var y0$2 = x0$2;
    var x1 = -x0$2;
    var y1 = x1;

    var boundsStream$1 = {
      point: boundsPoint$1,
      lineStart: noop,
      lineEnd: noop,
      polygonStart: noop,
      polygonEnd: noop,
      result: function () {
        var bounds = [[x0$2, y0$2], [x1, y1]];
        x1 = y1 = -(y0$2 = x0$2 = Infinity);
        return bounds;
      }
    };

    function boundsPoint$1(x, y) {
      if (x < x0$2) x0$2 = x;
      if (x > x1) x1 = x;
      if (y < y0$2) y0$2 = y;
      if (y > y1) y1 = y;
    }

    // TODO Enforce positive area for exterior, negative area for interior?

    var X0$1 = 0;
    var Y0$1 = 0;
    var Z0$1 = 0;
    var X1$1 = 0;
    var Y1$1 = 0;
    var Z1$1 = 0;
    var X2$1 = 0;
    var Y2$1 = 0;
    var Z2$1 = 0;
    var x00$1;
    var y00$1;
    var x0$3;
    var y0$3;

    var centroidStream$1 = {
      point: centroidPoint$1,
      lineStart: centroidLineStart$1,
      lineEnd: centroidLineEnd$1,
      polygonStart: function () {
        centroidStream$1.lineStart = centroidRingStart$1;
        centroidStream$1.lineEnd = centroidRingEnd$1;
      },
      polygonEnd: function () {
        centroidStream$1.point = centroidPoint$1;
        centroidStream$1.lineStart = centroidLineStart$1;
        centroidStream$1.lineEnd = centroidLineEnd$1;
      },
      result: function () {
        var centroid = Z2$1 ? [X2$1 / Z2$1, Y2$1 / Z2$1] : Z1$1 ? [X1$1 / Z1$1, Y1$1 / Z1$1] : Z0$1 ? [X0$1 / Z0$1, Y0$1 / Z0$1] : [NaN, NaN];
        X0$1 = Y0$1 = Z0$1 = X1$1 = Y1$1 = Z1$1 = X2$1 = Y2$1 = Z2$1 = 0;
        return centroid;
      }
    };

    function centroidPoint$1(x, y) {
      X0$1 += x;
      Y0$1 += y;
      ++Z0$1;
    }

    function centroidLineStart$1() {
      centroidStream$1.point = centroidPointFirstLine;
    }

    function centroidPointFirstLine(x, y) {
      centroidStream$1.point = centroidPointLine;
      centroidPoint$1(x0$3 = x, y0$3 = y);
    }

    function centroidPointLine(x, y) {
      var dx = x - x0$3,
          dy = y - y0$3,
          z = sqrt(dx * dx + dy * dy);
      X1$1 += z * (x0$3 + x) / 2;
      Y1$1 += z * (y0$3 + y) / 2;
      Z1$1 += z;
      centroidPoint$1(x0$3 = x, y0$3 = y);
    }

    function centroidLineEnd$1() {
      centroidStream$1.point = centroidPoint$1;
    }

    function centroidRingStart$1() {
      centroidStream$1.point = centroidPointFirstRing;
    }

    function centroidRingEnd$1() {
      centroidPointRing(x00$1, y00$1);
    }

    function centroidPointFirstRing(x, y) {
      centroidStream$1.point = centroidPointRing;
      centroidPoint$1(x00$1 = x0$3 = x, y00$1 = y0$3 = y);
    }

    function centroidPointRing(x, y) {
      var dx = x - x0$3,
          dy = y - y0$3,
          z = sqrt(dx * dx + dy * dy);

      X1$1 += z * (x0$3 + x) / 2;
      Y1$1 += z * (y0$3 + y) / 2;
      Z1$1 += z;

      z = y0$3 * x - x0$3 * y;
      X2$1 += z * (x0$3 + x);
      Y2$1 += z * (y0$3 + y);
      Z2$1 += z * 3;
      centroidPoint$1(x0$3 = x, y0$3 = y);
    }

    function PathContext(context) {
      this._context = context;
    }

    PathContext.prototype = {
      _radius: 4.5,
      pointRadius: function (_) {
        return this._radius = _, this;
      },
      polygonStart: function () {
        this._line = 0;
      },
      polygonEnd: function () {
        this._line = NaN;
      },
      lineStart: function () {
        this._point = 0;
      },
      lineEnd: function () {
        if (this._line === 0) this._context.closePath();
        this._point = NaN;
      },
      point: function (x, y) {
        switch (this._point) {
          case 0:
            {
              this._context.moveTo(x, y);
              this._point = 1;
              break;
            }
          case 1:
            {
              this._context.lineTo(x, y);
              break;
            }
          default:
            {
              this._context.moveTo(x + this._radius, y);
              this._context.arc(x, y, this._radius, 0, tau);
              break;
            }
        }
      },
      result: noop
    };

    var lengthSum$1 = adder();
    var lengthRing;
    var x00$2;
    var y00$2;
    var x0$4;
    var y0$4;

    var lengthStream$1 = {
      point: noop,
      lineStart: function () {
        lengthStream$1.point = lengthPointFirst$1;
      },
      lineEnd: function () {
        if (lengthRing) lengthPoint$1(x00$2, y00$2);
        lengthStream$1.point = noop;
      },
      polygonStart: function () {
        lengthRing = true;
      },
      polygonEnd: function () {
        lengthRing = null;
      },
      result: function () {
        var length = +lengthSum$1;
        lengthSum$1.reset();
        return length;
      }
    };

    function lengthPointFirst$1(x, y) {
      lengthStream$1.point = lengthPoint$1;
      x00$2 = x0$4 = x, y00$2 = y0$4 = y;
    }

    function lengthPoint$1(x, y) {
      x0$4 -= x, y0$4 -= y;
      lengthSum$1.add(sqrt(x0$4 * x0$4 + y0$4 * y0$4));
      x0$4 = x, y0$4 = y;
    }

    function PathString() {
      this._string = [];
    }

    PathString.prototype = {
      _radius: 4.5,
      _circle: circle$1(4.5),
      pointRadius: function (_) {
        if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
        return this;
      },
      polygonStart: function () {
        this._line = 0;
      },
      polygonEnd: function () {
        this._line = NaN;
      },
      lineStart: function () {
        this._point = 0;
      },
      lineEnd: function () {
        if (this._line === 0) this._string.push("Z");
        this._point = NaN;
      },
      point: function (x, y) {
        switch (this._point) {
          case 0:
            {
              this._string.push("M", x, ",", y);
              this._point = 1;
              break;
            }
          case 1:
            {
              this._string.push("L", x, ",", y);
              break;
            }
          default:
            {
              if (this._circle == null) this._circle = circle$1(this._radius);
              this._string.push("M", x, ",", y, this._circle);
              break;
            }
        }
      },
      result: function () {
        if (this._string.length) {
          var result = this._string.join("");
          this._string = [];
          return result;
        } else {
          return null;
        }
      }
    };

    function circle$1(radius) {
      return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
    }

    var index = function (projection, context) {
      var pointRadius = 4.5,
          projectionStream,
          contextStream;

      function path(object) {
        if (object) {
          if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
          geoStream(object, projectionStream(contextStream));
        }
        return contextStream.result();
      }

      path.area = function (object) {
        geoStream(object, projectionStream(areaStream$1));
        return areaStream$1.result();
      };

      path.measure = function (object) {
        geoStream(object, projectionStream(lengthStream$1));
        return lengthStream$1.result();
      };

      path.bounds = function (object) {
        geoStream(object, projectionStream(boundsStream$1));
        return boundsStream$1.result();
      };

      path.centroid = function (object) {
        geoStream(object, projectionStream(centroidStream$1));
        return centroidStream$1.result();
      };

      path.projection = function (_) {
        return arguments.length ? (projectionStream = _ == null ? (projection = null, identity) : (projection = _).stream, path) : projection;
      };

      path.context = function (_) {
        if (!arguments.length) return context;
        contextStream = _ == null ? (context = null, new PathString()) : new PathContext(context = _);
        if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
        return path;
      };

      path.pointRadius = function (_) {
        if (!arguments.length) return pointRadius;
        pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
        return path;
      };

      return path.projection(projection).context(context);
    };

    var clip = function (pointVisible, clipLine, interpolate, start) {
      return function (rotate, sink) {
        var line = clipLine(sink),
            rotatedStart = rotate.invert(start[0], start[1]),
            ringBuffer = clipBuffer(),
            ringSink = clipLine(ringBuffer),
            polygonStarted = false,
            polygon,
            segments,
            ring;

        var clip = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: function () {
            clip.point = pointRing;
            clip.lineStart = ringStart;
            clip.lineEnd = ringEnd;
            segments = [];
            polygon = [];
          },
          polygonEnd: function () {
            clip.point = point;
            clip.lineStart = lineStart;
            clip.lineEnd = lineEnd;
            segments = d3Array.merge(segments);
            var startInside = polygonContains(polygon, rotatedStart);
            if (segments.length) {
              if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
              clipPolygon(segments, compareIntersection, startInside, interpolate, sink);
            } else if (startInside) {
              if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
              sink.lineStart();
              interpolate(null, null, 1, sink);
              sink.lineEnd();
            }
            if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
            segments = polygon = null;
          },
          sphere: function () {
            sink.polygonStart();
            sink.lineStart();
            interpolate(null, null, 1, sink);
            sink.lineEnd();
            sink.polygonEnd();
          }
        };

        function point(lambda, phi) {
          var point = rotate(lambda, phi);
          if (pointVisible(lambda = point[0], phi = point[1])) sink.point(lambda, phi);
        }

        function pointLine(lambda, phi) {
          var point = rotate(lambda, phi);
          line.point(point[0], point[1]);
        }

        function lineStart() {
          clip.point = pointLine;
          line.lineStart();
        }

        function lineEnd() {
          clip.point = point;
          line.lineEnd();
        }

        function pointRing(lambda, phi) {
          ring.push([lambda, phi]);
          var point = rotate(lambda, phi);
          ringSink.point(point[0], point[1]);
        }

        function ringStart() {
          ringSink.lineStart();
          ring = [];
        }

        function ringEnd() {
          pointRing(ring[0][0], ring[0][1]);
          ringSink.lineEnd();

          var clean = ringSink.clean(),
              ringSegments = ringBuffer.result(),
              i,
              n = ringSegments.length,
              m,
              segment,
              point;

          ring.pop();
          polygon.push(ring);
          ring = null;

          if (!n) return;

          // No intersections.
          if (clean & 1) {
            segment = ringSegments[0];
            if ((m = segment.length - 1) > 0) {
              if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
              sink.lineStart();
              for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
              sink.lineEnd();
            }
            return;
          }

          // Rejoin connected segments.
          // TODO reuse ringBuffer.rejoin()?
          if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

          segments.push(ringSegments.filter(validSegment));
        }

        return clip;
      };
    };

    function validSegment(segment) {
      return segment.length > 1;
    }

    // Intersections are sorted along the clip edge. For both antimeridian cutting
    // and circle clipping, the same comparison is used.
    function compareIntersection(a, b) {
      return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);
    }

    var clipAntimeridian = clip(function () {
      return true;
    }, clipAntimeridianLine, clipAntimeridianInterpolate, [-pi, -halfPi]);

    // Takes a line and cuts into visible segments. Return values: 0 - there were
    // intersections or the line was empty; 1 - no intersections; 2 - there were
    // intersections, and the first and last segments should be rejoined.
    function clipAntimeridianLine(stream) {
      var lambda0 = NaN,
          phi0 = NaN,
          sign0 = NaN,
          clean; // no intersections

      return {
        lineStart: function () {
          stream.lineStart();
          clean = 1;
        },
        point: function (lambda1, phi1) {
          var sign1 = lambda1 > 0 ? pi : -pi,
              delta = abs(lambda1 - lambda0);
          if (abs(delta - pi) < epsilon) {
            // line crosses a pole
            stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);
            stream.point(sign0, phi0);
            stream.lineEnd();
            stream.lineStart();
            stream.point(sign1, phi0);
            stream.point(lambda1, phi0);
            clean = 0;
          } else if (sign0 !== sign1 && delta >= pi) {
            // line crosses antimeridian
            if (abs(lambda0 - sign0) < epsilon) lambda0 -= sign0 * epsilon; // handle degeneracies
            if (abs(lambda1 - sign1) < epsilon) lambda1 -= sign1 * epsilon;
            phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
            stream.point(sign0, phi0);
            stream.lineEnd();
            stream.lineStart();
            stream.point(sign1, phi0);
            clean = 0;
          }
          stream.point(lambda0 = lambda1, phi0 = phi1);
          sign0 = sign1;
        },
        lineEnd: function () {
          stream.lineEnd();
          lambda0 = phi0 = NaN;
        },
        clean: function () {
          return 2 - clean; // if intersections, rejoin first and last segments
        }
      };
    }

    function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
      var cosPhi0,
          cosPhi1,
          sinLambda0Lambda1 = sin(lambda0 - lambda1);
      return abs(sinLambda0Lambda1) > epsilon ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1) - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
    }

    function clipAntimeridianInterpolate(from, to, direction, stream) {
      var phi;
      if (from == null) {
        phi = direction * halfPi;
        stream.point(-pi, phi);
        stream.point(0, phi);
        stream.point(pi, phi);
        stream.point(pi, 0);
        stream.point(pi, -phi);
        stream.point(0, -phi);
        stream.point(-pi, -phi);
        stream.point(-pi, 0);
        stream.point(-pi, phi);
      } else if (abs(from[0] - to[0]) > epsilon) {
        var lambda = from[0] < to[0] ? pi : -pi;
        phi = direction * lambda / 2;
        stream.point(-lambda, phi);
        stream.point(0, phi);
        stream.point(lambda, phi);
      } else {
        stream.point(to[0], to[1]);
      }
    }

    var clipCircle = function (radius, delta) {
      var cr = cos(radius),
          smallRadius = cr > 0,
          notHemisphere = abs(cr) > epsilon; // TODO optimise for this common case

      function interpolate(from, to, direction, stream) {
        circleStream(stream, radius, delta, direction, from, to);
      }

      function visible(lambda, phi) {
        return cos(lambda) * cos(phi) > cr;
      }

      // Takes a line and cuts into visible segments. Return values used for polygon
      // clipping: 0 - there were intersections or the line was empty; 1 - no
      // intersections 2 - there were intersections, and the first and last segments
      // should be rejoined.
      function clipLine(stream) {
        var point0, // previous point
        c0, // code for previous point
        v0, // visibility of previous point
        v00, // visibility of first point
        clean; // no intersections
        return {
          lineStart: function () {
            v00 = v0 = false;
            clean = 1;
          },
          point: function (lambda, phi) {
            var point1 = [lambda, phi],
                point2,
                v = visible(lambda, phi),
                c = smallRadius ? v ? 0 : code(lambda, phi) : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;
            if (!point0 && (v00 = v0 = v)) stream.lineStart();
            // Handle degeneracies.
            // TODO ignore if not clipping polygons.
            if (v !== v0) {
              point2 = intersect(point0, point1);
              if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {
                point1[0] += epsilon;
                point1[1] += epsilon;
                v = visible(point1[0], point1[1]);
              }
            }
            if (v !== v0) {
              clean = 0;
              if (v) {
                // outside going in
                stream.lineStart();
                point2 = intersect(point1, point0);
                stream.point(point2[0], point2[1]);
              } else {
                // inside going out
                point2 = intersect(point0, point1);
                stream.point(point2[0], point2[1]);
                stream.lineEnd();
              }
              point0 = point2;
            } else if (notHemisphere && point0 && smallRadius ^ v) {
              var t;
              // If the codes for two points are different, or are both zero,
              // and there this segment intersects with the small circle.
              if (!(c & c0) && (t = intersect(point1, point0, true))) {
                clean = 0;
                if (smallRadius) {
                  stream.lineStart();
                  stream.point(t[0][0], t[0][1]);
                  stream.point(t[1][0], t[1][1]);
                  stream.lineEnd();
                } else {
                  stream.point(t[1][0], t[1][1]);
                  stream.lineEnd();
                  stream.lineStart();
                  stream.point(t[0][0], t[0][1]);
                }
              }
            }
            if (v && (!point0 || !pointEqual(point0, point1))) {
              stream.point(point1[0], point1[1]);
            }
            point0 = point1, v0 = v, c0 = c;
          },
          lineEnd: function () {
            if (v0) stream.lineEnd();
            point0 = null;
          },
          // Rejoin first and last segments if there were intersections and the first
          // and last points were visible.
          clean: function () {
            return clean | (v00 && v0) << 1;
          }
        };
      }

      // Intersects the great circle between a and b with the clip circle.
      function intersect(a, b, two) {
        var pa = cartesian(a),
            pb = cartesian(b);

        // We have two planes, n1.p = d1 and n2.p = d2.
        // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 â¨¯ n2).
        var n1 = [1, 0, 0],
            // normal
        n2 = cartesianCross(pa, pb),
            n2n2 = cartesianDot(n2, n2),
            n1n2 = n2[0],
            // cartesianDot(n1, n2),
        determinant = n2n2 - n1n2 * n1n2;

        // Two polar points.
        if (!determinant) return !two && a;

        var c1 = cr * n2n2 / determinant,
            c2 = -cr * n1n2 / determinant,
            n1xn2 = cartesianCross(n1, n2),
            A = cartesianScale(n1, c1),
            B = cartesianScale(n2, c2);
        cartesianAddInPlace(A, B);

        // Solve |p(t)|^2 = 1.
        var u = n1xn2,
            w = cartesianDot(A, u),
            uu = cartesianDot(u, u),
            t2 = w * w - uu * (cartesianDot(A, A) - 1);

        if (t2 < 0) return;

        var t = sqrt(t2),
            q = cartesianScale(u, (-w - t) / uu);
        cartesianAddInPlace(q, A);
        q = spherical(q);

        if (!two) return q;

        // Two intersection points.
        var lambda0 = a[0],
            lambda1 = b[0],
            phi0 = a[1],
            phi1 = b[1],
            z;

        if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

        var delta = lambda1 - lambda0,
            polar = abs(delta - pi) < epsilon,
            meridian = polar || delta < epsilon;

        if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

        // Check that the first point is between a and b.
        if (meridian ? polar ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
          var q1 = cartesianScale(u, (-w + t) / uu);
          cartesianAddInPlace(q1, A);
          return [q, spherical(q1)];
        }
      }

      // Generates a 4-bit vector representing the location of a point relative to
      // the small circle's bounding box.
      function code(lambda, phi) {
        var r = smallRadius ? radius : pi - radius,
            code = 0;
        if (lambda < -r) code |= 1; // left
        else if (lambda > r) code |= 2; // right
        if (phi < -r) code |= 4; // below
        else if (phi > r) code |= 8; // above
        return code;
      }

      return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);
    };

    var transform = function (methods) {
      return {
        stream: transformer(methods)
      };
    };

    function transformer(methods) {
      return function (stream) {
        var s = new TransformStream();
        for (var key in methods) s[key] = methods[key];
        s.stream = stream;
        return s;
      };
    }

    function TransformStream() {}

    TransformStream.prototype = {
      constructor: TransformStream,
      point: function (x, y) {
        this.stream.point(x, y);
      },
      sphere: function () {
        this.stream.sphere();
      },
      lineStart: function () {
        this.stream.lineStart();
      },
      lineEnd: function () {
        this.stream.lineEnd();
      },
      polygonStart: function () {
        this.stream.polygonStart();
      },
      polygonEnd: function () {
        this.stream.polygonEnd();
      }
    };

    function fitExtent(projection, extent, object) {
      var w = extent[1][0] - extent[0][0],
          h = extent[1][1] - extent[0][1],
          clip = projection.clipExtent && projection.clipExtent();

      projection.scale(150).translate([0, 0]);

      if (clip != null) projection.clipExtent(null);

      geoStream(object, projection.stream(boundsStream$1));

      var b = boundsStream$1.result(),
          k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
          x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
          y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;

      if (clip != null) projection.clipExtent(clip);

      return projection.scale(k * 150).translate([x, y]);
    }

    function fitSize(projection, size, object) {
      return fitExtent(projection, [[0, 0], size], object);
    }

    var maxDepth = 16;
    var cosMinDistance = cos(30 * radians); // cos(minimum angular distance)

    var resample = function (project, delta2) {
      return +delta2 ? resample$1(project, delta2) : resampleNone(project);
    };

    function resampleNone(project) {
      return transformer({
        point: function (x, y) {
          x = project(x, y);
          this.stream.point(x[0], x[1]);
        }
      });
    }

    function resample$1(project, delta2) {

      function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
        var dx = x1 - x0,
            dy = y1 - y0,
            d2 = dx * dx + dy * dy;
        if (d2 > 4 * delta2 && depth--) {
          var a = a0 + a1,
              b = b0 + b1,
              c = c0 + c1,
              m = sqrt(a * a + b * b + c * c),
              phi2 = asin(c /= m),
              lambda2 = abs(abs(c) - 1) < epsilon || abs(lambda0 - lambda1) < epsilon ? (lambda0 + lambda1) / 2 : atan2(b, a),
              p = project(lambda2, phi2),
              x2 = p[0],
              y2 = p[1],
              dx2 = x2 - x0,
              dy2 = y2 - y0,
              dz = dy * dx2 - dx * dy2;
          if (dz * dz / d2 > delta2 // perpendicular projected distance
          || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
          || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
            // angular distance
            resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
            stream.point(x2, y2);
            resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
          }
        }
      }
      return function (stream) {
        var lambda00, x00, y00, a00, b00, c00, // first point
        lambda0, x0, y0, a0, b0, c0; // previous point

        var resampleStream = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: function () {
            stream.polygonStart();resampleStream.lineStart = ringStart;
          },
          polygonEnd: function () {
            stream.polygonEnd();resampleStream.lineStart = lineStart;
          }
        };

        function point(x, y) {
          x = project(x, y);
          stream.point(x[0], x[1]);
        }

        function lineStart() {
          x0 = NaN;
          resampleStream.point = linePoint;
          stream.lineStart();
        }

        function linePoint(lambda, phi) {
          var c = cartesian([lambda, phi]),
              p = project(lambda, phi);
          resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
          stream.point(x0, y0);
        }

        function lineEnd() {
          resampleStream.point = point;
          stream.lineEnd();
        }

        function ringStart() {
          lineStart();
          resampleStream.point = ringPoint;
          resampleStream.lineEnd = ringEnd;
        }

        function ringPoint(lambda, phi) {
          linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
          resampleStream.point = linePoint;
        }

        function ringEnd() {
          resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
          resampleStream.lineEnd = lineEnd;
          lineEnd();
        }

        return resampleStream;
      };
    }

    var transformRadians = transformer({
      point: function (x, y) {
        this.stream.point(x * radians, y * radians);
      }
    });

    function projection(project) {
      return projectionMutator(function () {
        return project;
      })();
    }

    function projectionMutator(projectAt) {
      var project,
          k = 150,
          // scale
      x = 480,
          y = 250,
          // translate
      dx,
          dy,
          lambda = 0,
          phi = 0,
          // center
      deltaLambda = 0,
          deltaPhi = 0,
          deltaGamma = 0,
          rotate,
          projectRotate,
          // rotate
      theta = null,
          preclip = clipAntimeridian,
          // clip angle
      x0 = null,
          y0,
          x1,
          y1,
          postclip = identity,
          // clip extent
      delta2 = 0.5,
          projectResample = resample(projectTransform, delta2),
          // precision
      cache,
          cacheStream;

      function projection(point) {
        point = projectRotate(point[0] * radians, point[1] * radians);
        return [point[0] * k + dx, dy - point[1] * k];
      }

      function invert(point) {
        point = projectRotate.invert((point[0] - dx) / k, (dy - point[1]) / k);
        return point && [point[0] * degrees, point[1] * degrees];
      }

      function projectTransform(x, y) {
        return x = project(x, y), [x[0] * k + dx, dy - x[1] * k];
      }

      projection.stream = function (stream) {
        return cache && cacheStream === stream ? cache : cache = transformRadians(preclip(rotate, projectResample(postclip(cacheStream = stream))));
      };

      projection.clipAngle = function (_) {
        return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians, 6 * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;
      };

      projection.clipExtent = function (_) {
        return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
      };

      projection.scale = function (_) {
        return arguments.length ? (k = +_, recenter()) : k;
      };

      projection.translate = function (_) {
        return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
      };

      projection.center = function (_) {
        return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];
      };

      projection.rotate = function (_) {
        return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
      };

      projection.precision = function (_) {
        return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);
      };

      projection.fitExtent = function (extent, object) {
        return fitExtent(projection, extent, object);
      };

      projection.fitSize = function (size, object) {
        return fitSize(projection, size, object);
      };

      function recenter() {
        projectRotate = compose(rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma), project);
        var center = project(lambda, phi);
        dx = x - center[0] * k;
        dy = y + center[1] * k;
        return reset();
      }

      function reset() {
        cache = cacheStream = null;
        return projection;
      }

      return function () {
        project = projectAt.apply(this, arguments);
        projection.invert = project.invert && invert;
        return recenter();
      };
    }

    function conicProjection(projectAt) {
      var phi0 = 0,
          phi1 = pi / 3,
          m = projectionMutator(projectAt),
          p = m(phi0, phi1);

      p.parallels = function (_) {
        return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees, phi1 * degrees];
      };

      return p;
    }

    function cylindricalEqualAreaRaw(phi0) {
      var cosPhi0 = cos(phi0);

      function forward(lambda, phi) {
        return [lambda * cosPhi0, sin(phi) / cosPhi0];
      }

      forward.invert = function (x, y) {
        return [x / cosPhi0, asin(y * cosPhi0)];
      };

      return forward;
    }

    function conicEqualAreaRaw(y0, y1) {
      var sy0 = sin(y0),
          n = (sy0 + sin(y1)) / 2;

      // Are the parallels symmetrical around the Equator?
      if (abs(n) < epsilon) return cylindricalEqualAreaRaw(y0);

      var c = 1 + sy0 * (2 * n - sy0),
          r0 = sqrt(c) / n;

      function project(x, y) {
        var r = sqrt(c - 2 * n * sin(y)) / n;
        return [r * sin(x *= n), r0 - r * cos(x)];
      }

      project.invert = function (x, y) {
        var r0y = r0 - y;
        return [atan2(x, abs(r0y)) / n * sign(r0y), asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
      };

      return project;
    }

    var conicEqualArea = function () {
      return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
    };

    var albers = function () {
      return conicEqualArea().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
    };

    // The projections must have mutually exclusive clip regions on the sphere,
    // as this will avoid emitting interleaving lines and polygons.
    function multiplex(streams) {
      var n = streams.length;
      return {
        point: function (x, y) {
          var i = -1;while (++i < n) streams[i].point(x, y);
        },
        sphere: function () {
          var i = -1;while (++i < n) streams[i].sphere();
        },
        lineStart: function () {
          var i = -1;while (++i < n) streams[i].lineStart();
        },
        lineEnd: function () {
          var i = -1;while (++i < n) streams[i].lineEnd();
        },
        polygonStart: function () {
          var i = -1;while (++i < n) streams[i].polygonStart();
        },
        polygonEnd: function () {
          var i = -1;while (++i < n) streams[i].polygonEnd();
        }
      };
    }

    // A composite projection for the United States, configured by default for
    // 960Ã—500. The projection also works quite well at 960Ã—600 if you change the
    // scale to 1285 and adjust the translate accordingly. The set of standard
    // parallels for each region comes from USGS, which is published here:
    // http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
    var albersUsa = function () {
      var cache,
          cacheStream,
          lower48 = albers(),
          lower48Point,
          alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]),
          alaskaPoint,
          // EPSG:3338
      hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]),
          hawaiiPoint,
          // ESRI:102007
      point,
          pointStream = { point: function (x, y) {
          point = [x, y];
        } };

      function albersUsa(coordinates) {
        var x = coordinates[0],
            y = coordinates[1];
        return point = null, (lower48Point.point(x, y), point) || (alaskaPoint.point(x, y), point) || (hawaiiPoint.point(x, y), point);
      }

      albersUsa.invert = function (coordinates) {
        var k = lower48.scale(),
            t = lower48.translate(),
            x = (coordinates[0] - t[0]) / k,
            y = (coordinates[1] - t[1]) / k;
        return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii : lower48).invert(coordinates);
      };

      albersUsa.stream = function (stream) {
        return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
      };

      albersUsa.precision = function (_) {
        if (!arguments.length) return lower48.precision();
        lower48.precision(_), alaska.precision(_), hawaii.precision(_);
        return reset();
      };

      albersUsa.scale = function (_) {
        if (!arguments.length) return lower48.scale();
        lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
        return albersUsa.translate(lower48.translate());
      };

      albersUsa.translate = function (_) {
        if (!arguments.length) return lower48.translate();
        var k = lower48.scale(),
            x = +_[0],
            y = +_[1];

        lower48Point = lower48.translate(_).clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]]).stream(pointStream);

        alaskaPoint = alaska.translate([x - 0.307 * k, y + 0.201 * k]).clipExtent([[x - 0.425 * k + epsilon, y + 0.120 * k + epsilon], [x - 0.214 * k - epsilon, y + 0.234 * k - epsilon]]).stream(pointStream);

        hawaiiPoint = hawaii.translate([x - 0.205 * k, y + 0.212 * k]).clipExtent([[x - 0.214 * k + epsilon, y + 0.166 * k + epsilon], [x - 0.115 * k - epsilon, y + 0.234 * k - epsilon]]).stream(pointStream);

        return reset();
      };

      albersUsa.fitExtent = function (extent, object) {
        return fitExtent(albersUsa, extent, object);
      };

      albersUsa.fitSize = function (size, object) {
        return fitSize(albersUsa, size, object);
      };

      function reset() {
        cache = cacheStream = null;
        return albersUsa;
      }

      return albersUsa.scale(1070);
    };

    function azimuthalRaw(scale) {
      return function (x, y) {
        var cx = cos(x),
            cy = cos(y),
            k = scale(cx * cy);
        return [k * cy * sin(x), k * sin(y)];
      };
    }

    function azimuthalInvert(angle) {
      return function (x, y) {
        var z = sqrt(x * x + y * y),
            c = angle(z),
            sc = sin(c),
            cc = cos(c);
        return [atan2(x * sc, z * cc), asin(z && y * sc / z)];
      };
    }

    var azimuthalEqualAreaRaw = azimuthalRaw(function (cxcy) {
      return sqrt(2 / (1 + cxcy));
    });

    azimuthalEqualAreaRaw.invert = azimuthalInvert(function (z) {
      return 2 * asin(z / 2);
    });

    var azimuthalEqualArea = function () {
      return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
    };

    var azimuthalEquidistantRaw = azimuthalRaw(function (c) {
      return (c = acos(c)) && c / sin(c);
    });

    azimuthalEquidistantRaw.invert = azimuthalInvert(function (z) {
      return z;
    });

    var azimuthalEquidistant = function () {
      return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
    };

    function mercatorRaw(lambda, phi) {
      return [lambda, log(tan((halfPi + phi) / 2))];
    }

    mercatorRaw.invert = function (x, y) {
      return [x, 2 * atan(exp(y)) - halfPi];
    };

    var mercator = function () {
      return mercatorProjection(mercatorRaw).scale(961 / tau);
    };

    function mercatorProjection(project) {
      var m = projection(project),
          center = m.center,
          scale = m.scale,
          translate = m.translate,
          clipExtent = m.clipExtent,
          x0 = null,
          y0,
          x1,
          y1; // clip extent

      m.scale = function (_) {
        return arguments.length ? (scale(_), reclip()) : scale();
      };

      m.translate = function (_) {
        return arguments.length ? (translate(_), reclip()) : translate();
      };

      m.center = function (_) {
        return arguments.length ? (center(_), reclip()) : center();
      };

      m.clipExtent = function (_) {
        return arguments.length ? (_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];
      };

      function reclip() {
        var k = pi * scale(),
            t = m(rotation(m.rotate()).invert([0, 0]));
        return clipExtent(x0 == null ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]] : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);
      }

      return reclip();
    }

    function tany(y) {
      return tan((halfPi + y) / 2);
    }

    function conicConformalRaw(y0, y1) {
      var cy0 = cos(y0),
          n = y0 === y1 ? sin(y0) : log(cy0 / cos(y1)) / log(tany(y1) / tany(y0)),
          f = cy0 * pow(tany(y0), n) / n;

      if (!n) return mercatorRaw;

      function project(x, y) {
        if (f > 0) {
          if (y < -halfPi + epsilon) y = -halfPi + epsilon;
        } else {
          if (y > halfPi - epsilon) y = halfPi - epsilon;
        }
        var r = f / pow(tany(y), n);
        return [r * sin(n * x), f - r * cos(n * x)];
      }

      project.invert = function (x, y) {
        var fy = f - y,
            r = sign(n) * sqrt(x * x + fy * fy);
        return [atan2(x, abs(fy)) / n * sign(fy), 2 * atan(pow(f / r, 1 / n)) - halfPi];
      };

      return project;
    }

    var conicConformal = function () {
      return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
    };

    function equirectangularRaw(lambda, phi) {
      return [lambda, phi];
    }

    equirectangularRaw.invert = equirectangularRaw;

    var equirectangular = function () {
      return projection(equirectangularRaw).scale(152.63);
    };

    function conicEquidistantRaw(y0, y1) {
      var cy0 = cos(y0),
          n = y0 === y1 ? sin(y0) : (cy0 - cos(y1)) / (y1 - y0),
          g = cy0 / n + y0;

      if (abs(n) < epsilon) return equirectangularRaw;

      function project(x, y) {
        var gy = g - y,
            nx = n * x;
        return [gy * sin(nx), g - gy * cos(nx)];
      }

      project.invert = function (x, y) {
        var gy = g - y;
        return [atan2(x, abs(gy)) / n * sign(gy), g - sign(n) * sqrt(x * x + gy * gy)];
      };

      return project;
    }

    var conicEquidistant = function () {
      return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
    };

    function gnomonicRaw(x, y) {
      var cy = cos(y),
          k = cos(x) * cy;
      return [cy * sin(x) / k, sin(y) / k];
    }

    gnomonicRaw.invert = azimuthalInvert(atan);

    var gnomonic = function () {
      return projection(gnomonicRaw).scale(144.049).clipAngle(60);
    };

    function scaleTranslate(kx, ky, tx, ty) {
      return kx === 1 && ky === 1 && tx === 0 && ty === 0 ? identity : transformer({
        point: function (x, y) {
          this.stream.point(x * kx + tx, y * ky + ty);
        }
      });
    }

    var identity$1 = function () {
      var k = 1,
          tx = 0,
          ty = 0,
          sx = 1,
          sy = 1,
          transform = identity,
          // scale, translate and reflect
      x0 = null,
          y0,
          x1,
          y1,
          clip = identity,
          // clip extent
      cache,
          cacheStream,
          projection;

      function reset() {
        cache = cacheStream = null;
        return projection;
      }

      return projection = {
        stream: function (stream) {
          return cache && cacheStream === stream ? cache : cache = transform(clip(cacheStream = stream));
        },
        clipExtent: function (_) {
          return arguments.length ? (clip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
        },
        scale: function (_) {
          return arguments.length ? (transform = scaleTranslate((k = +_) * sx, k * sy, tx, ty), reset()) : k;
        },
        translate: function (_) {
          return arguments.length ? (transform = scaleTranslate(k * sx, k * sy, tx = +_[0], ty = +_[1]), reset()) : [tx, ty];
        },
        reflectX: function (_) {
          return arguments.length ? (transform = scaleTranslate(k * (sx = _ ? -1 : 1), k * sy, tx, ty), reset()) : sx < 0;
        },
        reflectY: function (_) {
          return arguments.length ? (transform = scaleTranslate(k * sx, k * (sy = _ ? -1 : 1), tx, ty), reset()) : sy < 0;
        },
        fitExtent: function (extent, object) {
          return fitExtent(projection, extent, object);
        },
        fitSize: function (size, object) {
          return fitSize(projection, size, object);
        }
      };
    };

    function orthographicRaw(x, y) {
      return [cos(y) * sin(x), sin(y)];
    }

    orthographicRaw.invert = azimuthalInvert(asin);

    var orthographic = function () {
      return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon);
    };

    function stereographicRaw(x, y) {
      var cy = cos(y),
          k = 1 + cos(x) * cy;
      return [cy * sin(x) / k, sin(y) / k];
    }

    stereographicRaw.invert = azimuthalInvert(function (z) {
      return 2 * atan(z);
    });

    var stereographic = function () {
      return projection(stereographicRaw).scale(250).clipAngle(142);
    };

    function transverseMercatorRaw(lambda, phi) {
      return [log(tan((halfPi + phi) / 2)), -lambda];
    }

    transverseMercatorRaw.invert = function (x, y) {
      return [-y, 2 * atan(exp(x)) - halfPi];
    };

    var transverseMercator = function () {
      var m = mercatorProjection(transverseMercatorRaw),
          center = m.center,
          rotate = m.rotate;

      m.center = function (_) {
        return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
      };

      m.rotate = function (_) {
        return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
      };

      return rotate([0, 0, 90]).scale(159.155);
    };

    exports.geoArea = area;
    exports.geoBounds = bounds;
    exports.geoCentroid = centroid;
    exports.geoCircle = circle;
    exports.geoClipExtent = extent;
    exports.geoContains = contains;
    exports.geoDistance = distance;
    exports.geoGraticule = graticule;
    exports.geoGraticule10 = graticule10;
    exports.geoInterpolate = interpolate;
    exports.geoLength = length;
    exports.geoPath = index;
    exports.geoAlbers = albers;
    exports.geoAlbersUsa = albersUsa;
    exports.geoAzimuthalEqualArea = azimuthalEqualArea;
    exports.geoAzimuthalEqualAreaRaw = azimuthalEqualAreaRaw;
    exports.geoAzimuthalEquidistant = azimuthalEquidistant;
    exports.geoAzimuthalEquidistantRaw = azimuthalEquidistantRaw;
    exports.geoConicConformal = conicConformal;
    exports.geoConicConformalRaw = conicConformalRaw;
    exports.geoConicEqualArea = conicEqualArea;
    exports.geoConicEqualAreaRaw = conicEqualAreaRaw;
    exports.geoConicEquidistant = conicEquidistant;
    exports.geoConicEquidistantRaw = conicEquidistantRaw;
    exports.geoEquirectangular = equirectangular;
    exports.geoEquirectangularRaw = equirectangularRaw;
    exports.geoGnomonic = gnomonic;
    exports.geoGnomonicRaw = gnomonicRaw;
    exports.geoIdentity = identity$1;
    exports.geoProjection = projection;
    exports.geoProjectionMutator = projectionMutator;
    exports.geoMercator = mercator;
    exports.geoMercatorRaw = mercatorRaw;
    exports.geoOrthographic = orthographic;
    exports.geoOrthographicRaw = orthographicRaw;
    exports.geoStereographic = stereographic;
    exports.geoStereographicRaw = stereographicRaw;
    exports.geoTransverseMercator = transverseMercator;
    exports.geoTransverseMercatorRaw = transverseMercatorRaw;
    exports.geoRotation = rotation;
    exports.geoStream = geoStream;
    exports.geoTransform = transform;

    Object.defineProperty(exports, '__esModule', { value: true });
  });
});
// JSTS. See https://github.com/bjornharrtell/jsts
// Licenses:
// https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EDLv1.txt
// https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EPLv1.txt
// https://github.com/bjornharrtell/jsts/blob/master/LICENSE_LICENSE_ES6_COLLECTIONS.txt
!function (t, e) {
  "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == "function" && true ? $__System.registerDynamic("20", [], false, function ($__require, $__exports, $__module) {
    if (typeof e === "function") {
      return e.call($__exports, $__exports);
    } else {
      return e;
    }
  }) : e(t.jsts = t.jsts || {});
}(this, function (t) {
  "use strict";
  function e(t, e) {
    for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
  }function n() {}function i() {}function r() {}function s() {}function o() {}function a() {}function u() {}function l(t) {
    this.name = "RuntimeException", this.message = t, this.stack = new Error().stack, Error.call(this, t);
  }function h(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t;
  }function c() {
    if (0 === arguments.length) l.call(this);else if (1 === arguments.length) {
      var t = arguments[0];l.call(this, t);
    }
  }function f() {}function g() {
    if (this.x = null, this.y = null, this.z = null, 0 === arguments.length) g.call(this, 0, 0);else if (1 === arguments.length) {
      var t = arguments[0];g.call(this, t.x, t.y, t.z);
    } else if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];g.call(this, e, n, g.NULL_ORDINATE);
    } else if (3 === arguments.length) {
      var i = arguments[0],
          r = arguments[1],
          s = arguments[2];this.x = i, this.y = r, this.z = s;
    }
  }function d() {
    if (this.dimensionsToTest = 2, 0 === arguments.length) d.call(this, 2);else if (1 === arguments.length) {
      var t = arguments[0];if (2 !== t && 3 !== t) throw new i("only 2 or 3 dimensions may be specified");this.dimensionsToTest = t;
    }
  }function p() {}function v() {}function m(t) {
    this.message = t || "";
  }function y() {}function x(t) {
    this.message = t || "";
  }function E(t) {
    this.message = t || "";
  }function I() {
    this.array_ = [], arguments[0] instanceof v && this.addAll(arguments[0]);
  }function N() {
    if (I.apply(this), 0 === arguments.length) ;else if (1 === arguments.length) {
      var t = arguments[0];this.ensureCapacity(t.length), this.add(t, !0);
    } else if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];this.ensureCapacity(e.length), this.add(e, n);
    }
  }function C() {
    if (this.minx = null, this.maxx = null, this.miny = null, this.maxy = null, 0 === arguments.length) this.init();else if (1 === arguments.length) {
      if (arguments[0] instanceof g) {
        var t = arguments[0];this.init(t.x, t.x, t.y, t.y);
      } else if (arguments[0] instanceof C) {
        var e = arguments[0];this.init(e);
      }
    } else if (2 === arguments.length) {
      var n = arguments[0],
          i = arguments[1];this.init(n.x, i.x, n.y, i.y);
    } else if (4 === arguments.length) {
      var r = arguments[0],
          s = arguments[1],
          o = arguments[2],
          a = arguments[3];this.init(r, s, o, a);
    }
  }function S() {}function w() {
    S.call(this, "Projective point not representable on the Cartesian plane.");
  }function L() {}function R(t, e) {
    return t.interfaces_ && t.interfaces_().indexOf(e) > -1;
  }function T() {}function P(t) {
    this.str = t;
  }function b(t) {
    this.value = t;
  }function O() {}function _() {
    if (this.hi = 0, this.lo = 0, 0 === arguments.length) this.init(0);else if (1 === arguments.length) {
      if ("number" == typeof arguments[0]) {
        var t = arguments[0];this.init(t);
      } else if (arguments[0] instanceof _) {
        var e = arguments[0];this.init(e);
      } else if ("string" == typeof arguments[0]) {
        var n = arguments[0];_.call(this, _.parse(n));
      }
    } else if (2 === arguments.length) {
      var i = arguments[0],
          r = arguments[1];this.init(i, r);
    }
  }function M() {}function D() {}function A() {}function F() {
    if (this.x = null, this.y = null, this.w = null, 0 === arguments.length) this.x = 0, this.y = 0, this.w = 1;else if (1 === arguments.length) {
      var t = arguments[0];this.x = t.x, this.y = t.y, this.w = 1;
    } else if (2 === arguments.length) {
      if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
        var e = arguments[0],
            n = arguments[1];this.x = e, this.y = n, this.w = 1;
      } else if (arguments[0] instanceof F && arguments[1] instanceof F) {
        var i = arguments[0],
            r = arguments[1];this.x = i.y * r.w - r.y * i.w, this.y = r.x * i.w - i.x * r.w, this.w = i.x * r.y - r.x * i.y;
      } else if (arguments[0] instanceof g && arguments[1] instanceof g) {
        var s = arguments[0],
            o = arguments[1];this.x = s.y - o.y, this.y = o.x - s.x, this.w = s.x * o.y - o.x * s.y;
      }
    } else if (3 === arguments.length) {
      var a = arguments[0],
          u = arguments[1],
          l = arguments[2];this.x = a, this.y = u, this.w = l;
    } else if (4 === arguments.length) {
      var h = arguments[0],
          c = arguments[1],
          f = arguments[2],
          d = arguments[3],
          p = h.y - c.y,
          v = c.x - h.x,
          m = h.x * c.y - c.x * h.y,
          y = f.y - d.y,
          x = d.x - f.x,
          E = f.x * d.y - d.x * f.y;this.x = v * E - x * m, this.y = y * m - p * E, this.w = p * x - y * v;
    }
  }function G() {}function q() {}function B() {
    this.envelope = null, this.factory = null, this.SRID = null, this.userData = null;var t = arguments[0];this.factory = t, this.SRID = t.getSRID();
  }function z() {}function V() {}function k() {}function Y() {}function U() {}function X() {}function H() {}function W() {}function j() {}function K() {}function Z() {}function Q() {}function J() {
    this.array_ = [], arguments[0] instanceof v && this.addAll(arguments[0]);
  }function $(t) {
    return null == t ? $s : t.color;
  }function tt(t) {
    return null == t ? null : t.parent;
  }function et(t, e) {
    null !== t && (t.color = e);
  }function nt(t) {
    return null == t ? null : t.left;
  }function it(t) {
    return null == t ? null : t.right;
  }function rt() {
    this.root_ = null, this.size_ = 0;
  }function st() {}function ot() {}function at() {
    this.array_ = [], arguments[0] instanceof v && this.addAll(arguments[0]);
  }function ut() {}function lt() {}function ht() {}function ct() {}function ft() {
    this.geometries = null;var t = arguments[0],
        e = arguments[1];if (B.call(this, e), null === t && (t = []), B.hasNullElements(t)) throw new i("geometries must not contain null elements");this.geometries = t;
  }function gt() {
    var t = arguments[0],
        e = arguments[1];ft.call(this, t, e);
  }function dt() {
    if (this.geom = null, this.geomFact = null, this.bnRule = null, this.endpointMap = null, 1 === arguments.length) {
      var t = arguments[0];dt.call(this, t, V.MOD2_BOUNDARY_RULE);
    } else if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];this.geom = e, this.geomFact = e.getFactory(), this.bnRule = n;
    }
  }function pt() {
    this.count = null;
  }function vt() {}function mt() {}function yt() {}function xt() {}function Et() {}function It() {}function Nt() {}function Ct() {}function St() {
    this.points = null;var t = arguments[0],
        e = arguments[1];B.call(this, e), this.init(t);
  }function wt() {}function Lt() {
    this.coordinates = null;var t = arguments[0],
        e = arguments[1];B.call(this, e), this.init(t);
  }function Rt() {}function Tt() {
    this.shell = null, this.holes = null;var t = arguments[0],
        e = arguments[1],
        n = arguments[2];if (B.call(this, n), null === t && (t = this.getFactory().createLinearRing()), null === e && (e = []), B.hasNullElements(e)) throw new i("holes must not contain null elements");if (t.isEmpty() && B.hasNonEmptyElements(e)) throw new i("shell is empty but holes are not");this.shell = t, this.holes = e;
  }function Pt() {
    var t = arguments[0],
        e = arguments[1];ft.call(this, t, e);
  }function bt() {
    if (arguments[0] instanceof g && arguments[1] instanceof ie) {
      var t = arguments[0],
          e = arguments[1];bt.call(this, e.getCoordinateSequenceFactory().create(t), e);
    } else if (R(arguments[0], D) && arguments[1] instanceof ie) {
      var n = arguments[0],
          i = arguments[1];St.call(this, n, i), this.validateConstruction();
    }
  }function Ot() {
    var t = arguments[0],
        e = arguments[1];ft.call(this, t, e);
  }function _t() {
    if (this.factory = null, this.isUserDataCopied = !1, 0 === arguments.length) ;else if (1 === arguments.length) {
      var t = arguments[0];this.factory = t;
    }
  }function Mt() {}function Dt() {}function At() {}function Ft() {}function Gt() {
    if (this.dimension = 3, this.coordinates = null, 1 === arguments.length) {
      if (arguments[0] instanceof Array) {
        var t = arguments[0];Gt.call(this, t, 3);
      } else if (Number.isInteger(arguments[0])) {
        var e = arguments[0];this.coordinates = new Array(e).fill(null);for (var n = 0; n < e; n++) this.coordinates[n] = new g();
      } else if (R(arguments[0], D)) {
        var i = arguments[0];if (null === i) return this.coordinates = new Array(0).fill(null), null;this.dimension = i.getDimension(), this.coordinates = new Array(i.size()).fill(null);for (var n = 0; n < this.coordinates.length; n++) this.coordinates[n] = i.getCoordinateCopy(n);
      }
    } else if (2 === arguments.length) if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
      var r = arguments[0],
          s = arguments[1];this.coordinates = r, this.dimension = s, null === r && (this.coordinates = new Array(0).fill(null));
    } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
      var o = arguments[0],
          a = arguments[1];this.coordinates = new Array(o).fill(null), this.dimension = a;for (var n = 0; n < o; n++) this.coordinates[n] = new g();
    }
  }function qt() {}function Bt(t, e) {
    return t === e || t !== t && e !== e;
  }function zt(t, e) {
    function n(t) {
      return this && this.constructor === n ? (this._keys = [], this._values = [], this._itp = [], this.objectOnly = e, void (t && Vt.call(this, t))) : new n(t);
    }return e || io(t, "size", { get: Jt }), t.constructor = n, n.prototype = t, n;
  }function Vt(t) {
    this.add ? t.forEach(this.add, this) : t.forEach(function (t) {
      this.set(t[0], t[1]);
    }, this);
  }function kt(t) {
    return this.has(t) && (this._keys.splice(no, 1), this._values.splice(no, 1), this._itp.forEach(function (t) {
      no < t[0] && t[0]--;
    })), no > -1;
  }function Yt(t) {
    return this.has(t) ? this._values[no] : void 0;
  }function Ut(t, e) {
    if (this.objectOnly && e !== Object(e)) throw new TypeError("Invalid value used as weak collection key");if (e !== e || 0 === e) for (no = t.length; no-- && !Bt(t[no], e););else no = t.indexOf(e);return no > -1;
  }function Xt(t) {
    return Ut.call(this, this._keys, t);
  }function Ht(t, e) {
    return this.has(t) ? this._values[no] = e : this._values[this._keys.push(t) - 1] = e, this;
  }function Wt() {
    (this._keys || 0).length = this._values.length = 0;
  }function jt() {
    return Qt(this._itp, this._keys);
  }function Kt() {
    return Qt(this._itp, this._values);
  }function Zt() {
    return Qt(this._itp, this._keys, this._values);
  }function Qt(t, e, n) {
    var i = [0],
        r = !1;return t.push(i), { next: function () {
        var s,
            o = i[0];return !r && o < e.length ? (s = n ? [e[o], n[o]] : e[o], i[0]++) : (r = !0, t.splice(t.indexOf(i), 1)), { done: r, value: s };
      } };
  }function Jt() {
    return this._values.length;
  }function $t(t, e) {
    for (var n = this.entries();;) {
      var i = n.next();if (i.done) break;t.call(e, i.value[1], i.value[0], this);
    }
  }function te() {
    this.map_ = new so();
  }function ee() {
    if (this.modelType = null, this.scale = null, 0 === arguments.length) this.modelType = ee.FLOATING;else if (1 === arguments.length) if (arguments[0] instanceof ne) {
      var t = arguments[0];this.modelType = t, t === ee.FIXED && this.setScale(1);
    } else if ("number" == typeof arguments[0]) {
      var e = arguments[0];this.modelType = ee.FIXED, this.setScale(e);
    } else if (arguments[0] instanceof ee) {
      var n = arguments[0];this.modelType = n.modelType, this.scale = n.scale;
    }
  }function ne() {
    this.name = null;var t = arguments[0];this.name = t, ne.nameToTypeMap.put(t, this);
  }function ie() {
    if (this.precisionModel = null, this.coordinateSequenceFactory = null, this.SRID = null, 0 === arguments.length) ie.call(this, new ee(), 0);else if (1 === arguments.length) {
      if (R(arguments[0], G)) {
        var t = arguments[0];ie.call(this, new ee(), 0, t);
      } else if (arguments[0] instanceof ee) {
        var e = arguments[0];ie.call(this, e, 0, ie.getDefaultCoordinateSequenceFactory());
      }
    } else if (2 === arguments.length) {
      var n = arguments[0],
          i = arguments[1];ie.call(this, n, i, ie.getDefaultCoordinateSequenceFactory());
    } else if (3 === arguments.length) {
      var r = arguments[0],
          s = arguments[1],
          o = arguments[2];this.precisionModel = r, this.coordinateSequenceFactory = o, this.SRID = s;
    }
  }function re(t) {
    this.geometryFactory = t || new ie();
  }function se(t) {
    this.parser = new re(t);
  }function oe() {
    this.result = null, this.inputLines = Array(2).fill().map(function () {
      return Array(2);
    }), this.intPt = new Array(2).fill(null), this.intLineIndex = null, this._isProper = null, this.pa = null, this.pb = null, this.precisionModel = null, this.intPt[0] = new g(), this.intPt[1] = new g(), this.pa = this.intPt[0], this.pb = this.intPt[1], this.result = 0;
  }function ae() {
    oe.apply(this);
  }function ue() {}function le() {
    this.p = null, this.crossingCount = 0, this.isPointOnSegment = !1;var t = arguments[0];this.p = t;
  }function he() {}function ce() {
    if (this.p0 = null, this.p1 = null, 0 === arguments.length) ce.call(this, new g(), new g());else if (1 === arguments.length) {
      var t = arguments[0];ce.call(this, t.p0, t.p1);
    } else if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];this.p0 = e, this.p1 = n;
    } else if (4 === arguments.length) {
      var i = arguments[0],
          r = arguments[1],
          s = arguments[2],
          o = arguments[3];ce.call(this, new g(i, r), new g(s, o));
    }
  }function fe() {
    if (this.matrix = null, 0 === arguments.length) this.matrix = Array(3).fill().map(function () {
      return Array(3);
    }), this.setAll(lt.FALSE);else if (1 === arguments.length) if ("string" == typeof arguments[0]) {
      var t = arguments[0];fe.call(this), this.set(t);
    } else if (arguments[0] instanceof fe) {
      var e = arguments[0];fe.call(this), this.matrix[L.INTERIOR][L.INTERIOR] = e.matrix[L.INTERIOR][L.INTERIOR], this.matrix[L.INTERIOR][L.BOUNDARY] = e.matrix[L.INTERIOR][L.BOUNDARY], this.matrix[L.INTERIOR][L.EXTERIOR] = e.matrix[L.INTERIOR][L.EXTERIOR], this.matrix[L.BOUNDARY][L.INTERIOR] = e.matrix[L.BOUNDARY][L.INTERIOR], this.matrix[L.BOUNDARY][L.BOUNDARY] = e.matrix[L.BOUNDARY][L.BOUNDARY], this.matrix[L.BOUNDARY][L.EXTERIOR] = e.matrix[L.BOUNDARY][L.EXTERIOR], this.matrix[L.EXTERIOR][L.INTERIOR] = e.matrix[L.EXTERIOR][L.INTERIOR], this.matrix[L.EXTERIOR][L.BOUNDARY] = e.matrix[L.EXTERIOR][L.BOUNDARY], this.matrix[L.EXTERIOR][L.EXTERIOR] = e.matrix[L.EXTERIOR][L.EXTERIOR];
    }
  }function ge() {
    this.areaBasePt = null, this.triangleCent3 = new g(), this.areasum2 = 0, this.cg3 = new g(), this.lineCentSum = new g(), this.totalLength = 0, this.ptCount = 0, this.ptCentSum = new g();var t = arguments[0];this.areaBasePt = null, this.add(t);
  }function de(t) {
    this.message = t || "";
  }function pe() {
    this.array_ = [];
  }function ve() {
    this.treeSet = new at(), this.list = new I();
  }function me() {
    if (this.geomFactory = null, this.inputPts = null, 1 === arguments.length) {
      var t = arguments[0];me.call(this, me.extractCoordinates(t), t.getFactory());
    } else if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];this.inputPts = ve.filterCoordinates(e), this.geomFactory = n;
    }
  }function ye() {
    this.origin = null;var t = arguments[0];this.origin = t;
  }function xe() {
    this.inputGeom = null, this.factory = null, this.pruneEmptyGeometry = !0, this.preserveGeometryCollectionType = !0, this.preserveCollections = !1, this.preserveType = !1;
  }function Ee() {
    if (this.snapTolerance = 0, this.srcPts = null, this.seg = new ce(), this.allowSnappingToSourceVertices = !1, this._isClosed = !1, arguments[0] instanceof St && "number" == typeof arguments[1]) {
      var t = arguments[0],
          e = arguments[1];Ee.call(this, t.getCoordinates(), e);
    } else if (arguments[0] instanceof Array && "number" == typeof arguments[1]) {
      var n = arguments[0],
          i = arguments[1];this.srcPts = n, this._isClosed = Ee.isClosed(n), this.snapTolerance = i;
    }
  }function Ie() {
    this.srcGeom = null;var t = arguments[0];this.srcGeom = t;
  }function Ne() {
    if (xe.apply(this), this.snapTolerance = null, this.snapPts = null, this.isSelfSnap = !1, 2 === arguments.length) {
      var t = arguments[0],
          e = arguments[1];this.snapTolerance = t, this.snapPts = e;
    } else if (3 === arguments.length) {
      var n = arguments[0],
          i = arguments[1],
          r = arguments[2];this.snapTolerance = n, this.snapPts = i, this.isSelfSnap = r;
    }
  }function Ce() {
    this.isFirst = !0, this.commonMantissaBitsCount = 53, this.commonBits = 0, this.commonSignExp = null;
  }function Se() {
    this.commonCoord = null, this.ccFilter = new we();
  }function we() {
    this.commonBitsX = new Ce(), this.commonBitsY = new Ce();
  }function Le() {
    this.trans = null;var t = arguments[0];this.trans = t;
  }function Re() {
    this.parent = null, this.atStart = null, this.max = null, this.index = null, this.subcollectionIterator = null;var t = arguments[0];this.parent = t, this.atStart = !0, this.index = 0, this.max = t.getNumGeometries();
  }function Te() {
    if (this.boundaryRule = V.OGC_SFS_BOUNDARY_RULE, this.isIn = null, this.numBoundaries = null, 0 === arguments.length) ;else if (1 === arguments.length) {
      var t = arguments[0];if (null === t) throw new i("Rule must be non-null");this.boundaryRule = t;
    }
  }function Pe() {}function be() {}function Oe() {
    this.pts = null, this.data = null;var t = arguments[0],
        e = arguments[1];this.pts = t, this.data = e;
  }function _e() {}function Me() {
    this.bounds = null, this.item = null;var t = arguments[0],
        e = arguments[1];this.bounds = t, this.item = e;
  }function De() {
    this._size = null, this.items = null, this._size = 0, this.items = new I(), this.items.add(null);
  }function Ae() {}function Fe() {}function Ge() {
    if (this.childBoundables = new I(), this.bounds = null, this.level = null, 0 === arguments.length) ;else if (1 === arguments.length) {
      var t = arguments[0];this.level = t;
    }
  }function qe() {
    this.boundable1 = null, this.boundable2 = null, this._distance = null, this.itemDistance = null;var t = arguments[0],
        e = arguments[1],
        n = arguments[2];this.boundable1 = t, this.boundable2 = e, this.itemDistance = n, this._distance = this.distance();
  }function Be() {
    if (this.root = null, this.built = !1, this.itemBoundables = new I(), this.nodeCapacity = null, 0 === arguments.length) Be.call(this, Be.DEFAULT_NODE_CAPACITY);else if (1 === arguments.length) {
      var t = arguments[0];f.isTrue(t > 1, "Node capacity must be greater than 1"), this.nodeCapacity = t;
    }
  }function ze() {}function Ve() {}function ke() {
    if (0 === arguments.length) ke.call(this, ke.DEFAULT_NODE_CAPACITY);else if (1 === arguments.length) {
      var t = arguments[0];Be.call(this, t);
    }
  }function Ye() {
    var t = arguments[0];Ge.call(this, t);
  }function Ue() {}function Xe() {
    this.segString = null, this.coord = null, this.segmentIndex = null, this.segmentOctant = null, this._isInterior = null;var t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3];this.segString = t, this.coord = new g(e), this.segmentIndex = n, this.segmentOctant = i, this._isInterior = !e.equals2D(t.getCoordinate(n));
  }function He() {
    this.nodeMap = new rt(), this.edge = null;var t = arguments[0];this.edge = t;
  }function We() {
    this.nodeList = null, this.edge = null, this.nodeIt = null, this.currNode = null, this.nextNode = null, this.currSegIndex = 0;var t = arguments[0];this.nodeList = t, this.edge = t.getEdge(), this.nodeIt = t.iterator(), this.readNextNode();
  }function je() {}function Ke() {
    this.nodeList = new He(this), this.pts = null, this.data = null;var t = arguments[0],
        e = arguments[1];this.pts = t, this.data = e;
  }function Ze() {
    this.tempEnv1 = new C(), this.tempEnv2 = new C(), this.overlapSeg1 = new ce(), this.overlapSeg2 = new ce();
  }function Qe() {
    this.pts = null, this.start = null, this.end = null, this.env = null, this.context = null, this.id = null;var t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3];this.pts = t, this.start = e, this.end = n, this.context = i;
  }function Je() {}function $e() {}function tn() {}function en() {
    if (this.segInt = null, 0 === arguments.length) ;else if (1 === arguments.length) {
      var t = arguments[0];this.setSegmentIntersector(t);
    }
  }function nn() {
    if (this.monoChains = new I(), this.index = new ke(), this.idCounter = 0, this.nodedSegStrings = null, this.nOverlaps = 0, 0 === arguments.length) ;else if (1 === arguments.length) {
      var t = arguments[0];en.call(this, t);
    }
  }function rn() {
    Ze.apply(this), this.si = null;var t = arguments[0];this.si = t;
  }function sn() {
    if (this.pt = null, 1 === arguments.length) {
      var t = arguments[0];l.call(this, t);
    } else if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];l.call(this, sn.msgWithCoord(e, n)), this.name = "TopologyException", this.pt = new g(n);
    }
  }function on() {}function an() {
    this.findAllIntersections = !1, this.isCheckEndSegmentsOnly = !1, this.li = null, this.interiorIntersection = null, this.intSegments = null, this.intersections = new I(), this.intersectionCount = 0, this.keepIntersections = !0;var t = arguments[0];this.li = t, this.interiorIntersection = null;
  }function un() {
    this.li = new ae(), this.segStrings = null, this.findAllIntersections = !1, this.segInt = null, this._isValid = !0;var t = arguments[0];this.segStrings = t;
  }function ln() {
    this.nv = null;var t = arguments[0];this.nv = new un(ln.toSegmentStrings(t));
  }function hn() {
    this.mapOp = null;var t = arguments[0];this.mapOp = t;
  }function cn() {}function fn() {
    if (this.location = null, 1 === arguments.length) {
      if (arguments[0] instanceof Array) {
        var t = arguments[0];this.init(t.length);
      } else if (Number.isInteger(arguments[0])) {
        var e = arguments[0];this.init(1), this.location[cn.ON] = e;
      } else if (arguments[0] instanceof fn) {
        var n = arguments[0];if (this.init(n.location.length), null !== n) for (var i = 0; i < this.location.length; i++) this.location[i] = n.location[i];
      }
    } else if (3 === arguments.length) {
      var r = arguments[0],
          s = arguments[1],
          o = arguments[2];this.init(3), this.location[cn.ON] = r, this.location[cn.LEFT] = s, this.location[cn.RIGHT] = o;
    }
  }function gn() {
    if (this.elt = new Array(2).fill(null), 1 === arguments.length) {
      if (Number.isInteger(arguments[0])) {
        var t = arguments[0];this.elt[0] = new fn(t), this.elt[1] = new fn(t);
      } else if (arguments[0] instanceof gn) {
        var e = arguments[0];this.elt[0] = new fn(e.elt[0]), this.elt[1] = new fn(e.elt[1]);
      }
    } else if (2 === arguments.length) {
      var n = arguments[0],
          i = arguments[1];this.elt[0] = new fn(L.NONE), this.elt[1] = new fn(L.NONE), this.elt[n].setLocation(i);
    } else if (3 === arguments.length) {
      var r = arguments[0],
          s = arguments[1],
          o = arguments[2];this.elt[0] = new fn(r, s, o), this.elt[1] = new fn(r, s, o);
    } else if (4 === arguments.length) {
      var a = arguments[0],
          u = arguments[1],
          l = arguments[2],
          h = arguments[3];this.elt[0] = new fn(L.NONE, L.NONE, L.NONE), this.elt[1] = new fn(L.NONE, L.NONE, L.NONE), this.elt[a].setLocations(u, l, h);
    }
  }function dn() {
    this.startDe = null, this.maxNodeDegree = -1, this.edges = new I(), this.pts = new I(), this.label = new gn(L.NONE), this.ring = null, this._isHole = null, this.shell = null, this.holes = new I(), this.geometryFactory = null;var t = arguments[0],
        e = arguments[1];this.geometryFactory = e, this.computePoints(t), this.computeRing();
  }function pn() {
    var t = arguments[0],
        e = arguments[1];dn.call(this, t, e);
  }function vn() {
    var t = arguments[0],
        e = arguments[1];dn.call(this, t, e);
  }function mn() {
    if (this.label = null, this._isInResult = !1, this._isCovered = !1, this._isCoveredSet = !1, this._isVisited = !1, 0 === arguments.length) ;else if (1 === arguments.length) {
      var t = arguments[0];this.label = t;
    }
  }function yn() {
    mn.apply(this), this.coord = null, this.edges = null;var t = arguments[0],
        e = arguments[1];this.coord = t, this.edges = e, this.label = new gn(0, L.NONE);
  }function xn() {
    this.nodeMap = new rt(), this.nodeFact = null;var t = arguments[0];this.nodeFact = t;
  }function En() {
    if (this.edge = null, this.label = null, this.node = null, this.p0 = null, this.p1 = null, this.dx = null, this.dy = null, this.quadrant = null, 1 === arguments.length) {
      var t = arguments[0];this.edge = t;
    } else if (3 === arguments.length) {
      var e = arguments[0],
          n = arguments[1],
          i = arguments[2];En.call(this, e, n, i, null);
    } else if (4 === arguments.length) {
      var r = arguments[0],
          s = arguments[1],
          o = arguments[2],
          a = arguments[3];En.call(this, r), this.init(s, o), this.label = a;
    }
  }function In() {
    this._isForward = null, this._isInResult = !1, this._isVisited = !1, this.sym = null, this.next = null, this.nextMin = null, this.edgeRing = null, this.minEdgeRing = null, this.depth = [0, -999, -999];var t = arguments[0],
        e = arguments[1];if (En.call(this, t), this._isForward = e, e) this.init(t.getCoordinate(0), t.getCoordinate(1));else {
      var n = t.getNumPoints() - 1;this.init(t.getCoordinate(n), t.getCoordinate(n - 1));
    }this.computeDirectedLabel();
  }function Nn() {}function Cn() {
    if (this.edges = new I(), this.nodes = null, this.edgeEndList = new I(), 0 === arguments.length) this.nodes = new xn(new Nn());else if (1 === arguments.length) {
      var t = arguments[0];this.nodes = new xn(t);
    }
  }function Sn() {
    this.geometryFactory = null, this.shellList = new I();var t = arguments[0];this.geometryFactory = t;
  }function wn() {
    this.op = null, this.geometryFactory = null, this.ptLocator = null, this.lineEdgesList = new I(), this.resultLineList = new I();var t = arguments[0],
        e = arguments[1],
        n = arguments[2];this.op = t, this.geometryFactory = e, this.ptLocator = n;
  }function Ln() {
    this.op = null, this.geometryFactory = null, this.resultPointList = new I();var t = arguments[0],
        e = arguments[1];arguments[2];this.op = t, this.geometryFactory = e;
  }function Rn() {}function Tn() {
    this.geom = null;var t = arguments[0];this.geom = t;
  }function Pn() {
    this.edgeMap = new rt(), this.edgeList = null, this.ptInAreaLocation = [L.NONE, L.NONE];
  }function bn() {
    Pn.apply(this), this.resultAreaEdgeList = null, this.label = null, this.SCANNING_FOR_INCOMING = 1, this.LINKING_TO_OUTGOING = 2;
  }function On() {
    Nn.apply(this);
  }function _n() {
    this.mce = null, this.chainIndex = null;var t = arguments[0],
        e = arguments[1];this.mce = t, this.chainIndex = e;
  }function Mn() {
    if (this.label = null, this.xValue = null, this.eventType = null, this.insertEvent = null, this.deleteEventIndex = null, this.obj = null, 2 === arguments.length) {
      var t = arguments[0],
          e = arguments[1];this.eventType = Mn.DELETE, this.xValue = t, this.insertEvent = e;
    } else if (3 === arguments.length) {
      var n = arguments[0],
          i = arguments[1],
          r = arguments[2];this.eventType = Mn.INSERT, this.label = n, this.xValue = i, this.obj = r;
    }
  }function Dn() {}function An() {
    this._hasIntersection = !1, this.hasProper = !1, this.hasProperInterior = !1, this.properIntersectionPoint = null, this.li = null, this.includeProper = null, this.recordIsolated = null, this.isSelfIntersection = null, this.numIntersections = 0, this.numTests = 0, this.bdyNodes = null, this._isDone = !1, this.isDoneWhenProperInt = !1;var t = arguments[0],
        e = arguments[1],
        n = arguments[2];this.li = t, this.includeProper = e, this.recordIsolated = n;
  }function Fn() {
    Dn.apply(this), this.events = new I(), this.nOverlaps = null;
  }function Gn() {
    this.min = r.POSITIVE_INFINITY, this.max = r.NEGATIVE_INFINITY;
  }function qn() {}function Bn() {
    Gn.apply(this), this.item = null;var t = arguments[0],
        e = arguments[1],
        n = arguments[2];this.min = t, this.max = e, this.item = n;
  }function zn() {
    Gn.apply(this), this.node1 = null, this.node2 = null;var t = arguments[0],
        e = arguments[1];this.node1 = t, this.node2 = e, this.buildExtent(this.node1, this.node2);
  }function Vn() {
    this.leaves = new I(), this.root = null, this.level = 0;
  }function kn() {
    if (this.lines = null, this.isForcedToLineString = !1, 1 === arguments.length) {
      var t = arguments[0];this.lines = t;
    } else if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];this.lines = e, this.isForcedToLineString = n;
    }
  }function Yn() {
    this.items = new I();
  }function Un() {
    this.index = null;var t = arguments[0];if (!R(t, Rt)) throw new i("Argument must be Polygonal");this.index = new Hn(t);
  }function Xn() {
    this.counter = null;var t = arguments[0];this.counter = t;
  }function Hn() {
    this.index = new Vn();var t = arguments[0];this.init(t);
  }function Wn() {
    this.coord = null, this.segmentIndex = null, this.dist = null;var t = arguments[0],
        e = arguments[1],
        n = arguments[2];this.coord = new g(t), this.segmentIndex = e, this.dist = n;
  }function jn() {
    this.nodeMap = new rt(), this.edge = null;var t = arguments[0];this.edge = t;
  }function Kn() {}function Zn() {
    this.e = null, this.pts = null, this.startIndex = null, this.env1 = new C(), this.env2 = new C();var t = arguments[0];this.e = t, this.pts = t.getCoordinates();var e = new Kn();this.startIndex = e.getChainStartIndices(this.pts);
  }function Qn() {
    this.depth = Array(2).fill().map(function () {
      return Array(3);
    });for (var t = 0; t < 2; t++) for (var e = 0; e < 3; e++) this.depth[t][e] = Qn.NULL_VALUE;
  }function Jn() {
    if (mn.apply(this), this.pts = null, this.env = null, this.eiList = new jn(this), this.name = null, this.mce = null, this._isIsolated = !0, this.depth = new Qn(), this.depthDelta = 0, 1 === arguments.length) {
      var t = arguments[0];Jn.call(this, t, null);
    } else if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];this.pts = e, this.label = n;
    }
  }function $n() {
    if (Cn.apply(this), this.parentGeom = null, this.lineEdgeMap = new te(), this.boundaryNodeRule = null, this.useBoundaryDeterminationRule = !0, this.argIndex = null, this.boundaryNodes = null, this._hasTooFewPoints = !1, this.invalidPoint = null, this.areaPtLocator = null, this.ptLocator = new Te(), 2 === arguments.length) {
      var t = arguments[0],
          e = arguments[1];$n.call(this, t, e, V.OGC_SFS_BOUNDARY_RULE);
    } else if (3 === arguments.length) {
      var n = arguments[0],
          i = arguments[1],
          r = arguments[2];this.argIndex = n, this.parentGeom = i, this.boundaryNodeRule = r, null !== i && this.add(i);
    }
  }function ti() {
    if (this.li = new ae(), this.resultPrecisionModel = null, this.arg = null, 1 === arguments.length) {
      var t = arguments[0];this.setComputationPrecision(t.getPrecisionModel()), this.arg = new Array(1).fill(null), this.arg[0] = new $n(0, t);
    } else if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];ti.call(this, e, n, V.OGC_SFS_BOUNDARY_RULE);
    } else if (3 === arguments.length) {
      var i = arguments[0],
          r = arguments[1],
          s = arguments[2];i.getPrecisionModel().compareTo(r.getPrecisionModel()) >= 0 ? this.setComputationPrecision(i.getPrecisionModel()) : this.setComputationPrecision(r.getPrecisionModel()), this.arg = new Array(2).fill(null), this.arg[0] = new $n(0, i, s), this.arg[1] = new $n(1, r, s);
    }
  }function ei() {
    this.pts = null, this._orientation = null;var t = arguments[0];this.pts = t, this._orientation = ei.orientation(t);
  }function ni() {
    this.edges = new I(), this.ocaMap = new rt();
  }function ii() {
    this.ptLocator = new Te(), this.geomFact = null, this.resultGeom = null, this.graph = null, this.edgeList = new ni(), this.resultPolyList = new I(), this.resultLineList = new I(), this.resultPointList = new I();var t = arguments[0],
        e = arguments[1];ti.call(this, t, e), this.graph = new Cn(new On()), this.geomFact = t.getFactory();
  }function ri() {
    this.geom = new Array(2).fill(null), this.snapTolerance = null, this.cbr = null;var t = arguments[0],
        e = arguments[1];this.geom[0] = t, this.geom[1] = e, this.computeSnapTolerance();
  }function si() {
    this.geom = new Array(2).fill(null);var t = arguments[0],
        e = arguments[1];this.geom[0] = t, this.geom[1] = e;
  }function oi() {
    this.factory = null, this.interiorPoint = null, this.maxWidth = 0;var t = arguments[0];this.factory = t.getFactory(), this.add(t);
  }function ai() {
    this.poly = null, this.centreY = null, this.hiY = r.MAX_VALUE, this.loY = -r.MAX_VALUE;var t = arguments[0];this.poly = t, this.hiY = t.getEnvelopeInternal().getMaxY(), this.loY = t.getEnvelopeInternal().getMinY(), this.centreY = oi.avg(this.loY, this.hiY);
  }function ui() {
    this.centroid = null, this.minDistance = r.MAX_VALUE, this.interiorPoint = null;var t = arguments[0];this.centroid = t.getCentroid().getCoordinate(), this.addInterior(t), null === this.interiorPoint && this.addEndpoints(t);
  }function li() {
    this.centroid = null, this.minDistance = r.MAX_VALUE, this.interiorPoint = null;var t = arguments[0];this.centroid = t.getCentroid().getCoordinate(), this.add(t);
  }function hi() {
    this.tempEnv1 = new C(), this.selectedSegment = new ce();
  }function ci() {
    this.items = new I(), this.subnode = [null, null];
  }function fi() {
    if (this.min = null, this.max = null, 0 === arguments.length) this.min = 0, this.max = 0;else if (1 === arguments.length) {
      var t = arguments[0];this.init(t.min, t.max);
    } else if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];this.init(e, n);
    }
  }function gi() {}function di(t, e) {
    var n,
        i,
        r,
        s,
        o = { 32: { d: 127, c: 128, b: 0, a: 0 }, 64: { d: 32752, c: 0, b: 0, a: 0 } },
        a = { 32: 8, 64: 11 }[t];if (s || (n = e < 0 || 1 / e < 0, isFinite(e) || (s = o[t], n && (s.d += 1 << t / 4 - 1), i = Math.pow(2, a) - 1, r = 0)), !s) {
      for (i = { 32: 127, 64: 1023 }[t], r = Math.abs(e); r >= 2;) i++, r /= 2;for (; r < 1 && i > 0;) i--, r *= 2;i <= 0 && (r /= 2), 32 === t && i > 254 && (s = { d: n ? 255 : 127, c: 128, b: 0, a: 0 }, i = Math.pow(2, a) - 1, r = 0);
    }return i;
  }function pi() {
    this.pt = 0, this.level = 0, this.interval = null;var t = arguments[0];this.computeKey(t);
  }function vi() {
    ci.apply(this), this.interval = null, this.centre = null, this.level = null;var t = arguments[0],
        e = arguments[1];this.interval = t, this.level = e, this.centre = (t.getMin() + t.getMax()) / 2;
  }function mi() {}function yi() {
    ci.apply(this);
  }function xi() {
    this.root = null, this.minExtent = 1, this.root = new yi();
  }function Ei() {}function Ii() {
    this.ring = null, this.tree = null, this.crossings = 0, this.interval = new fi();var t = arguments[0];this.ring = t, this.buildIndex();
  }function Ni() {
    hi.apply(this), this.mcp = null, this.p = null;var t = arguments[0],
        e = arguments[1];this.mcp = t, this.p = e;
  }function Ci() {}function Si() {
    this.p0 = null, this.p1 = null, this.p2 = null;var t = arguments[0],
        e = arguments[1],
        n = arguments[2];this.p0 = t, this.p1 = e, this.p2 = n;
  }function wi() {
    this.input = null, this.extremalPts = null, this.centre = null, this.radius = 0;var t = arguments[0];this.input = t;
  }function Li() {
    if (this.inputGeom = null, this.isConvex = null, this.convexHullPts = null, this.minBaseSeg = new ce(), this.minWidthPt = null, this.minPtIndex = null, this.minWidth = 0, 1 === arguments.length) {
      var t = arguments[0];Li.call(this, t, !1);
    } else if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];this.inputGeom = e, this.isConvex = n;
    }
  }function Ri() {
    this.inputGeom = null, this.distanceTolerance = null;var t = arguments[0];this.inputGeom = t;
  }function Ti() {
    xe.apply(this), this.distanceTolerance = null;var t = arguments[0];this.distanceTolerance = t;
  }function Pi() {
    this._orig = null, this._sym = null, this._next = null;var t = arguments[0];this._orig = t;
  }function bi() {
    this._isMarked = !1;var t = arguments[0];Pi.call(this, t);
  }function Oi() {
    this.vertexMap = new te();
  }function _i() {
    this._isStart = !1;var t = arguments[0];bi.call(this, t);
  }function Mi() {
    Oi.apply(this);
  }function Di() {
    this.result = null, this.factory = null, this.graph = null, this.lines = new I(), this.nodeEdgeStack = new pe(), this.ringStartEdge = null, this.graph = new Mi();
  }function Ai() {
    this.items = new I(), this.subnode = new Array(4).fill(null);
  }function Fi() {
    this.pt = new g(), this.level = 0, this.env = null;var t = arguments[0];this.computeKey(t);
  }function Gi() {
    Ai.apply(this), this.env = null, this.centrex = null, this.centrey = null, this.level = null;var t = arguments[0],
        e = arguments[1];this.env = t, this.level = e, this.centrex = (t.getMinX() + t.getMaxX()) / 2, this.centrey = (t.getMinY() + t.getMaxY()) / 2;
  }function qi() {
    Ai.apply(this);
  }function Bi() {
    this.root = null, this.minExtent = 1, this.root = new qi();
  }function zi(t) {
    this.geometryFactory = t || new ie();
  }function Vi(t) {
    this.geometryFactory = t || new ie(), this.precisionModel = this.geometryFactory.getPrecisionModel(), this.parser = new zi(this.geometryFactory);
  }function ki() {
    this.parser = new zi(this.geometryFactory);
  }function Yi(t) {
    this.geometryFactory = t || new ie(), this.precisionModel = this.geometryFactory.getPrecisionModel(), this.parser = new re(this.geometryFactory);
  }function Ui(t) {
    return [t.x, t.y];
  }function Xi(t, e) {
    this.geometryFactory = t || new ie(), this.ol = e || "undefined" != typeof ol && ol;
  }function Hi() {
    if (this.noder = null, this.scaleFactor = null, this.offsetX = null, this.offsetY = null, this.isScaled = !1, 2 === arguments.length) {
      var t = arguments[0],
          e = arguments[1];Hi.call(this, t, e, 0, 0);
    } else if (4 === arguments.length) {
      var n = arguments[0],
          i = arguments[1];arguments[2], arguments[3];this.noder = n, this.scaleFactor = i, this.isScaled = !this.isIntegerPrecision();
    }
  }function Wi() {
    if (this.inputGeom = null, this.isClosedEndpointsInInterior = !0, this.nonSimpleLocation = null, 1 === arguments.length) {
      var t = arguments[0];this.inputGeom = t;
    } else if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];
      this.inputGeom = e, this.isClosedEndpointsInInterior = !n.isInBoundary(2);
    }
  }function ji() {
    this.pt = null, this.isClosed = null, this.degree = null;var t = arguments[0];this.pt = t, this.isClosed = !1, this.degree = 0;
  }function Ki() {
    if (this.quadrantSegments = Ki.DEFAULT_QUADRANT_SEGMENTS, this.endCapStyle = Ki.CAP_ROUND, this.joinStyle = Ki.JOIN_ROUND, this.mitreLimit = Ki.DEFAULT_MITRE_LIMIT, this._isSingleSided = !1, this.simplifyFactor = Ki.DEFAULT_SIMPLIFY_FACTOR, 0 === arguments.length) ;else if (1 === arguments.length) {
      var t = arguments[0];this.setQuadrantSegments(t);
    } else if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];this.setQuadrantSegments(e), this.setEndCapStyle(n);
    } else if (4 === arguments.length) {
      var i = arguments[0],
          r = arguments[1],
          s = arguments[2],
          o = arguments[3];this.setQuadrantSegments(i), this.setEndCapStyle(r), this.setJoinStyle(s), this.setMitreLimit(o);
    }
  }function Zi() {
    this.minIndex = -1, this.minCoord = null, this.minDe = null, this.orientedDe = null;
  }function Qi() {
    this.array_ = [];
  }function Ji() {
    this.finder = null, this.dirEdgeList = new I(), this.nodes = new I(), this.rightMostCoord = null, this.env = null, this.finder = new Zi();
  }function $i() {
    this.inputLine = null, this.distanceTol = null, this.isDeleted = null, this.angleOrientation = he.COUNTERCLOCKWISE;var t = arguments[0];this.inputLine = t;
  }function tr() {
    this.ptList = null, this.precisionModel = null, this.minimimVertexDistance = 0, this.ptList = new I();
  }function er() {
    this.maxCurveSegmentError = 0, this.filletAngleQuantum = null, this.closingSegLengthFactor = 1, this.segList = null, this.distance = 0, this.precisionModel = null, this.bufParams = null, this.li = null, this.s0 = null, this.s1 = null, this.s2 = null, this.seg0 = new ce(), this.seg1 = new ce(), this.offset0 = new ce(), this.offset1 = new ce(), this.side = 0, this._hasNarrowConcaveAngle = !1;var t = arguments[0],
        e = arguments[1],
        n = arguments[2];this.precisionModel = t, this.bufParams = e, this.li = new ae(), this.filletAngleQuantum = Math.PI / 2 / e.getQuadrantSegments(), e.getQuadrantSegments() >= 8 && e.getJoinStyle() === Ki.JOIN_ROUND && (this.closingSegLengthFactor = er.MAX_CLOSING_SEG_LEN_FACTOR), this.init(n);
  }function nr() {
    this.distance = 0, this.precisionModel = null, this.bufParams = null;var t = arguments[0],
        e = arguments[1];this.precisionModel = t, this.bufParams = e;
  }function ir() {
    this.subgraphs = null, this.seg = new ce(), this.cga = new he();var t = arguments[0];this.subgraphs = t;
  }function rr() {
    this.upwardSeg = null, this.leftDepth = null;var t = arguments[0],
        e = arguments[1];this.upwardSeg = new ce(t), this.leftDepth = e;
  }function sr() {
    this.inputGeom = null, this.distance = null, this.curveBuilder = null, this.curveList = new I();var t = arguments[0],
        e = arguments[1],
        n = arguments[2];this.inputGeom = t, this.distance = e, this.curveBuilder = n;
  }function or() {
    this._hasIntersection = !1, this.hasProper = !1, this.hasProperInterior = !1, this.hasInterior = !1, this.properIntersectionPoint = null, this.li = null, this.isSelfIntersection = null, this.numIntersections = 0, this.numInteriorIntersections = 0, this.numProperIntersections = 0, this.numTests = 0;var t = arguments[0];this.li = t;
  }function ar() {
    this.bufParams = null, this.workingPrecisionModel = null, this.workingNoder = null, this.geomFact = null, this.graph = null, this.edgeList = new ni();var t = arguments[0];this.bufParams = t;
  }function ur() {
    this.li = new ae(), this.segStrings = null;var t = arguments[0];this.segStrings = t;
  }function lr() {
    this.li = null, this.pt = null, this.originalPt = null, this.ptScaled = null, this.p0Scaled = null, this.p1Scaled = null, this.scaleFactor = null, this.minx = null, this.maxx = null, this.miny = null, this.maxy = null, this.corner = new Array(4).fill(null), this.safeEnv = null;var t = arguments[0],
        e = arguments[1],
        n = arguments[2];if (this.originalPt = t, this.pt = t, this.scaleFactor = e, this.li = n, e <= 0) throw new i("Scale factor must be non-zero");1 !== e && (this.pt = new g(this.scale(t.x), this.scale(t.y)), this.p0Scaled = new g(), this.p1Scaled = new g()), this.initCorners(this.pt);
  }function hr() {
    this.index = null;var t = arguments[0];this.index = t;
  }function cr() {
    hi.apply(this), this.hotPixel = null, this.parentEdge = null, this.hotPixelVertexIndex = null, this._isNodeAdded = !1;var t = arguments[0],
        e = arguments[1],
        n = arguments[2];this.hotPixel = t, this.parentEdge = e, this.hotPixelVertexIndex = n;
  }function fr() {
    this.li = null, this.interiorIntersections = null;var t = arguments[0];this.li = t, this.interiorIntersections = new I();
  }function gr() {
    this.pm = null, this.li = null, this.scaleFactor = null, this.noder = null, this.pointSnapper = null, this.nodedSegStrings = null;var t = arguments[0];this.pm = t, this.li = new ae(), this.li.setPrecisionModel(t), this.scaleFactor = t.getScale();
  }function dr() {
    if (this.argGeom = null, this.distance = null, this.bufParams = new Ki(), this.resultGeometry = null, this.saveException = null, 1 === arguments.length) {
      var t = arguments[0];this.argGeom = t;
    } else if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];this.argGeom = e, this.bufParams = n;
    }
  }function pr() {
    this.comps = null;var t = arguments[0];this.comps = t;
  }function vr() {
    if (this.component = null, this.segIndex = null, this.pt = null, 2 === arguments.length) {
      var t = arguments[0],
          e = arguments[1];vr.call(this, t, vr.INSIDE_AREA, e);
    } else if (3 === arguments.length) {
      var n = arguments[0],
          i = arguments[1],
          r = arguments[2];this.component = n, this.segIndex = i, this.pt = r;
    }
  }function mr() {
    this.pts = null;var t = arguments[0];this.pts = t;
  }function yr() {
    this.locations = null;var t = arguments[0];this.locations = t;
  }function xr() {
    if (this.geom = null, this.terminateDistance = 0, this.ptLocator = new Te(), this.minDistanceLocation = null, this.minDistance = r.MAX_VALUE, 2 === arguments.length) {
      var t = arguments[0],
          e = arguments[1];xr.call(this, t, e, 0);
    } else if (3 === arguments.length) {
      var n = arguments[0],
          i = arguments[1],
          s = arguments[2];this.geom = new Array(2).fill(null), this.geom[0] = n, this.geom[1] = i, this.terminateDistance = s;
    }
  }function Er() {
    this.factory = null, this.directedEdges = new I(), this.coordinates = null;var t = arguments[0];this.factory = t;
  }function Ir() {
    this._isMarked = !1, this._isVisited = !1, this.data = null;
  }function Nr() {
    Ir.apply(this), this.parentEdge = null, this.from = null, this.to = null, this.p0 = null, this.p1 = null, this.sym = null, this.edgeDirection = null, this.quadrant = null, this.angle = null;var t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3];this.from = t, this.to = e, this.edgeDirection = i, this.p0 = t.getCoordinate(), this.p1 = n;var r = this.p1.x - this.p0.x,
        s = this.p1.y - this.p0.y;this.quadrant = Je.quadrant(r, s), this.angle = Math.atan2(s, r);
  }function Cr() {
    var t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3];Nr.call(this, t, e, n, i);
  }function Sr() {
    if (Ir.apply(this), this.dirEdge = null, 0 === arguments.length) ;else if (2 === arguments.length) {
      var t = arguments[0],
          e = arguments[1];this.setDirectedEdges(t, e);
    }
  }function wr() {
    this.outEdges = new I(), this.sorted = !1;
  }function Lr() {
    if (Ir.apply(this), this.pt = null, this.deStar = null, 1 === arguments.length) {
      var t = arguments[0];Lr.call(this, t, new wr());
    } else if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];this.pt = e, this.deStar = n;
    }
  }function Rr() {
    Sr.apply(this), this.line = null;var t = arguments[0];this.line = t;
  }function Tr() {
    this.nodeMap = new rt();
  }function Pr() {
    this.edges = new J(), this.dirEdges = new J(), this.nodeMap = new Tr();
  }function br() {
    Pr.apply(this);
  }function Or() {
    this.graph = new br(), this.mergedLineStrings = null, this.factory = null, this.edgeStrings = null;
  }function _r() {
    this.edgeRing = null, this.next = null, this.label = -1;var t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3];Nr.call(this, t, e, n, i);
  }function Mr() {
    Sr.apply(this), this.line = null;var t = arguments[0];this.line = t;
  }function Dr() {
    this.geometryFactory = new ie(), this.geomGraph = null, this.disconnectedRingcoord = null;var t = arguments[0];this.geomGraph = t;
  }function Ar() {}function Fr() {
    if (this.edgeEnds = new I(), 1 === arguments.length) {
      var t = arguments[0];Fr.call(this, null, t);
    } else if (2 === arguments.length) {
      var e = (arguments[0], arguments[1]);En.call(this, e.getEdge(), e.getCoordinate(), e.getDirectedCoordinate(), new gn(e.getLabel())), this.insert(e);
    }
  }function Gr() {
    Pn.apply(this);
  }function qr() {
    var t = arguments[0],
        e = arguments[1];yn.call(this, t, e);
  }function Br() {
    Nn.apply(this);
  }function zr() {
    this.nodes = new xn(new Br());
  }function Vr() {
    this.li = new ae(), this.geomGraph = null, this.nodeGraph = new zr(), this.invalidPoint = null;var t = arguments[0];this.geomGraph = t;
  }function kr() {
    this.graph = null, this.rings = new I(), this.totalEnv = new C(), this.index = null, this.nestedPt = null;var t = arguments[0];this.graph = t;
  }function Yr() {
    if (this.errorType = null, this.pt = null, 1 === arguments.length) {
      var t = arguments[0];Yr.call(this, t, null);
    } else if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];this.errorType = e, null !== n && (this.pt = n.copy());
    }
  }function Ur() {
    this.parentGeometry = null, this.isSelfTouchingRingFormingHoleValid = !1, this.validErr = null;var t = arguments[0];this.parentGeometry = t;
  }function Xr() {
    this.factory = null, this.deList = new I(), this.lowestEdge = null, this.ring = null, this.ringPts = null, this.holes = null, this.shell = null, this._isHole = null, this._isProcessed = !1, this._isIncludedSet = !1, this._isIncluded = !1;var t = arguments[0];this.factory = t;
  }function Hr() {}function Wr() {
    Pr.apply(this), this.factory = null;var t = arguments[0];this.factory = t;
  }function jr() {
    if (this.lineStringAdder = new Kr(this), this.graph = null, this.dangles = new I(), this.cutEdges = new I(), this.invalidRingLines = new I(), this.holeList = null, this.shellList = null, this.polyList = null, this.isCheckingRingsValid = !0, this.extractOnlyPolygonal = null, this.geomFactory = null, 0 === arguments.length) jr.call(this, !1);else if (1 === arguments.length) {
      var t = arguments[0];this.extractOnlyPolygonal = t;
    }
  }function Kr() {
    this.p = null;var t = arguments[0];this.p = t;
  }function Zr() {
    this.li = new ae(), this.ptLocator = new Te(), this.arg = null, this.nodes = new xn(new Br()), this.im = null, this.isolatedEdges = new I(), this.invalidPoint = null;var t = arguments[0];this.arg = t;
  }function Qr() {
    this.rectEnv = null;var t = arguments[0];this.rectEnv = t.getEnvelopeInternal();
  }function Jr() {
    this.li = new ae(), this.rectEnv = null, this.diagUp0 = null, this.diagUp1 = null, this.diagDown0 = null, this.diagDown1 = null;var t = arguments[0];this.rectEnv = t, this.diagUp0 = new g(t.getMinX(), t.getMinY()), this.diagUp1 = new g(t.getMaxX(), t.getMaxY()), this.diagDown0 = new g(t.getMinX(), t.getMaxY()), this.diagDown1 = new g(t.getMaxX(), t.getMinY());
  }function $r() {
    this._isDone = !1;
  }function ts() {
    this.rectangle = null, this.rectEnv = null;var t = arguments[0];this.rectangle = t, this.rectEnv = t.getEnvelopeInternal();
  }function es() {
    $r.apply(this), this.rectEnv = null, this._intersects = !1;var t = arguments[0];this.rectEnv = t;
  }function ns() {
    $r.apply(this), this.rectSeq = null, this.rectEnv = null, this._containsPoint = !1;var t = arguments[0];this.rectSeq = t.getExteriorRing().getCoordinateSequence(), this.rectEnv = t.getEnvelopeInternal();
  }function is() {
    $r.apply(this), this.rectEnv = null, this.rectIntersector = null, this.hasIntersection = !1, this.p0 = new g(), this.p1 = new g();var t = arguments[0];this.rectEnv = t.getEnvelopeInternal(), this.rectIntersector = new Jr(this.rectEnv);
  }function rs() {
    if (this._relate = null, 2 === arguments.length) {
      var t = arguments[0],
          e = arguments[1];ti.call(this, t, e), this._relate = new Zr(this.arg);
    } else if (3 === arguments.length) {
      var n = arguments[0],
          i = arguments[1],
          r = arguments[2];ti.call(this, n, i, r), this._relate = new Zr(this.arg);
    }
  }function ss() {
    this.geomFactory = null, this.skipEmpty = !1, this.inputGeoms = null;var t = arguments[0];this.geomFactory = ss.extractFactory(t), this.inputGeoms = t;
  }function os() {
    this.pointGeom = null, this.otherGeom = null, this.geomFact = null;var t = arguments[0],
        e = arguments[1];this.pointGeom = t, this.otherGeom = e, this.geomFact = e.getFactory();
  }function as() {
    this.sortIndex = -1, this.comps = null;var t = arguments[0],
        e = arguments[1];this.sortIndex = t, this.comps = e;
  }function us() {
    this.inputPolys = null, this.geomFactory = null;var t = arguments[0];this.inputPolys = t, null === this.inputPolys && (this.inputPolys = new I());
  }function ls() {
    if (this.polygons = new I(), this.lines = new I(), this.points = new I(), this.geomFact = null, 1 === arguments.length) {
      if (R(arguments[0], v)) {
        var t = arguments[0];this.extract(t);
      } else if (arguments[0] instanceof B) {
        var e = arguments[0];this.extract(e);
      }
    } else if (2 === arguments.length) {
      var n = arguments[0],
          i = arguments[1];this.geomFact = i, this.extract(n);
    }
  }function hs() {
    _t.CoordinateOperation.apply(this), this.targetPM = null, this.removeCollapsed = !0;var t = arguments[0],
        e = arguments[1];this.targetPM = t, this.removeCollapsed = e;
  }function cs() {
    this.targetPM = null, this.removeCollapsed = !0, this.changePrecisionModel = !1, this.isPointwise = !1;var t = arguments[0];this.targetPM = t;
  }function fs() {
    this.pts = null, this.usePt = null, this.distanceTolerance = null, this.seg = new ce();var t = arguments[0];this.pts = t;
  }function gs() {
    this.inputGeom = null, this.distanceTolerance = null, this.isEnsureValidTopology = !0;var t = arguments[0];this.inputGeom = t;
  }function ds() {
    xe.apply(this), this.isEnsureValidTopology = !0, this.distanceTolerance = null;var t = arguments[0],
        e = arguments[1];this.isEnsureValidTopology = t, this.distanceTolerance = e;
  }function ps() {
    if (this.parent = null, this.index = null, 2 === arguments.length) {
      var t = arguments[0],
          e = arguments[1];ps.call(this, t, e, null, -1);
    } else if (4 === arguments.length) {
      var n = arguments[0],
          i = arguments[1],
          r = arguments[2],
          s = arguments[3];ce.call(this, n, i), this.parent = r, this.index = s;
    }
  }function vs() {
    if (this.parentLine = null, this.segs = null, this.resultSegs = new I(), this.minimumSize = null, 1 === arguments.length) {
      var t = arguments[0];vs.call(this, t, 2);
    } else if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];this.parentLine = e, this.minimumSize = n, this.init();
    }
  }function ms() {
    this.index = new Bi();
  }function ys() {
    this.querySeg = null, this.items = new I();var t = arguments[0];this.querySeg = t;
  }function xs() {
    this.li = new ae(), this.inputIndex = new ms(), this.outputIndex = new ms(), this.line = null, this.linePts = null, this.distanceTolerance = 0;var t = arguments[0],
        e = arguments[1];this.inputIndex = t, this.outputIndex = e;
  }function Es() {
    this.inputIndex = new ms(), this.outputIndex = new ms(), this.distanceTolerance = 0;
  }function Is() {
    this.inputGeom = null, this.lineSimplifier = new Es(), this.linestringMap = null;var t = arguments[0];this.inputGeom = t;
  }function Ns() {
    xe.apply(this), this.linestringMap = null;var t = arguments[0];this.linestringMap = t;
  }function Cs() {
    this.tps = null;var t = arguments[0];this.tps = t;
  }function Ss() {
    this.seg = null, this.segLen = null, this.splitPt = null, this.minimumLen = 0;var t = arguments[0];this.seg = t, this.segLen = t.getLength();
  }function ws() {}function Ls() {}function Rs() {}function Ts() {
    if (this.p = null, 1 === arguments.length) {
      var t = arguments[0];this.p = new g(t);
    } else if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];this.p = new g(e, n);
    } else if (3 === arguments.length) {
      var i = arguments[0],
          r = arguments[1],
          s = arguments[2];this.p = new g(i, r, s);
    }
  }function Ps() {
    this._isOnConstraint = null, this.constraint = null;var t = arguments[0];Ts.call(this, t);
  }function bs() {
    this._rot = null, this.vertex = null, this.next = null, this.data = null;
  }function Os() {
    this.subdiv = null, this.isUsingTolerance = !1;var t = arguments[0];this.subdiv = t, this.isUsingTolerance = t.getTolerance() > 0;
  }function _s() {}function Ms() {
    this.subdiv = null, this.lastEdge = null;var t = arguments[0];this.subdiv = t, this.init();
  }function Ds() {
    if (this.seg = null, 1 === arguments.length) {
      if ("string" == typeof arguments[0]) {
        var t = arguments[0];l.call(this, t);
      } else if (arguments[0] instanceof ce) {
        var e = arguments[0];l.call(this, "Locate failed to converge (at edge: " + e + ").  Possible causes include invalid Subdivision topology or very close sites"), this.seg = new ce(e);
      }
    } else if (2 === arguments.length) {
      var n = arguments[0],
          i = arguments[1];l.call(this, Ds.msgWithSpatial(n, i)), this.seg = new ce(i);
    }
  }function As() {}function Fs() {
    this.visitedKey = 0, this.quadEdges = new I(), this.startingEdge = null, this.tolerance = null, this.edgeCoincidenceTolerance = null, this.frameVertex = new Array(3).fill(null), this.frameEnv = null, this.locator = null, this.seg = new ce(), this.triEdges = new Array(3).fill(null);var t = arguments[0],
        e = arguments[1];this.tolerance = e, this.edgeCoincidenceTolerance = e / Fs.EDGE_COINCIDENCE_TOL_FACTOR, this.createFrame(t), this.startingEdge = this.initSubdiv(), this.locator = new Ms(this);
  }function Gs() {}function qs() {
    this.triList = new I();
  }function Bs() {
    this.triList = new I();
  }function zs() {
    this.coordList = new N(), this.triCoords = new I();
  }function Vs() {
    if (this.ls = null, this.data = null, 2 === arguments.length) {
      var t = arguments[0],
          e = arguments[1];this.ls = new ce(t, e);
    } else if (3 === arguments.length) {
      var n = arguments[0],
          i = arguments[1],
          r = arguments[2];this.ls = new ce(n, i), this.data = r;
    } else if (6 === arguments.length) {
      var s = arguments[0],
          o = arguments[1],
          a = arguments[2],
          u = arguments[3],
          l = arguments[4],
          h = arguments[5];Vs.call(this, new g(s, o, a), new g(u, l, h));
    } else if (7 === arguments.length) {
      var c = arguments[0],
          f = arguments[1],
          d = arguments[2],
          p = arguments[3],
          v = arguments[4],
          m = arguments[5],
          y = arguments[6];Vs.call(this, new g(c, f, d), new g(p, v, m), y);
    }
  }function ks() {}function Ys() {
    if (this.p = null, this.data = null, this.left = null, this.right = null, this.count = null, 2 === arguments.length) {
      var t = arguments[0],
          e = arguments[1];this.p = new g(t), this.left = null, this.right = null, this.count = 1, this.data = e;
    } else if (3 === arguments.length) {
      var n = arguments[0],
          i = arguments[1],
          r = arguments[2];this.p = new g(n, i), this.left = null, this.right = null, this.count = 1, this.data = r;
    }
  }function Us() {
    if (this.root = null, this.numberOfNodes = null, this.tolerance = null, 0 === arguments.length) Us.call(this, 0);else if (1 === arguments.length) {
      var t = arguments[0];this.tolerance = t;
    }
  }function Xs() {
    this.tolerance = null, this.matchNode = null, this.matchDist = 0, this.p = null;var t = arguments[0],
        e = arguments[1];this.p = t, this.tolerance = e;
  }function Hs() {
    this.initialVertices = null, this.segVertices = null, this.segments = new I(), this.subdiv = null, this.incDel = null, this.convexHull = null, this.splitFinder = new Ls(), this.kdt = null, this.vertexFactory = null, this.computeAreaEnv = null, this.splitPt = null, this.tolerance = null;var t = arguments[0],
        e = arguments[1];this.initialVertices = new I(t), this.tolerance = e, this.kdt = new Us(e);
  }function Ws() {
    this.siteCoords = null, this.tolerance = 0, this.subdiv = null;
  }function js() {
    this.siteCoords = null, this.constraintLines = null, this.tolerance = 0, this.subdiv = null, this.constraintVertexMap = new rt();
  }function Ks() {
    this.siteCoords = null, this.tolerance = 0, this.subdiv = null, this.clipEnv = null, this.diagramEnv = null;
  }function Zs() {}"fill" in Array.prototype || Object.defineProperty(Array.prototype, "fill", { configurable: !0, value: function (t) {
      if (void 0 === this || null === this) throw new TypeError(this + " is not an object");var e = Object(this),
          n = Math.max(Math.min(e.length, 9007199254740991), 0) || 0,
          i = 1 in arguments ? parseInt(Number(arguments[1]), 10) || 0 : 0;i = i < 0 ? Math.max(n + i, 0) : Math.min(i, n);var r = 2 in arguments && void 0 !== arguments[2] ? parseInt(Number(arguments[2]), 10) || 0 : n;for (r = r < 0 ? Math.max(n + arguments[2], 0) : Math.min(r, n); i < r;) e[i] = t, ++i;return e;
    }, writable: !0 }), Number.isFinite = Number.isFinite || function (t) {
    return "number" == typeof t && isFinite(t);
  }, Number.isInteger = Number.isInteger || function (t) {
    return "number" == typeof t && isFinite(t) && Math.floor(t) === t;
  }, Number.parseFloat = Number.parseFloat || parseFloat, Number.isNaN = Number.isNaN || function (t) {
    return t !== t;
  }, Math.trunc = Math.trunc || function (t) {
    return t < 0 ? Math.ceil(t) : Math.floor(t);
  }, e(n.prototype, { interfaces_: function () {
      return [];
    }, getClass: function () {
      return n;
    } }), n.equalsWithTolerance = function (t, e, n) {
    return Math.abs(t - e) <= n;
  }, r.isNaN = function (t) {
    return Number.isNaN(t);
  }, r.doubleToLongBits = function (t) {
    return t;
  }, r.longBitsToDouble = function (t) {
    return t;
  }, r.isInfinite = function (t) {
    return !Number.isFinite(t);
  }, r.MAX_VALUE = Number.MAX_VALUE, l.prototype = Object.create(Error.prototype), l.prototype.constructor = Error, h(c, l), e(c.prototype, { interfaces_: function () {
      return [];
    }, getClass: function () {
      return c;
    } }), e(f.prototype, { interfaces_: function () {
      return [];
    }, getClass: function () {
      return f;
    } }), f.shouldNeverReachHere = function () {
    if (0 === arguments.length) f.shouldNeverReachHere(null);else if (1 === arguments.length) {
      var t = arguments[0];throw new c("Should never reach here" + (null !== t ? ": " + t : ""));
    }
  }, f.isTrue = function () {
    if (1 === arguments.length) {
      var t = arguments[0];f.isTrue(t, null);
    } else if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];if (!e) throw null === n ? new c() : new c(n);
    }
  }, f.equals = function () {
    if (2 === arguments.length) {
      var t = arguments[0],
          e = arguments[1];f.equals(t, e, null);
    } else if (3 === arguments.length) {
      var n = arguments[0],
          i = arguments[1],
          r = arguments[2];if (!i.equals(n)) throw new c("Expected " + n + " but encountered " + i + (null !== r ? ": " + r : ""));
    }
  }, e(g.prototype, { setOrdinate: function (t, e) {
      switch (t) {case g.X:
          this.x = e;break;case g.Y:
          this.y = e;break;case g.Z:
          this.z = e;break;default:
          throw new i("Invalid ordinate index: " + t);}
    }, equals2D: function () {
      if (1 === arguments.length) {
        var t = arguments[0];return this.x === t.x && this.y === t.y;
      }if (2 === arguments.length) {
        var e = arguments[0],
            i = arguments[1];return !!n.equalsWithTolerance(this.x, e.x, i) && !!n.equalsWithTolerance(this.y, e.y, i);
      }
    }, getOrdinate: function (t) {
      switch (t) {case g.X:
          return this.x;case g.Y:
          return this.y;case g.Z:
          return this.z;}throw new i("Invalid ordinate index: " + t);
    }, equals3D: function (t) {
      return this.x === t.x && this.y === t.y && (this.z === t.z || r.isNaN(this.z) && r.isNaN(t.z));
    }, equals: function (t) {
      return t instanceof g && this.equals2D(t);
    }, equalInZ: function (t, e) {
      return n.equalsWithTolerance(this.z, t.z, e);
    }, compareTo: function (t) {
      var e = t;return this.x < e.x ? -1 : this.x > e.x ? 1 : this.y < e.y ? -1 : this.y > e.y ? 1 : 0;
    }, clone: function () {
      try {
        var t = null;return t;
      } catch (t) {
        if (t instanceof CloneNotSupportedException) return f.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"), null;throw t;
      } finally {}
    }, copy: function () {
      return new g(this);
    }, toString: function () {
      return "(" + this.x + ", " + this.y + ", " + this.z + ")";
    }, distance3D: function (t) {
      var e = this.x - t.x,
          n = this.y - t.y,
          i = this.z - t.z;return Math.sqrt(e * e + n * n + i * i);
    }, distance: function (t) {
      var e = this.x - t.x,
          n = this.y - t.y;return Math.sqrt(e * e + n * n);
    }, hashCode: function () {
      var t = 17;return t = 37 * t + g.hashCode(this.x), t = 37 * t + g.hashCode(this.y);
    }, setCoordinate: function (t) {
      this.x = t.x, this.y = t.y, this.z = t.z;
    }, interfaces_: function () {
      return [s, o, u];
    }, getClass: function () {
      return g;
    } }), g.hashCode = function () {
    if (1 === arguments.length) {
      var t = arguments[0],
          e = r.doubleToLongBits(t);return Math.trunc(e ^ e >>> 32);
    }
  }, e(d.prototype, { compare: function (t, e) {
      var n = t,
          i = e,
          r = d.compare(n.x, i.x);if (0 !== r) return r;var s = d.compare(n.y, i.y);if (0 !== s) return s;if (this.dimensionsToTest <= 2) return 0;var o = d.compare(n.z, i.z);return o;
    }, interfaces_: function () {
      return [a];
    }, getClass: function () {
      return d;
    } }), d.compare = function (t, e) {
    return t < e ? -1 : t > e ? 1 : r.isNaN(t) ? r.isNaN(e) ? 0 : -1 : r.isNaN(e) ? 1 : 0;
  }, g.DimensionalComparator = d, g.serialVersionUID = 0x5cbf2c235c7e5800, g.NULL_ORDINATE = r.NaN, g.X = 0, g.Y = 1, g.Z = 2, p.prototype.hasNext = function () {}, p.prototype.next = function () {}, p.prototype.remove = function () {}, v.prototype.add = function () {}, v.prototype.addAll = function () {}, v.prototype.isEmpty = function () {}, v.prototype.iterator = function () {}, v.prototype.size = function () {}, v.prototype.toArray = function () {}, v.prototype.remove = function () {}, m.prototype = new Error(), m.prototype.name = "IndexOutOfBoundsException", y.prototype = Object.create(v.prototype), y.prototype.constructor = y, y.prototype.get = function () {}, y.prototype.set = function () {}, y.prototype.isEmpty = function () {}, x.prototype = new Error(), x.prototype.name = "NoSuchElementException", E.prototype = new Error(), E.prototype.name = "OperationNotSupported", I.prototype = Object.create(y.prototype), I.prototype.constructor = I, I.prototype.ensureCapacity = function () {}, I.prototype.interfaces_ = function () {
    return [y, v];
  }, I.prototype.add = function (t) {
    return 1 === arguments.length ? this.array_.push(t) : this.array_.splice(arguments[0], arguments[1]), !0;
  }, I.prototype.clear = function () {
    this.array_ = [];
  }, I.prototype.addAll = function (t) {
    for (var e = t.iterator(); e.hasNext();) this.add(e.next());return !0;
  }, I.prototype.set = function (t, e) {
    var n = this.array_[t];return this.array_[t] = e, n;
  }, I.prototype.iterator = function () {
    return new Qs(this);
  }, I.prototype.get = function (t) {
    if (t < 0 || t >= this.size()) throw new m();return this.array_[t];
  }, I.prototype.isEmpty = function () {
    return 0 === this.array_.length;
  }, I.prototype.size = function () {
    return this.array_.length;
  }, I.prototype.toArray = function () {
    for (var t = [], e = 0, n = this.array_.length; e < n; e++) t.push(this.array_[e]);return t;
  }, I.prototype.remove = function (t) {
    for (var e = !1, n = 0, i = this.array_.length; n < i; n++) if (this.array_[n] === t) {
      this.array_.splice(n, 1), e = !0;break;
    }return e;
  };var Qs = function (t) {
    this.arrayList_ = t, this.position_ = 0;
  };Qs.prototype.next = function () {
    if (this.position_ === this.arrayList_.size()) throw new x();return this.arrayList_.get(this.position_++);
  }, Qs.prototype.hasNext = function () {
    return this.position_ < this.arrayList_.size();
  }, Qs.prototype.set = function (t) {
    return this.arrayList_.set(this.position_ - 1, t);
  }, Qs.prototype.remove = function () {
    this.arrayList_.remove(this.arrayList_.get(this.position_));
  }, h(N, I), e(N.prototype, { getCoordinate: function (t) {
      return this.get(t);
    }, addAll: function () {
      if (2 === arguments.length) {
        for (var t = arguments[0], e = arguments[1], n = !1, i = t.iterator(); i.hasNext();) this.add(i.next(), e), n = !0;return n;
      }return I.prototype.addAll.apply(this, arguments);
    }, clone: function t() {
      for (var t = I.prototype.clone.call(this), e = 0; e < this.size(); e++) t.add(e, this.get(e).copy());return t;
    }, toCoordinateArray: function () {
      return this.toArray(N.coordArrayType);
    }, add: function () {
      if (1 === arguments.length) {
        var t = arguments[0];I.prototype.add.call(this, t);
      } else if (2 === arguments.length) {
        if (arguments[0] instanceof Array && "boolean" == typeof arguments[1]) {
          var e = arguments[0],
              n = arguments[1];return this.add(e, n, !0), !0;
        }if (arguments[0] instanceof g && "boolean" == typeof arguments[1]) {
          var i = arguments[0],
              r = arguments[1];if (!r && this.size() >= 1) {
            var s = this.get(this.size() - 1);if (s.equals2D(i)) return null;
          }I.prototype.add.call(this, i);
        } else if (arguments[0] instanceof Object && "boolean" == typeof arguments[1]) {
          var o = arguments[0],
              a = arguments[1];return this.add(o, a), !0;
        }
      } else if (3 === arguments.length) {
        if ("boolean" == typeof arguments[2] && arguments[0] instanceof Array && "boolean" == typeof arguments[1]) {
          var u = arguments[0],
              l = arguments[1],
              h = arguments[2];if (h) for (var c = 0; c < u.length; c++) this.add(u[c], l);else for (var c = u.length - 1; c >= 0; c--) this.add(u[c], l);return !0;
        }if ("boolean" == typeof arguments[2] && Number.isInteger(arguments[0]) && arguments[1] instanceof g) {
          var f = arguments[0],
              d = arguments[1],
              p = arguments[2];if (!p) {
            var v = this.size();if (v > 0) {
              if (f > 0) {
                var m = this.get(f - 1);if (m.equals2D(d)) return null;
              }if (f < v) {
                var y = this.get(f);if (y.equals2D(d)) return null;
              }
            }
          }I.prototype.add.call(this, f, d);
        }
      } else if (4 === arguments.length) {
        var x = arguments[0],
            E = arguments[1],
            N = arguments[2],
            C = arguments[3],
            S = 1;N > C && (S = -1);for (var c = N; c !== C; c += S) this.add(x[c], E);return !0;
      }
    }, closeRing: function () {
      this.size() > 0 && this.add(new g(this.get(0)), !1);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return N;
    } }), N.coordArrayType = new Array(0).fill(null), e(C.prototype, { getArea: function () {
      return this.getWidth() * this.getHeight();
    }, equals: function (t) {
      if (!(t instanceof C)) return !1;var e = t;return this.isNull() ? e.isNull() : this.maxx === e.getMaxX() && this.maxy === e.getMaxY() && this.minx === e.getMinX() && this.miny === e.getMinY();
    }, intersection: function (t) {
      if (this.isNull() || t.isNull() || !this.intersects(t)) return new C();var e = this.minx > t.minx ? this.minx : t.minx,
          n = this.miny > t.miny ? this.miny : t.miny,
          i = this.maxx < t.maxx ? this.maxx : t.maxx,
          r = this.maxy < t.maxy ? this.maxy : t.maxy;return new C(e, i, n, r);
    }, isNull: function () {
      return this.maxx < this.minx;
    }, getMaxX: function () {
      return this.maxx;
    }, covers: function () {
      if (1 === arguments.length) {
        if (arguments[0] instanceof g) {
          var t = arguments[0];return this.covers(t.x, t.y);
        }if (arguments[0] instanceof C) {
          var e = arguments[0];return !this.isNull() && !e.isNull() && e.getMinX() >= this.minx && e.getMaxX() <= this.maxx && e.getMinY() >= this.miny && e.getMaxY() <= this.maxy;
        }
      } else if (2 === arguments.length) {
        var n = arguments[0],
            i = arguments[1];return !this.isNull() && n >= this.minx && n <= this.maxx && i >= this.miny && i <= this.maxy;
      }
    }, intersects: function () {
      if (1 === arguments.length) {
        if (arguments[0] instanceof C) {
          var t = arguments[0];return !this.isNull() && !t.isNull() && !(t.minx > this.maxx || t.maxx < this.minx || t.miny > this.maxy || t.maxy < this.miny);
        }if (arguments[0] instanceof g) {
          var e = arguments[0];return this.intersects(e.x, e.y);
        }
      } else if (2 === arguments.length) {
        var n = arguments[0],
            i = arguments[1];return !this.isNull() && !(n > this.maxx || n < this.minx || i > this.maxy || i < this.miny);
      }
    }, getMinY: function () {
      return this.miny;
    }, getMinX: function () {
      return this.minx;
    }, expandToInclude: function () {
      if (1 === arguments.length) {
        if (arguments[0] instanceof g) {
          var t = arguments[0];this.expandToInclude(t.x, t.y);
        } else if (arguments[0] instanceof C) {
          var e = arguments[0];if (e.isNull()) return null;this.isNull() ? (this.minx = e.getMinX(), this.maxx = e.getMaxX(), this.miny = e.getMinY(), this.maxy = e.getMaxY()) : (e.minx < this.minx && (this.minx = e.minx), e.maxx > this.maxx && (this.maxx = e.maxx), e.miny < this.miny && (this.miny = e.miny), e.maxy > this.maxy && (this.maxy = e.maxy));
        }
      } else if (2 === arguments.length) {
        var n = arguments[0],
            i = arguments[1];this.isNull() ? (this.minx = n, this.maxx = n, this.miny = i, this.maxy = i) : (n < this.minx && (this.minx = n), n > this.maxx && (this.maxx = n), i < this.miny && (this.miny = i), i > this.maxy && (this.maxy = i));
      }
    }, minExtent: function () {
      if (this.isNull()) return 0;var t = this.getWidth(),
          e = this.getHeight();return t < e ? t : e;
    }, getWidth: function () {
      return this.isNull() ? 0 : this.maxx - this.minx;
    }, compareTo: function (t) {
      var e = t;return this.isNull() ? e.isNull() ? 0 : -1 : e.isNull() ? 1 : this.minx < e.minx ? -1 : this.minx > e.minx ? 1 : this.miny < e.miny ? -1 : this.miny > e.miny ? 1 : this.maxx < e.maxx ? -1 : this.maxx > e.maxx ? 1 : this.maxy < e.maxy ? -1 : this.maxy > e.maxy ? 1 : 0;
    }, translate: function (t, e) {
      return this.isNull() ? null : void this.init(this.getMinX() + t, this.getMaxX() + t, this.getMinY() + e, this.getMaxY() + e);
    }, toString: function () {
      return "Env[" + this.minx + " : " + this.maxx + ", " + this.miny + " : " + this.maxy + "]";
    }, setToNull: function () {
      this.minx = 0, this.maxx = -1, this.miny = 0, this.maxy = -1;
    }, getHeight: function () {
      return this.isNull() ? 0 : this.maxy - this.miny;
    }, maxExtent: function () {
      if (this.isNull()) return 0;var t = this.getWidth(),
          e = this.getHeight();return t > e ? t : e;
    }, expandBy: function () {
      if (1 === arguments.length) {
        var t = arguments[0];this.expandBy(t, t);
      } else if (2 === arguments.length) {
        var e = arguments[0],
            n = arguments[1];if (this.isNull()) return null;this.minx -= e, this.maxx += e, this.miny -= n, this.maxy += n, (this.minx > this.maxx || this.miny > this.maxy) && this.setToNull();
      }
    }, contains: function () {
      if (1 === arguments.length) {
        if (arguments[0] instanceof C) {
          var t = arguments[0];return this.covers(t);
        }if (arguments[0] instanceof g) {
          var e = arguments[0];return this.covers(e);
        }
      } else if (2 === arguments.length) {
        var n = arguments[0],
            i = arguments[1];return this.covers(n, i);
      }
    }, centre: function () {
      return this.isNull() ? null : new g((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2);
    }, init: function () {
      if (0 === arguments.length) this.setToNull();else if (1 === arguments.length) {
        if (arguments[0] instanceof g) {
          var t = arguments[0];this.init(t.x, t.x, t.y, t.y);
        } else if (arguments[0] instanceof C) {
          var e = arguments[0];this.minx = e.minx, this.maxx = e.maxx, this.miny = e.miny, this.maxy = e.maxy;
        }
      } else if (2 === arguments.length) {
        var n = arguments[0],
            i = arguments[1];this.init(n.x, i.x, n.y, i.y);
      } else if (4 === arguments.length) {
        var r = arguments[0],
            s = arguments[1],
            o = arguments[2],
            a = arguments[3];r < s ? (this.minx = r, this.maxx = s) : (this.minx = s, this.maxx = r), o < a ? (this.miny = o, this.maxy = a) : (this.miny = a, this.maxy = o);
      }
    }, getMaxY: function () {
      return this.maxy;
    }, distance: function (t) {
      if (this.intersects(t)) return 0;var e = 0;this.maxx < t.minx ? e = t.minx - this.maxx : this.minx > t.maxx && (e = this.minx - t.maxx);var n = 0;return this.maxy < t.miny ? n = t.miny - this.maxy : this.miny > t.maxy && (n = this.miny - t.maxy), 0 === e ? n : 0 === n ? e : Math.sqrt(e * e + n * n);
    }, hashCode: function () {
      var t = 17;return t = 37 * t + g.hashCode(this.minx), t = 37 * t + g.hashCode(this.maxx), t = 37 * t + g.hashCode(this.miny), t = 37 * t + g.hashCode(this.maxy);
    }, interfaces_: function () {
      return [s, u];
    }, getClass: function () {
      return C;
    } }), C.intersects = function () {
    if (3 === arguments.length) {
      var t = arguments[0],
          e = arguments[1],
          n = arguments[2];return n.x >= (t.x < e.x ? t.x : e.x) && n.x <= (t.x > e.x ? t.x : e.x) && n.y >= (t.y < e.y ? t.y : e.y) && n.y <= (t.y > e.y ? t.y : e.y);
    }if (4 === arguments.length) {
      var i = arguments[0],
          r = arguments[1],
          s = arguments[2],
          o = arguments[3],
          a = Math.min(s.x, o.x),
          u = Math.max(s.x, o.x),
          l = Math.min(i.x, r.x),
          h = Math.max(i.x, r.x);return !(l > u) && !(h < a) && (a = Math.min(s.y, o.y), u = Math.max(s.y, o.y), l = Math.min(i.y, r.y), h = Math.max(i.y, r.y), !(l > u) && !(h < a));
    }
  }, C.serialVersionUID = 0x51845cd552189800, h(w, S), e(w.prototype, { interfaces_: function () {
      return [];
    }, getClass: function () {
      return w;
    } }), e(L.prototype, { interfaces_: function () {
      return [];
    }, getClass: function () {
      return L;
    } }), L.toLocationSymbol = function (t) {
    switch (t) {case L.EXTERIOR:
        return "e";case L.BOUNDARY:
        return "b";case L.INTERIOR:
        return "i";case L.NONE:
        return "-";}throw new i("Unknown location value: " + t);
  }, L.INTERIOR = 0, L.BOUNDARY = 1, L.EXTERIOR = 2, L.NONE = -1, e(T.prototype, { interfaces_: function () {
      return [];
    }, getClass: function () {
      return T;
    } }), T.log10 = function (t) {
    var e = Math.log(t);return r.isInfinite(e) ? e : r.isNaN(e) ? e : e / T.LOG_10;
  }, T.min = function (t, e, n, i) {
    var r = t;return e < r && (r = e), n < r && (r = n), i < r && (r = i), r;
  }, T.clamp = function () {
    if ("number" == typeof arguments[2] && "number" == typeof arguments[0] && "number" == typeof arguments[1]) {
      var t = arguments[0],
          e = arguments[1],
          n = arguments[2];
      return t < e ? e : t > n ? n : t;
    }if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
      var i = arguments[0],
          r = arguments[1],
          s = arguments[2];return i < r ? r : i > s ? s : i;
    }
  }, T.wrap = function (t, e) {
    return t < 0 ? e - -t % e : t % e;
  }, T.max = function () {
    if (3 === arguments.length) {
      var t = arguments[0],
          e = arguments[1],
          n = arguments[2],
          i = t;return e > i && (i = e), n > i && (i = n), i;
    }if (4 === arguments.length) {
      var r = arguments[0],
          s = arguments[1],
          o = arguments[2],
          a = arguments[3],
          i = r;return s > i && (i = s), o > i && (i = o), a > i && (i = a), i;
    }
  }, T.average = function (t, e) {
    return (t + e) / 2;
  }, T.LOG_10 = Math.log(10), P.prototype.append = function (t) {
    this.str += t;
  }, P.prototype.setCharAt = function (t, e) {
    this.str = this.str.substr(0, t) + e + this.str.substr(t + 1);
  }, P.prototype.toString = function (t) {
    return this.str;
  }, b.prototype.intValue = function () {
    return this.value;
  }, b.prototype.compareTo = function (t) {
    return this.value < t ? -1 : this.value > t ? 1 : 0;
  }, b.isNaN = function (t) {
    return Number.isNaN(t);
  }, O.isWhitespace = function (t) {
    return t <= 32 && t >= 0 || 127 == t;
  }, O.toUpperCase = function (t) {
    return t.toUpperCase();
  }, e(_.prototype, { le: function (t) {
      return this.hi < t.hi || this.hi === t.hi && this.lo <= t.lo;
    }, extractSignificantDigits: function (t, e) {
      var n = this.abs(),
          i = _.magnitude(n.hi),
          r = _.TEN.pow(i);n = n.divide(r), n.gt(_.TEN) ? (n = n.divide(_.TEN), i += 1) : n.lt(_.ONE) && (n = n.multiply(_.TEN), i -= 1);for (var s = i + 1, o = new P(), a = _.MAX_PRINT_DIGITS - 1, u = 0; u <= a; u++) {
        t && u === s && o.append(".");var l = Math.trunc(n.hi);if (l < 0) break;var h = !1,
            c = 0;l > 9 ? (h = !0, c = "9") : c = "0" + l, o.append(c), n = n.subtract(_.valueOf(l)).multiply(_.TEN), h && n.selfAdd(_.TEN);var f = !0,
            g = _.magnitude(n.hi);if (g < 0 && Math.abs(g) >= a - u && (f = !1), !f) break;
      }return e[0] = i, o.toString();
    }, sqr: function () {
      return this.multiply(this);
    }, doubleValue: function () {
      return this.hi + this.lo;
    }, subtract: function () {
      if (arguments[0] instanceof _) {
        var t = arguments[0];return this.add(t.negate());
      }if ("number" == typeof arguments[0]) {
        var e = arguments[0];return this.add(-e);
      }
    }, equals: function () {
      if (1 === arguments.length) {
        var t = arguments[0];return this.hi === t.hi && this.lo === t.lo;
      }
    }, isZero: function () {
      return 0 === this.hi && 0 === this.lo;
    }, selfSubtract: function () {
      if (arguments[0] instanceof _) {
        var t = arguments[0];return this.isNaN() ? this : this.selfAdd(-t.hi, -t.lo);
      }if ("number" == typeof arguments[0]) {
        var e = arguments[0];return this.isNaN() ? this : this.selfAdd(-e, 0);
      }
    }, getSpecialNumberString: function () {
      return this.isZero() ? "0.0" : this.isNaN() ? "NaN " : null;
    }, min: function (t) {
      return this.le(t) ? this : t;
    }, selfDivide: function () {
      if (1 === arguments.length) {
        if (arguments[0] instanceof _) {
          var t = arguments[0];return this.selfDivide(t.hi, t.lo);
        }if ("number" == typeof arguments[0]) {
          var e = arguments[0];return this.selfDivide(e, 0);
        }
      } else if (2 === arguments.length) {
        var n = arguments[0],
            i = arguments[1],
            r = null,
            s = null,
            o = null,
            a = null,
            u = null,
            l = null,
            h = null,
            c = null;return u = this.hi / n, l = _.SPLIT * u, r = l - u, c = _.SPLIT * n, r = l - r, s = u - r, o = c - n, h = u * n, o = c - o, a = n - o, c = r * o - h + r * a + s * o + s * a, l = (this.hi - h - c + this.lo - u * i) / n, c = u + l, this.hi = c, this.lo = u - c + l, this;
      }
    }, dump: function () {
      return "DD<" + this.hi + ", " + this.lo + ">";
    }, divide: function () {
      if (arguments[0] instanceof _) {
        var t = arguments[0],
            e = null,
            n = null,
            i = null,
            s = null,
            o = null,
            a = null,
            u = null,
            l = null;o = this.hi / t.hi, a = _.SPLIT * o, e = a - o, l = _.SPLIT * t.hi, e = a - e, n = o - e, i = l - t.hi, u = o * t.hi, i = l - i, s = t.hi - i, l = e * i - u + e * s + n * i + n * s, a = (this.hi - u - l + this.lo - o * t.lo) / t.hi, l = o + a;var h = l,
            c = o - l + a;return new _(h, c);
      }if ("number" == typeof arguments[0]) {
        var f = arguments[0];return r.isNaN(f) ? _.createNaN() : _.copy(this).selfDivide(f, 0);
      }
    }, ge: function (t) {
      return this.hi > t.hi || this.hi === t.hi && this.lo >= t.lo;
    }, pow: function (t) {
      if (0 === t) return _.valueOf(1);var e = new _(this),
          n = _.valueOf(1),
          i = Math.abs(t);if (i > 1) for (; i > 0;) i % 2 === 1 && n.selfMultiply(e), i /= 2, i > 0 && (e = e.sqr());else n = e;return t < 0 ? n.reciprocal() : n;
    }, ceil: function () {
      if (this.isNaN()) return _.NaN;var t = Math.ceil(this.hi),
          e = 0;return t === this.hi && (e = Math.ceil(this.lo)), new _(t, e);
    }, compareTo: function (t) {
      var e = t;return this.hi < e.hi ? -1 : this.hi > e.hi ? 1 : this.lo < e.lo ? -1 : this.lo > e.lo ? 1 : 0;
    }, rint: function () {
      if (this.isNaN()) return this;var t = this.add(.5);return t.floor();
    }, setValue: function () {
      if (arguments[0] instanceof _) {
        var t = arguments[0];return this.init(t), this;
      }if ("number" == typeof arguments[0]) {
        var e = arguments[0];return this.init(e), this;
      }
    }, max: function (t) {
      return this.ge(t) ? this : t;
    }, sqrt: function () {
      if (this.isZero()) return _.valueOf(0);if (this.isNegative()) return _.NaN;var t = 1 / Math.sqrt(this.hi),
          e = this.hi * t,
          n = _.valueOf(e),
          i = this.subtract(n.sqr()),
          r = i.hi * (.5 * t);return n.add(r);
    }, selfAdd: function () {
      if (1 === arguments.length) {
        if (arguments[0] instanceof _) {
          var t = arguments[0];return this.selfAdd(t.hi, t.lo);
        }if ("number" == typeof arguments[0]) {
          var e = arguments[0],
              n = null,
              i = null,
              r = null,
              s = null,
              o = null,
              a = null;return r = this.hi + e, o = r - this.hi, s = r - o, s = e - o + (this.hi - s), a = s + this.lo, n = r + a, i = a + (r - n), this.hi = n + i, this.lo = i + (n - this.hi), this;
        }
      } else if (2 === arguments.length) {
        var u = arguments[0],
            l = arguments[1],
            n = null,
            i = null,
            h = null,
            c = null,
            r = null,
            s = null,
            o = null,
            a = null;r = this.hi + u, h = this.lo + l, o = r - this.hi, a = h - this.lo, s = r - o, c = h - a, s = u - o + (this.hi - s), c = l - a + (this.lo - c), o = s + h, n = r + o, i = o + (r - n), o = c + i;var f = n + o,
            g = o + (n - f);return this.hi = f, this.lo = g, this;
      }
    }, selfMultiply: function () {
      if (1 === arguments.length) {
        if (arguments[0] instanceof _) {
          var t = arguments[0];return this.selfMultiply(t.hi, t.lo);
        }if ("number" == typeof arguments[0]) {
          var e = arguments[0];return this.selfMultiply(e, 0);
        }
      } else if (2 === arguments.length) {
        var n = arguments[0],
            i = arguments[1],
            r = null,
            s = null,
            o = null,
            a = null,
            u = null,
            l = null;u = _.SPLIT * this.hi, r = u - this.hi, l = _.SPLIT * n, r = u - r, s = this.hi - r, o = l - n, u = this.hi * n, o = l - o, a = n - o, l = r * o - u + r * a + s * o + s * a + (this.hi * i + this.lo * n);var h = u + l;r = u - h;var c = l + r;return this.hi = h, this.lo = c, this;
      }
    }, selfSqr: function () {
      return this.selfMultiply(this);
    }, floor: function () {
      if (this.isNaN()) return _.NaN;var t = Math.floor(this.hi),
          e = 0;return t === this.hi && (e = Math.floor(this.lo)), new _(t, e);
    }, negate: function () {
      return this.isNaN() ? this : new _(-this.hi, -this.lo);
    }, clone: function () {
      try {
        return null;
      } catch (t) {
        if (t instanceof CloneNotSupportedException) return null;throw t;
      } finally {}
    }, multiply: function () {
      if (arguments[0] instanceof _) {
        var t = arguments[0];return t.isNaN() ? _.createNaN() : _.copy(this).selfMultiply(t);
      }if ("number" == typeof arguments[0]) {
        var e = arguments[0];return r.isNaN(e) ? _.createNaN() : _.copy(this).selfMultiply(e, 0);
      }
    }, isNaN: function () {
      return r.isNaN(this.hi);
    }, intValue: function () {
      return Math.trunc(this.hi);
    }, toString: function () {
      var t = _.magnitude(this.hi);return t >= -3 && t <= 20 ? this.toStandardNotation() : this.toSciNotation();
    }, toStandardNotation: function () {
      var t = this.getSpecialNumberString();if (null !== t) return t;var e = new Array(1).fill(null),
          n = this.extractSignificantDigits(!0, e),
          i = e[0] + 1,
          r = n;if ("." === n.charAt(0)) r = "0" + n;else if (i < 0) r = "0." + _.stringOfChar("0", -i) + n;else if (n.indexOf(".") === -1) {
        var s = i - n.length,
            o = _.stringOfChar("0", s);r = n + o + ".0";
      }return this.isNegative() ? "-" + r : r;
    }, reciprocal: function () {
      var t = null,
          e = null,
          n = null,
          i = null,
          r = null,
          s = null,
          o = null,
          a = null;r = 1 / this.hi, s = _.SPLIT * r, t = s - r, a = _.SPLIT * this.hi, t = s - t, e = r - t, n = a - this.hi, o = r * this.hi, n = a - n, i = this.hi - n, a = t * n - o + t * i + e * n + e * i, s = (1 - o - a - r * this.lo) / this.hi;var u = r + s,
          l = r - u + s;return new _(u, l);
    }, toSciNotation: function () {
      if (this.isZero()) return _.SCI_NOT_ZERO;var t = this.getSpecialNumberString();if (null !== t) return t;var e = new Array(1).fill(null),
          n = this.extractSignificantDigits(!1, e),
          i = _.SCI_NOT_EXPONENT_CHAR + e[0];if ("0" === n.charAt(0)) throw new IllegalStateException("Found leading zero: " + n);var r = "";n.length > 1 && (r = n.substring(1));var s = n.charAt(0) + "." + r;return this.isNegative() ? "-" + s + i : s + i;
    }, abs: function () {
      return this.isNaN() ? _.NaN : this.isNegative() ? this.negate() : new _(this);
    }, isPositive: function () {
      return this.hi > 0 || 0 === this.hi && this.lo > 0;
    }, lt: function (t) {
      return this.hi < t.hi || this.hi === t.hi && this.lo < t.lo;
    }, add: function () {
      if (arguments[0] instanceof _) {
        var t = arguments[0];return _.copy(this).selfAdd(t);
      }if ("number" == typeof arguments[0]) {
        var e = arguments[0];return _.copy(this).selfAdd(e);
      }
    }, init: function () {
      if (1 === arguments.length) {
        if ("number" == typeof arguments[0]) {
          var t = arguments[0];this.hi = t, this.lo = 0;
        } else if (arguments[0] instanceof _) {
          var e = arguments[0];this.hi = e.hi, this.lo = e.lo;
        }
      } else if (2 === arguments.length) {
        var n = arguments[0],
            i = arguments[1];this.hi = n, this.lo = i;
      }
    }, gt: function (t) {
      return this.hi > t.hi || this.hi === t.hi && this.lo > t.lo;
    }, isNegative: function () {
      return this.hi < 0 || 0 === this.hi && this.lo < 0;
    }, trunc: function () {
      return this.isNaN() ? _.NaN : this.isPositive() ? this.floor() : this.ceil();
    }, signum: function () {
      return this.hi > 0 ? 1 : this.hi < 0 ? -1 : this.lo > 0 ? 1 : this.lo < 0 ? -1 : 0;
    }, interfaces_: function () {
      return [u, s, o];
    }, getClass: function () {
      return _;
    } }), _.sqr = function (t) {
    return _.valueOf(t).selfMultiply(t);
  }, _.valueOf = function () {
    if ("string" == typeof arguments[0]) {
      var t = arguments[0];return _.parse(t);
    }if ("number" == typeof arguments[0]) {
      var e = arguments[0];return new _(e);
    }
  }, _.sqrt = function (t) {
    return _.valueOf(t).sqrt();
  }, _.parse = function (t) {
    for (var e = 0, n = t.length; O.isWhitespace(t.charAt(e));) e++;var i = !1;if (e < n) {
      var r = t.charAt(e);"-" !== r && "+" !== r || (e++, "-" === r && (i = !0));
    }for (var s = new _(), o = 0, a = 0, u = 0;;) {
      if (e >= n) break;var l = t.charAt(e);if (e++, O.isDigit(l)) {
        var h = l - "0";s.selfMultiply(_.TEN), s.selfAdd(h), o++;
      } else {
        if ("." !== l) {
          if ("e" === l || "E" === l) {
            var c = t.substring(e);try {
              u = b.parseInt(c);
            } catch (e) {
              throw e instanceof NumberFormatException ? new NumberFormatException("Invalid exponent " + c + " in string " + t) : e;
            } finally {}break;
          }throw new NumberFormatException("Unexpected character '" + l + "' at position " + e + " in string " + t);
        }a = o;
      }
    }var f = s,
        g = o - a - u;if (0 === g) f = s;else if (g > 0) {
      var d = _.TEN.pow(g);f = s.divide(d);
    } else if (g < 0) {
      var d = _.TEN.pow(-g);f = s.multiply(d);
    }return i ? f.negate() : f;
  }, _.createNaN = function () {
    return new _(r.NaN, r.NaN);
  }, _.copy = function (t) {
    return new _(t);
  }, _.magnitude = function (t) {
    var e = Math.abs(t),
        n = Math.log(e) / Math.log(10),
        i = Math.trunc(Math.floor(n)),
        r = Math.pow(10, i);return 10 * r <= e && (i += 1), i;
  }, _.stringOfChar = function (t, e) {
    for (var n = new P(), i = 0; i < e; i++) n.append(t);return n.toString();
  }, _.PI = new _(3.141592653589793, 1.2246467991473532e-16), _.TWO_PI = new _(6.283185307179586, 2.4492935982947064e-16), _.PI_2 = new _(1.5707963267948966, 6.123233995736766e-17), _.E = new _(2.718281828459045, 1.4456468917292502e-16), _.NaN = new _(r.NaN, r.NaN), _.EPS = 1.23259516440783e-32, _.SPLIT = 134217729, _.MAX_PRINT_DIGITS = 32, _.TEN = _.valueOf(10), _.ONE = _.valueOf(1), _.SCI_NOT_EXPONENT_CHAR = "E", _.SCI_NOT_ZERO = "0.0E0", e(M.prototype, { interfaces_: function () {
      return [];
    }, getClass: function () {
      return M;
    } }), M.orientationIndex = function (t, e, n) {
    var i = M.orientationIndexFilter(t, e, n);if (i <= 1) return i;var r = _.valueOf(e.x).selfAdd(-t.x),
        s = _.valueOf(e.y).selfAdd(-t.y),
        o = _.valueOf(n.x).selfAdd(-e.x),
        a = _.valueOf(n.y).selfAdd(-e.y);return r.selfMultiply(a).selfSubtract(s.selfMultiply(o)).signum();
  }, M.signOfDet2x2 = function (t, e, n, i) {
    var r = t.multiply(i).selfSubtract(e.multiply(n));return r.signum();
  }, M.intersection = function (t, e, n, i) {
    var r = _.valueOf(i.y).selfSubtract(n.y).selfMultiply(_.valueOf(e.x).selfSubtract(t.x)),
        s = _.valueOf(i.x).selfSubtract(n.x).selfMultiply(_.valueOf(e.y).selfSubtract(t.y)),
        o = r.subtract(s),
        a = _.valueOf(i.x).selfSubtract(n.x).selfMultiply(_.valueOf(t.y).selfSubtract(n.y)),
        u = _.valueOf(i.y).selfSubtract(n.y).selfMultiply(_.valueOf(t.x).selfSubtract(n.x)),
        l = a.subtract(u),
        h = l.selfDivide(o).doubleValue(),
        c = _.valueOf(t.x).selfAdd(_.valueOf(e.x).selfSubtract(t.x).selfMultiply(h)).doubleValue(),
        f = _.valueOf(e.x).selfSubtract(t.x).selfMultiply(_.valueOf(t.y).selfSubtract(n.y)),
        d = _.valueOf(e.y).selfSubtract(t.y).selfMultiply(_.valueOf(t.x).selfSubtract(n.x)),
        p = f.subtract(d),
        v = p.selfDivide(o).doubleValue(),
        m = _.valueOf(n.y).selfAdd(_.valueOf(i.y).selfSubtract(n.y).selfMultiply(v)).doubleValue();return new g(c, m);
  }, M.orientationIndexFilter = function (t, e, n) {
    var i = null,
        r = (t.x - n.x) * (e.y - n.y),
        s = (t.y - n.y) * (e.x - n.x),
        o = r - s;if (r > 0) {
      if (s <= 0) return M.signum(o);i = r + s;
    } else {
      if (!(r < 0)) return M.signum(o);if (s >= 0) return M.signum(o);i = -r - s;
    }var a = M.DP_SAFE_EPSILON * i;return o >= a || -o >= a ? M.signum(o) : 2;
  }, M.signum = function (t) {
    return t > 0 ? 1 : t < 0 ? -1 : 0;
  }, M.DP_SAFE_EPSILON = 1e-15, e(D.prototype, { setOrdinate: function (t, e, n) {}, size: function () {}, getOrdinate: function (t, e) {}, getCoordinate: function () {
      if (1 === arguments.length) {
        arguments[0];
      } else if (2 === arguments.length) {
        arguments[0], arguments[1];
      }
    }, getCoordinateCopy: function (t) {}, getDimension: function () {}, getX: function (t) {}, clone: function () {}, expandEnvelope: function (t) {}, copy: function () {}, getY: function (t) {}, toCoordinateArray: function () {}, interfaces_: function () {
      return [o];
    }, getClass: function () {
      return D;
    } }), D.X = 0, D.Y = 1, D.Z = 2, D.M = 3, A.arraycopy = function (t, e, n, i, r) {
    for (var s = 0, o = e; o < e + r; o++) n[i + s] = t[o], s++;
  }, A.getProperty = function (t) {
    return { "line.separator": "\n" }[t];
  }, e(F.prototype, { getY: function () {
      var t = this.y / this.w;if (r.isNaN(t) || r.isInfinite(t)) throw new w();return t;
    }, getX: function () {
      var t = this.x / this.w;if (r.isNaN(t) || r.isInfinite(t)) throw new w();return t;
    }, getCoordinate: function () {
      var t = new g();return t.x = this.getX(), t.y = this.getY(), t;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return F;
    } }), F.intersection = function (t, e, n, i) {
    var s = t.y - e.y,
        o = e.x - t.x,
        a = t.x * e.y - e.x * t.y,
        u = n.y - i.y,
        l = i.x - n.x,
        h = n.x * i.y - i.x * n.y,
        c = o * h - l * a,
        f = u * a - s * h,
        d = s * l - u * o,
        p = c / d,
        v = f / d;if (r.isNaN(p) || r.isInfinite(p) || r.isNaN(v) || r.isInfinite(v)) throw new w();return new g(p, v);
  }, e(G.prototype, { create: function () {
      if (1 === arguments.length) {
        if (arguments[0] instanceof Array) {
          arguments[0];
        } else if (R(arguments[0], D)) {
          arguments[0];
        }
      } else if (2 === arguments.length) {
        arguments[0], arguments[1];
      }
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return G;
    } }), e(q.prototype, { filter: function (t) {}, interfaces_: function () {
      return [];
    }, getClass: function () {
      return q;
    } }), e(B.prototype, { isGeometryCollection: function () {
      return this.getSortIndex() === B.SORTINDEX_GEOMETRYCOLLECTION;
    }, getFactory: function () {
      return this.factory;
    }, getGeometryN: function (t) {
      return this;
    }, getArea: function () {
      return 0;
    }, isRectangle: function () {
      return !1;
    }, equals: function () {
      if (1 === arguments.length) {
        if (arguments[0] instanceof B) {
          var t = arguments[0];return null !== t && this.equalsTopo(t);
        }if (arguments[0] instanceof Object) {
          var e = arguments[0];if (!(e instanceof B)) return !1;var n = e;return this.equalsExact(n);
        }
      }
    }, equalsExact: function (t) {
      return this === t || this.equalsExact(t, 0);
    }, geometryChanged: function () {
      this.apply(B.geometryChangedFilter);
    }, geometryChangedAction: function () {
      this.envelope = null;
    }, equalsNorm: function (t) {
      return null !== t && this.norm().equalsExact(t.norm());
    }, getLength: function () {
      return 0;
    }, getNumGeometries: function () {
      return 1;
    }, compareTo: function () {
      if (1 === arguments.length) {
        var t = arguments[0],
            e = t;return this.getSortIndex() !== e.getSortIndex() ? this.getSortIndex() - e.getSortIndex() : this.isEmpty() && e.isEmpty() ? 0 : this.isEmpty() ? -1 : e.isEmpty() ? 1 : this.compareToSameClass(t);
      }if (2 === arguments.length) {
        var n = arguments[0],
            i = arguments[1],
            e = n;return this.getSortIndex() !== e.getSortIndex() ? this.getSortIndex() - e.getSortIndex() : this.isEmpty() && e.isEmpty() ? 0 : this.isEmpty() ? -1 : e.isEmpty() ? 1 : this.compareToSameClass(n, i);
      }
    }, getUserData: function () {
      return this.userData;
    }, getSRID: function () {
      return this.SRID;
    }, getEnvelope: function () {
      return this.getFactory().toGeometry(this.getEnvelopeInternal());
    }, checkNotGeometryCollection: function (t) {
      if (t.getSortIndex() === B.SORTINDEX_GEOMETRYCOLLECTION) throw new i("This method does not support GeometryCollection arguments");
    }, equal: function (t, e, n) {
      return 0 === n ? t.equals(e) : t.distance(e) <= n;
    }, norm: function () {
      var t = this.copy();return t.normalize(), t;
    }, getPrecisionModel: function () {
      return this.factory.getPrecisionModel();
    }, getEnvelopeInternal: function () {
      return null === this.envelope && (this.envelope = this.computeEnvelopeInternal()), new C(this.envelope);
    }, setSRID: function (t) {
      this.SRID = t;
    }, setUserData: function (t) {
      this.userData = t;
    }, compare: function (t, e) {
      for (var n = t.iterator(), i = e.iterator(); n.hasNext() && i.hasNext();) {
        var r = n.next(),
            s = i.next(),
            o = r.compareTo(s);if (0 !== o) return o;
      }return n.hasNext() ? 1 : i.hasNext() ? -1 : 0;
    }, hashCode: function () {
      return this.getEnvelopeInternal().hashCode();
    }, isGeometryCollectionOrDerived: function () {
      return this.getSortIndex() === B.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === B.SORTINDEX_MULTIPOINT || this.getSortIndex() === B.SORTINDEX_MULTILINESTRING || this.getSortIndex() === B.SORTINDEX_MULTIPOLYGON;
    }, interfaces_: function () {
      return [o, s, u];
    }, getClass: function () {
      return B;
    } }), B.hasNonEmptyElements = function (t) {
    for (var e = 0; e < t.length; e++) if (!t[e].isEmpty()) return !0;return !1;
  }, B.hasNullElements = function (t) {
    for (var e = 0; e < t.length; e++) if (null === t[e]) return !0;return !1;
  }, B.serialVersionUID = 0x799ea46522854c00, B.SORTINDEX_POINT = 0, B.SORTINDEX_MULTIPOINT = 1, B.SORTINDEX_LINESTRING = 2, B.SORTINDEX_LINEARRING = 3, B.SORTINDEX_MULTILINESTRING = 4, B.SORTINDEX_POLYGON = 5, B.SORTINDEX_MULTIPOLYGON = 6, B.SORTINDEX_GEOMETRYCOLLECTION = 7, B.geometryChangedFilter = { interfaces_: function () {
      return [q];
    }, filter: function (t) {
      t.geometryChangedAction();
    } }, e(z.prototype, { filter: function (t) {}, interfaces_: function () {
      return [];
    }, getClass: function () {
      return z;
    } }), e(V.prototype, { isInBoundary: function (t) {}, interfaces_: function () {
      return [];
    }, getClass: function () {
      return V;
    } }), e(k.prototype, { isInBoundary: function (t) {
      return t % 2 === 1;
    }, interfaces_: function () {
      return [V];
    }, getClass: function () {
      return k;
    } }), e(Y.prototype, { isInBoundary: function (t) {
      return t > 0;
    }, interfaces_: function () {
      return [V];
    }, getClass: function () {
      return Y;
    } }), e(U.prototype, { isInBoundary: function (t) {
      return t > 1;
    }, interfaces_: function () {
      return [V];
    }, getClass: function () {
      return U;
    } }), e(X.prototype, { isInBoundary: function (t) {
      return 1 === t;
    }, interfaces_: function () {
      return [V];
    }, getClass: function () {
      return X;
    } }), V.Mod2BoundaryNodeRule = k, V.EndPointBoundaryNodeRule = Y, V.MultiValentEndPointBoundaryNodeRule = U, V.MonoValentEndPointBoundaryNodeRule = X, V.MOD2_BOUNDARY_RULE = new k(), V.ENDPOINT_BOUNDARY_RULE = new Y(), V.MULTIVALENT_ENDPOINT_BOUNDARY_RULE = new U(), V.MONOVALENT_ENDPOINT_BOUNDARY_RULE = new X(), V.OGC_SFS_BOUNDARY_RULE = V.MOD2_BOUNDARY_RULE, e(H.prototype, { interfaces_: function () {
      return [];
    }, getClass: function () {
      return H;
    } }), H.isRing = function (t) {
    return !(t.length < 4) && !!t[0].equals2D(t[t.length - 1]);
  }, H.ptNotInList = function (t, e) {
    for (var n = 0; n < t.length; n++) {
      var i = t[n];if (H.indexOf(i, e) < 0) return i;
    }return null;
  }, H.scroll = function (t, e) {
    var n = H.indexOf(e, t);if (n < 0) return null;var i = new Array(t.length).fill(null);A.arraycopy(t, n, i, 0, t.length - n), A.arraycopy(t, 0, i, t.length - n, n), A.arraycopy(i, 0, t, 0, t.length);
  }, H.equals = function () {
    if (2 === arguments.length) {
      var t = arguments[0],
          e = arguments[1];if (t === e) return !0;if (null === t || null === e) return !1;if (t.length !== e.length) return !1;for (var n = 0; n < t.length; n++) if (!t[n].equals(e[n])) return !1;return !0;
    }if (3 === arguments.length) {
      var i = arguments[0],
          r = arguments[1],
          s = arguments[2];if (i === r) return !0;if (null === i || null === r) return !1;if (i.length !== r.length) return !1;for (var n = 0; n < i.length; n++) if (0 !== s.compare(i[n], r[n])) return !1;return !0;
    }
  }, H.intersection = function (t, e) {
    for (var n = new N(), i = 0; i < t.length; i++) e.intersects(t[i]) && n.add(t[i], !0);return n.toCoordinateArray();
  }, H.hasRepeatedPoints = function (t) {
    for (var e = 1; e < t.length; e++) if (t[e - 1].equals(t[e])) return !0;return !1;
  }, H.removeRepeatedPoints = function (t) {
    if (!H.hasRepeatedPoints(t)) return t;var e = new N(t, !1);return e.toCoordinateArray();
  }, H.reverse = function (t) {
    for (var e = t.length - 1, n = Math.trunc(e / 2), i = 0; i <= n; i++) {
      var r = t[i];t[i] = t[e - i], t[e - i] = r;
    }
  }, H.removeNull = function (t) {
    for (var e = 0, n = 0; n < t.length; n++) null !== t[n] && e++;var i = new Array(e).fill(null);if (0 === e) return i;for (var r = 0, n = 0; n < t.length; n++) null !== t[n] && (i[r++] = t[n]);return i;
  }, H.copyDeep = function () {
    if (1 === arguments.length) {
      for (var t = arguments[0], e = new Array(t.length).fill(null), n = 0; n < t.length; n++) e[n] = new g(t[n]);return e;
    }if (5 === arguments.length) for (var i = arguments[0], r = arguments[1], s = arguments[2], o = arguments[3], a = arguments[4], n = 0; n < a; n++) s[o + n] = new g(i[r + n]);
  }, H.isEqualReversed = function (t, e) {
    for (var n = 0; n < t.length; n++) {
      var i = t[n],
          r = e[t.length - n - 1];if (0 !== i.compareTo(r)) return !1;
    }return !0;
  }, H.envelope = function (t) {
    for (var e = new C(), n = 0; n < t.length; n++) e.expandToInclude(t[n]);return e;
  }, H.toCoordinateArray = function (t) {
    return t.toArray(H.coordArrayType);
  }, H.atLeastNCoordinatesOrNothing = function (t, e) {
    return e.length >= t ? e : [];
  }, H.indexOf = function (t, e) {
    for (var n = 0; n < e.length; n++) if (t.equals(e[n])) return n;return -1;
  }, H.increasingDirection = function (t) {
    for (var e = 0; e < Math.trunc(t.length / 2); e++) {
      var n = t.length - 1 - e,
          i = t[e].compareTo(t[n]);if (0 !== i) return i;
    }return 1;
  }, H.compare = function (t, e) {
    for (var n = 0; n < t.length && n < e.length;) {
      var i = t[n].compareTo(e[n]);if (0 !== i) return i;n++;
    }return n < e.length ? -1 : n < t.length ? 1 : 0;
  }, H.minCoordinate = function (t) {
    for (var e = null, n = 0; n < t.length; n++) (null === e || e.compareTo(t[n]) > 0) && (e = t[n]);return e;
  }, H.extract = function (t, e, n) {
    e = T.clamp(e, 0, t.length), n = T.clamp(n, -1, t.length);var i = n - e + 1;n < 0 && (i = 0), e >= t.length && (i = 0), n < e && (i = 0);var r = new Array(i).fill(null);if (0 === i) return r;for (var s = 0, o = e; o <= n; o++) r[s++] = t[o];return r;
  }, e(W.prototype, { compare: function (t, e) {
      var n = t,
          i = e;return H.compare(n, i);
    }, interfaces_: function () {
      return [a];
    }, getClass: function () {
      return W;
    } }), e(j.prototype, { compare: function (t, e) {
      var n = t,
          i = e;if (n.length < i.length) return -1;if (n.length > i.length) return 1;if (0 === n.length) return 0;var r = H.compare(n, i),
          s = H.isEqualReversed(n, i);return s ? 0 : r;
    }, OLDcompare: function (t, e) {
      var n = t,
          i = e;if (n.length < i.length) return -1;if (n.length > i.length) return 1;if (0 === n.length) return 0;for (var r = H.increasingDirection(n), s = H.increasingDirection(i), o = r > 0 ? 0 : n.length - 1, a = s > 0 ? 0 : n.length - 1, u = 0; u < n.length; u++) {
        var l = n[o].compareTo(i[a]);if (0 !== l) return l;o += r, a += s;
      }return 0;
    }, interfaces_: function () {
      return [a];
    }, getClass: function () {
      return j;
    } }), H.ForwardComparator = W, H.BidirectionalComparator = j, H.coordArrayType = new Array(0).fill(null), K.prototype.get = function () {}, K.prototype.put = function () {}, K.prototype.size = function () {}, K.prototype.values = function () {}, K.prototype.entrySet = function () {}, Z.prototype = new K(), Q.prototype = new v(), Q.prototype.contains = function () {}, J.prototype = new Q(), J.prototype.contains = function (t) {
    for (var e = 0, n = this.array_.length; e < n; e++) {
      var i = this.array_[e];if (i === t) return !0;
    }return !1;
  }, J.prototype.add = function (t) {
    return !this.contains(t) && (this.array_.push(t), !0);
  }, J.prototype.addAll = function (t) {
    for (var e = t.iterator(); e.hasNext();) this.add(e.next());return !0;
  }, J.prototype.remove = function (t) {
    throw new javascript.util.OperationNotSupported();
  }, J.prototype.size = function () {
    return this.array_.length;
  }, J.prototype.isEmpty = function () {
    return 0 === this.array_.length;
  }, J.prototype.toArray = function () {
    for (var t = [], e = 0, n = this.array_.length; e < n; e++) t.push(this.array_[e]);return t;
  }, J.prototype.iterator = function () {
    return new Js(this);
  };var Js = function (t) {
    this.hashSet_ = t, this.position_ = 0;
  };Js.prototype.next = function () {
    if (this.position_ === this.hashSet_.size()) throw new x();return this.hashSet_.array_[this.position_++];
  }, Js.prototype.hasNext = function () {
    return this.position_ < this.hashSet_.size();
  }, Js.prototype.remove = function () {
    throw new E();
  };var $s = 0,
      to = 1;rt.prototype = new Z(), rt.prototype.get = function (t) {
    for (var e = this.root_; null !== e;) {
      var n = t.compareTo(e.key);if (n < 0) e = e.left;else {
        if (!(n > 0)) return e.value;e = e.right;
      }
    }return null;
  }, rt.prototype.put = function (t, e) {
    if (null === this.root_) return this.root_ = { key: t, value: e, left: null, right: null, parent: null, color: $s, getValue: function () {
        return this.value;
      }, getKey: function () {
        return this.key;
      } }, this.size_ = 1, null;var n,
        i,
        r = this.root_;do if (n = r, i = t.compareTo(r.key), i < 0) r = r.left;else {
      if (!(i > 0)) {
        var s = r.value;return r.value = e, s;
      }r = r.right;
    } while (null !== r);var o = { key: t, left: null, right: null, value: e, parent: n, color: $s, getValue: function () {
        return this.value;
      }, getKey: function () {
        return this.key;
      } };return i < 0 ? n.left = o : n.right = o, this.fixAfterInsertion(o), this.size_++, null;
  }, rt.prototype.fixAfterInsertion = function (t) {
    for (t.color = to; null != t && t != this.root_ && t.parent.color == to;) if (tt(t) == nt(tt(tt(t)))) {
      var e = it(tt(tt(t)));$(e) == to ? (et(tt(t), $s), et(e, $s), et(tt(tt(t)), to), t = tt(tt(t))) : (t == it(tt(t)) && (t = tt(t), this.rotateLeft(t)), et(tt(t), $s), et(tt(tt(t)), to), this.rotateRight(tt(tt(t))));
    } else {
      var e = nt(tt(tt(t)));$(e) == to ? (et(tt(t), $s), et(e, $s), et(tt(tt(t)), to), t = tt(tt(t))) : (t == nt(tt(t)) && (t = tt(t), this.rotateRight(t)), et(tt(t), $s), et(tt(tt(t)), to), this.rotateLeft(tt(tt(t))));
    }this.root_.color = $s;
  }, rt.prototype.values = function () {
    var t = new I(),
        e = this.getFirstEntry();if (null !== e) for (t.add(e.value); null !== (e = rt.successor(e));) t.add(e.value);return t;
  }, rt.prototype.entrySet = function () {
    var t = new J(),
        e = this.getFirstEntry();if (null !== e) for (t.add(e); null !== (e = rt.successor(e));) t.add(e);return t;
  }, rt.prototype.rotateLeft = function (t) {
    if (null != t) {
      var e = t.right;t.right = e.left, null != e.left && (e.left.parent = t), e.parent = t.parent, null == t.parent ? this.root_ = e : t.parent.left == t ? t.parent.left = e : t.parent.right = e, e.left = t, t.parent = e;
    }
  }, rt.prototype.rotateRight = function (t) {
    if (null != t) {
      var e = t.left;t.left = e.right, null != e.right && (e.right.parent = t), e.parent = t.parent, null == t.parent ? this.root_ = e : t.parent.right == t ? t.parent.right = e : t.parent.left = e, e.right = t, t.parent = e;
    }
  }, rt.prototype.getFirstEntry = function () {
    var t = this.root_;if (null != t) for (; null != t.left;) t = t.left;return t;
  }, rt.successor = function (t) {
    if (null === t) return null;if (null !== t.right) {
      for (var e = t.right; null !== e.left;) e = e.left;return e;
    }for (var e = t.parent, n = t; null !== e && n === e.right;) n = e, e = e.parent;return e;
  }, rt.prototype.size = function () {
    return this.size_;
  }, e(st.prototype, { interfaces_: function () {
      return [];
    }, getClass: function () {
      return st;
    } }), ot.prototype = new Q(), at.prototype = new ot(), at.prototype.contains = function (t) {
    for (var e = 0, n = this.array_.length; e < n; e++) {
      var i = this.array_[e];if (0 === i.compareTo(t)) return !0;
    }return !1;
  }, at.prototype.add = function (t) {
    if (this.contains(t)) return !1;for (var e = 0, n = this.array_.length; e < n; e++) {
      var i = this.array_[e];if (1 === i.compareTo(t)) return this.array_.splice(e, 0, t), !0;
    }return this.array_.push(t), !0;
  }, at.prototype.addAll = function (t) {
    for (var e = t.iterator(); e.hasNext();) this.add(e.next());return !0;
  }, at.prototype.remove = function (t) {
    throw new E();
  }, at.prototype.size = function () {
    return this.array_.length;
  }, at.prototype.isEmpty = function () {
    return 0 === this.array_.length;
  }, at.prototype.toArray = function () {
    for (var t = [], e = 0, n = this.array_.length; e < n; e++) t.push(this.array_[e]);return t;
  }, at.prototype.iterator = function () {
    return new eo(this);
  };var eo = function (t) {
    this.treeSet_ = t, this.position_ = 0;
  };eo.prototype.next = function () {
    if (this.position_ === this.treeSet_.size()) throw new x();return this.treeSet_.array_[this.position_++];
  }, eo.prototype.hasNext = function () {
    return this.position_ < this.treeSet_.size();
  }, eo.prototype.remove = function () {
    throw new E();
  }, ut.sort = function () {
    var t,
        e,
        n,
        i,
        r = arguments[0];if (1 === arguments.length) return i = function (t, e) {
      return t.compareTo(e);
    }, void r.sort(i);if (2 === arguments.length) n = arguments[1], i = function (t, e) {
      return n.compare(t, e);
    }, r.sort(i);else {
      if (3 === arguments.length) {
        e = r.slice(arguments[1], arguments[2]), e.sort();var s = r.slice(0, arguments[1]).concat(e, r.slice(arguments[2], r.length));for (r.splice(0, r.length), t = 0; t < s.length; t++) r.push(s[t]);return;
      }if (4 === arguments.length) {
        for (e = r.slice(arguments[1], arguments[2]), n = arguments[3], i = function (t, e) {
          return n.compare(t, e);
        }, e.sort(i), s = r.slice(0, arguments[1]).concat(e, r.slice(arguments[2], r.length)), r.splice(0, r.length), t = 0; t < s.length; t++) r.push(s[t]);return;
      }
    }
  }, ut.asList = function (t) {
    for (var e = new I(), n = 0, i = t.length; n < i; n++) e.add(t[n]);return e;
  }, e(lt.prototype, { interfaces_: function () {
      return [];
    }, getClass: function () {
      return lt;
    } }), lt.toDimensionSymbol = function (t) {
    switch (t) {case lt.FALSE:
        return lt.SYM_FALSE;case lt.TRUE:
        return lt.SYM_TRUE;case lt.DONTCARE:
        return lt.SYM_DONTCARE;case lt.P:
        return lt.SYM_P;case lt.L:
        return lt.SYM_L;case lt.A:
        return lt.SYM_A;}throw new i("Unknown dimension value: " + t);
  }, lt.toDimensionValue = function (t) {
    switch (O.toUpperCase(t)) {case lt.SYM_FALSE:
        return lt.FALSE;case lt.SYM_TRUE:
        return lt.TRUE;case lt.SYM_DONTCARE:
        return lt.DONTCARE;case lt.SYM_P:
        return lt.P;case lt.SYM_L:
        return lt.L;case lt.SYM_A:
        return lt.A;}throw new i("Unknown dimension symbol: " + t);
  }, lt.P = 0, lt.L = 1, lt.A = 2, lt.FALSE = -1, lt.TRUE = -2, lt.DONTCARE = -3, lt.SYM_FALSE = "F", lt.SYM_TRUE = "T", lt.SYM_DONTCARE = "*", lt.SYM_P = "0", lt.SYM_L = "1", lt.SYM_A = "2", e(ht.prototype, { filter: function (t) {}, interfaces_: function () {
      return [];
    }, getClass: function () {
      return ht;
    } }), e(ct.prototype, { filter: function (t, e) {}, isDone: function () {}, isGeometryChanged: function () {}, interfaces_: function () {
      return [];
    }, getClass: function () {
      return ct;
    } }), h(ft, B), e(ft.prototype, { computeEnvelopeInternal: function () {
      for (var t = new C(), e = 0; e < this.geometries.length; e++) t.expandToInclude(this.geometries[e].getEnvelopeInternal());return t;
    }, getGeometryN: function (t) {
      return this.geometries[t];
    }, getSortIndex: function () {
      return B.SORTINDEX_GEOMETRYCOLLECTION;
    }, getCoordinates: function () {
      for (var t = new Array(this.getNumPoints()).fill(null), e = -1, n = 0; n < this.geometries.length; n++) for (var i = this.geometries[n].getCoordinates(), r = 0; r < i.length; r++) e++, t[e] = i[r];return t;
    }, getArea: function () {
      for (var t = 0, e = 0; e < this.geometries.length; e++) t += this.geometries[e].getArea();return t;
    }, equalsExact: function () {
      if (2 === arguments.length) {
        var t = arguments[0],
            e = arguments[1];if (!this.isEquivalentClass(t)) return !1;var n = t;if (this.geometries.length !== n.geometries.length) return !1;for (var i = 0; i < this.geometries.length; i++) if (!this.geometries[i].equalsExact(n.geometries[i], e)) return !1;return !0;
      }return B.prototype.equalsExact.apply(this, arguments);
    }, normalize: function () {
      for (var t = 0; t < this.geometries.length; t++) this.geometries[t].normalize();ut.sort(this.geometries);
    }, getCoordinate: function () {
      return this.isEmpty() ? null : this.geometries[0].getCoordinate();
    }, getBoundaryDimension: function () {
      for (var t = lt.FALSE, e = 0; e < this.geometries.length; e++) t = Math.max(t, this.geometries[e].getBoundaryDimension());return t;
    }, getDimension: function () {
      for (var t = lt.FALSE, e = 0; e < this.geometries.length; e++) t = Math.max(t, this.geometries[e].getDimension());return t;
    }, getLength: function () {
      for (var t = 0, e = 0; e < this.geometries.length; e++) t += this.geometries[e].getLength();return t;
    }, getNumPoints: function () {
      for (var t = 0, e = 0; e < this.geometries.length; e++) t += this.geometries[e].getNumPoints();return t;
    }, getNumGeometries: function () {
      return this.geometries.length;
    }, reverse: function () {
      for (var t = this.geometries.length, e = new Array(t).fill(null), n = 0; n < this.geometries.length; n++) e[n] = this.geometries[n].reverse();return this.getFactory().createGeometryCollection(e);
    }, compareToSameClass: function () {
      if (1 === arguments.length) {
        var t = arguments[0],
            e = new at(ut.asList(this.geometries)),
            n = new at(ut.asList(t.geometries));return this.compare(e, n);
      }if (2 === arguments.length) {
        for (var i = arguments[0], r = arguments[1], s = i, o = this.getNumGeometries(), a = s.getNumGeometries(), u = 0; u < o && u < a;) {
          var l = this.getGeometryN(u),
              h = s.getGeometryN(u),
              c = l.compareToSameClass(h, r);if (0 !== c) return c;u++;
        }return u < o ? 1 : u < a ? -1 : 0;
      }
    }, apply: function () {
      if (R(arguments[0], z)) for (var t = arguments[0], e = 0; e < this.geometries.length; e++) this.geometries[e].apply(t);else if (R(arguments[0], ct)) {
        var n = arguments[0];if (0 === this.geometries.length) return null;for (var e = 0; e < this.geometries.length && (this.geometries[e].apply(n), !n.isDone()); e++);n.isGeometryChanged() && this.geometryChanged();
      } else if (R(arguments[0], ht)) {
        var i = arguments[0];i.filter(this);for (var e = 0; e < this.geometries.length; e++) this.geometries[e].apply(i);
      } else if (R(arguments[0], q)) {
        var r = arguments[0];r.filter(this);for (var e = 0; e < this.geometries.length; e++) this.geometries[e].apply(r);
      }
    }, getBoundary: function () {
      return this.checkNotGeometryCollection(this), f.shouldNeverReachHere(), null;
    }, clone: function () {
      var t = B.prototype.clone.call(this);t.geometries = new Array(this.geometries.length).fill(null);for (var e = 0; e < this.geometries.length; e++) t.geometries[e] = this.geometries[e].clone();return t;
    }, getGeometryType: function () {
      return "GeometryCollection";
    }, copy: function () {
      for (var t = new Array(this.geometries.length).fill(null), e = 0; e < t.length; e++) t[e] = this.geometries[e].copy();return new ft(t, this.factory);
    }, isEmpty: function () {
      for (var t = 0; t < this.geometries.length; t++) if (!this.geometries[t].isEmpty()) return !1;return !0;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return ft;
    } }), ft.serialVersionUID = -0x4f07bcb1f857d800, h(gt, ft), e(gt.prototype, { getSortIndex: function () {
      return B.SORTINDEX_MULTILINESTRING;
    }, equalsExact: function () {
      if (2 === arguments.length) {
        var t = arguments[0],
            e = arguments[1];return !!this.isEquivalentClass(t) && ft.prototype.equalsExact.call(this, t, e);
      }return ft.prototype.equalsExact.apply(this, arguments);
    }, getBoundaryDimension: function () {
      return this.isClosed() ? lt.FALSE : 0;
    }, isClosed: function () {
      if (this.isEmpty()) return !1;for (var t = 0; t < this.geometries.length; t++) if (!this.geometries[t].isClosed()) return !1;return !0;
    }, getDimension: function () {
      return 1;
    }, reverse: function () {
      for (var t = this.geometries.length, e = new Array(t).fill(null), n = 0; n < this.geometries.length; n++) e[t - 1 - n] = this.geometries[n].reverse();return this.getFactory().createMultiLineString(e);
    }, getBoundary: function () {
      return new dt(this).getBoundary();
    }, getGeometryType: function () {
      return "MultiLineString";
    }, copy: function () {
      for (var t = new Array(this.geometries.length).fill(null), e = 0; e < t.length; e++) t[e] = this.geometries[e].copy();return new gt(t, this.factory);
    }, interfaces_: function () {
      return [st];
    }, getClass: function () {
      return gt;
    } }), gt.serialVersionUID = 0x7155d2ab4afa8000, e(dt.prototype, { boundaryMultiLineString: function (t) {
      if (this.geom.isEmpty()) return this.getEmptyMultiPoint();var e = this.computeBoundaryCoordinates(t);return 1 === e.length ? this.geomFact.createPoint(e[0]) : this.geomFact.createMultiPointFromCoords(e);
    }, getBoundary: function () {
      return this.geom instanceof St ? this.boundaryLineString(this.geom) : this.geom instanceof gt ? this.boundaryMultiLineString(this.geom) : this.geom.getBoundary();
    }, boundaryLineString: function (t) {
      if (this.geom.isEmpty()) return this.getEmptyMultiPoint();if (t.isClosed()) {
        var e = this.bnRule.isInBoundary(2);return e ? t.getStartPoint() : this.geomFact.createMultiPoint();
      }return this.geomFact.createMultiPoint([t.getStartPoint(), t.getEndPoint()]);
    }, getEmptyMultiPoint: function () {
      return this.geomFact.createMultiPoint();
    }, computeBoundaryCoordinates: function (t) {
      var e = new I();this.endpointMap = new rt();for (var n = 0; n < t.getNumGeometries(); n++) {
        var i = t.getGeometryN(n);0 !== i.getNumPoints() && (this.addEndpoint(i.getCoordinateN(0)), this.addEndpoint(i.getCoordinateN(i.getNumPoints() - 1)));
      }for (var r = this.endpointMap.entrySet().iterator(); r.hasNext();) {
        var s = r.next(),
            o = s.getValue(),
            a = o.count;this.bnRule.isInBoundary(a) && e.add(s.getKey());
      }return H.toCoordinateArray(e);
    }, addEndpoint: function (t) {
      var e = this.endpointMap.get(t);null === e && (e = new pt(), this.endpointMap.put(t, e)), e.count++;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return dt;
    } }), dt.getBoundary = function () {
    if (1 === arguments.length) {
      var t = arguments[0],
          e = new dt(t);return e.getBoundary();
    }if (2 === arguments.length) {
      var n = arguments[0],
          i = arguments[1],
          e = new dt(n, i);return e.getBoundary();
    }
  }, e(pt.prototype, { interfaces_: function () {
      return [];
    }, getClass: function () {
      return pt;
    } }), e(Nt.prototype, { interfaces_: function () {
      return [];
    }, getClass: function () {
      return Nt;
    } }), Nt.chars = function (t, e) {
    for (var n = new Array(e).fill(null), i = 0; i < e; i++) n[i] = t;return new String(n);
  }, Nt.getStackTrace = function () {
    if (1 === arguments.length) {
      var t = arguments[0],
          e = new xt(),
          n = new vt(e);return t.printStackTrace(n), e.toString();
    }if (2 === arguments.length) {
      for (var i = arguments[0], r = arguments[1], s = "", o = new mt(Nt.getStackTrace(i)), a = new It(o), u = 0; u < r; u++) try {
        s += a.readLine() + Nt.NEWLINE;
      } catch (t) {
        if (!(t instanceof Et)) throw t;f.shouldNeverReachHere();
      } finally {}return s;
    }
  }, Nt.split = function (t, e) {
    for (var n = e.length, i = new I(), r = "" + t, s = r.indexOf(e); s >= 0;) {
      var o = r.substring(0, s);i.add(o), r = r.substring(s + n), s = r.indexOf(e);
    }r.length > 0 && i.add(r);for (var a = new Array(i.size()).fill(null), u = 0; u < a.length; u++) a[u] = i.get(u);return a;
  }, Nt.toString = function () {
    if (1 === arguments.length) {
      var t = arguments[0];return Nt.SIMPLE_ORDINATE_FORMAT.format(t);
    }
  }, Nt.spaces = function (t) {
    return Nt.chars(" ", t);
  }, Nt.NEWLINE = A.getProperty("line.separator"), Nt.SIMPLE_ORDINATE_FORMAT = new yt("0.#"), e(Ct.prototype, { interfaces_: function () {
      return [];
    }, getClass: function () {
      return Ct;
    } }), Ct.copyCoord = function (t, e, n, i) {
    for (var r = Math.min(t.getDimension(), n.getDimension()), s = 0; s < r; s++) n.setOrdinate(i, s, t.getOrdinate(e, s));
  }, Ct.isRing = function (t) {
    var e = t.size();return 0 === e || !(e <= 3) && t.getOrdinate(0, D.X) === t.getOrdinate(e - 1, D.X) && t.getOrdinate(0, D.Y) === t.getOrdinate(e - 1, D.Y);
  }, Ct.isEqual = function (t, e) {
    var n = t.size(),
        i = e.size();if (n !== i) return !1;for (var s = Math.min(t.getDimension(), e.getDimension()), o = 0; o < n; o++) for (var a = 0; a < s; a++) {
      var u = t.getOrdinate(o, a),
          l = e.getOrdinate(o, a);if (!(t.getOrdinate(o, a) === e.getOrdinate(o, a) || r.isNaN(u) && r.isNaN(l))) return !1;
    }return !0;
  }, Ct.extend = function (t, e, n) {
    var i = t.create(n, e.getDimension()),
        r = e.size();if (Ct.copy(e, 0, i, 0, r), r > 0) for (var s = r; s < n; s++) Ct.copy(e, r - 1, i, s, 1);return i;
  }, Ct.reverse = function (t) {
    for (var e = t.size() - 1, n = Math.trunc(e / 2), i = 0; i <= n; i++) Ct.swap(t, i, e - i);
  }, Ct.swap = function (t, e, n) {
    if (e === n) return null;for (var i = 0; i < t.getDimension(); i++) {
      var r = t.getOrdinate(e, i);t.setOrdinate(e, i, t.getOrdinate(n, i)), t.setOrdinate(n, i, r);
    }
  }, Ct.copy = function (t, e, n, i, r) {
    for (var s = 0; s < r; s++) Ct.copyCoord(t, e + s, n, i + s);
  }, Ct.toString = function () {
    if (1 === arguments.length) {
      var t = arguments[0],
          e = t.size();if (0 === e) return "()";var n = t.getDimension(),
          i = new P();i.append("(");for (var r = 0; r < e; r++) {
        r > 0 && i.append(" ");for (var s = 0; s < n; s++) s > 0 && i.append(","), i.append(Nt.toString(t.getOrdinate(r, s)));
      }return i.append(")"), i.toString();
    }
  }, Ct.ensureValidRing = function (t, e) {
    var n = e.size();if (0 === n) return e;if (n <= 3) return Ct.createClosedRing(t, e, 4);var i = e.getOrdinate(0, D.X) === e.getOrdinate(n - 1, D.X) && e.getOrdinate(0, D.Y) === e.getOrdinate(n - 1, D.Y);return i ? e : Ct.createClosedRing(t, e, n + 1);
  }, Ct.createClosedRing = function (t, e, n) {
    var i = t.create(n, e.getDimension()),
        r = e.size();Ct.copy(e, 0, i, 0, r);for (var s = r; s < n; s++) Ct.copy(e, 0, i, s, 1);return i;
  }, h(St, B), e(St.prototype, { computeEnvelopeInternal: function () {
      return this.isEmpty() ? new C() : this.points.expandEnvelope(new C());
    }, isRing: function () {
      return this.isClosed() && this.isSimple();
    }, getSortIndex: function () {
      return B.SORTINDEX_LINESTRING;
    }, getCoordinates: function () {
      return this.points.toCoordinateArray();
    }, equalsExact: function () {
      if (2 === arguments.length) {
        var t = arguments[0],
            e = arguments[1];if (!this.isEquivalentClass(t)) return !1;var n = t;if (this.points.size() !== n.points.size()) return !1;for (var i = 0; i < this.points.size(); i++) if (!this.equal(this.points.getCoordinate(i), n.points.getCoordinate(i), e)) return !1;return !0;
      }return B.prototype.equalsExact.apply(this, arguments);
    }, normalize: function () {
      for (var t = 0; t < Math.trunc(this.points.size() / 2); t++) {
        var e = this.points.size() - 1 - t;if (!this.points.getCoordinate(t).equals(this.points.getCoordinate(e))) return this.points.getCoordinate(t).compareTo(this.points.getCoordinate(e)) > 0 && Ct.reverse(this.points), null;
      }
    }, getCoordinate: function () {
      return this.isEmpty() ? null : this.points.getCoordinate(0);
    }, getBoundaryDimension: function () {
      return this.isClosed() ? lt.FALSE : 0;
    }, isClosed: function () {
      return !this.isEmpty() && this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));
    }, getEndPoint: function () {
      return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1);
    }, getDimension: function () {
      return 1;
    }, getLength: function () {
      return he.computeLength(this.points);
    }, getNumPoints: function () {
      return this.points.size();
    }, reverse: function () {
      var t = this.points.copy();Ct.reverse(t);var e = this.getFactory().createLineString(t);return e;
    }, compareToSameClass: function () {
      if (1 === arguments.length) {
        for (var t = arguments[0], e = t, n = 0, i = 0; n < this.points.size() && i < e.points.size();) {
          var r = this.points.getCoordinate(n).compareTo(e.points.getCoordinate(i));if (0 !== r) return r;n++, i++;
        }return n < this.points.size() ? 1 : i < e.points.size() ? -1 : 0;
      }if (2 === arguments.length) {
        var s = arguments[0],
            o = arguments[1],
            e = s;return o.compare(this.points, e.points);
      }
    }, apply: function () {
      if (R(arguments[0], z)) for (var t = arguments[0], e = 0; e < this.points.size(); e++) t.filter(this.points.getCoordinate(e));else if (R(arguments[0], ct)) {
        var n = arguments[0];if (0 === this.points.size()) return null;for (var e = 0; e < this.points.size() && (n.filter(this.points, e), !n.isDone()); e++);n.isGeometryChanged() && this.geometryChanged();
      } else if (R(arguments[0], ht)) {
        var i = arguments[0];i.filter(this);
      } else if (R(arguments[0], q)) {
        var r = arguments[0];r.filter(this);
      }
    }, getBoundary: function () {
      return new dt(this).getBoundary();
    }, isEquivalentClass: function (t) {
      return t instanceof St;
    }, clone: function () {
      var t = B.prototype.clone.call(this);return t.points = this.points.clone(), t;
    }, getCoordinateN: function (t) {
      return this.points.getCoordinate(t);
    }, getGeometryType: function () {
      return "LineString";
    }, copy: function () {
      return new St(this.points.copy(), this.factory);
    }, getCoordinateSequence: function () {
      return this.points;
    }, isEmpty: function () {
      return 0 === this.points.size();
    }, init: function (t) {
      if (null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])), 1 === t.size()) throw new i("Invalid number of points in LineString (found " + t.size() + " - must be 0 or >= 2)");this.points = t;
    }, isCoordinate: function (t) {
      for (var e = 0; e < this.points.size(); e++) if (this.points.getCoordinate(e).equals(t)) return !0;return !1;
    }, getStartPoint: function () {
      return this.isEmpty() ? null : this.getPointN(0);
    }, getPointN: function (t) {
      return this.getFactory().createPoint(this.points.getCoordinate(t));
    }, interfaces_: function () {
      return [st];
    }, getClass: function () {
      return St;
    } }), St.serialVersionUID = 0x2b2b51ba435c8e00, e(wt.prototype, { interfaces_: function () {
      return [];
    }, getClass: function () {
      return wt;
    } }), h(Lt, B), e(Lt.prototype, { computeEnvelopeInternal: function () {
      if (this.isEmpty()) return new C();var t = new C();return t.expandToInclude(this.coordinates.getX(0), this.coordinates.getY(0)), t;
    }, getSortIndex: function () {
      return B.SORTINDEX_POINT;
    }, getCoordinates: function () {
      return this.isEmpty() ? [] : [this.getCoordinate()];
    }, equalsExact: function () {
      if (2 === arguments.length) {
        var t = arguments[0],
            e = arguments[1];return !!this.isEquivalentClass(t) && (!(!this.isEmpty() || !t.isEmpty()) || this.isEmpty() === t.isEmpty() && this.equal(t.getCoordinate(), this.getCoordinate(), e));
      }return B.prototype.equalsExact.apply(this, arguments);
    }, normalize: function () {}, getCoordinate: function () {
      return 0 !== this.coordinates.size() ? this.coordinates.getCoordinate(0) : null;
    }, getBoundaryDimension: function () {
      return lt.FALSE;
    }, getDimension: function () {
      return 0;
    }, getNumPoints: function () {
      return this.isEmpty() ? 0 : 1;
    }, reverse: function () {
      return this.copy();
    }, getX: function () {
      if (null === this.getCoordinate()) throw new IllegalStateException("getX called on empty Point");return this.getCoordinate().x;
    }, compareToSameClass: function () {
      if (1 === arguments.length) {
        var t = arguments[0],
            e = t;return this.getCoordinate().compareTo(e.getCoordinate());
      }if (2 === arguments.length) {
        var n = arguments[0],
            i = arguments[1],
            e = n;return i.compare(this.coordinates, e.coordinates);
      }
    }, apply: function () {
      if (R(arguments[0], z)) {
        var t = arguments[0];if (this.isEmpty()) return null;t.filter(this.getCoordinate());
      } else if (R(arguments[0], ct)) {
        var e = arguments[0];if (this.isEmpty()) return null;e.filter(this.coordinates, 0), e.isGeometryChanged() && this.geometryChanged();
      } else if (R(arguments[0], ht)) {
        var n = arguments[0];n.filter(this);
      } else if (R(arguments[0], q)) {
        var i = arguments[0];i.filter(this);
      }
    }, getBoundary: function () {
      return this.getFactory().createGeometryCollection(null);
    }, clone: function () {
      var t = B.prototype.clone.call(this);return t.coordinates = this.coordinates.clone(), t;
    }, getGeometryType: function () {
      return "Point";
    }, copy: function () {
      return new Lt(this.coordinates.copy(), this.factory);
    }, getCoordinateSequence: function () {
      return this.coordinates;
    }, getY: function () {
      if (null === this.getCoordinate()) throw new IllegalStateException("getY called on empty Point");return this.getCoordinate().y;
    }, isEmpty: function () {
      return 0 === this.coordinates.size();
    }, init: function (t) {
      null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])), f.isTrue(t.size() <= 1), this.coordinates = t;
    }, isSimple: function () {
      return !0;
    }, interfaces_: function () {
      return [wt];
    }, getClass: function () {
      return Lt;
    } }), Lt.serialVersionUID = 0x44077bad161cbc00, e(Rt.prototype, { interfaces_: function () {
      return [];
    }, getClass: function () {
      return Rt;
    } }), h(Tt, B), e(Tt.prototype, { computeEnvelopeInternal: function () {
      return this.shell.getEnvelopeInternal();
    }, getSortIndex: function () {
      return B.SORTINDEX_POLYGON;
    }, getCoordinates: function () {
      if (this.isEmpty()) return [];for (var t = new Array(this.getNumPoints()).fill(null), e = -1, n = this.shell.getCoordinates(), i = 0; i < n.length; i++) e++, t[e] = n[i];for (var r = 0; r < this.holes.length; r++) for (var s = this.holes[r].getCoordinates(), o = 0; o < s.length; o++) e++, t[e] = s[o];return t;
    }, getArea: function () {
      var t = 0;t += Math.abs(he.signedArea(this.shell.getCoordinateSequence()));for (var e = 0; e < this.holes.length; e++) t -= Math.abs(he.signedArea(this.holes[e].getCoordinateSequence()));return t;
    }, isRectangle: function () {
      if (0 !== this.getNumInteriorRing()) return !1;if (null === this.shell) return !1;if (5 !== this.shell.getNumPoints()) return !1;for (var t = this.shell.getCoordinateSequence(), e = this.getEnvelopeInternal(), n = 0; n < 5; n++) {
        var i = t.getX(n);if (i !== e.getMinX() && i !== e.getMaxX()) return !1;var r = t.getY(n);if (r !== e.getMinY() && r !== e.getMaxY()) return !1;
      }for (var s = t.getX(0), o = t.getY(0), n = 1; n <= 4; n++) {
        var i = t.getX(n),
            r = t.getY(n),
            a = i !== s,
            u = r !== o;if (a === u) return !1;s = i, o = r;
      }return !0;
    }, equalsExact: function () {
      if (2 === arguments.length) {
        var t = arguments[0],
            e = arguments[1];if (!this.isEquivalentClass(t)) return !1;var n = t,
            i = this.shell,
            r = n.shell;if (!i.equalsExact(r, e)) return !1;if (this.holes.length !== n.holes.length) return !1;for (var s = 0; s < this.holes.length; s++) if (!this.holes[s].equalsExact(n.holes[s], e)) return !1;return !0;
      }return B.prototype.equalsExact.apply(this, arguments);
    }, normalize: function () {
      if (0 === arguments.length) {
        this.normalize(this.shell, !0);for (var t = 0; t < this.holes.length; t++) this.normalize(this.holes[t], !1);ut.sort(this.holes);
      } else if (2 === arguments.length) {
        var e = arguments[0],
            n = arguments[1];if (e.isEmpty()) return null;var i = new Array(e.getCoordinates().length - 1).fill(null);A.arraycopy(e.getCoordinates(), 0, i, 0, i.length);var r = H.minCoordinate(e.getCoordinates());H.scroll(i, r), A.arraycopy(i, 0, e.getCoordinates(), 0, i.length), e.getCoordinates()[i.length] = i[0], he.isCCW(e.getCoordinates()) === n && H.reverse(e.getCoordinates());
      }
    }, getCoordinate: function () {
      return this.shell.getCoordinate();
    }, getNumInteriorRing: function () {
      return this.holes.length;
    }, getBoundaryDimension: function () {
      return 1;
    }, getDimension: function () {
      return 2;
    }, getLength: function () {
      var t = 0;t += this.shell.getLength();for (var e = 0; e < this.holes.length; e++) t += this.holes[e].getLength();return t;
    }, getNumPoints: function () {
      for (var t = this.shell.getNumPoints(), e = 0; e < this.holes.length; e++) t += this.holes[e].getNumPoints();return t;
    }, reverse: function () {
      var t = this.copy();t.shell = this.shell.copy().reverse(), t.holes = new Array(this.holes.length).fill(null);for (var e = 0; e < this.holes.length; e++) t.holes[e] = this.holes[e].copy().reverse();return t;
    }, convexHull: function () {
      return this.getExteriorRing().convexHull();
    }, compareToSameClass: function () {
      if (1 === arguments.length) {
        var t = arguments[0],
            e = this.shell,
            n = t.shell;return e.compareToSameClass(n);
      }if (2 === arguments.length) {
        var i = arguments[0],
            r = arguments[1],
            s = i,
            e = this.shell,
            n = s.shell,
            o = e.compareToSameClass(n, r);if (0 !== o) return o;for (var a = this.getNumInteriorRing(), u = s.getNumInteriorRing(), l = 0; l < a && l < u;) {
          var h = this.getInteriorRingN(l),
              c = s.getInteriorRingN(l),
              f = h.compareToSameClass(c, r);if (0 !== f) return f;l++;
        }return l < a ? 1 : l < u ? -1 : 0;
      }
    }, apply: function () {
      if (R(arguments[0], z)) {
        var t = arguments[0];this.shell.apply(t);for (var e = 0; e < this.holes.length; e++) this.holes[e].apply(t);
      } else if (R(arguments[0], ct)) {
        var n = arguments[0];if (this.shell.apply(n), !n.isDone()) for (var e = 0; e < this.holes.length && (this.holes[e].apply(n), !n.isDone()); e++);n.isGeometryChanged() && this.geometryChanged();
      } else if (R(arguments[0], ht)) {
        var i = arguments[0];i.filter(this);
      } else if (R(arguments[0], q)) {
        var r = arguments[0];r.filter(this), this.shell.apply(r);for (var e = 0; e < this.holes.length; e++) this.holes[e].apply(r);
      }
    }, getBoundary: function () {
      if (this.isEmpty()) return this.getFactory().createMultiLineString();var t = new Array(this.holes.length + 1).fill(null);t[0] = this.shell;for (var e = 0; e < this.holes.length; e++) t[e + 1] = this.holes[e];return t.length <= 1 ? this.getFactory().createLinearRing(t[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(t);
    }, clone: function () {
      var t = B.prototype.clone.call(this);t.shell = this.shell.clone(), t.holes = new Array(this.holes.length).fill(null);for (var e = 0; e < this.holes.length; e++) t.holes[e] = this.holes[e].clone();return t;
    }, getGeometryType: function () {
      return "Polygon";
    }, copy: function () {
      for (var t = this.shell.copy(), e = new Array(this.holes.length).fill(null), n = 0; n < e.length; n++) e[n] = this.holes[n].copy();return new Tt(t, e, this.factory);
    }, getExteriorRing: function () {
      return this.shell;
    }, isEmpty: function () {
      return this.shell.isEmpty();
    }, getInteriorRingN: function (t) {
      return this.holes[t];
    }, interfaces_: function () {
      return [Rt];
    }, getClass: function () {
      return Tt;
    } }), Tt.serialVersionUID = -0x307ffefd8dc97200, h(Pt, ft), e(Pt.prototype, { getSortIndex: function () {
      return B.SORTINDEX_MULTIPOINT;
    }, isValid: function () {
      return !0;
    }, equalsExact: function () {
      if (2 === arguments.length) {
        var t = arguments[0],
            e = arguments[1];return !!this.isEquivalentClass(t) && ft.prototype.equalsExact.call(this, t, e);
      }return ft.prototype.equalsExact.apply(this, arguments);
    }, getCoordinate: function () {
      if (1 === arguments.length) {
        var t = arguments[0];return this.geometries[t].getCoordinate();
      }return ft.prototype.getCoordinate.apply(this, arguments);
    }, getBoundaryDimension: function () {
      return lt.FALSE;
    }, getDimension: function () {
      return 0;
    }, getBoundary: function () {
      return this.getFactory().createGeometryCollection(null);
    }, getGeometryType: function () {
      return "MultiPoint";
    }, copy: function () {
      for (var t = new Array(this.geometries.length).fill(null), e = 0; e < t.length; e++) t[e] = this.geometries[e].copy();return new Pt(t, this.factory);
    }, interfaces_: function () {
      return [wt];
    }, getClass: function () {
      return Pt;
    } }), Pt.serialVersionUID = -0x6fb1ed4162e0fc00, h(bt, St), e(bt.prototype, { getSortIndex: function () {
      return B.SORTINDEX_LINEARRING;
    }, getBoundaryDimension: function () {
      return lt.FALSE;
    }, isClosed: function () {
      return !!this.isEmpty() || St.prototype.isClosed.call(this);
    }, reverse: function () {
      var t = this.points.copy();Ct.reverse(t);var e = this.getFactory().createLinearRing(t);return e;
    }, validateConstruction: function () {
      if (!this.isEmpty() && !St.prototype.isClosed.call(this)) throw new i("Points of LinearRing do not form a closed linestring");if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < bt.MINIMUM_VALID_SIZE) throw new i("Invalid number of points in LinearRing (found " + this.getCoordinateSequence().size() + " - must be 0 or >= 4)");
    }, getGeometryType: function () {
      return "LinearRing";
    }, copy: function () {
      return new bt(this.points.copy(), this.factory);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return bt;
    } }), bt.MINIMUM_VALID_SIZE = 4, bt.serialVersionUID = -0x3b229e262367a600, h(Ot, ft), e(Ot.prototype, { getSortIndex: function () {
      return B.SORTINDEX_MULTIPOLYGON;
    }, equalsExact: function () {
      if (2 === arguments.length) {
        var t = arguments[0],
            e = arguments[1];return !!this.isEquivalentClass(t) && ft.prototype.equalsExact.call(this, t, e);
      }return ft.prototype.equalsExact.apply(this, arguments);
    }, getBoundaryDimension: function () {
      return 1;
    }, getDimension: function () {
      return 2;
    }, reverse: function () {
      for (var t = this.geometries.length, e = new Array(t).fill(null), n = 0; n < this.geometries.length; n++) e[n] = this.geometries[n].reverse();return this.getFactory().createMultiPolygon(e);
    }, getBoundary: function () {
      if (this.isEmpty()) return this.getFactory().createMultiLineString();for (var t = new I(), e = 0; e < this.geometries.length; e++) for (var n = this.geometries[e], i = n.getBoundary(), r = 0; r < i.getNumGeometries(); r++) t.add(i.getGeometryN(r));var s = new Array(t.size()).fill(null);return this.getFactory().createMultiLineString(t.toArray(s));
    }, getGeometryType: function () {
      return "MultiPolygon";
    }, copy: function () {
      for (var t = new Array(this.geometries.length).fill(null), e = 0; e < t.length; e++) t[e] = this.geometries[e].copy();return new Ot(t, this.factory);
    }, interfaces_: function () {
      return [Rt];
    }, getClass: function () {
      return Ot;
    } }), Ot.serialVersionUID = -0x7a5aa1369171980, e(_t.prototype, { setCopyUserData: function (t) {
      this.isUserDataCopied = t;
    }, edit: function (t, e) {
      if (null === t) return null;var n = this.editInternal(t, e);return this.isUserDataCopied && n.setUserData(t.getUserData()), n;
    }, editInternal: function (t, e) {
      return null === this.factory && (this.factory = t.getFactory()), t instanceof ft ? this.editGeometryCollection(t, e) : t instanceof Tt ? this.editPolygon(t, e) : t instanceof Lt ? e.edit(t, this.factory) : t instanceof St ? e.edit(t, this.factory) : (f.shouldNeverReachHere("Unsupported Geometry class: " + t.getClass().getName()), null);
    }, editGeometryCollection: function (t, e) {
      for (var n = e.edit(t, this.factory), i = new I(), r = 0; r < n.getNumGeometries(); r++) {
        var s = this.edit(n.getGeometryN(r), e);null === s || s.isEmpty() || i.add(s);
      }return n.getClass() === Pt ? this.factory.createMultiPoint(i.toArray([])) : n.getClass() === gt ? this.factory.createMultiLineString(i.toArray([])) : n.getClass() === Ot ? this.factory.createMultiPolygon(i.toArray([])) : this.factory.createGeometryCollection(i.toArray([]));
    }, editPolygon: function (t, e) {
      var n = e.edit(t, this.factory);if (null === n && (n = this.factory.createPolygon(null)), n.isEmpty()) return n;var i = this.edit(n.getExteriorRing(), e);if (null === i || i.isEmpty()) return this.factory.createPolygon();for (var r = new I(), s = 0; s < n.getNumInteriorRing(); s++) {
        var o = this.edit(n.getInteriorRingN(s), e);null === o || o.isEmpty() || r.add(o);
      }return this.factory.createPolygon(i, r.toArray([]));
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return _t;
    } }), _t.GeometryEditorOperation = Mt, e(Dt.prototype, { edit: function (t, e) {
      return t;
    }, interfaces_: function () {
      return [Mt];
    }, getClass: function () {
      return Dt;
    } }), e(At.prototype, { edit: function (t, e) {
      var n = this.editCoordinates(t.getCoordinates(), t);return null === n ? t : t instanceof bt ? e.createLinearRing(n) : t instanceof St ? e.createLineString(n) : t instanceof Lt ? n.length > 0 ? e.createPoint(n[0]) : e.createPoint() : t;
    }, interfaces_: function () {
      return [Mt];
    }, getClass: function () {
      return At;
    } }), e(Ft.prototype, { edit: function (t, e) {
      return t instanceof bt ? e.createLinearRing(this.edit(t.getCoordinateSequence(), t)) : t instanceof St ? e.createLineString(this.edit(t.getCoordinateSequence(), t)) : t instanceof Lt ? e.createPoint(this.edit(t.getCoordinateSequence(), t)) : t;
    }, interfaces_: function () {
      return [Mt];
    }, getClass: function () {
      return Ft;
    } }), _t.NoOpGeometryOperation = Dt, _t.CoordinateOperation = At, _t.CoordinateSequenceOperation = Ft, e(Gt.prototype, { setOrdinate: function (t, e, n) {
      switch (e) {case D.X:
          this.coordinates[t].x = n;break;case D.Y:
          this.coordinates[t].y = n;break;case D.Z:
          this.coordinates[t].z = n;break;default:
          throw new i("invalid ordinateIndex");}
    }, size: function () {
      return this.coordinates.length;
    }, getOrdinate: function (t, e) {
      switch (e) {case D.X:
          return this.coordinates[t].x;case D.Y:
          return this.coordinates[t].y;case D.Z:
          return this.coordinates[t].z;}return r.NaN;
    }, getCoordinate: function () {
      if (1 === arguments.length) {
        var t = arguments[0];return this.coordinates[t];
      }if (2 === arguments.length) {
        var e = arguments[0],
            n = arguments[1];n.x = this.coordinates[e].x, n.y = this.coordinates[e].y, n.z = this.coordinates[e].z;
      }
    }, getCoordinateCopy: function (t) {
      return new g(this.coordinates[t]);
    }, getDimension: function () {
      return this.dimension;
    }, getX: function (t) {
      return this.coordinates[t].x;
    }, clone: function () {
      for (var t = new Array(this.size()).fill(null), e = 0; e < this.coordinates.length; e++) t[e] = this.coordinates[e].clone();return new Gt(t, this.dimension);
    }, expandEnvelope: function (t) {
      for (var e = 0; e < this.coordinates.length; e++) t.expandToInclude(this.coordinates[e]);return t;
    }, copy: function () {
      for (var t = new Array(this.size()).fill(null), e = 0; e < this.coordinates.length; e++) t[e] = this.coordinates[e].copy();return new Gt(t, this.dimension);
    }, toString: function () {
      if (this.coordinates.length > 0) {
        var t = new P(17 * this.coordinates.length);t.append("("), t.append(this.coordinates[0]);for (var e = 1; e < this.coordinates.length; e++) t.append(", "), t.append(this.coordinates[e]);return t.append(")"), t.toString();
      }return "()";
    }, getY: function (t) {
      return this.coordinates[t].y;
    }, toCoordinateArray: function () {
      return this.coordinates;
    }, interfaces_: function () {
      return [D, u];
    }, getClass: function () {
      return Gt;
    } }), Gt.serialVersionUID = -0xcb44a778db18e00, e(qt.prototype, { readResolve: function () {
      return qt.instance();
    }, create: function () {
      if (1 === arguments.length) {
        if (arguments[0] instanceof Array) {
          var t = arguments[0];return new Gt(t);
        }if (R(arguments[0], D)) {
          var e = arguments[0];return new Gt(e);
        }
      } else if (2 === arguments.length) {
        var n = arguments[0],
            i = arguments[1];return i > 3 && (i = 3), i < 2 ? new Gt(n) : new Gt(n, i);
      }
    }, interfaces_: function () {
      return [G, u];
    }, getClass: function () {
      return qt;
    } }), qt.instance = function () {
    return qt.instanceObject;
  }, qt.serialVersionUID = -0x38e49fa6cf6f2e00, qt.instanceObject = new qt();var no,
      io = Object.defineProperty,
      ro = zt({ delete: kt, has: Xt, get: Yt, set: Ht, keys: jt, values: Kt, entries: Zt, forEach: $t, clear: Wt }),
      so = "undefined" != typeof Map && Map.prototype.values ? Map : ro;te.prototype = new K(), te.prototype.get = function (t) {
    return this.map_.get(t) || null;
  }, te.prototype.put = function (t, e) {
    return this.map_.set(t, e), e;
  }, te.prototype.values = function () {
    for (var t = new I(), e = this.map_.values(), n = e.next(); !n.done;) t.add(n.value), n = e.next();return t;
  }, te.prototype.entrySet = function () {
    var t = new J();return this.map_.entries().forEach(function (e) {
      return t.add(e);
    }), t;
  }, te.prototype.size = function () {
    return this.map_.size();
  }, e(ee.prototype, { equals: function (t) {
      if (!(t instanceof ee)) return !1;var e = t;return this.modelType === e.modelType && this.scale === e.scale;
    }, compareTo: function (t) {
      var e = t,
          n = this.getMaximumSignificantDigits(),
          i = e.getMaximumSignificantDigits();return new b(n).compareTo(new b(i));
    }, getScale: function () {
      return this.scale;
    }, isFloating: function () {
      return this.modelType === ee.FLOATING || this.modelType === ee.FLOATING_SINGLE;
    }, getType: function () {
      return this.modelType;
    }, toString: function () {
      var t = "UNKNOWN";return this.modelType === ee.FLOATING ? t = "Floating" : this.modelType === ee.FLOATING_SINGLE ? t = "Floating-Single" : this.modelType === ee.FIXED && (t = "Fixed (Scale=" + this.getScale() + ")"), t;
    }, makePrecise: function () {
      if ("number" == typeof arguments[0]) {
        var t = arguments[0];if (r.isNaN(t)) return t;if (this.modelType === ee.FLOATING_SINGLE) {
          var e = t;return e;
        }return this.modelType === ee.FIXED ? Math.round(t * this.scale) / this.scale : t;
      }if (arguments[0] instanceof g) {
        var n = arguments[0];if (this.modelType === ee.FLOATING) return null;n.x = this.makePrecise(n.x), n.y = this.makePrecise(n.y);
      }
    }, getMaximumSignificantDigits: function () {
      var t = 16;return this.modelType === ee.FLOATING ? t = 16 : this.modelType === ee.FLOATING_SINGLE ? t = 6 : this.modelType === ee.FIXED && (t = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))), t;
    }, setScale: function (t) {
      this.scale = Math.abs(t);
    }, interfaces_: function () {
      return [u, s];
    }, getClass: function () {
      return ee;
    } }), ee.mostPrecise = function (t, e) {
    return t.compareTo(e) >= 0 ? t : e;
  }, e(ne.prototype, { readResolve: function () {
      return ne.nameToTypeMap.get(this.name);
    }, toString: function () {
      return this.name;
    }, interfaces_: function () {
      return [u];
    }, getClass: function () {
      return ne;
    } }), ne.serialVersionUID = -552860263173159e4, ne.nameToTypeMap = new te(), ee.Type = ne, ee.serialVersionUID = 0x6bee6404e9a25c00, ee.FIXED = new ne("FIXED"), ee.FLOATING = new ne("FLOATING"), ee.FLOATING_SINGLE = new ne("FLOATING SINGLE"), ee.maximumPreciseValue = 9007199254740992, e(ie.prototype, { toGeometry: function (t) {
      return t.isNull() ? this.createPoint(null) : t.getMinX() === t.getMaxX() && t.getMinY() === t.getMaxY() ? this.createPoint(new g(t.getMinX(), t.getMinY())) : t.getMinX() === t.getMaxX() || t.getMinY() === t.getMaxY() ? this.createLineString([new g(t.getMinX(), t.getMinY()), new g(t.getMaxX(), t.getMaxY())]) : this.createPolygon(this.createLinearRing([new g(t.getMinX(), t.getMinY()), new g(t.getMinX(), t.getMaxY()), new g(t.getMaxX(), t.getMaxY()), new g(t.getMaxX(), t.getMinY()), new g(t.getMinX(), t.getMinY())]), null);
    }, createLineString: function () {
      if (0 === arguments.length) return this.createLineString(this.getCoordinateSequenceFactory().create([]));if (1 === arguments.length) {
        if (arguments[0] instanceof Array) {
          var t = arguments[0];return this.createLineString(null !== t ? this.getCoordinateSequenceFactory().create(t) : null);
        }if (R(arguments[0], D)) {
          var e = arguments[0];return new St(e, this);
        }
      }
    }, createMultiLineString: function () {
      if (0 === arguments.length) return new gt(null, this);if (1 === arguments.length) {
        var t = arguments[0];return new gt(t, this);
      }
    }, buildGeometry: function (t) {
      for (var e = null, n = !1, i = !1, r = t.iterator(); r.hasNext();) {
        var s = r.next(),
            o = s.getClass();null === e && (e = o), o !== e && (n = !0), s.isGeometryCollectionOrDerived() && (i = !0);
      }if (null === e) return this.createGeometryCollection();if (n || i) return this.createGeometryCollection(ie.toGeometryArray(t));var a = t.iterator().next(),
          u = t.size() > 1;if (u) {
        if (a instanceof Tt) return this.createMultiPolygon(ie.toPolygonArray(t));if (a instanceof St) return this.createMultiLineString(ie.toLineStringArray(t));if (a instanceof Lt) return this.createMultiPoint(ie.toPointArray(t));f.shouldNeverReachHere("Unhandled class: " + a.getClass().getName());
      }return a;
    }, createMultiPointFromCoords: function (t) {
      return this.createMultiPoint(null !== t ? this.getCoordinateSequenceFactory().create(t) : null);
    }, createPoint: function () {
      if (0 === arguments.length) return this.createPoint(this.getCoordinateSequenceFactory().create([]));if (1 === arguments.length) {
        if (arguments[0] instanceof g) {
          var t = arguments[0];return this.createPoint(null !== t ? this.getCoordinateSequenceFactory().create([t]) : null);
        }if (R(arguments[0], D)) {
          var e = arguments[0];return new Lt(e, this);
        }
      }
    }, getCoordinateSequenceFactory: function () {
      return this.coordinateSequenceFactory;
    }, createPolygon: function () {
      if (0 === arguments.length) return new Tt(null, null, this);if (1 === arguments.length) {
        if (R(arguments[0], D)) {
          var t = arguments[0];return this.createPolygon(this.createLinearRing(t));
        }if (arguments[0] instanceof Array) {
          var e = arguments[0];return this.createPolygon(this.createLinearRing(e));
        }if (arguments[0] instanceof bt) {
          var n = arguments[0];return this.createPolygon(n, null);
        }
      } else if (2 === arguments.length) {
        var i = arguments[0],
            r = arguments[1];return new Tt(i, r, this);
      }
    }, getSRID: function () {
      return this.SRID;
    }, createGeometryCollection: function () {
      if (0 === arguments.length) return new ft(null, this);if (1 === arguments.length) {
        var t = arguments[0];return new ft(t, this);
      }
    }, createGeometry: function (t) {
      var e = new _t(this);return e.edit(t, { edit: function () {
          if (2 === arguments.length) {
            var t = arguments[0];arguments[1];return this.coordinateSequenceFactory.create(t);
          }
        } });
    }, getPrecisionModel: function () {
      return this.precisionModel;
    }, createLinearRing: function () {
      if (0 === arguments.length) return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));if (1 === arguments.length) {
        if (arguments[0] instanceof Array) {
          var t = arguments[0];return this.createLinearRing(null !== t ? this.getCoordinateSequenceFactory().create(t) : null);
        }if (R(arguments[0], D)) {
          var e = arguments[0];return new bt(e, this);
        }
      }
    }, createMultiPolygon: function () {
      if (0 === arguments.length) return new Ot(null, this);if (1 === arguments.length) {
        var t = arguments[0];return new Ot(t, this);
      }
    }, createMultiPoint: function () {
      if (0 === arguments.length) return new Pt(null, this);if (1 === arguments.length) {
        if (arguments[0] instanceof Array) {
          var t = arguments[0];return new Pt(t, this);
        }if (arguments[0] instanceof Array) {
          var e = arguments[0];return this.createMultiPoint(null !== e ? this.getCoordinateSequenceFactory().create(e) : null);
        }if (R(arguments[0], D)) {
          var n = arguments[0];if (null === n) return this.createMultiPoint(new Array(0).fill(null));for (var i = new Array(n.size()).fill(null), r = 0; r < n.size(); r++) {
            var s = this.getCoordinateSequenceFactory().create(1, n.getDimension());Ct.copy(n, r, s, 0, 1), i[r] = this.createPoint(s);
          }return this.createMultiPoint(i);
        }
      }
    }, interfaces_: function () {
      return [u];
    }, getClass: function () {
      return ie;
    } }), ie.toMultiPolygonArray = function (t) {
    var e = new Array(t.size()).fill(null);return t.toArray(e);
  }, ie.toGeometryArray = function (t) {
    if (null === t) return null;var e = new Array(t.size()).fill(null);return t.toArray(e);
  }, ie.getDefaultCoordinateSequenceFactory = function () {
    return qt.instance();
  }, ie.toMultiLineStringArray = function (t) {
    var e = new Array(t.size()).fill(null);return t.toArray(e);
  }, ie.toLineStringArray = function (t) {
    var e = new Array(t.size()).fill(null);return t.toArray(e);
  }, ie.toMultiPointArray = function (t) {
    var e = new Array(t.size()).fill(null);return t.toArray(e);
  }, ie.toLinearRingArray = function (t) {
    var e = new Array(t.size()).fill(null);return t.toArray(e);
  }, ie.toPointArray = function (t) {
    var e = new Array(t.size()).fill(null);return t.toArray(e);
  }, ie.toPolygonArray = function (t) {
    var e = new Array(t.size()).fill(null);return t.toArray(e);
  }, ie.createPointFromInternalCoord = function (t, e) {
    return e.getPrecisionModel().makePrecise(t), e.getFactory().createPoint(t);
  }, ie.serialVersionUID = -0x5ea75f2051eeb400;var oo = { typeStr: /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/, emptyTypeStr: /^\s*(\w+)\s*EMPTY\s*$/, spaces: /\s+/, parenComma: /\)\s*,\s*\(/, doubleParenComma: /\)\s*\)\s*,\s*\(\s*\(/, trimParens: /^\s*\(?(.*?)\)?\s*$/ };e(re.prototype, { read: function (t) {
      var e, n, i;t = t.replace(/[\n\r]/g, " ");var r = oo.typeStr.exec(t);if (t.search("EMPTY") !== -1 && (r = oo.emptyTypeStr.exec(t), r[2] = void 0), r && (n = r[1].toLowerCase(), i = r[2], uo[n] && (e = uo[n].apply(this, [i]))), void 0 === e) throw new Error("Could not parse WKT " + t);return e;
    }, write: function (t) {
      return this.extractGeometry(t);
    }, extractGeometry: function (t) {
      var e = t.getGeometryType().toLowerCase();if (!ao[e]) return null;var n,
          i = e.toUpperCase();return n = t.isEmpty() ? i + " EMPTY" : i + "(" + ao[e].apply(this, [t]) + ")";
    } });var ao = { coordinate: function (t) {
      return t.x + " " + t.y;
    }, point: function (t) {
      return ao.coordinate.call(this, t.coordinates.coordinates[0]);
    }, multipoint: function (t) {
      for (var e = [], n = 0, i = t.geometries.length; n < i; ++n) e.push("(" + ao.point.apply(this, [t.geometries[n]]) + ")");return e.join(",");
    }, linestring: function (t) {
      for (var e = [], n = 0, i = t.points.coordinates.length; n < i; ++n) e.push(ao.coordinate.apply(this, [t.points.coordinates[n]]));return e.join(",");
    }, linearring: function (t) {
      for (var e = [], n = 0, i = t.points.coordinates.length; n < i; ++n) e.push(ao.coordinate.apply(this, [t.points.coordinates[n]]));return e.join(",");
    }, multilinestring: function (t) {
      for (var e = [], n = 0, i = t.geometries.length; n < i; ++n) e.push("(" + ao.linestring.apply(this, [t.geometries[n]]) + ")");return e.join(",");
    }, polygon: function (t) {
      var e = [];e.push("(" + ao.linestring.apply(this, [t.shell]) + ")");for (var n = 0, i = t.holes.length; n < i; ++n) e.push("(" + ao.linestring.apply(this, [t.holes[n]]) + ")");return e.join(",");
    }, multipolygon: function (t) {
      for (var e = [], n = 0, i = t.geometries.length; n < i; ++n) e.push("(" + ao.polygon.apply(this, [t.geometries[n]]) + ")");return e.join(",");
    }, geometrycollection: function (t) {
      for (var e = [], n = 0, i = t.geometries.length; n < i; ++n) e.push(this.extractGeometry(t.geometries[n]));return e.join(",");
    } },
      uo = { point: function (t) {
      if (void 0 === t) return this.geometryFactory.createPoint();var e = t.trim().split(oo.spaces);return this.geometryFactory.createPoint(new g(Number.parseFloat(e[0]), Number.parseFloat(e[1])));
    }, multipoint: function (t) {
      if (void 0 === t) return this.geometryFactory.createMultiPoint();for (var e, n = t.trim().split(","), i = [], r = 0, s = n.length; r < s; ++r) e = n[r].replace(oo.trimParens, "$1"), i.push(uo.point.apply(this, [e]));return this.geometryFactory.createMultiPoint(i);
    }, linestring: function (t) {
      if (void 0 === t) return this.geometryFactory.createLineString();for (var e, n = t.trim().split(","), i = [], r = 0, s = n.length; r < s; ++r) e = n[r].trim().split(oo.spaces), i.push(new g(Number.parseFloat(e[0]), Number.parseFloat(e[1])));return this.geometryFactory.createLineString(i);
    }, linearring: function (t) {
      if (void 0 === t) return this.geometryFactory.createLinearRing();for (var e, n = t.trim().split(","), i = [], r = 0, s = n.length; r < s; ++r) e = n[r].trim().split(oo.spaces), i.push(new g(Number.parseFloat(e[0]), Number.parseFloat(e[1])));return this.geometryFactory.createLinearRing(i);
    }, multilinestring: function (t) {
      if (void 0 === t) return this.geometryFactory.createMultiLineString();for (var e, n = t.trim().split(oo.parenComma), i = [], r = 0, s = n.length; r < s; ++r) e = n[r].replace(oo.trimParens, "$1"), i.push(uo.linestring.apply(this, [e]));return this.geometryFactory.createMultiLineString(i);
    }, polygon: function (t) {
      if (void 0 === t) return this.geometryFactory.createPolygon();for (var e, n, i, r, s = t.trim().split(oo.parenComma), o = [], a = 0, u = s.length; a < u; ++a) e = s[a].replace(oo.trimParens, "$1"), n = uo.linestring.apply(this, [e]), i = this.geometryFactory.createLinearRing(n.points), 0 === a ? r = i : o.push(i);return this.geometryFactory.createPolygon(r, o);
    }, multipolygon: function (t) {
      if (void 0 === t) return this.geometryFactory.createMultiPolygon();for (var e, n = t.trim().split(oo.doubleParenComma), i = [], r = 0, s = n.length; r < s; ++r) e = n[r].replace(oo.trimParens, "$1"), i.push(uo.polygon.apply(this, [e]));return this.geometryFactory.createMultiPolygon(i);
    }, geometrycollection: function (t) {
      if (void 0 === t) return this.geometryFactory.createGeometryCollection();t = t.replace(/,\s*([A-Za-z])/g, "|$1");for (var e = t.trim().split("|"), n = [], i = 0, r = e.length; i < r; ++i) n.push(this.read(e[i]));return this.geometryFactory.createGeometryCollection(n);
    } };e(se.prototype, { write: function (t) {
      return this.parser.write(t);
    } }), e(se, { toLineString: function (t, e) {
      if (2 !== arguments.length) throw new Error("Not implemented");return "LINESTRING ( " + t.x + " " + t.y + ", " + e.x + " " + e.y + " )";
    } }), e(oe.prototype, { getIndexAlongSegment: function (t, e) {
      return this.computeIntLineIndex(), this.intLineIndex[t][e];
    }, getTopologySummary: function () {
      var t = new P();return this.isEndPoint() && t.append(" endpoint"), this._isProper && t.append(" proper"), this.isCollinear() && t.append(" collinear"), t.toString();
    }, computeIntersection: function (t, e, n, i) {
      this.inputLines[0][0] = t, this.inputLines[0][1] = e, this.inputLines[1][0] = n, this.inputLines[1][1] = i, this.result = this.computeIntersect(t, e, n, i);
    }, getIntersectionNum: function () {
      return this.result;
    }, computeIntLineIndex: function () {
      if (0 === arguments.length) null === this.intLineIndex && (this.intLineIndex = Array(2).fill().map(function () {
        return Array(2);
      }), this.computeIntLineIndex(0), this.computeIntLineIndex(1));else if (1 === arguments.length) {
        var t = arguments[0],
            e = this.getEdgeDistance(t, 0),
            n = this.getEdgeDistance(t, 1);e > n ? (this.intLineIndex[t][0] = 0, this.intLineIndex[t][1] = 1) : (this.intLineIndex[t][0] = 1, this.intLineIndex[t][1] = 0);
      }
    }, isProper: function () {
      return this.hasIntersection() && this._isProper;
    }, setPrecisionModel: function (t) {
      this.precisionModel = t;
    }, isInteriorIntersection: function () {
      if (0 === arguments.length) return !!this.isInteriorIntersection(0) || !!this.isInteriorIntersection(1);if (1 === arguments.length) {
        for (var t = arguments[0], e = 0; e < this.result; e++) if (!this.intPt[e].equals2D(this.inputLines[t][0]) && !this.intPt[e].equals2D(this.inputLines[t][1])) return !0;return !1;
      }
    }, getIntersection: function (t) {
      return this.intPt[t];
    }, isEndPoint: function () {
      return this.hasIntersection() && !this._isProper;
    }, hasIntersection: function () {
      return this.result !== oe.NO_INTERSECTION;
    }, getEdgeDistance: function (t, e) {
      var n = oe.computeEdgeDistance(this.intPt[e], this.inputLines[t][0], this.inputLines[t][1]);return n;
    }, isCollinear: function () {
      return this.result === oe.COLLINEAR_INTERSECTION;
    }, toString: function () {
      return se.toLineString(this.inputLines[0][0], this.inputLines[0][1]) + " - " + se.toLineString(this.inputLines[1][0], this.inputLines[1][1]) + this.getTopologySummary();
    }, getEndpoint: function (t, e) {
      return this.inputLines[t][e];
    }, isIntersection: function (t) {
      for (var e = 0; e < this.result; e++) if (this.intPt[e].equals2D(t)) return !0;return !1;
    }, getIntersectionAlongSegment: function (t, e) {
      return this.computeIntLineIndex(), this.intPt[this.intLineIndex[t][e]];
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return oe;
    } }), oe.computeEdgeDistance = function (t, e, n) {
    var i = Math.abs(n.x - e.x),
        r = Math.abs(n.y - e.y),
        s = -1;if (t.equals(e)) s = 0;else if (t.equals(n)) s = i > r ? i : r;else {
      var o = Math.abs(t.x - e.x),
          a = Math.abs(t.y - e.y);s = i > r ? o : a, 0 !== s || t.equals(e) || (s = Math.max(o, a));
    }return f.isTrue(!(0 === s && !t.equals(e)), "Bad distance calculation"), s;
  }, oe.nonRobustComputeEdgeDistance = function (t, e, n) {
    var i = t.x - e.x,
        r = t.y - e.y,
        s = Math.sqrt(i * i + r * r);return f.isTrue(!(0 === s && !t.equals(e)), "Invalid distance calculation"), s;
  }, oe.DONT_INTERSECT = 0, oe.DO_INTERSECT = 1, oe.COLLINEAR = 2, oe.NO_INTERSECTION = 0, oe.POINT_INTERSECTION = 1, oe.COLLINEAR_INTERSECTION = 2, h(ae, oe), e(ae.prototype, { isInSegmentEnvelopes: function (t) {
      var e = new C(this.inputLines[0][0], this.inputLines[0][1]),
          n = new C(this.inputLines[1][0], this.inputLines[1][1]);return e.contains(t) && n.contains(t);
    }, computeIntersection: function () {
      if (3 !== arguments.length) return oe.prototype.computeIntersection.apply(this, arguments);var t = arguments[0],
          e = arguments[1],
          n = arguments[2];return this._isProper = !1, C.intersects(e, n, t) && 0 === he.orientationIndex(e, n, t) && 0 === he.orientationIndex(n, e, t) ? (this._isProper = !0, (t.equals(e) || t.equals(n)) && (this._isProper = !1), this.result = oe.POINT_INTERSECTION, null) : void (this.result = oe.NO_INTERSECTION);
    }, normalizeToMinimum: function (t, e, n, i, r) {
      r.x = this.smallestInAbsValue(t.x, e.x, n.x, i.x), r.y = this.smallestInAbsValue(t.y, e.y, n.y, i.y), t.x -= r.x, t.y -= r.y, e.x -= r.x, e.y -= r.y, n.x -= r.x, n.y -= r.y, i.x -= r.x, i.y -= r.y;
    }, safeHCoordinateIntersection: function (t, e, n, i) {
      var r = null;try {
        r = F.intersection(t, e, n, i);
      } catch (s) {
        if (!(s instanceof w)) throw s;r = ae.nearestEndpoint(t, e, n, i);
      } finally {}return r;
    }, intersection: function (t, e, n, i) {
      var r = this.intersectionWithNormalization(t, e, n, i);return this.isInSegmentEnvelopes(r) || (r = new g(ae.nearestEndpoint(t, e, n, i))), null !== this.precisionModel && this.precisionModel.makePrecise(r), r;
    }, smallestInAbsValue: function (t, e, n, i) {
      var r = t,
          s = Math.abs(r);return Math.abs(e) < s && (r = e, s = Math.abs(e)), Math.abs(n) < s && (r = n, s = Math.abs(n)), Math.abs(i) < s && (r = i), r;
    }, checkDD: function (t, e, n, i, r) {
      var s = M.intersection(t, e, n, i),
          o = this.isInSegmentEnvelopes(s);A.out.println("DD in env = " + o + "  --------------------- " + s), r.distance(s) > 1e-4 && A.out.println("Distance = " + r.distance(s));
    }, intersectionWithNormalization: function (t, e, n, i) {
      var r = new g(t),
          s = new g(e),
          o = new g(n),
          a = new g(i),
          u = new g();this.normalizeToEnvCentre(r, s, o, a, u);var l = this.safeHCoordinateIntersection(r, s, o, a);return l.x += u.x, l.y += u.y, l;
    }, computeCollinearIntersection: function (t, e, n, i) {
      var r = C.intersects(t, e, n),
          s = C.intersects(t, e, i),
          o = C.intersects(n, i, t),
          a = C.intersects(n, i, e);return r && s ? (this.intPt[0] = n, this.intPt[1] = i, oe.COLLINEAR_INTERSECTION) : o && a ? (this.intPt[0] = t, this.intPt[1] = e, oe.COLLINEAR_INTERSECTION) : r && o ? (this.intPt[0] = n, this.intPt[1] = t, !n.equals(t) || s || a ? oe.COLLINEAR_INTERSECTION : oe.POINT_INTERSECTION) : r && a ? (this.intPt[0] = n, this.intPt[1] = e, !n.equals(e) || s || o ? oe.COLLINEAR_INTERSECTION : oe.POINT_INTERSECTION) : s && o ? (this.intPt[0] = i, this.intPt[1] = t, !i.equals(t) || r || a ? oe.COLLINEAR_INTERSECTION : oe.POINT_INTERSECTION) : s && a ? (this.intPt[0] = i, this.intPt[1] = e, !i.equals(e) || r || o ? oe.COLLINEAR_INTERSECTION : oe.POINT_INTERSECTION) : oe.NO_INTERSECTION;
    }, normalizeToEnvCentre: function (t, e, n, i, r) {
      var s = t.x < e.x ? t.x : e.x,
          o = t.y < e.y ? t.y : e.y,
          a = t.x > e.x ? t.x : e.x,
          u = t.y > e.y ? t.y : e.y,
          l = n.x < i.x ? n.x : i.x,
          h = n.y < i.y ? n.y : i.y,
          c = n.x > i.x ? n.x : i.x,
          f = n.y > i.y ? n.y : i.y,
          g = s > l ? s : l,
          d = a < c ? a : c,
          p = o > h ? o : h,
          v = u < f ? u : f,
          m = (g + d) / 2,
          y = (p + v) / 2;r.x = m, r.y = y, t.x -= r.x, t.y -= r.y, e.x -= r.x, e.y -= r.y, n.x -= r.x, n.y -= r.y, i.x -= r.x, i.y -= r.y;
    }, computeIntersect: function (t, e, n, i) {
      if (this._isProper = !1, !C.intersects(t, e, n, i)) return oe.NO_INTERSECTION;var r = he.orientationIndex(t, e, n),
          s = he.orientationIndex(t, e, i);if (r > 0 && s > 0 || r < 0 && s < 0) return oe.NO_INTERSECTION;var o = he.orientationIndex(n, i, t),
          a = he.orientationIndex(n, i, e);if (o > 0 && a > 0 || o < 0 && a < 0) return oe.NO_INTERSECTION;var u = 0 === r && 0 === s && 0 === o && 0 === a;return u ? this.computeCollinearIntersection(t, e, n, i) : (0 === r || 0 === s || 0 === o || 0 === a ? (this._isProper = !1, t.equals2D(n) || t.equals2D(i) ? this.intPt[0] = t : e.equals2D(n) || e.equals2D(i) ? this.intPt[0] = e : 0 === r ? this.intPt[0] = new g(n) : 0 === s ? this.intPt[0] = new g(i) : 0 === o ? this.intPt[0] = new g(t) : 0 === a && (this.intPt[0] = new g(e))) : (this._isProper = !0, this.intPt[0] = this.intersection(t, e, n, i)), oe.POINT_INTERSECTION);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return ae;
    } }), ae.nearestEndpoint = function (t, e, n, i) {
    var r = t,
        s = he.distancePointLine(t, n, i),
        o = he.distancePointLine(e, n, i);return o < s && (s = o, r = e), o = he.distancePointLine(n, t, e), o < s && (s = o, r = n), o = he.distancePointLine(i, t, e), o < s && (s = o, r = i), r;
  }, e(ue.prototype, { interfaces_: function () {
      return [];
    }, getClass: function () {
      return ue;
    } }), ue.orientationIndex = function (t, e, n) {
    var i = e.x - t.x,
        r = e.y - t.y,
        s = n.x - e.x,
        o = n.y - e.y;return ue.signOfDet2x2(i, r, s, o);
  }, ue.signOfDet2x2 = function (t, e, n, i) {
    var r = null,
        s = null,
        o = null,
        a = 0;if (r = 1, 0 === t || 0 === i) return 0 === e || 0 === n ? 0 : e > 0 ? n > 0 ? -r : r : n > 0 ? r : -r;if (0 === e || 0 === n) return i > 0 ? t > 0 ? r : -r : t > 0 ? -r : r;if (0 < e ? 0 < i ? e <= i || (r = -r, s = t, t = n, n = s, s = e, e = i, i = s) : e <= -i ? (r = -r, n = -n, i = -i) : (s = t, t = -n, n = s, s = e, e = -i, i = s) : 0 < i ? -e <= i ? (r = -r, t = -t, e = -e) : (s = -t, t = n, n = s, s = -e, e = i, i = s) : e >= i ? (t = -t, e = -e, n = -n, i = -i) : (r = -r, s = -t, t = -n, n = s, s = -e, e = -i, i = s), 0 < t) {
      if (!(0 < n)) return r;if (!(t <= n)) return r;
    } else {
      if (0 < n) return -r;if (!(t >= n)) return -r;r = -r, t = -t, n = -n;
    }for (;;) {
      if (a += 1, o = Math.floor(n / t), n -= o * t, i -= o * e, i < 0) return -r;if (i > e) return r;if (t > n + n) {
        if (e < i + i) return r;
      } else {
        if (e > i + i) return -r;n = t - n, i = e - i, r = -r;
      }if (0 === i) return 0 === n ? 0 : -r;if (0 === n) return r;if (o = Math.floor(t / n), t -= o * n, e -= o * i, e < 0) return r;if (e > i) return -r;if (n > t + t) {
        if (i < e + e) return -r;
      } else {
        if (i > e + e) return r;t = n - t, e = i - e, r = -r;
      }if (0 === e) return 0 === t ? 0 : r;if (0 === t) return -r;
    }
  }, e(le.prototype, { countSegment: function (t, e) {
      if (t.x < this.p.x && e.x < this.p.x) return null;if (this.p.x === e.x && this.p.y === e.y) return this.isPointOnSegment = !0, null;if (t.y === this.p.y && e.y === this.p.y) {
        var n = t.x,
            i = e.x;return n > i && (n = e.x, i = t.x), this.p.x >= n && this.p.x <= i && (this.isPointOnSegment = !0), null;
      }if (t.y > this.p.y && e.y <= this.p.y || e.y > this.p.y && t.y <= this.p.y) {
        var r = t.x - this.p.x,
            s = t.y - this.p.y,
            o = e.x - this.p.x,
            a = e.y - this.p.y,
            u = ue.signOfDet2x2(r, s, o, a);if (0 === u) return this.isPointOnSegment = !0, null;a < s && (u = -u), u > 0 && this.crossingCount++;
      }
    }, isPointInPolygon: function () {
      return this.getLocation() !== L.EXTERIOR;
    }, getLocation: function () {
      return this.isPointOnSegment ? L.BOUNDARY : this.crossingCount % 2 === 1 ? L.INTERIOR : L.EXTERIOR;
    }, isOnSegment: function () {
      return this.isPointOnSegment;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return le;
    } }), le.locatePointInRing = function () {
    if (arguments[0] instanceof g && R(arguments[1], D)) {
      for (var t = arguments[0], e = arguments[1], n = new le(t), i = new g(), r = new g(), s = 1; s < e.size(); s++) if (e.getCoordinate(s, i), e.getCoordinate(s - 1, r), n.countSegment(i, r), n.isOnSegment()) return n.getLocation();return n.getLocation();
    }if (arguments[0] instanceof g && arguments[1] instanceof Array) {
      for (var o = arguments[0], a = arguments[1], n = new le(o), s = 1; s < a.length; s++) {
        var i = a[s],
            r = a[s - 1];if (n.countSegment(i, r), n.isOnSegment()) return n.getLocation();
      }return n.getLocation();
    }
  }, e(he.prototype, { interfaces_: function () {
      return [];
    }, getClass: function () {
      return he;
    } }), he.orientationIndex = function (t, e, n) {
    return M.orientationIndex(t, e, n);
  }, he.signedArea = function () {
    if (arguments[0] instanceof Array) {
      var t = arguments[0];if (t.length < 3) return 0;for (var e = 0, n = t[0].x, i = 1; i < t.length - 1; i++) {
        var r = t[i].x - n,
            s = t[i + 1].y,
            o = t[i - 1].y;e += r * (o - s);
      }return e / 2;
    }if (R(arguments[0], D)) {
      var a = arguments[0],
          u = a.size();if (u < 3) return 0;var l = new g(),
          h = new g(),
          c = new g();a.getCoordinate(0, h), a.getCoordinate(1, c);var n = h.x;c.x -= n;for (var e = 0, i = 1; i < u - 1; i++) l.y = h.y, h.x = c.x, h.y = c.y, a.getCoordinate(i + 1, c), c.x -= n, e += h.x * (l.y - c.y);return e / 2;
    }
  }, he.distanceLineLine = function (t, e, n, i) {
    if (t.equals(e)) return he.distancePointLine(t, n, i);if (n.equals(i)) return he.distancePointLine(i, t, e);var r = !1;if (C.intersects(t, e, n, i)) {
      var s = (e.x - t.x) * (i.y - n.y) - (e.y - t.y) * (i.x - n.x);if (0 === s) r = !0;else {
        var o = (t.y - n.y) * (i.x - n.x) - (t.x - n.x) * (i.y - n.y),
            a = (t.y - n.y) * (e.x - t.x) - (t.x - n.x) * (e.y - t.y),
            u = a / s,
            l = o / s;(l < 0 || l > 1 || u < 0 || u > 1) && (r = !0);
      }
    } else r = !0;return r ? T.min(he.distancePointLine(t, n, i), he.distancePointLine(e, n, i), he.distancePointLine(n, t, e), he.distancePointLine(i, t, e)) : 0;
  }, he.isPointInRing = function (t, e) {
    return he.locatePointInRing(t, e) !== L.EXTERIOR;
  }, he.computeLength = function (t) {
    var e = t.size();if (e <= 1) return 0;var n = 0,
        i = new g();t.getCoordinate(0, i);for (var r = i.x, s = i.y, o = 1; o < e; o++) {
      t.getCoordinate(o, i);var a = i.x,
          u = i.y,
          l = a - r,
          h = u - s;n += Math.sqrt(l * l + h * h), r = a, s = u;
    }return n;
  }, he.isCCW = function (t) {
    var e = t.length - 1;if (e < 3) throw new i("Ring has fewer than 4 points, so orientation cannot be determined");for (var n = t[0], r = 0, s = 1; s <= e; s++) {
      var o = t[s];o.y > n.y && (n = o, r = s);
    }var a = r;do a -= 1, a < 0 && (a = e); while (t[a].equals2D(n) && a !== r);var u = r;do u = (u + 1) % e; while (t[u].equals2D(n) && u !== r);var l = t[a],
        h = t[u];if (l.equals2D(n) || h.equals2D(n) || l.equals2D(h)) return !1;var c = he.computeOrientation(l, n, h),
        f = !1;return f = 0 === c ? l.x > h.x : c > 0;
  }, he.locatePointInRing = function (t, e) {
    return le.locatePointInRing(t, e);
  }, he.distancePointLinePerpendicular = function (t, e, n) {
    var i = (n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y),
        r = ((e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)) / i;return Math.abs(r) * Math.sqrt(i);
  }, he.computeOrientation = function (t, e, n) {
    return he.orientationIndex(t, e, n);
  }, he.distancePointLine = function () {
    if (2 === arguments.length) {
      var t = arguments[0],
          e = arguments[1];if (0 === e.length) throw new i("Line array must contain at least one vertex");for (var n = t.distance(e[0]), r = 0; r < e.length - 1; r++) {
        var s = he.distancePointLine(t, e[r], e[r + 1]);s < n && (n = s);
      }return n;
    }if (3 === arguments.length) {
      var o = arguments[0],
          a = arguments[1],
          u = arguments[2];if (a.x === u.x && a.y === u.y) return o.distance(a);var l = (u.x - a.x) * (u.x - a.x) + (u.y - a.y) * (u.y - a.y),
          h = ((o.x - a.x) * (u.x - a.x) + (o.y - a.y) * (u.y - a.y)) / l;if (h <= 0) return o.distance(a);if (h >= 1) return o.distance(u);var c = ((a.y - o.y) * (u.x - a.x) - (a.x - o.x) * (u.y - a.y)) / l;return Math.abs(c) * Math.sqrt(l);
    }
  }, he.isOnLine = function (t, e) {
    for (var n = new ae(), i = 1; i < e.length; i++) {
      var r = e[i - 1],
          s = e[i];if (n.computeIntersection(t, r, s), n.hasIntersection()) return !0;
    }return !1;
  }, he.CLOCKWISE = -1, he.RIGHT = he.CLOCKWISE, he.COUNTERCLOCKWISE = 1, he.LEFT = he.COUNTERCLOCKWISE, he.COLLINEAR = 0, he.STRAIGHT = he.COLLINEAR, e(ce.prototype, { minX: function () {
      return Math.min(this.p0.x, this.p1.x);
    }, orientationIndex: function () {
      if (arguments[0] instanceof ce) {
        var t = arguments[0],
            e = he.orientationIndex(this.p0, this.p1, t.p0),
            n = he.orientationIndex(this.p0, this.p1, t.p1);return e >= 0 && n >= 0 ? Math.max(e, n) : e <= 0 && n <= 0 ? Math.max(e, n) : 0;
      }if (arguments[0] instanceof g) {
        var i = arguments[0];return he.orientationIndex(this.p0, this.p1, i);
      }
    }, toGeometry: function (t) {
      return t.createLineString([this.p0, this.p1]);
    }, isVertical: function () {
      return this.p0.x === this.p1.x;
    }, equals: function (t) {
      if (!(t instanceof ce)) return !1;var e = t;return this.p0.equals(e.p0) && this.p1.equals(e.p1);
    }, intersection: function (t) {
      var e = new ae();return e.computeIntersection(this.p0, this.p1, t.p0, t.p1), e.hasIntersection() ? e.getIntersection(0) : null;
    }, project: function () {
      if (arguments[0] instanceof g) {
        var t = arguments[0];if (t.equals(this.p0) || t.equals(this.p1)) return new g(t);var e = this.projectionFactor(t),
            n = new g();return n.x = this.p0.x + e * (this.p1.x - this.p0.x), n.y = this.p0.y + e * (this.p1.y - this.p0.y), n;
      }if (arguments[0] instanceof ce) {
        var i = arguments[0],
            r = this.projectionFactor(i.p0),
            s = this.projectionFactor(i.p1);if (r >= 1 && s >= 1) return null;if (r <= 0 && s <= 0) return null;var o = this.project(i.p0);r < 0 && (o = this.p0), r > 1 && (o = this.p1);var a = this.project(i.p1);return s < 0 && (a = this.p0), s > 1 && (a = this.p1), new ce(o, a);
      }
    }, normalize: function () {
      this.p1.compareTo(this.p0) < 0 && this.reverse();
    }, angle: function () {
      return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);
    }, getCoordinate: function (t) {
      return 0 === t ? this.p0 : this.p1;
    }, distancePerpendicular: function (t) {
      return he.distancePointLinePerpendicular(t, this.p0, this.p1);
    }, minY: function () {
      return Math.min(this.p0.y, this.p1.y);
    }, midPoint: function () {
      return ce.midPoint(this.p0, this.p1);
    }, projectionFactor: function (t) {
      if (t.equals(this.p0)) return 0;if (t.equals(this.p1)) return 1;var e = this.p1.x - this.p0.x,
          n = this.p1.y - this.p0.y,
          i = e * e + n * n;if (i <= 0) return r.NaN;var s = ((t.x - this.p0.x) * e + (t.y - this.p0.y) * n) / i;return s;
    }, closestPoints: function (t) {
      var e = this.intersection(t);if (null !== e) return [e, e];var n = new Array(2).fill(null),
          i = r.MAX_VALUE,
          s = null,
          o = this.closestPoint(t.p0);i = o.distance(t.p0), n[0] = o, n[1] = t.p0;var a = this.closestPoint(t.p1);s = a.distance(t.p1), s < i && (i = s, n[0] = a, n[1] = t.p1);var u = t.closestPoint(this.p0);s = u.distance(this.p0), s < i && (i = s, n[0] = this.p0, n[1] = u);var l = t.closestPoint(this.p1);return s = l.distance(this.p1), s < i && (i = s, n[0] = this.p1, n[1] = l), n;
    }, closestPoint: function (t) {
      var e = this.projectionFactor(t);if (e > 0 && e < 1) return this.project(t);var n = this.p0.distance(t),
          i = this.p1.distance(t);return n < i ? this.p0 : this.p1;
    }, maxX: function () {
      return Math.max(this.p0.x, this.p1.x);
    }, getLength: function () {
      return this.p0.distance(this.p1);
    }, compareTo: function (t) {
      var e = t,
          n = this.p0.compareTo(e.p0);return 0 !== n ? n : this.p1.compareTo(e.p1);
    }, reverse: function () {
      var t = this.p0;this.p0 = this.p1, this.p1 = t;
    }, equalsTopo: function (t) {
      return this.p0.equals(t.p0) && this.p1.equals(t.p1) || this.p0.equals(t.p1) && this.p1.equals(t.p0);
    }, lineIntersection: function (t) {
      try {
        var e = F.intersection(this.p0, this.p1, t.p0, t.p1);return e;
      } catch (t) {
        if (!(t instanceof w)) throw t;
      } finally {}return null;
    }, maxY: function () {
      return Math.max(this.p0.y, this.p1.y);
    }, pointAlongOffset: function (t, e) {
      var n = this.p0.x + t * (this.p1.x - this.p0.x),
          i = this.p0.y + t * (this.p1.y - this.p0.y),
          r = this.p1.x - this.p0.x,
          s = this.p1.y - this.p0.y,
          o = Math.sqrt(r * r + s * s),
          a = 0,
          u = 0;if (0 !== e) {
        if (o <= 0) throw new IllegalStateException("Cannot compute offset from zero-length line segment");a = e * r / o, u = e * s / o;
      }var l = n - u,
          h = i + a,
          c = new g(l, h);return c;
    }, setCoordinates: function () {
      if (1 === arguments.length) {
        var t = arguments[0];this.setCoordinates(t.p0, t.p1);
      } else if (2 === arguments.length) {
        var e = arguments[0],
            n = arguments[1];this.p0.x = e.x, this.p0.y = e.y, this.p1.x = n.x, this.p1.y = n.y;
      }
    }, segmentFraction: function (t) {
      var e = this.projectionFactor(t);return e < 0 ? e = 0 : (e > 1 || r.isNaN(e)) && (e = 1), e;
    }, toString: function () {
      return "LINESTRING( " + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")";
    }, isHorizontal: function () {
      return this.p0.y === this.p1.y;
    }, distance: function () {
      if (arguments[0] instanceof ce) {
        var t = arguments[0];return he.distanceLineLine(this.p0, this.p1, t.p0, t.p1);
      }if (arguments[0] instanceof g) {
        var e = arguments[0];return he.distancePointLine(e, this.p0, this.p1);
      }
    }, pointAlong: function (t) {
      var e = new g();return e.x = this.p0.x + t * (this.p1.x - this.p0.x), e.y = this.p0.y + t * (this.p1.y - this.p0.y), e;
    }, hashCode: function () {
      var t = java.lang.Double.doubleToLongBits(this.p0.x);t ^= 31 * java.lang.Double.doubleToLongBits(this.p0.y);var e = Math.trunc(t) ^ Math.trunc(t >> 32),
          n = java.lang.Double.doubleToLongBits(this.p1.x);n ^= 31 * java.lang.Double.doubleToLongBits(this.p1.y);var i = Math.trunc(n) ^ Math.trunc(n >> 32);return e ^ i;
    }, interfaces_: function () {
      return [s, u];
    }, getClass: function () {
      return ce;
    } }), ce.midPoint = function (t, e) {
    return new g((t.x + e.x) / 2, (t.y + e.y) / 2);
  }, ce.serialVersionUID = 0x2d2172135f411c00, e(fe.prototype, { isIntersects: function () {
      return !this.isDisjoint();
    }, isCovers: function () {
      var t = fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR]) || fe.isTrue(this.matrix[L.INTERIOR][L.BOUNDARY]) || fe.isTrue(this.matrix[L.BOUNDARY][L.INTERIOR]) || fe.isTrue(this.matrix[L.BOUNDARY][L.BOUNDARY]);return t && this.matrix[L.EXTERIOR][L.INTERIOR] === lt.FALSE && this.matrix[L.EXTERIOR][L.BOUNDARY] === lt.FALSE;
    }, isCoveredBy: function () {
      var t = fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR]) || fe.isTrue(this.matrix[L.INTERIOR][L.BOUNDARY]) || fe.isTrue(this.matrix[L.BOUNDARY][L.INTERIOR]) || fe.isTrue(this.matrix[L.BOUNDARY][L.BOUNDARY]);return t && this.matrix[L.INTERIOR][L.EXTERIOR] === lt.FALSE && this.matrix[L.BOUNDARY][L.EXTERIOR] === lt.FALSE;
    }, set: function () {
      if (1 === arguments.length) for (var t = arguments[0], e = 0; e < t.length; e++) {
        var n = Math.trunc(e / 3),
            i = e % 3;this.matrix[n][i] = lt.toDimensionValue(t.charAt(e));
      } else if (3 === arguments.length) {
        var r = arguments[0],
            s = arguments[1],
            o = arguments[2];this.matrix[r][s] = o;
      }
    }, isContains: function () {
      return fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR]) && this.matrix[L.EXTERIOR][L.INTERIOR] === lt.FALSE && this.matrix[L.EXTERIOR][L.BOUNDARY] === lt.FALSE;
    }, setAtLeast: function () {
      if (1 === arguments.length) for (var t = arguments[0], e = 0; e < t.length; e++) {
        var n = Math.trunc(e / 3),
            i = e % 3;this.setAtLeast(n, i, lt.toDimensionValue(t.charAt(e)));
      } else if (3 === arguments.length) {
        var r = arguments[0],
            s = arguments[1],
            o = arguments[2];this.matrix[r][s] < o && (this.matrix[r][s] = o);
      }
    }, setAtLeastIfValid: function (t, e, n) {
      t >= 0 && e >= 0 && this.setAtLeast(t, e, n);
    }, isWithin: function () {
      return fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR]) && this.matrix[L.INTERIOR][L.EXTERIOR] === lt.FALSE && this.matrix[L.BOUNDARY][L.EXTERIOR] === lt.FALSE;
    }, isTouches: function (t, e) {
      return t > e ? this.isTouches(e, t) : (t === lt.A && e === lt.A || t === lt.L && e === lt.L || t === lt.L && e === lt.A || t === lt.P && e === lt.A || t === lt.P && e === lt.L) && this.matrix[L.INTERIOR][L.INTERIOR] === lt.FALSE && (fe.isTrue(this.matrix[L.INTERIOR][L.BOUNDARY]) || fe.isTrue(this.matrix[L.BOUNDARY][L.INTERIOR]) || fe.isTrue(this.matrix[L.BOUNDARY][L.BOUNDARY]));
    }, isOverlaps: function (t, e) {
      return t === lt.P && e === lt.P || t === lt.A && e === lt.A ? fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR]) && fe.isTrue(this.matrix[L.INTERIOR][L.EXTERIOR]) && fe.isTrue(this.matrix[L.EXTERIOR][L.INTERIOR]) : t === lt.L && e === lt.L && 1 === this.matrix[L.INTERIOR][L.INTERIOR] && fe.isTrue(this.matrix[L.INTERIOR][L.EXTERIOR]) && fe.isTrue(this.matrix[L.EXTERIOR][L.INTERIOR]);
    }, isEquals: function (t, e) {
      return t === e && fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR]) && this.matrix[L.INTERIOR][L.EXTERIOR] === lt.FALSE && this.matrix[L.BOUNDARY][L.EXTERIOR] === lt.FALSE && this.matrix[L.EXTERIOR][L.INTERIOR] === lt.FALSE && this.matrix[L.EXTERIOR][L.BOUNDARY] === lt.FALSE;
    }, toString: function () {
      for (var t = new P("123456789"), e = 0; e < 3; e++) for (var n = 0; n < 3; n++) t.setCharAt(3 * e + n, lt.toDimensionSymbol(this.matrix[e][n]));return t.toString();
    }, setAll: function (t) {
      for (var e = 0; e < 3; e++) for (var n = 0; n < 3; n++) this.matrix[e][n] = t;
    }, get: function (t, e) {
      return this.matrix[t][e];
    }, transpose: function () {
      var t = this.matrix[1][0];return this.matrix[1][0] = this.matrix[0][1], this.matrix[0][1] = t, t = this.matrix[2][0], this.matrix[2][0] = this.matrix[0][2], this.matrix[0][2] = t, t = this.matrix[2][1], this.matrix[2][1] = this.matrix[1][2], this.matrix[1][2] = t, this;
    }, matches: function (t) {
      if (9 !== t.length) throw new i("Should be length 9: " + t);for (var e = 0; e < 3; e++) for (var n = 0; n < 3; n++) if (!fe.matches(this.matrix[e][n], t.charAt(3 * e + n))) return !1;return !0;
    }, add: function (t) {
      for (var e = 0; e < 3; e++) for (var n = 0; n < 3; n++) this.setAtLeast(e, n, t.get(e, n));
    }, isDisjoint: function () {
      return this.matrix[L.INTERIOR][L.INTERIOR] === lt.FALSE && this.matrix[L.INTERIOR][L.BOUNDARY] === lt.FALSE && this.matrix[L.BOUNDARY][L.INTERIOR] === lt.FALSE && this.matrix[L.BOUNDARY][L.BOUNDARY] === lt.FALSE;
    }, isCrosses: function (t, e) {
      return t === lt.P && e === lt.L || t === lt.P && e === lt.A || t === lt.L && e === lt.A ? fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR]) && fe.isTrue(this.matrix[L.INTERIOR][L.EXTERIOR]) : t === lt.L && e === lt.P || t === lt.A && e === lt.P || t === lt.A && e === lt.L ? fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR]) && fe.isTrue(this.matrix[L.EXTERIOR][L.INTERIOR]) : t === lt.L && e === lt.L && 0 === this.matrix[L.INTERIOR][L.INTERIOR];
    }, interfaces_: function () {
      return [o];
    }, getClass: function () {
      return fe;
    } }), fe.matches = function () {
    if (Number.isInteger(arguments[0]) && "string" == typeof arguments[1]) {
      var t = arguments[0],
          e = arguments[1];return e === lt.SYM_DONTCARE || e === lt.SYM_TRUE && (t >= 0 || t === lt.TRUE) || e === lt.SYM_FALSE && t === lt.FALSE || e === lt.SYM_P && t === lt.P || e === lt.SYM_L && t === lt.L || e === lt.SYM_A && t === lt.A;
    }if ("string" == typeof arguments[0] && "string" == typeof arguments[1]) {
      var n = arguments[0],
          i = arguments[1],
          r = new fe(n);return r.matches(i);
    }
  }, fe.isTrue = function (t) {
    return t >= 0 || t === lt.TRUE;
  };var lo = Object.freeze({ Coordinate: g, CoordinateList: N, Envelope: C, LineSegment: ce, GeometryFactory: ie, Geometry: B, Point: Lt, LineString: St, LinearRing: bt, Polygon: Tt, GeometryCollection: ft, MultiPoint: Pt, MultiLineString: gt, MultiPolygon: Ot, Dimension: lt, IntersectionMatrix: fe, PrecisionModel: ee });e(ge.prototype, { addPoint: function (t) {
      this.ptCount += 1, this.ptCentSum.x += t.x, this.ptCentSum.y += t.y;
    }, setBasePoint: function (t) {
      null === this.areaBasePt && (this.areaBasePt = t);
    }, addLineSegments: function (t) {
      for (var e = 0, n = 0; n < t.length - 1; n++) {
        var i = t[n].distance(t[n + 1]);if (0 !== i) {
          e += i;var r = (t[n].x + t[n + 1].x) / 2;this.lineCentSum.x += i * r;var s = (t[n].y + t[n + 1].y) / 2;this.lineCentSum.y += i * s;
        }
      }this.totalLength += e, 0 === e && t.length > 0 && this.addPoint(t[0]);
    }, addHole: function (t) {
      for (var e = he.isCCW(t), n = 0; n < t.length - 1; n++) this.addTriangle(this.areaBasePt, t[n], t[n + 1], e);this.addLineSegments(t);
    }, getCentroid: function () {
      var t = new g();if (Math.abs(this.areasum2) > 0) t.x = this.cg3.x / 3 / this.areasum2, t.y = this.cg3.y / 3 / this.areasum2;else if (this.totalLength > 0) t.x = this.lineCentSum.x / this.totalLength, t.y = this.lineCentSum.y / this.totalLength;else {
        if (!(this.ptCount > 0)) return null;t.x = this.ptCentSum.x / this.ptCount, t.y = this.ptCentSum.y / this.ptCount;
      }return t;
    }, addShell: function (t) {
      t.length > 0 && this.setBasePoint(t[0]);for (var e = !he.isCCW(t), n = 0; n < t.length - 1; n++) this.addTriangle(this.areaBasePt, t[n], t[n + 1], e);this.addLineSegments(t);
    }, addTriangle: function (t, e, n, i) {
      var r = i ? 1 : -1;ge.centroid3(t, e, n, this.triangleCent3);var s = ge.area2(t, e, n);this.cg3.x += r * s * this.triangleCent3.x, this.cg3.y += r * s * this.triangleCent3.y, this.areasum2 += r * s;
    }, add: function () {
      if (arguments[0] instanceof Tt) {
        var t = arguments[0];this.addShell(t.getExteriorRing().getCoordinates());for (var e = 0; e < t.getNumInteriorRing(); e++) this.addHole(t.getInteriorRingN(e).getCoordinates());
      } else if (arguments[0] instanceof B) {
        var n = arguments[0];if (n.isEmpty()) return null;if (n instanceof Lt) this.addPoint(n.getCoordinate());else if (n instanceof St) this.addLineSegments(n.getCoordinates());else if (n instanceof Tt) {
          var i = n;this.add(i);
        } else if (n instanceof ft) for (var r = n, e = 0; e < r.getNumGeometries(); e++) this.add(r.getGeometryN(e));
      }
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return ge;
    } }), ge.area2 = function (t, e, n) {
    return (e.x - t.x) * (n.y - t.y) - (n.x - t.x) * (e.y - t.y);
  }, ge.centroid3 = function (t, e, n, i) {
    return i.x = t.x + e.x + n.x, i.y = t.y + e.y + n.y, null;
  }, ge.getCentroid = function (t) {
    var e = new ge(t);return e.getCentroid();
  }, de.prototype = new Error(), de.prototype.name = "EmptyStackException", pe.prototype = new y(), pe.prototype.add = function (t) {
    return this.array_.push(t), !0;
  }, pe.prototype.get = function (t) {
    if (t < 0 || t >= this.size()) throw new IndexOutOfBoundsException();return this.array_[t];
  }, pe.prototype.push = function (t) {
    return this.array_.push(t), t;
  }, pe.prototype.pop = function (t) {
    if (0 === this.array_.length) throw new de();return this.array_.pop();
  }, pe.prototype.peek = function () {
    if (0 === this.array_.length) throw new de();return this.array_[this.array_.length - 1];
  }, pe.prototype.empty = function () {
    return 0 === this.array_.length;
  }, pe.prototype.isEmpty = function () {
    return this.empty();
  }, pe.prototype.search = function (t) {
    return this.array_.indexOf(t);
  }, pe.prototype.size = function () {
    return this.array_.length;
  }, pe.prototype.toArray = function () {
    for (var t = [], e = 0, n = this.array_.length; e < n; e++) t.push(this.array_[e]);return t;
  }, e(ve.prototype, { filter: function (t) {
      this.treeSet.contains(t) || (this.list.add(t), this.treeSet.add(t));
    }, getCoordinates: function () {
      var t = new Array(this.list.size()).fill(null);return this.list.toArray(t);
    }, interfaces_: function () {
      return [z];
    }, getClass: function () {
      return ve;
    } }), ve.filterCoordinates = function (t) {
    for (var e = new ve(), n = 0; n < t.length; n++) e.filter(t[n]);return e.getCoordinates();
  }, e(me.prototype, { preSort: function (t) {
      for (var e = null, n = 1; n < t.length; n++) (t[n].y < t[0].y || t[n].y === t[0].y && t[n].x < t[0].x) && (e = t[0], t[0] = t[n], t[n] = e);return ut.sort(t, 1, t.length, new ye(t[0])), t;
    }, computeOctRing: function (t) {
      var e = this.computeOctPts(t),
          n = new N();return n.add(e, !1), n.size() < 3 ? null : (n.closeRing(), n.toCoordinateArray());
    }, lineOrPolygon: function (t) {
      if (t = this.cleanRing(t), 3 === t.length) return this.geomFactory.createLineString([t[0], t[1]]);var e = this.geomFactory.createLinearRing(t);return this.geomFactory.createPolygon(e, null);
    }, cleanRing: function (t) {
      f.equals(t[0], t[t.length - 1]);for (var e = new I(), n = null, i = 0; i <= t.length - 2; i++) {
        var r = t[i],
            s = t[i + 1];r.equals(s) || null !== n && this.isBetween(n, r, s) || (e.add(r), n = r);
      }e.add(t[t.length - 1]);var o = new Array(e.size()).fill(null);return e.toArray(o);
    }, isBetween: function (t, e, n) {
      if (0 !== he.computeOrientation(t, e, n)) return !1;if (t.x !== n.x) {
        if (t.x <= e.x && e.x <= n.x) return !0;if (n.x <= e.x && e.x <= t.x) return !0;
      }if (t.y !== n.y) {
        if (t.y <= e.y && e.y <= n.y) return !0;if (n.y <= e.y && e.y <= t.y) return !0;
      }return !1;
    }, reduce: function (t) {
      var e = this.computeOctRing(t);if (null === e) return t;for (var n = new at(), i = 0; i < e.length; i++) n.add(e[i]);for (var i = 0; i < t.length; i++) he.isPointInRing(t[i], e) || n.add(t[i]);var r = H.toCoordinateArray(n);return r.length < 3 ? this.padArray3(r) : r;
    }, getConvexHull: function () {
      if (0 === this.inputPts.length) return this.geomFactory.createGeometryCollection(null);if (1 === this.inputPts.length) return this.geomFactory.createPoint(this.inputPts[0]);if (2 === this.inputPts.length) return this.geomFactory.createLineString(this.inputPts);var t = this.inputPts;this.inputPts.length > 50 && (t = this.reduce(this.inputPts));var e = this.preSort(t),
          n = this.grahamScan(e),
          i = this.toCoordinateArray(n);return this.lineOrPolygon(i);
    }, padArray3: function (t) {
      for (var e = new Array(3).fill(null), n = 0; n < e.length; n++) n < t.length ? e[n] = t[n] : e[n] = t[0];return e;
    }, computeOctPts: function (t) {
      for (var e = new Array(8).fill(null), n = 0; n < e.length; n++) e[n] = t[0];for (var i = 1; i < t.length; i++) t[i].x < e[0].x && (e[0] = t[i]), t[i].x - t[i].y < e[1].x - e[1].y && (e[1] = t[i]), t[i].y > e[2].y && (e[2] = t[i]), t[i].x + t[i].y > e[3].x + e[3].y && (e[3] = t[i]), t[i].x > e[4].x && (e[4] = t[i]), t[i].x - t[i].y > e[5].x - e[5].y && (e[5] = t[i]), t[i].y < e[6].y && (e[6] = t[i]), t[i].x + t[i].y < e[7].x + e[7].y && (e[7] = t[i]);return e;
    }, toCoordinateArray: function (t) {
      for (var e = new Array(t.size()).fill(null), n = 0; n < t.size(); n++) {
        var i = t.get(n);e[n] = i;
      }return e;
    }, grahamScan: function (t) {
      var e = null,
          n = new pe();e = n.push(t[0]), e = n.push(t[1]), e = n.push(t[2]);for (var i = 3; i < t.length; i++) {
        for (e = n.pop(); !n.empty() && he.computeOrientation(n.peek(), e, t[i]) > 0;) e = n.pop();e = n.push(e), e = n.push(t[i]);
      }return e = n.push(t[0]), n;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return me;
    } }), me.extractCoordinates = function (t) {
    var e = new ve();return t.apply(e), e.getCoordinates();
  }, e(ye.prototype, { compare: function (t, e) {
      var n = t,
          i = e;return ye.polarCompare(this.origin, n, i);
    }, interfaces_: function () {
      return [a];
    }, getClass: function () {
      return ye;
    } }), ye.polarCompare = function (t, e, n) {
    var i = e.x - t.x,
        r = e.y - t.y,
        s = n.x - t.x,
        o = n.y - t.y,
        a = he.computeOrientation(t, e, n);if (a === he.COUNTERCLOCKWISE) return 1;if (a === he.CLOCKWISE) return -1;var u = i * i + r * r,
        l = s * s + o * o;return u < l ? -1 : u > l ? 1 : 0;
  }, me.RadialComparator = ye, e(xe.prototype, { transformPoint: function (t, e) {
      return this.factory.createPoint(this.transformCoordinates(t.getCoordinateSequence(), t));
    }, transformPolygon: function (t, e) {
      var n = !0,
          i = this.transformLinearRing(t.getExteriorRing(), t);null !== i && i instanceof bt && !i.isEmpty() || (n = !1);for (var r = new I(), s = 0; s < t.getNumInteriorRing(); s++) {
        var o = this.transformLinearRing(t.getInteriorRingN(s), t);null === o || o.isEmpty() || (o instanceof bt || (n = !1), r.add(o));
      }if (n) return this.factory.createPolygon(i, r.toArray([]));var a = new I();return null !== i && a.add(i), a.addAll(r), this.factory.buildGeometry(a);
    }, createCoordinateSequence: function (t) {
      return this.factory.getCoordinateSequenceFactory().create(t);
    }, getInputGeometry: function () {
      return this.inputGeom;
    }, transformMultiLineString: function (t, e) {
      for (var n = new I(), i = 0; i < t.getNumGeometries(); i++) {
        var r = this.transformLineString(t.getGeometryN(i), t);null !== r && (r.isEmpty() || n.add(r));
      }return this.factory.buildGeometry(n);
    }, transformCoordinates: function (t, e) {
      return this.copy(t);
    }, transformLineString: function (t, e) {
      return this.factory.createLineString(this.transformCoordinates(t.getCoordinateSequence(), t));
    }, transformMultiPoint: function (t, e) {
      for (var n = new I(), i = 0; i < t.getNumGeometries(); i++) {
        var r = this.transformPoint(t.getGeometryN(i), t);null !== r && (r.isEmpty() || n.add(r));
      }return this.factory.buildGeometry(n);
    }, transformMultiPolygon: function (t, e) {
      for (var n = new I(), i = 0; i < t.getNumGeometries(); i++) {
        var r = this.transformPolygon(t.getGeometryN(i), t);null !== r && (r.isEmpty() || n.add(r));
      }return this.factory.buildGeometry(n);
    }, copy: function (t) {
      return t.copy();
    }, transformGeometryCollection: function (t, e) {
      for (var n = new I(), i = 0; i < t.getNumGeometries(); i++) {
        var r = this.transform(t.getGeometryN(i));null !== r && (this.pruneEmptyGeometry && r.isEmpty() || n.add(r));
      }return this.preserveGeometryCollectionType ? this.factory.createGeometryCollection(ie.toGeometryArray(n)) : this.factory.buildGeometry(n);
    }, transform: function (t) {
      if (this.inputGeom = t, this.factory = t.getFactory(), t instanceof Lt) return this.transformPoint(t, null);if (t instanceof Pt) return this.transformMultiPoint(t, null);if (t instanceof bt) return this.transformLinearRing(t, null);if (t instanceof St) return this.transformLineString(t, null);if (t instanceof gt) return this.transformMultiLineString(t, null);if (t instanceof Tt) return this.transformPolygon(t, null);if (t instanceof Ot) return this.transformMultiPolygon(t, null);if (t instanceof ft) return this.transformGeometryCollection(t, null);throw new i("Unknown Geometry subtype: " + t.getClass().getName());
    }, transformLinearRing: function (t, e) {
      var n = this.transformCoordinates(t.getCoordinateSequence(), t);if (null === n) return this.factory.createLinearRing(null);var i = n.size();return i > 0 && i < 4 && !this.preserveType ? this.factory.createLineString(n) : this.factory.createLinearRing(n);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return xe;
    } }), e(Ee.prototype, { snapVertices: function (t, e) {
      for (var n = this._isClosed ? t.size() - 1 : t.size(), i = 0; i < n; i++) {
        var r = t.get(i),
            s = this.findSnapForVertex(r, e);null !== s && (t.set(i, new g(s)), 0 === i && this._isClosed && t.set(t.size() - 1, new g(s)));
      }
    }, findSnapForVertex: function (t, e) {
      for (var n = 0; n < e.length; n++) {
        if (t.equals2D(e[n])) return null;if (t.distance(e[n]) < this.snapTolerance) return e[n];
      }return null;
    }, snapTo: function (t) {
      var e = new N(this.srcPts);this.snapVertices(e, t), this.snapSegments(e, t);var n = e.toCoordinateArray();return n;
    }, snapSegments: function (t, e) {
      if (0 === e.length) return null;var n = e.length;e[0].equals2D(e[e.length - 1]) && (n = e.length - 1);for (var i = 0; i < n; i++) {
        var r = e[i],
            s = this.findSegmentIndexToSnap(r, t);s >= 0 && t.add(s + 1, new g(r), !1);
      }
    }, findSegmentIndexToSnap: function (t, e) {
      for (var n = r.MAX_VALUE, i = -1, s = 0; s < e.size() - 1; s++) {
        if (this.seg.p0 = e.get(s), this.seg.p1 = e.get(s + 1), this.seg.p0.equals2D(t) || this.seg.p1.equals2D(t)) {
          if (this.allowSnappingToSourceVertices) continue;return -1;
        }var o = this.seg.distance(t);o < this.snapTolerance && o < n && (n = o, i = s);
      }return i;
    }, setAllowSnappingToSourceVertices: function (t) {
      this.allowSnappingToSourceVertices = t;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Ee;
    } }), Ee.isClosed = function (t) {
    return !(t.length <= 1) && t[0].equals2D(t[t.length - 1]);
  }, e(Ie.prototype, { snapTo: function (t, e) {
      var n = this.extractTargetCoordinates(t),
          i = new Ne(e, n);return i.transform(this.srcGeom);
    }, snapToSelf: function (t, e) {
      var n = this.extractTargetCoordinates(this.srcGeom),
          i = new Ne(t, n, !0),
          r = i.transform(this.srcGeom),
          s = r;return e && R(s, Rt) && (s = r.buffer(0)), s;
    }, computeSnapTolerance: function (t) {
      var e = this.computeMinimumSegmentLength(t),
          n = e / 10;return n;
    }, extractTargetCoordinates: function (t) {
      for (var e = new at(), n = t.getCoordinates(), i = 0; i < n.length; i++) e.add(n[i]);return e.toArray(new Array(0).fill(null));
    }, computeMinimumSegmentLength: function (t) {
      for (var e = r.MAX_VALUE, n = 0; n < t.length - 1; n++) {
        var i = t[n].distance(t[n + 1]);i < e && (e = i);
      }return e;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Ie;
    } }), Ie.snap = function (t, e, n) {
    var i = new Array(2).fill(null),
        r = new Ie(t);i[0] = r.snapTo(e, n);var s = new Ie(e);return i[1] = s.snapTo(i[0], n), i;
  }, Ie.computeOverlaySnapTolerance = function () {
    if (1 === arguments.length) {
      var t = arguments[0],
          e = Ie.computeSizeBasedSnapTolerance(t),
          n = t.getPrecisionModel();if (n.getType() === ee.FIXED) {
        var i = 1 / n.getScale() * 2 / 1.415;i > e && (e = i);
      }return e;
    }if (2 === arguments.length) {
      var r = arguments[0],
          s = arguments[1];return Math.min(Ie.computeOverlaySnapTolerance(r), Ie.computeOverlaySnapTolerance(s));
    }
  }, Ie.computeSizeBasedSnapTolerance = function (t) {
    var e = t.getEnvelopeInternal(),
        n = Math.min(e.getHeight(), e.getWidth()),
        i = n * Ie.SNAP_PRECISION_FACTOR;return i;
  }, Ie.snapToSelf = function (t, e, n) {
    var i = new Ie(t);return i.snapToSelf(e, n);
  }, Ie.SNAP_PRECISION_FACTOR = 1e-9, h(Ne, xe), e(Ne.prototype, { snapLine: function (t, e) {
      var n = new Ee(t, this.snapTolerance);return n.setAllowSnappingToSourceVertices(this.isSelfSnap), n.snapTo(e);
    }, transformCoordinates: function (t, e) {
      var n = t.toCoordinateArray(),
          i = this.snapLine(n, this.snapPts);return this.factory.getCoordinateSequenceFactory().create(i);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Ne;
    } }), e(Ce.prototype, { getCommon: function () {
      return r.longBitsToDouble(this.commonBits);
    }, add: function (t) {
      var e = r.doubleToLongBits(t);if (this.isFirst) return this.commonBits = e, this.commonSignExp = Ce.signExpBits(this.commonBits), this.isFirst = !1, null;var n = Ce.signExpBits(e);return n !== this.commonSignExp ? (this.commonBits = 0, null) : (this.commonMantissaBitsCount = Ce.numCommonMostSigMantissaBits(this.commonBits, e), void (this.commonBits = Ce.zeroLowerBits(this.commonBits, 64 - (12 + this.commonMantissaBitsCount))));
    }, toString: function () {
      if (1 === arguments.length) {
        var t = arguments[0],
            e = r.longBitsToDouble(t),
            n = Long.toBinaryString(t),
            i = "0000000000000000000000000000000000000000000000000000000000000000" + n,
            s = i.substring(i.length - 64),
            o = s.substring(0, 1) + "  " + s.substring(1, 12) + "(exp) " + s.substring(12) + " [ " + e + " ]";return o;
      }
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Ce;
    } }), Ce.getBit = function (t, e) {
    var n = 1 << e;return 0 !== (t & n) ? 1 : 0;
  }, Ce.signExpBits = function (t) {
    return t >> 52;
  }, Ce.zeroLowerBits = function (t, e) {
    var n = (1 << e) - 1,
        i = ~n,
        r = t & i;return r;
  }, Ce.numCommonMostSigMantissaBits = function (t, e) {
    for (var n = 0, i = 52; i >= 0; i--) {
      if (Ce.getBit(t, i) !== Ce.getBit(e, i)) return n;n++;
    }return 52;
  }, e(Se.prototype, { addCommonBits: function (t) {
      var e = new Le(this.commonCoord);t.apply(e), t.geometryChanged();
    }, removeCommonBits: function (t) {
      if (0 === this.commonCoord.x && 0 === this.commonCoord.y) return t;var e = new g(this.commonCoord);e.x = -e.x, e.y = -e.y;var n = new Le(e);return t.apply(n), t.geometryChanged(), t;
    }, getCommonCoordinate: function () {
      return this.commonCoord;
    }, add: function (t) {
      t.apply(this.ccFilter), this.commonCoord = this.ccFilter.getCommonCoordinate();
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Se;
    } }), e(we.prototype, { filter: function (t) {
      this.commonBitsX.add(t.x), this.commonBitsY.add(t.y);
    }, getCommonCoordinate: function () {
      return new g(this.commonBitsX.getCommon(), this.commonBitsY.getCommon());
    }, interfaces_: function () {
      return [z];
    }, getClass: function () {
      return we;
    } }), e(Le.prototype, { filter: function (t, e) {
      var n = t.getOrdinate(e, 0) + this.trans.x,
          i = t.getOrdinate(e, 1) + this.trans.y;t.setOrdinate(e, 0, n), t.setOrdinate(e, 1, i);
    }, isDone: function () {
      return !1;
    }, isGeometryChanged: function () {
      return !0;
    }, interfaces_: function () {
      return [ct];
    }, getClass: function () {
      return Le;
    } }), Se.CommonCoordinateFilter = we, Se.Translater = Le, e(Re.prototype, { next: function () {
      if (this.atStart) return this.atStart = !1, Re.isAtomic(this.parent) && this.index++, this.parent;if (null !== this.subcollectionIterator) {
        if (this.subcollectionIterator.hasNext()) return this.subcollectionIterator.next();this.subcollectionIterator = null;
      }if (this.index >= this.max) throw new x();var t = this.parent.getGeometryN(this.index++);return t instanceof ft ? (this.subcollectionIterator = new Re(t), this.subcollectionIterator.next()) : t;
    }, remove: function () {
      throw new UnsupportedOperationException(this.getClass().getName());
    }, hasNext: function () {
      if (this.atStart) return !0;if (null !== this.subcollectionIterator) {
        if (this.subcollectionIterator.hasNext()) return !0;this.subcollectionIterator = null;
      }return !(this.index >= this.max);
    }, interfaces_: function () {
      return [p];
    }, getClass: function () {
      return Re;
    } }), Re.isAtomic = function (t) {
    return !(t instanceof ft);
  }, e(Te.prototype, { locateInternal: function () {
      if (arguments[0] instanceof g && arguments[1] instanceof Tt) {
        var t = arguments[0],
            e = arguments[1];if (e.isEmpty()) return L.EXTERIOR;var n = e.getExteriorRing(),
            i = this.locateInPolygonRing(t, n);if (i === L.EXTERIOR) return L.EXTERIOR;if (i === L.BOUNDARY) return L.BOUNDARY;for (var r = 0; r < e.getNumInteriorRing(); r++) {
          var s = e.getInteriorRingN(r),
              o = this.locateInPolygonRing(t, s);if (o === L.INTERIOR) return L.EXTERIOR;if (o === L.BOUNDARY) return L.BOUNDARY;
        }return L.INTERIOR;
      }if (arguments[0] instanceof g && arguments[1] instanceof St) {
        var a = arguments[0],
            u = arguments[1];if (!u.getEnvelopeInternal().intersects(a)) return L.EXTERIOR;var l = u.getCoordinates();return u.isClosed() || !a.equals(l[0]) && !a.equals(l[l.length - 1]) ? he.isOnLine(a, l) ? L.INTERIOR : L.EXTERIOR : L.BOUNDARY;
      }if (arguments[0] instanceof g && arguments[1] instanceof Lt) {
        var h = arguments[0],
            c = arguments[1],
            f = c.getCoordinate();return f.equals2D(h) ? L.INTERIOR : L.EXTERIOR;
      }
    }, locateInPolygonRing: function (t, e) {
      return e.getEnvelopeInternal().intersects(t) ? he.locatePointInRing(t, e.getCoordinates()) : L.EXTERIOR;
    }, intersects: function (t, e) {
      return this.locate(t, e) !== L.EXTERIOR;
    }, updateLocationInfo: function (t) {
      t === L.INTERIOR && (this.isIn = !0), t === L.BOUNDARY && this.numBoundaries++;
    }, computeLocation: function (t, e) {
      if (e instanceof Lt && this.updateLocationInfo(this.locateInternal(t, e)), e instanceof St) this.updateLocationInfo(this.locateInternal(t, e));else if (e instanceof Tt) this.updateLocationInfo(this.locateInternal(t, e));else if (e instanceof gt) for (var n = e, i = 0; i < n.getNumGeometries(); i++) {
        var r = n.getGeometryN(i);this.updateLocationInfo(this.locateInternal(t, r));
      } else if (e instanceof Ot) for (var s = e, i = 0; i < s.getNumGeometries(); i++) {
        var o = s.getGeometryN(i);this.updateLocationInfo(this.locateInternal(t, o));
      } else if (e instanceof ft) for (var a = new Re(e); a.hasNext();) {
        var u = a.next();u !== e && this.computeLocation(t, u);
      }
    }, locate: function (t, e) {
      return e.isEmpty() ? L.EXTERIOR : e instanceof St ? this.locateInternal(t, e) : e instanceof Tt ? this.locateInternal(t, e) : (this.isIn = !1, this.numBoundaries = 0, this.computeLocation(t, e), this.boundaryRule.isInBoundary(this.numBoundaries) ? L.BOUNDARY : this.numBoundaries > 0 || this.isIn ? L.INTERIOR : L.EXTERIOR);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Te;
    } }), e(Pe.prototype, { interfaces_: function () {
      return [];
    }, getClass: function () {
      return Pe;
    } }), Pe.octant = function () {
    if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
      var t = arguments[0],
          e = arguments[1];if (0 === t && 0 === e) throw new i("Cannot compute the octant for point ( " + t + ", " + e + " )");var n = Math.abs(t),
          r = Math.abs(e);return t >= 0 ? e >= 0 ? n >= r ? 0 : 1 : n >= r ? 7 : 6 : e >= 0 ? n >= r ? 3 : 2 : n >= r ? 4 : 5;
    }if (arguments[0] instanceof g && arguments[1] instanceof g) {
      var s = arguments[0],
          o = arguments[1],
          a = o.x - s.x,
          u = o.y - s.y;if (0 === a && 0 === u) throw new i("Cannot compute the octant for two identical points " + s);return Pe.octant(a, u);
    }
  }, e(be.prototype, { getCoordinates: function () {}, size: function () {}, getCoordinate: function (t) {}, isClosed: function () {}, setData: function (t) {}, getData: function () {}, interfaces_: function () {
      return [];
    }, getClass: function () {
      return be;
    } }), e(Oe.prototype, { getCoordinates: function () {
      return this.pts;
    }, size: function () {
      return this.pts.length;
    }, getCoordinate: function (t) {
      return this.pts[t];
    }, isClosed: function () {
      return this.pts[0].equals(this.pts[this.pts.length - 1]);
    }, getSegmentOctant: function (t) {
      return t === this.pts.length - 1 ? -1 : Pe.octant(this.getCoordinate(t), this.getCoordinate(t + 1));
    }, setData: function (t) {
      this.data = t;
    }, getData: function () {
      return this.data;
    }, toString: function () {
      return se.toLineString(new Gt(this.pts));
    }, interfaces_: function () {
      return [be];
    }, getClass: function () {
      return Oe;
    } }), e(_e.prototype, { getBounds: function () {}, interfaces_: function () {
      return [];
    }, getClass: function () {
      return _e;
    } }), e(Me.prototype, { getItem: function () {
      return this.item;
    }, getBounds: function () {
      return this.bounds;
    }, interfaces_: function () {
      return [_e, u];
    }, getClass: function () {
      return Me;
    } }), e(De.prototype, { poll: function () {
      if (this.isEmpty()) return null;var t = this.items.get(1);return this.items.set(1, this.items.get(this._size)), this._size -= 1, this.reorder(1), t;
    }, size: function () {
      return this._size;
    }, reorder: function (t) {
      for (var e = null, n = this.items.get(t); 2 * t <= this._size && (e = 2 * t, e !== this._size && this.items.get(e + 1).compareTo(this.items.get(e)) < 0 && e++, this.items.get(e).compareTo(n) < 0); t = e) this.items.set(t, this.items.get(e));this.items.set(t, n);
    }, clear: function () {
      this._size = 0, this.items.clear();
    }, isEmpty: function () {
      return 0 === this._size;
    }, add: function (t) {
      this.items.add(null), this._size += 1;var e = this._size;for (this.items.set(0, t); t.compareTo(this.items.get(Math.trunc(e / 2))) < 0; e /= 2) this.items.set(e, this.items.get(Math.trunc(e / 2)));this.items.set(e, t);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return De;
    } }), e(Ae.prototype, { visitItem: function (t) {}, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Ae;
    } }), e(Fe.prototype, { insert: function (t, e) {}, remove: function (t, e) {}, query: function () {
      if (1 === arguments.length) {
        arguments[0];
      } else if (2 === arguments.length) {
        arguments[0], arguments[1];
      }
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Fe;
    } }), e(Ge.prototype, { getLevel: function () {
      return this.level;
    }, size: function () {
      return this.childBoundables.size();
    }, getChildBoundables: function () {
      return this.childBoundables;
    }, addChildBoundable: function (t) {
      f.isTrue(null === this.bounds), this.childBoundables.add(t);
    }, isEmpty: function () {
      return this.childBoundables.isEmpty();
    }, getBounds: function () {
      return null === this.bounds && (this.bounds = this.computeBounds()), this.bounds;
    }, interfaces_: function () {
      return [_e, u];
    }, getClass: function () {
      return Ge;
    } }), Ge.serialVersionUID = 0x5a1e55ec41369800;var ho = { reverseOrder: function () {
      return { compare: function (t, e) {
          return e.compareTo(t);
        } };
    }, min: function (t) {
      return ho.sort(t), t.get(0);
    }, sort: function (t, e) {
      var n = t.toArray();e ? ut.sort(n, e) : ut.sort(n);for (var i = t.iterator(), r = 0, s = n.length; r < s; r++) i.next(), i.set(n[r]);
    }, singletonList: function (t) {
      var e = new I();return e.add(t), e;
    } };e(qe.prototype, { expandToQueue: function (t, e) {
      var n = qe.isComposite(this.boundable1),
          r = qe.isComposite(this.boundable2);if (n && r) return qe.area(this.boundable1) > qe.area(this.boundable2) ? (this.expand(this.boundable1, this.boundable2, t, e), null) : (this.expand(this.boundable2, this.boundable1, t, e), null);if (n) return this.expand(this.boundable1, this.boundable2, t, e), null;if (r) return this.expand(this.boundable2, this.boundable1, t, e), null;throw new i("neither boundable is composite");
    }, isLeaves: function () {
      return !(qe.isComposite(this.boundable1) || qe.isComposite(this.boundable2));
    }, compareTo: function (t) {
      var e = t;return this._distance < e._distance ? -1 : this._distance > e._distance ? 1 : 0;
    }, expand: function (t, e, n, i) {
      for (var r = t.getChildBoundables(), s = r.iterator(); s.hasNext();) {
        var o = s.next(),
            a = new qe(o, e, this.itemDistance);a.getDistance() < i && n.add(a);
      }
    }, getBoundable: function (t) {
      return 0 === t ? this.boundable1 : this.boundable2;
    }, getDistance: function () {
      return this._distance;
    }, distance: function () {
      return this.isLeaves() ? this.itemDistance.distance(this.boundable1, this.boundable2) : this.boundable1.getBounds().distance(this.boundable2.getBounds());
    }, interfaces_: function () {
      return [s];
    }, getClass: function () {
      return qe;
    } }), qe.area = function (t) {
    return t.getBounds().getArea();
  }, qe.isComposite = function (t) {
    return t instanceof Ge;
  }, e(Be.prototype, { getNodeCapacity: function () {
      return this.nodeCapacity;
    }, lastNode: function (t) {
      return t.get(t.size() - 1);
    }, size: function t() {
      if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.size(this.root));if (1 === arguments.length) {
        for (var e = arguments[0], t = 0, n = e.getChildBoundables().iterator(); n.hasNext();) {
          var i = n.next();i instanceof Ge ? t += this.size(i) : i instanceof Me && (t += 1);
        }return t;
      }
    }, removeItem: function (t, e) {
      for (var n = null, i = t.getChildBoundables().iterator(); i.hasNext();) {
        var r = i.next();r instanceof Me && r.getItem() === e && (n = r);
      }return null !== n && (t.getChildBoundables().remove(n), !0);
    }, itemsTree: function () {
      if (0 === arguments.length) {
        this.build();var t = this.itemsTree(this.root);return null === t ? new I() : t;
      }if (1 === arguments.length) {
        for (var e = arguments[0], n = new I(), i = e.getChildBoundables().iterator(); i.hasNext();) {
          var r = i.next();if (r instanceof Ge) {
            var s = this.itemsTree(r);null !== s && n.add(s);
          } else r instanceof Me ? n.add(r.getItem()) : f.shouldNeverReachHere();
        }return n.size() <= 0 ? null : n;
      }
    }, insert: function (t, e) {
      f.isTrue(!this.built, "Cannot insert items into an STR packed R-tree after it has been built."), this.itemBoundables.add(new Me(t, e));
    }, boundablesAtLevel: function () {
      if (1 === arguments.length) {
        var t = arguments[0],
            e = new I();return this.boundablesAtLevel(t, this.root, e), e;
      }if (3 === arguments.length) {
        var n = arguments[0],
            i = arguments[1],
            r = arguments[2];if (f.isTrue(n > -2), i.getLevel() === n) return r.add(i), null;for (var s = i.getChildBoundables().iterator(); s.hasNext();) {
          var o = s.next();o instanceof Ge ? this.boundablesAtLevel(n, o, r) : (f.isTrue(o instanceof Me), n === -1 && r.add(o));
        }return null;
      }
    }, query: function () {
      if (1 === arguments.length) {
        var t = arguments[0];this.build();var e = new I();return this.isEmpty() ? e : (this.getIntersectsOp().intersects(this.root.getBounds(), t) && this.query(t, this.root, e), e);
      }if (2 === arguments.length) {
        var n = arguments[0],
            i = arguments[1];if (this.build(), this.isEmpty()) return null;this.getIntersectsOp().intersects(this.root.getBounds(), n) && this.query(n, this.root, i);
      } else if (3 === arguments.length) if (R(arguments[2], Ae) && arguments[0] instanceof Object && arguments[1] instanceof Ge) for (var r = arguments[0], s = arguments[1], o = arguments[2], a = s.getChildBoundables(), u = 0; u < a.size(); u++) {
        var l = a.get(u);this.getIntersectsOp().intersects(l.getBounds(), r) && (l instanceof Ge ? this.query(r, l, o) : l instanceof Me ? o.visitItem(l.getItem()) : f.shouldNeverReachHere());
      } else if (R(arguments[2], y) && arguments[0] instanceof Object && arguments[1] instanceof Ge) for (var h = arguments[0], c = arguments[1], g = arguments[2], a = c.getChildBoundables(), u = 0; u < a.size(); u++) {
        var l = a.get(u);this.getIntersectsOp().intersects(l.getBounds(), h) && (l instanceof Ge ? this.query(h, l, g) : l instanceof Me ? g.add(l.getItem()) : f.shouldNeverReachHere());
      }
    }, build: function () {
      return this.built ? null : (this.root = this.itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this.itemBoundables, -1), this.itemBoundables = null, void (this.built = !0));
    }, getRoot: function () {
      return this.build(), this.root;
    }, remove: function () {
      if (2 === arguments.length) {
        var t = arguments[0],
            e = arguments[1];return this.build(), !!this.getIntersectsOp().intersects(this.root.getBounds(), t) && this.remove(t, this.root, e);
      }if (3 === arguments.length) {
        var n = arguments[0],
            i = arguments[1],
            r = arguments[2],
            s = this.removeItem(i, r);if (s) return !0;for (var o = null, a = i.getChildBoundables().iterator(); a.hasNext();) {
          var u = a.next();if (this.getIntersectsOp().intersects(u.getBounds(), n) && u instanceof Ge && (s = this.remove(n, u, r))) {
            o = u;break;
          }
        }return null !== o && o.getChildBoundables().isEmpty() && i.getChildBoundables().remove(o), s;
      }
    }, createHigherLevels: function (t, e) {
      f.isTrue(!t.isEmpty());var n = this.createParentBoundables(t, e + 1);return 1 === n.size() ? n.get(0) : this.createHigherLevels(n, e + 1);
    }, depth: function () {
      if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.depth(this.root));if (1 === arguments.length) {
        for (var t = arguments[0], e = 0, n = t.getChildBoundables().iterator(); n.hasNext();) {
          var i = n.next();if (i instanceof Ge) {
            var r = this.depth(i);r > e && (e = r);
          }
        }return e + 1;
      }
    }, createParentBoundables: function (t, e) {
      f.isTrue(!t.isEmpty());var n = new I();n.add(this.createNode(e));var i = new I(t);ho.sort(i, this.getComparator());for (var r = i.iterator(); r.hasNext();) {
        var s = r.next();this.lastNode(n).getChildBoundables().size() === this.getNodeCapacity() && n.add(this.createNode(e)), this.lastNode(n).addChildBoundable(s);
      }return n;
    }, isEmpty: function () {
      return this.built ? this.root.isEmpty() : this.itemBoundables.isEmpty();
    }, interfaces_: function () {
      return [u];
    }, getClass: function () {
      return Be;
    } }), Be.compareDoubles = function (t, e) {
    return t > e ? 1 : t < e ? -1 : 0;
  }, Be.IntersectsOp = ze, Be.serialVersionUID = -0x35ef64c82d4c5400, Be.DEFAULT_NODE_CAPACITY = 10, e(Ve.prototype, { distance: function (t, e) {}, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Ve;
    } }), h(ke, Be), e(ke.prototype, { createParentBoundablesFromVerticalSlices: function (t, e) {
      f.isTrue(t.length > 0);for (var n = new I(), i = 0; i < t.length; i++) n.addAll(this.createParentBoundablesFromVerticalSlice(t[i], e));return n;
    }, createNode: function (t) {
      return new Ye(t);
    }, size: function () {
      return 0 === arguments.length ? Be.prototype.size.call(this) : Be.prototype.size.apply(this, arguments);
    }, insert: function () {
      if (2 !== arguments.length) return Be.prototype.insert.apply(this, arguments);var t = arguments[0],
          e = arguments[1];return t.isNull() ? null : void Be.prototype.insert.call(this, t, e);
    }, getIntersectsOp: function () {
      return ke.intersectsOp;
    }, verticalSlices: function (t, e) {
      for (var n = Math.trunc(Math.ceil(t.size() / e)), i = new Array(e).fill(null), r = t.iterator(), s = 0; s < e; s++) {
        i[s] = new I();for (var o = 0; r.hasNext() && o < n;) {
          var a = r.next();i[s].add(a), o++;
        }
      }return i;
    }, query: function () {
      if (1 === arguments.length) {
        var t = arguments[0];return Be.prototype.query.call(this, t);
      }if (2 === arguments.length) {
        var e = arguments[0],
            n = arguments[1];Be.prototype.query.call(this, e, n);
      } else if (3 === arguments.length) if (R(arguments[2], Ae) && arguments[0] instanceof Object && arguments[1] instanceof Ge) {
        var i = arguments[0],
            r = arguments[1],
            s = arguments[2];Be.prototype.query.call(this, i, r, s);
      } else if (R(arguments[2], y) && arguments[0] instanceof Object && arguments[1] instanceof Ge) {
        var o = arguments[0],
            a = arguments[1],
            u = arguments[2];Be.prototype.query.call(this, o, a, u);
      }
    }, getComparator: function () {
      return ke.yComparator;
    }, createParentBoundablesFromVerticalSlice: function (t, e) {
      return Be.prototype.createParentBoundables.call(this, t, e);
    }, remove: function () {
      if (2 === arguments.length) {
        var t = arguments[0],
            e = arguments[1];return Be.prototype.remove.call(this, t, e);
      }return Be.prototype.remove.apply(this, arguments);
    }, depth: function () {
      return 0 === arguments.length ? Be.prototype.depth.call(this) : Be.prototype.depth.apply(this, arguments);
    }, createParentBoundables: function (t, e) {
      f.isTrue(!t.isEmpty());var n = Math.trunc(Math.ceil(t.size() / this.getNodeCapacity())),
          i = new I(t);ho.sort(i, ke.xComparator);var r = this.verticalSlices(i, Math.trunc(Math.ceil(Math.sqrt(n))));return this.createParentBoundablesFromVerticalSlices(r, e);
    }, nearestNeighbour: function () {
      if (1 === arguments.length) {
        if (R(arguments[0], Ve)) {
          var t = arguments[0],
              e = new qe(this.getRoot(), this.getRoot(), t);return this.nearestNeighbour(e);
        }if (arguments[0] instanceof qe) {
          var n = arguments[0];return this.nearestNeighbour(n, r.POSITIVE_INFINITY);
        }
      } else if (2 === arguments.length) {
        if (arguments[0] instanceof ke && R(arguments[1], Ve)) {
          var i = arguments[0],
              s = arguments[1],
              e = new qe(this.getRoot(), i.getRoot(), s);return this.nearestNeighbour(e);
        }if (arguments[0] instanceof qe && "number" == typeof arguments[1]) {
          var o = arguments[0],
              a = arguments[1],
              u = a,
              l = null,
              h = new De();for (h.add(o); !h.isEmpty() && u > 0;) {
            var c = h.poll(),
                f = c.getDistance();if (f >= u) break;c.isLeaves() ? (u = f, l = c) : c.expandToQueue(h, u);
          }return [l.getBoundable(0).getItem(), l.getBoundable(1).getItem()];
        }
      } else if (3 === arguments.length) {
        var g = arguments[0],
            d = arguments[1],
            p = arguments[2],
            v = new Me(g, d),
            e = new qe(this.getRoot(), v, p);return this.nearestNeighbour(e)[0];
      }
    }, interfaces_: function () {
      return [Fe, u];
    }, getClass: function () {
      return ke;
    } }), ke.centreX = function (t) {
    return ke.avg(t.getMinX(), t.getMaxX());
  }, ke.avg = function (t, e) {
    return (t + e) / 2;
  }, ke.centreY = function (t) {
    return ke.avg(t.getMinY(), t.getMaxY());
  }, h(Ye, Ge), e(Ye.prototype, { computeBounds: function () {
      for (var t = null, e = this.getChildBoundables().iterator(); e.hasNext();) {
        var n = e.next();null === t ? t = new C(n.getBounds()) : t.expandToInclude(n.getBounds());
      }return t;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Ye;
    } }), ke.STRtreeNode = Ye, ke.serialVersionUID = 0x39920f7d5f261e0, ke.xComparator = { interfaces_: function () {
      return [a];
    }, compare: function (t, e) {
      return Be.compareDoubles(ke.centreX(t.getBounds()), ke.centreX(e.getBounds()));
    } }, ke.yComparator = { interfaces_: function () {
      return [a];
    }, compare: function (t, e) {
      return Be.compareDoubles(ke.centreY(t.getBounds()), ke.centreY(e.getBounds()));
    } }, ke.intersectsOp = { interfaces_: function () {
      return [IntersectsOp];
    }, intersects: function (t, e) {
      return t.intersects(e);
    } }, ke.DEFAULT_NODE_CAPACITY = 10, e(Ue.prototype, { interfaces_: function () {
      return [];
    }, getClass: function () {
      return Ue;
    } }), Ue.relativeSign = function (t, e) {
    return t < e ? -1 : t > e ? 1 : 0;
  }, Ue.compare = function (t, e, n) {
    if (e.equals2D(n)) return 0;var i = Ue.relativeSign(e.x, n.x),
        r = Ue.relativeSign(e.y, n.y);switch (t) {case 0:
        return Ue.compareValue(i, r);case 1:
        return Ue.compareValue(r, i);case 2:
        return Ue.compareValue(r, -i);case 3:
        return Ue.compareValue(-i, r);case 4:
        return Ue.compareValue(-i, -r);case 5:
        return Ue.compareValue(-r, -i);case 6:
        return Ue.compareValue(-r, i);case 7:
        return Ue.compareValue(i, -r);}return f.shouldNeverReachHere("invalid octant value"), 0;
  }, Ue.compareValue = function (t, e) {
    return t < 0 ? -1 : t > 0 ? 1 : e < 0 ? -1 : e > 0 ? 1 : 0;
  }, e(Xe.prototype, { getCoordinate: function () {
      return this.coord;
    }, print: function (t) {
      t.print(this.coord), t.print(" seg # = " + this.segmentIndex);
    }, compareTo: function (t) {
      var e = t;return this.segmentIndex < e.segmentIndex ? -1 : this.segmentIndex > e.segmentIndex ? 1 : this.coord.equals2D(e.coord) ? 0 : Ue.compare(this.segmentOctant, this.coord, e.coord);
    }, isEndPoint: function (t) {
      return 0 === this.segmentIndex && !this._isInterior || this.segmentIndex === t;
    }, isInterior: function () {
      return this._isInterior;
    }, interfaces_: function () {
      return [s];
    }, getClass: function () {
      return Xe;
    } }), e(He.prototype, { getSplitCoordinates: function () {
      var t = new N();this.addEndpoints();for (var e = this.iterator(), n = e.next(); e.hasNext();) {
        var i = e.next();this.addEdgeCoordinates(n, i, t), n = i;
      }return t.toCoordinateArray();
    }, addCollapsedNodes: function () {
      var t = new I();this.findCollapsesFromInsertedNodes(t), this.findCollapsesFromExistingVertices(t);for (var e = t.iterator(); e.hasNext();) {
        var n = e.next().intValue();this.add(this.edge.getCoordinate(n), n);
      }
    }, print: function (t) {
      t.println("Intersections:");for (var e = this.iterator(); e.hasNext();) {
        var n = e.next();n.print(t);
      }
    }, findCollapsesFromExistingVertices: function (t) {
      for (var e = 0; e < this.edge.size() - 2; e++) {
        var n = this.edge.getCoordinate(e),
            i = (this.edge.getCoordinate(e + 1), this.edge.getCoordinate(e + 2));n.equals2D(i) && t.add(new b(e + 1));
      }
    }, addEdgeCoordinates: function (t, e, n) {
      var i = e.segmentIndex - t.segmentIndex + 2,
          r = this.edge.getCoordinate(e.segmentIndex),
          s = e.isInterior() || !e.coord.equals2D(r);s || i--;n.add(new g(t.coord), !1);for (var o = t.segmentIndex + 1; o <= e.segmentIndex; o++) n.add(this.edge.getCoordinate(o));s && n.add(new g(e.coord));
    }, iterator: function () {
      return this.nodeMap.values().iterator();
    }, addSplitEdges: function (t) {
      this.addEndpoints(), this.addCollapsedNodes();for (var e = this.iterator(), n = e.next(); e.hasNext();) {
        var i = e.next(),
            r = this.createSplitEdge(n, i);t.add(r), n = i;
      }
    }, findCollapseIndex: function (t, e, n) {
      if (!t.coord.equals2D(e.coord)) return !1;var i = e.segmentIndex - t.segmentIndex;return e.isInterior() || i--, 1 === i && (n[0] = t.segmentIndex + 1, !0);
    }, findCollapsesFromInsertedNodes: function (t) {
      for (var e = new Array(1).fill(null), n = this.iterator(), i = n.next(); n.hasNext();) {
        var r = n.next(),
            s = this.findCollapseIndex(i, r, e);s && t.add(new b(e[0])), i = r;
      }
    }, getEdge: function () {
      return this.edge;
    }, addEndpoints: function () {
      var t = this.edge.size() - 1;this.add(this.edge.getCoordinate(0), 0), this.add(this.edge.getCoordinate(t), t);
    }, createSplitEdge: function (t, e) {
      var n = e.segmentIndex - t.segmentIndex + 2,
          i = this.edge.getCoordinate(e.segmentIndex),
          r = e.isInterior() || !e.coord.equals2D(i);r || n--;var s = new Array(n).fill(null),
          o = 0;s[o++] = new g(t.coord);for (var a = t.segmentIndex + 1; a <= e.segmentIndex; a++) s[o++] = this.edge.getCoordinate(a);return r && (s[o] = new g(e.coord)), new Ke(s, this.edge.getData());
    }, add: function (t, e) {
      var n = new Xe(this.edge, t, e, this.edge.getSegmentOctant(e)),
          i = this.nodeMap.get(n);return null !== i ? (f.isTrue(i.coord.equals2D(t), "Found equal nodes with different coordinates"), i) : (this.nodeMap.put(n, n), n);
    }, checkSplitEdgesCorrectness: function (t) {
      var e = this.edge.getCoordinates(),
          n = t.get(0),
          i = n.getCoordinate(0);if (!i.equals2D(e[0])) throw new l("bad split edge start point at " + i);var r = t.get(t.size() - 1),
          s = r.getCoordinates(),
          o = s[s.length - 1];if (!o.equals2D(e[e.length - 1])) throw new l("bad split edge end point at " + o);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return He;
    } }), e(We.prototype, { next: function () {
      return null === this.currNode ? (this.currNode = this.nextNode, this.currSegIndex = this.currNode.segmentIndex, this.readNextNode(), this.currNode) : null === this.nextNode ? null : this.nextNode.segmentIndex === this.currNode.segmentIndex ? (this.currNode = this.nextNode, this.currSegIndex = this.currNode.segmentIndex, this.readNextNode(), this.currNode) : (this.nextNode.segmentIndex > this.currNode.segmentIndex, null);
    }, remove: function () {
      throw new UnsupportedOperationException(this.getClass().getName());
    }, hasNext: function () {
      return null !== this.nextNode;
    }, readNextNode: function () {
      this.nodeIt.hasNext() ? this.nextNode = this.nodeIt.next() : this.nextNode = null;
    }, interfaces_: function () {
      return [p];
    }, getClass: function () {
      return We;
    } }), e(je.prototype, { addIntersection: function (t, e) {}, interfaces_: function () {
      return [be];
    }, getClass: function () {
      return je;
    } }), e(Ke.prototype, { getCoordinates: function () {
      return this.pts;
    }, size: function () {
      return this.pts.length;
    }, getCoordinate: function (t) {
      return this.pts[t];
    }, isClosed: function () {
      return this.pts[0].equals(this.pts[this.pts.length - 1]);
    }, getSegmentOctant: function (t) {
      return t === this.pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(t), this.getCoordinate(t + 1));
    }, setData: function (t) {
      this.data = t;
    }, safeOctant: function (t, e) {
      return t.equals2D(e) ? 0 : Pe.octant(t, e);
    }, getData: function () {
      return this.data;
    }, addIntersection: function () {
      if (2 === arguments.length) {
        var t = arguments[0],
            e = arguments[1];this.addIntersectionNode(t, e);
      } else if (4 === arguments.length) {
        var n = arguments[0],
            i = arguments[1],
            r = (arguments[2], arguments[3]),
            s = new g(n.getIntersection(r));this.addIntersection(s, i);
      }
    }, toString: function () {
      return se.toLineString(new Gt(this.pts));
    }, getNodeList: function () {
      return this.nodeList;
    }, addIntersectionNode: function (t, e) {
      var n = e,
          i = n + 1;if (i < this.pts.length) {
        var r = this.pts[i];t.equals2D(r) && (n = i);
      }var s = this.nodeList.add(t, n);return s;
    }, addIntersections: function (t, e, n) {
      for (var i = 0; i < t.getIntersectionNum(); i++) this.addIntersection(t, e, n, i);
    }, interfaces_: function () {
      return [je];
    }, getClass: function () {
      return Ke;
    } }), Ke.getNodedSubstrings = function () {
    if (1 === arguments.length) {
      var t = arguments[0],
          e = new I();return Ke.getNodedSubstrings(t, e), e;
    }if (2 === arguments.length) for (var n = arguments[0], i = arguments[1], r = n.iterator(); r.hasNext();) {
      var s = r.next();s.getNodeList().addSplitEdges(i);
    }
  }, e(Ze.prototype, { overlap: function () {
      if (2 === arguments.length) {
        arguments[0], arguments[1];
      } else if (4 === arguments.length) {
        var t = arguments[0],
            e = arguments[1],
            n = arguments[2],
            i = arguments[3];t.getLineSegment(e, this.overlapSeg1), n.getLineSegment(i, this.overlapSeg2), this.overlap(this.overlapSeg1, this.overlapSeg2);
      }
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Ze;
    } }), e(Qe.prototype, { getLineSegment: function (t, e) {
      e.p0 = this.pts[t], e.p1 = this.pts[t + 1];
    }, computeSelect: function (t, e, n, i) {
      var r = this.pts[e],
          s = this.pts[n];if (i.tempEnv1.init(r, s), n - e === 1) return i.select(this, e), null;if (!t.intersects(i.tempEnv1)) return null;var o = Math.trunc((e + n) / 2);e < o && this.computeSelect(t, e, o, i), o < n && this.computeSelect(t, o, n, i);
    }, getCoordinates: function () {
      for (var t = new Array(this.end - this.start + 1).fill(null), e = 0, n = this.start; n <= this.end; n++) t[e++] = this.pts[n];return t;
    }, computeOverlaps: function (t, e) {
      this.computeOverlapsInternal(this.start, this.end, t, t.start, t.end, e);
    }, setId: function (t) {
      this.id = t;
    }, select: function (t, e) {
      this.computeSelect(t, this.start, this.end, e);
    }, getEnvelope: function () {
      if (null === this.env) {
        var t = this.pts[this.start],
            e = this.pts[this.end];this.env = new C(t, e);
      }return this.env;
    }, getEndIndex: function () {
      return this.end;
    }, getStartIndex: function () {
      return this.start;
    }, getContext: function () {
      return this.context;
    }, getId: function () {
      return this.id;
    }, computeOverlapsInternal: function (t, e, n, i, r, s) {
      var o = this.pts[t],
          a = this.pts[e],
          u = n.pts[i],
          l = n.pts[r];if (e - t === 1 && r - i === 1) return s.overlap(this, t, n, i), null;if (s.tempEnv1.init(o, a), s.tempEnv2.init(u, l), !s.tempEnv1.intersects(s.tempEnv2)) return null;var h = Math.trunc((t + e) / 2),
          c = Math.trunc((i + r) / 2);t < h && (i < c && this.computeOverlapsInternal(t, h, n, i, c, s), c < r && this.computeOverlapsInternal(t, h, n, c, r, s)), h < e && (i < c && this.computeOverlapsInternal(h, e, n, i, c, s), c < r && this.computeOverlapsInternal(h, e, n, c, r, s));
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Qe;
    } }), e(Je.prototype, { interfaces_: function () {
      return [];
    }, getClass: function () {
      return Je;
    } }), Je.isNorthern = function (t) {
    return t === Je.NE || t === Je.NW;
  }, Je.isOpposite = function (t, e) {
    if (t === e) return !1;var n = (t - e + 4) % 4;return 2 === n;
  }, Je.commonHalfPlane = function (t, e) {
    if (t === e) return t;var n = (t - e + 4) % 4;if (2 === n) return -1;var i = t < e ? t : e,
        r = t > e ? t : e;return 0 === i && 3 === r ? 3 : i;
  }, Je.isInHalfPlane = function (t, e) {
    return e === Je.SE ? t === Je.SE || t === Je.SW : t === e || t === e + 1;
  }, Je.quadrant = function () {
    if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
      var t = arguments[0],
          e = arguments[1];if (0 === t && 0 === e) throw new i("Cannot compute the quadrant for point ( " + t + ", " + e + " )");return t >= 0 ? e >= 0 ? Je.NE : Je.SE : e >= 0 ? Je.NW : Je.SW;
    }if (arguments[0] instanceof g && arguments[1] instanceof g) {
      var n = arguments[0],
          r = arguments[1];if (r.x === n.x && r.y === n.y) throw new i("Cannot compute the quadrant for two identical points " + n);return r.x >= n.x ? r.y >= n.y ? Je.NE : Je.SE : r.y >= n.y ? Je.NW : Je.SW;
    }
  }, Je.NE = 0, Je.NW = 1, Je.SW = 2, Je.SE = 3, e($e.prototype, { interfaces_: function () {
      return [];
    }, getClass: function () {
      return $e;
    } }), $e.getChainStartIndices = function (t) {
    var e = 0,
        n = new I();n.add(new b(e));do {
      var i = $e.findChainEnd(t, e);n.add(new b(i)), e = i;
    } while (e < t.length - 1);var r = $e.toIntArray(n);return r;
  }, $e.findChainEnd = function (t, e) {
    for (var n = e; n < t.length - 1 && t[n].equals2D(t[n + 1]);) n++;if (n >= t.length - 1) return t.length - 1;for (var i = Je.quadrant(t[n], t[n + 1]), r = e + 1; r < t.length;) {
      if (!t[r - 1].equals2D(t[r])) {
        var s = Je.quadrant(t[r - 1], t[r]);if (s !== i) break;
      }r++;
    }return r - 1;
  }, $e.getChains = function () {
    if (1 === arguments.length) {
      var t = arguments[0];return $e.getChains(t, null);
    }if (2 === arguments.length) {
      for (var e = arguments[0], n = arguments[1], i = new I(), r = $e.getChainStartIndices(e), s = 0; s < r.length - 1; s++) {
        var o = new Qe(e, r[s], r[s + 1], n);i.add(o);
      }return i;
    }
  }, $e.toIntArray = function (t) {
    for (var e = new Array(t.size()).fill(null), n = 0; n < e.length; n++) e[n] = t.get(n).intValue();return e;
  }, e(tn.prototype, { computeNodes: function (t) {}, getNodedSubstrings: function () {}, interfaces_: function () {
      return [];
    }, getClass: function () {
      return tn;
    } }), e(en.prototype, { setSegmentIntersector: function (t) {
      this.segInt = t;
    }, interfaces_: function () {
      return [tn];
    }, getClass: function () {
      return en;
    } }), h(nn, en), e(nn.prototype, { getMonotoneChains: function () {
      return this.monoChains;
    }, getNodedSubstrings: function () {
      return Ke.getNodedSubstrings(this.nodedSegStrings);
    }, getIndex: function () {
      return this.index;
    }, add: function (t) {
      for (var e = $e.getChains(t.getCoordinates(), t), n = e.iterator(); n.hasNext();) {
        var i = n.next();i.setId(this.idCounter++), this.index.insert(i.getEnvelope(), i), this.monoChains.add(i);
      }
    }, computeNodes: function (t) {
      this.nodedSegStrings = t;for (var e = t.iterator(); e.hasNext();) this.add(e.next());this.intersectChains();
    }, intersectChains: function () {
      for (var t = new rn(this.segInt), e = this.monoChains.iterator(); e.hasNext();) for (var n = e.next(), i = this.index.query(n.getEnvelope()), r = i.iterator(); r.hasNext();) {
        var s = r.next();if (s.getId() > n.getId() && (n.computeOverlaps(s, t), this.nOverlaps++), this.segInt.isDone()) return null;
      }
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return nn;
    } }), h(rn, Ze), e(rn.prototype, { overlap: function () {
      if (4 !== arguments.length) return Ze.prototype.overlap.apply(this, arguments);var t = arguments[0],
          e = arguments[1],
          n = arguments[2],
          i = arguments[3],
          r = t.getContext(),
          s = n.getContext();this.si.processIntersections(r, e, s, i);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return rn;
    } }), nn.SegmentOverlapAction = rn, h(sn, l), e(sn.prototype, { getCoordinate: function () {
      return this.pt;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return sn;
    } }), sn.msgWithCoord = function (t, e) {
    return null !== e ? t + " [ " + e + " ]" : t;
  }, e(on.prototype, { processIntersections: function (t, e, n, i) {}, isDone: function () {}, interfaces_: function () {
      return [];
    }, getClass: function () {
      return on;
    } }), e(an.prototype, { getInteriorIntersection: function () {
      return this.interiorIntersection;
    }, setCheckEndSegmentsOnly: function (t) {
      this.isCheckEndSegmentsOnly = t;
    }, getIntersectionSegments: function () {
      return this.intSegments;
    }, count: function () {
      return this.intersectionCount;
    }, getIntersections: function () {
      return this.intersections;
    }, setFindAllIntersections: function (t) {
      this.findAllIntersections = t;
    }, setKeepIntersections: function (t) {
      this.keepIntersections = t;
    }, processIntersections: function (t, e, n, i) {
      if (!this.findAllIntersections && this.hasIntersection()) return null;if (t === n && e === i) return null;if (this.isCheckEndSegmentsOnly) {
        var r = this.isEndSegment(t, e) || this.isEndSegment(n, i);if (!r) return null;
      }var s = t.getCoordinates()[e],
          o = t.getCoordinates()[e + 1],
          a = n.getCoordinates()[i],
          u = n.getCoordinates()[i + 1];this.li.computeIntersection(s, o, a, u), this.li.hasIntersection() && this.li.isInteriorIntersection() && (this.intSegments = new Array(4).fill(null), this.intSegments[0] = s, this.intSegments[1] = o, this.intSegments[2] = a, this.intSegments[3] = u, this.interiorIntersection = this.li.getIntersection(0), this.keepIntersections && this.intersections.add(this.interiorIntersection), this.intersectionCount++);
    }, isEndSegment: function (t, e) {
      return 0 === e || e >= t.size() - 2;
    }, hasIntersection: function () {
      return null !== this.interiorIntersection;
    }, isDone: function () {
      return !this.findAllIntersections && null !== this.interiorIntersection;
    }, interfaces_: function () {
      return [on];
    }, getClass: function () {
      return an;
    } }), an.createAllIntersectionsFinder = function (t) {
    var e = new an(t);return e.setFindAllIntersections(!0), e;
  }, an.createAnyIntersectionFinder = function (t) {
    return new an(t);
  }, an.createIntersectionCounter = function (t) {
    var e = new an(t);return e.setFindAllIntersections(!0), e.setKeepIntersections(!1), e;
  }, e(un.prototype, { execute: function () {
      return null !== this.segInt ? null : void this.checkInteriorIntersections();
    }, getIntersections: function () {
      return this.segInt.getIntersections();
    }, isValid: function () {
      return this.execute(), this._isValid;
    }, setFindAllIntersections: function (t) {
      this.findAllIntersections = t;
    }, checkInteriorIntersections: function () {
      this._isValid = !0, this.segInt = new an(this.li), this.segInt.setFindAllIntersections(this.findAllIntersections);var t = new nn();if (t.setSegmentIntersector(this.segInt), t.computeNodes(this.segStrings), this.segInt.hasIntersection()) return this._isValid = !1, null;
    }, checkValid: function () {
      if (this.execute(), !this._isValid) throw new sn(this.getErrorMessage(), this.segInt.getInteriorIntersection());
    }, getErrorMessage: function () {
      if (this._isValid) return "no intersections found";var t = this.segInt.getIntersectionSegments();return "found non-noded intersection between " + se.toLineString(t[0], t[1]) + " and " + se.toLineString(t[2], t[3]);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return un;
    } }), un.computeIntersections = function (t) {
    var e = new un(t);return e.setFindAllIntersections(!0), e.isValid(), e.getIntersections();
  }, e(ln.prototype, { checkValid: function () {
      this.nv.checkValid();
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return ln;
    } }), ln.toSegmentStrings = function (t) {
    for (var e = new I(), n = t.iterator(); n.hasNext();) {
      var i = n.next();e.add(new Oe(i.getCoordinates(), i));
    }return e;
  }, ln.checkValid = function (t) {
    var e = new ln(t);e.checkValid();
  }, e(hn.prototype, { map: function (t) {
      for (var e = new I(), n = 0; n < t.getNumGeometries(); n++) {
        var i = this.mapOp.map(t.getGeometryN(n));i.isEmpty() || e.add(i);
      }return t.getFactory().createGeometryCollection(ie.toGeometryArray(e));
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return hn;
    } }), hn.map = function (t, e) {
    var n = new hn(e);return n.map(t);
  }, e(cn.prototype, { interfaces_: function () {
      return [];
    }, getClass: function () {
      return cn;
    } }), cn.opposite = function (t) {
    return t === cn.LEFT ? cn.RIGHT : t === cn.RIGHT ? cn.LEFT : t;
  }, cn.ON = 0, cn.LEFT = 1, cn.RIGHT = 2, e(fn.prototype, { setAllLocations: function (t) {
      for (var e = 0; e < this.location.length; e++) this.location[e] = t;
    }, isNull: function () {
      for (var t = 0; t < this.location.length; t++) if (this.location[t] !== L.NONE) return !1;return !0;
    }, setAllLocationsIfNull: function (t) {
      for (var e = 0; e < this.location.length; e++) this.location[e] === L.NONE && (this.location[e] = t);
    }, isLine: function () {
      return 1 === this.location.length;
    }, merge: function (t) {
      if (t.location.length > this.location.length) {
        var e = new Array(3).fill(null);e[cn.ON] = this.location[cn.ON], e[cn.LEFT] = L.NONE, e[cn.RIGHT] = L.NONE, this.location = e;
      }for (var n = 0; n < this.location.length; n++) this.location[n] === L.NONE && n < t.location.length && (this.location[n] = t.location[n]);
    }, getLocations: function () {
      return this.location;
    }, flip: function () {
      if (this.location.length <= 1) return null;var t = this.location[cn.LEFT];this.location[cn.LEFT] = this.location[cn.RIGHT], this.location[cn.RIGHT] = t;
    }, toString: function () {
      var t = new P();return this.location.length > 1 && t.append(L.toLocationSymbol(this.location[cn.LEFT])), t.append(L.toLocationSymbol(this.location[cn.ON])), this.location.length > 1 && t.append(L.toLocationSymbol(this.location[cn.RIGHT])), t.toString();
    }, setLocations: function (t, e, n) {
      this.location[cn.ON] = t, this.location[cn.LEFT] = e, this.location[cn.RIGHT] = n;
    }, get: function (t) {
      return t < this.location.length ? this.location[t] : L.NONE;
    }, isArea: function () {
      return this.location.length > 1;
    }, isAnyNull: function () {
      for (var t = 0; t < this.location.length; t++) if (this.location[t] === L.NONE) return !0;return !1;
    }, setLocation: function () {
      if (1 === arguments.length) {
        var t = arguments[0];this.setLocation(cn.ON, t);
      } else if (2 === arguments.length) {
        var e = arguments[0],
            n = arguments[1];this.location[e] = n;
      }
    }, init: function (t) {
      this.location = new Array(t).fill(null), this.setAllLocations(L.NONE);
    }, isEqualOnSide: function (t, e) {
      return this.location[e] === t.location[e];
    }, allPositionsEqual: function (t) {
      for (var e = 0; e < this.location.length; e++) if (this.location[e] !== t) return !1;return !0;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return fn;
    } }), e(gn.prototype, { getGeometryCount: function () {
      var t = 0;return this.elt[0].isNull() || t++, this.elt[1].isNull() || t++, t;
    }, setAllLocations: function (t, e) {
      this.elt[t].setAllLocations(e);
    }, isNull: function (t) {
      return this.elt[t].isNull();
    }, setAllLocationsIfNull: function () {
      if (1 === arguments.length) {
        var t = arguments[0];this.setAllLocationsIfNull(0, t), this.setAllLocationsIfNull(1, t);
      } else if (2 === arguments.length) {
        var e = arguments[0],
            n = arguments[1];this.elt[e].setAllLocationsIfNull(n);
      }
    }, isLine: function (t) {
      return this.elt[t].isLine();
    }, merge: function (t) {
      for (var e = 0; e < 2; e++) null === this.elt[e] && null !== t.elt[e] ? this.elt[e] = new fn(t.elt[e]) : this.elt[e].merge(t.elt[e]);
    }, flip: function () {
      this.elt[0].flip(), this.elt[1].flip();
    }, getLocation: function () {
      if (1 === arguments.length) {
        var t = arguments[0];return this.elt[t].get(cn.ON);
      }if (2 === arguments.length) {
        var e = arguments[0],
            n = arguments[1];return this.elt[e].get(n);
      }
    }, toString: function () {
      var t = new P();return null !== this.elt[0] && (t.append("A:"), t.append(this.elt[0].toString())), null !== this.elt[1] && (t.append(" B:"), t.append(this.elt[1].toString())), t.toString();
    }, isArea: function () {
      if (0 === arguments.length) return this.elt[0].isArea() || this.elt[1].isArea();if (1 === arguments.length) {
        var t = arguments[0];return this.elt[t].isArea();
      }
    }, isAnyNull: function (t) {
      return this.elt[t].isAnyNull();
    }, setLocation: function () {
      if (2 === arguments.length) {
        var t = arguments[0],
            e = arguments[1];this.elt[t].setLocation(cn.ON, e);
      } else if (3 === arguments.length) {
        var n = arguments[0],
            i = arguments[1],
            r = arguments[2];this.elt[n].setLocation(i, r);
      }
    }, isEqualOnSide: function (t, e) {
      return this.elt[0].isEqualOnSide(t.elt[0], e) && this.elt[1].isEqualOnSide(t.elt[1], e);
    }, allPositionsEqual: function (t, e) {
      return this.elt[t].allPositionsEqual(e);
    }, toLine: function (t) {
      this.elt[t].isArea() && (this.elt[t] = new fn(this.elt[t].location[0]));
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return gn;
    } }), gn.toLineLabel = function (t) {
    for (var e = new gn(L.NONE), n = 0; n < 2; n++) e.setLocation(n, t.getLocation(n));return e;
  }, e(dn.prototype, { computeRing: function () {
      if (null !== this.ring) return null;for (var t = new Array(this.pts.size()).fill(null), e = 0; e < this.pts.size(); e++) t[e] = this.pts.get(e);this.ring = this.geometryFactory.createLinearRing(t), this._isHole = he.isCCW(this.ring.getCoordinates());
    }, isIsolated: function () {
      return 1 === this.label.getGeometryCount();
    }, computePoints: function (t) {
      this.startDe = t;var e = t,
          n = !0;do {
        if (null === e) throw new sn("Found null DirectedEdge");if (e.getEdgeRing() === this) throw new sn("Directed Edge visited twice during ring-building at " + e.getCoordinate());this.edges.add(e);var i = e.getLabel();f.isTrue(i.isArea()), this.mergeLabel(i), this.addPoints(e.getEdge(), e.isForward(), n), n = !1, this.setEdgeRing(e, this), e = this.getNext(e);
      } while (e !== this.startDe);
    }, getLinearRing: function () {
      return this.ring;
    }, getCoordinate: function (t) {
      return this.pts.get(t);
    }, computeMaxNodeDegree: function () {
      this.maxNodeDegree = 0;var t = this.startDe;do {
        var e = t.getNode(),
            n = e.getEdges().getOutgoingDegree(this);n > this.maxNodeDegree && (this.maxNodeDegree = n), t = this.getNext(t);
      } while (t !== this.startDe);this.maxNodeDegree *= 2;
    }, addPoints: function (t, e, n) {
      var i = t.getCoordinates();if (e) {
        var r = 1;n && (r = 0);for (var s = r; s < i.length; s++) this.pts.add(i[s]);
      } else {
        var r = i.length - 2;n && (r = i.length - 1);for (var s = r; s >= 0; s--) this.pts.add(i[s]);
      }
    }, isHole: function () {
      return this._isHole;
    }, setInResult: function () {
      var t = this.startDe;do t.getEdge().setInResult(!0), t = t.getNext(); while (t !== this.startDe);
    }, containsPoint: function (t) {
      var e = this.getLinearRing(),
          n = e.getEnvelopeInternal();if (!n.contains(t)) return !1;if (!he.isPointInRing(t, e.getCoordinates())) return !1;for (var i = this.holes.iterator(); i.hasNext();) {
        var r = i.next();if (r.containsPoint(t)) return !1;
      }return !0;
    }, addHole: function (t) {
      this.holes.add(t);
    }, isShell: function () {
      return null === this.shell;
    }, getLabel: function () {
      return this.label;
    }, getEdges: function () {
      return this.edges;
    }, getMaxNodeDegree: function () {
      return this.maxNodeDegree < 0 && this.computeMaxNodeDegree(), this.maxNodeDegree;
    }, getShell: function () {
      return this.shell;
    }, mergeLabel: function () {
      if (1 === arguments.length) {
        var t = arguments[0];this.mergeLabel(t, 0), this.mergeLabel(t, 1);
      } else if (2 === arguments.length) {
        var e = arguments[0],
            n = arguments[1],
            i = e.getLocation(n, cn.RIGHT);if (i === L.NONE) return null;if (this.label.getLocation(n) === L.NONE) return this.label.setLocation(n, i), null;
      }
    }, setShell: function (t) {
      this.shell = t, null !== t && t.addHole(this);
    }, toPolygon: function (t) {
      for (var e = new Array(this.holes.size()).fill(null), n = 0; n < this.holes.size(); n++) e[n] = this.holes.get(n).getLinearRing();var i = t.createPolygon(this.getLinearRing(), e);return i;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return dn;
    } }), h(pn, dn), e(pn.prototype, { setEdgeRing: function (t, e) {
      t.setMinEdgeRing(e);
    }, getNext: function (t) {
      return t.getNextMin();
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return pn;
    } }), h(vn, dn), e(vn.prototype, { buildMinimalRings: function () {
      var t = new I(),
          e = this.startDe;do {
        if (null === e.getMinEdgeRing()) {
          var n = new pn(e, this.geometryFactory);t.add(n);
        }e = e.getNext();
      } while (e !== this.startDe);return t;
    }, setEdgeRing: function (t, e) {
      t.setEdgeRing(e);
    }, linkDirectedEdgesForMinimalEdgeRings: function () {
      var t = this.startDe;do {
        var e = t.getNode();e.getEdges().linkMinimalDirectedEdges(this), t = t.getNext();
      } while (t !== this.startDe);
    }, getNext: function (t) {
      return t.getNext();
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return vn;
    } }), e(mn.prototype, { setVisited: function (t) {
      this._isVisited = t;
    }, setInResult: function (t) {
      this._isInResult = t;
    }, isCovered: function () {
      return this._isCovered;
    }, isCoveredSet: function () {
      return this._isCoveredSet;
    }, setLabel: function (t) {
      this.label = t;
    }, getLabel: function () {
      return this.label;
    }, setCovered: function (t) {
      this._isCovered = t, this._isCoveredSet = !0;
    }, updateIM: function (t) {
      f.isTrue(this.label.getGeometryCount() >= 2, "found partial label"), this.computeIM(t);
    }, isInResult: function () {
      return this._isInResult;
    }, isVisited: function () {
      return this._isVisited;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return mn;
    } }), h(yn, mn), e(yn.prototype, { isIncidentEdgeInResult: function () {
      for (var t = this.getEdges().getEdges().iterator(); t.hasNext();) {
        var e = t.next();if (e.getEdge().isInResult()) return !0;
      }return !1;
    }, isIsolated: function () {
      return 1 === this.label.getGeometryCount();
    }, getCoordinate: function () {
      return this.coord;
    }, print: function (t) {
      t.println("node " + this.coord + " lbl: " + this.label);
    }, computeIM: function (t) {}, computeMergedLocation: function (t, e) {
      var n = L.NONE;if (n = this.label.getLocation(e), !t.isNull(e)) {
        var i = t.getLocation(e);n !== L.BOUNDARY && (n = i);
      }return n;
    }, setLabel: function () {
      if (2 !== arguments.length) return mn.prototype.setLabel.apply(this, arguments);var t = arguments[0],
          e = arguments[1];null === this.label ? this.label = new gn(t, e) : this.label.setLocation(t, e);
    }, getEdges: function () {
      return this.edges;
    }, mergeLabel: function () {
      if (arguments[0] instanceof yn) {
        var t = arguments[0];this.mergeLabel(t.label);
      } else if (arguments[0] instanceof gn) for (var e = arguments[0], n = 0; n < 2; n++) {
        var i = this.computeMergedLocation(e, n),
            r = this.label.getLocation(n);r === L.NONE && this.label.setLocation(n, i);
      }
    }, add: function (t) {
      this.edges.insert(t), t.setNode(this);
    }, setLabelBoundary: function (t) {
      if (null === this.label) return null;var e = L.NONE;null !== this.label && (e = this.label.getLocation(t));var n = null;switch (e) {case L.BOUNDARY:
          n = L.INTERIOR;break;case L.INTERIOR:
          n = L.BOUNDARY;break;default:
          n = L.BOUNDARY;}this.label.setLocation(t, n);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return yn;
    } }), e(xn.prototype, { find: function (t) {
      return this.nodeMap.get(t);
    }, addNode: function () {
      if (arguments[0] instanceof g) {
        var t = arguments[0],
            e = this.nodeMap.get(t);return null === e && (e = this.nodeFact.createNode(t), this.nodeMap.put(t, e)), e;
      }if (arguments[0] instanceof yn) {
        var n = arguments[0],
            e = this.nodeMap.get(n.getCoordinate());return null === e ? (this.nodeMap.put(n.getCoordinate(), n), n) : (e.mergeLabel(n), e);
      }
    }, print: function (t) {
      for (var e = this.iterator(); e.hasNext();) {
        var n = e.next();n.print(t);
      }
    }, iterator: function () {
      return this.nodeMap.values().iterator();
    }, values: function () {
      return this.nodeMap.values();
    }, getBoundaryNodes: function (t) {
      for (var e = new I(), n = this.iterator(); n.hasNext();) {
        var i = n.next();i.getLabel().getLocation(t) === L.BOUNDARY && e.add(i);
      }return e;
    }, add: function (t) {
      var e = t.getCoordinate(),
          n = this.addNode(e);n.add(t);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return xn;
    } }), e(En.prototype, { compareDirection: function (t) {
      return this.dx === t.dx && this.dy === t.dy ? 0 : this.quadrant > t.quadrant ? 1 : this.quadrant < t.quadrant ? -1 : he.computeOrientation(t.p0, t.p1, this.p1);
    }, getDy: function () {
      return this.dy;
    }, getCoordinate: function () {
      return this.p0;
    }, setNode: function (t) {
      this.node = t;
    }, print: function (t) {
      var e = Math.atan2(this.dy, this.dx),
          n = this.getClass().getName(),
          i = n.lastIndexOf("."),
          r = n.substring(i + 1);t.print("  " + r + ": " + this.p0 + " - " + this.p1 + " " + this.quadrant + ":" + e + "   " + this.label);
    }, compareTo: function (t) {
      var e = t;return this.compareDirection(e);
    }, getDirectedCoordinate: function () {
      return this.p1;
    }, getDx: function () {
      return this.dx;
    }, getLabel: function () {
      return this.label;
    }, getEdge: function () {
      return this.edge;
    }, getQuadrant: function () {
      return this.quadrant;
    }, getNode: function () {
      return this.node;
    }, toString: function () {
      var t = Math.atan2(this.dy, this.dx),
          e = this.getClass().getName(),
          n = e.lastIndexOf("."),
          i = e.substring(n + 1);return "  " + i + ": " + this.p0 + " - " + this.p1 + " " + this.quadrant + ":" + t + "   " + this.label;
    }, computeLabel: function (t) {}, init: function (t, e) {
      this.p0 = t, this.p1 = e, this.dx = e.x - t.x, this.dy = e.y - t.y, this.quadrant = Je.quadrant(this.dx, this.dy), f.isTrue(!(0 === this.dx && 0 === this.dy), "EdgeEnd with identical endpoints found");
    }, interfaces_: function () {
      return [s];
    }, getClass: function () {
      return En;
    } }), h(In, En), e(In.prototype, { getNextMin: function () {
      return this.nextMin;
    }, getDepth: function (t) {
      return this.depth[t];
    }, setVisited: function (t) {
      this._isVisited = t;
    }, computeDirectedLabel: function () {
      this.label = new gn(this.edge.getLabel()), this._isForward || this.label.flip();
    }, getNext: function () {
      return this.next;
    }, setDepth: function (t, e) {
      if (this.depth[t] !== -999 && this.depth[t] !== e) throw new sn("assigned depths do not match", this.getCoordinate());this.depth[t] = e;
    }, isInteriorAreaEdge: function t() {
      for (var t = !0, e = 0; e < 2; e++) this.label.isArea(e) && this.label.getLocation(e, cn.LEFT) === L.INTERIOR && this.label.getLocation(e, cn.RIGHT) === L.INTERIOR || (t = !1);return t;
    }, setNextMin: function (t) {
      this.nextMin = t;
    }, print: function (t) {
      En.prototype.print.call(this, t), t.print(" " + this.depth[cn.LEFT] + "/" + this.depth[cn.RIGHT]), t.print(" (" + this.getDepthDelta() + ")"), this._isInResult && t.print(" inResult");
    }, setMinEdgeRing: function (t) {
      this.minEdgeRing = t;
    }, isLineEdge: function () {
      var t = this.label.isLine(0) || this.label.isLine(1),
          e = !this.label.isArea(0) || this.label.allPositionsEqual(0, L.EXTERIOR),
          n = !this.label.isArea(1) || this.label.allPositionsEqual(1, L.EXTERIOR);return t && e && n;
    }, setEdgeRing: function (t) {
      this.edgeRing = t;
    }, getMinEdgeRing: function () {
      return this.minEdgeRing;
    }, getDepthDelta: function () {
      var t = this.edge.getDepthDelta();return this._isForward || (t = -t), t;
    }, setInResult: function (t) {
      this._isInResult = t;
    }, getSym: function () {
      return this.sym;
    }, isForward: function () {
      return this._isForward;
    }, getEdge: function () {
      return this.edge;
    }, printEdge: function (t) {
      this.print(t), t.print(" "), this._isForward ? this.edge.print(t) : this.edge.printReverse(t);
    }, setSym: function (t) {
      this.sym = t;
    }, setVisitedEdge: function (t) {
      this.setVisited(t), this.sym.setVisited(t);
    }, setEdgeDepths: function (t, e) {
      var n = this.getEdge().getDepthDelta();this._isForward || (n = -n);var i = 1;t === cn.LEFT && (i = -1);var r = cn.opposite(t),
          s = n * i,
          o = e + s;this.setDepth(t, e), this.setDepth(r, o);
    }, getEdgeRing: function () {
      return this.edgeRing;
    }, isInResult: function () {
      return this._isInResult;
    }, setNext: function (t) {
      this.next = t;
    }, isVisited: function () {
      return this._isVisited;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return In;
    } }), In.depthFactor = function (t, e) {
    return t === L.EXTERIOR && e === L.INTERIOR ? 1 : t === L.INTERIOR && e === L.EXTERIOR ? -1 : 0;
  }, e(Nn.prototype, { createNode: function (t) {
      return new yn(t, null);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Nn;
    } }), e(Cn.prototype, { printEdges: function (t) {
      t.println("Edges:");for (var e = 0; e < this.edges.size(); e++) {
        t.println("edge " + e + ":");var n = this.edges.get(e);n.print(t), n.eiList.print(t);
      }
    }, find: function (t) {
      return this.nodes.find(t);
    }, addNode: function () {
      if (arguments[0] instanceof yn) {
        var t = arguments[0];return this.nodes.addNode(t);
      }if (arguments[0] instanceof g) {
        var e = arguments[0];return this.nodes.addNode(e);
      }
    }, getNodeIterator: function () {
      return this.nodes.iterator();
    }, linkResultDirectedEdges: function () {
      for (var t = this.nodes.iterator(); t.hasNext();) {
        var e = t.next();e.getEdges().linkResultDirectedEdges();
      }
    }, debugPrintln: function (t) {
      A.out.println(t);
    }, isBoundaryNode: function (t, e) {
      var n = this.nodes.find(e);if (null === n) return !1;var i = n.getLabel();return null !== i && i.getLocation(t) === L.BOUNDARY;
    }, linkAllDirectedEdges: function () {
      for (var t = this.nodes.iterator(); t.hasNext();) {
        var e = t.next();e.getEdges().linkAllDirectedEdges();
      }
    }, matchInSameDirection: function (t, e, n, i) {
      return !!t.equals(n) && he.computeOrientation(t, e, i) === he.COLLINEAR && Je.quadrant(t, e) === Je.quadrant(n, i);
    }, getEdgeEnds: function () {
      return this.edgeEndList;
    }, debugPrint: function (t) {
      A.out.print(t);
    }, getEdgeIterator: function () {
      return this.edges.iterator();
    }, findEdgeInSameDirection: function (t, e) {
      for (var n = 0; n < this.edges.size(); n++) {
        var i = this.edges.get(n),
            r = i.getCoordinates();if (this.matchInSameDirection(t, e, r[0], r[1])) return i;if (this.matchInSameDirection(t, e, r[r.length - 1], r[r.length - 2])) return i;
      }return null;
    }, insertEdge: function (t) {
      this.edges.add(t);
    }, findEdgeEnd: function (t) {
      for (var e = this.getEdgeEnds().iterator(); e.hasNext();) {
        var n = e.next();if (n.getEdge() === t) return n;
      }return null;
    }, addEdges: function (t) {
      for (var e = t.iterator(); e.hasNext();) {
        var n = e.next();this.edges.add(n);var i = new In(n, !0),
            r = new In(n, !1);i.setSym(r), r.setSym(i), this.add(i), this.add(r);
      }
    }, add: function (t) {
      this.nodes.add(t), this.edgeEndList.add(t);
    }, getNodes: function () {
      return this.nodes.values();
    }, findEdge: function (t, e) {
      for (var n = 0; n < this.edges.size(); n++) {
        var i = this.edges.get(n),
            r = i.getCoordinates();if (t.equals(r[0]) && e.equals(r[1])) return i;
      }return null;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Cn;
    } }), Cn.linkResultDirectedEdges = function (t) {
    for (var e = t.iterator(); e.hasNext();) {
      var n = e.next();n.getEdges().linkResultDirectedEdges();
    }
  }, e(Sn.prototype, { sortShellsAndHoles: function (t, e, n) {
      for (var i = t.iterator(); i.hasNext();) {
        var r = i.next();r.isHole() ? n.add(r) : e.add(r);
      }
    }, computePolygons: function (t) {
      for (var e = new I(), n = t.iterator(); n.hasNext();) {
        var i = n.next(),
            r = i.toPolygon(this.geometryFactory);e.add(r);
      }return e;
    }, placeFreeHoles: function (t, e) {
      for (var n = e.iterator(); n.hasNext();) {
        var i = n.next();if (null === i.getShell()) {
          var r = this.findEdgeRingContaining(i, t);if (null === r) throw new sn("unable to assign hole to a shell", i.getCoordinate(0));i.setShell(r);
        }
      }
    }, buildMinimalEdgeRings: function (t, e, n) {
      for (var i = new I(), r = t.iterator(); r.hasNext();) {
        var s = r.next();if (s.getMaxNodeDegree() > 2) {
          s.linkDirectedEdgesForMinimalEdgeRings();var o = s.buildMinimalRings(),
              a = this.findShell(o);null !== a ? (this.placePolygonHoles(a, o), e.add(a)) : n.addAll(o);
        } else i.add(s);
      }return i;
    }, containsPoint: function (t) {
      for (var e = this.shellList.iterator(); e.hasNext();) {
        var n = e.next();if (n.containsPoint(t)) return !0;
      }return !1;
    }, buildMaximalEdgeRings: function (t) {
      for (var e = new I(), n = t.iterator(); n.hasNext();) {
        var i = n.next();if (i.isInResult() && i.getLabel().isArea() && null === i.getEdgeRing()) {
          var r = new vn(i, this.geometryFactory);e.add(r), r.setInResult();
        }
      }return e;
    }, placePolygonHoles: function (t, e) {
      for (var n = e.iterator(); n.hasNext();) {
        var i = n.next();i.isHole() && i.setShell(t);
      }
    }, getPolygons: function () {
      var t = this.computePolygons(this.shellList);return t;
    }, findEdgeRingContaining: function (t, e) {
      for (var n = t.getLinearRing(), i = n.getEnvelopeInternal(), r = n.getCoordinateN(0), s = null, o = null, a = e.iterator(); a.hasNext();) {
        var u = a.next(),
            l = u.getLinearRing(),
            h = l.getEnvelopeInternal();null !== s && (o = s.getLinearRing().getEnvelopeInternal());var c = !1;h.contains(i) && he.isPointInRing(r, l.getCoordinates()) && (c = !0), c && (null === s || o.contains(h)) && (s = u);
      }return s;
    }, findShell: function (t) {
      for (var e = 0, n = null, i = t.iterator(); i.hasNext();) {
        var r = i.next();r.isHole() || (n = r, e++);
      }return f.isTrue(e <= 1, "found two shells in MinimalEdgeRing list"), n;
    }, add: function () {
      if (1 === arguments.length) {
        var t = arguments[0];this.add(t.getEdgeEnds(), t.getNodes());
      } else if (2 === arguments.length) {
        var e = arguments[0],
            n = arguments[1];Cn.linkResultDirectedEdges(n);var i = this.buildMaximalEdgeRings(e),
            r = new I(),
            s = this.buildMinimalEdgeRings(i, this.shellList, r);this.sortShellsAndHoles(s, this.shellList, r), this.placeFreeHoles(this.shellList, r);
      }
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Sn;
    } }), e(wn.prototype, { collectLines: function (t) {
      for (var e = this.op.getGraph().getEdgeEnds().iterator(); e.hasNext();) {
        var n = e.next();this.collectLineEdge(n, t, this.lineEdgesList), this.collectBoundaryTouchEdge(n, t, this.lineEdgesList);
      }
    }, labelIsolatedLine: function (t, e) {
      var n = this.ptLocator.locate(t.getCoordinate(), this.op.getArgGeometry(e));t.getLabel().setLocation(e, n);
    }, build: function (t) {
      return this.findCoveredLineEdges(), this.collectLines(t), this.buildLines(t), this.resultLineList;
    }, collectLineEdge: function (t, e, n) {
      var i = t.getLabel(),
          r = t.getEdge();t.isLineEdge() && (t.isVisited() || !ii.isResultOfOp(i, e) || r.isCovered() || (n.add(r), t.setVisitedEdge(!0)));
    }, findCoveredLineEdges: function () {
      for (var t = this.op.getGraph().getNodes().iterator(); t.hasNext();) {
        var e = t.next();e.getEdges().findCoveredLineEdges();
      }for (var n = this.op.getGraph().getEdgeEnds().iterator(); n.hasNext();) {
        var i = n.next(),
            r = i.getEdge();if (i.isLineEdge() && !r.isCoveredSet()) {
          var s = this.op.isCoveredByA(i.getCoordinate());r.setCovered(s);
        }
      }
    }, labelIsolatedLines: function (t) {
      for (var e = t.iterator(); e.hasNext();) {
        var n = e.next(),
            i = n.getLabel();n.isIsolated() && (i.isNull(0) ? this.labelIsolatedLine(n, 0) : this.labelIsolatedLine(n, 1));
      }
    }, buildLines: function (t) {
      for (var e = this.lineEdgesList.iterator(); e.hasNext();) {
        var n = e.next(),
            i = (n.getLabel(), this.geometryFactory.createLineString(n.getCoordinates()));this.resultLineList.add(i), n.setInResult(!0);
      }
    }, collectBoundaryTouchEdge: function (t, e, n) {
      var i = t.getLabel();return t.isLineEdge() ? null : t.isVisited() ? null : t.isInteriorAreaEdge() ? null : t.getEdge().isInResult() ? null : (f.isTrue(!(t.isInResult() || t.getSym().isInResult()) || !t.getEdge().isInResult()), void (ii.isResultOfOp(i, e) && e === ii.INTERSECTION && (n.add(t.getEdge()), t.setVisitedEdge(!0))));
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return wn;
    } }), e(Ln.prototype, { filterCoveredNodeToPoint: function (t) {
      var e = t.getCoordinate();if (!this.op.isCoveredByLA(e)) {
        var n = this.geometryFactory.createPoint(e);this.resultPointList.add(n);
      }
    }, extractNonCoveredResultNodes: function (t) {
      for (var e = this.op.getGraph().getNodes().iterator(); e.hasNext();) {
        var n = e.next();if (!(n.isInResult() || n.isIncidentEdgeInResult() || 0 !== n.getEdges().getDegree() && t !== ii.INTERSECTION)) {
          var i = n.getLabel();ii.isResultOfOp(i, t) && this.filterCoveredNodeToPoint(n);
        }
      }
    }, build: function (t) {
      return this.extractNonCoveredResultNodes(t), this.resultPointList;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Ln;
    } }), e(Rn.prototype, { locate: function (t) {}, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Rn;
    } }), e(Tn.prototype, { locate: function (t) {
      return Tn.locate(t, this.geom);
    }, interfaces_: function () {
      return [Rn];
    }, getClass: function () {
      return Tn;
    } }), Tn.isPointInRing = function (t, e) {
    return !!e.getEnvelopeInternal().intersects(t) && he.isPointInRing(t, e.getCoordinates());
  }, Tn.containsPointInPolygon = function (t, e) {
    if (e.isEmpty()) return !1;var n = e.getExteriorRing();if (!Tn.isPointInRing(t, n)) return !1;for (var i = 0; i < e.getNumInteriorRing(); i++) {
      var r = e.getInteriorRingN(i);if (Tn.isPointInRing(t, r)) return !1;
    }return !0;
  }, Tn.containsPoint = function (t, e) {
    if (e instanceof Tt) return Tn.containsPointInPolygon(t, e);if (e instanceof ft) for (var n = new Re(e); n.hasNext();) {
      var i = n.next();if (i !== e && Tn.containsPoint(t, i)) return !0;
    }return !1;
  }, Tn.locate = function (t, e) {
    return e.isEmpty() ? L.EXTERIOR : Tn.containsPoint(t, e) ? L.INTERIOR : L.EXTERIOR;
  }, e(Pn.prototype, { getNextCW: function (t) {
      this.getEdges();var e = this.edgeList.indexOf(t),
          n = e - 1;return 0 === e && (n = this.edgeList.size() - 1), this.edgeList.get(n);
    }, propagateSideLabels: function (t) {
      for (var e = L.NONE, n = this.iterator(); n.hasNext();) {
        var i = n.next(),
            r = i.getLabel();r.isArea(t) && r.getLocation(t, cn.LEFT) !== L.NONE && (e = r.getLocation(t, cn.LEFT));
      }if (e === L.NONE) return null;for (var s = e, n = this.iterator(); n.hasNext();) {
        var i = n.next(),
            r = i.getLabel();if (r.getLocation(t, cn.ON) === L.NONE && r.setLocation(t, cn.ON, s), r.isArea(t)) {
          var o = r.getLocation(t, cn.LEFT),
              a = r.getLocation(t, cn.RIGHT);if (a !== L.NONE) {
            if (a !== s) throw new sn("side location conflict", i.getCoordinate());o === L.NONE && f.shouldNeverReachHere("found single null side (at " + i.getCoordinate() + ")"), s = o;
          } else f.isTrue(r.getLocation(t, cn.LEFT) === L.NONE, "found single null side"), r.setLocation(t, cn.RIGHT, s), r.setLocation(t, cn.LEFT, s);
        }
      }
    }, getCoordinate: function () {
      var t = this.iterator();if (!t.hasNext()) return null;var e = t.next();return e.getCoordinate();
    }, print: function (t) {
      A.out.println("EdgeEndStar:   " + this.getCoordinate());for (var e = this.iterator(); e.hasNext();) {
        var n = e.next();
        n.print(t);
      }
    }, isAreaLabelsConsistent: function (t) {
      return this.computeEdgeEndLabels(t.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0);
    }, checkAreaLabelsConsistent: function (t) {
      var e = this.getEdges();if (e.size() <= 0) return !0;var n = e.size() - 1,
          i = e.get(n).getLabel(),
          r = i.getLocation(t, cn.LEFT);f.isTrue(r !== L.NONE, "Found unlabelled area edge");for (var s = r, o = this.iterator(); o.hasNext();) {
        var a = o.next(),
            u = a.getLabel();f.isTrue(u.isArea(t), "Found non-area edge");var l = u.getLocation(t, cn.LEFT),
            h = u.getLocation(t, cn.RIGHT);if (l === h) return !1;if (h !== s) return !1;s = l;
      }return !0;
    }, findIndex: function (t) {
      this.iterator();for (var e = 0; e < this.edgeList.size(); e++) {
        var n = this.edgeList.get(e);if (n === t) return e;
      }return -1;
    }, iterator: function () {
      return this.getEdges().iterator();
    }, getEdges: function () {
      return null === this.edgeList && (this.edgeList = new I(this.edgeMap.values())), this.edgeList;
    }, getLocation: function (t, e, n) {
      return this.ptInAreaLocation[t] === L.NONE && (this.ptInAreaLocation[t] = Tn.locate(e, n[t].getGeometry())), this.ptInAreaLocation[t];
    }, toString: function () {
      var t = new P();t.append("EdgeEndStar:   " + this.getCoordinate()), t.append("\n");for (var e = this.iterator(); e.hasNext();) {
        var n = e.next();t.append(n), t.append("\n");
      }return t.toString();
    }, computeEdgeEndLabels: function (t) {
      for (var e = this.iterator(); e.hasNext();) {
        var n = e.next();n.computeLabel(t);
      }
    }, computeLabelling: function (t) {
      this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()), this.propagateSideLabels(0), this.propagateSideLabels(1);for (var e = [!1, !1], n = this.iterator(); n.hasNext();) for (var i = n.next(), r = i.getLabel(), s = 0; s < 2; s++) r.isLine(s) && r.getLocation(s) === L.BOUNDARY && (e[s] = !0);for (var n = this.iterator(); n.hasNext();) for (var i = n.next(), r = i.getLabel(), s = 0; s < 2; s++) if (r.isAnyNull(s)) {
        var o = L.NONE;if (e[s]) o = L.EXTERIOR;else {
          var a = i.getCoordinate();o = this.getLocation(s, a, t);
        }r.setAllLocationsIfNull(s, o);
      }
    }, getDegree: function () {
      return this.edgeMap.size();
    }, insertEdgeEnd: function (t, e) {
      this.edgeMap.put(t, e), this.edgeList = null;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Pn;
    } }), h(bn, Pn), e(bn.prototype, { linkResultDirectedEdges: function () {
      this.getResultAreaEdges();for (var t = null, e = null, n = this.SCANNING_FOR_INCOMING, i = 0; i < this.resultAreaEdgeList.size(); i++) {
        var r = this.resultAreaEdgeList.get(i),
            s = r.getSym();if (r.getLabel().isArea()) switch (null === t && r.isInResult() && (t = r), n) {case this.SCANNING_FOR_INCOMING:
            if (!s.isInResult()) continue;e = s, n = this.LINKING_TO_OUTGOING;break;case this.LINKING_TO_OUTGOING:
            if (!r.isInResult()) continue;e.setNext(r), n = this.SCANNING_FOR_INCOMING;}
      }if (n === this.LINKING_TO_OUTGOING) {
        if (null === t) throw new sn("no outgoing dirEdge found", this.getCoordinate());f.isTrue(t.isInResult(), "unable to link last incoming dirEdge"), e.setNext(t);
      }
    }, insert: function (t) {
      var e = t;this.insertEdgeEnd(e, e);
    }, getRightmostEdge: function () {
      var t = this.getEdges(),
          e = t.size();if (e < 1) return null;var n = t.get(0);if (1 === e) return n;var i = t.get(e - 1),
          r = n.getQuadrant(),
          s = i.getQuadrant();if (Je.isNorthern(r) && Je.isNorthern(s)) return n;if (!Je.isNorthern(r) && !Je.isNorthern(s)) return i;return 0 !== n.getDy() ? n : 0 !== i.getDy() ? i : (f.shouldNeverReachHere("found two horizontal edges incident on node"), null);
    }, print: function (t) {
      A.out.println("DirectedEdgeStar: " + this.getCoordinate());for (var e = this.iterator(); e.hasNext();) {
        var n = e.next();t.print("out "), n.print(t), t.println(), t.print("in "), n.getSym().print(t), t.println();
      }
    }, getResultAreaEdges: function () {
      if (null !== this.resultAreaEdgeList) return this.resultAreaEdgeList;this.resultAreaEdgeList = new I();for (var t = this.iterator(); t.hasNext();) {
        var e = t.next();(e.isInResult() || e.getSym().isInResult()) && this.resultAreaEdgeList.add(e);
      }return this.resultAreaEdgeList;
    }, updateLabelling: function (t) {
      for (var e = this.iterator(); e.hasNext();) {
        var n = e.next(),
            i = n.getLabel();i.setAllLocationsIfNull(0, t.getLocation(0)), i.setAllLocationsIfNull(1, t.getLocation(1));
      }
    }, linkAllDirectedEdges: function () {
      this.getEdges();for (var t = null, e = null, n = this.edgeList.size() - 1; n >= 0; n--) {
        var i = this.edgeList.get(n),
            r = i.getSym();null === e && (e = r), null !== t && r.setNext(t), t = i;
      }e.setNext(t);
    }, computeDepths: function () {
      if (1 === arguments.length) {
        var t = arguments[0],
            e = this.findIndex(t),
            n = (t.getLabel(), t.getDepth(cn.LEFT)),
            i = t.getDepth(cn.RIGHT),
            r = this.computeDepths(e + 1, this.edgeList.size(), n),
            s = this.computeDepths(0, e, r);if (s !== i) throw new sn("depth mismatch at " + t.getCoordinate());
      } else if (3 === arguments.length) {
        for (var o = arguments[0], a = arguments[1], u = arguments[2], l = u, h = o; h < a; h++) {
          var c = this.edgeList.get(h);c.getLabel();c.setEdgeDepths(cn.RIGHT, l), l = c.getDepth(cn.LEFT);
        }return l;
      }
    }, mergeSymLabels: function () {
      for (var t = this.iterator(); t.hasNext();) {
        var e = t.next(),
            n = e.getLabel();n.merge(e.getSym().getLabel());
      }
    }, linkMinimalDirectedEdges: function (t) {
      for (var e = null, n = null, i = this.SCANNING_FOR_INCOMING, r = this.resultAreaEdgeList.size() - 1; r >= 0; r--) {
        var s = this.resultAreaEdgeList.get(r),
            o = s.getSym();switch (null === e && s.getEdgeRing() === t && (e = s), i) {case this.SCANNING_FOR_INCOMING:
            if (o.getEdgeRing() !== t) continue;n = o, i = this.LINKING_TO_OUTGOING;break;case this.LINKING_TO_OUTGOING:
            if (s.getEdgeRing() !== t) continue;n.setNextMin(s), i = this.SCANNING_FOR_INCOMING;}
      }i === this.LINKING_TO_OUTGOING && (f.isTrue(null !== e, "found null for first outgoing dirEdge"), f.isTrue(e.getEdgeRing() === t, "unable to link last incoming dirEdge"), n.setNextMin(e));
    }, getOutgoingDegree: function () {
      if (0 === arguments.length) {
        for (var t = 0, e = this.iterator(); e.hasNext();) {
          var n = e.next();n.isInResult() && t++;
        }return t;
      }if (1 === arguments.length) {
        for (var i = arguments[0], t = 0, e = this.iterator(); e.hasNext();) {
          var n = e.next();n.getEdgeRing() === i && t++;
        }return t;
      }
    }, getLabel: function () {
      return this.label;
    }, findCoveredLineEdges: function () {
      for (var t = L.NONE, e = this.iterator(); e.hasNext();) {
        var n = e.next(),
            i = n.getSym();if (!n.isLineEdge()) {
          if (n.isInResult()) {
            t = L.INTERIOR;break;
          }if (i.isInResult()) {
            t = L.EXTERIOR;break;
          }
        }
      }if (t === L.NONE) return null;for (var r = t, e = this.iterator(); e.hasNext();) {
        var n = e.next(),
            i = n.getSym();n.isLineEdge() ? n.getEdge().setCovered(r === L.INTERIOR) : (n.isInResult() && (r = L.EXTERIOR), i.isInResult() && (r = L.INTERIOR));
      }
    }, computeLabelling: function (t) {
      Pn.prototype.computeLabelling.call(this, t), this.label = new gn(L.NONE);for (var e = this.iterator(); e.hasNext();) for (var n = e.next(), i = n.getEdge(), r = i.getLabel(), s = 0; s < 2; s++) {
        var o = r.getLocation(s);o !== L.INTERIOR && o !== L.BOUNDARY || this.label.setLocation(s, L.INTERIOR);
      }
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return bn;
    } }), h(On, Nn), e(On.prototype, { createNode: function (t) {
      return new yn(t, new bn());
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return On;
    } }), e(_n.prototype, { computeIntersections: function (t, e) {
      this.mce.computeIntersectsForChain(this.chainIndex, t.mce, t.chainIndex, e);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return _n;
    } }), e(Mn.prototype, { isDelete: function () {
      return this.eventType === Mn.DELETE;
    }, setDeleteEventIndex: function (t) {
      this.deleteEventIndex = t;
    }, getObject: function () {
      return this.obj;
    }, compareTo: function (t) {
      var e = t;return this.xValue < e.xValue ? -1 : this.xValue > e.xValue ? 1 : this.eventType < e.eventType ? -1 : this.eventType > e.eventType ? 1 : 0;
    }, getInsertEvent: function () {
      return this.insertEvent;
    }, isInsert: function () {
      return this.eventType === Mn.INSERT;
    }, isSameLabel: function (t) {
      return null !== this.label && this.label === t.label;
    }, getDeleteEventIndex: function () {
      return this.deleteEventIndex;
    }, interfaces_: function () {
      return [s];
    }, getClass: function () {
      return Mn;
    } }), Mn.INSERT = 1, Mn.DELETE = 2, e(Dn.prototype, { interfaces_: function () {
      return [];
    }, getClass: function () {
      return Dn;
    } }), e(An.prototype, { isTrivialIntersection: function (t, e, n, i) {
      if (t === n && 1 === this.li.getIntersectionNum()) {
        if (An.isAdjacentSegments(e, i)) return !0;if (t.isClosed()) {
          var r = t.getNumPoints() - 1;if (0 === e && i === r || 0 === i && e === r) return !0;
        }
      }return !1;
    }, getProperIntersectionPoint: function () {
      return this.properIntersectionPoint;
    }, setIsDoneIfProperInt: function (t) {
      this.isDoneWhenProperInt = t;
    }, hasProperInteriorIntersection: function () {
      return this.hasProperInterior;
    }, isBoundaryPointInternal: function (t, e) {
      for (var n = e.iterator(); n.hasNext();) {
        var i = n.next(),
            r = i.getCoordinate();if (t.isIntersection(r)) return !0;
      }return !1;
    }, hasProperIntersection: function () {
      return this.hasProper;
    }, hasIntersection: function () {
      return this._hasIntersection;
    }, isDone: function () {
      return this._isDone;
    }, isBoundaryPoint: function (t, e) {
      return null !== e && (!!this.isBoundaryPointInternal(t, e[0]) || !!this.isBoundaryPointInternal(t, e[1]));
    }, setBoundaryNodes: function (t, e) {
      this.bdyNodes = new Array(2).fill(null), this.bdyNodes[0] = t, this.bdyNodes[1] = e;
    }, addIntersections: function (t, e, n, i) {
      if (t === n && e === i) return null;this.numTests++;var r = t.getCoordinates()[e],
          s = t.getCoordinates()[e + 1],
          o = n.getCoordinates()[i],
          a = n.getCoordinates()[i + 1];this.li.computeIntersection(r, s, o, a), this.li.hasIntersection() && (this.recordIsolated && (t.setIsolated(!1), n.setIsolated(!1)), this.numIntersections++, this.isTrivialIntersection(t, e, n, i) || (this._hasIntersection = !0, !this.includeProper && this.li.isProper() || (t.addIntersections(this.li, e, 0), n.addIntersections(this.li, i, 1)), this.li.isProper() && (this.properIntersectionPoint = this.li.getIntersection(0).copy(), this.hasProper = !0, this.isDoneWhenProperInt && (this._isDone = !0), this.isBoundaryPoint(this.li, this.bdyNodes) || (this.hasProperInterior = !0))));
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return An;
    } }), An.isAdjacentSegments = function (t, e) {
    return 1 === Math.abs(t - e);
  }, h(Fn, Dn), e(Fn.prototype, { prepareEvents: function () {
      ho.sort(this.events);for (var t = 0; t < this.events.size(); t++) {
        var e = this.events.get(t);e.isDelete() && e.getInsertEvent().setDeleteEventIndex(t);
      }
    }, computeIntersections: function () {
      if (1 === arguments.length) {
        var t = arguments[0];this.nOverlaps = 0, this.prepareEvents();for (var e = 0; e < this.events.size(); e++) {
          var n = this.events.get(e);if (n.isInsert() && this.processOverlaps(e, n.getDeleteEventIndex(), n, t), t.isDone()) break;
        }
      } else if (3 === arguments.length) if (arguments[2] instanceof An && R(arguments[0], y) && R(arguments[1], y)) {
        var i = arguments[0],
            r = arguments[1],
            s = arguments[2];this.addEdges(i, i), this.addEdges(r, r), this.computeIntersections(s);
      } else if ("boolean" == typeof arguments[2] && R(arguments[0], y) && arguments[1] instanceof An) {
        var o = arguments[0],
            a = arguments[1],
            u = arguments[2];u ? this.addEdges(o, null) : this.addEdges(o), this.computeIntersections(a);
      }
    }, addEdge: function (t, e) {
      for (var n = t.getMonotoneChainEdge(), i = n.getStartIndexes(), r = 0; r < i.length - 1; r++) {
        var s = new _n(n, r),
            o = new Mn(e, n.getMinX(r), s);this.events.add(o), this.events.add(new Mn(n.getMaxX(r), o));
      }
    }, processOverlaps: function (t, e, n, i) {
      for (var r = n.getObject(), s = t; s < e; s++) {
        var o = this.events.get(s);if (o.isInsert()) {
          var a = o.getObject();n.isSameLabel(o) || (r.computeIntersections(a, i), this.nOverlaps++);
        }
      }
    }, addEdges: function () {
      if (1 === arguments.length) for (var t = arguments[0], e = t.iterator(); e.hasNext();) {
        var n = e.next();this.addEdge(n, n);
      } else if (2 === arguments.length) for (var i = arguments[0], r = arguments[1], e = i.iterator(); e.hasNext();) {
        var n = e.next();this.addEdge(n, r);
      }
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Fn;
    } }), e(Gn.prototype, { getMin: function () {
      return this.min;
    }, intersects: function (t, e) {
      return !(this.min > e || this.max < t);
    }, getMax: function () {
      return this.max;
    }, toString: function () {
      return se.toLineString(new g(this.min, 0), new g(this.max, 0));
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Gn;
    } }), e(qn.prototype, { compare: function (t, e) {
      var n = t,
          i = e,
          r = (n.min + n.max) / 2,
          s = (i.min + i.max) / 2;return r < s ? -1 : r > s ? 1 : 0;
    }, interfaces_: function () {
      return [a];
    }, getClass: function () {
      return qn;
    } }), Gn.NodeComparator = qn, h(Bn, Gn), e(Bn.prototype, { query: function (t, e, n) {
      return this.intersects(t, e) ? void n.visitItem(this.item) : null;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Bn;
    } }), h(zn, Gn), e(zn.prototype, { buildExtent: function (t, e) {
      this.min = Math.min(t.min, e.min), this.max = Math.max(t.max, e.max);
    }, query: function (t, e, n) {
      return this.intersects(t, e) ? (null !== this.node1 && this.node1.query(t, e, n), void (null !== this.node2 && this.node2.query(t, e, n))) : null;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return zn;
    } }), e(Vn.prototype, { buildTree: function () {
      ho.sort(this.leaves, new IntervalRTreeNode.NodeComparator());for (var t = this.leaves, e = null, n = new I();;) {
        if (this.buildLevel(t, n), 1 === n.size()) return n.get(0);e = t, t = n, n = e;
      }
    }, insert: function (t, e, n) {
      if (null !== this.root) throw new IllegalStateException("Index cannot be added to once it has been queried");this.leaves.add(new Bn(t, e, n));
    }, query: function (t, e, n) {
      this.init(), this.root.query(t, e, n);
    }, buildRoot: function () {
      return null !== this.root ? null : void (this.root = this.buildTree());
    }, printNode: function (t) {
      A.out.println(se.toLineString(new g(t.min, this.level), new g(t.max, this.level)));
    }, init: function () {
      return null !== this.root ? null : void this.buildRoot();
    }, buildLevel: function (t, e) {
      this.level++, e.clear();for (var n = 0; n < t.size(); n += 2) {
        var i = t.get(n),
            r = n + 1 < t.size() ? t.get(n) : null;if (null === r) e.add(i);else {
          var s = new zn(t.get(n), t.get(n + 1));e.add(s);
        }
      }
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Vn;
    } }), e(kn.prototype, { filter: function (t) {
      if (this.isForcedToLineString && t instanceof bt) {
        var e = t.getFactory().createLineString(t.getCoordinateSequence());return this.lines.add(e), null;
      }t instanceof St && this.lines.add(t);
    }, setForceToLineString: function (t) {
      this.isForcedToLineString = t;
    }, interfaces_: function () {
      return [q];
    }, getClass: function () {
      return kn;
    } }), kn.getGeometry = function () {
    if (1 === arguments.length) {
      var t = arguments[0];return t.getFactory().buildGeometry(kn.getLines(t));
    }if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];return e.getFactory().buildGeometry(kn.getLines(e, n));
    }
  }, kn.getLines = function () {
    if (1 === arguments.length) {
      var t = arguments[0];return kn.getLines(t, !1);
    }if (2 === arguments.length) {
      if (R(arguments[0], v) && R(arguments[1], v)) {
        for (var e = arguments[0], n = arguments[1], i = e.iterator(); i.hasNext();) {
          var r = i.next();kn.getLines(r, n);
        }return n;
      }if (arguments[0] instanceof B && "boolean" == typeof arguments[1]) {
        var s = arguments[0],
            o = arguments[1],
            a = new I();return s.apply(new kn(a, o)), a;
      }if (arguments[0] instanceof B && R(arguments[1], v)) {
        var u = arguments[0],
            l = arguments[1];return u instanceof St ? l.add(u) : u.apply(new kn(l)), l;
      }
    } else if (3 === arguments.length) {
      if ("boolean" == typeof arguments[2] && R(arguments[0], v) && R(arguments[1], v)) {
        for (var h = arguments[0], c = arguments[1], f = arguments[2], i = h.iterator(); i.hasNext();) {
          var r = i.next();kn.getLines(r, c, f);
        }return c;
      }if ("boolean" == typeof arguments[2] && arguments[0] instanceof B && R(arguments[1], v)) {
        var g = arguments[0],
            d = arguments[1],
            p = arguments[2];return g.apply(new kn(d, p)), d;
      }
    }
  }, e(Yn.prototype, { visitItem: function (t) {
      this.items.add(t);
    }, getItems: function () {
      return this.items;
    }, interfaces_: function () {
      return [Ae];
    }, getClass: function () {
      return Yn;
    } }), e(Un.prototype, { locate: function (t) {
      var e = new le(t),
          n = new Xn(e);return this.index.query(t.y, t.y, n), e.getLocation();
    }, interfaces_: function () {
      return [Rn];
    }, getClass: function () {
      return Un;
    } }), e(Xn.prototype, { visitItem: function (t) {
      var e = t;this.counter.countSegment(e.getCoordinate(0), e.getCoordinate(1));
    }, interfaces_: function () {
      return [Ae];
    }, getClass: function () {
      return Xn;
    } }), e(Hn.prototype, { init: function (t) {
      for (var e = kn.getLines(t), n = e.iterator(); n.hasNext();) {
        var i = n.next(),
            r = i.getCoordinates();this.addLine(r);
      }
    }, addLine: function (t) {
      for (var e = 1; e < t.length; e++) {
        var n = new ce(t[e - 1], t[e]),
            i = Math.min(n.p0.y, n.p1.y),
            r = Math.max(n.p0.y, n.p1.y);this.index.insert(i, r, n);
      }
    }, query: function () {
      if (2 === arguments.length) {
        var t = arguments[0],
            e = arguments[1],
            n = new Yn();return this.index.query(t, e, n), n.getItems();
      }if (3 === arguments.length) {
        var i = arguments[0],
            r = arguments[1],
            s = arguments[2];this.index.query(i, r, s);
      }
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Hn;
    } }), Un.SegmentVisitor = Xn, Un.IntervalIndexedGeometry = Hn, e(Wn.prototype, { getSegmentIndex: function () {
      return this.segmentIndex;
    }, getCoordinate: function () {
      return this.coord;
    }, print: function (t) {
      t.print(this.coord), t.print(" seg # = " + this.segmentIndex), t.println(" dist = " + this.dist);
    }, compareTo: function (t) {
      var e = t;return this.compare(e.segmentIndex, e.dist);
    }, isEndPoint: function (t) {
      return 0 === this.segmentIndex && 0 === this.dist || this.segmentIndex === t;
    }, toString: function () {
      return this.coord + " seg # = " + this.segmentIndex + " dist = " + this.dist;
    }, getDistance: function () {
      return this.dist;
    }, compare: function (t, e) {
      return this.segmentIndex < t ? -1 : this.segmentIndex > t ? 1 : this.dist < e ? -1 : this.dist > e ? 1 : 0;
    }, interfaces_: function () {
      return [s];
    }, getClass: function () {
      return Wn;
    } }), e(jn.prototype, { print: function (t) {
      t.println("Intersections:");for (var e = this.iterator(); e.hasNext();) {
        var n = e.next();n.print(t);
      }
    }, iterator: function () {
      return this.nodeMap.values().iterator();
    }, addSplitEdges: function (t) {
      this.addEndpoints();for (var e = this.iterator(), n = e.next(); e.hasNext();) {
        var i = e.next(),
            r = this.createSplitEdge(n, i);t.add(r), n = i;
      }
    }, addEndpoints: function () {
      var t = this.edge.pts.length - 1;this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[t], t, 0);
    }, createSplitEdge: function (t, e) {
      var n = e.segmentIndex - t.segmentIndex + 2,
          i = this.edge.pts[e.segmentIndex],
          r = e.dist > 0 || !e.coord.equals2D(i);r || n--;var s = new Array(n).fill(null),
          o = 0;s[o++] = new g(t.coord);for (var a = t.segmentIndex + 1; a <= e.segmentIndex; a++) s[o++] = this.edge.pts[a];return r && (s[o] = e.coord), new Jn(s, new gn(this.edge.label));
    }, add: function (t, e, n) {
      var i = new Wn(t, e, n),
          r = this.nodeMap.get(i);return null !== r ? r : (this.nodeMap.put(i, i), i);
    }, isIntersection: function (t) {
      for (var e = this.iterator(); e.hasNext();) {
        var n = e.next();if (n.coord.equals(t)) return !0;
      }return !1;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return jn;
    } }), e(Kn.prototype, { getChainStartIndices: function (t) {
      var e = 0,
          n = new I();n.add(new b(e));do {
        var i = this.findChainEnd(t, e);n.add(new b(i)), e = i;
      } while (e < t.length - 1);var r = Kn.toIntArray(n);return r;
    }, findChainEnd: function (t, e) {
      for (var n = Je.quadrant(t[e], t[e + 1]), i = e + 1; i < t.length;) {
        var r = Je.quadrant(t[i - 1], t[i]);if (r !== n) break;i++;
      }return i - 1;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Kn;
    } }), Kn.toIntArray = function (t) {
    for (var e = new Array(t.size()).fill(null), n = 0; n < e.length; n++) e[n] = t.get(n).intValue();return e;
  }, e(Zn.prototype, { getCoordinates: function () {
      return this.pts;
    }, getMaxX: function (t) {
      var e = this.pts[this.startIndex[t]].x,
          n = this.pts[this.startIndex[t + 1]].x;return e > n ? e : n;
    }, getMinX: function (t) {
      var e = this.pts[this.startIndex[t]].x,
          n = this.pts[this.startIndex[t + 1]].x;return e < n ? e : n;
    }, computeIntersectsForChain: function () {
      if (4 === arguments.length) {
        var t = arguments[0],
            e = arguments[1],
            n = arguments[2],
            i = arguments[3];this.computeIntersectsForChain(this.startIndex[t], this.startIndex[t + 1], e, e.startIndex[n], e.startIndex[n + 1], i);
      } else if (6 === arguments.length) {
        var r = arguments[0],
            s = arguments[1],
            o = arguments[2],
            a = arguments[3],
            u = arguments[4],
            l = arguments[5],
            h = this.pts[r],
            c = this.pts[s],
            f = o.pts[a],
            g = o.pts[u];if (s - r === 1 && u - a === 1) return l.addIntersections(this.e, r, o.e, a), null;if (this.env1.init(h, c), this.env2.init(f, g), !this.env1.intersects(this.env2)) return null;var d = Math.trunc((r + s) / 2),
            p = Math.trunc((a + u) / 2);r < d && (a < p && this.computeIntersectsForChain(r, d, o, a, p, l), p < u && this.computeIntersectsForChain(r, d, o, p, u, l)), d < s && (a < p && this.computeIntersectsForChain(d, s, o, a, p, l), p < u && this.computeIntersectsForChain(d, s, o, p, u, l));
      }
    }, getStartIndexes: function () {
      return this.startIndex;
    }, computeIntersects: function (t, e) {
      for (var n = 0; n < this.startIndex.length - 1; n++) for (var i = 0; i < t.startIndex.length - 1; i++) this.computeIntersectsForChain(n, t, i, e);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Zn;
    } }), e(Qn.prototype, { getDepth: function (t, e) {
      return this.depth[t][e];
    }, setDepth: function (t, e, n) {
      this.depth[t][e] = n;
    }, isNull: function () {
      if (0 === arguments.length) {
        for (var t = 0; t < 2; t++) for (var e = 0; e < 3; e++) if (this.depth[t][e] !== Qn.NULL_VALUE) return !1;return !0;
      }if (1 === arguments.length) {
        var n = arguments[0];return this.depth[n][1] === Qn.NULL_VALUE;
      }if (2 === arguments.length) {
        var i = arguments[0],
            r = arguments[1];return this.depth[i][r] === Qn.NULL_VALUE;
      }
    }, normalize: function () {
      for (var t = 0; t < 2; t++) if (!this.isNull(t)) {
        var e = this.depth[t][1];this.depth[t][2] < e && (e = this.depth[t][2]), e < 0 && (e = 0);for (var n = 1; n < 3; n++) {
          var i = 0;this.depth[t][n] > e && (i = 1), this.depth[t][n] = i;
        }
      }
    }, getDelta: function (t) {
      return this.depth[t][cn.RIGHT] - this.depth[t][cn.LEFT];
    }, getLocation: function (t, e) {
      return this.depth[t][e] <= 0 ? L.EXTERIOR : L.INTERIOR;
    }, toString: function () {
      return "A: " + this.depth[0][1] + "," + this.depth[0][2] + " B: " + this.depth[1][1] + "," + this.depth[1][2];
    }, add: function () {
      if (1 === arguments.length) for (var t = arguments[0], e = 0; e < 2; e++) for (var n = 1; n < 3; n++) {
        var i = t.getLocation(e, n);i !== L.EXTERIOR && i !== L.INTERIOR || (this.isNull(e, n) ? this.depth[e][n] = Qn.depthAtLocation(i) : this.depth[e][n] += Qn.depthAtLocation(i));
      } else if (3 === arguments.length) {
        var r = arguments[0],
            s = arguments[1],
            o = arguments[2];o === L.INTERIOR && this.depth[r][s]++;
      }
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Qn;
    } }), Qn.depthAtLocation = function (t) {
    return t === L.EXTERIOR ? 0 : t === L.INTERIOR ? 1 : Qn.NULL_VALUE;
  }, Qn.NULL_VALUE = -1, h(Jn, mn), e(Jn.prototype, { getDepth: function () {
      return this.depth;
    }, getCollapsedEdge: function () {
      var t = new Array(2).fill(null);t[0] = this.pts[0], t[1] = this.pts[1];var e = new Jn(t, gn.toLineLabel(this.label));return e;
    }, isIsolated: function () {
      return this._isIsolated;
    }, getCoordinates: function () {
      return this.pts;
    }, setIsolated: function (t) {
      this._isIsolated = t;
    }, setName: function (t) {
      this.name = t;
    }, equals: function (t) {
      if (!(t instanceof Jn)) return !1;var e = t;if (this.pts.length !== e.pts.length) return !1;for (var n = !0, i = !0, r = this.pts.length, s = 0; s < this.pts.length; s++) if (this.pts[s].equals2D(e.pts[s]) || (n = !1), this.pts[s].equals2D(e.pts[--r]) || (i = !1), !n && !i) return !1;return !0;
    }, getCoordinate: function () {
      if (0 === arguments.length) return this.pts.length > 0 ? this.pts[0] : null;if (1 === arguments.length) {
        var t = arguments[0];return this.pts[t];
      }
    }, print: function (t) {
      t.print("edge " + this.name + ": "), t.print("LINESTRING (");for (var e = 0; e < this.pts.length; e++) e > 0 && t.print(","), t.print(this.pts[e].x + " " + this.pts[e].y);t.print(")  " + this.label + " " + this.depthDelta);
    }, computeIM: function (t) {
      Jn.updateIM(this.label, t);
    }, isCollapsed: function () {
      return !!this.label.isArea() && 3 === this.pts.length && !!this.pts[0].equals(this.pts[2]);
    }, isClosed: function () {
      return this.pts[0].equals(this.pts[this.pts.length - 1]);
    }, getMaximumSegmentIndex: function () {
      return this.pts.length - 1;
    }, getDepthDelta: function () {
      return this.depthDelta;
    }, getNumPoints: function () {
      return this.pts.length;
    }, printReverse: function (t) {
      t.print("edge " + this.name + ": ");for (var e = this.pts.length - 1; e >= 0; e--) t.print(this.pts[e] + " ");t.println("");
    }, getMonotoneChainEdge: function () {
      return null === this.mce && (this.mce = new Zn(this)), this.mce;
    }, getEnvelope: function () {
      if (null === this.env) {
        this.env = new C();for (var t = 0; t < this.pts.length; t++) this.env.expandToInclude(this.pts[t]);
      }return this.env;
    }, addIntersection: function (t, e, n, i) {
      var r = new g(t.getIntersection(i)),
          s = e,
          o = t.getEdgeDistance(n, i),
          a = s + 1;if (a < this.pts.length) {
        var u = this.pts[a];r.equals2D(u) && (s = a, o = 0);
      }this.eiList.add(r, s, o);
    }, toString: function () {
      var t = new P();t.append("edge " + this.name + ": "), t.append("LINESTRING (");for (var e = 0; e < this.pts.length; e++) e > 0 && t.append(","), t.append(this.pts[e].x + " " + this.pts[e].y);return t.append(")  " + this.label + " " + this.depthDelta), t.toString();
    }, isPointwiseEqual: function (t) {
      if (this.pts.length !== t.pts.length) return !1;for (var e = 0; e < this.pts.length; e++) if (!this.pts[e].equals2D(t.pts[e])) return !1;return !0;
    }, setDepthDelta: function (t) {
      this.depthDelta = t;
    }, getEdgeIntersectionList: function () {
      return this.eiList;
    }, addIntersections: function (t, e, n) {
      for (var i = 0; i < t.getIntersectionNum(); i++) this.addIntersection(t, e, n, i);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Jn;
    } }), Jn.updateIM = function () {
    if (2 !== arguments.length) return mn.prototype.updateIM.apply(this, arguments);var t = arguments[0],
        e = arguments[1];e.setAtLeastIfValid(t.getLocation(0, cn.ON), t.getLocation(1, cn.ON), 1), t.isArea() && (e.setAtLeastIfValid(t.getLocation(0, cn.LEFT), t.getLocation(1, cn.LEFT), 2), e.setAtLeastIfValid(t.getLocation(0, cn.RIGHT), t.getLocation(1, cn.RIGHT), 2));
  }, h($n, Cn), e($n.prototype, { insertBoundaryPoint: function (t, e) {
      var n = this.nodes.addNode(e),
          i = n.getLabel(),
          r = 1,
          s = L.NONE;s = i.getLocation(t, cn.ON), s === L.BOUNDARY && r++;var o = $n.determineBoundary(this.boundaryNodeRule, r);i.setLocation(t, o);
    }, computeSelfNodes: function () {
      if (2 === arguments.length) {
        var t = arguments[0],
            e = arguments[1];return this.computeSelfNodes(t, e, !1);
      }if (3 === arguments.length) {
        var n = arguments[0],
            i = arguments[1],
            r = arguments[2],
            s = new An(n, !0, !1);s.setIsDoneIfProperInt(r);var o = this.createEdgeSetIntersector(),
            a = this.parentGeom instanceof bt || this.parentGeom instanceof Tt || this.parentGeom instanceof Ot,
            u = i || !a;return o.computeIntersections(this.edges, s, u), this.addSelfIntersectionNodes(this.argIndex), s;
      }
    }, computeSplitEdges: function (t) {
      for (var e = this.edges.iterator(); e.hasNext();) {
        var n = e.next();n.eiList.addSplitEdges(t);
      }
    }, computeEdgeIntersections: function (t, e, n) {
      var i = new An(e, n, !0);i.setBoundaryNodes(this.getBoundaryNodes(), t.getBoundaryNodes());var r = this.createEdgeSetIntersector();return r.computeIntersections(this.edges, t.edges, i), i;
    }, getGeometry: function () {
      return this.parentGeom;
    }, getBoundaryNodeRule: function () {
      return this.boundaryNodeRule;
    }, hasTooFewPoints: function () {
      return this._hasTooFewPoints;
    }, addPoint: function () {
      if (arguments[0] instanceof Lt) {
        var t = arguments[0],
            e = t.getCoordinate();this.insertPoint(this.argIndex, e, L.INTERIOR);
      } else if (arguments[0] instanceof g) {
        var n = arguments[0];this.insertPoint(this.argIndex, n, L.INTERIOR);
      }
    }, addPolygon: function (t) {
      this.addPolygonRing(t.getExteriorRing(), L.EXTERIOR, L.INTERIOR);for (var e = 0; e < t.getNumInteriorRing(); e++) {
        var n = t.getInteriorRingN(e);this.addPolygonRing(n, L.INTERIOR, L.EXTERIOR);
      }
    }, addEdge: function (t) {
      this.insertEdge(t);var e = t.getCoordinates();this.insertPoint(this.argIndex, e[0], L.BOUNDARY), this.insertPoint(this.argIndex, e[e.length - 1], L.BOUNDARY);
    }, addLineString: function (t) {
      var e = H.removeRepeatedPoints(t.getCoordinates());if (e.length < 2) return this._hasTooFewPoints = !0, this.invalidPoint = e[0], null;var n = new Jn(e, new gn(this.argIndex, L.INTERIOR));this.lineEdgeMap.put(t, n), this.insertEdge(n), f.isTrue(e.length >= 2, "found LineString with single point"), this.insertBoundaryPoint(this.argIndex, e[0]), this.insertBoundaryPoint(this.argIndex, e[e.length - 1]);
    }, getInvalidPoint: function () {
      return this.invalidPoint;
    }, getBoundaryPoints: function () {
      for (var t = this.getBoundaryNodes(), e = new Array(t.size()).fill(null), n = 0, i = t.iterator(); i.hasNext();) {
        var r = i.next();e[n++] = r.getCoordinate().copy();
      }return e;
    }, getBoundaryNodes: function () {
      return null === this.boundaryNodes && (this.boundaryNodes = this.nodes.getBoundaryNodes(this.argIndex)), this.boundaryNodes;
    }, addSelfIntersectionNode: function (t, e, n) {
      return this.isBoundaryNode(t, e) ? null : void (n === L.BOUNDARY && this.useBoundaryDeterminationRule ? this.insertBoundaryPoint(t, e) : this.insertPoint(t, e, n));
    }, addPolygonRing: function (t, e, n) {
      if (t.isEmpty()) return null;var i = H.removeRepeatedPoints(t.getCoordinates());if (i.length < 4) return this._hasTooFewPoints = !0, this.invalidPoint = i[0], null;var r = e,
          s = n;he.isCCW(i) && (r = n, s = e);var o = new Jn(i, new gn(this.argIndex, L.BOUNDARY, r, s));this.lineEdgeMap.put(t, o), this.insertEdge(o), this.insertPoint(this.argIndex, i[0], L.BOUNDARY);
    }, insertPoint: function (t, e, n) {
      var i = this.nodes.addNode(e),
          r = i.getLabel();null === r ? i.label = new gn(t, n) : r.setLocation(t, n);
    }, createEdgeSetIntersector: function () {
      return new Fn();
    }, addSelfIntersectionNodes: function (t) {
      for (var e = this.edges.iterator(); e.hasNext();) for (var n = e.next(), i = n.getLabel().getLocation(t), r = n.eiList.iterator(); r.hasNext();) {
        var s = r.next();this.addSelfIntersectionNode(t, s.coord, i);
      }
    }, add: function () {
      if (1 !== arguments.length) return Cn.prototype.add.apply(this, arguments);var t = arguments[0];if (t.isEmpty()) return null;if (t instanceof Ot && (this.useBoundaryDeterminationRule = !1), t instanceof Tt) this.addPolygon(t);else if (t instanceof St) this.addLineString(t);else if (t instanceof Lt) this.addPoint(t);else if (t instanceof Pt) this.addCollection(t);else if (t instanceof gt) this.addCollection(t);else if (t instanceof Ot) this.addCollection(t);else {
        if (!(t instanceof ft)) throw new UnsupportedOperationException(t.getClass().getName());this.addCollection(t);
      }
    }, addCollection: function (t) {
      for (var e = 0; e < t.getNumGeometries(); e++) {
        var n = t.getGeometryN(e);this.add(n);
      }
    }, locate: function (t) {
      return R(this.parentGeom, Rt) && this.parentGeom.getNumGeometries() > 50 ? (null === this.areaPtLocator && (this.areaPtLocator = new Un(this.parentGeom)), this.areaPtLocator.locate(t)) : this.ptLocator.locate(t, this.parentGeom);
    }, findEdge: function () {
      if (1 === arguments.length) {
        var t = arguments[0];return this.lineEdgeMap.get(t);
      }return Cn.prototype.findEdge.apply(this, arguments);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return $n;
    } }), $n.determineBoundary = function (t, e) {
    return t.isInBoundary(e) ? L.BOUNDARY : L.INTERIOR;
  }, e(ti.prototype, { getArgGeometry: function (t) {
      return this.arg[t].getGeometry();
    }, setComputationPrecision: function (t) {
      this.resultPrecisionModel = t, this.li.setPrecisionModel(this.resultPrecisionModel);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return ti;
    } }), e(ei.prototype, { compareTo: function (t) {
      var e = t,
          n = ei.compareOriented(this.pts, this._orientation, e.pts, e._orientation);return n;
    }, interfaces_: function () {
      return [s];
    }, getClass: function () {
      return ei;
    } }), ei.orientation = function (t) {
    return 1 === H.increasingDirection(t);
  }, ei.compareOriented = function (t, e, n, i) {
    for (var r = e ? 1 : -1, s = i ? 1 : -1, o = e ? t.length : -1, a = i ? n.length : -1, u = e ? 0 : t.length - 1, l = i ? 0 : n.length - 1;;) {
      var h = t[u].compareTo(n[l]);if (0 !== h) return h;u += r, l += s;var c = u === o,
          f = l === a;if (c && !f) return -1;if (!c && f) return 1;if (c && f) return 0;
    }
  }, e(ni.prototype, { print: function (t) {
      t.print("MULTILINESTRING ( ");for (var e = 0; e < this.edges.size(); e++) {
        var n = this.edges.get(e);e > 0 && t.print(","), t.print("(");for (var i = n.getCoordinates(), r = 0; r < i.length; r++) r > 0 && t.print(","), t.print(i[r].x + " " + i[r].y);t.println(")");
      }t.print(")  ");
    }, addAll: function (t) {
      for (var e = t.iterator(); e.hasNext();) this.add(e.next());
    }, findEdgeIndex: function (t) {
      for (var e = 0; e < this.edges.size(); e++) if (this.edges.get(e).equals(t)) return e;return -1;
    }, iterator: function () {
      return this.edges.iterator();
    }, getEdges: function () {
      return this.edges;
    }, get: function (t) {
      return this.edges.get(t);
    }, findEqualEdge: function (t) {
      var e = new ei(t.getCoordinates()),
          n = this.ocaMap.get(e);return n;
    }, add: function (t) {
      this.edges.add(t);var e = new ei(t.getCoordinates());this.ocaMap.put(e, t);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return ni;
    } }), h(ii, ti), e(ii.prototype, { insertUniqueEdge: function (t) {
      var e = this.edgeList.findEqualEdge(t);if (null !== e) {
        var n = e.getLabel(),
            i = t.getLabel();e.isPointwiseEqual(t) || (i = new gn(t.getLabel()), i.flip());var r = e.getDepth();r.isNull() && r.add(n), r.add(i), n.merge(i);
      } else this.edgeList.add(t);
    }, getGraph: function () {
      return this.graph;
    }, cancelDuplicateResultEdges: function () {
      for (var t = this.graph.getEdgeEnds().iterator(); t.hasNext();) {
        var e = t.next(),
            n = e.getSym();e.isInResult() && n.isInResult() && (e.setInResult(!1), n.setInResult(!1));
      }
    }, isCoveredByLA: function (t) {
      return !!this.isCovered(t, this.resultLineList) || !!this.isCovered(t, this.resultPolyList);
    }, computeGeometry: function (t, e, n, i) {
      var r = new I();return r.addAll(t), r.addAll(e), r.addAll(n), r.isEmpty() ? ii.createEmptyResult(i, this.arg[0].getGeometry(), this.arg[1].getGeometry(), this.geomFact) : this.geomFact.buildGeometry(r);
    }, mergeSymLabels: function () {
      for (var t = this.graph.getNodes().iterator(); t.hasNext();) {
        var e = t.next();e.getEdges().mergeSymLabels();
      }
    }, isCovered: function (t, e) {
      for (var n = e.iterator(); n.hasNext();) {
        var i = n.next(),
            r = this.ptLocator.locate(t, i);if (r !== L.EXTERIOR) return !0;
      }return !1;
    }, replaceCollapsedEdges: function () {
      for (var t = new I(), e = this.edgeList.iterator(); e.hasNext();) {
        var n = e.next();n.isCollapsed() && (e.remove(), t.add(n.getCollapsedEdge()));
      }this.edgeList.addAll(t);
    }, updateNodeLabelling: function () {
      for (var t = this.graph.getNodes().iterator(); t.hasNext();) {
        var e = t.next(),
            n = e.getEdges().getLabel();e.getLabel().merge(n);
      }
    }, getResultGeometry: function (t) {
      return this.computeOverlay(t), this.resultGeom;
    }, insertUniqueEdges: function (t) {
      for (var e = t.iterator(); e.hasNext();) {
        var n = e.next();this.insertUniqueEdge(n);
      }
    }, computeOverlay: function (t) {
      this.copyPoints(0), this.copyPoints(1), this.arg[0].computeSelfNodes(this.li, !1), this.arg[1].computeSelfNodes(this.li, !1), this.arg[0].computeEdgeIntersections(this.arg[1], this.li, !0);var e = new I();this.arg[0].computeSplitEdges(e), this.arg[1].computeSplitEdges(e);this.insertUniqueEdges(e), this.computeLabelsFromDepths(), this.replaceCollapsedEdges(), ln.checkValid(this.edgeList.getEdges()), this.graph.addEdges(this.edgeList.getEdges()), this.computeLabelling(), this.labelIncompleteNodes(), this.findResultAreaEdges(t), this.cancelDuplicateResultEdges();var n = new Sn(this.geomFact);n.add(this.graph), this.resultPolyList = n.getPolygons();var i = new wn(this, this.geomFact, this.ptLocator);this.resultLineList = i.build(t);var r = new Ln(this, this.geomFact, this.ptLocator);this.resultPointList = r.build(t), this.resultGeom = this.computeGeometry(this.resultPointList, this.resultLineList, this.resultPolyList, t);
    }, labelIncompleteNode: function (t, e) {
      var n = this.ptLocator.locate(t.getCoordinate(), this.arg[e].getGeometry());t.getLabel().setLocation(e, n);
    }, copyPoints: function (t) {
      for (var e = this.arg[t].getNodeIterator(); e.hasNext();) {
        var n = e.next(),
            i = this.graph.addNode(n.getCoordinate());i.setLabel(t, n.getLabel().getLocation(t));
      }
    }, findResultAreaEdges: function (t) {
      for (var e = this.graph.getEdgeEnds().iterator(); e.hasNext();) {
        var n = e.next(),
            i = n.getLabel();i.isArea() && !n.isInteriorAreaEdge() && ii.isResultOfOp(i.getLocation(0, cn.RIGHT), i.getLocation(1, cn.RIGHT), t) && n.setInResult(!0);
      }
    }, computeLabelsFromDepths: function () {
      for (var t = this.edgeList.iterator(); t.hasNext();) {
        var e = t.next(),
            n = e.getLabel(),
            i = e.getDepth();if (!i.isNull()) {
          i.normalize();for (var r = 0; r < 2; r++) n.isNull(r) || !n.isArea() || i.isNull(r) || (0 === i.getDelta(r) ? n.toLine(r) : (f.isTrue(!i.isNull(r, cn.LEFT), "depth of LEFT side has not been initialized"), n.setLocation(r, cn.LEFT, i.getLocation(r, cn.LEFT)), f.isTrue(!i.isNull(r, cn.RIGHT), "depth of RIGHT side has not been initialized"), n.setLocation(r, cn.RIGHT, i.getLocation(r, cn.RIGHT))));
        }
      }
    }, computeLabelling: function () {
      for (var t = this.graph.getNodes().iterator(); t.hasNext();) {
        var e = t.next();e.getEdges().computeLabelling(this.arg);
      }this.mergeSymLabels(), this.updateNodeLabelling();
    }, labelIncompleteNodes: function () {
      for (var t = 0, e = this.graph.getNodes().iterator(); e.hasNext();) {
        var n = e.next(),
            i = n.getLabel();n.isIsolated() && (t++, i.isNull(0) ? this.labelIncompleteNode(n, 0) : this.labelIncompleteNode(n, 1)), n.getEdges().updateLabelling(i);
      }
    }, isCoveredByA: function (t) {
      return !!this.isCovered(t, this.resultPolyList);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return ii;
    } }), ii.overlayOp = function (t, e, n) {
    var i = new ii(t, e),
        r = i.getResultGeometry(n);return r;
  }, ii.intersection = function (t, e) {
    if (t.isEmpty() || e.isEmpty()) return ii.createEmptyResult(ii.INTERSECTION, t, e, t.getFactory());if (t.isGeometryCollection()) {
      var n = e;return hn.map(t, { interfaces_: function () {
          return [MapOp];
        }, map: function (t) {
          return t.intersection(n);
        } });
    }return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), si.overlayOp(t, e, ii.INTERSECTION);
  }, ii.symDifference = function (t, e) {
    if (t.isEmpty() || e.isEmpty()) {
      if (t.isEmpty() && e.isEmpty()) return ii.createEmptyResult(ii.SYMDIFFERENCE, t, e, t.getFactory());if (t.isEmpty()) return e.copy();if (e.isEmpty()) return t.copy();
    }return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), si.overlayOp(t, e, ii.SYMDIFFERENCE);
  }, ii.resultDimension = function (t, e, n) {
    var i = e.getDimension(),
        r = n.getDimension(),
        s = -1;switch (t) {case ii.INTERSECTION:
        s = Math.min(i, r);break;case ii.UNION:
        s = Math.max(i, r);break;case ii.DIFFERENCE:
        s = i;break;case ii.SYMDIFFERENCE:
        s = Math.max(i, r);}return s;
  }, ii.createEmptyResult = function (t, e, n, i) {
    var r = null;switch (ii.resultDimension(t, e, n)) {case -1:
        r = i.createGeometryCollection(new Array(0).fill(null));break;case 0:
        r = i.createPoint();break;case 1:
        r = i.createLineString();break;case 2:
        r = i.createPolygon();}return r;
  }, ii.difference = function (t, e) {
    return t.isEmpty() ? ii.createEmptyResult(ii.DIFFERENCE, t, e, t.getFactory()) : e.isEmpty() ? t.copy() : (t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), si.overlayOp(t, e, ii.DIFFERENCE));
  }, ii.isResultOfOp = function () {
    if (2 === arguments.length) {
      var t = arguments[0],
          e = arguments[1],
          n = t.getLocation(0),
          i = t.getLocation(1);return ii.isResultOfOp(n, i, e);
    }if (3 === arguments.length) {
      var r = arguments[0],
          s = arguments[1],
          o = arguments[2];switch (r === L.BOUNDARY && (r = L.INTERIOR), s === L.BOUNDARY && (s = L.INTERIOR), o) {case ii.INTERSECTION:
          return r === L.INTERIOR && s === L.INTERIOR;case ii.UNION:
          return r === L.INTERIOR || s === L.INTERIOR;case ii.DIFFERENCE:
          return r === L.INTERIOR && s !== L.INTERIOR;case ii.SYMDIFFERENCE:
          return r === L.INTERIOR && s !== L.INTERIOR || r !== L.INTERIOR && s === L.INTERIOR;}return !1;
    }
  }, ii.INTERSECTION = 1, ii.UNION = 2, ii.DIFFERENCE = 3, ii.SYMDIFFERENCE = 4, e(ri.prototype, { selfSnap: function (t) {
      var e = new Ie(t),
          n = e.snapTo(t, this.snapTolerance);return n;
    }, removeCommonBits: function (t) {
      this.cbr = new Se(), this.cbr.add(t[0]), this.cbr.add(t[1]);var e = new Array(2).fill(null);return e[0] = this.cbr.removeCommonBits(t[0].copy()), e[1] = this.cbr.removeCommonBits(t[1].copy()), e;
    }, prepareResult: function (t) {
      return this.cbr.addCommonBits(t), t;
    }, getResultGeometry: function (t) {
      var e = this.snap(this.geom),
          n = ii.overlayOp(e[0], e[1], t);return this.prepareResult(n);
    }, checkValid: function (t) {
      t.isValid() || A.out.println("Snapped geometry is invalid");
    }, computeSnapTolerance: function () {
      this.snapTolerance = Ie.computeOverlaySnapTolerance(this.geom[0], this.geom[1]);
    }, snap: function (t) {
      var e = this.removeCommonBits(t),
          n = Ie.snap(e[0], e[1], this.snapTolerance);return n;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return ri;
    } }), ri.overlayOp = function (t, e, n) {
    var i = new ri(t, e);return i.getResultGeometry(n);
  }, ri.union = function (t, e) {
    return ri.overlayOp(t, e, ii.UNION);
  }, ri.intersection = function (t, e) {
    return ri.overlayOp(t, e, ii.INTERSECTION);
  }, ri.symDifference = function (t, e) {
    return ri.overlayOp(t, e, ii.SYMDIFFERENCE);
  }, ri.difference = function (t, e) {
    return ri.overlayOp(t, e, ii.DIFFERENCE);
  }, e(si.prototype, { getResultGeometry: function (t) {
      var e = null,
          n = !1,
          i = null;try {
        e = ii.overlayOp(this.geom[0], this.geom[1], t);var r = !0;r && (n = !0);
      } catch (t) {
        if (!(t instanceof l)) throw t;i = t;
      } finally {}if (!n) try {
        e = ri.overlayOp(this.geom[0], this.geom[1], t);
      } catch (t) {
        throw t instanceof l ? i : t;
      } finally {}return e;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return si;
    } }), si.overlayOp = function (t, e, n) {
    var i = new si(t, e);return i.getResultGeometry(n);
  }, si.union = function (t, e) {
    return si.overlayOp(t, e, ii.UNION);
  }, si.intersection = function (t, e) {
    return si.overlayOp(t, e, ii.INTERSECTION);
  }, si.symDifference = function (t, e) {
    return si.overlayOp(t, e, ii.SYMDIFFERENCE);
  }, si.difference = function (t, e) {
    return si.overlayOp(t, e, ii.DIFFERENCE);
  }, e(oi.prototype, { addPolygon: function (t) {
      if (t.isEmpty()) return null;var e = null,
          n = 0,
          i = this.horizontalBisector(t);if (0 === i.getLength()) n = 0, e = i.getCoordinate();else {
        var r = si.overlayOp(i, t, ii.INTERSECTION),
            s = this.widestGeometry(r);n = s.getEnvelopeInternal().getWidth(), e = oi.centre(s.getEnvelopeInternal());
      }(null === this.interiorPoint || n > this.maxWidth) && (this.interiorPoint = e, this.maxWidth = n);
    }, getInteriorPoint: function () {
      return this.interiorPoint;
    }, widestGeometry: function t() {
      if (arguments[0] instanceof ft) {
        var e = arguments[0];if (e.isEmpty()) return e;for (var t = e.getGeometryN(0), n = 1; n < e.getNumGeometries(); n++) e.getGeometryN(n).getEnvelopeInternal().getWidth() > t.getEnvelopeInternal().getWidth() && (t = e.getGeometryN(n));return t;
      }if (arguments[0] instanceof B) {
        var i = arguments[0];return i instanceof ft ? this.widestGeometry(i) : i;
      }
    }, horizontalBisector: function (t) {
      var e = t.getEnvelopeInternal(),
          n = ai.getBisectorY(t);return this.factory.createLineString([new g(e.getMinX(), n), new g(e.getMaxX(), n)]);
    }, add: function (t) {
      if (t instanceof Tt) this.addPolygon(t);else if (t instanceof ft) for (var e = t, n = 0; n < e.getNumGeometries(); n++) this.add(e.getGeometryN(n));
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return oi;
    } }), oi.centre = function (t) {
    return new g(oi.avg(t.getMinX(), t.getMaxX()), oi.avg(t.getMinY(), t.getMaxY()));
  }, oi.avg = function (t, e) {
    return (t + e) / 2;
  }, e(ai.prototype, { updateInterval: function (t) {
      t <= this.centreY ? t > this.loY && (this.loY = t) : t > this.centreY && t < this.hiY && (this.hiY = t);
    }, getBisectorY: function () {
      this.process(this.poly.getExteriorRing());for (var t = 0; t < this.poly.getNumInteriorRing(); t++) this.process(this.poly.getInteriorRingN(t));var e = oi.avg(this.hiY, this.loY);return e;
    }, process: function (t) {
      for (var e = t.getCoordinateSequence(), n = 0; n < e.size(); n++) {
        var i = e.getY(n);this.updateInterval(i);
      }
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return ai;
    } }), ai.getBisectorY = function (t) {
    var e = new ai(t);return e.getBisectorY();
  }, oi.SafeBisectorFinder = ai, e(ui.prototype, { addEndpoints: function () {
      if (arguments[0] instanceof B) {
        var t = arguments[0];if (t instanceof St) this.addEndpoints(t.getCoordinates());else if (t instanceof ft) for (var e = t, n = 0; n < e.getNumGeometries(); n++) this.addEndpoints(e.getGeometryN(n));
      } else if (arguments[0] instanceof Array) {
        var i = arguments[0];this.add(i[0]), this.add(i[i.length - 1]);
      }
    }, getInteriorPoint: function () {
      return this.interiorPoint;
    }, addInterior: function () {
      if (arguments[0] instanceof B) {
        var t = arguments[0];if (t instanceof St) this.addInterior(t.getCoordinates());else if (t instanceof ft) for (var e = t, n = 0; n < e.getNumGeometries(); n++) this.addInterior(e.getGeometryN(n));
      } else if (arguments[0] instanceof Array) for (var i = arguments[0], n = 1; n < i.length - 1; n++) this.add(i[n]);
    }, add: function (t) {
      var e = t.distance(this.centroid);e < this.minDistance && (this.interiorPoint = new g(t), this.minDistance = e);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return ui;
    } }), e(li.prototype, { getInteriorPoint: function () {
      return this.interiorPoint;
    }, add: function () {
      if (arguments[0] instanceof B) {
        var t = arguments[0];if (t instanceof Lt) this.add(t.getCoordinate());else if (t instanceof ft) for (var e = t, n = 0; n < e.getNumGeometries(); n++) this.add(e.getGeometryN(n));
      } else if (arguments[0] instanceof g) {
        var i = arguments[0],
            r = i.distance(this.centroid);r < this.minDistance && (this.interiorPoint = new g(i), this.minDistance = r);
      }
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return li;
    } }), e(hi.prototype, { select: function () {
      if (1 === arguments.length) {
        arguments[0];
      } else if (2 === arguments.length) {
        var t = arguments[0],
            e = arguments[1];t.getLineSegment(e, this.selectedSegment), this.select(this.selectedSegment);
      }
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return hi;
    } }), e(ci.prototype, { hasChildren: function () {
      for (var t = 0; t < 2; t++) if (null !== this.subnode[t]) return !0;return !1;
    }, isPrunable: function () {
      return !(this.hasChildren() || this.hasItems());
    }, addAllItems: function (t) {
      t.addAll(this.items);for (var e = 0; e < 2; e++) null !== this.subnode[e] && this.subnode[e].addAllItems(t);return t;
    }, size: function () {
      for (var t = 0, e = 0; e < 2; e++) null !== this.subnode[e] && (t += this.subnode[e].size());return t + this.items.size();
    }, addAllItemsFromOverlapping: function (t, e) {
      return null === t || this.isSearchMatch(t) ? (e.addAll(this.items), null !== this.subnode[0] && this.subnode[0].addAllItemsFromOverlapping(t, e), void (null !== this.subnode[1] && this.subnode[1].addAllItemsFromOverlapping(t, e))) : null;
    }, hasItems: function () {
      return !this.items.isEmpty();
    }, remove: function (t, e) {
      if (!this.isSearchMatch(t)) return !1;for (var n = !1, i = 0; i < 2; i++) if (null !== this.subnode[i] && (n = this.subnode[i].remove(t, e))) {
        this.subnode[i].isPrunable() && (this.subnode[i] = null);break;
      }return n ? n : n = this.items.remove(e);
    }, getItems: function () {
      return this.items;
    }, depth: function () {
      for (var t = 0, e = 0; e < 2; e++) if (null !== this.subnode[e]) {
        var n = this.subnode[e].depth();n > t && (t = n);
      }return t + 1;
    }, nodeSize: function () {
      for (var t = 0, e = 0; e < 2; e++) null !== this.subnode[e] && (t += this.subnode[e].nodeSize());return t + 1;
    }, add: function (t) {
      this.items.add(t);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return ci;
    } }), ci.getSubnodeIndex = function (t, e) {
    var n = -1;return t.min >= e && (n = 1), t.max <= e && (n = 0), n;
  }, e(fi.prototype, { expandToInclude: function (t) {
      t.max > this.max && (this.max = t.max), t.min < this.min && (this.min = t.min);
    }, getWidth: function () {
      return this.max - this.min;
    }, overlaps: function () {
      if (1 === arguments.length) {
        var t = arguments[0];return this.overlaps(t.min, t.max);
      }if (2 === arguments.length) {
        var e = arguments[0],
            n = arguments[1];return !(this.min > n || this.max < e);
      }
    }, getMin: function () {
      return this.min;
    }, toString: function () {
      return "[" + this.min + ", " + this.max + "]";
    }, contains: function () {
      if (1 === arguments.length) {
        if (arguments[0] instanceof fi) {
          var t = arguments[0];return this.contains(t.min, t.max);
        }if ("number" == typeof arguments[0]) {
          var e = arguments[0];return e >= this.min && e <= this.max;
        }
      } else if (2 === arguments.length) {
        var n = arguments[0],
            i = arguments[1];return n >= this.min && i <= this.max;
      }
    }, init: function (t, e) {
      this.min = t, this.max = e, t > e && (this.min = e, this.max = t);
    }, getMax: function () {
      return this.max;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return fi;
    } }), gi.exponent = function (t) {
    return di(64, t) - 1023;
  }, gi.powerOf2 = function (t) {
    return Math.pow(2, t);
  }, e(pi.prototype, { getInterval: function () {
      return this.interval;
    }, getLevel: function () {
      return this.level;
    }, computeKey: function (t) {
      for (this.level = pi.computeLevel(t), this.interval = new fi(), this.computeInterval(this.level, t); !this.interval.contains(t);) this.level += 1, this.computeInterval(this.level, t);
    }, computeInterval: function (t, e) {
      var n = gi.powerOf2(t);this.pt = Math.floor(e.getMin() / n) * n, this.interval.init(this.pt, this.pt + n);
    }, getPoint: function () {
      return this.pt;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return pi;
    } }), pi.computeLevel = function (t) {
    var e = t.getWidth(),
        n = gi.exponent(e) + 1;return n;
  }, h(vi, ci), e(vi.prototype, { getInterval: function () {
      return this.interval;
    }, find: function (t) {
      var e = ci.getSubnodeIndex(t, this.centre);if (e === -1) return this;if (null !== this.subnode[e]) {
        var n = this.subnode[e];return n.find(t);
      }return this;
    }, insert: function (t) {
      f.isTrue(null === this.interval || this.interval.contains(t.interval));var e = ci.getSubnodeIndex(t.interval, this.centre);if (t.level === this.level - 1) this.subnode[e] = t;else {
        var n = this.createSubnode(e);n.insert(t), this.subnode[e] = n;
      }
    }, isSearchMatch: function (t) {
      return t.overlaps(this.interval);
    }, getSubnode: function (t) {
      return null === this.subnode[t] && (this.subnode[t] = this.createSubnode(t)), this.subnode[t];
    }, getNode: function (t) {
      var e = ci.getSubnodeIndex(t, this.centre);if (e !== -1) {
        var n = this.getSubnode(e);return n.getNode(t);
      }return this;
    }, createSubnode: function (t) {
      var e = 0,
          n = 0;switch (t) {case 0:
          e = this.interval.getMin(), n = this.centre;break;case 1:
          e = this.centre, n = this.interval.getMax();}var i = new fi(e, n),
          r = new vi(i, this.level - 1);return r;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return vi;
    } }), vi.createNode = function (t) {
    var e = new pi(t),
        n = new vi(e.getInterval(), e.getLevel());return n;
  }, vi.createExpanded = function (t, e) {
    var n = new fi(e);null !== t && n.expandToInclude(t.interval);var i = vi.createNode(n);return null !== t && i.insert(t), i;
  }, e(mi.prototype, { interfaces_: function () {
      return [];
    }, getClass: function () {
      return mi;
    } });mi.isZeroWidth = function (t, e) {
    var n = e - t;if (0 === n) return !0;var i = Math.max(Math.abs(t), Math.abs(e)),
        r = n / i,
        s = gi.exponent(r);return s <= mi.MIN_BINARY_EXPONENT;
  };mi.MIN_BINARY_EXPONENT = -50, h(yi, ci), e(yi.prototype, { insert: function (t, e) {
      var n = ci.getSubnodeIndex(t, yi.origin);if (n === -1) return this.add(e), null;var i = this.subnode[n];if (null === i || !i.getInterval().contains(t)) {
        var r = vi.createExpanded(i, t);this.subnode[n] = r;
      }this.insertContained(this.subnode[n], t, e);
    }, isSearchMatch: function (t) {
      return !0;
    }, insertContained: function (t, e, n) {
      f.isTrue(t.getInterval().contains(e));var i = mi.isZeroWidth(e.getMin(), e.getMax()),
          r = null;r = i ? t.find(e) : t.getNode(e), r.add(n);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return yi;
    } }), yi.origin = 0, e(xi.prototype, { size: function () {
      return null !== this.root ? this.root.size() : 0;
    }, insert: function (t, e) {
      this.collectStats(t);var n = xi.ensureExtent(t, this.minExtent);this.root.insert(n, e);
    }, query: function () {
      if (1 === arguments.length) {
        if ("number" == typeof arguments[0]) {
          var t = arguments[0];return this.query(new fi(t, t));
        }if (arguments[0] instanceof fi) {
          var e = arguments[0],
              n = new I();return this.query(e, n), n;
        }
      } else if (2 === arguments.length) {
        var i = arguments[0],
            r = arguments[1];this.root.addAllItemsFromOverlapping(i, r);
      }
    }, iterator: function () {
      var t = new I();return this.root.addAllItems(t), t.iterator();
    }, remove: function (t, e) {
      var n = xi.ensureExtent(t, this.minExtent);return this.root.remove(n, e);
    }, collectStats: function (t) {
      var e = t.getWidth();e < this.minExtent && e > 0 && (this.minExtent = e);
    }, depth: function () {
      return null !== this.root ? this.root.depth() : 0;
    }, nodeSize: function () {
      return null !== this.root ? this.root.nodeSize() : 0;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return xi;
    } }), xi.ensureExtent = function (t, e) {
    var n = t.getMin(),
        i = t.getMax();return n !== i ? t : (n === i && (n -= e / 2, i = n + e / 2), new fi(n, i));
  }, e(Ei.prototype, { isInside: function (t) {}, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Ei;
    } }), e(Ii.prototype, { testLineSegment: function (t, e) {
      var n = null,
          i = null,
          r = null,
          s = null,
          o = null,
          a = e.p0,
          u = e.p1;i = a.x - t.x, r = a.y - t.y, s = u.x - t.x, o = u.y - t.y, (r > 0 && o <= 0 || o > 0 && r <= 0) && (n = ue.signOfDet2x2(i, r, s, o) / (o - r), 0 < n && this.crossings++);
    }, buildIndex: function () {
      this.tree = new xi();for (var t = H.removeRepeatedPoints(this.ring.getCoordinates()), e = $e.getChains(t), n = 0; n < e.size(); n++) {
        var i = e.get(n),
            r = i.getEnvelope();this.interval.min = r.getMinY(), this.interval.max = r.getMaxY(), this.tree.insert(this.interval, i);
      }
    }, testMonotoneChain: function (t, e, n) {
      n.select(t, e);
    }, isInside: function (t) {
      this.crossings = 0;var e = new C(r.NEGATIVE_INFINITY, r.POSITIVE_INFINITY, t.y, t.y);this.interval.min = t.y, this.interval.max = t.y;for (var n = this.tree.query(this.interval), i = new Ni(this, t), s = n.iterator(); s.hasNext();) {
        var o = s.next();this.testMonotoneChain(e, i, o);
      }return this.crossings % 2 === 1;
    }, interfaces_: function () {
      return [Ei];
    }, getClass: function () {
      return Ii;
    } }), h(Ni, hi), e(Ni.prototype, { select: function () {
      if (1 !== arguments.length) return hi.prototype.select.apply(this, arguments);var t = arguments[0];this.mcp.testLineSegment(this.p, t);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Ni;
    } }), Ii.MCSelecter = Ni, e(Ci.prototype, { interfaces_: function () {
      return [];
    }, getClass: function () {
      return Ci;
    } }), Ci.toDegrees = function (t) {
    return 180 * t / Math.PI;
  }, Ci.normalize = function (t) {
    for (; t > Math.PI;) t -= Ci.PI_TIMES_2;for (; t <= -Math.PI;) t += Ci.PI_TIMES_2;return t;
  }, Ci.angle = function () {
    if (1 === arguments.length) {
      var t = arguments[0];return Math.atan2(t.y, t.x);
    }if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1],
          i = n.x - e.x,
          r = n.y - e.y;return Math.atan2(r, i);
    }
  }, Ci.isAcute = function (t, e, n) {
    var i = t.x - e.x,
        r = t.y - e.y,
        s = n.x - e.x,
        o = n.y - e.y,
        a = i * s + r * o;return a > 0;
  }, Ci.isObtuse = function (t, e, n) {
    var i = t.x - e.x,
        r = t.y - e.y,
        s = n.x - e.x,
        o = n.y - e.y,
        a = i * s + r * o;return a < 0;
  }, Ci.interiorAngle = function (t, e, n) {
    var i = Ci.angle(e, t),
        r = Ci.angle(e, n);return Math.abs(r - i);
  }, Ci.normalizePositive = function (t) {
    if (t < 0) {
      for (; t < 0;) t += Ci.PI_TIMES_2;t >= Ci.PI_TIMES_2 && (t = 0);
    } else {
      for (; t >= Ci.PI_TIMES_2;) t -= Ci.PI_TIMES_2;t < 0 && (t = 0);
    }return t;
  }, Ci.angleBetween = function (t, e, n) {
    var i = Ci.angle(e, t),
        r = Ci.angle(e, n);return Ci.diff(i, r);
  }, Ci.diff = function (t, e) {
    var n = null;return n = t < e ? e - t : t - e, n > Math.PI && (n = 2 * Math.PI - n), n;
  }, Ci.toRadians = function (t) {
    return t * Math.PI / 180;
  }, Ci.getTurn = function (t, e) {
    var n = Math.sin(e - t);return n > 0 ? Ci.COUNTERCLOCKWISE : n < 0 ? Ci.CLOCKWISE : Ci.NONE;
  }, Ci.angleBetweenOriented = function (t, e, n) {
    var i = Ci.angle(e, t),
        r = Ci.angle(e, n),
        s = r - i;return s <= -Math.PI ? s + Ci.PI_TIMES_2 : s > Math.PI ? s - Ci.PI_TIMES_2 : s;
  }, Ci.PI_TIMES_2 = 2 * Math.PI, Ci.PI_OVER_2 = Math.PI / 2, Ci.PI_OVER_4 = Math.PI / 4, Ci.COUNTERCLOCKWISE = he.COUNTERCLOCKWISE, Ci.CLOCKWISE = he.CLOCKWISE, Ci.NONE = he.COLLINEAR, e(Si.prototype, { area: function () {
      return Si.area(this.p0, this.p1, this.p2);
    }, signedArea: function () {
      return Si.signedArea(this.p0, this.p1, this.p2);
    }, interpolateZ: function (t) {
      if (null === t) throw new i("Supplied point is null.");return Si.interpolateZ(t, this.p0, this.p1, this.p2);
    }, longestSideLength: function () {
      return Si.longestSideLength(this.p0, this.p1, this.p2);
    }, isAcute: function () {
      return Si.isAcute(this.p0, this.p1, this.p2);
    }, circumcentre: function () {
      return Si.circumcentre(this.p0, this.p1, this.p2);
    }, area3D: function () {
      return Si.area3D(this.p0, this.p1, this.p2);
    }, centroid: function () {
      return Si.centroid(this.p0, this.p1, this.p2);
    }, inCentre: function () {
      return Si.inCentre(this.p0, this.p1, this.p2);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Si;
    } }), Si.area = function (t, e, n) {
    return Math.abs(((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2);
  }, Si.signedArea = function (t, e, n) {
    return ((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2;
  }, Si.det = function (t, e, n, i) {
    return t * i - e * n;
  }, Si.interpolateZ = function (t, e, n, i) {
    var r = e.x,
        s = e.y,
        o = n.x - r,
        a = i.x - r,
        u = n.y - s,
        l = i.y - s,
        h = o * l - a * u,
        c = t.x - r,
        f = t.y - s,
        g = (l * c - a * f) / h,
        d = (-u * c + o * f) / h,
        p = e.z + g * (n.z - e.z) + d * (i.z - e.z);return p;
  }, Si.longestSideLength = function (t, e, n) {
    var i = t.distance(e),
        r = e.distance(n),
        s = n.distance(t),
        o = i;return r > o && (o = r), s > o && (o = s), o;
  }, Si.isAcute = function (t, e, n) {
    return !!Ci.isAcute(t, e, n) && !!Ci.isAcute(e, n, t) && !!Ci.isAcute(n, t, e);
  }, Si.circumcentre = function (t, e, n) {
    var i = n.x,
        r = n.y,
        s = t.x - i,
        o = t.y - r,
        a = e.x - i,
        u = e.y - r,
        l = 2 * Si.det(s, o, a, u),
        h = Si.det(o, s * s + o * o, u, a * a + u * u),
        c = Si.det(s, s * s + o * o, a, a * a + u * u),
        f = i - h / l,
        d = r + c / l;return new g(f, d);
  }, Si.perpendicularBisector = function (t, e) {
    var n = e.x - t.x,
        i = e.y - t.y,
        r = new F(t.x + n / 2, t.y + i / 2, 1),
        s = new F(t.x - i + n / 2, t.y + n + i / 2, 1);return new F(r, s);
  }, Si.angleBisector = function (t, e, n) {
    var i = e.distance(t),
        r = e.distance(n),
        s = i / (i + r),
        o = n.x - t.x,
        a = n.y - t.y,
        u = new g(t.x + s * o, t.y + s * a);return u;
  }, Si.area3D = function (t, e, n) {
    var i = e.x - t.x,
        r = e.y - t.y,
        s = e.z - t.z,
        o = n.x - t.x,
        a = n.y - t.y,
        u = n.z - t.z,
        l = r * u - s * a,
        h = s * o - i * u,
        c = i * a - r * o,
        f = l * l + h * h + c * c,
        g = Math.sqrt(f) / 2;return g;
  }, Si.centroid = function (t, e, n) {
    var i = (t.x + e.x + n.x) / 3,
        r = (t.y + e.y + n.y) / 3;return new g(i, r);
  }, Si.inCentre = function (t, e, n) {
    var i = e.distance(n),
        r = t.distance(n),
        s = t.distance(e),
        o = i + r + s,
        a = (i * t.x + r * e.x + s * n.x) / o,
        u = (i * t.y + r * e.y + s * n.y) / o;return new g(a, u);
  }, e(wi.prototype, { getRadius: function () {
      return this.compute(), this.radius;
    }, getDiameter: function () {
      switch (this.compute(), this.extremalPts.length) {case 0:
          return this.input.getFactory().createLineString();case 1:
          return this.input.getFactory().createPoint(this.centre);}var t = this.extremalPts[0],
          e = this.extremalPts[1];return this.input.getFactory().createLineString([t, e]);
    }, getExtremalPoints: function () {
      return this.compute(), this.extremalPts;
    }, computeCirclePoints: function () {
      if (this.input.isEmpty()) return this.extremalPts = new Array(0).fill(null), null;if (1 === this.input.getNumPoints()) {
        var t = this.input.getCoordinates();return this.extremalPts = [new g(t[0])], null;
      }var e = this.input.convexHull(),
          n = e.getCoordinates(),
          t = n;if (n[0].equals2D(n[n.length - 1]) && (t = new Array(n.length - 1).fill(null), H.copyDeep(n, 0, t, 0, n.length - 1)), t.length <= 2) return this.extremalPts = H.copyDeep(t), null;for (var i = wi.lowestPoint(t), r = wi.pointWitMinAngleWithX(t, i), s = 0; s < t.length; s++) {
        var o = wi.pointWithMinAngleWithSegment(t, i, r);if (Ci.isObtuse(i, o, r)) return this.extremalPts = [new g(i), new g(r)], null;if (Ci.isObtuse(o, i, r)) i = o;else {
          if (!Ci.isObtuse(o, r, i)) return this.extremalPts = [new g(i), new g(r), new g(o)], null;r = o;
        }
      }f.shouldNeverReachHere("Logic failure in Minimum Bounding Circle algorithm!");
    }, compute: function () {
      return null !== this.extremalPts ? null : (this.computeCirclePoints(), this.computeCentre(), void (null !== this.centre && (this.radius = this.centre.distance(this.extremalPts[0]))));
    }, getFarthestPoints: function () {
      switch (this.compute(), this.extremalPts.length) {case 0:
          return this.input.getFactory().createLineString();case 1:
          return this.input.getFactory().createPoint(this.centre);}var t = this.extremalPts[0],
          e = this.extremalPts[this.extremalPts.length - 1];return this.input.getFactory().createLineString([t, e]);
    }, getCircle: function () {
      if (this.compute(), null === this.centre) return this.input.getFactory().createPolygon();var t = this.input.getFactory().createPoint(this.centre);return 0 === this.radius ? t : t.buffer(this.radius);
    }, getCentre: function () {
      return this.compute(), this.centre;
    }, computeCentre: function () {
      switch (this.extremalPts.length) {case 0:
          this.centre = null;break;case 1:
          this.centre = this.extremalPts[0];break;case 2:
          this.centre = new g((this.extremalPts[0].x + this.extremalPts[1].x) / 2, (this.extremalPts[0].y + this.extremalPts[1].y) / 2);break;case 3:
          this.centre = Si.circumcentre(this.extremalPts[0], this.extremalPts[1], this.extremalPts[2]);}
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return wi;
    } }), wi.pointWitMinAngleWithX = function (t, e) {
    for (var n = r.MAX_VALUE, i = null, s = 0; s < t.length; s++) {
      var o = t[s];if (o !== e) {
        var a = o.x - e.x,
            u = o.y - e.y;u < 0 && (u = -u);var l = Math.sqrt(a * a + u * u),
            h = u / l;h < n && (n = h, i = o);
      }
    }return i;
  }, wi.lowestPoint = function (t) {
    for (var e = t[0], n = 1; n < t.length; n++) t[n].y < e.y && (e = t[n]);return e;
  }, wi.pointWithMinAngleWithSegment = function (t, e, n) {
    for (var i = r.MAX_VALUE, s = null, o = 0; o < t.length; o++) {
      var a = t[o];if (a !== e && a !== n) {
        var u = Ci.angleBetween(e, a, n);u < i && (i = u, s = a);
      }
    }return s;
  }, e(Li.prototype, { getWidthCoordinate: function () {
      return this.computeMinimumDiameter(), this.minWidthPt;
    }, getSupportingSegment: function () {
      return this.computeMinimumDiameter(), this.inputGeom.getFactory().createLineString([this.minBaseSeg.p0, this.minBaseSeg.p1]);
    }, getDiameter: function () {
      if (this.computeMinimumDiameter(), null === this.minWidthPt) return this.inputGeom.getFactory().createLineString(null);var t = this.minBaseSeg.project(this.minWidthPt);return this.inputGeom.getFactory().createLineString([t, this.minWidthPt]);
    }, computeWidthConvex: function (t) {
      t instanceof Tt ? this.convexHullPts = t.getExteriorRing().getCoordinates() : this.convexHullPts = t.getCoordinates(), 0 === this.convexHullPts.length ? (this.minWidth = 0, this.minWidthPt = null, this.minBaseSeg = null) : 1 === this.convexHullPts.length ? (this.minWidth = 0, this.minWidthPt = this.convexHullPts[0], this.minBaseSeg.p0 = this.convexHullPts[0], this.minBaseSeg.p1 = this.convexHullPts[0]) : 2 === this.convexHullPts.length || 3 === this.convexHullPts.length ? (this.minWidth = 0, this.minWidthPt = this.convexHullPts[0], this.minBaseSeg.p0 = this.convexHullPts[0], this.minBaseSeg.p1 = this.convexHullPts[1]) : this.computeConvexRingMinDiameter(this.convexHullPts);
    }, computeConvexRingMinDiameter: function (t) {
      this.minWidth = r.MAX_VALUE;for (var e = 1, n = new ce(), i = 0; i < t.length - 1; i++) n.p0 = t[i], n.p1 = t[i + 1], e = this.findMaxPerpDistance(t, n, e);
    }, computeMinimumDiameter: function () {
      if (null !== this.minWidthPt) return null;if (this.isConvex) this.computeWidthConvex(this.inputGeom);else {
        var t = new me(this.inputGeom).getConvexHull();this.computeWidthConvex(t);
      }
    }, getLength: function () {
      return this.computeMinimumDiameter(), this.minWidth;
    }, findMaxPerpDistance: function (t, e, n) {
      for (var i = e.distancePerpendicular(t[n]), r = i, s = n, o = s; r >= i;) i = r, s = o, o = Li.nextIndex(t, s), r = e.distancePerpendicular(t[o]);return i < this.minWidth && (this.minPtIndex = s, this.minWidth = i, this.minWidthPt = t[this.minPtIndex], this.minBaseSeg = new ce(e)), s;
    }, getMinimumRectangle: function () {
      if (this.computeMinimumDiameter(), 0 === this.minWidth) return this.minBaseSeg.p0.equals2D(this.minBaseSeg.p1) ? this.inputGeom.getFactory().createPoint(this.minBaseSeg.p0) : this.minBaseSeg.toGeometry(this.inputGeom.getFactory());for (var t = this.minBaseSeg.p1.x - this.minBaseSeg.p0.x, e = this.minBaseSeg.p1.y - this.minBaseSeg.p0.y, n = r.MAX_VALUE, i = -r.MAX_VALUE, s = r.MAX_VALUE, o = -r.MAX_VALUE, a = 0; a < this.convexHullPts.length; a++) {
        var u = Li.computeC(t, e, this.convexHullPts[a]);u > i && (i = u), u < n && (n = u);var l = Li.computeC(-e, t, this.convexHullPts[a]);l > o && (o = l), l < s && (s = l);
      }var h = Li.computeSegmentForLine(-t, -e, o),
          c = Li.computeSegmentForLine(-t, -e, s),
          f = Li.computeSegmentForLine(-e, t, i),
          g = Li.computeSegmentForLine(-e, t, n),
          d = f.lineIntersection(h),
          p = g.lineIntersection(h),
          v = g.lineIntersection(c),
          m = f.lineIntersection(c),
          y = this.inputGeom.getFactory().createLinearRing([d, p, v, m, d]);return this.inputGeom.getFactory().createPolygon(y, null);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Li;
    } }), Li.nextIndex = function (t, e) {
    return e++, e >= t.length && (e = 0), e;
  }, Li.computeC = function (t, e, n) {
    return t * n.y - e * n.x;
  }, Li.getMinimumDiameter = function (t) {
    return new Li(t).getDiameter();
  }, Li.getMinimumRectangle = function (t) {
    return new Li(t).getMinimumRectangle();
  }, Li.computeSegmentForLine = function (t, e, n) {
    var i = null,
        r = null;return Math.abs(e) > Math.abs(t) ? (i = new g(0, n / e), r = new g(1, n / e - t / e)) : (i = new g(n / t, 0), r = new g(n / t - e / t, 1)), new ce(i, r);
  };var co = Object.freeze({ Centroid: ge, CGAlgorithms: he, ConvexHull: me, InteriorPointArea: oi, InteriorPointLine: ui, InteriorPointPoint: li, RobustLineIntersector: ae, MCPointInRing: Ii, MinimumBoundingCircle: wi, MinimumDiameter: Li });e(Ri.prototype, { getResultGeometry: function () {
      return new Ti(this.distanceTolerance).transform(this.inputGeom);
    }, setDistanceTolerance: function (t) {
      if (t <= 0) throw new i("Tolerance must be positive");this.distanceTolerance = t;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Ri;
    } }), Ri.densifyPoints = function (t, e, n) {
    for (var i = new ce(), r = new N(), s = 0; s < t.length - 1; s++) {
      i.p0 = t[s], i.p1 = t[s + 1], r.add(i.p0, !1);var o = i.getLength(),
          a = Math.trunc(o / e) + 1;if (a > 1) for (var u = o / a, l = 1; l < a; l++) {
        var h = l * u / o,
            c = i.pointAlong(h);n.makePrecise(c), r.add(c, !1);
      }
    }return r.add(t[t.length - 1], !1), r.toCoordinateArray();
  }, Ri.densify = function (t, e) {
    var n = new Ri(t);return n.setDistanceTolerance(e), n.getResultGeometry();
  }, h(Ti, xe), e(Ti.prototype, { transformMultiPolygon: function (t, e) {
      var n = xe.prototype.transformMultiPolygon.call(this, t, e);return this.createValidArea(n);
    }, transformPolygon: function (t, e) {
      var n = xe.prototype.transformPolygon.call(this, t, e);return e instanceof Ot ? n : this.createValidArea(n);
    }, transformCoordinates: function (t, e) {
      var n = t.toCoordinateArray(),
          i = Ri.densifyPoints(n, this.distanceTolerance, e.getPrecisionModel());return e instanceof St && 1 === i.length && (i = new Array(0).fill(null)), this.factory.getCoordinateSequenceFactory().create(i);
    }, createValidArea: function (t) {
      return t.buffer(0);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Ti;
    } }), Ri.DensifyTransformer = Ti;var fo = Object.freeze({ Densifier: Ri });e(Pi.prototype, { find: function (t) {
      var e = this;do {
        if (null === e) return null;if (e.dest().equals2D(t)) return e;e = e.oNext();
      } while (e !== this);return null;
    }, dest: function () {
      return this._sym._orig;
    }, oNext: function () {
      return this._sym._next;
    }, insert: function (t) {
      if (this.oNext() === this) return this.insertAfter(t), null;var e = this.compareTo(t),
          n = this;do {
        var i = n.oNext(),
            r = i.compareTo(t);if (r !== e || i === this) return n.insertAfter(t), null;n = i;
      } while (n !== this);f.shouldNeverReachHere();
    }, insertAfter: function (t) {
      f.equals(this._orig, t.orig());var e = this.oNext();this._sym.setNext(t), t.sym().setNext(e);
    }, degree: function t() {
      var t = 0,
          e = this;do t++, e = e.oNext(); while (e !== this);return t;
    }, equals: function () {
      if (2 === arguments.length) {
        var t = arguments[0],
            e = arguments[1];return this._orig.equals2D(t) && this._sym._orig.equals(e);
      }
    }, deltaY: function () {
      return this._sym._orig.y - this._orig.y;
    }, sym: function () {
      return this._sym;
    }, prev: function () {
      return this._sym.next()._sym;
    }, compareAngularDirection: function (t) {
      var e = this.deltaX(),
          n = this.deltaY(),
          i = t.deltaX(),
          r = t.deltaY();if (e === i && n === r) return 0;var s = Je.quadrant(e, n),
          o = Je.quadrant(i, r);return s > o ? 1 : s < o ? -1 : he.computeOrientation(t._orig, t.dest(), this.dest());
    }, prevNode: function () {
      for (var t = this; 2 === t.degree();) if (t = t.prev(), t === this) return null;return t;
    }, compareTo: function (t) {
      var e = t,
          n = this.compareAngularDirection(e);return n;
    }, next: function () {
      return this._next;
    }, setSym: function (t) {
      this._sym = t;
    }, orig: function () {
      return this._orig;
    }, toString: function () {
      return "HE(" + this._orig.x + " " + this._orig.y + ", " + this._sym._orig.x + " " + this._sym._orig.y + ")";
    }, setNext: function (t) {
      this._next = t;
    }, init: function (t) {
      this.setSym(t), t.setSym(this), this.setNext(t), t.setNext(this);
    }, deltaX: function () {
      return this._sym._orig.x - this._orig.x;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Pi;
    } }), Pi.init = function (t, e) {
    if (null !== t._sym || null !== e._sym || null !== t._next || null !== e._next) throw new IllegalStateException("Edges are already initialized");return t.init(e), t;
  }, Pi.create = function (t, e) {
    var n = new Pi(t),
        i = new Pi(e);return n.init(i), n;
  }, h(bi, Pi), e(bi.prototype, { mark: function () {
      this._isMarked = !0;
    }, setMark: function (t) {
      this._isMarked = t;
    }, isMarked: function () {
      return this._isMarked;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return bi;
    } }), bi.setMarkBoth = function (t, e) {
    t.setMark(e), t.sym().setMark(e);
  }, bi.isMarked = function (t) {
    return t.isMarked();
  }, bi.setMark = function (t, e) {
    t.setMark(e);
  }, bi.markBoth = function (t) {
    t.mark(), t.sym().mark();
  }, bi.mark = function (t) {
    t.mark();
  }, e(Oi.prototype, { insert: function (t, e, n) {
      var i = this.create(t, e);null !== n ? n.insert(i) : this.vertexMap.put(t, i);var r = this.vertexMap.get(e);return null !== r ? r.insert(i.sym()) : this.vertexMap.put(e, i.sym()), i;
    }, create: function (t, e) {
      var n = this.createEdge(t),
          i = this.createEdge(e);return Pi.init(n, i), n;
    }, createEdge: function (t) {
      return new Pi(t);
    }, addEdge: function (t, e) {
      if (!Oi.isValidEdge(t, e)) return null;var n = this.vertexMap.get(t),
          i = null;if (null !== n && (i = n.find(e)), null !== i) return i;var r = this.insert(t, e, n);return r;
    }, getVertexEdges: function () {
      return this.vertexMap.values();
    }, findEdge: function (t, e) {
      var n = this.vertexMap.get(t);return null === n ? null : n.find(e);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Oi;
    } }), Oi.isValidEdge = function (t, e) {
    var n = e.compareTo(t);return 0 !== n;
  }, h(_i, bi), e(_i.prototype, { setStart: function () {
      this._isStart = !0;
    }, isStart: function () {
      return this._isStart;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return _i;
    } }), h(Mi, Oi), e(Mi.prototype, { createEdge: function (t) {
      return new _i(t);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Mi;
    } }), e(Di.prototype, { addLine: function (t) {
      this.lines.add(this.factory.createLineString(t.toCoordinateArray()));
    }, updateRingStartEdge: function (t) {
      return t.isStart() || (t = t.sym(), t.isStart()) ? null === this.ringStartEdge ? (this.ringStartEdge = t, null) : void (t.orig().compareTo(this.ringStartEdge.orig()) < 0 && (this.ringStartEdge = t)) : null;
    }, getResult: function () {
      return null === this.result && this.computeResult(), this.result;
    }, process: function (t) {
      var e = t.prevNode();null === e && (e = t), this.stackEdges(e), this.buildLines();
    }, buildRing: function (t) {
      var e = new N(),
          n = t;for (e.add(n.orig().copy(), !1); 2 === n.sym().degree();) {
        var i = n.next();if (i === t) break;e.add(i.orig().copy(), !1), n = i;
      }e.add(n.dest().copy(), !1), this.addLine(e);
    }, buildLine: function (t) {
      var e = new N(),
          n = t;for (this.ringStartEdge = null, bi.markBoth(n), e.add(n.orig().copy(), !1); 2 === n.sym().degree();) {
        this.updateRingStartEdge(n);var i = n.next();if (i === t) return this.buildRing(this.ringStartEdge), null;e.add(i.orig().copy(), !1), n = i, bi.markBoth(n);
      }e.add(n.dest().copy(), !1), this.stackEdges(n.sym()), this.addLine(e);
    }, stackEdges: function (t) {
      var e = t;do bi.isMarked(e) || this.nodeEdgeStack.add(e), e = e.oNext(); while (e !== t);
    }, computeResult: function () {
      for (var t = this.graph.getVertexEdges(), e = t.iterator(); e.hasNext();) {
        var n = e.next();bi.isMarked(n) || this.process(n);
      }this.result = this.factory.buildGeometry(this.lines);
    }, buildLines: function () {
      for (; !this.nodeEdgeStack.empty();) {
        var t = this.nodeEdgeStack.pop();bi.isMarked(t) || this.buildLine(t);
      }
    }, add: function () {
      if (arguments[0] instanceof B) {
        var t = arguments[0];t.apply({ interfaces_: function () {
            return [q];
          }, filter: function (t) {
            t instanceof St && this.add(t);
          } });
      } else if (R(arguments[0], v)) for (var e = arguments[0], n = e.iterator(); n.hasNext();) {
        var i = n.next();this.add(i);
      } else if (arguments[0] instanceof St) {
        var r = arguments[0];null === this.factory && (this.factory = r.getFactory());for (var s = r.getCoordinateSequence(), o = !1, n = 1; n < s.size(); n++) {
          var a = this.graph.addEdge(s.getCoordinate(n - 1), s.getCoordinate(n));null !== a && (o || (a.setStart(), o = !0));
        }
      }
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Di;
    } }), Di.dissolve = function (t) {
    var e = new Di();return e.add(t), e.getResult();
  };var go = Object.freeze({ LineDissolver: Di }),
      po = Object.freeze({ GeometryGraph: $n });e(Ai.prototype, { hasChildren: function () {
      for (var t = 0; t < 4; t++) if (null !== this.subnode[t]) return !0;return !1;
    }, isPrunable: function () {
      return !(this.hasChildren() || this.hasItems());
    }, addAllItems: function (t) {
      t.addAll(this.items);for (var e = 0; e < 4; e++) null !== this.subnode[e] && this.subnode[e].addAllItems(t);return t;
    }, getNodeCount: function () {
      for (var t = 0, e = 0; e < 4; e++) null !== this.subnode[e] && (t += this.subnode[e].size());return t + 1;
    }, size: function () {
      for (var t = 0, e = 0; e < 4; e++) null !== this.subnode[e] && (t += this.subnode[e].size());return t + this.items.size();
    }, addAllItemsFromOverlapping: function (t, e) {
      if (!this.isSearchMatch(t)) return null;e.addAll(this.items);for (var n = 0; n < 4; n++) null !== this.subnode[n] && this.subnode[n].addAllItemsFromOverlapping(t, e);
    }, visitItems: function (t, e) {
      for (var n = this.items.iterator(); n.hasNext();) e.visitItem(n.next());
    }, hasItems: function () {
      return !this.items.isEmpty();
    }, remove: function (t, e) {
      if (!this.isSearchMatch(t)) return !1;for (var n = !1, i = 0; i < 4; i++) if (null !== this.subnode[i] && (n = this.subnode[i].remove(t, e))) {
        this.subnode[i].isPrunable() && (this.subnode[i] = null);break;
      }return n ? n : n = this.items.remove(e);
    }, visit: function (t, e) {
      if (!this.isSearchMatch(t)) return null;this.visitItems(t, e);for (var n = 0; n < 4; n++) null !== this.subnode[n] && this.subnode[n].visit(t, e);
    }, getItems: function () {
      return this.items;
    }, depth: function () {
      for (var t = 0, e = 0; e < 4; e++) if (null !== this.subnode[e]) {
        var n = this.subnode[e].depth();n > t && (t = n);
      }return t + 1;
    }, isEmpty: function t() {
      var t = !0;this.items.isEmpty() || (t = !1);for (var e = 0; e < 4; e++) null !== this.subnode[e] && (this.subnode[e].isEmpty() || (t = !1));return t;
    }, add: function (t) {
      this.items.add(t);
    }, interfaces_: function () {
      return [u];
    }, getClass: function () {
      return Ai;
    } }), Ai.getSubnodeIndex = function (t, e, n) {
    var i = -1;return t.getMinX() >= e && (t.getMinY() >= n && (i = 3), t.getMaxY() <= n && (i = 1)), t.getMaxX() <= e && (t.getMinY() >= n && (i = 2), t.getMaxY() <= n && (i = 0)), i;
  }, e(Fi.prototype, { getLevel: function () {
      return this.level;
    }, computeKey: function () {
      if (1 === arguments.length) {
        var t = arguments[0];for (this.level = Fi.computeQuadLevel(t), this.env = new C(), this.computeKey(this.level, t); !this.env.contains(t);) this.level += 1, this.computeKey(this.level, t);
      } else if (2 === arguments.length) {
        var e = arguments[0],
            n = arguments[1],
            i = gi.powerOf2(e);this.pt.x = Math.floor(n.getMinX() / i) * i, this.pt.y = Math.floor(n.getMinY() / i) * i, this.env.init(this.pt.x, this.pt.x + i, this.pt.y, this.pt.y + i);
      }
    }, getEnvelope: function () {
      return this.env;
    }, getCentre: function () {
      return new g((this.env.getMinX() + this.env.getMaxX()) / 2, (this.env.getMinY() + this.env.getMaxY()) / 2);
    }, getPoint: function () {
      return this.pt;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Fi;
    } }), Fi.computeQuadLevel = function (t) {
    var e = t.getWidth(),
        n = t.getHeight(),
        i = e > n ? e : n,
        r = gi.exponent(i) + 1;return r;
  }, h(Gi, Ai), e(Gi.prototype, { find: function (t) {
      var e = Ai.getSubnodeIndex(t, this.centrex, this.centrey);if (e === -1) return this;if (null !== this.subnode[e]) {
        var n = this.subnode[e];return n.find(t);
      }return this;
    }, isSearchMatch: function (t) {
      return this.env.intersects(t);
    }, getSubnode: function (t) {
      return null === this.subnode[t] && (this.subnode[t] = this.createSubnode(t)), this.subnode[t];
    }, getEnvelope: function () {
      return this.env;
    }, getNode: function (t) {
      var e = Ai.getSubnodeIndex(t, this.centrex, this.centrey);if (e !== -1) {
        var n = this.getSubnode(e);return n.getNode(t);
      }return this;
    }, createSubnode: function (t) {
      var e = 0,
          n = 0,
          i = 0,
          r = 0;switch (t) {case 0:
          e = this.env.getMinX(), n = this.centrex, i = this.env.getMinY(), r = this.centrey;break;case 1:
          e = this.centrex, n = this.env.getMaxX(), i = this.env.getMinY(), r = this.centrey;break;case 2:
          e = this.env.getMinX(), n = this.centrex, i = this.centrey, r = this.env.getMaxY();break;case 3:
          e = this.centrex, n = this.env.getMaxX(), i = this.centrey, r = this.env.getMaxY();}var s = new C(e, n, i, r),
          o = new Gi(s, this.level - 1);return o;
    }, insertNode: function (t) {
      f.isTrue(null === this.env || this.env.contains(t.env));var e = Ai.getSubnodeIndex(t.env, this.centrex, this.centrey);if (t.level === this.level - 1) this.subnode[e] = t;else {
        var n = this.createSubnode(e);n.insertNode(t), this.subnode[e] = n;
      }
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Gi;
    } }), Gi.createNode = function (t) {
    var e = new Fi(t),
        n = new Gi(e.getEnvelope(), e.getLevel());return n;
  }, Gi.createExpanded = function (t, e) {
    var n = new C(e);null !== t && n.expandToInclude(t.env);var i = Gi.createNode(n);return null !== t && i.insertNode(t), i;
  }, h(qi, Ai), e(qi.prototype, { insert: function (t, e) {
      var n = Ai.getSubnodeIndex(t, qi.origin.x, qi.origin.y);if (n === -1) return this.add(e), null;var i = this.subnode[n];if (null === i || !i.getEnvelope().contains(t)) {
        var r = Gi.createExpanded(i, t);this.subnode[n] = r;
      }this.insertContained(this.subnode[n], t, e);
    }, isSearchMatch: function (t) {
      return !0;
    }, insertContained: function (t, e, n) {
      f.isTrue(t.getEnvelope().contains(e));var i = mi.isZeroWidth(e.getMinX(), e.getMaxX()),
          r = mi.isZeroWidth(e.getMinY(), e.getMaxY()),
          s = null;s = i || r ? t.find(e) : t.getNode(e), s.add(n);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return qi;
    } }), qi.origin = new g(0, 0), e(Bi.prototype, { size: function () {
      return null !== this.root ? this.root.size() : 0;
    }, insert: function (t, e) {
      this.collectStats(t);var n = Bi.ensureExtent(t, this.minExtent);this.root.insert(n, e);
    }, query: function () {
      if (1 === arguments.length) {
        var t = arguments[0],
            e = new Yn();return this.query(t, e), e.getItems();
      }if (2 === arguments.length) {
        var n = arguments[0],
            i = arguments[1];this.root.visit(n, i);
      }
    }, queryAll: function () {
      var t = new I();return this.root.addAllItems(t), t;
    }, remove: function (t, e) {
      var n = Bi.ensureExtent(t, this.minExtent);return this.root.remove(n, e);
    }, collectStats: function (t) {
      var e = t.getWidth();e < this.minExtent && e > 0 && (this.minExtent = e);var n = t.getHeight();n < this.minExtent && n > 0 && (this.minExtent = n);
    }, depth: function () {
      return null !== this.root ? this.root.depth() : 0;
    }, isEmpty: function () {
      return null === this.root;
    }, interfaces_: function () {
      return [Fe, u];
    }, getClass: function () {
      return Bi;
    } }), Bi.ensureExtent = function (t, e) {
    var n = t.getMinX(),
        i = t.getMaxX(),
        r = t.getMinY(),
        s = t.getMaxY();return n !== i && r !== s ? t : (n === i && (n -= e / 2, i = n + e / 2), r === s && (r -= e / 2, s = r + e / 2), new C(n, i, r, s));
  }, Bi.serialVersionUID = -0x678b60c967a25400;var vo = Object.freeze({ Quadtree: Bi }),
      mo = Object.freeze({ STRtree: ke }),
      yo = Object.freeze({ quadtree: vo, strtree: mo }),
      xo = ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"];e(zi.prototype, { read: function (t) {
      var e = void 0;e = "string" == typeof t ? JSON.parse(t) : t;var n = e.type;if (!Eo[n]) throw new Error("Unknown GeoJSON type: " + e.type);return xo.indexOf(n) !== -1 ? Eo[n].apply(this, [e.coordinates]) : "GeometryCollection" === n ? Eo[n].apply(this, [e.geometries]) : Eo[n].apply(this, [e]);
    }, write: function (t) {
      var e = t.getGeometryType();if (!Io[e]) throw new Error("Geometry is not supported");return Io[e].apply(this, [t]);
    } });var Eo = { Feature: function (t) {
      var e = {};for (var n in t) e[n] = t[n];if (t.geometry) {
        var i = t.geometry.type;if (!Eo[i]) throw new Error("Unknown GeoJSON type: " + t.type);e.geometry = this.read(t.geometry);
      }return t.bbox && (e.bbox = Eo.bbox.apply(this, [t.bbox])), e;
    }, FeatureCollection: function (t) {
      var e = {};if (t.features) {
        e.features = [];for (var n = 0; n < t.features.length; ++n) e.features.push(this.read(t.features[n]));
      }return t.bbox && (e.bbox = this.parse.bbox.apply(this, [t.bbox])), e;
    }, coordinates: function t(e) {
      for (var t = [], n = 0; n < e.length; ++n) {
        var i = e[n];t.push(new g(i[0], i[1]));
      }return t;
    }, bbox: function (t) {
      return this.geometryFactory.createLinearRing([new g(t[0], t[1]), new g(t[2], t[1]), new g(t[2], t[3]), new g(t[0], t[3]), new g(t[0], t[1])]);
    }, Point: function (t) {
      var e = new g(t[0], t[1]);return this.geometryFactory.createPoint(e);
    }, MultiPoint: function (t) {
      for (var e = [], n = 0; n < t.length; ++n) e.push(Eo.Point.apply(this, [t[n]]));return this.geometryFactory.createMultiPoint(e);
    }, LineString: function (t) {
      var e = Eo.coordinates.apply(this, [t]);return this.geometryFactory.createLineString(e);
    }, MultiLineString: function (t) {
      for (var e = [], n = 0; n < t.length; ++n) e.push(Eo.LineString.apply(this, [t[n]]));return this.geometryFactory.createMultiLineString(e);
    }, Polygon: function (t) {
      for (var e = Eo.coordinates.apply(this, [t[0]]), n = this.geometryFactory.createLinearRing(e), i = [], r = 1; r < t.length; ++r) {
        var s = t[r],
            o = Eo.coordinates.apply(this, [s]),
            a = this.geometryFactory.createLinearRing(o);i.push(a);
      }return this.geometryFactory.createPolygon(n, i);
    }, MultiPolygon: function (t) {
      for (var e = [], n = 0; n < t.length; ++n) {
        var i = t[n];e.push(Eo.Polygon.apply(this, [i]));
      }return this.geometryFactory.createMultiPolygon(e);
    }, GeometryCollection: function (t) {
      for (var e = [], n = 0; n < t.length; ++n) {
        var i = t[n];e.push(this.read(i));
      }return this.geometryFactory.createGeometryCollection(e);
    } },
      Io = { coordinate: function (t) {
      return [t.x, t.y];
    }, Point: function (t) {
      var e = Io.coordinate.apply(this, [t.getCoordinate()]);return { type: "Point", coordinates: e };
    }, MultiPoint: function (t) {
      for (var e = [], n = 0; n < t.geometries.length; ++n) {
        var i = t.geometries[n],
            r = Io.Point.apply(this, [i]);e.push(r.coordinates);
      }return { type: "MultiPoint", coordinates: e };
    }, LineString: function (t) {
      for (var e = [], n = t.getCoordinates(), i = 0; i < n.length; ++i) {
        var r = n[i];e.push(Io.coordinate.apply(this, [r]));
      }return { type: "LineString", coordinates: e };
    }, MultiLineString: function (t) {
      for (var e = [], n = 0; n < t.geometries.length; ++n) {
        var i = t.geometries[n],
            r = Io.LineString.apply(this, [i]);e.push(r.coordinates);
      }return { type: "MultiLineString", coordinates: e };
    }, Polygon: function (t) {
      var e = [],
          n = Io.LineString.apply(this, [t.shell]);e.push(n.coordinates);for (var i = 0; i < t.holes.length; ++i) {
        var r = t.holes[i],
            s = Io.LineString.apply(this, [r]);e.push(s.coordinates);
      }return { type: "Polygon", coordinates: e };
    }, MultiPolygon: function (t) {
      for (var e = [], n = 0; n < t.geometries.length; ++n) {
        var i = t.geometries[n],
            r = Io.Polygon.apply(this, [i]);e.push(r.coordinates);
      }return { type: "MultiPolygon", coordinates: e };
    }, GeometryCollection: function (t) {
      for (var e = [], n = 0; n < t.geometries.length; ++n) {
        var i = t.geometries[n],
            r = i.getGeometryType();e.push(Io[r].apply(this, [i]));
      }return { type: "GeometryCollection", geometries: e };
    } };e(Vi.prototype, { read: function (t) {
      var e = this.parser.read(t);return this.precisionModel.getType() === ee.FIXED && this.reducePrecision(e), e;
    }, reducePrecision: function (t) {
      var e, n;if (t.coordinate) this.precisionModel.makePrecise(t.coordinate);else if (t.points) for (e = 0, n = t.points.length; e < n; e++) this.precisionModel.makePrecise(t.points[e]);else if (t.geometries) for (e = 0, n = t.geometries.length; e < n; e++) this.reducePrecision(t.geometries[e]);
    } }), e(ki.prototype, { write: function (t) {
      return this.parser.write(t);
    } }), e(Yi.prototype, { read: function (t) {
      var e = this.parser.read(t);return this.precisionModel.getType() === ee.FIXED && this.reducePrecision(e), e;
    }, reducePrecision: function (t) {
      if (t.coordinate) this.precisionModel.makePrecise(t.coordinate);else if (t.points) for (var e = 0, n = t.points.coordinates.length; e < n; e++) this.precisionModel.makePrecise(t.points.coordinates[e]);else if (t.geometries) for (var i = 0, r = t.geometries.length; i < r; i++) this.reducePrecision(t.geometries[i]);
    } }), e(Xi.prototype, { read: function (t) {
      var e = this.ol;return t instanceof e.geom.Point ? this.convertFromPoint(t) : t instanceof e.geom.LineString ? this.convertFromLineString(t) : t instanceof e.geom.LinearRing ? this.convertFromLinearRing(t) : t instanceof e.geom.Polygon ? this.convertFromPolygon(t) : t instanceof e.geom.MultiPoint ? this.convertFromMultiPoint(t) : t instanceof e.geom.MultiLineString ? this.convertFromMultiLineString(t) : t instanceof e.geom.MultiPolygon ? this.convertFromMultiPolygon(t) : t instanceof e.geom.GeometryCollection ? this.convertFromCollection(t) : void 0;
    }, convertFromPoint: function (t) {
      var e = t.getCoordinates();return this.geometryFactory.createPoint(new g(e[0], e[1]));
    }, convertFromLineString: function (t) {
      return this.geometryFactory.createLineString(t.getCoordinates().map(function (t) {
        return new g(t[0], t[1]);
      }));
    }, convertFromLinearRing: function (t) {
      return this.geometryFactory.createLinearRing(t.getCoordinates().map(function (t) {
        return new g(t[0], t[1]);
      }));
    }, convertFromPolygon: function (t) {
      for (var e = t.getLinearRings(), n = null, i = [], r = 0; r < e.length; r++) {
        var s = this.convertFromLinearRing(e[r]);0 === r ? n = s : i.push(s);
      }return this.geometryFactory.createPolygon(n, i);
    }, convertFromMultiPoint: function (t) {
      var e = t.getPoints().map(function (t) {
        return this.convertFromPoint(t);
      }, this);return this.geometryFactory.createMultiPoint(e);
    }, convertFromMultiLineString: function (t) {
      var e = t.getLineStrings().map(function (t) {
        return this.convertFromLineString(t);
      }, this);return this.geometryFactory.createMultiLineString(e);
    }, convertFromMultiPolygon: function (t) {
      var e = t.getPolygons().map(function (t) {
        return this.convertFromPolygon(t);
      }, this);return this.geometryFactory.createMultiPolygon(e);
    }, convertFromCollection: function (t) {
      var e = t.getGeometries().map(function (t) {
        return this.read(t);
      }, this);return this.geometryFactory.createGeometryCollection(e);
    }, write: function (t) {
      return "Point" === t.getGeometryType() ? this.convertToPoint(t.getCoordinate()) : "LineString" === t.getGeometryType() ? this.convertToLineString(t) : "LinearRing" === t.getGeometryType() ? this.convertToLinearRing(t) : "Polygon" === t.getGeometryType() ? this.convertToPolygon(t) : "MultiPoint" === t.getGeometryType() ? this.convertToMultiPoint(t) : "MultiLineString" === t.getGeometryType() ? this.convertToMultiLineString(t) : "MultiPolygon" === t.getGeometryType() ? this.convertToMultiPolygon(t) : "GeometryCollection" === t.getGeometryType() ? this.convertToCollection(t) : void 0;
    }, convertToPoint: function (t) {
      return new this.ol.geom.Point([t.x, t.y]);
    }, convertToLineString: function (t) {
      var e = t.points.coordinates.map(Ui);return new this.ol.geom.LineString(e);
    }, convertToLinearRing: function (t) {
      var e = t.points.coordinates.map(Ui);return new this.ol.geom.LinearRing(e);
    }, convertToPolygon: function (t) {
      for (var e = [t.shell.points.coordinates.map(Ui)], n = 0; n < t.holes.length; n++) e.push(t.holes[n].points.coordinates.map(Ui));return new this.ol.geom.Polygon(e);
    }, convertToMultiPoint: function (t) {
      return new this.ol.geom.MultiPoint(t.getCoordinates().map(Ui));
    }, convertToMultiLineString: function (t) {
      for (var e = [], n = 0; n < t.geometries.length; n++) e.push(this.convertToLineString(t.geometries[n]).getCoordinates());return new this.ol.geom.MultiLineString(e);
    }, convertToMultiPolygon: function (t) {
      for (var e = [], n = 0; n < t.geometries.length; n++) e.push(this.convertToPolygon(t.geometries[n]).getCoordinates());return new this.ol.geom.MultiPolygon(e);
    }, convertToCollection: function (t) {
      for (var e = [], n = 0; n < t.geometries.length; n++) {
        var i = t.geometries[n];e.push(this.write(i));
      }return new this.ol.geom.GeometryCollection(e);
    } });var No = Object.freeze({ GeoJSONReader: Vi, GeoJSONWriter: ki, OL3Parser: Xi, WKTReader: Yi, WKTWriter: se });e(Hi.prototype, { rescale: function () {
      if (R(arguments[0], v)) for (var t = arguments[0], e = t.iterator(); e.hasNext();) {
        var n = e.next();this.rescale(n.getCoordinates());
      } else if (arguments[0] instanceof Array) {
        var i = arguments[0],
            r = null,
            s = null;2 === i.length && (r = new g(i[0]), s = new g(i[1]));for (var e = 0; e < i.length; e++) i[e].x = i[e].x / this.scaleFactor + this.offsetX, i[e].y = i[e].y / this.scaleFactor + this.offsetY;2 === i.length && i[0].equals2D(i[1]) && A.out.println(i);
      }
    }, scale: function () {
      if (R(arguments[0], v)) {
        for (var t = arguments[0], e = new I(), n = t.iterator(); n.hasNext();) {
          var i = n.next();e.add(new Ke(this.scale(i.getCoordinates()), i.getData()));
        }return e;
      }if (arguments[0] instanceof Array) {
        for (var r = arguments[0], s = new Array(r.length).fill(null), n = 0; n < r.length; n++) s[n] = new g(Math.round((r[n].x - this.offsetX) * this.scaleFactor), Math.round((r[n].y - this.offsetY) * this.scaleFactor), r[n].z);var o = H.removeRepeatedPoints(s);return o;
      }
    }, isIntegerPrecision: function () {
      return 1 === this.scaleFactor;
    }, getNodedSubstrings: function () {
      var t = this.noder.getNodedSubstrings();return this.isScaled && this.rescale(t), t;
    }, computeNodes: function (t) {
      var e = t;this.isScaled && (e = this.scale(t)), this.noder.computeNodes(e);
    }, interfaces_: function () {
      return [tn];
    }, getClass: function () {
      return Hi;
    } });var Co = Object.freeze({ MCIndexNoder: nn, ScaledNoder: Hi, SegmentString: be });e(Wi.prototype, { isSimpleMultiPoint: function (t) {
      if (t.isEmpty()) return !0;for (var e = new at(), n = 0; n < t.getNumGeometries(); n++) {
        var i = t.getGeometryN(n),
            r = i.getCoordinate();if (e.contains(r)) return this.nonSimpleLocation = r, !1;e.add(r);
      }return !0;
    }, isSimplePolygonal: function (t) {
      for (var e = kn.getLines(t), n = e.iterator(); n.hasNext();) {
        var i = n.next();if (!this.isSimpleLinearGeometry(i)) return !1;
      }return !0;
    }, hasClosedEndpointIntersection: function (t) {
      for (var e = new rt(), n = t.getEdgeIterator(); n.hasNext();) {
        var i = n.next(),
            r = (i.getMaximumSegmentIndex(), i.isClosed()),
            s = i.getCoordinate(0);this.addEndpoint(e, s, r);var o = i.getCoordinate(i.getNumPoints() - 1);this.addEndpoint(e, o, r);
      }for (var n = e.values().iterator(); n.hasNext();) {
        var a = n.next();if (a.isClosed && 2 !== a.degree) return this.nonSimpleLocation = a.getCoordinate(), !0;
      }return !1;
    }, getNonSimpleLocation: function () {
      return this.nonSimpleLocation;
    }, isSimpleLinearGeometry: function (t) {
      if (t.isEmpty()) return !0;var e = new $n(0, t),
          n = new ae(),
          i = e.computeSelfNodes(n, !0);return !i.hasIntersection() || (i.hasProperIntersection() ? (this.nonSimpleLocation = i.getProperIntersectionPoint(), !1) : !this.hasNonEndpointIntersection(e) && (!this.isClosedEndpointsInInterior || !this.hasClosedEndpointIntersection(e)));
    }, hasNonEndpointIntersection: function (t) {
      for (var e = t.getEdgeIterator(); e.hasNext();) for (var n = e.next(), i = n.getMaximumSegmentIndex(), r = n.getEdgeIntersectionList().iterator(); r.hasNext();) {
        var s = r.next();if (!s.isEndPoint(i)) return this.nonSimpleLocation = s.getCoordinate(), !0;
      }return !1;
    }, addEndpoint: function (t, e, n) {
      var i = t.get(e);null === i && (i = new ji(e), t.put(e, i)), i.addEndpoint(n);
    }, computeSimple: function (t) {
      return this.nonSimpleLocation = null, !!t.isEmpty() || (t instanceof St ? this.isSimpleLinearGeometry(t) : t instanceof gt ? this.isSimpleLinearGeometry(t) : t instanceof Pt ? this.isSimpleMultiPoint(t) : R(t, Rt) ? this.isSimplePolygonal(t) : !(t instanceof ft) || this.isSimpleGeometryCollection(t));
    }, isSimple: function () {
      return this.nonSimpleLocation = null, this.computeSimple(this.inputGeom);
    }, isSimpleGeometryCollection: function (t) {
      for (var e = 0; e < t.getNumGeometries(); e++) {
        var n = t.getGeometryN(e);if (!this.computeSimple(n)) return !1;
      }return !0;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Wi;
    } }), e(ji.prototype, { addEndpoint: function (t) {
      this.degree++, this.isClosed |= t;
    }, getCoordinate: function () {
      return this.pt;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return ji;
    } }), Wi.EndpointInfo = ji, e(Ki.prototype, { getEndCapStyle: function () {
      return this.endCapStyle;
    }, isSingleSided: function () {
      return this._isSingleSided;
    }, setQuadrantSegments: function (t) {
      this.quadrantSegments = t, 0 === this.quadrantSegments && (this.joinStyle = Ki.JOIN_BEVEL), this.quadrantSegments < 0 && (this.joinStyle = Ki.JOIN_MITRE, this.mitreLimit = Math.abs(this.quadrantSegments)), t <= 0 && (this.quadrantSegments = 1), this.joinStyle !== Ki.JOIN_ROUND && (this.quadrantSegments = Ki.DEFAULT_QUADRANT_SEGMENTS);
    }, getJoinStyle: function () {
      return this.joinStyle;
    }, setJoinStyle: function (t) {
      this.joinStyle = t;
    }, setSimplifyFactor: function (t) {
      this.simplifyFactor = t < 0 ? 0 : t;
    }, getSimplifyFactor: function () {
      return this.simplifyFactor;
    }, getQuadrantSegments: function () {
      return this.quadrantSegments;
    }, setEndCapStyle: function (t) {
      this.endCapStyle = t;
    }, getMitreLimit: function () {
      return this.mitreLimit;
    }, setMitreLimit: function (t) {
      this.mitreLimit = t;
    }, setSingleSided: function (t) {
      this._isSingleSided = t;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Ki;
    } }), Ki.bufferDistanceError = function (t) {
    var e = Math.PI / 2 / t;return 1 - Math.cos(e / 2);
  }, Ki.CAP_ROUND = 1, Ki.CAP_FLAT = 2, Ki.CAP_SQUARE = 3, Ki.JOIN_ROUND = 1, Ki.JOIN_MITRE = 2, Ki.JOIN_BEVEL = 3, Ki.DEFAULT_QUADRANT_SEGMENTS = 8, Ki.DEFAULT_MITRE_LIMIT = 5, Ki.DEFAULT_SIMPLIFY_FACTOR = .01, e(Zi.prototype, { getCoordinate: function () {
      return this.minCoord;
    }, getRightmostSide: function (t, e) {
      var n = this.getRightmostSideOfSegment(t, e);return n < 0 && (n = this.getRightmostSideOfSegment(t, e - 1)), n < 0 && (this.minCoord = null, this.checkForRightmostCoordinate(t)), n;
    }, findRightmostEdgeAtVertex: function () {
      var t = this.minDe.getEdge().getCoordinates();f.isTrue(this.minIndex > 0 && this.minIndex < t.length, "rightmost point expected to be interior vertex of edge");var e = t[this.minIndex - 1],
          n = t[this.minIndex + 1],
          i = he.computeOrientation(this.minCoord, n, e),
          r = !1;e.y < this.minCoord.y && n.y < this.minCoord.y && i === he.COUNTERCLOCKWISE ? r = !0 : e.y > this.minCoord.y && n.y > this.minCoord.y && i === he.CLOCKWISE && (r = !0), r && (this.minIndex = this.minIndex - 1);
    }, getRightmostSideOfSegment: function (t, e) {
      var n = t.getEdge(),
          i = n.getCoordinates();if (e < 0 || e + 1 >= i.length) return -1;if (i[e].y === i[e + 1].y) return -1;var r = cn.LEFT;return i[e].y < i[e + 1].y && (r = cn.RIGHT), r;
    }, getEdge: function () {
      return this.orientedDe;
    }, checkForRightmostCoordinate: function (t) {
      for (var e = t.getEdge().getCoordinates(), n = 0; n < e.length - 1; n++) (null === this.minCoord || e[n].x > this.minCoord.x) && (this.minDe = t, this.minIndex = n, this.minCoord = e[n]);
    }, findRightmostEdgeAtNode: function () {
      var t = this.minDe.getNode(),
          e = t.getEdges();this.minDe = e.getRightmostEdge(), this.minDe.isForward() || (this.minDe = this.minDe.getSym(), this.minIndex = this.minDe.getEdge().getCoordinates().length - 1);
    }, findEdge: function (t) {
      for (var e = t.iterator(); e.hasNext();) {
        var n = e.next();n.isForward() && this.checkForRightmostCoordinate(n);
      }f.isTrue(0 !== this.minIndex || this.minCoord.equals(this.minDe.getCoordinate()), "inconsistency in rightmost processing"), 0 === this.minIndex ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(), this.orientedDe = this.minDe;var i = this.getRightmostSide(this.minDe, this.minIndex);i === cn.LEFT && (this.orientedDe = this.minDe.getSym());
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Zi;
    } }), Qi.prototype.addLast = function (t) {
    this.array_.push(t);
  }, Qi.prototype.removeFirst = function () {
    return this.array_.shift();
  }, Qi.prototype.isEmpty = function () {
    return 0 === this.array_.length;
  }, e(Ji.prototype, { clearVisitedEdges: function () {
      for (var t = this.dirEdgeList.iterator(); t.hasNext();) {
        var e = t.next();e.setVisited(!1);
      }
    }, getRightmostCoordinate: function () {
      return this.rightMostCoord;
    }, computeNodeDepth: function (t) {
      for (var e = null, n = t.getEdges().iterator(); n.hasNext();) {
        var i = n.next();if (i.isVisited() || i.getSym().isVisited()) {
          e = i;break;
        }
      }if (null === e) throw new sn("unable to find edge to compute depths at " + t.getCoordinate());t.getEdges().computeDepths(e);for (var n = t.getEdges().iterator(); n.hasNext();) {
        var i = n.next();i.setVisited(!0), this.copySymDepths(i);
      }
    }, computeDepth: function (t) {
      this.clearVisitedEdges();var e = this.finder.getEdge();e.getNode(), e.getLabel();e.setEdgeDepths(cn.RIGHT, t), this.copySymDepths(e), this.computeDepths(e);
    }, create: function (t) {
      this.addReachable(t), this.finder.findEdge(this.dirEdgeList), this.rightMostCoord = this.finder.getCoordinate();
    }, findResultEdges: function () {
      for (var t = this.dirEdgeList.iterator(); t.hasNext();) {
        var e = t.next();e.getDepth(cn.RIGHT) >= 1 && e.getDepth(cn.LEFT) <= 0 && !e.isInteriorAreaEdge() && e.setInResult(!0);
      }
    }, computeDepths: function (t) {
      var e = new J(),
          n = new Qi(),
          i = t.getNode();for (n.addLast(i), e.add(i), t.setVisited(!0); !n.isEmpty();) {
        var r = n.removeFirst();e.add(r), this.computeNodeDepth(r);for (var s = r.getEdges().iterator(); s.hasNext();) {
          var o = s.next(),
              a = o.getSym();if (!a.isVisited()) {
            var u = a.getNode();e.contains(u) || (n.addLast(u), e.add(u));
          }
        }
      }
    }, compareTo: function (t) {
      var e = t;return this.rightMostCoord.x < e.rightMostCoord.x ? -1 : this.rightMostCoord.x > e.rightMostCoord.x ? 1 : 0;
    }, getEnvelope: function () {
      if (null === this.env) {
        for (var t = new C(), e = this.dirEdgeList.iterator(); e.hasNext();) for (var n = e.next(), i = n.getEdge().getCoordinates(), r = 0; r < i.length - 1; r++) t.expandToInclude(i[r]);this.env = t;
      }return this.env;
    }, addReachable: function (t) {
      var e = new pe();for (e.add(t); !e.empty();) {
        var n = e.pop();this.add(n, e);
      }
    }, copySymDepths: function (t) {
      var e = t.getSym();e.setDepth(cn.LEFT, t.getDepth(cn.RIGHT)), e.setDepth(cn.RIGHT, t.getDepth(cn.LEFT));
    }, add: function (t, e) {
      t.setVisited(!0), this.nodes.add(t);for (var n = t.getEdges().iterator(); n.hasNext();) {
        var i = n.next();this.dirEdgeList.add(i);var r = i.getSym(),
            s = r.getNode();s.isVisited() || e.push(s);
      }
    }, getNodes: function () {
      return this.nodes;
    }, getDirectedEdges: function () {
      return this.dirEdgeList;
    }, interfaces_: function () {
      return [s];
    }, getClass: function () {
      return Ji;
    } }), e($i.prototype, { isDeletable: function (t, e, n, i) {
      var r = this.inputLine[t],
          s = this.inputLine[e],
          o = this.inputLine[n];return !!this.isConcave(r, s, o) && !!this.isShallow(r, s, o, i) && this.isShallowSampled(r, s, t, n, i);
    }, deleteShallowConcavities: function () {
      for (var t = 1, e = (this.inputLine.length - 1, this.findNextNonDeletedIndex(t)), n = this.findNextNonDeletedIndex(e), i = !1; n < this.inputLine.length;) {
        var r = !1;this.isDeletable(t, e, n, this.distanceTol) && (this.isDeleted[e] = $i.DELETE, r = !0, i = !0), t = r ? n : e, e = this.findNextNonDeletedIndex(t), n = this.findNextNonDeletedIndex(e);
      }return i;
    }, isShallowConcavity: function (t, e, n, i) {
      var r = he.computeOrientation(t, e, n),
          s = r === this.angleOrientation;if (!s) return !1;var o = he.distancePointLine(e, t, n);return o < i;
    }, isShallowSampled: function (t, e, n, i, r) {
      var s = Math.trunc((i - n) / $i.NUM_PTS_TO_CHECK);s <= 0 && (s = 1);for (var o = n; o < i; o += s) if (!this.isShallow(t, e, this.inputLine[o], r)) return !1;return !0;
    }, isConcave: function t(e, n, i) {
      var r = he.computeOrientation(e, n, i),
          t = r === this.angleOrientation;return t;
    }, simplify: function (t) {
      this.distanceTol = Math.abs(t), t < 0 && (this.angleOrientation = he.CLOCKWISE), this.isDeleted = new Array(this.inputLine.length).fill(null);var e = !1;do e = this.deleteShallowConcavities(); while (e);return this.collapseLine();
    }, findNextNonDeletedIndex: function (t) {
      for (var e = t + 1; e < this.inputLine.length && this.isDeleted[e] === $i.DELETE;) e++;return e;
    }, isShallow: function (t, e, n, i) {
      var r = he.distancePointLine(e, t, n);return r < i;
    }, collapseLine: function () {
      for (var t = new N(), e = 0; e < this.inputLine.length; e++) this.isDeleted[e] !== $i.DELETE && t.add(this.inputLine[e]);return t.toCoordinateArray();
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return $i;
    } }), $i.simplify = function (t, e) {
    var n = new $i(t);return n.simplify(e);
  }, $i.INIT = 0, $i.DELETE = 1, $i.KEEP = 1, $i.NUM_PTS_TO_CHECK = 10, e(tr.prototype, { getCoordinates: function () {
      var t = this.ptList.toArray(tr.COORDINATE_ARRAY_TYPE);return t;
    }, setPrecisionModel: function (t) {
      this.precisionModel = t;
    }, addPt: function (t) {
      var e = new g(t);return this.precisionModel.makePrecise(e), this.isRedundant(e) ? null : void this.ptList.add(e);
    }, reverse: function () {}, addPts: function (t, e) {
      if (e) for (var n = 0; n < t.length; n++) this.addPt(t[n]);else for (var n = t.length - 1; n >= 0; n--) this.addPt(t[n]);
    }, isRedundant: function (t) {
      if (this.ptList.size() < 1) return !1;var e = this.ptList.get(this.ptList.size() - 1),
          n = t.distance(e);return n < this.minimimVertexDistance;
    }, toString: function () {
      var t = new ie(),
          e = t.createLineString(this.getCoordinates());return e.toString();
    }, closeRing: function () {
      if (this.ptList.size() < 1) return null;var t = new g(this.ptList.get(0)),
          e = this.ptList.get(this.ptList.size() - 1),
          n = null;return this.ptList.size() >= 2 && (n = this.ptList.get(this.ptList.size() - 2)), t.equals(e) ? null : void this.ptList.add(t);
    }, setMinimumVertexDistance: function (t) {
      this.minimimVertexDistance = t;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return tr;
    } }), tr.COORDINATE_ARRAY_TYPE = new Array(0).fill(null), e(er.prototype, { addNextSegment: function (t, e) {
      if (this.s0 = this.s1, this.s1 = this.s2, this.s2 = t, this.seg0.setCoordinates(this.s0, this.s1), this.computeOffsetSegment(this.seg0, this.side, this.distance, this.offset0), this.seg1.setCoordinates(this.s1, this.s2), this.computeOffsetSegment(this.seg1, this.side, this.distance, this.offset1), this.s1.equals(this.s2)) return null;var n = he.computeOrientation(this.s0, this.s1, this.s2),
          i = n === he.CLOCKWISE && this.side === cn.LEFT || n === he.COUNTERCLOCKWISE && this.side === cn.RIGHT;0 === n ? this.addCollinear(e) : i ? this.addOutsideTurn(n, e) : this.addInsideTurn(n, e);
    }, addLineEndCap: function (t, e) {
      var n = new ce(t, e),
          i = new ce();this.computeOffsetSegment(n, cn.LEFT, this.distance, i);var r = new ce();this.computeOffsetSegment(n, cn.RIGHT, this.distance, r);var s = e.x - t.x,
          o = e.y - t.y,
          a = Math.atan2(o, s);switch (this.bufParams.getEndCapStyle()) {case Ki.CAP_ROUND:
          this.segList.addPt(i.p1), this.addFilletArc(e, a + Math.PI / 2, a - Math.PI / 2, he.CLOCKWISE, this.distance), this.segList.addPt(r.p1);break;case Ki.CAP_FLAT:
          this.segList.addPt(i.p1), this.segList.addPt(r.p1);break;case Ki.CAP_SQUARE:
          var u = new g();u.x = Math.abs(this.distance) * Math.cos(a), u.y = Math.abs(this.distance) * Math.sin(a);var l = new g(i.p1.x + u.x, i.p1.y + u.y),
              h = new g(r.p1.x + u.x, r.p1.y + u.y);this.segList.addPt(l), this.segList.addPt(h);}
    }, getCoordinates: function () {
      var t = this.segList.getCoordinates();return t;
    }, addMitreJoin: function (t, e, n, i) {
      var r = !0,
          s = null;try {
        s = F.intersection(e.p0, e.p1, n.p0, n.p1);var o = i <= 0 ? 1 : s.distance(t) / Math.abs(i);o > this.bufParams.getMitreLimit() && (r = !1);
      } catch (t) {
        if (!(t instanceof w)) throw t;s = new g(0, 0), r = !1;
      } finally {}r ? this.segList.addPt(s) : this.addLimitedMitreJoin(e, n, i, this.bufParams.getMitreLimit());
    }, addFilletCorner: function (t, e, n, i, r) {
      var s = e.x - t.x,
          o = e.y - t.y,
          a = Math.atan2(o, s),
          u = n.x - t.x,
          l = n.y - t.y,
          h = Math.atan2(l, u);i === he.CLOCKWISE ? a <= h && (a += 2 * Math.PI) : a >= h && (a -= 2 * Math.PI), this.segList.addPt(e), this.addFilletArc(t, a, h, i, r), this.segList.addPt(n);
    }, addOutsideTurn: function (t, e) {
      return this.offset0.p1.distance(this.offset1.p0) < this.distance * er.OFFSET_SEGMENT_SEPARATION_FACTOR ? (this.segList.addPt(this.offset0.p1), null) : void (this.bufParams.getJoinStyle() === Ki.JOIN_MITRE ? this.addMitreJoin(this.s1, this.offset0, this.offset1, this.distance) : this.bufParams.getJoinStyle() === Ki.JOIN_BEVEL ? this.addBevelJoin(this.offset0, this.offset1) : (e && this.segList.addPt(this.offset0.p1), this.addFilletCorner(this.s1, this.offset0.p1, this.offset1.p0, t, this.distance), this.segList.addPt(this.offset1.p0)));
    }, createSquare: function (t) {
      this.segList.addPt(new g(t.x + this.distance, t.y + this.distance)), this.segList.addPt(new g(t.x + this.distance, t.y - this.distance)), this.segList.addPt(new g(t.x - this.distance, t.y - this.distance)), this.segList.addPt(new g(t.x - this.distance, t.y + this.distance)), this.segList.closeRing();
    }, addSegments: function (t, e) {
      this.segList.addPts(t, e);
    }, addFirstSegment: function () {
      this.segList.addPt(this.offset1.p0);
    }, addLastSegment: function () {
      this.segList.addPt(this.offset1.p1);
    }, initSideSegments: function (t, e, n) {
      this.s1 = t, this.s2 = e, this.side = n, this.seg1.setCoordinates(t, e), this.computeOffsetSegment(this.seg1, n, this.distance, this.offset1);
    }, addLimitedMitreJoin: function (t, e, n, i) {
      var r = this.seg0.p1,
          s = Ci.angle(r, this.seg0.p0),
          o = (Ci.angle(r, this.seg1.p1), Ci.angleBetweenOriented(this.seg0.p0, r, this.seg1.p1)),
          a = o / 2,
          u = Ci.normalize(s + a),
          l = Ci.normalize(u + Math.PI),
          h = i * n,
          c = h * Math.abs(Math.sin(a)),
          f = n - c,
          d = r.x + h * Math.cos(l),
          p = r.y + h * Math.sin(l),
          v = new g(d, p),
          m = new ce(r, v),
          y = m.pointAlongOffset(1, f),
          x = m.pointAlongOffset(1, -f);this.side === cn.LEFT ? (this.segList.addPt(y), this.segList.addPt(x)) : (this.segList.addPt(x), this.segList.addPt(y));
    }, computeOffsetSegment: function (t, e, n, i) {
      var r = e === cn.LEFT ? 1 : -1,
          s = t.p1.x - t.p0.x,
          o = t.p1.y - t.p0.y,
          a = Math.sqrt(s * s + o * o),
          u = r * n * s / a,
          l = r * n * o / a;i.p0.x = t.p0.x - l, i.p0.y = t.p0.y + u, i.p1.x = t.p1.x - l, i.p1.y = t.p1.y + u;
    }, addFilletArc: function (t, e, n, i, r) {
      var s = i === he.CLOCKWISE ? -1 : 1,
          o = Math.abs(e - n),
          a = Math.trunc(o / this.filletAngleQuantum + .5);if (a < 1) return null;var u = null,
          l = null;u = 0, l = o / a;for (var h = u, c = new g(); h < o;) {
        var f = e + s * h;c.x = t.x + r * Math.cos(f), c.y = t.y + r * Math.sin(f), this.segList.addPt(c), h += l;
      }
    }, addInsideTurn: function (t, e) {
      if (this.li.computeIntersection(this.offset0.p0, this.offset0.p1, this.offset1.p0, this.offset1.p1), this.li.hasIntersection()) this.segList.addPt(this.li.getIntersection(0));else if (this._hasNarrowConcaveAngle = !0, this.offset0.p1.distance(this.offset1.p0) < this.distance * er.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) this.segList.addPt(this.offset0.p1);else {
        if (this.segList.addPt(this.offset0.p1), this.closingSegLengthFactor > 0) {
          var n = new g((this.closingSegLengthFactor * this.offset0.p1.x + this.s1.x) / (this.closingSegLengthFactor + 1), (this.closingSegLengthFactor * this.offset0.p1.y + this.s1.y) / (this.closingSegLengthFactor + 1));this.segList.addPt(n);var i = new g((this.closingSegLengthFactor * this.offset1.p0.x + this.s1.x) / (this.closingSegLengthFactor + 1), (this.closingSegLengthFactor * this.offset1.p0.y + this.s1.y) / (this.closingSegLengthFactor + 1));this.segList.addPt(i);
        } else this.segList.addPt(this.s1);this.segList.addPt(this.offset1.p0);
      }
    }, createCircle: function (t) {
      var e = new g(t.x + this.distance, t.y);this.segList.addPt(e), this.addFilletArc(t, 0, 2 * Math.PI, -1, this.distance), this.segList.closeRing();
    }, addBevelJoin: function (t, e) {
      this.segList.addPt(t.p1), this.segList.addPt(e.p0);
    }, init: function (t) {
      this.distance = t, this.maxCurveSegmentError = t * (1 - Math.cos(this.filletAngleQuantum / 2)), this.segList = new tr(), this.segList.setPrecisionModel(this.precisionModel), this.segList.setMinimumVertexDistance(t * er.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);
    }, addCollinear: function (t) {
      this.li.computeIntersection(this.s0, this.s1, this.s1, this.s2);var e = this.li.getIntersectionNum();e >= 2 && (this.bufParams.getJoinStyle() === Ki.JOIN_BEVEL || this.bufParams.getJoinStyle() === Ki.JOIN_MITRE ? (t && this.segList.addPt(this.offset0.p1), this.segList.addPt(this.offset1.p0)) : this.addFilletCorner(this.s1, this.offset0.p1, this.offset1.p0, he.CLOCKWISE, this.distance));
    }, closeRing: function () {
      this.segList.closeRing();
    }, hasNarrowConcaveAngle: function () {
      return this._hasNarrowConcaveAngle;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return er;
    } }), er.OFFSET_SEGMENT_SEPARATION_FACTOR = .001, er.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = .001, er.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1e-6, er.MAX_CLOSING_SEG_LEN_FACTOR = 80, e(nr.prototype, { getOffsetCurve: function (t, e) {
      if (this.distance = e, 0 === e) return null;var n = e < 0,
          i = Math.abs(e),
          r = this.getSegGen(i);t.length <= 1 ? this.computePointCurve(t[0], r) : this.computeOffsetCurve(t, n, r);var s = r.getCoordinates();return n && H.reverse(s), s;
    }, computeSingleSidedBufferCurve: function (t, e, n) {
      var i = this.simplifyTolerance(this.distance);if (e) {
        n.addSegments(t, !0);var r = $i.simplify(t, -i),
            s = r.length - 1;n.initSideSegments(r[s], r[s - 1], cn.LEFT), n.addFirstSegment();for (var o = s - 2; o >= 0; o--) n.addNextSegment(r[o], !0);
      } else {
        n.addSegments(t, !1);var a = $i.simplify(t, i),
            u = a.length - 1;n.initSideSegments(a[0], a[1], cn.LEFT), n.addFirstSegment();for (var o = 2; o <= u; o++) n.addNextSegment(a[o], !0);
      }n.addLastSegment(), n.closeRing();
    }, computeRingBufferCurve: function (t, e, n) {
      var i = this.simplifyTolerance(this.distance);e === cn.RIGHT && (i = -i);var r = $i.simplify(t, i),
          s = r.length - 1;n.initSideSegments(r[s - 1], r[0], e);for (var o = 1; o <= s; o++) {
        var a = 1 !== o;n.addNextSegment(r[o], a);
      }n.closeRing();
    }, computeLineBufferCurve: function (t, e) {
      var n = this.simplifyTolerance(this.distance),
          i = $i.simplify(t, n),
          r = i.length - 1;e.initSideSegments(i[0], i[1], cn.LEFT);for (var s = 2; s <= r; s++) e.addNextSegment(i[s], !0);e.addLastSegment(), e.addLineEndCap(i[r - 1], i[r]);var o = $i.simplify(t, -n),
          a = o.length - 1;e.initSideSegments(o[a], o[a - 1], cn.LEFT);for (var s = a - 2; s >= 0; s--) e.addNextSegment(o[s], !0);e.addLastSegment(), e.addLineEndCap(o[1], o[0]), e.closeRing();
    }, computePointCurve: function (t, e) {
      switch (this.bufParams.getEndCapStyle()) {case Ki.CAP_ROUND:
          e.createCircle(t);break;case Ki.CAP_SQUARE:
          e.createSquare(t);}
    }, getLineCurve: function (t, e) {
      if (this.distance = e, e < 0 && !this.bufParams.isSingleSided()) return null;if (0 === e) return null;var n = Math.abs(e),
          i = this.getSegGen(n);if (t.length <= 1) this.computePointCurve(t[0], i);else if (this.bufParams.isSingleSided()) {
        var r = e < 0;this.computeSingleSidedBufferCurve(t, r, i);
      } else this.computeLineBufferCurve(t, i);var s = i.getCoordinates();return s;
    }, getBufferParameters: function () {
      return this.bufParams;
    }, simplifyTolerance: function (t) {
      return t * this.bufParams.getSimplifyFactor();
    }, getRingCurve: function (t, e, n) {
      if (this.distance = n, t.length <= 2) return this.getLineCurve(t, n);if (0 === n) return nr.copyCoordinates(t);var i = this.getSegGen(n);return this.computeRingBufferCurve(t, e, i), i.getCoordinates();
    }, computeOffsetCurve: function (t, e, n) {
      var i = this.simplifyTolerance(this.distance);if (e) {
        var r = $i.simplify(t, -i),
            s = r.length - 1;n.initSideSegments(r[s], r[s - 1], cn.LEFT), n.addFirstSegment();for (var o = s - 2; o >= 0; o--) n.addNextSegment(r[o], !0);
      } else {
        var a = $i.simplify(t, i),
            u = a.length - 1;n.initSideSegments(a[0], a[1], cn.LEFT), n.addFirstSegment();for (var o = 2; o <= u; o++) n.addNextSegment(a[o], !0);
      }n.addLastSegment();
    }, getSegGen: function (t) {
      return new er(this.precisionModel, this.bufParams, t);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return nr;
    } }), nr.copyCoordinates = function (t) {
    for (var e = new Array(t.length).fill(null), n = 0; n < e.length; n++) e[n] = new g(t[n]);return e;
  }, e(ir.prototype, { findStabbedSegments: function () {
      if (1 === arguments.length) {
        for (var t = arguments[0], e = new I(), n = this.subgraphs.iterator(); n.hasNext();) {
          var i = n.next(),
              r = i.getEnvelope();t.y < r.getMinY() || t.y > r.getMaxY() || this.findStabbedSegments(t, i.getDirectedEdges(), e);
        }return e;
      }if (3 === arguments.length) if (R(arguments[2], y) && arguments[0] instanceof g && arguments[1] instanceof In) for (var s = arguments[0], o = arguments[1], a = arguments[2], u = o.getEdge().getCoordinates(), n = 0; n < u.length - 1; n++) {
        this.seg.p0 = u[n], this.seg.p1 = u[n + 1], this.seg.p0.y > this.seg.p1.y && this.seg.reverse();var l = Math.max(this.seg.p0.x, this.seg.p1.x);if (!(l < s.x || this.seg.isHorizontal() || s.y < this.seg.p0.y || s.y > this.seg.p1.y || he.computeOrientation(this.seg.p0, this.seg.p1, s) === he.RIGHT)) {
          var h = o.getDepth(cn.LEFT);this.seg.p0.equals(u[n]) || (h = o.getDepth(cn.RIGHT));var c = new rr(this.seg, h);a.add(c);
        }
      } else if (R(arguments[2], y) && arguments[0] instanceof g && R(arguments[1], y)) for (var f = arguments[0], d = arguments[1], p = arguments[2], n = d.iterator(); n.hasNext();) {
        var v = n.next();v.isForward() && this.findStabbedSegments(f, v, p);
      }
    }, getDepth: function (t) {
      var e = this.findStabbedSegments(t);if (0 === e.size()) return 0;var n = ho.min(e);return n.leftDepth;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return ir;
    } }), e(rr.prototype, { compareTo: function (t) {
      var e = t;if (this.upwardSeg.minX() >= e.upwardSeg.maxX()) return 1;if (this.upwardSeg.maxX() <= e.upwardSeg.minX()) return -1;var n = this.upwardSeg.orientationIndex(e.upwardSeg);return 0 !== n ? n : (n = -1 * e.upwardSeg.orientationIndex(this.upwardSeg), 0 !== n ? n : this.upwardSeg.compareTo(e.upwardSeg));
    }, compareX: function (t, e) {
      var n = t.p0.compareTo(e.p0);return 0 !== n ? n : t.p1.compareTo(e.p1);
    }, toString: function () {
      return this.upwardSeg.toString();
    }, interfaces_: function () {
      return [s];
    }, getClass: function () {
      return rr;
    } }), ir.DepthSegment = rr, e(sr.prototype, { addPoint: function (t) {
      if (this.distance <= 0) return null;var e = t.getCoordinates(),
          n = this.curveBuilder.getLineCurve(e, this.distance);this.addCurve(n, L.EXTERIOR, L.INTERIOR);
    }, addPolygon: function (t) {
      var e = this.distance,
          n = cn.LEFT;this.distance < 0 && (e = -this.distance, n = cn.RIGHT);var i = t.getExteriorRing(),
          r = H.removeRepeatedPoints(i.getCoordinates());if (this.distance < 0 && this.isErodedCompletely(i, this.distance)) return null;if (this.distance <= 0 && r.length < 3) return null;this.addPolygonRing(r, e, n, L.EXTERIOR, L.INTERIOR);for (var s = 0; s < t.getNumInteriorRing(); s++) {
        var o = t.getInteriorRingN(s),
            a = H.removeRepeatedPoints(o.getCoordinates());this.distance > 0 && this.isErodedCompletely(o, -this.distance) || this.addPolygonRing(a, e, cn.opposite(n), L.INTERIOR, L.EXTERIOR);
      }
    }, isTriangleErodedCompletely: function (t, e) {
      var n = new Si(t[0], t[1], t[2]),
          i = n.inCentre(),
          r = he.distancePointLine(i, n.p0, n.p1);return r < Math.abs(e);
    }, addLineString: function (t) {
      if (this.distance <= 0 && !this.curveBuilder.getBufferParameters().isSingleSided()) return null;var e = H.removeRepeatedPoints(t.getCoordinates()),
          n = this.curveBuilder.getLineCurve(e, this.distance);this.addCurve(n, L.EXTERIOR, L.INTERIOR);
    }, addCurve: function (t, e, n) {
      if (null === t || t.length < 2) return null;var i = new Ke(t, new gn(0, L.BOUNDARY, e, n));this.curveList.add(i);
    }, getCurves: function () {
      return this.add(this.inputGeom), this.curveList;
    }, addPolygonRing: function (t, e, n, i, r) {
      if (0 === e && t.length < bt.MINIMUM_VALID_SIZE) return null;var s = i,
          o = r;t.length >= bt.MINIMUM_VALID_SIZE && he.isCCW(t) && (s = r, o = i, n = cn.opposite(n));var a = this.curveBuilder.getRingCurve(t, n, e);this.addCurve(a, s, o);
    }, add: function (t) {
      if (t.isEmpty()) return null;if (t instanceof Tt) this.addPolygon(t);else if (t instanceof St) this.addLineString(t);else if (t instanceof Lt) this.addPoint(t);else if (t instanceof Pt) this.addCollection(t);else if (t instanceof gt) this.addCollection(t);else if (t instanceof Ot) this.addCollection(t);else {
        if (!(t instanceof ft)) throw new UnsupportedOperationException(t.getClass().getName());this.addCollection(t);
      }
    }, isErodedCompletely: function (t, e) {
      var n = t.getCoordinates();if (n.length < 4) return e < 0;if (4 === n.length) return this.isTriangleErodedCompletely(n, e);var i = t.getEnvelopeInternal(),
          r = Math.min(i.getHeight(), i.getWidth());return e < 0 && 2 * Math.abs(e) > r;
    }, addCollection: function (t) {
      for (var e = 0; e < t.getNumGeometries(); e++) {
        var n = t.getGeometryN(e);this.add(n);
      }
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return sr;
    } }), e(or.prototype, { isTrivialIntersection: function (t, e, n, i) {
      if (t === n && 1 === this.li.getIntersectionNum()) {
        if (or.isAdjacentSegments(e, i)) return !0;if (t.isClosed()) {
          var r = t.size() - 1;if (0 === e && i === r || 0 === i && e === r) return !0;
        }
      }return !1;
    }, getProperIntersectionPoint: function () {
      return this.properIntersectionPoint;
    }, hasProperInteriorIntersection: function () {
      return this.hasProperInterior;
    }, getLineIntersector: function () {
      return this.li;
    }, hasProperIntersection: function () {
      return this.hasProper;
    }, processIntersections: function (t, e, n, i) {
      if (t === n && e === i) return null;this.numTests++;var r = t.getCoordinates()[e],
          s = t.getCoordinates()[e + 1],
          o = n.getCoordinates()[i],
          a = n.getCoordinates()[i + 1];this.li.computeIntersection(r, s, o, a), this.li.hasIntersection() && (this.numIntersections++, this.li.isInteriorIntersection() && (this.numInteriorIntersections++, this.hasInterior = !0), this.isTrivialIntersection(t, e, n, i) || (this._hasIntersection = !0, t.addIntersections(this.li, e, 0), n.addIntersections(this.li, i, 1), this.li.isProper() && (this.numProperIntersections++, this.hasProper = !0, this.hasProperInterior = !0)));
    }, hasIntersection: function () {
      return this._hasIntersection;
    }, isDone: function () {
      return !1;
    }, hasInteriorIntersection: function () {
      return this.hasInterior;
    }, interfaces_: function () {
      return [on];
    }, getClass: function () {
      return or;
    } }), or.isAdjacentSegments = function (t, e) {
    return 1 === Math.abs(t - e);
  }, e(ar.prototype, { setWorkingPrecisionModel: function (t) {
      this.workingPrecisionModel = t;
    }, insertUniqueEdge: function (t) {
      var e = this.edgeList.findEqualEdge(t);if (null !== e) {
        var n = e.getLabel(),
            i = t.getLabel();e.isPointwiseEqual(t) || (i = new gn(t.getLabel()), i.flip()), n.merge(i);var r = ar.depthDelta(i),
            s = e.getDepthDelta(),
            o = s + r;e.setDepthDelta(o);
      } else this.edgeList.add(t), t.setDepthDelta(ar.depthDelta(t.getLabel()));
    }, buildSubgraphs: function (t, e) {
      for (var n = new I(), i = t.iterator(); i.hasNext();) {
        var r = i.next(),
            s = r.getRightmostCoordinate(),
            o = new ir(n),
            a = o.getDepth(s);r.computeDepth(a), r.findResultEdges(), n.add(r), e.add(r.getDirectedEdges(), r.getNodes());
      }
    }, createSubgraphs: function (t) {
      for (var e = new I(), n = t.getNodes().iterator(); n.hasNext();) {
        var i = n.next();if (!i.isVisited()) {
          var r = new Ji();r.create(i), e.add(r);
        }
      }return ho.sort(e, ho.reverseOrder()), e;
    }, createEmptyResultGeometry: function () {
      var t = this.geomFact.createPolygon();return t;
    }, getNoder: function (t) {
      if (null !== this.workingNoder) return this.workingNoder;var e = new nn(),
          n = new ae();return n.setPrecisionModel(t), e.setSegmentIntersector(new or(n)), e;
    }, buffer: function (t, e) {
      var n = this.workingPrecisionModel;null === n && (n = t.getPrecisionModel()), this.geomFact = t.getFactory();var i = new nr(n, this.bufParams),
          r = new sr(t, e, i),
          s = r.getCurves();if (s.size() <= 0) return this.createEmptyResultGeometry();this.computeNodedEdges(s, n), this.graph = new Cn(new On()), this.graph.addEdges(this.edgeList.getEdges());var o = this.createSubgraphs(this.graph),
          a = new Sn(this.geomFact);this.buildSubgraphs(o, a);var u = a.getPolygons();if (u.size() <= 0) return this.createEmptyResultGeometry();var l = this.geomFact.buildGeometry(u);return l;
    }, computeNodedEdges: function (t, e) {
      var n = this.getNoder(e);n.computeNodes(t);for (var i = n.getNodedSubstrings(), r = i.iterator(); r.hasNext();) {
        var s = r.next(),
            o = s.getCoordinates();if (2 !== o.length || !o[0].equals2D(o[1])) {
          var a = s.getData(),
              u = new Jn(s.getCoordinates(), new gn(a));this.insertUniqueEdge(u);
        }
      }
    }, setNoder: function (t) {
      this.workingNoder = t;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return ar;
    } }), ar.depthDelta = function (t) {
    var e = t.getLocation(0, cn.LEFT),
        n = t.getLocation(0, cn.RIGHT);return e === L.INTERIOR && n === L.EXTERIOR ? 1 : e === L.EXTERIOR && n === L.INTERIOR ? -1 : 0;
  }, ar.convertSegStrings = function (t) {
    for (var e = new ie(), n = new I(); t.hasNext();) {
      var i = t.next(),
          r = e.createLineString(i.getCoordinates());n.add(r);
    }return e.buildGeometry(n);
  }, e(ur.prototype, { checkEndPtVertexIntersections: function () {
      if (0 === arguments.length) for (var t = this.segStrings.iterator(); t.hasNext();) {
        var e = t.next(),
            n = e.getCoordinates();this.checkEndPtVertexIntersections(n[0], this.segStrings), this.checkEndPtVertexIntersections(n[n.length - 1], this.segStrings);
      } else if (2 === arguments.length) for (var i = arguments[0], r = arguments[1], t = r.iterator(); t.hasNext();) for (var e = t.next(), n = e.getCoordinates(), s = 1; s < n.length - 1; s++) if (n[s].equals(i)) throw new l("found endpt/interior pt intersection at index " + s + " :pt " + i);
    }, checkInteriorIntersections: function () {
      if (0 === arguments.length) for (var t = this.segStrings.iterator(); t.hasNext();) for (var e = t.next(), n = this.segStrings.iterator(); n.hasNext();) {
        var i = n.next();this.checkInteriorIntersections(e, i);
      } else if (2 === arguments.length) for (var r = arguments[0], s = arguments[1], o = r.getCoordinates(), a = s.getCoordinates(), u = 0; u < o.length - 1; u++) for (var h = 0; h < a.length - 1; h++) this.checkInteriorIntersections(r, u, s, h);else if (4 === arguments.length) {
        var c = arguments[0],
            f = arguments[1],
            g = arguments[2],
            d = arguments[3];if (c === g && f === d) return null;var p = c.getCoordinates()[f],
            v = c.getCoordinates()[f + 1],
            m = g.getCoordinates()[d],
            y = g.getCoordinates()[d + 1];if (this.li.computeIntersection(p, v, m, y), this.li.hasIntersection() && (this.li.isProper() || this.hasInteriorIntersection(this.li, p, v) || this.hasInteriorIntersection(this.li, m, y))) throw new l("found non-noded intersection at " + p + "-" + v + " and " + m + "-" + y);
      }
    }, checkValid: function () {
      this.checkEndPtVertexIntersections(), this.checkInteriorIntersections(), this.checkCollapses();
    }, checkCollapses: function () {
      if (0 === arguments.length) for (var t = this.segStrings.iterator(); t.hasNext();) {
        var e = t.next();this.checkCollapses(e);
      } else if (1 === arguments.length) for (var n = arguments[0], i = n.getCoordinates(), t = 0; t < i.length - 2; t++) this.checkCollapse(i[t], i[t + 1], i[t + 2]);
    }, hasInteriorIntersection: function (t, e, n) {
      for (var i = 0; i < t.getIntersectionNum(); i++) {
        var r = t.getIntersection(i);if (!r.equals(e) && !r.equals(n)) return !0;
      }return !1;
    }, checkCollapse: function (t, e, n) {
      if (t.equals(n)) throw new l("found non-noded collapse at " + ur.fact.createLineString([t, e, n]));
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return ur;
    } }), ur.fact = new ie(), e(lr.prototype, { intersectsScaled: function (t, e) {
      var n = Math.min(t.x, e.x),
          i = Math.max(t.x, e.x),
          r = Math.min(t.y, e.y),
          s = Math.max(t.y, e.y),
          o = this.maxx < n || this.minx > i || this.maxy < r || this.miny > s;if (o) return !1;var a = this.intersectsToleranceSquare(t, e);return f.isTrue(!(o && a), "Found bad envelope test"), a;
    }, initCorners: function (t) {
      var e = .5;this.minx = t.x - e, this.maxx = t.x + e, this.miny = t.y - e, this.maxy = t.y + e, this.corner[0] = new g(this.maxx, this.maxy), this.corner[1] = new g(this.minx, this.maxy), this.corner[2] = new g(this.minx, this.miny), this.corner[3] = new g(this.maxx, this.miny);
    }, intersects: function (t, e) {
      return 1 === this.scaleFactor ? this.intersectsScaled(t, e) : (this.copyScaled(t, this.p0Scaled), this.copyScaled(e, this.p1Scaled), this.intersectsScaled(this.p0Scaled, this.p1Scaled));
    }, scale: function (t) {
      return Math.round(t * this.scaleFactor);
    }, getCoordinate: function () {
      return this.originalPt;
    }, copyScaled: function (t, e) {
      e.x = this.scale(t.x), e.y = this.scale(t.y);
    }, getSafeEnvelope: function () {
      if (null === this.safeEnv) {
        var t = lr.SAFE_ENV_EXPANSION_FACTOR / this.scaleFactor;this.safeEnv = new C(this.originalPt.x - t, this.originalPt.x + t, this.originalPt.y - t, this.originalPt.y + t);
      }return this.safeEnv;
    }, intersectsPixelClosure: function (t, e) {
      return this.li.computeIntersection(t, e, this.corner[0], this.corner[1]), !!this.li.hasIntersection() || (this.li.computeIntersection(t, e, this.corner[1], this.corner[2]), !!this.li.hasIntersection() || (this.li.computeIntersection(t, e, this.corner[2], this.corner[3]), !!this.li.hasIntersection() || (this.li.computeIntersection(t, e, this.corner[3], this.corner[0]), !!this.li.hasIntersection())));
    }, intersectsToleranceSquare: function (t, e) {
      var n = !1,
          i = !1;return this.li.computeIntersection(t, e, this.corner[0], this.corner[1]), !!this.li.isProper() || (this.li.computeIntersection(t, e, this.corner[1], this.corner[2]), !!this.li.isProper() || (this.li.hasIntersection() && (n = !0), this.li.computeIntersection(t, e, this.corner[2], this.corner[3]), !!this.li.isProper() || (this.li.hasIntersection() && (i = !0), this.li.computeIntersection(t, e, this.corner[3], this.corner[0]), !!this.li.isProper() || !(!n || !i) || !!t.equals(this.pt) || !!e.equals(this.pt))));
    }, addSnappedNode: function (t, e) {
      var n = t.getCoordinate(e),
          i = t.getCoordinate(e + 1);return !!this.intersects(n, i) && (t.addIntersection(this.getCoordinate(), e), !0);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return lr;
    } }), lr.SAFE_ENV_EXPANSION_FACTOR = .75, e(hr.prototype, { snap: function () {
      if (1 === arguments.length) {
        var t = arguments[0];return this.snap(t, null, -1);
      }if (3 === arguments.length) {
        var e = arguments[0],
            n = arguments[1],
            i = arguments[2],
            r = e.getSafeEnvelope(),
            s = new cr(e, n, i);return this.index.query(r, { interfaces_: function () {
            return [Ae];
          }, visitItem: function (t) {
            var e = t;e.select(r, s);
          } }), s.isNodeAdded();
      }
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return hr;
    } }), h(cr, hi), e(cr.prototype, { isNodeAdded: function () {
      return this._isNodeAdded;
    }, select: function () {
      if (2 !== arguments.length) return hi.prototype.select.apply(this, arguments);var t = arguments[0],
          e = arguments[1],
          n = t.getContext();return null !== this.parentEdge && n === this.parentEdge && e === this.hotPixelVertexIndex ? null : void (this._isNodeAdded = this.hotPixel.addSnappedNode(n, e));
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return cr;
    } }), hr.HotPixelSnapAction = cr, e(fr.prototype, { processIntersections: function (t, e, n, i) {
      if (t === n && e === i) return null;var r = t.getCoordinates()[e],
          s = t.getCoordinates()[e + 1],
          o = n.getCoordinates()[i],
          a = n.getCoordinates()[i + 1];if (this.li.computeIntersection(r, s, o, a), this.li.hasIntersection() && this.li.isInteriorIntersection()) {
        for (var u = 0; u < this.li.getIntersectionNum(); u++) this.interiorIntersections.add(this.li.getIntersection(u));t.addIntersections(this.li, e, 0), n.addIntersections(this.li, i, 1);
      }
    }, isDone: function () {
      return !1;
    }, getInteriorIntersections: function () {
      return this.interiorIntersections;
    }, interfaces_: function () {
      return [on];
    }, getClass: function () {
      return fr;
    } }), e(gr.prototype, { checkCorrectness: function (t) {
      var e = Ke.getNodedSubstrings(t),
          n = new ur(e);try {
        n.checkValid();
      } catch (t) {
        if (!(t instanceof S)) throw t;t.printStackTrace();
      } finally {}
    }, getNodedSubstrings: function () {
      return Ke.getNodedSubstrings(this.nodedSegStrings);
    }, snapRound: function (t, e) {
      var n = this.findInteriorIntersections(t, e);this.computeIntersectionSnaps(n), this.computeVertexSnaps(t);
    }, findInteriorIntersections: function (t, e) {
      var n = new fr(e);return this.noder.setSegmentIntersector(n), this.noder.computeNodes(t), n.getInteriorIntersections();
    }, computeVertexSnaps: function () {
      if (R(arguments[0], v)) for (var t = arguments[0], e = t.iterator(); e.hasNext();) {
        var n = e.next();this.computeVertexSnaps(n);
      } else if (arguments[0] instanceof Ke) for (var i = arguments[0], r = i.getCoordinates(), s = 0; s < r.length; s++) {
        var o = new lr(r[s], this.scaleFactor, this.li),
            a = this.pointSnapper.snap(o, i, s);a && i.addIntersection(r[s], s);
      }
    }, computeNodes: function (t) {
      this.nodedSegStrings = t, this.noder = new nn(), this.pointSnapper = new hr(this.noder.getIndex()), this.snapRound(t, this.li);
    }, computeIntersectionSnaps: function (t) {
      for (var e = t.iterator(); e.hasNext();) {
        var n = e.next(),
            i = new lr(n, this.scaleFactor, this.li);this.pointSnapper.snap(i);
      }
    }, interfaces_: function () {
      return [tn];
    }, getClass: function () {
      return gr;
    } }), e(dr.prototype, { bufferFixedPrecision: function (t) {
      var e = new Hi(new gr(new ee(1)), t.getScale()),
          n = new ar(this.bufParams);n.setWorkingPrecisionModel(t), n.setNoder(e), this.resultGeometry = n.buffer(this.argGeom, this.distance);
    }, bufferReducedPrecision: function () {
      if (0 === arguments.length) {
        for (var t = dr.MAX_PRECISION_DIGITS; t >= 0; t--) {
          try {
            this.bufferReducedPrecision(t);
          } catch (t) {
            if (!(t instanceof sn)) throw t;this.saveException = t;
          } finally {}if (null !== this.resultGeometry) return null;
        }throw this.saveException;
      }if (1 === arguments.length) {
        var e = arguments[0],
            n = dr.precisionScaleFactor(this.argGeom, this.distance, e),
            i = new ee(n);this.bufferFixedPrecision(i);
      }
    }, computeGeometry: function () {
      if (this.bufferOriginalPrecision(), null !== this.resultGeometry) return null;var t = this.argGeom.getFactory().getPrecisionModel();t.getType() === ee.FIXED ? this.bufferFixedPrecision(t) : this.bufferReducedPrecision();
    }, setQuadrantSegments: function (t) {
      this.bufParams.setQuadrantSegments(t);
    }, bufferOriginalPrecision: function () {
      try {
        var t = new ar(this.bufParams);this.resultGeometry = t.buffer(this.argGeom, this.distance);
      } catch (t) {
        if (!(t instanceof l)) throw t;this.saveException = t;
      } finally {}
    }, getResultGeometry: function (t) {
      return this.distance = t, this.computeGeometry(), this.resultGeometry;
    }, setEndCapStyle: function (t) {
      this.bufParams.setEndCapStyle(t);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return dr;
    } }), dr.bufferOp = function () {
    if (2 === arguments.length) {
      var t = arguments[0],
          e = arguments[1],
          n = new dr(t),
          i = n.getResultGeometry(e);return i;
    }if (3 === arguments.length) {
      if (Number.isInteger(arguments[2]) && arguments[0] instanceof B && "number" == typeof arguments[1]) {
        var r = arguments[0],
            s = arguments[1],
            o = arguments[2],
            a = new dr(r);a.setQuadrantSegments(o);var i = a.getResultGeometry(s);return i;
      }if (arguments[2] instanceof Ki && arguments[0] instanceof B && "number" == typeof arguments[1]) {
        var u = arguments[0],
            l = arguments[1],
            h = arguments[2],
            a = new dr(u, h),
            i = a.getResultGeometry(l);return i;
      }
    } else if (4 === arguments.length) {
      var c = arguments[0],
          f = arguments[1],
          g = arguments[2],
          d = arguments[3],
          a = new dr(c);a.setQuadrantSegments(g), a.setEndCapStyle(d);var i = a.getResultGeometry(f);return i;
    }
  }, dr.precisionScaleFactor = function (t, e, n) {
    var i = t.getEnvelopeInternal(),
        r = T.max(Math.abs(i.getMaxX()), Math.abs(i.getMaxY()), Math.abs(i.getMinX()), Math.abs(i.getMinY())),
        s = e > 0 ? e : 0,
        o = r + 2 * s,
        a = Math.trunc(Math.log(o) / Math.log(10) + 1),
        u = n - a,
        l = Math.pow(10, u);return l;
  }, dr.CAP_ROUND = Ki.CAP_ROUND, dr.CAP_BUTT = Ki.CAP_FLAT, dr.CAP_FLAT = Ki.CAP_FLAT, dr.CAP_SQUARE = Ki.CAP_SQUARE, dr.MAX_PRECISION_DIGITS = 12;var So = Object.freeze({ BufferOp: dr, BufferParameters: Ki });e(pr.prototype, { filter: function (t) {
      t instanceof Tt && this.comps.add(t);
    }, interfaces_: function () {
      return [ht];
    }, getClass: function () {
      return pr;
    } }), pr.getPolygons = function () {
    if (1 === arguments.length) {
      var t = arguments[0];return pr.getPolygons(t, new I());
    }if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];return e instanceof Tt ? n.add(e) : e instanceof ft && e.apply(new pr(n)), n;
    }
  }, e(vr.prototype, { isInsideArea: function () {
      return this.segIndex === vr.INSIDE_AREA;
    }, getCoordinate: function () {
      return this.pt;
    }, getGeometryComponent: function () {
      return this.component;
    }, getSegmentIndex: function () {
      return this.segIndex;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return vr;
    } }), vr.INSIDE_AREA = -1, e(mr.prototype, { filter: function (t) {
      t instanceof Lt && this.pts.add(t);
    }, interfaces_: function () {
      return [ht];
    }, getClass: function () {
      return mr;
    } }), mr.getPoints = function () {
    if (1 === arguments.length) {
      var t = arguments[0];return t instanceof Lt ? ho.singletonList(t) : mr.getPoints(t, new I());
    }if (2 === arguments.length) {
      var e = arguments[0],
          n = arguments[1];return e instanceof Lt ? n.add(e) : e instanceof ft && e.apply(new mr(n)), n;
    }
  }, e(yr.prototype, { filter: function (t) {
      (t instanceof Lt || t instanceof St || t instanceof Tt) && this.locations.add(new vr(t, 0, t.getCoordinate()));
    }, interfaces_: function () {
      return [ht];
    }, getClass: function () {
      return yr;
    } }), yr.getLocations = function (t) {
    var e = new I();return t.apply(new yr(e)), e;
  }, e(xr.prototype, { computeContainmentDistance: function () {
      if (0 === arguments.length) {
        var t = new Array(2).fill(null);if (this.computeContainmentDistance(0, t), this.minDistance <= this.terminateDistance) return null;this.computeContainmentDistance(1, t);
      } else if (2 === arguments.length) {
        var e = arguments[0],
            n = arguments[1],
            i = 1 - e,
            r = pr.getPolygons(this.geom[e]);if (r.size() > 0) {
          var s = yr.getLocations(this.geom[i]);if (this.computeContainmentDistance(s, r, n), this.minDistance <= this.terminateDistance) return this.minDistanceLocation[i] = n[0], this.minDistanceLocation[e] = n[1], null;
        }
      } else if (3 === arguments.length) if (arguments[2] instanceof Array && R(arguments[0], y) && R(arguments[1], y)) {
        for (var o = arguments[0], a = arguments[1], u = arguments[2], l = 0; l < o.size(); l++) for (var h = o.get(l), c = 0; c < a.size(); c++) if (this.computeContainmentDistance(h, a.get(c), u), this.minDistance <= this.terminateDistance) return null;
      } else if (arguments[2] instanceof Array && arguments[0] instanceof vr && arguments[1] instanceof Tt) {
        var f = arguments[0],
            g = arguments[1],
            d = arguments[2],
            p = f.getCoordinate();if (L.EXTERIOR !== this.ptLocator.locate(p, g)) return this.minDistance = 0, d[0] = f, d[1] = new vr(g, p), null;
      }
    }, computeMinDistanceLinesPoints: function (t, e, n) {
      for (var i = 0; i < t.size(); i++) for (var r = t.get(i), s = 0; s < e.size(); s++) {
        var o = e.get(s);if (this.computeMinDistance(r, o, n), this.minDistance <= this.terminateDistance) return null;
      }
    }, computeFacetDistance: function () {
      var t = new Array(2).fill(null),
          e = kn.getLines(this.geom[0]),
          n = kn.getLines(this.geom[1]),
          i = mr.getPoints(this.geom[0]),
          r = mr.getPoints(this.geom[1]);return this.computeMinDistanceLines(e, n, t), this.updateMinDistance(t, !1), this.minDistance <= this.terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistanceLinesPoints(e, r, t), this.updateMinDistance(t, !1), this.minDistance <= this.terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistanceLinesPoints(n, i, t), this.updateMinDistance(t, !0), this.minDistance <= this.terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistancePoints(i, r, t), void this.updateMinDistance(t, !1))));
    }, nearestLocations: function () {
      return this.computeMinDistance(), this.minDistanceLocation;
    }, updateMinDistance: function (t, e) {
      return null === t[0] ? null : void (e ? (this.minDistanceLocation[0] = t[1], this.minDistanceLocation[1] = t[0]) : (this.minDistanceLocation[0] = t[0], this.minDistanceLocation[1] = t[1]));
    }, nearestPoints: function () {
      this.computeMinDistance();var t = [this.minDistanceLocation[0].getCoordinate(), this.minDistanceLocation[1].getCoordinate()];return t;
    }, computeMinDistance: function () {
      if (0 === arguments.length) {
        if (null !== this.minDistanceLocation) return null;if (this.minDistanceLocation = new Array(2).fill(null), this.computeContainmentDistance(), this.minDistance <= this.terminateDistance) return null;this.computeFacetDistance();
      } else if (3 === arguments.length) if (arguments[2] instanceof Array && arguments[0] instanceof St && arguments[1] instanceof Lt) {
        var t = arguments[0],
            e = arguments[1],
            n = arguments[2];if (t.getEnvelopeInternal().distance(e.getEnvelopeInternal()) > this.minDistance) return null;for (var i = t.getCoordinates(), r = e.getCoordinate(), s = 0; s < i.length - 1; s++) {
          var o = he.distancePointLine(r, i[s], i[s + 1]);if (o < this.minDistance) {
            this.minDistance = o;var a = new ce(i[s], i[s + 1]),
                u = a.closestPoint(r);n[0] = new vr(t, s, u), n[1] = new vr(e, 0, r);
          }if (this.minDistance <= this.terminateDistance) return null;
        }
      } else if (arguments[2] instanceof Array && arguments[0] instanceof St && arguments[1] instanceof St) {
        var l = arguments[0],
            h = arguments[1],
            c = arguments[2];if (l.getEnvelopeInternal().distance(h.getEnvelopeInternal()) > this.minDistance) return null;for (var i = l.getCoordinates(), f = h.getCoordinates(), s = 0; s < i.length - 1; s++) for (var g = 0; g < f.length - 1; g++) {
          var o = he.distanceLineLine(i[s], i[s + 1], f[g], f[g + 1]);if (o < this.minDistance) {
            this.minDistance = o;var d = new ce(i[s], i[s + 1]),
                p = new ce(f[g], f[g + 1]),
                v = d.closestPoints(p);c[0] = new vr(l, s, v[0]), c[1] = new vr(h, g, v[1]);
          }if (this.minDistance <= this.terminateDistance) return null;
        }
      }
    }, computeMinDistancePoints: function (t, e, n) {
      for (var i = 0; i < t.size(); i++) for (var r = t.get(i), s = 0; s < e.size(); s++) {
        var o = e.get(s),
            a = r.getCoordinate().distance(o.getCoordinate());if (a < this.minDistance && (this.minDistance = a, n[0] = new vr(r, 0, r.getCoordinate()), n[1] = new vr(o, 0, o.getCoordinate())), this.minDistance <= this.terminateDistance) return null;
      }
    }, distance: function () {
      if (null === this.geom[0] || null === this.geom[1]) throw new i("null geometries are not supported");return this.geom[0].isEmpty() || this.geom[1].isEmpty() ? 0 : (this.computeMinDistance(), this.minDistance);
    }, computeMinDistanceLines: function (t, e, n) {
      for (var i = 0; i < t.size(); i++) for (var r = t.get(i), s = 0; s < e.size(); s++) {
        var o = e.get(s);if (this.computeMinDistance(r, o, n), this.minDistance <= this.terminateDistance) return null;
      }
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return xr;
    } }), xr.distance = function (t, e) {
    var n = new xr(t, e);return n.distance();
  }, xr.isWithinDistance = function (t, e, n) {
    var i = new xr(t, e, n);return i.distance() <= n;
  }, xr.nearestPoints = function (t, e) {
    var n = new xr(t, e);return n.nearestPoints();
  };var wo = Object.freeze({ DistanceOp: xr });e(Er.prototype, { getCoordinates: function () {
      if (null === this.coordinates) {
        for (var t = 0, e = 0, n = new N(), i = this.directedEdges.iterator(); i.hasNext();) {
          var r = i.next();r.getEdgeDirection() ? t++ : e++, n.add(r.getEdge().getLine().getCoordinates(), !1, r.getEdgeDirection());
        }this.coordinates = n.toCoordinateArray(), e > t && H.reverse(this.coordinates);
      }return this.coordinates;
    }, toLineString: function () {
      return this.factory.createLineString(this.getCoordinates());
    }, add: function (t) {
      this.directedEdges.add(t);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Er;
    } }), e(Ir.prototype, { setVisited: function (t) {
      this._isVisited = t;
    }, isMarked: function () {
      return this._isMarked;
    }, setData: function (t) {
      this.data = t;
    }, getData: function () {
      return this.data;
    }, setMarked: function (t) {
      this._isMarked = t;
    }, getContext: function () {
      return this.data;
    }, isVisited: function () {
      return this._isVisited;
    }, setContext: function (t) {
      this.data = t;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Ir;
    } }), Ir.getComponentWithVisitedState = function (t, e) {
    for (; t.hasNext();) {
      var n = t.next();if (n.isVisited() === e) return n;
    }return null;
  }, Ir.setVisited = function (t, e) {
    for (; t.hasNext();) {
      var n = t.next();n.setVisited(e);
    }
  }, Ir.setMarked = function (t, e) {
    for (; t.hasNext();) {
      var n = t.next();n.setMarked(e);
    }
  }, h(Nr, Ir), e(Nr.prototype, { isRemoved: function () {
      return null === this.parentEdge;
    }, compareDirection: function (t) {
      return this.quadrant > t.quadrant ? 1 : this.quadrant < t.quadrant ? -1 : he.computeOrientation(t.p0, t.p1, this.p1);
    }, getCoordinate: function () {
      return this.from.getCoordinate();
    }, print: function (t) {
      var e = this.getClass().getName(),
          n = e.lastIndexOf("."),
          i = e.substring(n + 1);t.print("  " + i + ": " + this.p0 + " - " + this.p1 + " " + this.quadrant + ":" + this.angle);
    }, getDirectionPt: function () {
      return this.p1;
    }, getAngle: function () {
      return this.angle;
    }, compareTo: function (t) {
      var e = t;return this.compareDirection(e);
    }, getFromNode: function () {
      return this.from;
    }, getSym: function () {
      return this.sym;
    }, setEdge: function (t) {
      this.parentEdge = t;
    }, remove: function () {
      this.sym = null, this.parentEdge = null;
    }, getEdge: function () {
      return this.parentEdge;
    }, getQuadrant: function () {
      return this.quadrant;
    }, setSym: function (t) {
      this.sym = t;
    }, getToNode: function () {
      return this.to;
    }, getEdgeDirection: function () {
      return this.edgeDirection;
    }, interfaces_: function () {
      return [s];
    }, getClass: function () {
      return Nr;
    } }), Nr.toEdges = function (t) {
    for (var e = new I(), n = t.iterator(); n.hasNext();) e.add(n.next().parentEdge);return e;
  }, h(Cr, Nr), e(Cr.prototype, { getNext: function () {
      return 2 !== this.getToNode().getDegree() ? null : this.getToNode().getOutEdges().getEdges().get(0) === this.getSym() ? this.getToNode().getOutEdges().getEdges().get(1) : (f.isTrue(this.getToNode().getOutEdges().getEdges().get(1) === this.getSym()), this.getToNode().getOutEdges().getEdges().get(0));
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Cr;
    } }), h(Sr, Ir), e(Sr.prototype, { isRemoved: function () {
      return null === this.dirEdge;
    }, setDirectedEdges: function (t, e) {
      this.dirEdge = [t, e], t.setEdge(this), e.setEdge(this), t.setSym(e), e.setSym(t), t.getFromNode().addOutEdge(t), e.getFromNode().addOutEdge(e);
    }, getDirEdge: function () {
      if (Number.isInteger(arguments[0])) {
        var t = arguments[0];return this.dirEdge[t];
      }if (arguments[0] instanceof Lr) {
        var e = arguments[0];return this.dirEdge[0].getFromNode() === e ? this.dirEdge[0] : this.dirEdge[1].getFromNode() === e ? this.dirEdge[1] : null;
      }
    }, remove: function () {
      this.dirEdge = null;
    }, getOppositeNode: function (t) {
      return this.dirEdge[0].getFromNode() === t ? this.dirEdge[0].getToNode() : this.dirEdge[1].getFromNode() === t ? this.dirEdge[1].getToNode() : null;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Sr;
    } }), e(wr.prototype, { getNextEdge: function (t) {
      var e = this.getIndex(t);return this.outEdges.get(this.getIndex(e + 1));
    }, getCoordinate: function () {
      var t = this.iterator();if (!t.hasNext()) return null;var e = t.next();return e.getCoordinate();
    }, iterator: function () {
      return this.sortEdges(), this.outEdges.iterator();
    }, sortEdges: function () {
      this.sorted || (ho.sort(this.outEdges), this.sorted = !0);
    }, remove: function (t) {
      this.outEdges.remove(t);
    }, getEdges: function () {
      return this.sortEdges(), this.outEdges;
    }, getNextCWEdge: function (t) {
      var e = this.getIndex(t);return this.outEdges.get(this.getIndex(e - 1));
    }, getIndex: function () {
      if (arguments[0] instanceof Sr) {
        var t = arguments[0];this.sortEdges();for (var e = 0; e < this.outEdges.size(); e++) {
          var n = this.outEdges.get(e);if (n.getEdge() === t) return e;
        }return -1;
      }if (arguments[0] instanceof Nr) {
        var i = arguments[0];this.sortEdges();for (var e = 0; e < this.outEdges.size(); e++) {
          var n = this.outEdges.get(e);if (n === i) return e;
        }return -1;
      }if (Number.isInteger(arguments[0])) {
        var r = arguments[0],
            s = r % this.outEdges.size();return s < 0 && (s += this.outEdges.size()), s;
      }
    }, add: function (t) {
      this.outEdges.add(t), this.sorted = !1;
    }, getDegree: function () {
      return this.outEdges.size();
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return wr;
    } }), h(Lr, Ir), e(Lr.prototype, { isRemoved: function () {
      return null === this.pt;
    }, addOutEdge: function (t) {
      this.deStar.add(t);
    }, getCoordinate: function () {
      return this.pt;
    }, getOutEdges: function () {
      return this.deStar;
    }, remove: function () {
      if (0 === arguments.length) this.pt = null;else if (1 === arguments.length) {
        var t = arguments[0];this.deStar.remove(t);
      }
    }, getIndex: function (t) {
      return this.deStar.getIndex(t);
    }, getDegree: function () {
      return this.deStar.getDegree();
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Lr;
    } }), Lr.getEdgesBetween = function (t, e) {
    var n = Nr.toEdges(t.getOutEdges().getEdges()),
        i = new J(n),
        r = Nr.toEdges(e.getOutEdges().getEdges());return i.retainAll(r), i;
  }, h(Rr, Sr), e(Rr.prototype, { getLine: function () {
      return this.line;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Rr;
    } }), e(Tr.prototype, { find: function (t) {
      return this.nodeMap.get(t);
    }, iterator: function () {
      return this.nodeMap.values().iterator();
    }, remove: function (t) {
      return this.nodeMap.remove(t);
    }, values: function () {
      return this.nodeMap.values();
    }, add: function (t) {
      return this.nodeMap.put(t.getCoordinate(), t), t;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Tr;
    } }), e(Pr.prototype, { findNodesOfDegree: function (t) {
      for (var e = new I(), n = this.nodeIterator(); n.hasNext();) {
        var i = n.next();i.getDegree() === t && e.add(i);
      }return e;
    }, dirEdgeIterator: function () {
      return this.dirEdges.iterator();
    }, edgeIterator: function () {
      return this.edges.iterator();
    }, remove: function () {
      if (arguments[0] instanceof Sr) {
        var t = arguments[0];this.remove(t.getDirEdge(0)), this.remove(t.getDirEdge(1)), this.edges.remove(t), t.remove();
      } else if (arguments[0] instanceof Nr) {
        var e = arguments[0],
            n = e.getSym();null !== n && n.setSym(null), e.getFromNode().remove(e), e.remove(), this.dirEdges.remove(e);
      } else if (arguments[0] instanceof Lr) {
        for (var i = arguments[0], r = i.getOutEdges().getEdges(), s = r.iterator(); s.hasNext();) {
          var o = s.next(),
              n = o.getSym();null !== n && this.remove(n), this.dirEdges.remove(o);var a = o.getEdge();null !== a && this.edges.remove(a);
        }this.nodeMap.remove(i.getCoordinate()), i.remove();
      }
    }, findNode: function (t) {
      return this.nodeMap.find(t);
    }, getEdges: function () {
      return this.edges;
    }, nodeIterator: function () {
      return this.nodeMap.iterator();
    }, contains: function () {
      if (arguments[0] instanceof Sr) {
        var t = arguments[0];return this.edges.contains(t);
      }if (arguments[0] instanceof Nr) {
        var e = arguments[0];return this.dirEdges.contains(e);
      }
    }, add: function () {
      if (arguments[0] instanceof Lr) {
        var t = arguments[0];this.nodeMap.add(t);
      } else if (arguments[0] instanceof Sr) {
        var e = arguments[0];this.edges.add(e), this.add(e.getDirEdge(0)), this.add(e.getDirEdge(1));
      } else if (arguments[0] instanceof Nr) {
        var n = arguments[0];this.dirEdges.add(n);
      }
    }, getNodes: function () {
      return this.nodeMap.values();
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Pr;
    } }), h(br, Pr), e(br.prototype, { addEdge: function (t) {
      if (t.isEmpty()) return null;var e = H.removeRepeatedPoints(t.getCoordinates());if (e.length <= 1) return null;var n = e[0],
          i = e[e.length - 1],
          r = this.getNode(n),
          s = this.getNode(i),
          o = new Cr(r, s, e[1], !0),
          a = new Cr(s, r, e[e.length - 2], !1),
          u = new Rr(t);u.setDirectedEdges(o, a), this.add(u);
    }, getNode: function (t) {
      var e = this.findNode(t);return null === e && (e = new Lr(t), this.add(e)), e;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return br;
    } }), e(Or.prototype, { buildEdgeStringsForUnprocessedNodes: function () {
      for (var t = this.graph.getNodes().iterator(); t.hasNext();) {
        var e = t.next();e.isMarked() || (f.isTrue(2 === e.getDegree()), this.buildEdgeStringsStartingAt(e), e.setMarked(!0));
      }
    }, buildEdgeStringsForNonDegree2Nodes: function () {
      for (var t = this.graph.getNodes().iterator(); t.hasNext();) {
        var e = t.next();2 !== e.getDegree() && (this.buildEdgeStringsStartingAt(e), e.setMarked(!0));
      }
    }, buildEdgeStringsForObviousStartNodes: function () {
      this.buildEdgeStringsForNonDegree2Nodes();
    }, getMergedLineStrings: function () {
      return this.merge(), this.mergedLineStrings;
    }, buildEdgeStringsStartingAt: function (t) {
      for (var e = t.getOutEdges().iterator(); e.hasNext();) {
        var n = e.next();n.getEdge().isMarked() || this.edgeStrings.add(this.buildEdgeStringStartingWith(n));
      }
    }, merge: function () {
      if (null !== this.mergedLineStrings) return null;Ir.setMarked(this.graph.nodeIterator(), !1), Ir.setMarked(this.graph.edgeIterator(), !1), this.edgeStrings = new I(), this.buildEdgeStringsForObviousStartNodes(), this.buildEdgeStringsForIsolatedLoops(), this.mergedLineStrings = new I();for (var t = this.edgeStrings.iterator(); t.hasNext();) {
        var e = t.next();this.mergedLineStrings.add(e.toLineString());
      }
    }, buildEdgeStringStartingWith: function (t) {
      var e = new Er(this.factory),
          n = t;do e.add(n), n.getEdge().setMarked(!0), n = n.getNext(); while (null !== n && n !== t);return e;
    }, add: function () {
      if (arguments[0] instanceof B) {
        var t = arguments[0];t.apply({ interfaces_: function () {
            return [q];
          }, filter: function (t) {
            t instanceof St && this.add(t);
          } });
      } else if (R(arguments[0], v)) {
        var e = arguments[0];this.mergedLineStrings = null;for (var n = e.iterator(); n.hasNext();) {
          var i = n.next();this.add(i);
        }
      } else if (arguments[0] instanceof St) {
        var r = arguments[0];null === this.factory && (this.factory = r.getFactory()), this.graph.addEdge(r);
      }
    }, buildEdgeStringsForIsolatedLoops: function () {
      this.buildEdgeStringsForUnprocessedNodes();
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Or;
    } });var Lo = Object.freeze({ LineMerger: Or }),
      Ro = Object.freeze({ OverlayOp: ii });h(_r, Nr), e(_r.prototype, { getNext: function () {
      return this.next;
    }, isInRing: function () {
      return null !== this.edgeRing;
    }, setRing: function (t) {
      this.edgeRing = t;
    }, setLabel: function (t) {
      this.label = t;
    }, getLabel: function () {
      return this.label;
    }, setNext: function (t) {
      this.next = t;
    }, getRing: function () {
      return this.edgeRing;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return _r;
    } }), h(Mr, Sr), e(Mr.prototype, { getLine: function () {
      return this.line;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Mr;
    } }), e(Dr.prototype, { visitInteriorRing: function (t, e) {
      var n = t.getCoordinates(),
          i = n[0],
          r = Dr.findDifferentPoint(n, i),
          s = e.findEdgeInSameDirection(i, r),
          o = e.findEdgeEnd(s),
          a = null;o.getLabel().getLocation(0, cn.RIGHT) === L.INTERIOR ? a = o : o.getSym().getLabel().getLocation(0, cn.RIGHT) === L.INTERIOR && (a = o.getSym()), f.isTrue(null !== a, "unable to find dirEdge with Interior on RHS"), this.visitLinkedDirectedEdges(a);
    }, visitShellInteriors: function (t, e) {
      if (t instanceof Tt) {
        var n = t;this.visitInteriorRing(n.getExteriorRing(), e);
      }if (t instanceof Ot) for (var i = t, r = 0; r < i.getNumGeometries(); r++) {
        var n = i.getGeometryN(r);this.visitInteriorRing(n.getExteriorRing(), e);
      }
    }, getCoordinate: function () {
      return this.disconnectedRingcoord;
    }, setInteriorEdgesInResult: function (t) {
      for (var e = t.getEdgeEnds().iterator(); e.hasNext();) {
        var n = e.next();n.getLabel().getLocation(0, cn.RIGHT) === L.INTERIOR && n.setInResult(!0);
      }
    }, visitLinkedDirectedEdges: function (t) {
      var e = t,
          n = t;do f.isTrue(null !== n, "found null Directed Edge"), n.setVisited(!0), n = n.getNext(); while (n !== e);
    }, buildEdgeRings: function (t) {
      for (var e = new I(), n = t.iterator(); n.hasNext();) {
        var i = n.next();if (i.isInResult() && null === i.getEdgeRing()) {
          var r = new vn(i, this.geometryFactory);r.linkDirectedEdgesForMinimalEdgeRings();var s = r.buildMinimalRings();e.addAll(s);
        }
      }return e;
    }, hasUnvisitedShellEdge: function (t) {
      for (var e = 0; e < t.size(); e++) {
        var n = t.get(e);if (!n.isHole()) {
          var i = n.getEdges(),
              r = i.get(0);if (r.getLabel().getLocation(0, cn.RIGHT) === L.INTERIOR) for (var s = 0; s < i.size(); s++) if (r = i.get(s), !r.isVisited()) return this.disconnectedRingcoord = r.getCoordinate(), !0;
        }
      }return !1;
    }, isInteriorsConnected: function () {
      var t = new I();this.geomGraph.computeSplitEdges(t);var e = new Cn(new On());e.addEdges(t), this.setInteriorEdgesInResult(e), e.linkResultDirectedEdges();var n = this.buildEdgeRings(e.getEdgeEnds());return this.visitShellInteriors(this.geomGraph.getGeometry(), e), !this.hasUnvisitedShellEdge(n);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Dr;
    } }), Dr.findDifferentPoint = function (t, e) {
    for (var n = 0; n < t.length; n++) if (!t[n].equals(e)) return t[n];return null;
  }, e(Ar.prototype, { createEdgeEndForNext: function (t, e, n, i) {
      var r = n.segmentIndex + 1;if (r >= t.getNumPoints() && null === i) return null;var s = t.getCoordinate(r);null !== i && i.segmentIndex === n.segmentIndex && (s = i.coord);var o = new En(t, n.coord, s, new gn(t.getLabel()));e.add(o);
    }, createEdgeEndForPrev: function (t, e, n, i) {
      var r = n.segmentIndex;if (0 === n.dist) {
        if (0 === r) return null;r--;
      }var s = t.getCoordinate(r);null !== i && i.segmentIndex >= r && (s = i.coord);var o = new gn(t.getLabel());o.flip();var a = new En(t, n.coord, s, o);e.add(a);
    }, computeEdgeEnds: function () {
      if (1 === arguments.length) {
        for (var t = arguments[0], e = new I(), n = t; n.hasNext();) {
          var i = n.next();this.computeEdgeEnds(i, e);
        }return e;
      }if (2 === arguments.length) {
        var r = arguments[0],
            s = arguments[1],
            o = r.getEdgeIntersectionList();o.addEndpoints();var a = o.iterator(),
            u = null,
            l = null;if (!a.hasNext()) return null;var h = a.next();do u = l, l = h, h = null, a.hasNext() && (h = a.next()), null !== l && (this.createEdgeEndForPrev(r, s, l, u), this.createEdgeEndForNext(r, s, l, h)); while (null !== l);
      }
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Ar;
    } }), h(Fr, En), e(Fr.prototype, { insert: function (t) {
      this.edgeEnds.add(t);
    }, print: function (t) {
      t.println("EdgeEndBundle--> Label: " + this.label);for (var e = this.iterator(); e.hasNext();) {
        var n = e.next();n.print(t), t.println();
      }
    }, iterator: function () {
      return this.edgeEnds.iterator();
    }, getEdgeEnds: function () {
      return this.edgeEnds;
    }, computeLabelOn: function (t, e) {
      for (var n = 0, i = !1, r = this.iterator(); r.hasNext();) {
        var s = r.next(),
            o = s.getLabel().getLocation(t);o === L.BOUNDARY && n++, o === L.INTERIOR && (i = !0);
      }var o = L.NONE;i && (o = L.INTERIOR), n > 0 && (o = $n.determineBoundary(e, n)), this.label.setLocation(t, o);
    }, computeLabelSide: function (t, e) {
      for (var n = this.iterator(); n.hasNext();) {
        var i = n.next();if (i.getLabel().isArea()) {
          var r = i.getLabel().getLocation(t, e);if (r === L.INTERIOR) return this.label.setLocation(t, e, L.INTERIOR), null;r === L.EXTERIOR && this.label.setLocation(t, e, L.EXTERIOR);
        }
      }
    }, getLabel: function () {
      return this.label;
    }, computeLabelSides: function (t) {
      this.computeLabelSide(t, cn.LEFT), this.computeLabelSide(t, cn.RIGHT);
    }, updateIM: function (t) {
      Jn.updateIM(this.label, t);
    }, computeLabel: function (t) {
      for (var e = !1, n = this.iterator(); n.hasNext();) {
        var i = n.next();i.getLabel().isArea() && (e = !0);
      }e ? this.label = new gn(L.NONE, L.NONE, L.NONE) : this.label = new gn(L.NONE);for (var r = 0; r < 2; r++) this.computeLabelOn(r, t), e && this.computeLabelSides(r);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Fr;
    } }), h(Gr, Pn), e(Gr.prototype, { updateIM: function (t) {
      for (var e = this.iterator(); e.hasNext();) {
        var n = e.next();n.updateIM(t);
      }
    }, insert: function (t) {
      var e = this.edgeMap.get(t);null === e ? (e = new Fr(t), this.insertEdgeEnd(t, e)) : e.insert(t);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Gr;
    } }), h(qr, yn), e(qr.prototype, { updateIMFromEdges: function (t) {
      this.edges.updateIM(t);
    }, computeIM: function (t) {
      t.setAtLeastIfValid(this.label.getLocation(0), this.label.getLocation(1), 0);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return qr;
    } }), h(Br, Nn), e(Br.prototype, { createNode: function (t) {
      return new qr(t, new Gr());
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Br;
    } }), e(zr.prototype, { insertEdgeEnds: function (t) {
      for (var e = t.iterator(); e.hasNext();) {
        var n = e.next();this.nodes.add(n);
      }
    }, getNodeIterator: function () {
      return this.nodes.iterator();
    }, copyNodesAndLabels: function (t, e) {
      for (var n = t.getNodeIterator(); n.hasNext();) {
        var i = n.next(),
            r = this.nodes.addNode(i.getCoordinate());r.setLabel(e, i.getLabel().getLocation(e));
      }
    }, build: function (t) {
      this.computeIntersectionNodes(t, 0), this.copyNodesAndLabels(t, 0);var e = new Ar(),
          n = e.computeEdgeEnds(t.getEdgeIterator());this.insertEdgeEnds(n);
    }, computeIntersectionNodes: function (t, e) {
      for (var n = t.getEdgeIterator(); n.hasNext();) for (var i = n.next(), r = i.getLabel().getLocation(e), s = i.getEdgeIntersectionList().iterator(); s.hasNext();) {
        var o = s.next(),
            a = this.nodes.addNode(o.coord);r === L.BOUNDARY ? a.setLabelBoundary(e) : a.getLabel().isNull(e) && a.setLabel(e, L.INTERIOR);
      }
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return zr;
    } }), e(Vr.prototype, { isNodeEdgeAreaLabelsConsistent: function () {
      for (var t = this.nodeGraph.getNodeIterator(); t.hasNext();) {
        var e = t.next();if (!e.getEdges().isAreaLabelsConsistent(this.geomGraph)) return this.invalidPoint = e.getCoordinate().copy(), !1;
      }return !0;
    }, getInvalidPoint: function () {
      return this.invalidPoint;
    }, hasDuplicateRings: function () {
      for (var t = this.nodeGraph.getNodeIterator(); t.hasNext();) for (var e = t.next(), n = e.getEdges().iterator(); n.hasNext();) {
        var i = n.next();if (i.getEdgeEnds().size() > 1) return this.invalidPoint = i.getEdge().getCoordinate(0), !0;
      }return !1;
    }, isNodeConsistentArea: function () {
      var t = this.geomGraph.computeSelfNodes(this.li, !0, !0);return t.hasProperIntersection() ? (this.invalidPoint = t.getProperIntersectionPoint(), !1) : (this.nodeGraph.build(this.geomGraph), this.isNodeEdgeAreaLabelsConsistent());
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Vr;
    } }), e(kr.prototype, { buildIndex: function () {
      this.index = new ke();for (var t = 0; t < this.rings.size(); t++) {
        var e = this.rings.get(t),
            n = e.getEnvelopeInternal();this.index.insert(n, e);
      }
    }, getNestedPoint: function () {
      return this.nestedPt;
    }, isNonNested: function () {
      this.buildIndex();for (var t = 0; t < this.rings.size(); t++) for (var e = this.rings.get(t), n = e.getCoordinates(), i = this.index.query(e.getEnvelopeInternal()), r = 0; r < i.size(); r++) {
        var s = i.get(r),
            o = s.getCoordinates();if (e !== s && e.getEnvelopeInternal().intersects(s.getEnvelopeInternal())) {
          var a = Ur.findPtNotNode(n, s, this.graph);if (null !== a) {
            var u = he.isPointInRing(a, o);if (u) return this.nestedPt = a, !1;
          }
        }
      }return !0;
    }, add: function (t) {
      this.rings.add(t), this.totalEnv.expandToInclude(t.getEnvelopeInternal());
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return kr;
    } }), e(Yr.prototype, { getErrorType: function () {
      return this.errorType;
    }, getMessage: function () {
      return Yr.errMsg[this.errorType];
    }, getCoordinate: function () {
      return this.pt;
    }, toString: function () {
      var t = "";return null !== this.pt && (t = " at or near point " + this.pt), this.getMessage() + t;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Yr;
    } }), Yr.ERROR = 0, Yr.REPEATED_POINT = 1, Yr.HOLE_OUTSIDE_SHELL = 2, Yr.NESTED_HOLES = 3, Yr.DISCONNECTED_INTERIOR = 4, Yr.SELF_INTERSECTION = 5, Yr.RING_SELF_INTERSECTION = 6, Yr.NESTED_SHELLS = 7, Yr.DUPLICATE_RINGS = 8, Yr.TOO_FEW_POINTS = 9, Yr.INVALID_COORDINATE = 10, Yr.RING_NOT_CLOSED = 11, Yr.errMsg = ["Topology Validation Error", "Repeated Point", "Hole lies outside shell", "Holes are nested", "Interior is disconnected", "Self-intersection", "Ring Self-intersection", "Nested shells", "Duplicate Rings", "Too few distinct points in geometry component", "Invalid Coordinate", "Ring is not closed"], e(Ur.prototype, { checkInvalidCoordinates: function () {
      if (arguments[0] instanceof Array) {
        for (var t = arguments[0], e = 0; e < t.length; e++) if (!Ur.isValid(t[e])) return this.validErr = new Yr(Yr.INVALID_COORDINATE, t[e]), null;
      } else if (arguments[0] instanceof Tt) {
        var n = arguments[0];if (this.checkInvalidCoordinates(n.getExteriorRing().getCoordinates()), null !== this.validErr) return null;for (var e = 0; e < n.getNumInteriorRing(); e++) if (this.checkInvalidCoordinates(n.getInteriorRingN(e).getCoordinates()), null !== this.validErr) return null;
      }
    }, checkHolesNotNested: function (t, e) {
      for (var n = new kr(e), i = 0; i < t.getNumInteriorRing(); i++) {
        var r = t.getInteriorRingN(i);n.add(r);
      }var s = n.isNonNested();s || (this.validErr = new Yr(Yr.NESTED_HOLES, n.getNestedPoint()));
    }, checkConsistentArea: function (t) {
      var e = new Vr(t),
          n = e.isNodeConsistentArea();return n ? void (e.hasDuplicateRings() && (this.validErr = new Yr(Yr.DUPLICATE_RINGS, e.getInvalidPoint()))) : (this.validErr = new Yr(Yr.SELF_INTERSECTION, e.getInvalidPoint()), null);
    }, isValid: function () {
      return this.checkValid(this.parentGeometry), null === this.validErr;
    }, checkShellInsideHole: function (t, e, n) {
      var i = t.getCoordinates(),
          r = e.getCoordinates(),
          s = Ur.findPtNotNode(i, e, n);if (null !== s) {
        var o = he.isPointInRing(s, r);if (!o) return s;
      }var a = Ur.findPtNotNode(r, t, n);if (null !== a) {
        var u = he.isPointInRing(a, i);return u ? a : null;
      }return f.shouldNeverReachHere("points in shell and hole appear to be equal"), null;
    }, checkNoSelfIntersectingRings: function (t) {
      for (var e = t.getEdgeIterator(); e.hasNext();) {
        var n = e.next();if (this.checkNoSelfIntersectingRing(n.getEdgeIntersectionList()), null !== this.validErr) return null;
      }
    }, checkConnectedInteriors: function (t) {
      var e = new Dr(t);e.isInteriorsConnected() || (this.validErr = new Yr(Yr.DISCONNECTED_INTERIOR, e.getCoordinate()));
    }, checkNoSelfIntersectingRing: function (t) {
      for (var e = new at(), n = !0, i = t.iterator(); i.hasNext();) {
        var r = i.next();if (n) n = !1;else {
          if (e.contains(r.coord)) return this.validErr = new Yr(Yr.RING_SELF_INTERSECTION, r.coord), null;e.add(r.coord);
        }
      }
    }, checkHolesInShell: function (t, e) {
      for (var n = t.getExteriorRing(), i = new Ii(n), r = 0; r < t.getNumInteriorRing(); r++) {
        var s = t.getInteriorRingN(r),
            o = Ur.findPtNotNode(s.getCoordinates(), n, e);if (null === o) return null;var a = !i.isInside(o);if (a) return this.validErr = new Yr(Yr.HOLE_OUTSIDE_SHELL, o), null;
      }
    }, checkTooFewPoints: function (t) {
      if (t.hasTooFewPoints()) return this.validErr = new Yr(Yr.TOO_FEW_POINTS, t.getInvalidPoint()), null;
    }, getValidationError: function () {
      return this.checkValid(this.parentGeometry), this.validErr;
    }, checkValid: function () {
      if (arguments[0] instanceof Lt) {
        var t = arguments[0];this.checkInvalidCoordinates(t.getCoordinates());
      } else if (arguments[0] instanceof Pt) {
        var e = arguments[0];this.checkInvalidCoordinates(e.getCoordinates());
      } else if (arguments[0] instanceof bt) {
        var n = arguments[0];if (this.checkInvalidCoordinates(n.getCoordinates()), null !== this.validErr) return null;if (this.checkClosedRing(n), null !== this.validErr) return null;var i = new $n(0, n);if (this.checkTooFewPoints(i), null !== this.validErr) return null;var r = new ae();i.computeSelfNodes(r, !0, !0), this.checkNoSelfIntersectingRings(i);
      } else if (arguments[0] instanceof St) {
        var s = arguments[0];if (this.checkInvalidCoordinates(s.getCoordinates()), null !== this.validErr) return null;var i = new $n(0, s);this.checkTooFewPoints(i);
      } else if (arguments[0] instanceof Tt) {
        var o = arguments[0];if (this.checkInvalidCoordinates(o), null !== this.validErr) return null;if (this.checkClosedRings(o), null !== this.validErr) return null;var i = new $n(0, o);if (this.checkTooFewPoints(i), null !== this.validErr) return null;if (this.checkConsistentArea(i), null !== this.validErr) return null;if (!this.isSelfTouchingRingFormingHoleValid && (this.checkNoSelfIntersectingRings(i), null !== this.validErr)) return null;if (this.checkHolesInShell(o, i), null !== this.validErr) return null;if (this.checkHolesNotNested(o, i), null !== this.validErr) return null;this.checkConnectedInteriors(i);
      } else if (arguments[0] instanceof Ot) {
        for (var a = arguments[0], u = 0; u < a.getNumGeometries(); u++) {
          var l = a.getGeometryN(u);if (this.checkInvalidCoordinates(l), null !== this.validErr) return null;if (this.checkClosedRings(l), null !== this.validErr) return null;
        }var i = new $n(0, a);if (this.checkTooFewPoints(i), null !== this.validErr) return null;if (this.checkConsistentArea(i), null !== this.validErr) return null;if (!this.isSelfTouchingRingFormingHoleValid && (this.checkNoSelfIntersectingRings(i), null !== this.validErr)) return null;for (var u = 0; u < a.getNumGeometries(); u++) {
          var l = a.getGeometryN(u);if (this.checkHolesInShell(l, i), null !== this.validErr) return null;
        }for (var u = 0; u < a.getNumGeometries(); u++) {
          var l = a.getGeometryN(u);if (this.checkHolesNotNested(l, i), null !== this.validErr) return null;
        }if (this.checkShellsNotNested(a, i), null !== this.validErr) return null;this.checkConnectedInteriors(i);
      } else if (arguments[0] instanceof ft) for (var h = arguments[0], u = 0; u < h.getNumGeometries(); u++) {
        var c = h.getGeometryN(u);if (this.checkValid(c), null !== this.validErr) return null;
      } else if (arguments[0] instanceof B) {
        var f = arguments[0];if (this.validErr = null, f.isEmpty()) return null;if (f instanceof Lt) this.checkValid(f);else if (f instanceof Pt) this.checkValid(f);else if (f instanceof bt) this.checkValid(f);else if (f instanceof St) this.checkValid(f);else if (f instanceof Tt) this.checkValid(f);else if (f instanceof Ot) this.checkValid(f);else {
          if (!(f instanceof ft)) throw new UnsupportedOperationException(f.getClass().getName());this.checkValid(f);
        }
      }
    }, setSelfTouchingRingFormingHoleValid: function (t) {
      this.isSelfTouchingRingFormingHoleValid = t;
    }, checkShellNotNested: function (t, e, n) {
      var i = t.getCoordinates(),
          r = e.getExteriorRing(),
          s = r.getCoordinates(),
          o = Ur.findPtNotNode(i, r, n);if (null === o) return null;var a = he.isPointInRing(o, s);if (!a) return null;if (e.getNumInteriorRing() <= 0) return this.validErr = new Yr(Yr.NESTED_SHELLS, o), null;for (var u = null, l = 0; l < e.getNumInteriorRing(); l++) {
        var h = e.getInteriorRingN(l);if (u = this.checkShellInsideHole(t, h, n), null === u) return null;
      }this.validErr = new Yr(Yr.NESTED_SHELLS, u);
    }, checkClosedRings: function (t) {
      if (this.checkClosedRing(t.getExteriorRing()), null !== this.validErr) return null;for (var e = 0; e < t.getNumInteriorRing(); e++) if (this.checkClosedRing(t.getInteriorRingN(e)), null !== this.validErr) return null;
    }, checkClosedRing: function (t) {
      if (!t.isClosed()) {
        var e = null;t.getNumPoints() >= 1 && (e = t.getCoordinateN(0)), this.validErr = new Yr(Yr.RING_NOT_CLOSED, e);
      }
    }, checkShellsNotNested: function (t, e) {
      for (var n = 0; n < t.getNumGeometries(); n++) for (var i = t.getGeometryN(n), r = i.getExteriorRing(), s = 0; s < t.getNumGeometries(); s++) if (n !== s) {
        var o = t.getGeometryN(s);if (this.checkShellNotNested(r, o, e), null !== this.validErr) return null;
      }
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Ur;
    } }), Ur.findPtNotNode = function (t, e, n) {
    for (var i = n.findEdge(e), r = i.getEdgeIntersectionList(), s = 0; s < t.length; s++) {
      var o = t[s];if (!r.isIntersection(o)) return o;
    }return null;
  }, Ur.isValid = function () {
    if (arguments[0] instanceof B) {
      var t = arguments[0],
          e = new Ur(t);return e.isValid();
    }if (arguments[0] instanceof g) {
      var n = arguments[0];return !r.isNaN(n.x) && !r.isInfinite(n.x) && !r.isNaN(n.y) && !r.isInfinite(n.y);
    }
  }, e(Xr.prototype, { isIncluded: function () {
      return this._isIncluded;
    }, getCoordinates: function () {
      if (null === this.ringPts) {
        for (var t = new N(), e = this.deList.iterator(); e.hasNext();) {
          var n = e.next(),
              i = n.getEdge();Xr.addEdge(i.getLine().getCoordinates(), n.getEdgeDirection(), t);
        }this.ringPts = t.toCoordinateArray();
      }return this.ringPts;
    }, isIncludedSet: function () {
      return this._isIncludedSet;
    }, isValid: function () {
      return this.getCoordinates(), !(this.ringPts.length <= 3) && (this.getRing(), Ur.isValid(this.ring));
    }, build: function (t) {
      var e = t;do this.add(e), e.setRing(this), e = e.getNext(), f.isTrue(null !== e, "found null DE in ring"), f.isTrue(e === t || !e.isInRing(), "found DE already in ring"); while (e !== t);
    }, isOuterHole: function () {
      return !!this._isHole && !this.hasShell();
    }, getPolygon: function () {
      var t = null;if (null !== this.holes) {
        t = new Array(this.holes.size()).fill(null);for (var e = 0; e < this.holes.size(); e++) t[e] = this.holes.get(e);
      }var n = this.factory.createPolygon(this.ring, t);return n;
    }, isHole: function () {
      return this._isHole;
    }, isProcessed: function () {
      return this._isProcessed;
    }, addHole: function () {
      if (arguments[0] instanceof bt) {
        var t = arguments[0];null === this.holes && (this.holes = new I()), this.holes.add(t);
      } else if (arguments[0] instanceof Xr) {
        var e = arguments[0];e.setShell(this);var n = e.getRing();null === this.holes && (this.holes = new I()), this.holes.add(n);
      }
    }, setIncluded: function (t) {
      this._isIncluded = t, this._isIncludedSet = !0;
    }, getOuterHole: function () {
      if (this.isHole()) return null;for (var t = 0; t < this.deList.size(); t++) {
        var e = this.deList.get(t),
            n = e.getSym().getRing();if (n.isOuterHole()) return n;
      }return null;
    }, computeHole: function () {
      var t = this.getRing();this._isHole = he.isCCW(t.getCoordinates());
    }, hasShell: function () {
      return null !== this.shell;
    }, isOuterShell: function () {
      return null !== this.getOuterHole();
    }, getLineString: function () {
      return this.getCoordinates(), this.factory.createLineString(this.ringPts);
    }, toString: function () {
      return se.toLineString(new Gt(this.getCoordinates()));
    }, getShell: function () {
      return this.isHole() ? this.shell : this;
    }, add: function (t) {
      this.deList.add(t);
    }, getRing: function () {
      if (null !== this.ring) return this.ring;this.getCoordinates(), this.ringPts.length < 3 && A.out.println(this.ringPts);try {
        this.ring = this.factory.createLinearRing(this.ringPts);
      } catch (t) {
        if (!(t instanceof S)) throw t;A.out.println(this.ringPts);
      } finally {}return this.ring;
    }, updateIncluded: function () {
      if (this.isHole()) return null;for (var t = 0; t < this.deList.size(); t++) {
        var e = this.deList.get(t),
            n = e.getSym().getRing().getShell();if (null !== n && n.isIncludedSet()) return this.setIncluded(!n.isIncluded()), null;
      }
    }, setShell: function (t) {
      this.shell = t;
    }, setProcessed: function (t) {
      this._isProcessed = t;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Xr;
    } }), Xr.findDirEdgesInRing = function (t) {
    var e = t,
        n = new I();do n.add(e), e = e.getNext(), f.isTrue(null !== e, "found null DE in ring"), f.isTrue(e === t || !e.isInRing(), "found DE already in ring"); while (e !== t);return n;
  }, Xr.addEdge = function (t, e, n) {
    if (e) for (var i = 0; i < t.length; i++) n.add(t[i], !1);else for (var i = t.length - 1; i >= 0; i--) n.add(t[i], !1);
  }, Xr.findEdgeRingContaining = function (t, e) {
    for (var n = t.getRing(), i = n.getEnvelopeInternal(), r = n.getCoordinateN(0), s = null, o = null, a = e.iterator(); a.hasNext();) {
      var u = a.next(),
          l = u.getRing(),
          h = l.getEnvelopeInternal();if (!h.equals(i) && h.contains(i)) {
        r = H.ptNotInList(n.getCoordinates(), l.getCoordinates());var c = !1;he.isPointInRing(r, l.getCoordinates()) && (c = !0), c && (null === s || o.contains(h)) && (s = u, o = s.getRing().getEnvelopeInternal());
      }
    }return s;
  }, e(Hr.prototype, { compare: function (t, e) {
      var n = t,
          i = e;return n.getRing().getEnvelope().compareTo(i.getRing().getEnvelope());
    }, interfaces_: function () {
      return [a];
    }, getClass: function () {
      return Hr;
    } }), Xr.EnvelopeComparator = Hr, h(Wr, Pr), e(Wr.prototype, { findEdgeRing: function (t) {
      var e = new Xr(this.factory);return e.build(t), e;
    }, computeDepthParity: function () {
      if (0 === arguments.length) for (;;) {
        var t = null;if (null === t) return null;this.computeDepthParity(t);
      } else if (1 === arguments.length) {
        arguments[0];
      }
    }, computeNextCWEdges: function () {
      for (var t = this.nodeIterator(); t.hasNext();) {
        var e = t.next();Wr.computeNextCWEdges(e);
      }
    }, addEdge: function (t) {
      if (t.isEmpty()) return null;var e = H.removeRepeatedPoints(t.getCoordinates());if (e.length < 2) return null;var n = e[0],
          i = e[e.length - 1],
          r = this.getNode(n),
          s = this.getNode(i),
          o = new _r(r, s, e[1], !0),
          a = new _r(s, r, e[e.length - 2], !1),
          u = new Mr(t);u.setDirectedEdges(o, a), this.add(u);
    }, deleteCutEdges: function () {
      this.computeNextCWEdges(), Wr.findLabeledEdgeRings(this.dirEdges);for (var t = new I(), e = this.dirEdges.iterator(); e.hasNext();) {
        var n = e.next();if (!n.isMarked()) {
          var i = n.getSym();if (n.getLabel() === i.getLabel()) {
            n.setMarked(!0), i.setMarked(!0);var r = n.getEdge();t.add(r.getLine());
          }
        }
      }return t;
    }, getEdgeRings: function () {
      this.computeNextCWEdges(), Wr.label(this.dirEdges, -1);var t = Wr.findLabeledEdgeRings(this.dirEdges);this.convertMaximalToMinimalEdgeRings(t);for (var e = new I(), n = this.dirEdges.iterator(); n.hasNext();) {
        var i = n.next();if (!i.isMarked() && !i.isInRing()) {
          var r = this.findEdgeRing(i);e.add(r);
        }
      }return e;
    }, getNode: function (t) {
      var e = this.findNode(t);return null === e && (e = new Lr(t), this.add(e)), e;
    }, convertMaximalToMinimalEdgeRings: function (t) {
      for (var e = t.iterator(); e.hasNext();) {
        var n = e.next(),
            i = n.getLabel(),
            r = Wr.findIntersectionNodes(n, i);if (null !== r) for (var s = r.iterator(); s.hasNext();) {
          var o = s.next();Wr.computeNextCCWEdges(o, i);
        }
      }
    }, deleteDangles: function () {
      for (var t = this.findNodesOfDegree(1), e = new J(), n = new pe(), i = t.iterator(); i.hasNext();) n.push(i.next());for (; !n.isEmpty();) {
        var r = n.pop();Wr.deleteAllEdges(r);for (var s = r.getOutEdges().getEdges(), i = s.iterator(); i.hasNext();) {
          var o = i.next();o.setMarked(!0);var a = o.getSym();null !== a && a.setMarked(!0);var u = o.getEdge();e.add(u.getLine());var l = o.getToNode();1 === Wr.getDegreeNonDeleted(l) && n.push(l);
        }
      }return e;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Wr;
    } }), Wr.findLabeledEdgeRings = function (t) {
    for (var e = new I(), n = 1, i = t.iterator(); i.hasNext();) {
      var r = i.next();if (!(r.isMarked() || r.getLabel() >= 0)) {
        e.add(r);var s = Xr.findDirEdgesInRing(r);Wr.label(s, n), n++;
      }
    }return e;
  }, Wr.getDegreeNonDeleted = function (t) {
    for (var e = t.getOutEdges().getEdges(), n = 0, i = e.iterator(); i.hasNext();) {
      var r = i.next();r.isMarked() || n++;
    }return n;
  }, Wr.deleteAllEdges = function (t) {
    for (var e = t.getOutEdges().getEdges(), n = e.iterator(); n.hasNext();) {
      var i = n.next();i.setMarked(!0);var r = i.getSym();null !== r && r.setMarked(!0);
    }
  }, Wr.label = function (t, e) {
    for (var n = t.iterator(); n.hasNext();) {
      var i = n.next();i.setLabel(e);
    }
  }, Wr.computeNextCWEdges = function (t) {
    for (var e = t.getOutEdges(), n = null, i = null, r = e.getEdges().iterator(); r.hasNext();) {
      var s = r.next();if (!s.isMarked()) {
        if (null === n && (n = s), null !== i) {
          var o = i.getSym();o.setNext(s);
        }i = s;
      }
    }if (null !== i) {
      var o = i.getSym();o.setNext(n);
    }
  }, Wr.computeNextCCWEdges = function (t, e) {
    for (var n = t.getOutEdges(), i = null, r = null, s = n.getEdges(), o = s.size() - 1; o >= 0; o--) {
      var a = s.get(o),
          u = a.getSym(),
          l = null;a.getLabel() === e && (l = a);var h = null;u.getLabel() === e && (h = u), null === l && null === h || (null !== h && (r = h), null !== l && (null !== r && (r.setNext(l), r = null), null === i && (i = l)));
    }null !== r && (f.isTrue(null !== i), r.setNext(i));
  }, Wr.getDegree = function (t, e) {
    for (var n = t.getOutEdges().getEdges(), i = 0, r = n.iterator(); r.hasNext();) {
      var s = r.next();s.getLabel() === e && i++;
    }return i;
  }, Wr.findIntersectionNodes = function (t, e) {
    var n = t,
        i = null;do {
      var r = n.getFromNode();Wr.getDegree(r, e) > 1 && (null === i && (i = new I()), i.add(r)), n = n.getNext(), f.isTrue(null !== n, "found null DE in ring"), f.isTrue(n === t || !n.isInRing(), "found DE already in ring");
    } while (n !== t);return i;
  }, e(jr.prototype, { getGeometry: function () {
      return null === this.geomFactory && (this.geomFactory = new ie()), this.polygonize(), this.extractOnlyPolygonal ? this.geomFactory.buildGeometry(this.polyList) : this.geomFactory.createGeometryCollection(ie.toGeometryArray(this.polyList));
    }, getInvalidRingLines: function () {
      return this.polygonize(), this.invalidRingLines;
    }, findValidRings: function (t, e, n) {
      for (var i = t.iterator(); i.hasNext();) {
        var r = i.next();r.isValid() ? e.add(r) : n.add(r.getLineString());
      }
    }, polygonize: function () {
      if (null !== this.polyList) return null;
      if (this.polyList = new I(), null === this.graph) return null;this.dangles = this.graph.deleteDangles(), this.cutEdges = this.graph.deleteCutEdges();var t = this.graph.getEdgeRings(),
          e = new I();this.invalidRingLines = new I(), this.isCheckingRingsValid ? this.findValidRings(t, e, this.invalidRingLines) : e = t, this.findShellsAndHoles(e), jr.assignHolesToShells(this.holeList, this.shellList), ho.sort(this.shellList, new Xr.EnvelopeComparator());var n = !0;this.extractOnlyPolygonal && (jr.findDisjointShells(this.shellList), n = !1), this.polyList = jr.extractPolygons(this.shellList, n);
    }, getDangles: function () {
      return this.polygonize(), this.dangles;
    }, getCutEdges: function () {
      return this.polygonize(), this.cutEdges;
    }, getPolygons: function () {
      return this.polygonize(), this.polyList;
    }, add: function () {
      if (R(arguments[0], v)) for (var t = arguments[0], e = t.iterator(); e.hasNext();) {
        var n = e.next();this.add(n);
      } else if (arguments[0] instanceof St) {
        var i = arguments[0];this.geomFactory = i.getFactory(), null === this.graph && (this.graph = new Wr(this.geomFactory)), this.graph.addEdge(i);
      } else if (arguments[0] instanceof B) {
        var r = arguments[0];r.apply(this.lineStringAdder);
      }
    }, setCheckRingsValid: function (t) {
      this.isCheckingRingsValid = t;
    }, findShellsAndHoles: function (t) {
      this.holeList = new I(), this.shellList = new I();for (var e = t.iterator(); e.hasNext();) {
        var n = e.next();n.computeHole(), n.isHole() ? this.holeList.add(n) : this.shellList.add(n);
      }
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return jr;
    } }), jr.findOuterShells = function (t) {
    for (var e = t.iterator(); e.hasNext();) {
      var n = e.next(),
          i = n.getOuterHole();null === i || i.isProcessed() || (n.setIncluded(!0), i.setProcessed(!0));
    }
  }, jr.extractPolygons = function (t, e) {
    for (var n = new I(), i = t.iterator(); i.hasNext();) {
      var r = i.next();(e || r.isIncluded()) && n.add(r.getPolygon());
    }return n;
  }, jr.assignHolesToShells = function (t, e) {
    for (var n = t.iterator(); n.hasNext();) {
      var i = n.next();jr.assignHoleToShell(i, e);
    }
  }, jr.assignHoleToShell = function (t, e) {
    var n = Xr.findEdgeRingContaining(t, e);null !== n && n.addHole(t);
  }, jr.findDisjointShells = function (t) {
    jr.findOuterShells(t);var e = null;do {
      e = !1;for (var n = t.iterator(); n.hasNext();) {
        var i = n.next();i.isIncludedSet() || (i.updateIncluded(), i.isIncludedSet() || (e = !0));
      }
    } while (e);
  }, e(Kr.prototype, { filter: function (t) {
      t instanceof St && this.p.add(t);
    }, interfaces_: function () {
      return [q];
    }, getClass: function () {
      return Kr;
    } }), jr.LineStringAdder = Kr;var To = Object.freeze({ Polygonizer: jr });e(Zr.prototype, { insertEdgeEnds: function (t) {
      for (var e = t.iterator(); e.hasNext();) {
        var n = e.next();this.nodes.add(n);
      }
    }, computeProperIntersectionIM: function (t, e) {
      var n = this.arg[0].getGeometry().getDimension(),
          i = this.arg[1].getGeometry().getDimension(),
          r = t.hasProperIntersection(),
          s = t.hasProperInteriorIntersection();2 === n && 2 === i ? r && e.setAtLeast("212101212") : 2 === n && 1 === i ? (r && e.setAtLeast("FFF0FFFF2"), s && e.setAtLeast("1FFFFF1FF")) : 1 === n && 2 === i ? (r && e.setAtLeast("F0FFFFFF2"), s && e.setAtLeast("1F1FFFFFF")) : 1 === n && 1 === i && s && e.setAtLeast("0FFFFFFFF");
    }, labelIsolatedEdges: function (t, e) {
      for (var n = this.arg[t].getEdgeIterator(); n.hasNext();) {
        var i = n.next();i.isIsolated() && (this.labelIsolatedEdge(i, e, this.arg[e].getGeometry()), this.isolatedEdges.add(i));
      }
    }, labelIsolatedEdge: function (t, e, n) {
      if (n.getDimension() > 0) {
        var i = this.ptLocator.locate(t.getCoordinate(), n);t.getLabel().setAllLocations(e, i);
      } else t.getLabel().setAllLocations(e, L.EXTERIOR);
    }, computeIM: function () {
      var t = new fe();if (t.set(L.EXTERIOR, L.EXTERIOR, 2), !this.arg[0].getGeometry().getEnvelopeInternal().intersects(this.arg[1].getGeometry().getEnvelopeInternal())) return this.computeDisjointIM(t), t;this.arg[0].computeSelfNodes(this.li, !1), this.arg[1].computeSelfNodes(this.li, !1);var e = this.arg[0].computeEdgeIntersections(this.arg[1], this.li, !1);this.computeIntersectionNodes(0), this.computeIntersectionNodes(1), this.copyNodesAndLabels(0), this.copyNodesAndLabels(1), this.labelIsolatedNodes(), this.computeProperIntersectionIM(e, t);var n = new Ar(),
          i = n.computeEdgeEnds(this.arg[0].getEdgeIterator());this.insertEdgeEnds(i);var r = n.computeEdgeEnds(this.arg[1].getEdgeIterator());return this.insertEdgeEnds(r), this.labelNodeEdges(), this.labelIsolatedEdges(0, 1), this.labelIsolatedEdges(1, 0), this.updateIM(t), t;
    }, labelNodeEdges: function () {
      for (var t = this.nodes.iterator(); t.hasNext();) {
        var e = t.next();e.getEdges().computeLabelling(this.arg);
      }
    }, copyNodesAndLabels: function (t) {
      for (var e = this.arg[t].getNodeIterator(); e.hasNext();) {
        var n = e.next(),
            i = this.nodes.addNode(n.getCoordinate());i.setLabel(t, n.getLabel().getLocation(t));
      }
    }, labelIntersectionNodes: function (t) {
      for (var e = this.arg[t].getEdgeIterator(); e.hasNext();) for (var n = e.next(), i = n.getLabel().getLocation(t), r = n.getEdgeIntersectionList().iterator(); r.hasNext();) {
        var s = r.next(),
            o = this.nodes.find(s.coord);o.getLabel().isNull(t) && (i === L.BOUNDARY ? o.setLabelBoundary(t) : o.setLabel(t, L.INTERIOR));
      }
    }, labelIsolatedNode: function (t, e) {
      var n = this.ptLocator.locate(t.getCoordinate(), this.arg[e].getGeometry());t.getLabel().setAllLocations(e, n);
    }, computeIntersectionNodes: function (t) {
      for (var e = this.arg[t].getEdgeIterator(); e.hasNext();) for (var n = e.next(), i = n.getLabel().getLocation(t), r = n.getEdgeIntersectionList().iterator(); r.hasNext();) {
        var s = r.next(),
            o = this.nodes.addNode(s.coord);i === L.BOUNDARY ? o.setLabelBoundary(t) : o.getLabel().isNull(t) && o.setLabel(t, L.INTERIOR);
      }
    }, labelIsolatedNodes: function () {
      for (var t = this.nodes.iterator(); t.hasNext();) {
        var e = t.next(),
            n = e.getLabel();f.isTrue(n.getGeometryCount() > 0, "node with empty label found"), e.isIsolated() && (n.isNull(0) ? this.labelIsolatedNode(e, 0) : this.labelIsolatedNode(e, 1));
      }
    }, updateIM: function (t) {
      for (var e = this.isolatedEdges.iterator(); e.hasNext();) {
        var n = e.next();n.updateIM(t);
      }for (var i = this.nodes.iterator(); i.hasNext();) {
        var r = i.next();r.updateIM(t), r.updateIMFromEdges(t);
      }
    }, computeDisjointIM: function (t) {
      var e = this.arg[0].getGeometry();e.isEmpty() || (t.set(L.INTERIOR, L.EXTERIOR, e.getDimension()), t.set(L.BOUNDARY, L.EXTERIOR, e.getBoundaryDimension()));var n = this.arg[1].getGeometry();n.isEmpty() || (t.set(L.EXTERIOR, L.INTERIOR, n.getDimension()), t.set(L.EXTERIOR, L.BOUNDARY, n.getBoundaryDimension()));
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Zr;
    } }), e(Qr.prototype, { isContainedInBoundary: function (t) {
      if (t instanceof Tt) return !1;if (t instanceof Lt) return this.isPointContainedInBoundary(t);if (t instanceof St) return this.isLineStringContainedInBoundary(t);for (var e = 0; e < t.getNumGeometries(); e++) {
        var n = t.getGeometryN(e);if (!this.isContainedInBoundary(n)) return !1;
      }return !0;
    }, isLineSegmentContainedInBoundary: function (t, e) {
      if (t.equals(e)) return this.isPointContainedInBoundary(t);if (t.x === e.x) {
        if (t.x === this.rectEnv.getMinX() || t.x === this.rectEnv.getMaxX()) return !0;
      } else if (t.y === e.y && (t.y === this.rectEnv.getMinY() || t.y === this.rectEnv.getMaxY())) return !0;return !1;
    }, isLineStringContainedInBoundary: function (t) {
      for (var e = t.getCoordinateSequence(), n = new g(), i = new g(), r = 0; r < e.size() - 1; r++) if (e.getCoordinate(r, n), e.getCoordinate(r + 1, i), !this.isLineSegmentContainedInBoundary(n, i)) return !1;return !0;
    }, isPointContainedInBoundary: function () {
      if (arguments[0] instanceof Lt) {
        var t = arguments[0];return this.isPointContainedInBoundary(t.getCoordinate());
      }if (arguments[0] instanceof g) {
        var e = arguments[0];return e.x === this.rectEnv.getMinX() || e.x === this.rectEnv.getMaxX() || e.y === this.rectEnv.getMinY() || e.y === this.rectEnv.getMaxY();
      }
    }, contains: function (t) {
      return !!this.rectEnv.contains(t.getEnvelopeInternal()) && !this.isContainedInBoundary(t);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Qr;
    } }), Qr.contains = function (t, e) {
    var n = new Qr(t);return n.contains(e);
  }, e(Jr.prototype, { intersects: function (t, e) {
      var n = new C(t, e);if (!this.rectEnv.intersects(n)) return !1;if (this.rectEnv.intersects(t)) return !0;if (this.rectEnv.intersects(e)) return !0;if (t.compareTo(e) > 0) {
        var i = t;t = e, e = i;
      }var r = !1;return e.y > t.y && (r = !0), r ? this.li.computeIntersection(t, e, this.diagDown0, this.diagDown1) : this.li.computeIntersection(t, e, this.diagUp0, this.diagUp1), !!this.li.hasIntersection();
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Jr;
    } }), e($r.prototype, { applyTo: function (t) {
      for (var e = 0; e < t.getNumGeometries() && !this._isDone; e++) {
        var n = t.getGeometryN(e);if (n instanceof ft) this.applyTo(n);else if (this.visit(n), this.isDone()) return this._isDone = !0, null;
      }
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return $r;
    } }), e(ts.prototype, { intersects: function (t) {
      if (!this.rectEnv.intersects(t.getEnvelopeInternal())) return !1;var e = new es(this.rectEnv);if (e.applyTo(t), e.intersects()) return !0;var n = new ns(this.rectangle);if (n.applyTo(t), n.containsPoint()) return !0;var i = new is(this.rectangle);return i.applyTo(t), !!i.intersects();
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return ts;
    } }), ts.intersects = function (t, e) {
    var n = new ts(t);return n.intersects(e);
  }, h(es, $r), e(es.prototype, { isDone: function () {
      return this._intersects === !0;
    }, visit: function (t) {
      var e = t.getEnvelopeInternal();return this.rectEnv.intersects(e) ? this.rectEnv.contains(e) ? (this._intersects = !0, null) : e.getMinX() >= this.rectEnv.getMinX() && e.getMaxX() <= this.rectEnv.getMaxX() ? (this._intersects = !0, null) : e.getMinY() >= this.rectEnv.getMinY() && e.getMaxY() <= this.rectEnv.getMaxY() ? (this._intersects = !0, null) : void 0 : null;
    }, intersects: function () {
      return this._intersects;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return es;
    } }), h(ns, $r), e(ns.prototype, { isDone: function () {
      return this._containsPoint === !0;
    }, visit: function (t) {
      if (!(t instanceof Tt)) return null;var e = t.getEnvelopeInternal();if (!this.rectEnv.intersects(e)) return null;for (var n = new g(), i = 0; i < 4; i++) if (this.rectSeq.getCoordinate(i, n), e.contains(n) && Tn.containsPointInPolygon(n, t)) return this._containsPoint = !0, null;
    }, containsPoint: function () {
      return this._containsPoint;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return ns;
    } }), h(is, $r), e(is.prototype, { intersects: function () {
      return this.hasIntersection;
    }, isDone: function () {
      return this.hasIntersection === !0;
    }, visit: function (t) {
      var e = t.getEnvelopeInternal();if (!this.rectEnv.intersects(e)) return null;var n = kn.getLines(t);this.checkIntersectionWithLineStrings(n);
    }, checkIntersectionWithLineStrings: function (t) {
      for (var e = t.iterator(); e.hasNext();) {
        var n = e.next();if (this.checkIntersectionWithSegments(n), this.hasIntersection) return null;
      }
    }, checkIntersectionWithSegments: function (t) {
      for (var e = t.getCoordinateSequence(), n = 1; n < e.size(); n++) if (e.getCoordinate(n - 1, this.p0), e.getCoordinate(n, this.p1), this.rectIntersector.intersects(this.p0, this.p1)) return this.hasIntersection = !0, null;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return is;
    } }), h(rs, ti), e(rs.prototype, { getIntersectionMatrix: function () {
      return this._relate.computeIM();
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return rs;
    } }), rs.covers = function (t, e) {
    return !!t.getEnvelopeInternal().covers(e.getEnvelopeInternal()) && (!!t.isRectangle() || rs.relate(t, e).isCovers());
  }, rs.intersects = function (t, e) {
    return !!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()) && (t.isRectangle() ? ts.intersects(t, e) : e.isRectangle() ? ts.intersects(e, t) : rs.relate(t, e).isIntersects());
  }, rs.touches = function (t, e) {
    return !!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()) && rs.relate(t, e).isTouches(t.getDimension(), e.getDimension());
  }, rs.within = function (t, e) {
    return e.contains(t);
  }, rs.coveredBy = function (t, e) {
    return rs.covers(e, t);
  }, rs.relate = function () {
    if (2 === arguments.length) {
      var t = arguments[0],
          e = arguments[1],
          n = new rs(t, e),
          i = n.getIntersectionMatrix();return i;
    }if (3 === arguments.length) {
      if ("string" == typeof arguments[2] && arguments[0] instanceof B && arguments[1] instanceof B) {
        var r = arguments[0],
            s = arguments[1],
            o = arguments[2];return rs.relateWithCheck(r, s).matches(o);
      }if (R(arguments[2], V) && arguments[0] instanceof B && arguments[1] instanceof B) {
        var a = arguments[0],
            u = arguments[1],
            l = arguments[2],
            n = new rs(a, u, l),
            i = n.getIntersectionMatrix();return i;
      }
    }
  }, rs.overlaps = function (t, e) {
    return !!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()) && rs.relate(t, e).isOverlaps(t.getDimension(), e.getDimension());
  }, rs.disjoint = function (t, e) {
    return !t.intersects(e);
  }, rs.relateWithCheck = function (t, e) {
    return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), rs.relate(t, e);
  }, rs.crosses = function (t, e) {
    return !!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()) && rs.relate(t, e).isCrosses(t.getDimension(), e.getDimension());
  }, rs.contains = function (t, e) {
    return !!t.getEnvelopeInternal().contains(e.getEnvelopeInternal()) && (t.isRectangle() ? Qr.contains(t, e) : rs.relate(t, e).isContains());
  };var Po = Object.freeze({ RelateOp: rs });e(ss.prototype, { extractElements: function (t, e) {
      if (null === t) return null;for (var n = 0; n < t.getNumGeometries(); n++) {
        var i = t.getGeometryN(n);this.skipEmpty && i.isEmpty() || e.add(i);
      }
    }, combine: function () {
      for (var t = new I(), e = this.inputGeoms.iterator(); e.hasNext();) {
        var n = e.next();this.extractElements(n, t);
      }return 0 === t.size() ? null !== this.geomFactory ? this.geomFactory.createGeometryCollection(null) : null : this.geomFactory.buildGeometry(t);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return ss;
    } }), ss.combine = function () {
    if (1 === arguments.length) {
      var t = arguments[0],
          e = new ss(t);return e.combine();
    }if (2 === arguments.length) {
      var n = arguments[0],
          i = arguments[1],
          e = new ss(ss.createList(n, i));return e.combine();
    }if (3 === arguments.length) {
      var r = arguments[0],
          s = arguments[1],
          o = arguments[2],
          e = new ss(ss.createList(r, s, o));return e.combine();
    }
  }, ss.extractFactory = function (t) {
    return t.isEmpty() ? null : t.iterator().next().getFactory();
  }, ss.createList = function () {
    if (2 === arguments.length) {
      var t = arguments[0],
          e = arguments[1],
          n = new I();return n.add(t), n.add(e), n;
    }if (3 === arguments.length) {
      var i = arguments[0],
          r = arguments[1],
          s = arguments[2],
          n = new I();return n.add(i), n.add(r), n.add(s), n;
    }
  }, e(os.prototype, { union: function () {
      for (var t = new Te(), e = new at(), n = 0; n < this.pointGeom.getNumGeometries(); n++) {
        var i = this.pointGeom.getGeometryN(n),
            r = i.getCoordinate(),
            s = t.locate(r, this.otherGeom);s === L.EXTERIOR && e.add(r);
      }if (0 === e.size()) return this.otherGeom;var o = null,
          a = H.toCoordinateArray(e);return o = 1 === a.length ? this.geomFact.createPoint(a[0]) : this.geomFact.createMultiPointFromCoords(a), ss.combine(o, this.otherGeom);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return os;
    } }), os.union = function (t, e) {
    var n = new os(t, e);return n.union();
  }, e(as.prototype, { filter: function (t) {
      this.sortIndex !== -1 && t.getSortIndex() !== this.sortIndex || this.comps.add(t);
    }, interfaces_: function () {
      return [ht];
    }, getClass: function () {
      return as;
    } }), as.extract = function () {
    if (2 === arguments.length) {
      var t = arguments[0],
          e = arguments[1];return as.extract(t, e, new I());
    }if (3 === arguments.length) {
      var n = arguments[0],
          i = arguments[1],
          r = arguments[2];return n.getSortIndex() === i ? r.add(n) : n instanceof ft && n.apply(new as(i, r)), r;
    }
  }, e(us.prototype, { reduceToGeometries: function (t) {
      for (var e = new I(), n = t.iterator(); n.hasNext();) {
        var i = n.next(),
            r = null;R(i, y) ? r = this.unionTree(i) : i instanceof B && (r = i), e.add(r);
      }return e;
    }, extractByEnvelope: function (t, e, n) {
      for (var i = new I(), r = 0; r < e.getNumGeometries(); r++) {
        var s = e.getGeometryN(r);s.getEnvelopeInternal().intersects(t) ? i.add(s) : n.add(s);
      }return this.geomFactory.buildGeometry(i);
    }, unionOptimized: function (t, e) {
      var n = t.getEnvelopeInternal(),
          i = e.getEnvelopeInternal();if (!n.intersects(i)) {
        var r = ss.combine(t, e);return r;
      }if (t.getNumGeometries() <= 1 && e.getNumGeometries() <= 1) return this.unionActual(t, e);var s = n.intersection(i);return this.unionUsingEnvelopeIntersection(t, e, s);
    }, union: function () {
      if (null === this.inputPolys) throw new IllegalStateException("union() method cannot be called twice");if (this.inputPolys.isEmpty()) return null;this.geomFactory = this.inputPolys.iterator().next().getFactory();for (var t = new ke(us.STRTREE_NODE_CAPACITY), e = this.inputPolys.iterator(); e.hasNext();) {
        var n = e.next();t.insert(n.getEnvelopeInternal(), n);
      }this.inputPolys = null;var i = t.itemsTree(),
          r = this.unionTree(i);return r;
    }, binaryUnion: function () {
      if (1 === arguments.length) {
        var t = arguments[0];return this.binaryUnion(t, 0, t.size());
      }if (3 === arguments.length) {
        var e = arguments[0],
            n = arguments[1],
            i = arguments[2];if (i - n <= 1) {
          var r = us.getGeometry(e, n);return this.unionSafe(r, null);
        }if (i - n === 2) return this.unionSafe(us.getGeometry(e, n), us.getGeometry(e, n + 1));var s = Math.trunc((i + n) / 2),
            r = this.binaryUnion(e, n, s),
            o = this.binaryUnion(e, s, i);return this.unionSafe(r, o);
      }
    }, repeatedUnion: function (t) {
      for (var e = null, n = t.iterator(); n.hasNext();) {
        var i = n.next();e = null === e ? i.copy() : e.union(i);
      }return e;
    }, unionSafe: function (t, e) {
      return null === t && null === e ? null : null === t ? e.copy() : null === e ? t.copy() : this.unionOptimized(t, e);
    }, unionActual: function (t, e) {
      return us.restrictToPolygons(t.union(e));
    }, unionTree: function (t) {
      var e = this.reduceToGeometries(t),
          n = this.binaryUnion(e);return n;
    }, unionUsingEnvelopeIntersection: function (t, e, n) {
      var i = new I(),
          r = this.extractByEnvelope(n, t, i),
          s = this.extractByEnvelope(n, e, i),
          o = this.unionActual(r, s);i.add(o);var a = ss.combine(i);return a;
    }, bufferUnion: function () {
      if (1 === arguments.length) {
        var t = arguments[0],
            e = t.get(0).getFactory(),
            n = e.buildGeometry(t),
            i = n.buffer(0);return i;
      }if (2 === arguments.length) {
        var r = arguments[0],
            s = arguments[1],
            e = r.getFactory(),
            n = e.createGeometryCollection([r, s]),
            i = n.buffer(0);return i;
      }
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return us;
    } }), us.restrictToPolygons = function (t) {
    if (R(t, Rt)) return t;var e = pr.getPolygons(t);return 1 === e.size() ? e.get(0) : t.getFactory().createMultiPolygon(ie.toPolygonArray(e));
  }, us.getGeometry = function (t, e) {
    return e >= t.size() ? null : t.get(e);
  }, us.union = function (t) {
    var e = new us(t);return e.union();
  }, us.STRTREE_NODE_CAPACITY = 4, e(ls.prototype, { unionNoOpt: function (t) {
      var e = this.geomFact.createPoint();return si.overlayOp(t, e, ii.UNION);
    }, unionWithNull: function (t, e) {
      return null === t && null === e ? null : null === e ? t : null === t ? e : t.union(e);
    }, extract: function () {
      if (R(arguments[0], v)) for (var t = arguments[0], e = t.iterator(); e.hasNext();) {
        var n = e.next();this.extract(n);
      } else if (arguments[0] instanceof B) {
        var i = arguments[0];null === this.geomFact && (this.geomFact = i.getFactory()), as.extract(i, B.SORTINDEX_POLYGON, this.polygons), as.extract(i, B.SORTINDEX_LINESTRING, this.lines), as.extract(i, B.SORTINDEX_POINT, this.points);
      }
    }, union: function t() {
      if (null === this.geomFact) return null;var e = null;if (this.points.size() > 0) {
        var n = this.geomFact.buildGeometry(this.points);e = this.unionNoOpt(n);
      }var i = null;if (this.lines.size() > 0) {
        var r = this.geomFact.buildGeometry(this.lines);i = this.unionNoOpt(r);
      }var s = null;this.polygons.size() > 0 && (s = us.union(this.polygons));var o = this.unionWithNull(i, s),
          t = null;return t = null === e ? o : null === o ? e : os.union(e, o), null === t ? this.geomFact.createGeometryCollection() : t;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return ls;
    } }), ls.union = function () {
    if (1 === arguments.length) {
      if (R(arguments[0], v)) {
        var t = arguments[0],
            e = new ls(t);return e.union();
      }if (arguments[0] instanceof B) {
        var n = arguments[0],
            e = new ls(n);return e.union();
      }
    } else if (2 === arguments.length) {
      var i = arguments[0],
          r = arguments[1],
          e = new ls(i, r);return e.union();
    }
  };var bo = Object.freeze({ UnaryUnionOp: ls }),
      Oo = Object.freeze({ IsValidOp: Ur, ConsistentAreaTester: Vr }),
      _o = Object.freeze({ BoundaryOp: dt, IsSimpleOp: Wi, buffer: So, distance: wo, linemerge: Lo, overlay: Ro, polygonize: To, relate: Po, union: bo, valid: Oo });h(hs, _t.CoordinateOperation), e(hs.prototype, { editCoordinates: function (t, e) {
      if (0 === t.length) return null;for (var n = new Array(t.length).fill(null), i = 0; i < t.length; i++) {
        var r = new g(t[i]);this.targetPM.makePrecise(r), n[i] = r;
      }var s = new N(n, !1),
          o = s.toCoordinateArray(),
          a = 0;e instanceof St && (a = 2), e instanceof bt && (a = 4);var u = n;return this.removeCollapsed && (u = null), o.length < a ? u : o;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return hs;
    } }), e(cs.prototype, { fixPolygonalTopology: function (t) {
      var e = t;this.changePrecisionModel || (e = this.changePM(t, this.targetPM));var n = e.buffer(0),
          i = n;return this.changePrecisionModel || (i = this.changePM(n, t.getPrecisionModel())), i;
    }, reducePointwise: function (t) {
      var e = null;if (this.changePrecisionModel) {
        var n = this.createFactory(t.getFactory(), this.targetPM);e = new _t(n);
      } else e = new _t();var i = this.removeCollapsed;t.getDimension() >= 2 && (i = !0);var r = e.edit(t, new hs(this.targetPM, i));return r;
    }, changePM: function (t, e) {
      var n = this.createEditor(t.getFactory(), e);return n.edit(t, new _t.NoOpGeometryOperation());
    }, setRemoveCollapsedComponents: function (t) {
      this.removeCollapsed = t;
    }, createFactory: function (t, e) {
      var n = new ie(e, t.getSRID(), t.getCoordinateSequenceFactory());return n;
    }, setChangePrecisionModel: function (t) {
      this.changePrecisionModel = t;
    }, reduce: function (t) {
      var e = this.reducePointwise(t);return this.isPointwise ? e : R(e, Rt) ? e.isValid() ? e : this.fixPolygonalTopology(e) : e;
    }, setPointwise: function (t) {
      this.isPointwise = t;
    }, createEditor: function (t, e) {
      if (t.getPrecisionModel() === e) return new _t();var n = this.createFactory(t, e),
          i = new _t(n);return i;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return cs;
    } }), cs.reduce = function (t, e) {
    var n = new cs(e);return n.reduce(t);
  }, cs.reducePointwise = function (t, e) {
    var n = new cs(e);return n.setPointwise(!0), n.reduce(t);
  };var Mo = Object.freeze({ GeometryPrecisionReducer: cs });e(fs.prototype, { simplifySection: function (t, e) {
      if (t + 1 === e) return null;this.seg.p0 = this.pts[t], this.seg.p1 = this.pts[e];for (var n = -1, i = t, r = t + 1; r < e; r++) {
        var s = this.seg.distance(this.pts[r]);s > n && (n = s, i = r);
      }if (n <= this.distanceTolerance) for (var r = t + 1; r < e; r++) this.usePt[r] = !1;else this.simplifySection(t, i), this.simplifySection(i, e);
    }, setDistanceTolerance: function (t) {
      this.distanceTolerance = t;
    }, simplify: function () {
      this.usePt = new Array(this.pts.length).fill(null);for (var t = 0; t < this.pts.length; t++) this.usePt[t] = !0;this.simplifySection(0, this.pts.length - 1);for (var e = new N(), t = 0; t < this.pts.length; t++) this.usePt[t] && e.add(new g(this.pts[t]));return e.toCoordinateArray();
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return fs;
    } }), fs.simplify = function (t, e) {
    var n = new fs(t);return n.setDistanceTolerance(e), n.simplify();
  }, e(gs.prototype, { setEnsureValid: function (t) {
      this.isEnsureValidTopology = t;
    }, getResultGeometry: function () {
      return this.inputGeom.isEmpty() ? this.inputGeom.copy() : new ds(this.isEnsureValidTopology, this.distanceTolerance).transform(this.inputGeom);
    }, setDistanceTolerance: function (t) {
      if (t < 0) throw new i("Tolerance must be non-negative");this.distanceTolerance = t;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return gs;
    } }), gs.simplify = function (t, e) {
    var n = new gs(t);return n.setDistanceTolerance(e), n.getResultGeometry();
  }, h(ds, xe), e(ds.prototype, { transformPolygon: function (t, e) {
      if (t.isEmpty()) return null;var n = xe.prototype.transformPolygon.call(this, t, e);return e instanceof Ot ? n : this.createValidArea(n);
    }, createValidArea: function (t) {
      return this.isEnsureValidTopology ? t.buffer(0) : t;
    }, transformCoordinates: function (t, e) {
      var n = t.toCoordinateArray(),
          i = null;return i = 0 === n.length ? new Array(0).fill(null) : fs.simplify(n, this.distanceTolerance), this.factory.getCoordinateSequenceFactory().create(i);
    }, transformMultiPolygon: function (t, e) {
      var n = xe.prototype.transformMultiPolygon.call(this, t, e);return this.createValidArea(n);
    }, transformLinearRing: function (t, e) {
      var n = e instanceof Tt,
          i = xe.prototype.transformLinearRing.call(this, t, e);return !n || i instanceof bt ? i : null;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return ds;
    } }), gs.DPTransformer = ds, h(ps, ce), e(ps.prototype, { getIndex: function () {
      return this.index;
    }, getParent: function () {
      return this.parent;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return ps;
    } }), e(vs.prototype, { addToResult: function (t) {
      this.resultSegs.add(t);
    }, asLineString: function () {
      return this.parentLine.getFactory().createLineString(vs.extractCoordinates(this.resultSegs));
    }, getResultSize: function () {
      var t = this.resultSegs.size();return 0 === t ? 0 : t + 1;
    }, getParent: function () {
      return this.parentLine;
    }, getSegment: function (t) {
      return this.segs[t];
    }, getParentCoordinates: function () {
      return this.parentLine.getCoordinates();
    }, getMinimumSize: function () {
      return this.minimumSize;
    }, asLinearRing: function () {
      return this.parentLine.getFactory().createLinearRing(vs.extractCoordinates(this.resultSegs));
    }, getSegments: function () {
      return this.segs;
    }, init: function () {
      var t = this.parentLine.getCoordinates();this.segs = new Array(t.length - 1).fill(null);for (var e = 0; e < t.length - 1; e++) {
        var n = new ps(t[e], t[e + 1], this.parentLine, e);this.segs[e] = n;
      }
    }, getResultCoordinates: function () {
      return vs.extractCoordinates(this.resultSegs);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return vs;
    } }), vs.extractCoordinates = function (t) {
    for (var e = new Array(t.size() + 1).fill(null), n = null, i = 0; i < t.size(); i++) n = t.get(i), e[i] = n.p0;return e[e.length - 1] = n.p1, e;
  }, e(ms.prototype, { remove: function (t) {
      this.index.remove(new C(t.p0, t.p1), t);
    }, add: function () {
      if (arguments[0] instanceof vs) for (var t = arguments[0], e = t.getSegments(), n = 0; n < e.length; n++) {
        var i = e[n];this.add(i);
      } else if (arguments[0] instanceof ce) {
        var r = arguments[0];this.index.insert(new C(r.p0, r.p1), r);
      }
    }, query: function (t) {
      var e = new C(t.p0, t.p1),
          n = new ys(t);this.index.query(e, n);var i = n.getItems();return i;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return ms;
    } }), e(ys.prototype, { visitItem: function (t) {
      var e = t;C.intersects(e.p0, e.p1, this.querySeg.p0, this.querySeg.p1) && this.items.add(t);
    }, getItems: function () {
      return this.items;
    }, interfaces_: function () {
      return [Ae];
    }, getClass: function () {
      return ys;
    } }), e(xs.prototype, { flatten: function (t, e) {
      var n = this.linePts[t],
          i = this.linePts[e],
          r = new ce(n, i);return this.remove(this.line, t, e), this.outputIndex.add(r), r;
    }, hasBadIntersection: function (t, e, n) {
      return !!this.hasBadOutputIntersection(n) || !!this.hasBadInputIntersection(t, e, n);
    }, setDistanceTolerance: function (t) {
      this.distanceTolerance = t;
    }, simplifySection: function (t, e, n) {
      n += 1;var i = new Array(2).fill(null);if (t + 1 === e) {
        var r = this.line.getSegment(t);return this.line.addToResult(r), null;
      }var s = !0;if (this.line.getResultSize() < this.line.getMinimumSize()) {
        var o = n + 1;o < this.line.getMinimumSize() && (s = !1);
      }var a = new Array(1).fill(null),
          u = this.findFurthestPoint(this.linePts, t, e, a);a[0] > this.distanceTolerance && (s = !1);var l = new ce();if (l.p0 = this.linePts[t], l.p1 = this.linePts[e], i[0] = t, i[1] = e, this.hasBadIntersection(this.line, i, l) && (s = !1), s) {
        var r = this.flatten(t, e);return this.line.addToResult(r), null;
      }this.simplifySection(t, u, n), this.simplifySection(u, e, n);
    }, hasBadOutputIntersection: function (t) {
      for (var e = this.outputIndex.query(t), n = e.iterator(); n.hasNext();) {
        var i = n.next();if (this.hasInteriorIntersection(i, t)) return !0;
      }return !1;
    }, findFurthestPoint: function (t, e, n, i) {
      var r = new ce();r.p0 = t[e], r.p1 = t[n];for (var s = -1, o = e, a = e + 1; a < n; a++) {
        var u = t[a],
            l = r.distance(u);l > s && (s = l, o = a);
      }return i[0] = s, o;
    }, simplify: function (t) {
      this.line = t, this.linePts = t.getParentCoordinates(), this.simplifySection(0, this.linePts.length - 1, 0);
    }, remove: function (t, e, n) {
      for (var i = e; i < n; i++) {
        var r = t.getSegment(i);this.inputIndex.remove(r);
      }
    }, hasInteriorIntersection: function (t, e) {
      return this.li.computeIntersection(t.p0, t.p1, e.p0, e.p1), this.li.isInteriorIntersection();
    }, hasBadInputIntersection: function (t, e, n) {
      for (var i = this.inputIndex.query(n), r = i.iterator(); r.hasNext();) {
        var s = r.next();if (this.hasInteriorIntersection(s, n)) {
          if (xs.isInLineSection(t, e, s)) continue;return !0;
        }
      }return !1;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return xs;
    } }), xs.isInLineSection = function (t, e, n) {
    if (n.getParent() !== t.getParent()) return !1;var i = n.getIndex();return i >= e[0] && i < e[1];
  }, e(Es.prototype, { setDistanceTolerance: function (t) {
      this.distanceTolerance = t;
    }, simplify: function (t) {
      for (var e = t.iterator(); e.hasNext();) this.inputIndex.add(e.next());for (var e = t.iterator(); e.hasNext();) {
        var n = new xs(this.inputIndex, this.outputIndex);n.setDistanceTolerance(this.distanceTolerance), n.simplify(e.next());
      }
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Es;
    } }), e(Is.prototype, { getResultGeometry: function () {
      if (this.inputGeom.isEmpty()) return this.inputGeom.copy();this.linestringMap = new te(), this.inputGeom.apply(new Cs(this)), this.lineSimplifier.simplify(this.linestringMap.values());var t = new Ns(this.linestringMap).transform(this.inputGeom);return t;
    }, setDistanceTolerance: function (t) {
      if (t < 0) throw new i("Tolerance must be non-negative");this.lineSimplifier.setDistanceTolerance(t);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Is;
    } }), Is.simplify = function (t, e) {
    var n = new Is(t);return n.setDistanceTolerance(e), n.getResultGeometry();
  }, h(Ns, xe), e(Ns.prototype, { transformCoordinates: function (t, e) {
      if (0 === t.size()) return null;if (e instanceof St) {
        var n = this.linestringMap.get(e);return this.createCoordinateSequence(n.getResultCoordinates());
      }return xe.prototype.transformCoordinates.call(this, t, e);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Ns;
    } }), e(Cs.prototype, { filter: function (t) {
      if (t instanceof St) {
        var e = t;if (e.isEmpty()) return null;var n = e.isClosed() ? 4 : 2,
            i = new vs(e, n);this.tps.linestringMap.put(e, i);
      }
    }, interfaces_: function () {
      return [q];
    }, getClass: function () {
      return Cs;
    } }), Is.LineStringTransformer = Ns, Is.LineStringMapBuilderFilter = Cs;var Do = Object.freeze({ DouglasPeuckerSimplifier: gs, TopologyPreservingSimplifier: Is });e(Ss.prototype, { splitAt: function () {
      if (1 === arguments.length) {
        var t = arguments[0],
            e = this.minimumLen / this.segLen;if (t.distance(this.seg.p0) < this.minimumLen) return this.splitPt = this.seg.pointAlong(e), null;if (t.distance(this.seg.p1) < this.minimumLen) return this.splitPt = Ss.pointAlongReverse(this.seg, e), null;this.splitPt = t;
      } else if (2 === arguments.length) {
        var n = arguments[0],
            i = arguments[1],
            r = this.getConstrainedLength(n),
            s = r / this.segLen;i.equals2D(this.seg.p0) ? this.splitPt = this.seg.pointAlong(s) : this.splitPt = Ss.pointAlongReverse(this.seg, s);
      }
    }, setMinimumLength: function (t) {
      this.minimumLen = t;
    }, getConstrainedLength: function (t) {
      return t < this.minimumLen ? this.minimumLen : t;
    }, getSplitPoint: function () {
      return this.splitPt;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Ss;
    } }), Ss.pointAlongReverse = function (t, e) {
    var n = new g();return n.x = t.p1.x - e * (t.p1.x - t.p0.x), n.y = t.p1.y - e * (t.p1.y - t.p0.y), n;
  }, e(ws.prototype, { findSplitPoint: function (t, e) {}, interfaces_: function () {
      return [];
    }, getClass: function () {
      return ws;
    } }), e(Ls.prototype, { findSplitPoint: function (t, e) {
      var n = t.getLineSegment(),
          i = n.getLength(),
          r = i / 2,
          s = new Ss(n),
          o = Ls.projectedSplitPoint(t, e),
          a = 2 * o.distance(e) * .8,
          u = a;return u > r && (u = r), s.setMinimumLength(u), s.splitAt(o), s.getSplitPoint();
    }, interfaces_: function () {
      return [ws];
    }, getClass: function () {
      return Ls;
    } }), Ls.projectedSplitPoint = function (t, e) {
    var n = t.getLineSegment(),
        i = n.project(e);return i;
  }, e(Rs.prototype, { interfaces_: function () {
      return [];
    }, getClass: function () {
      return Rs;
    } }), Rs.triArea = function (t, e, n) {
    return (e.x - t.x) * (n.y - t.y) - (e.y - t.y) * (n.x - t.x);
  }, Rs.isInCircleDDNormalized = function (t, e, n, i) {
    var r = _.valueOf(t.x).selfSubtract(i.x),
        s = _.valueOf(t.y).selfSubtract(i.y),
        o = _.valueOf(e.x).selfSubtract(i.x),
        a = _.valueOf(e.y).selfSubtract(i.y),
        u = _.valueOf(n.x).selfSubtract(i.x),
        l = _.valueOf(n.y).selfSubtract(i.y),
        h = r.multiply(a).selfSubtract(o.multiply(s)),
        c = o.multiply(l).selfSubtract(u.multiply(a)),
        f = u.multiply(s).selfSubtract(r.multiply(l)),
        g = r.multiply(r).selfAdd(s.multiply(s)),
        d = o.multiply(o).selfAdd(a.multiply(a)),
        p = u.multiply(u).selfAdd(l.multiply(l)),
        v = g.selfMultiply(c).selfAdd(d.selfMultiply(f)).selfAdd(p.selfMultiply(h)),
        m = v.doubleValue() > 0;return m;
  }, Rs.checkRobustInCircle = function (t, e, n, i) {
    var r = Rs.isInCircleNonRobust(t, e, n, i),
        s = Rs.isInCircleDDSlow(t, e, n, i),
        o = Rs.isInCircleCC(t, e, n, i),
        a = Si.circumcentre(t, e, n);A.out.println("p radius diff a = " + Math.abs(i.distance(a) - t.distance(a)) / t.distance(a)), r === s && r === o || (A.out.println("inCircle robustness failure (double result = " + r + ", DD result = " + s + ", CC result = " + o + ")"), A.out.println(se.toLineString(new Gt([t, e, n, i]))), A.out.println("Circumcentre = " + se.toPoint(a) + " radius = " + t.distance(a)), A.out.println("p radius diff a = " + Math.abs(i.distance(a) / t.distance(a) - 1)), A.out.println("p radius diff b = " + Math.abs(i.distance(a) / e.distance(a) - 1)), A.out.println("p radius diff c = " + Math.abs(i.distance(a) / n.distance(a) - 1)), A.out.println());
  }, Rs.isInCircleDDFast = function (t, e, n, i) {
    var r = _.sqr(t.x).selfAdd(_.sqr(t.y)).selfMultiply(Rs.triAreaDDFast(e, n, i)),
        s = _.sqr(e.x).selfAdd(_.sqr(e.y)).selfMultiply(Rs.triAreaDDFast(t, n, i)),
        o = _.sqr(n.x).selfAdd(_.sqr(n.y)).selfMultiply(Rs.triAreaDDFast(t, e, i)),
        a = _.sqr(i.x).selfAdd(_.sqr(i.y)).selfMultiply(Rs.triAreaDDFast(t, e, n)),
        u = r.selfSubtract(s).selfAdd(o).selfSubtract(a),
        l = u.doubleValue() > 0;return l;
  }, Rs.isInCircleCC = function (t, e, n, i) {
    var r = Si.circumcentre(t, e, n),
        s = t.distance(r),
        o = i.distance(r) - s;return o <= 0;
  }, Rs.isInCircleNormalized = function (t, e, n, i) {
    var r = t.x - i.x,
        s = t.y - i.y,
        o = e.x - i.x,
        a = e.y - i.y,
        u = n.x - i.x,
        l = n.y - i.y,
        h = r * a - o * s,
        c = o * l - u * a,
        f = u * s - r * l,
        g = r * r + s * s,
        d = o * o + a * a,
        p = u * u + l * l,
        v = g * c + d * f + p * h;
    return v > 0;
  }, Rs.isInCircleDDSlow = function (t, e, n, i) {
    var r = _.valueOf(i.x),
        s = _.valueOf(i.y),
        o = _.valueOf(t.x),
        a = _.valueOf(t.y),
        u = _.valueOf(e.x),
        l = _.valueOf(e.y),
        h = _.valueOf(n.x),
        c = _.valueOf(n.y),
        f = o.multiply(o).add(a.multiply(a)).multiply(Rs.triAreaDDSlow(u, l, h, c, r, s)),
        g = u.multiply(u).add(l.multiply(l)).multiply(Rs.triAreaDDSlow(o, a, h, c, r, s)),
        d = h.multiply(h).add(c.multiply(c)).multiply(Rs.triAreaDDSlow(o, a, u, l, r, s)),
        p = r.multiply(r).add(s.multiply(s)).multiply(Rs.triAreaDDSlow(o, a, u, l, h, c)),
        v = f.subtract(g).add(d).subtract(p),
        m = v.doubleValue() > 0;return m;
  }, Rs.isInCircleNonRobust = function (t, e, n, i) {
    var r = (t.x * t.x + t.y * t.y) * Rs.triArea(e, n, i) - (e.x * e.x + e.y * e.y) * Rs.triArea(t, n, i) + (n.x * n.x + n.y * n.y) * Rs.triArea(t, e, i) - (i.x * i.x + i.y * i.y) * Rs.triArea(t, e, n) > 0;return r;
  }, Rs.isInCircleRobust = function (t, e, n, i) {
    return Rs.isInCircleNormalized(t, e, n, i);
  }, Rs.triAreaDDSlow = function (t, e, n, i, r, s) {
    return n.subtract(t).multiply(s.subtract(e)).subtract(i.subtract(e).multiply(r.subtract(t)));
  }, Rs.triAreaDDFast = function (t, e, n) {
    var i = _.valueOf(e.x).selfSubtract(t.x).selfMultiply(_.valueOf(n.y).selfSubtract(t.y)),
        r = _.valueOf(e.y).selfSubtract(t.y).selfMultiply(_.valueOf(n.x).selfSubtract(t.x));return i.selfSubtract(r);
  }, e(Ts.prototype, { circleCenter: function (t, e) {
      var n = new Ts(this.getX(), this.getY()),
          i = this.bisector(n, t),
          r = this.bisector(t, e),
          s = new F(i, r),
          o = null;try {
        o = new Ts(s.getX(), s.getY());
      } catch (i) {
        if (!(i instanceof w)) throw i;A.err.println("a: " + n + "  b: " + t + "  c: " + e), A.err.println(i);
      } finally {}return o;
    }, dot: function (t) {
      return this.p.x * t.getX() + this.p.y * t.getY();
    }, magn: function () {
      return Math.sqrt(this.p.x * this.p.x + this.p.y * this.p.y);
    }, getZ: function () {
      return this.p.z;
    }, bisector: function (t, e) {
      var n = e.getX() - t.getX(),
          i = e.getY() - t.getY(),
          r = new F(t.getX() + n / 2, t.getY() + i / 2, 1),
          s = new F(t.getX() - i + n / 2, t.getY() + n + i / 2, 1);return new F(r, s);
    }, equals: function () {
      if (1 === arguments.length) {
        var t = arguments[0];return this.p.x === t.getX() && this.p.y === t.getY();
      }if (2 === arguments.length) {
        var e = arguments[0],
            n = arguments[1];return this.p.distance(e.getCoordinate()) < n;
      }
    }, getCoordinate: function () {
      return this.p;
    }, isInCircle: function (t, e, n) {
      return Rs.isInCircleRobust(t.p, e.p, n.p, this.p);
    }, interpolateZValue: function (t, e, n) {
      var i = t.getX(),
          r = t.getY(),
          s = e.getX() - i,
          o = n.getX() - i,
          a = e.getY() - r,
          u = n.getY() - r,
          l = s * u - o * a,
          h = this.getX() - i,
          c = this.getY() - r,
          f = (u * h - o * c) / l,
          g = (-a * h + s * c) / l,
          d = t.getZ() + f * (e.getZ() - t.getZ()) + g * (n.getZ() - t.getZ());return d;
    }, midPoint: function (t) {
      var e = (this.p.x + t.getX()) / 2,
          n = (this.p.y + t.getY()) / 2,
          i = (this.p.z + t.getZ()) / 2;return new Ts(e, n, i);
    }, rightOf: function (t) {
      return this.isCCW(t.dest(), t.orig());
    }, isCCW: function (t, e) {
      return (t.p.x - this.p.x) * (e.p.y - this.p.y) - (t.p.y - this.p.y) * (e.p.x - this.p.x) > 0;
    }, getX: function () {
      return this.p.x;
    }, crossProduct: function (t) {
      return this.p.x * t.getY() - this.p.y * t.getX();
    }, setZ: function (t) {
      this.p.z = t;
    }, times: function (t) {
      return new Ts(t * this.p.x, t * this.p.y);
    }, cross: function () {
      return new Ts(this.p.y, -this.p.x);
    }, leftOf: function (t) {
      return this.isCCW(t.orig(), t.dest());
    }, toString: function () {
      return "POINT (" + this.p.x + " " + this.p.y + ")";
    }, sub: function (t) {
      return new Ts(this.p.x - t.getX(), this.p.y - t.getY());
    }, getY: function () {
      return this.p.y;
    }, classify: function (t, e) {
      var n = this,
          i = e.sub(t),
          r = n.sub(t),
          s = i.crossProduct(r);return s > 0 ? Ts.LEFT : s < 0 ? Ts.RIGHT : i.getX() * r.getX() < 0 || i.getY() * r.getY() < 0 ? Ts.BEHIND : i.magn() < r.magn() ? Ts.BEYOND : t.equals(n) ? Ts.ORIGIN : e.equals(n) ? Ts.DESTINATION : Ts.BETWEEN;
    }, sum: function (t) {
      return new Ts(this.p.x + t.getX(), this.p.y + t.getY());
    }, distance: function (t, e) {
      return Math.sqrt(Math.pow(e.getX() - t.getX(), 2) + Math.pow(e.getY() - t.getY(), 2));
    }, circumRadiusRatio: function (t, e) {
      var n = this.circleCenter(t, e),
          i = this.distance(n, t),
          r = this.distance(this, t),
          s = this.distance(t, e);return s < r && (r = s), s = this.distance(e, this), s < r && (r = s), i / r;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Ts;
    } }), Ts.interpolateZ = function () {
    if (3 === arguments.length) {
      var t = arguments[0],
          e = arguments[1],
          n = arguments[2],
          i = e.distance(n),
          r = t.distance(e),
          s = n.z - e.z,
          o = e.z + s * (r / i);return o;
    }if (4 === arguments.length) {
      var a = arguments[0],
          u = arguments[1],
          l = arguments[2],
          h = arguments[3],
          c = u.x,
          f = u.y,
          g = l.x - c,
          d = h.x - c,
          p = l.y - f,
          v = h.y - f,
          m = g * v - d * p,
          y = a.x - c,
          x = a.y - f,
          E = (v * y - d * x) / m,
          I = (-p * y + g * x) / m,
          N = u.z + E * (l.z - u.z) + I * (h.z - u.z);return N;
    }
  }, Ts.LEFT = 0, Ts.RIGHT = 1, Ts.BEYOND = 2, Ts.BEHIND = 3, Ts.BETWEEN = 4, Ts.ORIGIN = 5, Ts.DESTINATION = 6, h(Ps, Ts), e(Ps.prototype, { getConstraint: function () {
      return this.constraint;
    }, setOnConstraint: function (t) {
      this._isOnConstraint = t;
    }, merge: function (t) {
      t._isOnConstraint && (this._isOnConstraint = !0, this.constraint = t.constraint);
    }, isOnConstraint: function () {
      return this._isOnConstraint;
    }, setConstraint: function (t) {
      this._isOnConstraint = !0, this.constraint = t;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Ps;
    } }), e(bs.prototype, { equalsNonOriented: function (t) {
      return !!this.equalsOriented(t) || !!this.equalsOriented(t.sym());
    }, toLineSegment: function () {
      return new ce(this.vertex.getCoordinate(), this.dest().getCoordinate());
    }, dest: function () {
      return this.sym().orig();
    }, oNext: function () {
      return this.next;
    }, equalsOriented: function (t) {
      return !(!this.orig().getCoordinate().equals2D(t.orig().getCoordinate()) || !this.dest().getCoordinate().equals2D(t.dest().getCoordinate()));
    }, dNext: function () {
      return this.sym().oNext().sym();
    }, lPrev: function () {
      return this.next.sym();
    }, rPrev: function () {
      return this.sym().oNext();
    }, rot: function () {
      return this._rot;
    }, oPrev: function () {
      return this._rot.next._rot;
    }, sym: function () {
      return this._rot._rot;
    }, setOrig: function (t) {
      this.vertex = t;
    }, lNext: function () {
      return this.invRot().oNext().rot();
    }, getLength: function () {
      return this.orig().getCoordinate().distance(this.dest().getCoordinate());
    }, invRot: function () {
      return this._rot.sym();
    }, setDest: function (t) {
      this.sym().setOrig(t);
    }, setData: function (t) {
      this.data = t;
    }, getData: function () {
      return this.data;
    }, delete: function () {
      this._rot = null;
    }, orig: function () {
      return this.vertex;
    }, rNext: function () {
      return this._rot.next.invRot();
    }, toString: function () {
      var t = this.vertex.getCoordinate(),
          e = this.dest().getCoordinate();return se.toLineString(t, e);
    }, isLive: function () {
      return null !== this._rot;
    }, getPrimary: function () {
      return this.orig().getCoordinate().compareTo(this.dest().getCoordinate()) <= 0 ? this : this.sym();
    }, dPrev: function () {
      return this.invRot().oNext().invRot();
    }, setNext: function (t) {
      this.next = t;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return bs;
    } }), bs.makeEdge = function (t, e) {
    var n = new bs(),
        i = new bs(),
        r = new bs(),
        s = new bs();n._rot = i, i._rot = r, r._rot = s, s._rot = n, n.setNext(n), i.setNext(s), r.setNext(r), s.setNext(i);var o = n;return o.setOrig(t), o.setDest(e), o;
  }, bs.swap = function (t) {
    var e = t.oPrev(),
        n = t.sym().oPrev();bs.splice(t, e), bs.splice(t.sym(), n), bs.splice(t, e.lNext()), bs.splice(t.sym(), n.lNext()), t.setOrig(e.dest()), t.setDest(n.dest());
  }, bs.splice = function (t, e) {
    var n = t.oNext().rot(),
        i = e.oNext().rot(),
        r = e.oNext(),
        s = t.oNext(),
        o = i.oNext(),
        a = n.oNext();t.setNext(r), e.setNext(s), n.setNext(o), i.setNext(a);
  }, bs.connect = function (t, e) {
    var n = bs.makeEdge(t.dest(), e.orig());return bs.splice(n, t.lNext()), bs.splice(n.sym(), e), n;
  }, e(Os.prototype, { insertSite: function (t) {
      var e = this.subdiv.locate(t);if (this.subdiv.isVertexOfEdge(e, t)) return e;this.subdiv.isOnEdge(e, t.getCoordinate()) && (e = e.oPrev(), this.subdiv.delete(e.oNext()));var n = this.subdiv.makeEdge(e.orig(), t);bs.splice(n, e);var i = n;do n = this.subdiv.connect(e, n.sym()), e = n.oPrev(); while (e.lNext() !== i);for (;;) {
        var r = e.oPrev();if (r.dest().rightOf(e) && t.isInCircle(e.orig(), r.dest(), e.dest())) bs.swap(e), e = e.oPrev();else {
          if (e.oNext() === i) return n;e = e.oNext().lPrev();
        }
      }
    }, insertSites: function (t) {
      for (var e = t.iterator(); e.hasNext();) {
        var n = e.next();this.insertSite(n);
      }
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Os;
    } }), e(_s.prototype, { locate: function (t) {}, interfaces_: function () {
      return [];
    }, getClass: function () {
      return _s;
    } }), e(Ms.prototype, { init: function () {
      this.lastEdge = this.findEdge();
    }, locate: function (t) {
      this.lastEdge.isLive() || this.init();var e = this.subdiv.locateFromEdge(t, this.lastEdge);return this.lastEdge = e, e;
    }, findEdge: function () {
      var t = this.subdiv.getEdges();return t.iterator().next();
    }, interfaces_: function () {
      return [_s];
    }, getClass: function () {
      return Ms;
    } }), h(Ds, l), e(Ds.prototype, { getSegment: function () {
      return this.seg;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Ds;
    } }), Ds.msgWithSpatial = function (t, e) {
    return null !== e ? t + " [ " + e + " ]" : t;
  }, e(As.prototype, { visit: function (t) {}, interfaces_: function () {
      return [];
    }, getClass: function () {
      return As;
    } }), e(Fs.prototype, { getTriangleVertices: function (t) {
      var e = new Bs();return this.visitTriangles(e, t), e.getTriangleVertices();
    }, isFrameVertex: function (t) {
      return !!t.equals(this.frameVertex[0]) || !!t.equals(this.frameVertex[1]) || !!t.equals(this.frameVertex[2]);
    }, isVertexOfEdge: function (t, e) {
      return !(!e.equals(t.orig(), this.tolerance) && !e.equals(t.dest(), this.tolerance));
    }, connect: function (t, e) {
      var n = bs.connect(t, e);return this.quadEdges.add(n), n;
    }, getVoronoiCellPolygon: function (t, e) {
      var n = new I(),
          i = t;do {
        var r = t.rot().orig().getCoordinate();n.add(r), t = t.oPrev();
      } while (t !== i);var s = new N();s.addAll(n, !1), s.closeRing(), s.size() < 4 && (A.out.println(s), s.add(s.get(s.size() - 1), !0));var o = s.toCoordinateArray(),
          a = e.createPolygon(e.createLinearRing(o), null),
          u = i.orig();return a.setUserData(u.getCoordinate()), a;
    }, setLocator: function (t) {
      this.locator = t;
    }, initSubdiv: function () {
      var t = this.makeEdge(this.frameVertex[0], this.frameVertex[1]),
          e = this.makeEdge(this.frameVertex[1], this.frameVertex[2]);bs.splice(t.sym(), e);var n = this.makeEdge(this.frameVertex[2], this.frameVertex[0]);return bs.splice(e.sym(), n), bs.splice(n.sym(), t), t;
    }, isFrameBorderEdge: function (t) {
      var e = new Array(3).fill(null);Fs.getTriangleEdges(t, e);var n = new Array(3).fill(null);Fs.getTriangleEdges(t.sym(), n);var i = t.lNext().dest();if (this.isFrameVertex(i)) return !0;var r = t.sym().lNext().dest();return !!this.isFrameVertex(r);
    }, makeEdge: function (t, e) {
      var n = bs.makeEdge(t, e);return this.quadEdges.add(n), n;
    }, visitTriangles: function (t, e) {
      this.visitedKey++;var n = new pe();n.push(this.startingEdge);for (var i = new J(); !n.empty();) {
        var r = n.pop();if (!i.contains(r)) {
          var s = this.fetchTriangleToVisit(r, n, e, i);null !== s && t.visit(s);
        }
      }
    }, isFrameEdge: function (t) {
      return !(!this.isFrameVertex(t.orig()) && !this.isFrameVertex(t.dest()));
    }, isOnEdge: function (t, e) {
      this.seg.setCoordinates(t.orig().getCoordinate(), t.dest().getCoordinate());var n = this.seg.distance(e);return n < this.edgeCoincidenceTolerance;
    }, getEnvelope: function () {
      return new C(this.frameEnv);
    }, createFrame: function (t) {
      var e = t.getWidth(),
          n = t.getHeight(),
          i = 0;i = e > n ? 10 * e : 10 * n, this.frameVertex[0] = new Ts((t.getMaxX() + t.getMinX()) / 2, t.getMaxY() + i), this.frameVertex[1] = new Ts(t.getMinX() - i, t.getMinY() - i), this.frameVertex[2] = new Ts(t.getMaxX() + i, t.getMinY() - i), this.frameEnv = new C(this.frameVertex[0].getCoordinate(), this.frameVertex[1].getCoordinate()), this.frameEnv.expandToInclude(this.frameVertex[2].getCoordinate());
    }, getTriangleCoordinates: function (t) {
      var e = new zs();return this.visitTriangles(e, t), e.getTriangles();
    }, getVertices: function (t) {
      for (var e = new J(), n = this.quadEdges.iterator(); n.hasNext();) {
        var i = n.next(),
            r = i.orig();!t && this.isFrameVertex(r) || e.add(r);var s = i.dest();!t && this.isFrameVertex(s) || e.add(s);
      }return e;
    }, fetchTriangleToVisit: function (t, e, n, i) {
      var r = t,
          s = 0,
          o = !1;do {
        this.triEdges[s] = r, this.isFrameEdge(r) && (o = !0);var a = r.sym();i.contains(a) || e.push(a), i.add(r), s++, r = r.lNext();
      } while (r !== t);return o && !n ? null : this.triEdges;
    }, getEdges: function () {
      if (0 === arguments.length) return this.quadEdges;if (1 === arguments.length) {
        for (var t = arguments[0], e = this.getPrimaryEdges(!1), n = new Array(e.size()).fill(null), i = 0, r = e.iterator(); r.hasNext();) {
          var s = r.next();n[i++] = t.createLineString([s.orig().getCoordinate(), s.dest().getCoordinate()]);
        }return t.createMultiLineString(n);
      }
    }, getVertexUniqueEdges: function (t) {
      for (var e = new I(), n = new J(), i = this.quadEdges.iterator(); i.hasNext();) {
        var r = i.next(),
            s = r.orig();n.contains(s) || (n.add(s), !t && this.isFrameVertex(s) || e.add(r));var o = r.sym(),
            a = o.orig();n.contains(a) || (n.add(a), !t && this.isFrameVertex(a) || e.add(o));
      }return e;
    }, getTriangleEdges: function (t) {
      var e = new qs();return this.visitTriangles(e, t), e.getTriangleEdges();
    }, getPrimaryEdges: function (t) {
      this.visitedKey++;var e = new I(),
          n = new pe();n.push(this.startingEdge);for (var i = new J(); !n.empty();) {
        var r = n.pop();if (!i.contains(r)) {
          var s = r.getPrimary();!t && this.isFrameEdge(s) || e.add(s), n.push(r.oNext()), n.push(r.sym().oNext()), i.add(r), i.add(r.sym());
        }
      }return e;
    }, delete: function (t) {
      bs.splice(t, t.oPrev()), bs.splice(t.sym(), t.sym().oPrev());var e = t.sym(),
          n = t.rot(),
          i = t.rot().sym();this.quadEdges.remove(t), this.quadEdges.remove(e), this.quadEdges.remove(n), this.quadEdges.remove(i), t.delete(), e.delete(), n.delete(), i.delete();
    }, locateFromEdge: function (t, e) {
      for (var n = 0, i = this.quadEdges.size(), r = e;;) {
        if (n++, n > i) throw new Ds(r.toLineSegment());if (t.equals(r.orig()) || t.equals(r.dest())) break;if (t.rightOf(r)) r = r.sym();else if (t.rightOf(r.oNext())) {
          if (t.rightOf(r.dPrev())) break;r = r.dPrev();
        } else r = r.oNext();
      }return r;
    }, getTolerance: function () {
      return this.tolerance;
    }, getVoronoiCellPolygons: function (t) {
      this.visitTriangles(new Gs(), !0);for (var e = new I(), n = this.getVertexUniqueEdges(!1), i = n.iterator(); i.hasNext();) {
        var r = i.next();e.add(this.getVoronoiCellPolygon(r, t));
      }return e;
    }, getVoronoiDiagram: function (t) {
      var e = this.getVoronoiCellPolygons(t);return t.createGeometryCollection(ie.toGeometryArray(e));
    }, getTriangles: function (t) {
      for (var e = this.getTriangleCoordinates(!1), n = new Array(e.size()).fill(null), i = 0, r = e.iterator(); r.hasNext();) {
        var s = r.next();n[i++] = t.createPolygon(t.createLinearRing(s), null);
      }return t.createGeometryCollection(n);
    }, insertSite: function (t) {
      var e = this.locate(t);if (t.equals(e.orig(), this.tolerance) || t.equals(e.dest(), this.tolerance)) return e;var n = this.makeEdge(e.orig(), t);bs.splice(n, e);var i = n;do n = this.connect(e, n.sym()), e = n.oPrev(); while (e.lNext() !== i);return i;
    }, locate: function () {
      if (1 === arguments.length) {
        if (arguments[0] instanceof Ts) {
          var t = arguments[0];return this.locator.locate(t);
        }if (arguments[0] instanceof g) {
          var e = arguments[0];return this.locator.locate(new Ts(e));
        }
      } else if (2 === arguments.length) {
        var n = arguments[0],
            i = arguments[1],
            r = this.locator.locate(new Ts(n));if (null === r) return null;var s = r;r.dest().getCoordinate().equals2D(n) && (s = r.sym());var o = s;do {
          if (o.dest().getCoordinate().equals2D(i)) return o;o = o.oNext();
        } while (o !== s);return null;
      }
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Fs;
    } }), Fs.getTriangleEdges = function (t, e) {
    if (e[0] = t, e[1] = e[0].lNext(), e[2] = e[1].lNext(), e[2].lNext() !== e[0]) throw new i("Edges do not form a triangle");
  }, e(Gs.prototype, { visit: function (t) {
      for (var e = t[0].orig().getCoordinate(), n = t[1].orig().getCoordinate(), i = t[2].orig().getCoordinate(), r = Si.circumcentre(e, n, i), s = new Ts(r), o = 0; o < 3; o++) t[o].rot().setOrig(s);
    }, interfaces_: function () {
      return [As];
    }, getClass: function () {
      return Gs;
    } }), e(qs.prototype, { getTriangleEdges: function () {
      return this.triList;
    }, visit: function (t) {
      this.triList.add(t.clone());
    }, interfaces_: function () {
      return [As];
    }, getClass: function () {
      return qs;
    } }), e(Bs.prototype, { visit: function (t) {
      this.triList.add([t[0].orig(), t[1].orig(), t[2].orig()]);
    }, getTriangleVertices: function () {
      return this.triList;
    }, interfaces_: function () {
      return [As];
    }, getClass: function () {
      return Bs;
    } }), e(zs.prototype, { checkTriangleSize: function (t) {
      var e = "";t.length >= 2 ? e = se.toLineString(t[0], t[1]) : t.length >= 1 && (e = se.toPoint(t[0]));
    }, visit: function (t) {
      this.coordList.clear();for (var e = 0; e < 3; e++) {
        var n = t[e].orig();this.coordList.add(n.getCoordinate());
      }if (this.coordList.size() > 0) {
        this.coordList.closeRing();var i = this.coordList.toCoordinateArray();if (4 !== i.length) return null;this.triCoords.add(i);
      }
    }, getTriangles: function () {
      return this.triCoords;
    }, interfaces_: function () {
      return [As];
    }, getClass: function () {
      return zs;
    } }), Fs.TriangleCircumcentreVisitor = Gs, Fs.TriangleEdgesListVisitor = qs, Fs.TriangleVertexListVisitor = Bs, Fs.TriangleCoordinatesVisitor = zs, Fs.EDGE_COINCIDENCE_TOL_FACTOR = 1e3, e(Vs.prototype, { getLineSegment: function () {
      return this.ls;
    }, getEndZ: function () {
      var t = this.ls.getCoordinate(1);return t.z;
    }, getStartZ: function () {
      var t = this.ls.getCoordinate(0);return t.z;
    }, intersection: function (t) {
      return this.ls.intersection(t.getLineSegment());
    }, getStart: function () {
      return this.ls.getCoordinate(0);
    }, getEnd: function () {
      return this.ls.getCoordinate(1);
    }, getEndY: function () {
      var t = this.ls.getCoordinate(1);return t.y;
    }, getStartX: function () {
      var t = this.ls.getCoordinate(0);return t.x;
    }, equalsTopo: function (t) {
      return this.ls.equalsTopo(t.getLineSegment());
    }, getStartY: function () {
      var t = this.ls.getCoordinate(0);return t.y;
    }, setData: function (t) {
      this.data = t;
    }, getData: function () {
      return this.data;
    }, getEndX: function () {
      var t = this.ls.getCoordinate(1);return t.x;
    }, toString: function () {
      return this.ls.toString();
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Vs;
    } }), e(ks.prototype, { visit: function (t) {}, interfaces_: function () {
      return [];
    }, getClass: function () {
      return ks;
    } }), e(Ys.prototype, { isRepeated: function () {
      return this.count > 1;
    }, getRight: function () {
      return this.right;
    }, getCoordinate: function () {
      return this.p;
    }, setLeft: function (t) {
      this.left = t;
    }, getX: function () {
      return this.p.x;
    }, getData: function () {
      return this.data;
    }, getCount: function () {
      return this.count;
    }, getLeft: function () {
      return this.left;
    }, getY: function () {
      return this.p.y;
    }, increment: function () {
      this.count = this.count + 1;
    }, setRight: function (t) {
      this.right = t;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Ys;
    } }), e(Us.prototype, { insert: function () {
      if (1 === arguments.length) {
        var t = arguments[0];return this.insert(t, null);
      }if (2 === arguments.length) {
        var e = arguments[0],
            n = arguments[1];if (null === this.root) return this.root = new Ys(e, n), this.root;if (this.tolerance > 0) {
          var i = this.findBestMatchNode(e);if (null !== i) return i.increment(), i;
        }return this.insertExact(e, n);
      }
    }, query: function () {
      var t = arguments,
          e = this;if (1 === arguments.length) {
        var n = arguments[0],
            i = new I();return this.query(n, i), i;
      }if (2 === arguments.length) if (arguments[0] instanceof C && R(arguments[1], y)) !function () {
        var n = t[0],
            i = t[1];e.queryNode(e.root, n, !0, { interfaces_: function () {
            return [ks];
          }, visit: function (t) {
            i.add(t);
          } });
      }();else if (arguments[0] instanceof C && R(arguments[1], ks)) {
        var r = arguments[0],
            s = arguments[1];this.queryNode(this.root, r, !0, s);
      }
    }, queryNode: function (t, e, n, i) {
      if (null === t) return null;var r = null,
          s = null,
          o = null;n ? (r = e.getMinX(), s = e.getMaxX(), o = t.getX()) : (r = e.getMinY(), s = e.getMaxY(), o = t.getY());var a = r < o,
          u = o <= s;a && this.queryNode(t.getLeft(), e, !n, i), e.contains(t.getCoordinate()) && i.visit(t), u && this.queryNode(t.getRight(), e, !n, i);
    }, findBestMatchNode: function (t) {
      var e = new Xs(t, this.tolerance);return this.query(e.queryEnvelope(), e), e.getNode();
    }, isEmpty: function () {
      return null === this.root;
    }, insertExact: function (t, e) {
      for (var n = this.root, i = this.root, r = !0, s = !0; null !== n;) {
        if (null !== n) {
          var o = t.distance(n.getCoordinate()) <= this.tolerance;if (o) return n.increment(), n;
        }s = r ? t.x < n.getX() : t.y < n.getY(), i = n, n = s ? n.getLeft() : n.getRight(), r = !r;
      }this.numberOfNodes = this.numberOfNodes + 1;var a = new Ys(t, e);return s ? i.setLeft(a) : i.setRight(a), a;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Us;
    } }), Us.toCoordinates = function () {
    if (1 === arguments.length) {
      var t = arguments[0];return Us.toCoordinates(t, !1);
    }if (2 === arguments.length) {
      for (var e = arguments[0], n = arguments[1], i = new N(), r = e.iterator(); r.hasNext();) for (var s = r.next(), o = n ? s.getCount() : 1, a = 0; a < o; a++) i.add(s.getCoordinate(), !0);return i.toCoordinateArray();
    }
  }, e(Xs.prototype, { visit: function (t) {
      var e = this.p.distance(t.getCoordinate()),
          n = e <= this.tolerance;if (!n) return null;var i = !1;(null === this.matchNode || e < this.matchDist || null !== this.matchNode && e === this.matchDist && t.getCoordinate().compareTo(this.matchNode.getCoordinate()) < 1) && (i = !0), i && (this.matchNode = t, this.matchDist = e);
    }, queryEnvelope: function () {
      var t = new C(this.p);return t.expandBy(this.tolerance), t;
    }, getNode: function () {
      return this.matchNode;
    }, interfaces_: function () {
      return [ks];
    }, getClass: function () {
      return Xs;
    } }), Us.BestMatchVisitor = Xs, e(Hs.prototype, { getInitialVertices: function () {
      return this.initialVertices;
    }, getKDT: function () {
      return this.kdt;
    }, enforceConstraints: function () {
      this.addConstraintVertices();var t = 0,
          e = 0;do e = this.enforceGabriel(this.segments), t++; while (e > 0 && t < Hs.MAX_SPLIT_ITER);
    }, insertSites: function (t) {
      for (var e = t.iterator(); e.hasNext();) {
        var n = e.next();this.insertSite(n);
      }
    }, getVertexFactory: function () {
      return this.vertexFactory;
    }, getPointArray: function () {
      for (var t = new Array(this.initialVertices.size() + this.segVertices.size()).fill(null), e = 0, n = this.initialVertices.iterator(); n.hasNext();) {
        var i = n.next();t[e++] = i.getCoordinate();
      }for (var r = this.segVertices.iterator(); r.hasNext();) {
        var i = r.next();t[e++] = i.getCoordinate();
      }return t;
    }, setConstraints: function (t, e) {
      this.segments = t, this.segVertices = e;
    }, computeConvexHull: function () {
      var t = new ie(),
          e = this.getPointArray(),
          n = new me(e, t);this.convexHull = n.getConvexHull();
    }, addConstraintVertices: function () {
      this.computeConvexHull(), this.insertSites(this.segVertices);
    }, findNonGabrielPoint: function (t) {
      var e = t.getStart(),
          n = t.getEnd(),
          i = new g((e.x + n.x) / 2, (e.y + n.y) / 2),
          s = e.distance(i),
          o = new C(i);o.expandBy(s);for (var a = this.kdt.query(o), u = null, l = r.MAX_VALUE, h = a.iterator(); h.hasNext();) {
        var c = h.next(),
            f = c.getCoordinate();if (!f.equals2D(e) && !f.equals2D(n)) {
          var d = i.distance(f);if (d < s) {
            var p = d;(null === u || p < l) && (u = f, l = p);
          }
        }
      }return u;
    }, getConstraintSegments: function () {
      return this.segments;
    }, setSplitPointFinder: function (t) {
      this.splitFinder = t;
    }, getConvexHull: function () {
      return this.convexHull;
    }, getTolerance: function () {
      return this.tolerance;
    }, enforceGabriel: function (t) {
      for (var e = new I(), n = 0, i = new I(), r = t.iterator(); r.hasNext();) {
        var s = r.next(),
            o = this.findNonGabrielPoint(s);if (null !== o) {
          this.splitPt = this.splitFinder.findSplitPoint(s, o);var a = this.createVertex(this.splitPt, s),
              u = (this.insertSite(a), new Vs(s.getStartX(), s.getStartY(), s.getStartZ(), a.getX(), a.getY(), a.getZ(), s.getData())),
              l = new Vs(a.getX(), a.getY(), a.getZ(), s.getEndX(), s.getEndY(), s.getEndZ(), s.getData());e.add(u), e.add(l), i.add(s), n += 1;
        }
      }return t.removeAll(i), t.addAll(e), n;
    }, createVertex: function () {
      if (1 === arguments.length) {
        var t = arguments[0],
            e = null;return e = null !== this.vertexFactory ? this.vertexFactory.createVertex(t, null) : new Ps(t);
      }if (2 === arguments.length) {
        var n = arguments[0],
            i = arguments[1],
            e = null;return e = null !== this.vertexFactory ? this.vertexFactory.createVertex(n, i) : new Ps(n), e.setOnConstraint(!0), e;
      }
    }, getSubdivision: function () {
      return this.subdiv;
    }, computeBoundingBox: function () {
      var t = Hs.computeVertexEnvelope(this.initialVertices),
          e = Hs.computeVertexEnvelope(this.segVertices),
          n = new C(t);n.expandToInclude(e);var i = .2 * n.getWidth(),
          r = .2 * n.getHeight(),
          s = Math.max(i, r);this.computeAreaEnv = new C(n), this.computeAreaEnv.expandBy(s);
    }, setVertexFactory: function (t) {
      this.vertexFactory = t;
    }, formInitialDelaunay: function () {
      this.computeBoundingBox(), this.subdiv = new Fs(this.computeAreaEnv, this.tolerance), this.subdiv.setLocator(new Ms(this.subdiv)), this.incDel = new Os(this.subdiv), this.insertSites(this.initialVertices);
    }, insertSite: function () {
      if (arguments[0] instanceof Ps) {
        var t = arguments[0],
            e = this.kdt.insert(t.getCoordinate(), t);if (e.isRepeated()) {
          var n = e.getData();return n.merge(t), n;
        }return this.incDel.insertSite(t), t;
      }if (arguments[0] instanceof g) {
        var i = arguments[0];this.insertSite(this.createVertex(i));
      }
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Hs;
    } }), Hs.computeVertexEnvelope = function (t) {
    for (var e = new C(), n = t.iterator(); n.hasNext();) {
      var i = n.next();e.expandToInclude(i.getCoordinate());
    }return e;
  }, Hs.MAX_SPLIT_ITER = 99, e(Ws.prototype, { create: function () {
      if (null !== this.subdiv) return null;var t = Ws.envelope(this.siteCoords),
          e = Ws.toVertices(this.siteCoords);this.subdiv = new Fs(t, this.tolerance);var n = new Os(this.subdiv);n.insertSites(e);
    }, setTolerance: function (t) {
      this.tolerance = t;
    }, setSites: function () {
      if (arguments[0] instanceof B) {
        var t = arguments[0];this.siteCoords = Ws.extractUniqueCoordinates(t);
      } else if (R(arguments[0], v)) {
        var e = arguments[0];this.siteCoords = Ws.unique(H.toCoordinateArray(e));
      }
    }, getEdges: function (t) {
      return this.create(), this.subdiv.getEdges(t);
    }, getSubdivision: function () {
      return this.create(), this.subdiv;
    }, getTriangles: function (t) {
      return this.create(), this.subdiv.getTriangles(t);
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Ws;
    } }), Ws.extractUniqueCoordinates = function (t) {
    if (null === t) return new N();var e = t.getCoordinates();return Ws.unique(e);
  }, Ws.envelope = function (t) {
    for (var e = new C(), n = t.iterator(); n.hasNext();) {
      var i = n.next();e.expandToInclude(i);
    }return e;
  }, Ws.unique = function (t) {
    var e = H.copyDeep(t);ut.sort(e);var n = new N(e, !1);return n;
  }, Ws.toVertices = function (t) {
    for (var e = new I(), n = t.iterator(); n.hasNext();) {
      var i = n.next();e.add(new Ts(i));
    }return e;
  }, e(js.prototype, { createSiteVertices: function (t) {
      for (var e = new I(), n = t.iterator(); n.hasNext();) {
        var i = n.next();this.constraintVertexMap.containsKey(i) || e.add(new Ps(i));
      }return e;
    }, create: function () {
      if (null !== this.subdiv) return null;var t = Ws.envelope(this.siteCoords),
          e = new I();null !== this.constraintLines && (t.expandToInclude(this.constraintLines.getEnvelopeInternal()), this.createVertices(this.constraintLines), e = js.createConstraintSegments(this.constraintLines));var n = this.createSiteVertices(this.siteCoords),
          i = new Hs(n, this.tolerance);i.setConstraints(e, new I(this.constraintVertexMap.values())), i.formInitialDelaunay(), i.enforceConstraints(), this.subdiv = i.getSubdivision();
    }, setTolerance: function (t) {
      this.tolerance = t;
    }, setConstraints: function (t) {
      this.constraintLines = t;
    }, setSites: function (t) {
      this.siteCoords = Ws.extractUniqueCoordinates(t);
    }, getEdges: function (t) {
      return this.create(), this.subdiv.getEdges(t);
    }, getSubdivision: function () {
      return this.create(), this.subdiv;
    }, getTriangles: function (t) {
      return this.create(), this.subdiv.getTriangles(t);
    }, createVertices: function (t) {
      for (var e = t.getCoordinates(), n = 0; n < e.length; n++) {
        var i = new Ps(e[n]);this.constraintVertexMap.put(e[n], i);
      }
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return js;
    } }), js.createConstraintSegments = function () {
    if (1 === arguments.length) {
      for (var t = arguments[0], e = kn.getLines(t), n = new I(), i = e.iterator(); i.hasNext();) {
        var r = i.next();js.createConstraintSegments(r, n);
      }return n;
    }if (2 === arguments.length) for (var s = arguments[0], o = arguments[1], a = s.getCoordinates(), i = 1; i < a.length; i++) o.add(new Vs(a[i - 1], a[i]));
  }, e(Ks.prototype, { create: function () {
      if (null !== this.subdiv) return null;var t = Ws.envelope(this.siteCoords);this.diagramEnv = t;var e = Math.max(this.diagramEnv.getWidth(), this.diagramEnv.getHeight());this.diagramEnv.expandBy(e), null !== this.clipEnv && this.diagramEnv.expandToInclude(this.clipEnv);var n = Ws.toVertices(this.siteCoords);this.subdiv = new Fs(t, this.tolerance);var i = new Os(this.subdiv);i.insertSites(n);
    }, getDiagram: function (t) {
      this.create();var e = this.subdiv.getVoronoiDiagram(t);return Ks.clipGeometryCollection(e, this.diagramEnv);
    }, setTolerance: function (t) {
      this.tolerance = t;
    }, setSites: function () {
      if (arguments[0] instanceof B) {
        var t = arguments[0];this.siteCoords = Ws.extractUniqueCoordinates(t);
      } else if (R(arguments[0], v)) {
        var e = arguments[0];this.siteCoords = Ws.unique(H.toCoordinateArray(e));
      }
    }, setClipEnvelope: function (t) {
      this.clipEnv = t;
    }, getSubdivision: function () {
      return this.create(), this.subdiv;
    }, interfaces_: function () {
      return [];
    }, getClass: function () {
      return Ks;
    } }), Ks.clipGeometryCollection = function (t, e) {
    for (var n = t.getFactory().toGeometry(e), i = new I(), r = 0; r < t.getNumGeometries(); r++) {
      var s = t.getGeometryN(r),
          o = null;e.contains(s.getEnvelopeInternal()) ? o = s : e.intersects(s.getEnvelopeInternal()) && (o = n.intersection(s), o.setUserData(s.getUserData())), null === o || o.isEmpty() || i.add(o);
    }return t.getFactory().createGeometryCollection(ie.toGeometryArray(i));
  };var Ao = Object.freeze({ Vertex: Ts }),
      Fo = Object.freeze({ ConformingDelaunayTriangulationBuilder: js, DelaunayTriangulationBuilder: Ws, VoronoiDiagramBuilder: Ks, quadedge: Ao });e(Zs.prototype, { interfaces_: function () {
      return [];
    }, getClass: function () {
      return Zs;
    } }), Zs.union = function (t, e) {
    if (t.isEmpty() || e.isEmpty()) {
      if (t.isEmpty() && e.isEmpty()) return ii.createEmptyResult(ii.UNION, t, e, t.getFactory());if (t.isEmpty()) return e.copy();if (e.isEmpty()) return t.copy();
    }return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), si.overlayOp(t, e, ii.UNION);
  }, e(B.prototype, { equalsTopo: function (t) {
      return !!this.getEnvelopeInternal().equals(t.getEnvelopeInternal()) && rs.relate(this, t).isEquals(this.getDimension(), t.getDimension());
    }, union: function () {
      if (0 === arguments.length) return ls.union(this);if (1 === arguments.length) {
        var t = arguments[0];return Zs.union(this, t);
      }
    }, isValid: function () {
      return Ur.isValid(this);
    }, intersection: function (t) {
      if (this.isEmpty() || t.isEmpty()) return ii.createEmptyResult(ii.INTERSECTION, this, t, this.factory);if (this.isGeometryCollection()) {
        var e = t;return hn.map(this, { interfaces_: function () {
            return [MapOp];
          }, map: function (t) {
            return t.intersection(e);
          } });
      }return this.checkNotGeometryCollection(this), this.checkNotGeometryCollection(t), si.overlayOp(this, t, ii.INTERSECTION);
    }, covers: function (t) {
      return rs.covers(this, t);
    }, coveredBy: function (t) {
      return rs.coveredBy(this, t);
    }, touches: function (t) {
      return rs.touches(this, t);
    }, intersects: function (t) {
      return rs.intersects(this, t);
    }, within: function (t) {
      return rs.within(this, t);
    }, overlaps: function (t) {
      return rs.overlaps(this, t);
    }, disjoint: function (t) {
      return rs.disjoint(this, t);
    }, crosses: function (t) {
      return rs.crosses(this, t);
    }, buffer: function () {
      if (1 === arguments.length) {
        var t = arguments[0];return dr.bufferOp(this, t);
      }if (2 === arguments.length) {
        var e = arguments[0],
            n = arguments[1];return dr.bufferOp(this, e, n);
      }if (3 === arguments.length) {
        var i = arguments[0],
            r = arguments[1],
            s = arguments[2];return dr.bufferOp(this, i, r, s);
      }
    }, convexHull: function () {
      return new me(this).getConvexHull();
    }, relate: function () {
      for (var t = arguments.length, e = Array(t), n = 0; n < t; n++) e[n] = arguments[n];return rs.relate.apply(rs, [this].concat(e));
    }, getCentroid: function () {
      if (this.isEmpty()) return this.factory.createPoint();var t = ge.getCentroid(this);return this.createPointFromInternalCoord(t, this);
    }, getInteriorPoint: function () {
      if (this.isEmpty()) return this.factory.createPoint();var t = null,
          e = this.getDimension();if (0 === e) {
        var n = new li(this);t = n.getInteriorPoint();
      } else if (1 === e) {
        var n = new ui(this);t = n.getInteriorPoint();
      } else {
        var n = new oi(this);t = n.getInteriorPoint();
      }return this.createPointFromInternalCoord(t, this);
    }, symDifference: function (t) {
      if (this.isEmpty() || t.isEmpty()) {
        if (this.isEmpty() && t.isEmpty()) return ii.createEmptyResult(ii.SYMDIFFERENCE, this, t, this.factory);if (this.isEmpty()) return t.copy();if (t.isEmpty()) return this.copy();
      }return this.checkNotGeometryCollection(this), this.checkNotGeometryCollection(t), si.overlayOp(this, t, ii.SYMDIFFERENCE);
    }, createPointFromInternalCoord: function (t, e) {
      return e.getPrecisionModel().makePrecise(t), e.getFactory().createPoint(t);
    }, toText: function () {
      var t = new se();return t.write(this);
    }, toString: function () {
      this.toText();
    }, contains: function (t) {
      return rs.contains(this, t);
    }, difference: function (t) {
      return this.isEmpty() ? ii.createEmptyResult(ii.DIFFERENCE, this, t, this.factory) : t.isEmpty() ? this.copy() : (this.checkNotGeometryCollection(this), this.checkNotGeometryCollection(t), si.overlayOp(this, t, ii.DIFFERENCE));
    }, isSimple: function () {
      var t = new Wi(this);return t.isSimple();
    }, isWithinDistance: function (t, e) {
      var n = this.getEnvelopeInternal().distance(t.getEnvelopeInternal());return !(n > e) && xr.isWithinDistance(this, t, e);
    }, distance: function (t) {
      return xr.distance(this, t);
    }, isEquivalentClass: function (t) {
      return this.getClass() === t.getClass();
    } });var Go = "1.3.0 (6e65adb)";t.version = Go, t.algorithm = co, t.densify = fo, t.dissolve = go, t.geom = lo, t.geomgraph = po, t.index = yo, t.io = No, t.noding = Co, t.operation = _o, t.precision = Mo, t.simplify = Do, t.triangulate = Fo, Object.defineProperty(t, "__esModule", { value: !0 });
});
$__System.registerDynamic('23', ['16'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    var coordEach = $__require('16').coordEach;

    /**
     * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.
     *
     * @name bbox
     * @param {FeatureCollection|Feature<any>} geojson input features
     * @returns {Array<number>} bbox extent in [minX, minY, maxX, maxY] order
     * @example
     * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);
     * var bbox = turf.bbox(line);
     * var bboxPolygon = turf.bboxPolygon(bbox);
     *
     * //addToMap
     * var addToMap = [line, bboxPolygon]
     */
    module.exports = function (geojson) {
        var bbox = [Infinity, Infinity, -Infinity, -Infinity];
        coordEach(geojson, function (coord) {
            if (bbox[0] > coord[0]) bbox[0] = coord[0];
            if (bbox[1] > coord[1]) bbox[1] = coord[1];
            if (bbox[2] < coord[0]) bbox[2] = coord[0];
            if (bbox[3] < coord[1]) bbox[3] = coord[1];
        });
        return bbox;
    };
});
$__System.registerDynamic('24', ['23', 'c'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var bbox = $__require('23');
  var point = $__require('c').point;

  /**
   * Takes a {@link Feature} or {@link FeatureCollection} and returns the absolute center point of all features.
   *
   * @name center
   * @param {GeoJSON} geojson GeoJSON to be centered
   * @param {Object} [properties] an Object that is used as the {@link Feature}'s properties
   * @returns {Feature<Point>} a Point feature at the absolute center point of all input features
   * @example
   * var features = turf.featureCollection([
   *   turf.point( [-97.522259, 35.4691]),
   *   turf.point( [-97.502754, 35.463455]),
   *   turf.point( [-97.508269, 35.463245])
   * ]);
   *
   * var center = turf.center(features);
   *
   * //addToMap
   * var addToMap = [features, center]
   * center.properties['marker-size'] = 'large';
   * center.properties['marker-color'] = '#000';
   */
  module.exports = function (geojson, properties) {
    var ext = bbox(geojson);
    var x = (ext[0] + ext[2]) / 2;
    var y = (ext[1] + ext[3]) / 2;
    return point([x, y], properties);
  };
});
$__System.registerDynamic('25', ['22', '20', '16', '24', 'c'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    var d3 = $__require('22');
    var jsts = $__require('20');
    var meta = $__require('16');
    var center = $__require('24');
    var helpers = $__require('c');
    var feature = helpers.feature;
    var geomEach = meta.geomEach;
    var featureEach = meta.featureEach;
    var featureCollection = helpers.featureCollection;
    var radiansToDistance = helpers.radiansToDistance;
    var distanceToRadians = helpers.distanceToRadians;

    /**
     * Calculates a buffer for input features for a given radius. Units supported are miles, kilometers, and degrees.
     *
     * When using a negative radius, the resulting geometry may be invalid if
     * it's too small compared to the radius magnitude. If the input is a
     * FeatureCollection, only valid members will be returned in the output
     * FeatureCollection - i.e., the output collection may have fewer members than
     * the input, or even be empty.
     *
     * @name buffer
     * @param {FeatureCollection|Geometry|Feature<any>} geojson input to be buffered
     * @param {number} radius distance to draw the buffer (negative values are allowed)
     * @param {string} [units=kilometers] any of the options supported by turf units
     * @param {number} [steps=64] number of steps
     * @returns {FeatureCollection|Feature<Polygon|MultiPolygon>|undefined} buffered features
     * @example
     * var point = turf.point([-90.548630, 14.616599]);
     * var buffered = turf.buffer(point, 500, 'miles');
     *
     * //addToMap
     * var addToMap = [point, buffered]
     */
    module.exports = function (geojson, radius, units, steps) {
        // validation
        if (!geojson) throw new Error('geojson is required');
        // Allow negative buffers ("erosion") or zero-sized buffers ("repair geometry")
        if (radius === undefined) throw new Error('radius is required');
        if (steps <= 0) throw new Error('steps must be greater than 0');

        // prevent input mutation
        // geojson = JSON.parse(JSON.stringify(geojson));

        // default params
        steps = steps || 64;
        units = units || 'kilometers';

        var results = [];
        switch (geojson.type) {
            case 'GeometryCollection':
                geomEach(geojson, function (geometry) {
                    var buffered = buffer(geometry, radius, units, steps);
                    if (buffered) results.push(buffered);
                });
                return featureCollection(results);
            case 'FeatureCollection':
                featureEach(geojson, function (feature) {
                    var multiBuffered = buffer(feature, radius, units, steps);
                    if (multiBuffered) {
                        featureEach(multiBuffered, function (buffered) {
                            if (buffered) results.push(buffered);
                        });
                    }
                });
                return featureCollection(results);
        }
        return buffer(geojson, radius, units, steps);
    };

    /**
     * Buffer single Feature/Geometry
     *
     * @private
     * @param {Feature<any>} geojson input to be buffered
     * @param {number} radius distance to draw the buffer
     * @param {string} [units='kilometers'] any of the options supported by turf units
     * @param {number} [steps=64] number of steps
     * @returns {Feature<Polygon|MultiPolygon>} buffered feature
     */
    function buffer(geojson, radius, units, steps) {
        var properties = geojson.properties || {};
        var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson;

        // Geometry Types faster than jsts
        switch (geometry.type) {
            case 'GeometryCollection':
                var results = [];
                geomEach(geojson, function (geometry) {
                    var buffered = buffer(geometry, radius, units, steps);
                    if (buffered) results.push(buffered);
                });
                return featureCollection(results);
        }

        // Project GeoJSON to Transverse Mercator projection (convert to Meters)
        var distance = radiansToDistance(distanceToRadians(radius, units), 'meters');
        var projection = defineProjection(geojson);
        var projected = {
            type: geometry.type,
            coordinates: projectCoords(geometry.coordinates, projection)
        };

        // JSTS buffer operation
        var reader = new jsts.io.GeoJSONReader();
        var geom = reader.read(projected);
        var buffered = geom.buffer(distance);
        var writer = new jsts.io.GeoJSONWriter();
        buffered = writer.write(buffered);

        // Detect if empty geometries
        if (coordsIsNaN(buffered.coordinates)) return undefined;

        // Unproject coordinates (convert to Degrees)
        buffered.coordinates = unprojectCoords(buffered.coordinates, projection);
        return feature(buffered, properties);
    }

    /**
     * Coordinates isNaN
     *
     * @private
     * @param {Array<any>} coords GeoJSON Coordinates
     * @returns {Boolean} if NaN exists
     */
    function coordsIsNaN(coords) {
        if (Array.isArray(coords[0])) return coordsIsNaN(coords[0]);
        return isNaN(coords[0]);
    }

    /**
     * Project coordinates to projection
     *
     * @private
     * @param {Array<any>} coords to project
     * @param {GeoProjection} projection D3 Geo Projection
     * @returns {Array<any>} projected coordinates
     */
    function projectCoords(coords, projection) {
        if (typeof coords[0] !== 'object') return projection(coords);
        return coords.map(function (coord) {
            return projectCoords(coord, projection);
        });
    }

    /**
     * Un-Project coordinates to projection
     *
     * @private
     * @param {Array<any>} coords to un-project
     * @param {GeoProjection} projection D3 Geo Projection
     * @returns {Array<any>} un-projected coordinates
     */
    function unprojectCoords(coords, projection) {
        if (typeof coords[0] !== 'object') return projection.invert(coords);
        return coords.map(function (coord) {
            return unprojectCoords(coord, projection);
        });
    }

    /**
     * Define Transverse Mercator projection
     *
     * @private
     * @param {Geometry|Feature<any>} geojson Base projection on center of GeoJSON
     * @returns {GeoProjection} D3 Geo Transverse Mercator Projection
     */
    function defineProjection(geojson) {
        var coords = center(geojson).geometry.coordinates.reverse();
        var rotate = coords.map(function (coord) {
            return -coord;
        });
        var projection = d3.geoTransverseMercator().center(coords).rotate(rotate).scale(6373000);

        return projection;
    }
});
$__System.registerDynamic('26', ['c'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    var point = $__require('c').point;

    /**
     * Takes a {@link LineString|linestring}, {@link MultiLineString|multi-linestring}, {@link MultiPolygon|multi-polygon}, or {@link Polygon|polygon} and returns {@link Point|points} at all self-intersections.
     *
     * @name kinks
     * @param {Feature<LineString|MultiLineString|MultiPolygon|Polygon>} featureIn input feature
     * @returns {FeatureCollection<Point>} self-intersections
     * @example
     * var poly = turf.polygon([[
     *   [-12.034835, 8.901183],
     *   [-12.060413, 8.899826],
     *   [-12.03638, 8.873199],
     *   [-12.059383, 8.871418],
     *   [-12.034835, 8.901183]
     * ]]);
     *
     * var kinks = turf.kinks(poly);
     *
     * //addToMap
     * var addToMap = [poly, kinks]
     */
    module.exports = function (featureIn) {
        var coordinates;
        var feature;
        var results = {
            type: 'FeatureCollection',
            features: []
        };
        if (featureIn.type === 'Feature') {
            feature = featureIn.geometry;
        } else {
            feature = featureIn;
        }
        if (feature.type === 'LineString') {
            coordinates = [feature.coordinates];
        } else if (feature.type === 'MultiLineString') {
            coordinates = feature.coordinates;
        } else if (feature.type === 'MultiPolygon') {
            coordinates = [].concat.apply([], feature.coordinates);
        } else if (feature.type === 'Polygon') {
            coordinates = feature.coordinates;
        } else {
            throw new Error('Input must be a LineString, MultiLineString, ' + 'Polygon, or MultiPolygon Feature or Geometry');
        }
        coordinates.forEach(function (line1) {
            coordinates.forEach(function (line2) {
                for (var i = 0; i < line1.length - 1; i++) {
                    // start iteration at i, intersections for k < i have already been checked in previous outer loop iterations
                    for (var k = i; k < line2.length - 1; k++) {
                        if (line1 === line2) {
                            // segments are adjacent and always share a vertex, not a kink
                            if (Math.abs(i - k) === 1) {
                                continue;
                            }
                            // first and last segment in a closed lineString or ring always share a vertex, not a kink
                            if (
                            // segments are first and last segment of lineString
                            i === 0 && k === line1.length - 2 &&
                            // lineString is closed
                            line1[i][0] === line1[line1.length - 1][0] && line1[i][1] === line1[line1.length - 1][1]) {
                                continue;
                            }
                        }

                        var intersection = lineIntersects(line1[i][0], line1[i][1], line1[i + 1][0], line1[i + 1][1], line2[k][0], line2[k][1], line2[k + 1][0], line2[k + 1][1]);
                        if (intersection) {
                            results.features.push(point([intersection[0], intersection[1]]));
                        }
                    }
                }
            });
        });
        return results;
    };

    // modified from http://jsfiddle.net/justin_c_rounds/Gd2S2/light/
    function lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {
        // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point
        var denominator,
            a,
            b,
            numerator1,
            numerator2,
            result = {
            x: null,
            y: null,
            onLine1: false,
            onLine2: false
        };
        denominator = (line2EndY - line2StartY) * (line1EndX - line1StartX) - (line2EndX - line2StartX) * (line1EndY - line1StartY);
        if (denominator === 0) {
            if (result.x !== null && result.y !== null) {
                return result;
            } else {
                return false;
            }
        }
        a = line1StartY - line2StartY;
        b = line1StartX - line2StartX;
        numerator1 = (line2EndX - line2StartX) * a - (line2EndY - line2StartY) * b;
        numerator2 = (line1EndX - line1StartX) * a - (line1EndY - line1StartY) * b;
        a = numerator1 / denominator;
        b = numerator2 / denominator;

        // if we cast these lines infinitely in both directions, they intersect here:
        result.x = line1StartX + a * (line1EndX - line1StartX);
        result.y = line1StartY + a * (line1EndY - line1StartY);

        // if line1 is a segment and line2 is infinite, they intersect if:
        if (a >= 0 && a <= 1) {
            result.onLine1 = true;
        }
        // if line2 is a segment and line1 is infinite, they intersect if:
        if (b >= 0 && b <= 1) {
            result.onLine2 = true;
        }
        // if line1 and line2 are segments, they intersect if both of the above are true
        if (result.onLine1 && result.onLine2) {
            return [result.x, result.y];
        } else {
            return false;
        }
    }
});
$__System.registerDynamic("27", ["28"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  // Find self-intersections in geojson polygon (possibly with interior rings)
  var rbush = $__require("28");

  module.exports = function (feature, filterFn, useSpatialIndex) {
    if (feature.geometry.type != "Polygon") throw new Error("The input feature must be a Polygon");
    if (useSpatialIndex == undefined) useSpatialIndex = 1;

    var coord = feature.geometry.coordinates;

    var output = [];
    var seen = {};

    if (useSpatialIndex) {
      var allEdgesAsRbushTreeItems = [];
      for (var ring0 = 0; ring0 < coord.length; ring0++) {
        for (var edge0 = 0; edge0 < coord[ring0].length - 1; edge0++) {
          allEdgesAsRbushTreeItems.push(rbushTreeItem(ring0, edge0));
        }
      }
      var tree = rbush();
      tree.load(allEdgesAsRbushTreeItems);
    }

    for (var ring0 = 0; ring0 < coord.length; ring0++) {
      for (var edge0 = 0; edge0 < coord[ring0].length - 1; edge0++) {
        if (useSpatialIndex) {
          var bboxOverlaps = tree.search(rbushTreeItem(ring0, edge0));
          bboxOverlaps.forEach(function (bboxIsect) {
            var ring1 = bboxIsect.ring;
            var edge1 = bboxIsect.edge;
            ifIsectAddToOutput(ring0, edge0, ring1, edge1);
          });
        } else {
          for (var ring1 = 0; ring1 < coord.length; ring1++) {
            for (var edge1 = 0; edge1 < coord[ring1].length - 1; edge1++) {
              // TODO: speedup possible if only interested in unique: start last two loops at ring0 and edge0+1
              ifIsectAddToOutput(ring0, edge0, ring1, edge1);
            }
          }
        }
      }
    }

    if (!filterFn) output = { type: "Feature", geometry: { type: "MultiPoint", coordinates: output } };
    return output;

    // Function to check if two edges intersect and add the intersection to the output
    function ifIsectAddToOutput(ring0, edge0, ring1, edge1) {
      var start0 = coord[ring0][edge0];
      var end0 = coord[ring0][edge0 + 1];
      var start1 = coord[ring1][edge1];
      var end1 = coord[ring1][edge1 + 1];

      var isect = intersect(start0, end0, start1, end1);

      if (isect == null) return; // discard parallels and coincidence
      frac0, frac1;
      if (end0[0] != start0[0]) {
        var frac0 = (isect[0] - start0[0]) / (end0[0] - start0[0]);
      } else {
        var frac0 = (isect[1] - start0[1]) / (end0[1] - start0[1]);
      };
      if (end1[0] != start1[0]) {
        var frac1 = (isect[0] - start1[0]) / (end1[0] - start1[0]);
      } else {
        var frac1 = (isect[1] - start1[1]) / (end1[1] - start1[1]);
      };
      if (frac0 >= 1 || frac0 <= 0 || frac1 >= 1 || frac1 <= 0) return; // require segment intersection

      var key = isect;
      var unique = !seen[key];
      if (unique) {
        seen[key] = true;
      }

      if (filterFn) {
        output.push(filterFn(isect, ring0, edge0, start0, end0, frac0, ring1, edge1, start1, end1, frac1, unique));
      } else {
        output.push(isect);
      }
    }

    // Function to return a rbush tree item given an ring and edge number
    function rbushTreeItem(ring, edge) {

      var start = coord[ring][edge];
      var end = coord[ring][edge + 1];

      if (start[0] < end[0]) {
        var minX = start[0],
            maxX = end[0];
      } else {
        var minX = end[0],
            maxX = start[0];
      };
      if (start[1] < end[1]) {
        var minY = start[1],
            maxY = end[1];
      } else {
        var minY = end[1],
            maxY = start[1];
      }
      return { minX: minX, minY: minY, maxX: maxX, maxY: maxY, ring: ring, edge: edge };
    }
  };

  // Function to compute where two lines (not segments) intersect. From https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection
  function intersect(start0, end0, start1, end1) {
    if (equalArrays(start0, start1) || equalArrays(start0, end1) || equalArrays(end0, start1) || equalArrays(end1, start1)) return null;
    var x0 = start0[0],
        y0 = start0[1],
        x1 = end0[0],
        y1 = end0[1],
        x2 = start1[0],
        y2 = start1[1],
        x3 = end1[0],
        y3 = end1[1];
    var denom = (x0 - x1) * (y2 - y3) - (y0 - y1) * (x2 - x3);
    if (denom == 0) return null;
    var x4 = ((x0 * y1 - y0 * x1) * (x2 - x3) - (x0 - x1) * (x2 * y3 - y2 * x3)) / denom;
    var y4 = ((x0 * y1 - y0 * x1) * (y2 - y3) - (y0 - y1) * (x2 * y3 - y2 * x3)) / denom;
    return [x4, y4];
  }

  // Function to compare Arrays of numbers. From http://stackoverflow.com/questions/7837456/how-to-compare-arrays-in-javascript
  function equalArrays(array1, array2) {
    // if the other array is a falsy value, return
    if (!array1 || !array2) return false;

    // compare lengths - can save a lot of time
    if (array1.length != array2.length) return false;

    for (var i = 0, l = array1.length; i < l; i++) {
      // Check if we have nested arrays
      if (array1[i] instanceof Array && array2[i] instanceof Array) {
        // recurse into the nested arrays
        if (!equalArrays(array1[i], array2[i])) return false;
      } else if (array1[i] != array2[i]) {
        // Warning - two different object instances will never be equal: {x:20} != {x:20}
        return false;
      }
    }
    return true;
  }
});
$__System.registerDynamic('29', [], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /**
     * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
     *
     * @name feature
     * @param {Geometry} geometry input geometry
     * @param {Object} properties properties
     * @returns {FeatureCollection} a FeatureCollection of input features
     * @example
     * var geometry = {
     *      "type": "Point",
     *      "coordinates": [
     *        67.5,
     *        32.84267363195431
     *      ]
     *    }
     *
     * var feature = turf.feature(geometry);
     *
     * //=feature
     */
    function feature(geometry, properties) {
        if (!geometry) throw new Error('No geometry passed');

        return {
            type: 'Feature',
            properties: properties || {},
            geometry: geometry
        };
    }
    module.exports.feature = feature;

    /**
     * Takes coordinates and properties (optional) and returns a new {@link Point} feature.
     *
     * @name point
     * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)
     * @param {Object=} properties an Object that is used as the {@link Feature}'s
     * properties
     * @returns {Feature<Point>} a Point feature
     * @example
     * var pt1 = turf.point([-75.343, 39.984]);
     *
     * //=pt1
     */
    module.exports.point = function (coordinates, properties) {
        if (!coordinates) throw new Error('No coordinates passed');
        if (coordinates.length === undefined) throw new Error('Coordinates must be an array');
        if (coordinates.length < 2) throw new Error('Coordinates must be at least 2 numbers long');
        if (typeof coordinates[0] !== 'number' || typeof coordinates[1] !== 'number') throw new Error('Coordinates must numbers');

        return feature({
            type: 'Point',
            coordinates: coordinates
        }, properties);
    };

    /**
     * Takes an array of LinearRings and optionally an {@link Object} with properties and returns a {@link Polygon} feature.
     *
     * @name polygon
     * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
     * @param {Object=} properties a properties object
     * @returns {Feature<Polygon>} a Polygon feature
     * @throws {Error} throw an error if a LinearRing of the polygon has too few positions
     * or if a LinearRing of the Polygon does not have matching Positions at the
     * beginning & end.
     * @example
     * var polygon = turf.polygon([[
     *  [-2.275543, 53.464547],
     *  [-2.275543, 53.489271],
     *  [-2.215118, 53.489271],
     *  [-2.215118, 53.464547],
     *  [-2.275543, 53.464547]
     * ]], { name: 'poly1', population: 400});
     *
     * //=polygon
     */
    module.exports.polygon = function (coordinates, properties) {
        if (!coordinates) throw new Error('No coordinates passed');

        for (var i = 0; i < coordinates.length; i++) {
            var ring = coordinates[i];
            if (ring.length < 4) {
                throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');
            }
            for (var j = 0; j < ring[ring.length - 1].length; j++) {
                if (ring[ring.length - 1][j] !== ring[0][j]) {
                    throw new Error('First and last Position are not equivalent.');
                }
            }
        }

        return feature({
            type: 'Polygon',
            coordinates: coordinates
        }, properties);
    };

    /**
     * Creates a {@link LineString} based on a
     * coordinate array. Properties can be added optionally.
     *
     * @name lineString
     * @param {Array<Array<number>>} coordinates an array of Positions
     * @param {Object=} properties an Object of key-value pairs to add as properties
     * @returns {Feature<LineString>} a LineString feature
     * @throws {Error} if no coordinates are passed
     * @example
     * var linestring1 = turf.lineString([
     *   [-21.964416, 64.148203],
     *   [-21.956176, 64.141316],
     *   [-21.93901, 64.135924],
     *   [-21.927337, 64.136673]
     * ]);
     * var linestring2 = turf.lineString([
     *   [-21.929054, 64.127985],
     *   [-21.912918, 64.134726],
     *   [-21.916007, 64.141016],
     *   [-21.930084, 64.14446]
     * ], {name: 'line 1', distance: 145});
     *
     * //=linestring1
     *
     * //=linestring2
     */
    module.exports.lineString = function (coordinates, properties) {
        if (!coordinates) throw new Error('No coordinates passed');

        return feature({
            type: 'LineString',
            coordinates: coordinates
        }, properties);
    };

    /**
     * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
     *
     * @name featureCollection
     * @param {Feature[]} features input features
     * @returns {FeatureCollection} a FeatureCollection of input features
     * @example
     * var features = [
     *  turf.point([-75.343, 39.984], {name: 'Location A'}),
     *  turf.point([-75.833, 39.284], {name: 'Location B'}),
     *  turf.point([-75.534, 39.123], {name: 'Location C'})
     * ];
     *
     * var fc = turf.featureCollection(features);
     *
     * //=fc
     */
    module.exports.featureCollection = function (features) {
        if (!features) throw new Error('No features passed');

        return {
            type: 'FeatureCollection',
            features: features
        };
    };

    /**
     * Creates a {@link Feature<MultiLineString>} based on a
     * coordinate array. Properties can be added optionally.
     *
     * @name multiLineString
     * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings
     * @param {Object=} properties an Object of key-value pairs to add as properties
     * @returns {Feature<MultiLineString>} a MultiLineString feature
     * @throws {Error} if no coordinates are passed
     * @example
     * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);
     *
     * //=multiLine
     *
     */
    module.exports.multiLineString = function (coordinates, properties) {
        if (!coordinates) throw new Error('No coordinates passed');

        return feature({
            type: 'MultiLineString',
            coordinates: coordinates
        }, properties);
    };

    /**
     * Creates a {@link Feature<MultiPoint>} based on a
     * coordinate array. Properties can be added optionally.
     *
     * @name multiPoint
     * @param {Array<Array<number>>} coordinates an array of Positions
     * @param {Object=} properties an Object of key-value pairs to add as properties
     * @returns {Feature<MultiPoint>} a MultiPoint feature
     * @throws {Error} if no coordinates are passed
     * @example
     * var multiPt = turf.multiPoint([[0,0],[10,10]]);
     *
     * //=multiPt
     *
     */
    module.exports.multiPoint = function (coordinates, properties) {
        if (!coordinates) throw new Error('No coordinates passed');

        return feature({
            type: 'MultiPoint',
            coordinates: coordinates
        }, properties);
    };

    /**
     * Creates a {@link Feature<MultiPolygon>} based on a
     * coordinate array. Properties can be added optionally.
     *
     * @name multiPolygon
     * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons
     * @param {Object=} properties an Object of key-value pairs to add as properties
     * @returns {Feature<MultiPolygon>} a multipolygon feature
     * @throws {Error} if no coordinates are passed
     * @example
     * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);
     *
     * //=multiPoly
     *
     */
    module.exports.multiPolygon = function (coordinates, properties) {
        if (!coordinates) throw new Error('No coordinates passed');

        return feature({
            type: 'MultiPolygon',
            coordinates: coordinates
        }, properties);
    };

    /**
     * Creates a {@link Feature<GeometryCollection>} based on a
     * coordinate array. Properties can be added optionally.
     *
     * @name geometryCollection
     * @param {Array<{Geometry}>} geometries an array of GeoJSON Geometries
     * @param {Object=} properties an Object of key-value pairs to add as properties
     * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature
     * @example
     * var pt = {
     *     "type": "Point",
     *       "coordinates": [100, 0]
     *     };
     * var line = {
     *     "type": "LineString",
     *     "coordinates": [ [101, 0], [102, 1] ]
     *   };
     * var collection = turf.geometryCollection([pt, line]);
     *
     * //=collection
     */
    module.exports.geometryCollection = function (geometries, properties) {
        if (!geometries) throw new Error('No geometries passed');

        return feature({
            type: 'GeometryCollection',
            geometries: geometries
        }, properties);
    };

    var factors = {
        miles: 3960,
        nauticalmiles: 3441.145,
        degrees: 57.2957795,
        radians: 1,
        inches: 250905600,
        yards: 6969600,
        meters: 6373000,
        metres: 6373000,
        kilometers: 6373,
        kilometres: 6373,
        feet: 20908792.65
    };

    /*
     * Convert a distance measurement from radians to a more friendly unit.
     *
     * @name radiansToDistance
     * @param {number} distance in radians across the sphere
     * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers
     * inches, yards, metres, meters, kilometres, kilometers.
     * @returns {number} distance
     */
    module.exports.radiansToDistance = function (radians, units) {
        var factor = factors[units || 'kilometers'];
        if (factor === undefined) throw new Error('Invalid unit');

        return radians * factor;
    };

    /*
     * Convert a distance measurement from a real-world unit into radians
     *
     * @name distanceToRadians
     * @param {number} distance in real units
     * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers
     * inches, yards, metres, meters, kilometres, kilometers.
     * @returns {number} radians
     */
    module.exports.distanceToRadians = function (distance, units) {
        var factor = factors[units || 'kilometers'];
        if (factor === undefined) throw new Error('Invalid unit');

        return distance / factor;
    };

    /*
     * Convert a distance measurement from a real-world unit into degrees
     *
     * @name distanceToRadians
     * @param {number} distance in real units
     * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers
     * inches, yards, metres, meters, kilometres, kilometers.
     * @returns {number} degrees
     */
    module.exports.distanceToDegrees = function (distance, units) {
        var factor = factors[units || 'kilometers'];
        if (factor === undefined) throw new Error('Invalid unit');

        return distance / factor * 57.2958;
    };
});
$__System.registerDynamic('2a', ['19'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    var invariant = $__require('19');
    var getCoord = invariant.getCoord;
    var getCoords = invariant.getCoords;

    // http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule
    // modified from: https://github.com/substack/point-in-polygon/blob/master/index.js
    // which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html

    /**
     * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point resides inside the polygon. The polygon can
     * be convex or concave. The function accounts for holes.
     *
     * @name inside
     * @param {Feature<Point>} point input point
     * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon
     * @param {boolean} [ignoreBoundary=false] True if polygon boundary should be ignored when determining if the point is inside the polygon otherwise false.
     * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon
     * @example
     * var pt = turf.point([-77, 44]);
     * var poly = turf.polygon([[
     *   [-81, 41],
     *   [-81, 47],
     *   [-72, 47],
     *   [-72, 41],
     *   [-81, 41]
     * ]]);
     *
     * turf.inside(pt, poly);
     * //= true
     */
    module.exports = function (point, polygon, ignoreBoundary) {
        // validation
        if (!point) throw new Error('point is required');
        if (!polygon) throw new Error('polygon is required');

        var pt = getCoord(point);
        var polys = getCoords(polygon);
        var type = polygon.geometry ? polygon.geometry.type : polygon.type;
        var bbox = polygon.bbox;

        // Quick elimination if point is not inside bbox
        if (bbox && inBBox(pt, bbox) === false) return false;

        // normalize to multipolygon
        if (type === 'Polygon') polys = [polys];

        for (var i = 0, insidePoly = false; i < polys.length && !insidePoly; i++) {
            // check if it is in the outer ring first
            if (inRing(pt, polys[i][0], ignoreBoundary)) {
                var inHole = false;
                var k = 1;
                // check for the point in any of the holes
                while (k < polys[i].length && !inHole) {
                    if (inRing(pt, polys[i][k], !ignoreBoundary)) {
                        inHole = true;
                    }
                    k++;
                }
                if (!inHole) insidePoly = true;
            }
        }
        return insidePoly;
    };

    /**
     * inRing
     *
     * @private
     * @param {[number, number]} pt [x,y]
     * @param {Array<[number, number]>} ring [[x,y], [x,y],..]
     * @param {boolean} ignoreBoundary ignoreBoundary
     * @returns {boolean} inRing
     */
    function inRing(pt, ring, ignoreBoundary) {
        var isInside = false;
        if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) ring = ring.slice(0, ring.length - 1);

        for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
            var xi = ring[i][0],
                yi = ring[i][1];
            var xj = ring[j][0],
                yj = ring[j][1];
            var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 && (xi - pt[0]) * (xj - pt[0]) <= 0 && (yi - pt[1]) * (yj - pt[1]) <= 0;
            if (onBoundary) return !ignoreBoundary;
            var intersect = yi > pt[1] !== yj > pt[1] && pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi;
            if (intersect) isInside = !isInside;
        }
        return isInside;
    }

    /**
     * inBBox
     *
     * @private
     * @param {[number, number]} pt point [x,y]
     * @param {[number, number, number, number]} bbox BBox [west, south, east, north]
     * @returns {boolean} true/false if point is inside BBox
     */
    function inBBox(pt, bbox) {
        return bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1];
    }
});
$__System.registerDynamic("2b", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports.RADIUS = 6378137;
  module.exports.FLATTENING = 1 / 298.257223563;
  module.exports.POLAR_RADIUS = 6356752.3142;
});
$__System.registerDynamic('2c', ['2b'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    var wgs84 = $__require('2b');

    module.exports.geometry = geometry;
    module.exports.ring = ringArea;

    function geometry(_) {
        var area = 0,
            i;
        switch (_.type) {
            case 'Polygon':
                return polygonArea(_.coordinates);
            case 'MultiPolygon':
                for (i = 0; i < _.coordinates.length; i++) {
                    area += polygonArea(_.coordinates[i]);
                }
                return area;
            case 'Point':
            case 'MultiPoint':
            case 'LineString':
            case 'MultiLineString':
                return 0;
            case 'GeometryCollection':
                for (i = 0; i < _.geometries.length; i++) {
                    area += geometry(_.geometries[i]);
                }
                return area;
        }
    }

    function polygonArea(coords) {
        var area = 0;
        if (coords && coords.length > 0) {
            area += Math.abs(ringArea(coords[0]));
            for (var i = 1; i < coords.length; i++) {
                area -= Math.abs(ringArea(coords[i]));
            }
        }
        return area;
    }

    /**
     * Calculate the approximate area of the polygon were it projected onto
     *     the earth.  Note that this area will be positive if ring is oriented
     *     clockwise, otherwise it will be negative.
     *
     * Reference:
     * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
     *     Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
     *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409
     *
     * Returns:
     * {float} The approximate signed geodesic area of the polygon in square
     *     meters.
     */

    function ringArea(coords) {
        var p1,
            p2,
            p3,
            lowerIndex,
            middleIndex,
            upperIndex,
            i,
            area = 0,
            coordsLength = coords.length;

        if (coordsLength > 2) {
            for (i = 0; i < coordsLength; i++) {
                if (i === coordsLength - 2) {
                    // i = N-2
                    lowerIndex = coordsLength - 2;
                    middleIndex = coordsLength - 1;
                    upperIndex = 0;
                } else if (i === coordsLength - 1) {
                    // i = N-1
                    lowerIndex = coordsLength - 1;
                    middleIndex = 0;
                    upperIndex = 1;
                } else {
                    // i = 0 to N-3
                    lowerIndex = i;
                    middleIndex = i + 1;
                    upperIndex = i + 2;
                }
                p1 = coords[lowerIndex];
                p2 = coords[middleIndex];
                p3 = coords[upperIndex];
                area += (rad(p3[0]) - rad(p1[0])) * Math.sin(rad(p2[1]));
            }

            area = area * wgs84.RADIUS * wgs84.RADIUS / 2;
        }

        return area;
    }

    function rad(_) {
        return _ * Math.PI / 180;
    }
});
$__System.registerDynamic('13', [], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /**
     * Callback for coordEach
     *
     * @private
     * @callback coordEachCallback
     * @param {[number, number]} currentCoords The current coordinates being processed.
     * @param {number} currentIndex The index of the current element being processed in the
     * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
     */

    /**
     * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()
     *
     * @name coordEach
     * @param {Object} layer any GeoJSON object
     * @param {Function} callback a method that takes (currentCoords, currentIndex)
     * @param {boolean} [excludeWrapCoord=false] whether or not to include
     * the final coordinate of LinearRings that wraps the ring in its iteration.
     * @example
     * var features = {
     *   "type": "FeatureCollection",
     *   "features": [
     *     {
     *       "type": "Feature",
     *       "properties": {},
     *       "geometry": {
     *         "type": "Point",
     *         "coordinates": [26, 37]
     *       }
     *     },
     *     {
     *       "type": "Feature",
     *       "properties": {},
     *       "geometry": {
     *         "type": "Point",
     *         "coordinates": [36, 53]
     *       }
     *     }
     *   ]
     * };
     * turf.coordEach(features, function (currentCoords, currentIndex) {
     *   //=currentCoords
     *   //=currentIndex
     * });
     */
    function coordEach(layer, callback, excludeWrapCoord) {
        var i,
            j,
            k,
            g,
            l,
            geometry,
            stopG,
            coords,
            geometryMaybeCollection,
            wrapShrink = 0,
            currentIndex = 0,
            isGeometryCollection,
            isFeatureCollection = layer.type === 'FeatureCollection',
            isFeature = layer.type === 'Feature',
            stop = isFeatureCollection ? layer.features.length : 1;

        // This logic may look a little weird. The reason why it is that way
        // is because it's trying to be fast. GeoJSON supports multiple kinds
        // of objects at its root: FeatureCollection, Features, Geometries.
        // This function has the responsibility of handling all of them, and that
        // means that some of the `for` loops you see below actually just don't apply
        // to certain inputs. For instance, if you give this just a
        // Point geometry, then both loops are short-circuited and all we do
        // is gradually rename the input until it's called 'geometry'.
        //
        // This also aims to allocate as few resources as possible: just a
        // few numbers and booleans, rather than any temporary arrays as would
        // be required with the normalization approach.
        for (i = 0; i < stop; i++) {

            geometryMaybeCollection = isFeatureCollection ? layer.features[i].geometry : isFeature ? layer.geometry : layer;
            isGeometryCollection = geometryMaybeCollection.type === 'GeometryCollection';
            stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

            for (g = 0; g < stopG; g++) {
                geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
                coords = geometry.coordinates;

                wrapShrink = excludeWrapCoord && (geometry.type === 'Polygon' || geometry.type === 'MultiPolygon') ? 1 : 0;

                if (geometry.type === 'Point') {
                    callback(coords, currentIndex);
                    currentIndex++;
                } else if (geometry.type === 'LineString' || geometry.type === 'MultiPoint') {
                    for (j = 0; j < coords.length; j++) {
                        callback(coords[j], currentIndex);
                        currentIndex++;
                    }
                } else if (geometry.type === 'Polygon' || geometry.type === 'MultiLineString') {
                    for (j = 0; j < coords.length; j++) for (k = 0; k < coords[j].length - wrapShrink; k++) {
                        callback(coords[j][k], currentIndex);
                        currentIndex++;
                    }
                } else if (geometry.type === 'MultiPolygon') {
                    for (j = 0; j < coords.length; j++) for (k = 0; k < coords[j].length; k++) for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                        callback(coords[j][k][l], currentIndex);
                        currentIndex++;
                    }
                } else if (geometry.type === 'GeometryCollection') {
                    for (j = 0; j < geometry.geometries.length; j++) coordEach(geometry.geometries[j], callback, excludeWrapCoord);
                } else {
                    throw new Error('Unknown Geometry Type');
                }
            }
        }
    }
    module.exports.coordEach = coordEach;

    /**
     * Callback for coordReduce
     *
     * The first time the callback function is called, the values provided as arguments depend
     * on whether the reduce method has an initialValue argument.
     *
     * If an initialValue is provided to the reduce method:
     *  - The previousValue argument is initialValue.
     *  - The currentValue argument is the value of the first element present in the array.
     *
     * If an initialValue is not provided:
     *  - The previousValue argument is the value of the first element present in the array.
     *  - The currentValue argument is the value of the second element present in the array.
     *
     * @private
     * @callback coordReduceCallback
     * @param {*} previousValue The accumulated value previously returned in the last invocation
     * of the callback, or initialValue, if supplied.
     * @param {[number, number]} currentCoords The current coordinate being processed.
     * @param {number} currentIndex The index of the current element being processed in the
     * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
     */

    /**
     * Reduce coordinates in any GeoJSON object, similar to Array.reduce()
     *
     * @name coordReduce
     * @param {Object} layer any GeoJSON object
     * @param {Function} callback a method that takes (previousValue, currentCoords, currentIndex)
     * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
     * @param {boolean} [excludeWrapCoord=false] whether or not to include
     * the final coordinate of LinearRings that wraps the ring in its iteration.
     * @returns {*} The value that results from the reduction.
     * @example
     * var features = {
     *   "type": "FeatureCollection",
     *   "features": [
     *     {
     *       "type": "Feature",
     *       "properties": {},
     *       "geometry": {
     *         "type": "Point",
     *         "coordinates": [26, 37]
     *       }
     *     },
     *     {
     *       "type": "Feature",
     *       "properties": {},
     *       "geometry": {
     *         "type": "Point",
     *         "coordinates": [36, 53]
     *       }
     *     }
     *   ]
     * };
     * turf.coordReduce(features, function (previousValue, currentCoords, currentIndex) {
     *   //=previousValue
     *   //=currentCoords
     *   //=currentIndex
     *   return currentCoords;
     * });
     */
    function coordReduce(layer, callback, initialValue, excludeWrapCoord) {
        var previousValue = initialValue;
        coordEach(layer, function (currentCoords, currentIndex) {
            if (currentIndex === 0 && initialValue === undefined) {
                previousValue = currentCoords;
            } else {
                previousValue = callback(previousValue, currentCoords, currentIndex);
            }
        }, excludeWrapCoord);
        return previousValue;
    }
    module.exports.coordReduce = coordReduce;

    /**
     * Callback for propEach
     *
     * @private
     * @callback propEachCallback
     * @param {*} currentProperties The current properties being processed.
     * @param {number} currentIndex The index of the current element being processed in the
     * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
     */

    /**
     * Iterate over properties in any GeoJSON object, similar to Array.forEach()
     *
     * @name propEach
     * @param {Object} layer any GeoJSON object
     * @param {Function} callback a method that takes (currentProperties, currentIndex)
     * @example
     * var features = {
     *   "type": "FeatureCollection",
     *   "features": [
     *     {
     *       "type": "Feature",
     *       "properties": {"foo": "bar"},
     *       "geometry": {
     *         "type": "Point",
     *         "coordinates": [26, 37]
     *       }
     *     },
     *     {
     *       "type": "Feature",
     *       "properties": {"hello": "world"},
     *       "geometry": {
     *         "type": "Point",
     *         "coordinates": [36, 53]
     *       }
     *     }
     *   ]
     * };
     * turf.propEach(features, function (currentProperties, currentIndex) {
     *   //=currentProperties
     *   //=currentIndex
     * });
     */
    function propEach(layer, callback) {
        var i;
        switch (layer.type) {
            case 'FeatureCollection':
                for (i = 0; i < layer.features.length; i++) {
                    callback(layer.features[i].properties, i);
                }
                break;
            case 'Feature':
                callback(layer.properties, 0);
                break;
        }
    }
    module.exports.propEach = propEach;

    /**
     * Callback for propReduce
     *
     * The first time the callback function is called, the values provided as arguments depend
     * on whether the reduce method has an initialValue argument.
     *
     * If an initialValue is provided to the reduce method:
     *  - The previousValue argument is initialValue.
     *  - The currentValue argument is the value of the first element present in the array.
     *
     * If an initialValue is not provided:
     *  - The previousValue argument is the value of the first element present in the array.
     *  - The currentValue argument is the value of the second element present in the array.
     *
     * @private
     * @callback propReduceCallback
     * @param {*} previousValue The accumulated value previously returned in the last invocation
     * of the callback, or initialValue, if supplied.
     * @param {*} currentProperties The current properties being processed.
     * @param {number} currentIndex The index of the current element being processed in the
     * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
     */

    /**
     * Reduce properties in any GeoJSON object into a single value,
     * similar to how Array.reduce works. However, in this case we lazily run
     * the reduction, so an array of all properties is unnecessary.
     *
     * @name propReduce
     * @param {Object} layer any GeoJSON object
     * @param {Function} callback a method that takes (previousValue, currentProperties, currentIndex)
     * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
     * @returns {*} The value that results from the reduction.
     * @example
     * var features = {
     *   "type": "FeatureCollection",
     *   "features": [
     *     {
     *       "type": "Feature",
     *       "properties": {"foo": "bar"},
     *       "geometry": {
     *         "type": "Point",
     *         "coordinates": [26, 37]
     *       }
     *     },
     *     {
     *       "type": "Feature",
     *       "properties": {"hello": "world"},
     *       "geometry": {
     *         "type": "Point",
     *         "coordinates": [36, 53]
     *       }
     *     }
     *   ]
     * };
     * turf.propReduce(features, function (previousValue, currentProperties, currentIndex) {
     *   //=previousValue
     *   //=currentProperties
     *   //=currentIndex
     *   return currentProperties
     * });
     */
    function propReduce(layer, callback, initialValue) {
        var previousValue = initialValue;
        propEach(layer, function (currentProperties, currentIndex) {
            if (currentIndex === 0 && initialValue === undefined) {
                previousValue = currentProperties;
            } else {
                previousValue = callback(previousValue, currentProperties, currentIndex);
            }
        });
        return previousValue;
    }
    module.exports.propReduce = propReduce;

    /**
     * Callback for featureEach
     *
     * @private
     * @callback featureEachCallback
     * @param {Feature<any>} currentFeature The current feature being processed.
     * @param {number} currentIndex The index of the current element being processed in the
     * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
     */

    /**
     * Iterate over features in any GeoJSON object, similar to
     * Array.forEach.
     *
     * @name featureEach
     * @param {Object} layer any GeoJSON object
     * @param {Function} callback a method that takes (currentFeature, currentIndex)
     * @example
     * var features = {
     *   "type": "FeatureCollection",
     *   "features": [
     *     {
     *       "type": "Feature",
     *       "properties": {},
     *       "geometry": {
     *         "type": "Point",
     *         "coordinates": [26, 37]
     *       }
     *     },
     *     {
     *       "type": "Feature",
     *       "properties": {},
     *       "geometry": {
     *         "type": "Point",
     *         "coordinates": [36, 53]
     *       }
     *     }
     *   ]
     * };
     * turf.featureEach(features, function (currentFeature, currentIndex) {
     *   //=currentFeature
     *   //=currentIndex
     * });
     */
    function featureEach(layer, callback) {
        if (layer.type === 'Feature') {
            callback(layer, 0);
        } else if (layer.type === 'FeatureCollection') {
            for (var i = 0; i < layer.features.length; i++) {
                callback(layer.features[i], i);
            }
        }
    }
    module.exports.featureEach = featureEach;

    /**
     * Callback for featureReduce
     *
     * The first time the callback function is called, the values provided as arguments depend
     * on whether the reduce method has an initialValue argument.
     *
     * If an initialValue is provided to the reduce method:
     *  - The previousValue argument is initialValue.
     *  - The currentValue argument is the value of the first element present in the array.
     *
     * If an initialValue is not provided:
     *  - The previousValue argument is the value of the first element present in the array.
     *  - The currentValue argument is the value of the second element present in the array.
     *
     * @private
     * @callback featureReduceCallback
     * @param {*} previousValue The accumulated value previously returned in the last invocation
     * of the callback, or initialValue, if supplied.
     * @param {Feature<any>} currentFeature The current Feature being processed.
     * @param {number} currentIndex The index of the current element being processed in the
     * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
     */

    /**
     * Reduce features in any GeoJSON object, similar to Array.reduce().
     *
     * @name featureReduce
     * @param {Object} layer any GeoJSON object
     * @param {Function} callback a method that takes (previousValue, currentFeature, currentIndex)
     * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
     * @returns {*} The value that results from the reduction.
     * @example
     * var features = {
     *   "type": "FeatureCollection",
     *   "features": [
     *     {
     *       "type": "Feature",
     *       "properties": {"foo": "bar"},
     *       "geometry": {
     *         "type": "Point",
     *         "coordinates": [26, 37]
     *       }
     *     },
     *     {
     *       "type": "Feature",
     *       "properties": {"hello": "world"},
     *       "geometry": {
     *         "type": "Point",
     *         "coordinates": [36, 53]
     *       }
     *     }
     *   ]
     * };
     * turf.featureReduce(features, function (previousValue, currentFeature, currentIndex) {
     *   //=previousValue
     *   //=currentFeature
     *   //=currentIndex
     *   return currentFeature
     * });
     */
    function featureReduce(layer, callback, initialValue) {
        var previousValue = initialValue;
        featureEach(layer, function (currentFeature, currentIndex) {
            if (currentIndex === 0 && initialValue === undefined) {
                previousValue = currentFeature;
            } else {
                previousValue = callback(previousValue, currentFeature, currentIndex);
            }
        });
        return previousValue;
    }
    module.exports.featureReduce = featureReduce;

    /**
     * Get all coordinates from any GeoJSON object.
     *
     * @name coordAll
     * @param {Object} layer any GeoJSON object
     * @returns {Array<Array<number>>} coordinate position array
     * @example
     * var features = {
     *   "type": "FeatureCollection",
     *   "features": [
     *     {
     *       "type": "Feature",
     *       "properties": {},
     *       "geometry": {
     *         "type": "Point",
     *         "coordinates": [26, 37]
     *       }
     *     },
     *     {
     *       "type": "Feature",
     *       "properties": {},
     *       "geometry": {
     *         "type": "Point",
     *         "coordinates": [36, 53]
     *       }
     *     }
     *   ]
     * };
     * var coords = turf.coordAll(features);
     * //=coords
     */
    function coordAll(layer) {
        var coords = [];
        coordEach(layer, function (coord) {
            coords.push(coord);
        });
        return coords;
    }
    module.exports.coordAll = coordAll;

    /**
     * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()
     *
     * @name geomEach
     * @param {Object} layer any GeoJSON object
     * @param {Function} callback a method that takes (currentGeometry, currentIndex)
     * @example
     * var features = {
     *   "type": "FeatureCollection",
     *   "features": [
     *     {
     *       "type": "Feature",
     *       "properties": {},
     *       "geometry": {
     *         "type": "Point",
     *         "coordinates": [26, 37]
     *       }
     *     },
     *     {
     *       "type": "Feature",
     *       "properties": {},
     *       "geometry": {
     *         "type": "Point",
     *         "coordinates": [36, 53]
     *       }
     *     }
     *   ]
     * };
     * turf.geomEach(features, function (currentGeometry, currentIndex) {
     *   //=currentGeometry
     *   //=currentIndex
     * });
     */
    function geomEach(layer, callback) {
        var i,
            j,
            g,
            geometry,
            stopG,
            geometryMaybeCollection,
            isGeometryCollection,
            currentIndex = 0,
            isFeatureCollection = layer.type === 'FeatureCollection',
            isFeature = layer.type === 'Feature',
            stop = isFeatureCollection ? layer.features.length : 1;

        // This logic may look a little weird. The reason why it is that way
        // is because it's trying to be fast. GeoJSON supports multiple kinds
        // of objects at its root: FeatureCollection, Features, Geometries.
        // This function has the responsibility of handling all of them, and that
        // means that some of the `for` loops you see below actually just don't apply
        // to certain inputs. For instance, if you give this just a
        // Point geometry, then both loops are short-circuited and all we do
        // is gradually rename the input until it's called 'geometry'.
        //
        // This also aims to allocate as few resources as possible: just a
        // few numbers and booleans, rather than any temporary arrays as would
        // be required with the normalization approach.
        for (i = 0; i < stop; i++) {

            geometryMaybeCollection = isFeatureCollection ? layer.features[i].geometry : isFeature ? layer.geometry : layer;
            isGeometryCollection = geometryMaybeCollection.type === 'GeometryCollection';
            stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

            for (g = 0; g < stopG; g++) {
                geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;

                if (geometry.type === 'Point' || geometry.type === 'LineString' || geometry.type === 'MultiPoint' || geometry.type === 'Polygon' || geometry.type === 'MultiLineString' || geometry.type === 'MultiPolygon') {
                    callback(geometry, currentIndex);
                    currentIndex++;
                } else if (geometry.type === 'GeometryCollection') {
                    for (j = 0; j < geometry.geometries.length; j++) {
                        callback(geometry.geometries[j], currentIndex);
                        currentIndex++;
                    }
                } else {
                    throw new Error('Unknown Geometry Type');
                }
            }
        }
    }
    module.exports.geomEach = geomEach;

    /**
     * Callback for geomReduce
     *
     * The first time the callback function is called, the values provided as arguments depend
     * on whether the reduce method has an initialValue argument.
     *
     * If an initialValue is provided to the reduce method:
     *  - The previousValue argument is initialValue.
     *  - The currentValue argument is the value of the first element present in the array.
     *
     * If an initialValue is not provided:
     *  - The previousValue argument is the value of the first element present in the array.
     *  - The currentValue argument is the value of the second element present in the array.
     *
     * @private
     * @callback geomReduceCallback
     * @param {*} previousValue The accumulated value previously returned in the last invocation
     * of the callback, or initialValue, if supplied.
     * @param {*} currentGeometry The current Feature being processed.
     * @param {number} currentIndex The index of the current element being processed in the
     * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
     */

    /**
     * Reduce geometry in any GeoJSON object, similar to Array.reduce().
     *
     * @name geomReduce
     * @param {Object} layer any GeoJSON object
     * @param {Function} callback a method that takes (previousValue, currentGeometry, currentIndex)
     * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
     * @returns {*} The value that results from the reduction.
     * @example
     * var features = {
     *   "type": "FeatureCollection",
     *   "features": [
     *     {
     *       "type": "Feature",
     *       "properties": {"foo": "bar"},
     *       "geometry": {
     *         "type": "Point",
     *         "coordinates": [26, 37]
     *       }
     *     },
     *     {
     *       "type": "Feature",
     *       "properties": {"hello": "world"},
     *       "geometry": {
     *         "type": "Point",
     *         "coordinates": [36, 53]
     *       }
     *     }
     *   ]
     * };
     * turf.geomReduce(features, function (previousValue, currentGeometry, currentIndex) {
     *   //=previousValue
     *   //=currentGeometry
     *   //=currentIndex
     *   return currentGeometry
     * });
     */
    function geomReduce(layer, callback, initialValue) {
        var previousValue = initialValue;
        geomEach(layer, function (currentGeometry, currentIndex) {
            if (currentIndex === 0 && initialValue === undefined) {
                previousValue = currentGeometry;
            } else {
                previousValue = callback(previousValue, currentGeometry, currentIndex);
            }
        });
        return previousValue;
    }
    module.exports.geomReduce = geomReduce;
});
$__System.registerDynamic('2d', ['2c', '13'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    var area = $__require('2c').geometry;
    var geomReduce = $__require('13').geomReduce;

    /**
     * Takes one or more features and returns their area in square meters.
     *
     * @name area
     * @param {FeatureCollection|Feature<any>} geojson input GeoJSON feature(s)
     * @returns {number} area in square meters
     * @addToMap polygon
     * @example
     * var polygon = {
     *   "type": "Feature",
     *   "properties": {},
     *   "geometry": {
     *     "type": "Polygon",
     *     "coordinates": [
     *       [
     *         [125, -15],
     *         [113, -22],
     *         [117, -37],
     *         [130, -33],
     *         [148, -39],
     *         [154, -27],
     *         [144, -15],
     *         [125, -15]
     *       ]
     *     ]
     *   }
     * }
     * var area = turf.area(polygon);
     * //=area => square meters
     * //=polygon
     */
    module.exports = function (geojson) {
        return geomReduce(geojson, function (value, geometry) {
            return value + area(geometry);
        }, 0);
    };
});
$__System.registerDynamic('2e', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /**
   * Helpers.
   */

  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var y = d * 365.25;

  /**
   * Parse or format the given `val`.
   *
   * Options:
   *
   *  - `long` verbose formatting [false]
   *
   * @param {String|Number} val
   * @param {Object} [options]
   * @throws {Error} throw an error if val is not a non-empty string or a number
   * @return {String|Number}
   * @api public
   */

  module.exports = function (val, options) {
    options = options || {};
    var type = typeof val;
    if (type === 'string' && val.length > 0) {
      return parse(val);
    } else if (type === 'number' && isNaN(val) === false) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
  };

  /**
   * Parse the given `str` and return milliseconds.
   *
   * @param {String} str
   * @return {Number}
   * @api private
   */

  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch (type) {
      case 'years':
      case 'year':
      case 'yrs':
      case 'yr':
      case 'y':
        return n * y;
      case 'days':
      case 'day':
      case 'd':
        return n * d;
      case 'hours':
      case 'hour':
      case 'hrs':
      case 'hr':
      case 'h':
        return n * h;
      case 'minutes':
      case 'minute':
      case 'mins':
      case 'min':
      case 'm':
        return n * m;
      case 'seconds':
      case 'second':
      case 'secs':
      case 'sec':
      case 's':
        return n * s;
      case 'milliseconds':
      case 'millisecond':
      case 'msecs':
      case 'msec':
      case 'ms':
        return n;
      default:
        return undefined;
    }
  }

  /**
   * Short format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */

  function fmtShort(ms) {
    if (ms >= d) {
      return Math.round(ms / d) + 'd';
    }
    if (ms >= h) {
      return Math.round(ms / h) + 'h';
    }
    if (ms >= m) {
      return Math.round(ms / m) + 'm';
    }
    if (ms >= s) {
      return Math.round(ms / s) + 's';
    }
    return ms + 'ms';
  }

  /**
   * Long format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */

  function fmtLong(ms) {
    return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
  }

  /**
   * Pluralization helper.
   */

  function plural(ms, n, name) {
    if (ms < n) {
      return;
    }
    if (ms < n * 1.5) {
      return Math.floor(ms / n) + ' ' + name;
    }
    return Math.ceil(ms / n) + ' ' + name + 's';
  }
});
$__System.registerDynamic('2f', ['2e'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;

  /**
   * This is the common logic for both the Node.js and web browser
   * implementations of `debug()`.
   *
   * Expose `debug()` as the module.
   */

  exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
  exports.coerce = coerce;
  exports.disable = disable;
  exports.enable = enable;
  exports.enabled = enabled;
  exports.humanize = $__require('2e');

  /**
   * The currently active debug mode names, and names to skip.
   */

  exports.names = [];
  exports.skips = [];

  /**
   * Map of special "%n" handling functions, for the debug "format" argument.
   *
   * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
   */

  exports.formatters = {};

  /**
   * Previous log timestamp.
   */

  var prevTime;

  /**
   * Select a color.
   * @param {String} namespace
   * @return {Number}
   * @api private
   */

  function selectColor(namespace) {
    var hash = 0,
        i;

    for (i in namespace) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return exports.colors[Math.abs(hash) % exports.colors.length];
  }

  /**
   * Create a debugger with the given `namespace`.
   *
   * @param {String} namespace
   * @return {Function}
   * @api public
   */

  function createDebug(namespace) {

    function debug() {
      // disabled?
      if (!debug.enabled) return;

      var self = debug;

      // set `diff` timestamp
      var curr = +new Date();
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;

      // turn the `arguments` into a proper Array
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }

      args[0] = exports.coerce(args[0]);

      if ('string' !== typeof args[0]) {
        // anything else let's inspect with %O
        args.unshift('%O');
      }

      // apply any `formatters` transformations
      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // if we encounter an escaped % then don't increase the array index
        if (match === '%%') return match;
        index++;
        var formatter = exports.formatters[format];
        if ('function' === typeof formatter) {
          var val = args[index];
          match = formatter.call(self, val);

          // now we need to remove `args[index]` since it's inlined in the `format`
          args.splice(index, 1);
          index--;
        }
        return match;
      });

      // apply env-specific formatting (colors, etc.)
      exports.formatArgs.call(self, args);

      var logFn = debug.log || exports.log || console.log.bind(console);
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.enabled = exports.enabled(namespace);
    debug.useColors = exports.useColors();
    debug.color = selectColor(namespace);

    // env-specific initialization logic for debug instances
    if ('function' === typeof exports.init) {
      exports.init(debug);
    }

    return debug;
  }

  /**
   * Enables a debug mode by namespaces. This can include modes
   * separated by a colon and wildcards.
   *
   * @param {String} namespaces
   * @api public
   */

  function enable(namespaces) {
    exports.save(namespaces);

    exports.names = [];
    exports.skips = [];

    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;

    for (var i = 0; i < len; i++) {
      if (!split[i]) continue; // ignore empty strings
      namespaces = split[i].replace(/\*/g, '.*?');
      if (namespaces[0] === '-') {
        exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        exports.names.push(new RegExp('^' + namespaces + '$'));
      }
    }
  }

  /**
   * Disable debug output.
   *
   * @api public
   */

  function disable() {
    exports.enable('');
  }

  /**
   * Returns true if the given mode name is enabled, false otherwise.
   *
   * @param {String} name
   * @return {Boolean}
   * @api public
   */

  function enabled(name) {
    var i, len;
    for (i = 0, len = exports.skips.length; i < len; i++) {
      if (exports.skips[i].test(name)) {
        return false;
      }
    }
    for (i = 0, len = exports.names.length; i < len; i++) {
      if (exports.names[i].test(name)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Coerce `val`.
   *
   * @param {Mixed} val
   * @return {Mixed}
   * @api private
   */

  function coerce(val) {
    if (val instanceof Error) return val.stack || val.message;
    return val;
  }
});
$__System.registerDynamic('30', ['2f'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /**
   * This is the web browser implementation of `debug()`.
   *
   * Expose `debug()` as the module.
   */

  exports = module.exports = $__require('2f');
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();

  /**
   * Colors.
   */

  exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];

  /**
   * Currently only WebKit-based Web Inspectors, Firefox >= v31,
   * and the Firebug extension (any Firefox version) are known
   * to support "%c" CSS customizations.
   *
   * TODO: add a `localStorage` variable to explicitly enable/disable colors
   */

  function useColors() {
    // NB: In an Electron preload script, document will be defined but not fully
    // initialized. Since we know we're in Chrome, we'll just detect this case
    // explicitly
    if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
      return true;
    }

    // is webkit? http://stackoverflow.com/a/16459606/376773
    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
    return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||
    // double check webkit in userAgent just in case we are in a worker
    typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }

  /**
   * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
   */

  exports.formatters.j = function (v) {
    try {
      return JSON.stringify(v);
    } catch (err) {
      return '[UnexpectedJSONParseError]: ' + err.message;
    }
  };

  /**
   * Colorize log arguments if enabled.
   *
   * @api public
   */

  function formatArgs(args) {
    var useColors = this.useColors;

    args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);

    if (!useColors) return;

    var c = 'color: ' + this.color;
    args.splice(1, 0, c, 'color: inherit');

    // the final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into
    var index = 0;
    var lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, function (match) {
      if ('%%' === match) return;
      index++;
      if ('%c' === match) {
        // we only are interested in the *last* %c
        // (the user may have provided their own)
        lastC = index;
      }
    });

    args.splice(lastC, 0, c);
  }

  /**
   * Invokes `console.log()` when available.
   * No-op when `console.log` is not a "function".
   *
   * @api public
   */

  function log() {
    // this hackery is required for IE8/9, where
    // the `console.log` function doesn't have 'apply'
    return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
  }

  /**
   * Save `namespaces`.
   *
   * @param {String} namespaces
   * @api private
   */

  function save(namespaces) {
    try {
      if (null == namespaces) {
        exports.storage.removeItem('debug');
      } else {
        exports.storage.debug = namespaces;
      }
    } catch (e) {}
  }

  /**
   * Load `namespaces`.
   *
   * @return {String} returns the previously persisted debug modes
   * @api private
   */

  function load() {
    var r;
    try {
      r = exports.storage.debug;
    } catch (e) {}

    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
    if (!r && typeof process !== 'undefined' && 'env' in process) {
      r = process.env.DEBUG;
    }

    return r;
  }

  /**
   * Enable namespaces listed in `localStorage.debug` initially.
   */

  exports.enable(load());

  /**
   * Localstorage attempts to return the localstorage.
   *
   * This is necessary because safari throws
   * when a user disables cookies/localstorage
   * and you attempt to access it.
   *
   * @return {LocalStorage}
   * @api private
   */

  function localstorage() {
    try {
      return window.localStorage;
    } catch (e) {}
  }
});
$__System.registerDynamic('31', ['27', '29', '2a', '2d', '28', '30'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var isects = $__require('27');
  var helpers = $__require('29');
  var inside = $__require('2a');
  var area = $__require('2d');
  var rbush = $__require('28');
  var debug = $__require('30')('simplepolygon');
  var debugAll = $__require('30')('simplepolygon:all');

  /**
  * Takes a complex (i.e. self-intersecting) geojson polygon, and breaks it down into its composite simple, non-self-intersecting one-ring polygons.
  *
  * @module simplepolygon
  * @param {Feature} feature Input polygon. This polygon may be unconform the {@link https://en.wikipedia.org/wiki/Simple_Features|Simple Features standard} in the sense that it's inner and outer rings may cross-intersect or self-intersect, that the outer ring must not contain the optional inner rings and that the winding number must not be positive for the outer and negative for the inner rings.
  * @return {FeatureCollection} Feature collection containing the simple, non-self-intersecting one-ring polygon features that the complex polygon is composed of. These simple polygons have properties such as their parent polygon, winding number and net winding number.
  *
  * @example
  * var poly = {
  *   "type": "Feature",
  *   "geometry": {
  *     "type": "Polygon",
  *     "coordinates": [[[0,0],[2,0],[0,2],[2,2],[0,0]]]
  *   }
  * };
  *
  * var result = simplepolygon(poly);
  *
  * // =result
  * // which will be a featureCollection of two polygons, one with coordinates [[[0,0],[2,0],[1,1],[0,0]]], parent -1, winding 1 and net winding 1, and one with coordinates [[[1,1],[0,2],[2,2],[1,1]]], parent -1, winding -1 and net winding -1
  */

  module.exports = function (feature) {
    // Check input
    if (feature.type != "Feature") throw new Error("The input must a geojson object of type Feature");
    if (feature.geometry === undefined || feature.geometry == null) throw new Error("The input must a geojson object with a non-empty geometry");
    if (feature.geometry.type != "Polygon") throw new Error("The input must be a geojson Polygon");

    // Process input
    var numRings = feature.geometry.coordinates.length;
    var vertices = [];
    for (var i = 0; i < numRings; i++) {
      var ring = feature.geometry.coordinates[i];
      if (!equalArrays(ring[0], ring[ring.length - 1])) {
        ring.push(ring[0]); // Close input ring if it is not
      }
      vertices.push.apply(vertices, ring.slice(0, ring.length - 1));
    }
    if (!isUnique(vertices)) throw new Error("The input polygon may not have duplicate vertices (except for the first and last vertex of each ring)");
    var numvertices = vertices.length; // number of input ring vertices, with the last closing vertices not counted
    debug("Processing input");

    // Compute self-intersections
    var selfIsectsData = isects(feature, function filterFn(isect, ring0, edge0, start0, end0, frac0, ring1, edge1, start1, end1, frac1, unique) {
      return [isect, ring0, edge0, start0, end0, frac0, ring1, edge1, start1, end1, frac1, unique];
    });
    var numSelfIsect = selfIsectsData.length;
    debug("Computing self-intersections");

    // If no self-intersections are found, the input rings are the output rings. Hence, we must only compute their winding numbers, net winding numbers and (since ohers rings could lie outside the first ring) parents.
    if (numSelfIsect == 0) {
      var outputFeatureArray = [];
      for (var i = 0; i < numRings; i++) {
        outputFeatureArray.push(helpers.polygon([feature.geometry.coordinates[i]], { parent: -1, winding: windingOfRing(feature.geometry.coordinates[i]) }));
      }
      var output = helpers.featureCollection(outputFeatureArray);
      determineParents();
      setNetWinding();
      debugAll("No self-intersections found. Input rings are output rings. Computed winding numbers, net winding numbers and parents");
      debug("Finishing without self-intersections");
      return output;
    }

    // If self-intersections are found, we will compute the output rings with the help of two intermediate variables
    // First, we build the pseudo vertex list and intersection list
    // The Pseudo vertex list is an array with for each ring an array with for each edge an array containing the pseudo-vertices (as made by their constructor) that have this ring and edge as ringAndEdgeIn, sorted for each edge by their fractional distance on this edge. It's length hence equals numRings.
    var pseudoVtxListByRingAndEdge = [];
    // The intersection list is an array containing intersections (as made by their constructor). First all numvertices ring-vertex-intersections, then all self-intersections (intra- and inter-ring). The order of the latter is not important but is permanent once given.
    var isectList = [];
    // Adding ring-pseudo-vertices to pseudoVtxListByRingAndEdge and ring-vertex-intersections to isectList
    for (var i = 0; i < numRings; i++) {
      pseudoVtxListByRingAndEdge.push([]);
      for (var j = 0; j < feature.geometry.coordinates[i].length - 1; j++) {
        // Each edge will feature one ring-pseudo-vertex in its array, on the last position. i.e. edge j features the ring-pseudo-vertex of the ring vertex j+1, which has ringAndEdgeIn = [i,j], on the last position.
        pseudoVtxListByRingAndEdge[i].push([new PseudoVtx(feature.geometry.coordinates[i][(j + 1).modulo(feature.geometry.coordinates[i].length - 1)], 1, [i, j], [i, (j + 1).modulo(feature.geometry.coordinates[i].length - 1)], undefined)]);
        // The first numvertices elements in isectList correspond to the ring-vertex-intersections
        isectList.push(new Isect(feature.geometry.coordinates[i][j], [i, (j - 1).modulo(feature.geometry.coordinates[i].length - 1)], [i, j], undefined, undefined, false, true));
      }
    }
    // Adding intersection-pseudo-vertices to pseudoVtxListByRingAndEdge and self-intersections to isectList
    for (var i = 0; i < numSelfIsect; i++) {
      // Adding intersection-pseudo-vertices made using selfIsectsData to pseudoVtxListByRingAndEdge's array corresponding to the incomming ring and edge
      pseudoVtxListByRingAndEdge[selfIsectsData[i][1]][selfIsectsData[i][2]].push(new PseudoVtx(selfIsectsData[i][0], selfIsectsData[i][5], [selfIsectsData[i][1], selfIsectsData[i][2]], [selfIsectsData[i][6], selfIsectsData[i][7]], undefined));
      // selfIsectsData contains double mentions of each intersection, but we only want to add them once to isectList
      if (selfIsectsData[i][11]) isectList.push(new Isect(selfIsectsData[i][0], [selfIsectsData[i][1], selfIsectsData[i][2]], [selfIsectsData[i][6], selfIsectsData[i][7]], undefined, undefined, true, true));
    }
    var numIsect = isectList.length;
    // Sort edge arrays of pseudoVtxListByRingAndEdge by the fractional distance 'param'
    for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {
      for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {
        pseudoVtxListByRingAndEdge[i][j].sort(function (a, b) {
          return a.param < b.param ? -1 : 1;
        });
      }
    }
    debug("Setting up pseudoVtxListByRingAndEdge and isectList");

    // Make a spatial index of intersections, in preperation for the following two steps
    allIsectsAsIsectRbushTreeItem = [];
    for (var i = 0; i < numIsect; i++) {
      allIsectsAsIsectRbushTreeItem.push({ minX: isectList[i].coord[0], minY: isectList[i].coord[1], maxX: isectList[i].coord[0], maxY: isectList[i].coord[1], index: i }); // could pass isect: isectList[i], but not necessary
    }
    var isectRbushTree = rbush();
    isectRbushTree.load(allIsectsAsIsectRbushTreeItem);

    // Now we will teach each intersection in isectList which is the next intersection along both it's [ring, edge]'s, in two steps.
    // First, we find the next intersection for each pseudo-vertex in pseudoVtxListByRingAndEdge:
    // For each pseudovertex in pseudoVtxListByRingAndEdge (3 loops) look at the next pseudovertex on that edge and find the corresponding intersection by comparing coordinates
    for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {
      for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {
        for (var k = 0; k < pseudoVtxListByRingAndEdge[i][j].length; k++) {
          var coordToFind;
          if (k == pseudoVtxListByRingAndEdge[i][j].length - 1) {
            // If it's the last pseudoVertex on that edge, then the next pseudoVertex is the first one on the next edge of that ring.
            coordToFind = pseudoVtxListByRingAndEdge[i][(j + 1).modulo(feature.geometry.coordinates[i].length - 1)][0].coord;
          } else {
            coordToFind = pseudoVtxListByRingAndEdge[i][j][k + 1].coord;
          }
          var IsectRbushTreeItemFound = isectRbushTree.search({ minX: coordToFind[0], minY: coordToFind[1], maxX: coordToFind[0], maxY: coordToFind[1] })[0]; // We can take [0] of the result, because there is only one isect correponding to a pseudo-vertex
          pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn = IsectRbushTreeItemFound.index;
        }
      }
    }
    debug("Computing nextIsect for pseudoVtxListByRingAndEdge");

    // Second, we port this knowledge of the next intersection over to the intersections in isectList, by finding the intersection corresponding to each pseudo-vertex and copying the pseudo-vertex' knownledge of the next-intersection over to the intersection
    for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {
      for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {
        for (var k = 0; k < pseudoVtxListByRingAndEdge[i][j].length; k++) {
          var coordToFind = pseudoVtxListByRingAndEdge[i][j][k].coord;
          var IsectRbushTreeItemFound = isectRbushTree.search({ minX: coordToFind[0], minY: coordToFind[1], maxX: coordToFind[0], maxY: coordToFind[1] })[0]; // We can take [0] of the result, because there is only one isect correponding to a pseudo-vertex
          var l = IsectRbushTreeItemFound.index;
          if (l < numvertices) {
            // Special treatment at ring-vertices: we correct the misnaming that happened in the previous block, since ringAndEdgeOut = ringAndEdge2 for ring vertices.
            isectList[l].nxtIsectAlongRingAndEdge2 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;
          } else {
            // Port the knowledge of the next intersection from the pseudo-vertices to the intersections, depending on how the edges are labeled in the pseudo-vertex and intersection.
            if (equalArrays(isectList[l].ringAndEdge1, pseudoVtxListByRingAndEdge[i][j][k].ringAndEdgeIn)) {
              isectList[l].nxtIsectAlongRingAndEdge1 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;
            } else {
              isectList[l].nxtIsectAlongRingAndEdge2 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;
            }
          }
        }
      }
    }
    // This explains why, eventhough when we will walk away from an intersection, we will walk way from the corresponding pseudo-vertex along edgeOut, pseudo-vertices have the property 'nxtIsectAlongEdgeIn' in stead of some propery 'nxtPseudoVtxAlongEdgeOut'. This is because this property (which is easy to find out) is used in the above for nxtIsectAlongRingAndEdge1 and nxtIsectAlongRingAndEdge2!
    debug("Porting nextIsect to isectList");

    // Before we start walking over the intersections to build the output rings, we prepare a queue that stores information on intersections we still have to deal with, and put at least one intersection in it.
    // This queue will contain information on intersections where we can start walking from once the current walk is finished, and its parent output ring (the smallest output ring it lies within, -1 if no parent or parent unknown yet) and its winding number (which we can already determine).
    var queue = [];
    // For each output ring, add the ring-vertex-intersection with the smalles x-value (i.e. the left-most) as a start intersection. By choosing such an extremal intersections, we are sure to start at an intersection that is a convex vertex of its output ring. By adding them all to the queue, we are sure that no rings will be forgotten. If due to ring-intersections such an intersection will be encountered while walking, it will be removed from the queue.
    var i = 0;
    for (var j = 0; j < numRings; j++) {
      var leftIsect = i;
      for (var k = 0; k < feature.geometry.coordinates[j].length - 1; k++) {
        if (isectList[i].coord[0] < isectList[leftIsect].coord[0]) {
          leftIsect = i;
        }
        i++;
      }
      // Compute winding at this left-most ring-vertex-intersection. We thus this by using our knowledge that this extremal vertex must be a convex vertex.
      // We first find the intersection before and after it, and then use them to determine the winding number of the corresponding output ring, since we know that an extremal vertex of a simple, non-self-intersecting ring is always convex, so the only reason it would not be is because the winding number we use to compute it is wrong
      var isectAfterLeftIsect = isectList[leftIsect].nxtIsectAlongRingAndEdge2;
      for (var k = 0; k < isectList.length; k++) {
        if (isectList[k].nxtIsectAlongRingAndEdge1 == leftIsect || isectList[k].nxtIsectAlongRingAndEdge2 == leftIsect) {
          var isectBeforeLeftIsect = k;
          break;
        }
      }
      var windingAtIsect = isConvex([isectList[isectBeforeLeftIsect].coord, isectList[leftIsect].coord, isectList[isectAfterLeftIsect].coord], true) ? 1 : -1;

      queue.push({ isect: leftIsect, parent: -1, winding: windingAtIsect });
    }
    // Sort the queue by the same criterion used to find the leftIsect: the left-most leftIsect must be last in the queue, such that it will be popped first, such that we will work from out to in regarding input rings. This assumtion is used when predicting the winding number and parent of a new queue member.
    queue.sort(function (a, b) {
      return isectList[a.isect].coord > isectList[b.isect].coord ? -1 : 1;
    });
    debugAll("Initial state of the queue: " + JSON.stringify(queue));
    debug("Setting up queue");

    // Initialise output
    var outputFeatureArray = [];

    // While the queue is not empty, take the last object (i.e. its intersection) out and start making an output ring by walking in the direction that has not been walked away over yet.
    while (queue.length > 0) {
      // Get the last object out of the queue
      var popped = queue.pop();
      var startIsect = popped.isect;
      var currentOutputRingParent = popped.parent;
      var currentOutputRingWinding = popped.winding;
      // Make new output ring and add vertex from starting intersection
      var currentOutputRing = outputFeatureArray.length;
      var currentOutputRingCoords = [isectList[startIsect].coord];
      debugAll("# Starting output ring number " + outputFeatureArray.length + " with winding " + currentOutputRingWinding + " from intersection " + startIsect);
      if (startIsect < numvertices) debugAll("This is a ring-vertex-intersections, which means this output ring does not touch existing output rings");
      // Set up the variables used while walking over intersections: 'currentIsect', 'nxtIsect' and 'walkingRingAndEdge'
      var currentIsect = startIsect;
      if (isectList[startIsect].ringAndEdge1Walkable) {
        var walkingRingAndEdge = isectList[startIsect].ringAndEdge1;
        var nxtIsect = isectList[startIsect].nxtIsectAlongRingAndEdge1;
      } else {
        var walkingRingAndEdge = isectList[startIsect].ringAndEdge2;
        var nxtIsect = isectList[startIsect].nxtIsectAlongRingAndEdge2;
      }
      // While we have not arrived back at the same intersection, keep walking
      while (!equalArrays(isectList[startIsect].coord, isectList[nxtIsect].coord)) {
        debugAll("Walking from intersection " + currentIsect + " to " + nxtIsect + " over ring " + walkingRingAndEdge[0] + " and edge " + walkingRingAndEdge[1]);
        currentOutputRingCoords.push(isectList[nxtIsect].coord);
        debugAll("Adding intersection " + nxtIsect + " to current output ring");
        // If the next intersection is queued, we can remove it, because we will go there now.
        var nxtIsectInQueue = undefined;
        for (var i = 0; i < queue.length; i++) {
          if (queue[i].isect == nxtIsect) {
            nxtIsectInQueue = i;break;
          }
        }
        if (nxtIsectInQueue != undefined) {
          debugAll("Removing intersection " + nxtIsect + " from queue");
          queue.splice(nxtIsectInQueue, 1);
        }
        // Arriving at this new intersection, we know which will be our next walking ring and edge (if we came from 1 we will walk away from 2 and vice versa),
        // So we can set it as our new walking ring and intersection and remember that we (will) have walked over it
        // If we have never walked away from this new intersection along the other ring and edge then we will soon do, add the intersection (and the parent wand winding number) to the queue
        // (We can predict the winding number and parent as follows: if the edge is convex, the other output ring started from there will have the alternate winding and lie outside of the current one, and thus have the same parent ring as the current ring. Otherwise, it will have the same winding number and lie inside of the current ring. We are, however, only sure of this of an output ring started from there does not enclose the current ring. This is why the initial queue's intersections must be sorted such that outer ones come out first.)
        // We then update the other two walking variables.
        if (equalArrays(walkingRingAndEdge, isectList[nxtIsect].ringAndEdge1)) {
          walkingRingAndEdge = isectList[nxtIsect].ringAndEdge2;
          isectList[nxtIsect].ringAndEdge2Walkable = false;
          if (isectList[nxtIsect].ringAndEdge1Walkable) {
            debugAll("Adding intersection " + nxtIsect + " to queue");
            var pushing = { isect: nxtIsect };
            if (isConvex([isectList[currentIsect].coord, isectList[nxtIsect].coord, isectList[isectList[nxtIsect].nxtIsectAlongRingAndEdge2].coord], currentOutputRingWinding == 1)) {
              pushing.parent = currentOutputRingParent;
              pushing.winding = -currentOutputRingWinding;
            } else {
              pushing.parent = currentOutputRing;
              pushing.winding = currentOutputRingWinding;
            }
            queue.push(pushing);
          }
          currentIsect = nxtIsect;
          nxtIsect = isectList[nxtIsect].nxtIsectAlongRingAndEdge2;
        } else {
          walkingRingAndEdge = isectList[nxtIsect].ringAndEdge1;
          isectList[nxtIsect].ringAndEdge1Walkable = false;
          if (isectList[nxtIsect].ringAndEdge2Walkable) {
            debugAll("Adding intersection " + nxtIsect + " to queue");
            var pushing = { isect: nxtIsect };
            if (isConvex([isectList[currentIsect].coord, isectList[nxtIsect].coord, isectList[isectList[nxtIsect].nxtIsectAlongRingAndEdge1].coord], currentOutputRingWinding == 1)) {
              pushing.parent = currentOutputRingParent;
              pushing.winding = -currentOutputRingWinding;
            } else {
              pushing.parent = currentOutputRing;
              pushing.winding = currentOutputRingWinding;
            }
            queue.push(pushing);
          }
          currentIsect = nxtIsect;
          nxtIsect = isectList[nxtIsect].nxtIsectAlongRingAndEdge1;
        }
        debugAll("Current state of the queue: " + JSON.stringify(queue));
      }
      debugAll("Walking from intersection " + currentIsect + " to " + nxtIsect + " over ring " + walkingRingAndEdge[0] + " and edge " + walkingRingAndEdge[1] + " and closing ring");
      // Close output ring
      currentOutputRingCoords.push(isectList[nxtIsect].coord);
      // Push output ring to output
      outputFeatureArray.push(helpers.polygon([currentOutputRingCoords], { index: currentOutputRing, parent: currentOutputRingParent, winding: currentOutputRingWinding, netWinding: undefined }));
    }

    var output = helpers.featureCollection(outputFeatureArray);
    debug("Walking");

    determineParents();
    debug("Determining parents");

    setNetWinding();
    debug("Setting winding number");

    // These functions are also used if no intersections are found
    function determineParents() {
      var featuresWithoutParent = [];
      for (var i = 0; i < output.features.length; i++) {
        debugAll("Output ring " + i + " has parent " + output.features[i].properties.parent);
        if (output.features[i].properties.parent == -1) featuresWithoutParent.push(i);
      }
      debugAll("The following output ring(s) have no parent: " + featuresWithoutParent);
      if (featuresWithoutParent.length > 1) {
        for (var i = 0; i < featuresWithoutParent.length; i++) {
          var parent = -1;
          var parentArea = Infinity;
          for (var j = 0; j < output.features.length; j++) {
            if (featuresWithoutParent[i] == j) continue;
            if (inside(helpers.point(output.features[featuresWithoutParent[i]].geometry.coordinates[0][0]), output.features[j], true)) {
              if (area(output.features[j]) < parentArea) {
                parent = j;
                debugAll("Ring " + featuresWithoutParent[i] + " lies inside output ring " + j);
              }
            }
          }
          output.features[featuresWithoutParent[i]].properties.parent = parent;
          debugAll("Ring " + featuresWithoutParent[i] + " is assigned parent " + parent);
        }
      }
    }

    function setNetWinding() {
      for (var i = 0; i < output.features.length; i++) {
        if (output.features[i].properties.parent == -1) {
          var netWinding = output.features[i].properties.winding;
          output.features[i].properties.netWinding = netWinding;
          setNetWindingOfChildren(i, netWinding);
        }
      }
    }

    function setNetWindingOfChildren(parent, ParentNetWinding) {
      for (var i = 0; i < output.features.length; i++) {
        if (output.features[i].properties.parent == parent) {
          var netWinding = ParentNetWinding + output.features[i].properties.winding;
          output.features[i].properties.netWinding = netWinding;
          setNetWindingOfChildren(i, netWinding);
        }
      }
    }

    debugAll("# Total of " + output.features.length + " rings");

    return output;
  };

  // Constructor for (ring- or intersection-) pseudo-vertices.
  var PseudoVtx = function (coord, param, ringAndEdgeIn, ringAndEdgeOut, nxtIsectAlongEdgeIn) {
    this.coord = coord; // [x,y] of this pseudo-vertex
    this.param = param; // fractional distance of this intersection on incomming edge
    this.ringAndEdgeIn = ringAndEdgeIn; // [ring index, edge index] of incomming edge
    this.ringAndEdgeOut = ringAndEdgeOut; // [ring index, edge index] of outgoing edge
    this.nxtIsectAlongEdgeIn = nxtIsectAlongEdgeIn; // The next intersection when following the incomming edge (so not when following ringAndEdgeOut!)
  };

  // Constructor for an intersection. There are two intersection-pseudo-vertices per self-intersection and one ring-pseudo-vertex per ring-vertex-intersection. Their labels 1 and 2 are not assigned a particular meaning but are permanent once given.
  var Isect = function (coord, ringAndEdge1, ringAndEdge2, nxtIsectAlongRingAndEdge1, nxtIsectAlongRingAndEdge2, ringAndEdge1Walkable, ringAndEdge2Walkable) {
    this.coord = coord; // [x,y] of this intersection
    this.ringAndEdge1 = ringAndEdge1; // first edge of this intersection
    this.ringAndEdge2 = ringAndEdge2; // second edge of this intersection
    this.nxtIsectAlongRingAndEdge1 = nxtIsectAlongRingAndEdge1; // the next intersection when following ringAndEdge1
    this.nxtIsectAlongRingAndEdge2 = nxtIsectAlongRingAndEdge2; // the next intersection when following ringAndEdge2
    this.ringAndEdge1Walkable = ringAndEdge1Walkable; // May we (still) walk away from this intersection over ringAndEdge1?
    this.ringAndEdge2Walkable = ringAndEdge2Walkable; // May we (still) walk away from this intersection over ringAndEdge2?
  };

  // Function to determine if three consecutive points of a simple, non-self-intersecting ring make up a convex vertex, assuming the ring is right- or lefthanded
  function isConvex(pts, righthanded) {
    // 'pts' is an [x,y] pair
    // 'righthanded' is a boolean
    if (typeof righthanded === 'undefined') righthanded = true;
    if (pts.length != 3) throw new Error("This function requires an array of three points [x,y]");
    var d = (pts[1][0] - pts[0][0]) * (pts[2][1] - pts[0][1]) - (pts[1][1] - pts[0][1]) * (pts[2][0] - pts[0][0]);
    return d >= 0 == righthanded;
  }

  // Function to compute winding of simple, non-self-intersecting ring
  function windingOfRing(ring) {
    // 'ring' is an array of [x,y] pairs with the last equal to the first
    // Compute the winding number based on the vertex with the smallest x-value, it precessor and successor. An extremal vertex of a simple, non-self-intersecting ring is always convex, so the only reason it is not is because the winding number we use to compute it is wrong
    var leftVtx = 0;
    for (var i = 0; i < ring.length - 1; i++) {
      if (ring[i][0] < ring[leftVtx][0]) leftVtx = i;
    }
    if (isConvex([ring[(leftVtx - 1).modulo(ring.length - 1)], ring[leftVtx], ring[(leftVtx + 1).modulo(ring.length - 1)]], true)) {
      var winding = 1;
    } else {
      var winding = -1;
    }
    return winding;
  }

  // Function to compare Arrays of numbers. From http://stackoverflow.com/questions/7837456/how-to-compare-arrays-in-javascript
  function equalArrays(array1, array2) {
    // if the other array is a falsy value, return
    if (!array1 || !array2) return false;

    // compare lengths - can save a lot of time
    if (array1.length != array2.length) return false;

    for (var i = 0, l = array1.length; i < l; i++) {
      // Check if we have nested arrays
      if (array1[i] instanceof Array && array2[i] instanceof Array) {
        // recurse into the nested arrays
        if (!equalArrays(array1[i], array2[i])) return false;
      } else if (array1[i] != array2[i]) {
        // Warning - two different object instances will never be equal: {x:20} != {x:20}
        return false;
      }
    }
    return true;
  }

  // Fix Javascript modulo for negative number. From http://stackoverflow.com/questions/4467539/javascript-modulo-not-behaving
  Number.prototype.modulo = function (n) {
    return (this % n + n) % n;
  };

  // Function to get array with only unique elements. From http://stackoverflow.com/questions/1960473/unique-values-in-an-array
  function getUnique(array) {
    var u = {},
        a = [];
    for (var i = 0, l = array.length; i < l; ++i) {
      if (u.hasOwnProperty(array[i])) {
        continue;
      }
      a.push(array[i]);
      u[array[i]] = 1;
    }
    return a;
  }

  // Function to check if array is unique (i.e. all unique elements, i.e. no duplicate elements)
  function isUnique(array) {
    var u = {},
        a = [];
    var isUnique = 1;
    for (var i = 0, l = array.length; i < l; ++i) {
      if (u.hasOwnProperty(array[i])) {
        isUnique = 0;
        break;
      }
      u[array[i]] = 1;
    }
    return isUnique;
  }
});
$__System.registerDynamic('32', ['16', 'c', '31'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    var meta = $__require('16');
    var helpers = $__require('c');
    var simplepolygon = $__require('31');
    var flattenEach = meta.flattenEach;
    var featureEach = meta.featureEach;
    var polygon = helpers.polygon;
    var featureCollection = helpers.featureCollection;

    /**
     * Takes a kinked polygon and returns a feature collection of polygons that have no kinks.
     * Uses [simplepolygon](https://github.com/mclaeysb/simplepolygon) internally.
     *
     * @name unkinkPolygon
     * @param {FeatureCollection|Feature<Polygon|MultiPolygon>} geojson GeoJSON Polygon or MultiPolygon
     * @returns {FeatureCollection<Polygon>} Unkinked polygons
     * @example
     * var poly = turf.polygon([[[0, 0], [2, 0], [0, 2], [2, 2], [0, 0]]]);
     *
     * var result = turf.unkinkPolygon(poly);
     *
     * //addToMap
     * var addToMap = [poly, result]
     */
    module.exports = function (geojson) {
        var features = [];
        flattenEach(geojson, function (feature) {
            if (feature.geometry.type !== 'Polygon') return;
            featureEach(simplepolygon(feature), function (poly) {
                features.push(polygon(poly.geometry.coordinates, feature.properties));
            });
        });
        return featureCollection(features);
    };
});
$__System.registerDynamic('1d', ['19'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    var getCoord = $__require('19').getCoord;
    //http://en.wikipedia.org/wiki/Haversine_formula
    //http://www.movable-type.co.uk/scripts/latlong.html

    /**
     * Takes two {@link Point|points} and finds the geographic bearing between them,
     * i.e. the angle measured in degrees from the north line (0 degrees)
     *
     * @name bearing
     * @param {Geometry|Feature<Point>|Array<number>} start starting Point
     * @param {Geometry|Feature<Point>|Array<number>} end ending Point
     * @param {boolean} [final=false] calculates the final bearing if true
     * @returns {number} bearing in decimal degrees, between -180 and 180 degrees (positive clockwise)
     * @example
     * var point1 = turf.point([-75.343, 39.984]);
     * var point2 = turf.point([-75.534, 39.123]);
     *
     * var bearing = turf.bearing(point1, point2);
     *
     * //addToMap
     * var addToMap = [point1, point2]
     * point1.properties['marker-color'] = '#f00'
     * point2.properties['marker-color'] = '#0f0'
     * point1.properties.bearing = bearing
     */
    function bearing(start, end, final) {
        if (final === true) return calculateFinalBearing(start, end);

        var degrees2radians = Math.PI / 180;
        var radians2degrees = 180 / Math.PI;
        var coordinates1 = getCoord(start);
        var coordinates2 = getCoord(end);

        var lon1 = degrees2radians * coordinates1[0];
        var lon2 = degrees2radians * coordinates2[0];
        var lat1 = degrees2radians * coordinates1[1];
        var lat2 = degrees2radians * coordinates2[1];
        var a = Math.sin(lon2 - lon1) * Math.cos(lat2);
        var b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);

        var bear = radians2degrees * Math.atan2(a, b);

        return bear;
    }

    /**
     * Calculates Final Bearing
     * @private
     * @param {Feature<Point>} start starting Point
     * @param {Feature<Point>} end ending Point
     * @returns {number} bearing
     */
    function calculateFinalBearing(start, end) {
        // Swap start & end
        var bear = bearing(end, start);
        bear = (bear + 180) % 360;
        return bear;
    }

    module.exports = bearing;
});
$__System.registerDynamic('15', ['19', 'c'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var getCoord = $__require('19').getCoord;
  var radiansToDistance = $__require('c').radiansToDistance;
  //http://en.wikipedia.org/wiki/Haversine_formula
  //http://www.movable-type.co.uk/scripts/latlong.html

  /**
   * Calculates the distance between two {@link Point|points} in degrees, radians,
   * miles, or kilometers. This uses the
   * [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula)
   * to account for global curvature.
   *
   * @name distance
   * @param {Geometry|Feature<Point>|Array<number>} from origin point
   * @param {Geometry|Feature<Point>|Array<number>} to destination point
   * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers
   * @returns {number} distance between the two points
   * @example
   * var from = turf.point([-75.343, 39.984]);
   * var to = turf.point([-75.534, 39.123]);
   *
   * var distance = turf.distance(from, to, "miles");
   *
   * //addToMap
   * var addToMap = [from, to];
   * from.properties.distance = distance;
   * to.properties.distance = distance;
   */
  module.exports = function (from, to, units) {
    var degrees2radians = Math.PI / 180;
    var coordinates1 = getCoord(from);
    var coordinates2 = getCoord(to);
    var dLat = degrees2radians * (coordinates2[1] - coordinates1[1]);
    var dLon = degrees2radians * (coordinates2[0] - coordinates1[0]);
    var lat1 = degrees2radians * coordinates1[1];
    var lat2 = degrees2radians * coordinates2[1];

    var a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);

    return radiansToDistance(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), units);
  };
});
$__System.registerDynamic('1e', ['19', 'c'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    //http://en.wikipedia.org/wiki/Haversine_formula
    //http://www.movable-type.co.uk/scripts/latlong.html
    var getCoord = $__require('19').getCoord;
    var helpers = $__require('c');
    var point = helpers.point;
    var distanceToRadians = helpers.distanceToRadians;

    /**
     * Takes a {@link Point} and calculates the location of a destination point given a distance in degrees, radians, miles, or kilometers; and bearing in degrees. This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.
     *
     * @name destination
     * @param {Geometry|Feature<Point>|Array<number>} origin starting point
     * @param {number} distance distance from the origin point
     * @param {number} bearing ranging from -180 to 180
     * @param {string} [units=kilometers] miles, kilometers, degrees, or radians
     * @returns {Feature<Point>} destination point
     * @example
     * var point = turf.point([-75.343, 39.984]);
     * var distance = 50;
     * var bearing = 90;
     * var units = 'miles';
     *
     * var destination = turf.destination(point, distance, bearing, units);
     *
     * //addToMap
     * var addToMap = [point, destination]
     * destination.properties['marker-color'] = '#f00';
     * point.properties['marker-color'] = '#0f0';
     */
    module.exports = function (origin, distance, bearing, units) {
        var degrees2radians = Math.PI / 180;
        var radians2degrees = 180 / Math.PI;
        var coordinates1 = getCoord(origin);
        var longitude1 = degrees2radians * coordinates1[0];
        var latitude1 = degrees2radians * coordinates1[1];
        var bearing_rad = degrees2radians * bearing;

        var radians = distanceToRadians(distance, units);

        var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) + Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearing_rad));
        var longitude2 = longitude1 + Math.atan2(Math.sin(bearing_rad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));

        return point([radians2degrees * longitude2, radians2degrees * latitude2]);
    };
});
$__System.registerDynamic('33', ['16', 'c', '1d', '15', '19', '1e', '34'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    var meta = $__require('16');
    var helpers = $__require('c');
    var bearing = $__require('1d');
    var distance = $__require('15');
    var invariant = $__require('19');
    var destination = $__require('1e');
    var lineIntersects = $__require('34');
    var point = helpers.point;
    var getCoords = invariant.getCoords;
    var lineString = helpers.lineString;
    var flattenEach = meta.flattenEach;

    /**
     * Takes a {@link Point} and a {@link LineString} and calculates the closest Point on the (Multi)LineString.
     *
     * @name pointOnLine
     * @param {Geometry|Feature<LineString|MultiLineString>} lines lines to snap to
     * @param {Geometry|Feature<Point>|number[]} pt point to snap from
     * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers
     * @returns {Feature<Point>} closest point on the `line` to `point`. The properties object will contain three values: `index`: closest point was found on nth line part, `dist`: distance between pt and the closest point, `location`: distance along the line between start and the closest point.
     * @example
     * var line = turf.lineString([
     *     [-77.031669, 38.878605],
     *     [-77.029609, 38.881946],
     *     [-77.020339, 38.884084],
     *     [-77.025661, 38.885821],
     *     [-77.021884, 38.889563],
     *     [-77.019824, 38.892368]
     * ]);
     * var pt = turf.point([-77.037076, 38.884017]);
     *
     * var snapped = turf.pointOnLine(line, pt, 'miles');
     *
     * //addToMap
     * var addToMap = [line, pt, snapped];
     * snapped.properties['marker-color'] = '#00f';
     */
    module.exports = function (lines, pt, units) {
        // validation
        var type = lines.geometry ? lines.geometry.type : lines.type;
        if (type !== 'LineString' && type !== 'MultiLineString') {
            throw new Error('lines must be LineString or MultiLineString');
        }

        var closestPt = point([Infinity, Infinity], {
            dist: Infinity
        });

        var length = 0.0;
        flattenEach(lines, function (line) {
            var coords = getCoords(line);

            for (var i = 0; i < coords.length - 1; i++) {
                //start
                var start = point(coords[i]);
                start.properties.dist = distance(pt, start, units);
                //stop
                var stop = point(coords[i + 1]);
                stop.properties.dist = distance(pt, stop, units);
                // sectionLength
                var sectionLength = distance(start, stop, units);
                //perpendicular
                var heightDistance = Math.max(start.properties.dist, stop.properties.dist);
                var direction = bearing(start, stop);
                var perpendicularPt1 = destination(pt, heightDistance, direction + 90, units);
                var perpendicularPt2 = destination(pt, heightDistance, direction - 90, units);
                var intersect = lineIntersects(lineString([perpendicularPt1.geometry.coordinates, perpendicularPt2.geometry.coordinates]), lineString([start.geometry.coordinates, stop.geometry.coordinates]));
                var intersectPt = null;
                if (intersect.features.length > 0) {
                    intersectPt = intersect.features[0];
                    intersectPt.properties.dist = distance(pt, intersectPt, units);
                    intersectPt.properties.location = length + distance(start, intersectPt, units);
                }

                if (start.properties.dist < closestPt.properties.dist) {
                    closestPt = start;
                    closestPt.properties.index = i;
                    closestPt.properties.location = length;
                }
                if (stop.properties.dist < closestPt.properties.dist) {
                    closestPt = stop;
                    closestPt.properties.index = i + 1;
                    closestPt.properties.location = length + sectionLength;
                }
                if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {
                    closestPt = intersectPt;
                    closestPt.properties.index = i;
                }
                // update length
                length += sectionLength;
            }
        });

        return closestPt;
    };
});
$__System.registerDynamic('35', ['c', '33'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    var linestring = $__require('c').lineString;
    var pointOnLine = $__require('33');

    /**
     * Takes a {@link LineString|line}, a start {@link Point}, and a stop point
     * and returns a subsection of the line in-between those points.
     * The start & stop points don't need to fall exactly on the line.
     *
     * This can be useful for extracting only the part of a route between waypoints.
     *
     * @name lineSlice
     * @param {Feature<Point>} startPt starting point
     * @param {Feature<Point>} stopPt stopping point
     * @param {Feature<LineString>|LineString} line line to slice
     * @returns {Feature<LineString>} sliced line
     * @example
     * var line = turf.lineString([
     *     [-77.031669, 38.878605],
     *     [-77.029609, 38.881946],
     *     [-77.020339, 38.884084],
     *     [-77.025661, 38.885821],
     *     [-77.021884, 38.889563],
     *     [-77.019824, 38.892368]
     * ]);
     * var start = turf.point([-77.029609, 38.881946]);
     * var stop = turf.point([-77.021884, 38.889563]);
     *
     * var sliced = turf.lineSlice(start, stop, line);
     *
     * //addToMap
     * var addToMap = [start, stop, line]
     */
    module.exports = function lineSlice(startPt, stopPt, line) {
        var coords;
        if (line.type === 'Feature') {
            coords = line.geometry.coordinates;
        } else if (line.type === 'LineString') {
            coords = line.coordinates;
        } else {
            throw new Error('input must be a LineString Feature or Geometry');
        }

        var startVertex = pointOnLine(line, startPt);
        var stopVertex = pointOnLine(line, stopPt);
        var ends;
        if (startVertex.properties.index <= stopVertex.properties.index) {
            ends = [startVertex, stopVertex];
        } else {
            ends = [stopVertex, startVertex];
        }
        var clipCoords = [ends[0].geometry.coordinates];
        for (var i = ends[0].properties.index + 1; i < ends[1].properties.index + 1; i++) {
            clipCoords.push(coords[i]);
        }
        clipCoords.push(ends[1].geometry.coordinates);
        return linestring(clipCoords, line.properties);
    };
});
$__System.registerDynamic('36', [], true, function ($__require, exports, module) {
    'use strict';

    var global = this || self,
        GLOBAL = global;
    module.exports = partialSort;

    // Floyd-Rivest selection algorithm:
    // Rearrange items so that all items in the [left, k] range are smaller than all items in (k, right];
    // The k-th element will have the (k - left + 1)th smallest value in [left, right]

    function partialSort(arr, k, left, right, compare) {
        left = left || 0;
        right = right || arr.length - 1;
        compare = compare || defaultCompare;

        while (right > left) {
            if (right - left > 600) {
                var n = right - left + 1;
                var m = k - left + 1;
                var z = Math.log(n);
                var s = 0.5 * Math.exp(2 * z / 3);
                var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
                var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
                var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
                partialSort(arr, k, newLeft, newRight, compare);
            }

            var t = arr[k];
            var i = left;
            var j = right;

            swap(arr, left, k);
            if (compare(arr[right], t) > 0) swap(arr, left, right);

            while (i < j) {
                swap(arr, i, j);
                i++;
                j--;
                while (compare(arr[i], t) < 0) i++;
                while (compare(arr[j], t) > 0) j--;
            }

            if (compare(arr[left], t) === 0) swap(arr, left, j);else {
                j++;
                swap(arr, j, right);
            }

            if (j <= k) left = j + 1;
            if (k <= j) right = j - 1;
        }
    }

    function swap(arr, i, j) {
        var tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    function defaultCompare(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
    }
});
$__System.registerDynamic('28', ['36'], true, function ($__require, exports, module) {
    'use strict';

    var global = this || self,
        GLOBAL = global;
    module.exports = rbush;

    var quickselect = $__require('36');

    function rbush(maxEntries, format) {
        if (!(this instanceof rbush)) return new rbush(maxEntries, format);

        // max entries in a node is 9 by default; min node fill is 40% for best performance
        this._maxEntries = Math.max(4, maxEntries || 9);
        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

        if (format) {
            this._initFormat(format);
        }

        this.clear();
    }

    rbush.prototype = {

        all: function () {
            return this._all(this.data, []);
        },

        search: function (bbox) {

            var node = this.data,
                result = [],
                toBBox = this.toBBox;

            if (!intersects(bbox, node)) return result;

            var nodesToSearch = [],
                i,
                len,
                child,
                childBBox;

            while (node) {
                for (i = 0, len = node.children.length; i < len; i++) {

                    child = node.children[i];
                    childBBox = node.leaf ? toBBox(child) : child;

                    if (intersects(bbox, childBBox)) {
                        if (node.leaf) result.push(child);else if (contains(bbox, childBBox)) this._all(child, result);else nodesToSearch.push(child);
                    }
                }
                node = nodesToSearch.pop();
            }

            return result;
        },

        collides: function (bbox) {

            var node = this.data,
                toBBox = this.toBBox;

            if (!intersects(bbox, node)) return false;

            var nodesToSearch = [],
                i,
                len,
                child,
                childBBox;

            while (node) {
                for (i = 0, len = node.children.length; i < len; i++) {

                    child = node.children[i];
                    childBBox = node.leaf ? toBBox(child) : child;

                    if (intersects(bbox, childBBox)) {
                        if (node.leaf || contains(bbox, childBBox)) return true;
                        nodesToSearch.push(child);
                    }
                }
                node = nodesToSearch.pop();
            }

            return false;
        },

        load: function (data) {
            if (!(data && data.length)) return this;

            if (data.length < this._minEntries) {
                for (var i = 0, len = data.length; i < len; i++) {
                    this.insert(data[i]);
                }
                return this;
            }

            // recursively build the tree with the given data from stratch using OMT algorithm
            var node = this._build(data.slice(), 0, data.length - 1, 0);

            if (!this.data.children.length) {
                // save as is if tree is empty
                this.data = node;
            } else if (this.data.height === node.height) {
                // split root if trees have the same height
                this._splitRoot(this.data, node);
            } else {
                if (this.data.height < node.height) {
                    // swap trees if inserted one is bigger
                    var tmpNode = this.data;
                    this.data = node;
                    node = tmpNode;
                }

                // insert the small tree into the large tree at appropriate level
                this._insert(node, this.data.height - node.height - 1, true);
            }

            return this;
        },

        insert: function (item) {
            if (item) this._insert(item, this.data.height - 1);
            return this;
        },

        clear: function () {
            this.data = createNode([]);
            return this;
        },

        remove: function (item, equalsFn) {
            if (!item) return this;

            var node = this.data,
                bbox = this.toBBox(item),
                path = [],
                indexes = [],
                i,
                parent,
                index,
                goingUp;

            // depth-first iterative tree traversal
            while (node || path.length) {

                if (!node) {
                    // go up
                    node = path.pop();
                    parent = path[path.length - 1];
                    i = indexes.pop();
                    goingUp = true;
                }

                if (node.leaf) {
                    // check current node
                    index = findItem(item, node.children, equalsFn);

                    if (index !== -1) {
                        // item found, remove the item and condense tree upwards
                        node.children.splice(index, 1);
                        path.push(node);
                        this._condense(path);
                        return this;
                    }
                }

                if (!goingUp && !node.leaf && contains(node, bbox)) {
                    // go down
                    path.push(node);
                    indexes.push(i);
                    i = 0;
                    parent = node;
                    node = node.children[0];
                } else if (parent) {
                    // go right
                    i++;
                    node = parent.children[i];
                    goingUp = false;
                } else node = null; // nothing found
            }

            return this;
        },

        toBBox: function (item) {
            return item;
        },

        compareMinX: compareNodeMinX,
        compareMinY: compareNodeMinY,

        toJSON: function () {
            return this.data;
        },

        fromJSON: function (data) {
            this.data = data;
            return this;
        },

        _all: function (node, result) {
            var nodesToSearch = [];
            while (node) {
                if (node.leaf) result.push.apply(result, node.children);else nodesToSearch.push.apply(nodesToSearch, node.children);

                node = nodesToSearch.pop();
            }
            return result;
        },

        _build: function (items, left, right, height) {

            var N = right - left + 1,
                M = this._maxEntries,
                node;

            if (N <= M) {
                // reached leaf level; return leaf
                node = createNode(items.slice(left, right + 1));
                calcBBox(node, this.toBBox);
                return node;
            }

            if (!height) {
                // target height of the bulk-loaded tree
                height = Math.ceil(Math.log(N) / Math.log(M));

                // target number of root entries to maximize storage utilization
                M = Math.ceil(N / Math.pow(M, height - 1));
            }

            node = createNode([]);
            node.leaf = false;
            node.height = height;

            // split the items into M mostly square tiles

            var N2 = Math.ceil(N / M),
                N1 = N2 * Math.ceil(Math.sqrt(M)),
                i,
                j,
                right2,
                right3;

            multiSelect(items, left, right, N1, this.compareMinX);

            for (i = left; i <= right; i += N1) {

                right2 = Math.min(i + N1 - 1, right);

                multiSelect(items, i, right2, N2, this.compareMinY);

                for (j = i; j <= right2; j += N2) {

                    right3 = Math.min(j + N2 - 1, right2);

                    // pack each entry recursively
                    node.children.push(this._build(items, j, right3, height - 1));
                }
            }

            calcBBox(node, this.toBBox);

            return node;
        },

        _chooseSubtree: function (bbox, node, level, path) {

            var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

            while (true) {
                path.push(node);

                if (node.leaf || path.length - 1 === level) break;

                minArea = minEnlargement = Infinity;

                for (i = 0, len = node.children.length; i < len; i++) {
                    child = node.children[i];
                    area = bboxArea(child);
                    enlargement = enlargedArea(bbox, child) - area;

                    // choose entry with the least area enlargement
                    if (enlargement < minEnlargement) {
                        minEnlargement = enlargement;
                        minArea = area < minArea ? area : minArea;
                        targetNode = child;
                    } else if (enlargement === minEnlargement) {
                        // otherwise choose one with the smallest area
                        if (area < minArea) {
                            minArea = area;
                            targetNode = child;
                        }
                    }
                }

                node = targetNode || node.children[0];
            }

            return node;
        },

        _insert: function (item, level, isNode) {

            var toBBox = this.toBBox,
                bbox = isNode ? item : toBBox(item),
                insertPath = [];

            // find the best node for accommodating the item, saving all nodes along the path too
            var node = this._chooseSubtree(bbox, this.data, level, insertPath);

            // put the item into the node
            node.children.push(item);
            extend(node, bbox);

            // split on node overflow; propagate upwards if necessary
            while (level >= 0) {
                if (insertPath[level].children.length > this._maxEntries) {
                    this._split(insertPath, level);
                    level--;
                } else break;
            }

            // adjust bboxes along the insertion path
            this._adjustParentBBoxes(bbox, insertPath, level);
        },

        // split overflowed node into two
        _split: function (insertPath, level) {

            var node = insertPath[level],
                M = node.children.length,
                m = this._minEntries;

            this._chooseSplitAxis(node, m, M);

            var splitIndex = this._chooseSplitIndex(node, m, M);

            var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
            newNode.height = node.height;
            newNode.leaf = node.leaf;

            calcBBox(node, this.toBBox);
            calcBBox(newNode, this.toBBox);

            if (level) insertPath[level - 1].children.push(newNode);else this._splitRoot(node, newNode);
        },

        _splitRoot: function (node, newNode) {
            // split root node
            this.data = createNode([node, newNode]);
            this.data.height = node.height + 1;
            this.data.leaf = false;
            calcBBox(this.data, this.toBBox);
        },

        _chooseSplitIndex: function (node, m, M) {

            var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

            minOverlap = minArea = Infinity;

            for (i = m; i <= M - m; i++) {
                bbox1 = distBBox(node, 0, i, this.toBBox);
                bbox2 = distBBox(node, i, M, this.toBBox);

                overlap = intersectionArea(bbox1, bbox2);
                area = bboxArea(bbox1) + bboxArea(bbox2);

                // choose distribution with minimum overlap
                if (overlap < minOverlap) {
                    minOverlap = overlap;
                    index = i;

                    minArea = area < minArea ? area : minArea;
                } else if (overlap === minOverlap) {
                    // otherwise choose distribution with minimum area
                    if (area < minArea) {
                        minArea = area;
                        index = i;
                    }
                }
            }

            return index;
        },

        // sorts node children by the best axis for split
        _chooseSplitAxis: function (node, m, M) {

            var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
                compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
                xMargin = this._allDistMargin(node, m, M, compareMinX),
                yMargin = this._allDistMargin(node, m, M, compareMinY);

            // if total distributions margin value is minimal for x, sort by minX,
            // otherwise it's already sorted by minY
            if (xMargin < yMargin) node.children.sort(compareMinX);
        },

        // total margin of all possible split distributions where each node is at least m full
        _allDistMargin: function (node, m, M, compare) {

            node.children.sort(compare);

            var toBBox = this.toBBox,
                leftBBox = distBBox(node, 0, m, toBBox),
                rightBBox = distBBox(node, M - m, M, toBBox),
                margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
                i,
                child;

            for (i = m; i < M - m; i++) {
                child = node.children[i];
                extend(leftBBox, node.leaf ? toBBox(child) : child);
                margin += bboxMargin(leftBBox);
            }

            for (i = M - m - 1; i >= m; i--) {
                child = node.children[i];
                extend(rightBBox, node.leaf ? toBBox(child) : child);
                margin += bboxMargin(rightBBox);
            }

            return margin;
        },

        _adjustParentBBoxes: function (bbox, path, level) {
            // adjust bboxes along the given tree path
            for (var i = level; i >= 0; i--) {
                extend(path[i], bbox);
            }
        },

        _condense: function (path) {
            // go through the path, removing empty nodes and updating bboxes
            for (var i = path.length - 1, siblings; i >= 0; i--) {
                if (path[i].children.length === 0) {
                    if (i > 0) {
                        siblings = path[i - 1].children;
                        siblings.splice(siblings.indexOf(path[i]), 1);
                    } else this.clear();
                } else calcBBox(path[i], this.toBBox);
            }
        },

        _initFormat: function (format) {
            // data format (minX, minY, maxX, maxY accessors)

            // uses eval-type function compilation instead of just accepting a toBBox function
            // because the algorithms are very sensitive to sorting functions performance,
            // so they should be dead simple and without inner calls

            var compareArr = ['return a', ' - b', ';'];

            this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
            this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));

            this.toBBox = new Function('a', 'return {minX: a' + format[0] + ', minY: a' + format[1] + ', maxX: a' + format[2] + ', maxY: a' + format[3] + '};');
        }
    };

    function findItem(item, items, equalsFn) {
        if (!equalsFn) return items.indexOf(item);

        for (var i = 0; i < items.length; i++) {
            if (equalsFn(item, items[i])) return i;
        }
        return -1;
    }

    // calculate node's bbox from bboxes of its children
    function calcBBox(node, toBBox) {
        distBBox(node, 0, node.children.length, toBBox, node);
    }

    // min bounding rectangle of node children from k to p-1
    function distBBox(node, k, p, toBBox, destNode) {
        if (!destNode) destNode = createNode(null);
        destNode.minX = Infinity;
        destNode.minY = Infinity;
        destNode.maxX = -Infinity;
        destNode.maxY = -Infinity;

        for (var i = k, child; i < p; i++) {
            child = node.children[i];
            extend(destNode, node.leaf ? toBBox(child) : child);
        }

        return destNode;
    }

    function extend(a, b) {
        a.minX = Math.min(a.minX, b.minX);
        a.minY = Math.min(a.minY, b.minY);
        a.maxX = Math.max(a.maxX, b.maxX);
        a.maxY = Math.max(a.maxY, b.maxY);
        return a;
    }

    function compareNodeMinX(a, b) {
        return a.minX - b.minX;
    }
    function compareNodeMinY(a, b) {
        return a.minY - b.minY;
    }

    function bboxArea(a) {
        return (a.maxX - a.minX) * (a.maxY - a.minY);
    }
    function bboxMargin(a) {
        return a.maxX - a.minX + (a.maxY - a.minY);
    }

    function enlargedArea(a, b) {
        return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
    }

    function intersectionArea(a, b) {
        var minX = Math.max(a.minX, b.minX),
            minY = Math.max(a.minY, b.minY),
            maxX = Math.min(a.maxX, b.maxX),
            maxY = Math.min(a.maxY, b.maxY);

        return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
    }

    function contains(a, b) {
        return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
    }

    function intersects(a, b) {
        return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
    }

    function createNode(children) {
        return {
            children: children,
            height: 1,
            leaf: true,
            minX: Infinity,
            minY: Infinity,
            maxX: -Infinity,
            maxY: -Infinity
        };
    }

    // sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
    // combines selection algorithm with binary divide & conquer approach

    function multiSelect(arr, left, right, n, compare) {
        var stack = [left, right],
            mid;

        while (stack.length) {
            right = stack.pop();
            left = stack.pop();

            if (right - left <= n) continue;

            mid = left + Math.ceil((right - left) / n / 2) * n;
            quickselect(arr, mid, left, right, compare);

            stack.push(left, mid, mid, right);
        }
    }
});
$__System.registerDynamic('37', ['28', '16'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    var rbush = $__require('28');
    var meta = $__require('16');
    var featureEach = meta.featureEach;
    var coordEach = meta.coordEach;

    /**
     * GeoJSON implementation of [RBush](https://github.com/mourner/rbush#rbush) spatial index.
     *
     * @name rbush
     * @param {number} [maxEntries=9] defines the maximum number of entries in a tree node. 9 (used by default) is a
     * reasonable choice for most applications. Higher value means faster insertion and slower search, and vice versa.
     * @returns {RBush} GeoJSON RBush
     * @example
     * var rbush = require('geojson-rbush')
     * var tree = rbush()
     */
    module.exports = function (maxEntries) {
        var tree = rbush(maxEntries);
        /**
         * [insert](https://github.com/mourner/rbush#data-format)
         *
         * @param {Feature<any>} feature insert single GeoJSON Feature
         * @returns {RBush} GeoJSON RBush
         * @example
         * var polygon = {
         *   "type": "Feature",
         *   "properties": {},
         *   "geometry": {
         *     "type": "Polygon",
         *     "coordinates": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]
         *   }
         * }
         * tree.insert(polygon)
         */
        tree.insert = function (feature) {
            if (Array.isArray(feature)) {
                var bbox = feature;
                feature = bboxPolygon(bbox);
                feature.bbox = bbox;
            } else {
                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);
            }
            return rbush.prototype.insert.call(this, feature);
        };

        /**
         * [load](https://github.com/mourner/rbush#bulk-inserting-data)
         *
         * @param {BBox[]|FeatureCollection<any>} features load entire GeoJSON FeatureCollection
         * @returns {RBush} GeoJSON RBush
         * @example
         * var polygons = {
         *   "type": "FeatureCollection",
         *   "features": [
         *     {
         *       "type": "Feature",
         *       "properties": {},
         *       "geometry": {
         *         "type": "Polygon",
         *         "coordinates": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]
         *       }
         *     },
         *     {
         *       "type": "Feature",
         *       "properties": {},
         *       "geometry": {
         *         "type": "Polygon",
         *         "coordinates": [[[-93, 32], [-83, 32], [-83, 39], [-93, 39], [-93, 32]]]
         *       }
         *     }
         *   ]
         * }
         * tree.load(polygons)
         */
        tree.load = function (features) {
            var load = [];
            // Load an Array of BBox
            if (Array.isArray(features)) {
                features.forEach(function (bbox) {
                    var feature = bboxPolygon(bbox);
                    feature.bbox = bbox;
                    load.push(feature);
                });
            } else {
                // Load FeatureCollection
                featureEach(features, function (feature) {
                    feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);
                    load.push(feature);
                });
            }
            return rbush.prototype.load.call(this, load);
        };

        /**
         * [remove](https://github.com/mourner/rbush#removing-data)
         *
         * @param {BBox|Feature<any>} feature remove single GeoJSON Feature
         * @returns {RBush} GeoJSON RBush
         * @example
         * var polygon = {
         *   "type": "Feature",
         *   "properties": {},
         *   "geometry": {
         *     "type": "Polygon",
         *     "coordinates": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]
         *   }
         * }
         * tree.remove(polygon)
         */
        tree.remove = function (feature) {
            if (Array.isArray(feature)) {
                var bbox = feature;
                feature = bboxPolygon(bbox);
                feature.bbox = bbox;
            }
            return rbush.prototype.remove.call(this, feature);
        };

        /**
         * [clear](https://github.com/mourner/rbush#removing-data)
         *
         * @returns {RBush} GeoJSON Rbush
         * @example
         * tree.clear()
         */
        tree.clear = function () {
            return rbush.prototype.clear.call(this);
        };

        /**
         * [search](https://github.com/mourner/rbush#search)
         *
         * @param {BBox|FeatureCollection|Feature<any>} geojson search with GeoJSON
         * @returns {FeatureCollection<any>} all features that intersects with the given GeoJSON.
         * @example
         * var polygon = {
         *   "type": "Feature",
         *   "properties": {},
         *   "geometry": {
         *     "type": "Polygon",
         *     "coordinates": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]
         *   }
         * }
         * tree.search(polygon)
         */
        tree.search = function (geojson) {
            var features = rbush.prototype.search.call(this, this.toBBox(geojson));
            return {
                type: 'FeatureCollection',
                features: features
            };
        };

        /**
         * [collides](https://github.com/mourner/rbush#collisions)
         *
         * @param {BBox|FeatureCollection|Feature<any>} geojson collides with GeoJSON
         * @returns {boolean} true if there are any items intersecting the given GeoJSON, otherwise false.
         * @example
         * var polygon = {
         *   "type": "Feature",
         *   "properties": {},
         *   "geometry": {
         *     "type": "Polygon",
         *     "coordinates": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]
         *   }
         * }
         * tree.collides(polygon)
         */
        tree.collides = function (geojson) {
            return rbush.prototype.collides.call(this, this.toBBox(geojson));
        };

        /**
         * [all](https://github.com/mourner/rbush#search)
         *
         * @returns {FeatureCollection<any>} all the features in RBush
         * @example
         * tree.all()
         * //=FeatureCollection
         */
        tree.all = function () {
            var features = rbush.prototype.all.call(this);
            return {
                type: 'FeatureCollection',
                features: features
            };
        };

        /**
         * [toJSON](https://github.com/mourner/rbush#export-and-import)
         *
         * @returns {any} export data as JSON object
         * @example
         * var exported = tree.toJSON()
         * //=JSON object
         */
        tree.toJSON = function () {
            return rbush.prototype.toJSON.call(this);
        };

        /**
         * [fromJSON](https://github.com/mourner/rbush#export-and-import)
         *
         * @param {any} json import previously exported data
         * @returns {RBush} GeoJSON RBush
         * @example
         * var exported = {
         *   "children": [
         *     {
         *       "type": "Feature",
         *       "geometry": {
         *         "type": "Point",
         *         "coordinates": [110, 50]
         *       },
         *       "properties": {},
         *       "bbox": [110, 50, 110, 50]
         *     }
         *   ],
         *   "height": 1,
         *   "leaf": true,
         *   "minX": 110,
         *   "minY": 50,
         *   "maxX": 110,
         *   "maxY": 50
         * }
         * tree.fromJSON(exported)
         */
        tree.fromJSON = function (json) {
            return rbush.prototype.fromJSON.call(this, json);
        };

        /**
         * Converts GeoJSON to {minX, minY, maxX, maxY} schema
         *
         * @private
         * @param {BBox|FeatureCollectio|Feature<any>} geojson feature(s) to retrieve BBox from
         * @returns {Object} converted to {minX, minY, maxX, maxY}
         */
        tree.toBBox = function (geojson) {
            var bbox;
            if (geojson.bbox) bbox = geojson.bbox;else if (Array.isArray(geojson) && geojson.length === 4) bbox = geojson;else bbox = turfBBox(geojson);

            return {
                minX: bbox[0],
                minY: bbox[1],
                maxX: bbox[2],
                maxY: bbox[3]
            };
        };
        return tree;
    };

    /**
     * Takes a bbox and returns an equivalent {@link Polygon|polygon}.
     *
     * @private
     * @name bboxPolygon
     * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order
     * @returns {Feature<Polygon>} a Polygon representation of the bounding box
     * @example
     * var bbox = [0, 0, 10, 10];
     *
     * var poly = turf.bboxPolygon(bbox);
     *
     * //addToMap
     * var addToMap = [poly]
     */
    function bboxPolygon(bbox) {
        var lowLeft = [bbox[0], bbox[1]];
        var topLeft = [bbox[0], bbox[3]];
        var topRight = [bbox[2], bbox[3]];
        var lowRight = [bbox[2], bbox[1]];
        var coordinates = [[lowLeft, lowRight, topRight, topLeft, lowLeft]];

        return {
            type: 'Feature',
            bbox: bbox,
            properties: {},
            geometry: {
                type: 'Polygon',
                coordinates: coordinates
            }
        };
    }

    /**
     * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.
     *
     * @private
     * @name bbox
     * @param {FeatureCollection|Feature<any>} geojson input features
     * @returns {Array<number>} bbox extent in [minX, minY, maxX, maxY] order
     * @example
     * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);
     * var bbox = turf.bbox(line);
     * var bboxPolygon = turf.bboxPolygon(bbox);
     *
     * //addToMap
     * var addToMap = [line, bboxPolygon]
     */
    function turfBBox(geojson) {
        var bbox = [Infinity, Infinity, -Infinity, -Infinity];
        coordEach(geojson, function (coord) {
            if (bbox[0] > coord[0]) bbox[0] = coord[0];
            if (bbox[1] > coord[1]) bbox[1] = coord[1];
            if (bbox[2] < coord[0]) bbox[2] = coord[0];
            if (bbox[3] < coord[1]) bbox[3] = coord[1];
        });
        return bbox;
    }
});
$__System.registerDynamic('c', [], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /**
     * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
     *
     * @name feature
     * @param {Geometry} geometry input geometry
     * @param {Object} [properties={}] an Object of key-value pairs to add as properties
     * @param {Array<number>} [bbox] BBox [west, south, east, north]
     * @param {string|number} [id] Identifier
     * @returns {Feature} a GeoJSON Feature
     * @example
     * var geometry = {
     *   "type": "Point",
     *   "coordinates": [110, 50]
     * };
     *
     * var feature = turf.feature(geometry);
     *
     * //=feature
     */
    function feature(geometry, properties, bbox, id) {
        if (geometry === undefined) throw new Error('geometry is required');
        if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');
        if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');
        if (id && ['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');

        var feat = { type: 'Feature' };
        if (id) feat.id = id;
        if (bbox) feat.bbox = bbox;
        feat.properties = properties || {};
        feat.geometry = geometry;
        return feat;
    }

    /**
     * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.
     * For GeometryCollection type use `helpers.geometryCollection`
     *
     * @name geometry
     * @param {string} type Geometry Type
     * @param {Array<number>} coordinates Coordinates
     * @param {Array<number>} [bbox] BBox [west, south, east, north]
     * @returns {Geometry} a GeoJSON Geometry
     * @example
     * var type = 'Point';
     * var coordinates = [110, 50];
     *
     * var geometry = turf.geometry(type, coordinates);
     *
     * //=geometry
     */
    function geometry(type, coordinates, bbox) {
        // Validation
        if (!type) throw new Error('type is required');
        if (!coordinates) throw new Error('coordinates is required');
        if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');
        if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');

        var geom;
        switch (type) {
            case 'Point':
                geom = point(coordinates).geometry;break;
            case 'LineString':
                geom = lineString(coordinates).geometry;break;
            case 'Polygon':
                geom = polygon(coordinates).geometry;break;
            case 'MultiPoint':
                geom = multiPoint(coordinates).geometry;break;
            case 'MultiLineString':
                geom = multiLineString(coordinates).geometry;break;
            case 'MultiPolygon':
                geom = multiPolygon(coordinates).geometry;break;
            default:
                throw new Error(type + ' is invalid');
        }
        if (bbox) geom.bbox = bbox;
        return geom;
    }

    /**
     * Takes coordinates and properties (optional) and returns a new {@link Point} feature.
     *
     * @name point
     * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)
     * @param {Object} [properties={}] an Object of key-value pairs to add as properties
     * @param {Array<number>} [bbox] BBox [west, south, east, north]
     * @param {string|number} [id] Identifier
     * @returns {Feature<Point>} a Point feature
     * @example
     * var point = turf.point([-75.343, 39.984]);
     *
     * //=point
     */
    function point(coordinates, properties, bbox, id) {
        if (!coordinates) throw new Error('No coordinates passed');
        if (coordinates.length === undefined) throw new Error('Coordinates must be an array');
        if (coordinates.length < 2) throw new Error('Coordinates must be at least 2 numbers long');
        if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('Coordinates must contain numbers');

        return feature({
            type: 'Point',
            coordinates: coordinates
        }, properties, bbox, id);
    }

    /**
     * Takes an array of LinearRings and optionally an {@link Object} with properties and returns a {@link Polygon} feature.
     *
     * @name polygon
     * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
     * @param {Object} [properties={}] an Object of key-value pairs to add as properties
     * @param {Array<number>} [bbox] BBox [west, south, east, north]
     * @param {string|number} [id] Identifier
     * @returns {Feature<Polygon>} a Polygon feature
     * @throws {Error} throw an error if a LinearRing of the polygon has too few positions
     * or if a LinearRing of the Polygon does not have matching Positions at the beginning & end.
     * @example
     * var polygon = turf.polygon([[
     *   [-2.275543, 53.464547],
     *   [-2.275543, 53.489271],
     *   [-2.215118, 53.489271],
     *   [-2.215118, 53.464547],
     *   [-2.275543, 53.464547]
     * ]], { name: 'poly1', population: 400});
     *
     * //=polygon
     */
    function polygon(coordinates, properties, bbox, id) {
        if (!coordinates) throw new Error('No coordinates passed');

        for (var i = 0; i < coordinates.length; i++) {
            var ring = coordinates[i];
            if (ring.length < 4) {
                throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');
            }
            for (var j = 0; j < ring[ring.length - 1].length; j++) {
                // Check if first point of Polygon contains two numbers
                if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('Coordinates must contain numbers');
                if (ring[ring.length - 1][j] !== ring[0][j]) {
                    throw new Error('First and last Position are not equivalent.');
                }
            }
        }

        return feature({
            type: 'Polygon',
            coordinates: coordinates
        }, properties, bbox, id);
    }

    /**
     * Creates a {@link LineString} based on a
     * coordinate array. Properties can be added optionally.
     *
     * @name lineString
     * @param {Array<Array<number>>} coordinates an array of Positions
     * @param {Object} [properties={}] an Object of key-value pairs to add as properties
     * @param {Array<number>} [bbox] BBox [west, south, east, north]
     * @param {string|number} [id] Identifier
     * @returns {Feature<LineString>} a LineString feature
     * @throws {Error} if no coordinates are passed
     * @example
     * var linestring1 = turf.lineString([
     *   [-21.964416, 64.148203],
     *   [-21.956176, 64.141316],
     *   [-21.93901, 64.135924],
     *   [-21.927337, 64.136673]
     * ]);
     * var linestring2 = turf.lineString([
     *   [-21.929054, 64.127985],
     *   [-21.912918, 64.134726],
     *   [-21.916007, 64.141016],
     *   [-21.930084, 64.14446]
     * ], {name: 'line 1', distance: 145});
     *
     * //=linestring1
     *
     * //=linestring2
     */
    function lineString(coordinates, properties, bbox, id) {
        if (!coordinates) throw new Error('No coordinates passed');
        if (coordinates.length < 2) throw new Error('Coordinates must be an array of two or more positions');
        // Check if first point of LineString contains two numbers
        if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('Coordinates must contain numbers');

        return feature({
            type: 'LineString',
            coordinates: coordinates
        }, properties, bbox, id);
    }

    /**
     * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
     *
     * @name featureCollection
     * @param {Feature[]} features input features
     * @param {Array<number>} [bbox] BBox [west, south, east, north]
     * @param {string|number} [id] Identifier
     * @returns {FeatureCollection} a FeatureCollection of input features
     * @example
     * var features = [
     *  turf.point([-75.343, 39.984], {name: 'Location A'}),
     *  turf.point([-75.833, 39.284], {name: 'Location B'}),
     *  turf.point([-75.534, 39.123], {name: 'Location C'})
     * ];
     *
     * var collection = turf.featureCollection(features);
     *
     * //=collection
     */
    function featureCollection(features, bbox, id) {
        if (!features) throw new Error('No features passed');
        if (!Array.isArray(features)) throw new Error('features must be an Array');
        if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');
        if (id && ['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');

        var fc = { type: 'FeatureCollection' };
        if (id) fc.id = id;
        if (bbox) fc.bbox = bbox;
        fc.features = features;
        return fc;
    }

    /**
     * Creates a {@link Feature<MultiLineString>} based on a
     * coordinate array. Properties can be added optionally.
     *
     * @name multiLineString
     * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings
     * @param {Object} [properties={}] an Object of key-value pairs to add as properties
     * @param {Array<number>} [bbox] BBox [west, south, east, north]
     * @param {string|number} [id] Identifier
     * @returns {Feature<MultiLineString>} a MultiLineString feature
     * @throws {Error} if no coordinates are passed
     * @example
     * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);
     *
     * //=multiLine
     */
    function multiLineString(coordinates, properties, bbox, id) {
        if (!coordinates) throw new Error('No coordinates passed');

        return feature({
            type: 'MultiLineString',
            coordinates: coordinates
        }, properties, bbox, id);
    }

    /**
     * Creates a {@link Feature<MultiPoint>} based on a
     * coordinate array. Properties can be added optionally.
     *
     * @name multiPoint
     * @param {Array<Array<number>>} coordinates an array of Positions
     * @param {Object} [properties={}] an Object of key-value pairs to add as properties
     * @param {Array<number>} [bbox] BBox [west, south, east, north]
     * @param {string|number} [id] Identifier
     * @returns {Feature<MultiPoint>} a MultiPoint feature
     * @throws {Error} if no coordinates are passed
     * @example
     * var multiPt = turf.multiPoint([[0,0],[10,10]]);
     *
     * //=multiPt
     */
    function multiPoint(coordinates, properties, bbox, id) {
        if (!coordinates) throw new Error('No coordinates passed');

        return feature({
            type: 'MultiPoint',
            coordinates: coordinates
        }, properties, bbox, id);
    }

    /**
     * Creates a {@link Feature<MultiPolygon>} based on a
     * coordinate array. Properties can be added optionally.
     *
     * @name multiPolygon
     * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons
     * @param {Object} [properties={}] an Object of key-value pairs to add as properties
     * @param {Array<number>} [bbox] BBox [west, south, east, north]
     * @param {string|number} [id] Identifier
     * @returns {Feature<MultiPolygon>} a multipolygon feature
     * @throws {Error} if no coordinates are passed
     * @example
     * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);
     *
     * //=multiPoly
     *
     */
    function multiPolygon(coordinates, properties, bbox, id) {
        if (!coordinates) throw new Error('No coordinates passed');

        return feature({
            type: 'MultiPolygon',
            coordinates: coordinates
        }, properties, bbox, id);
    }

    /**
     * Creates a {@link Feature<GeometryCollection>} based on a
     * coordinate array. Properties can be added optionally.
     *
     * @name geometryCollection
     * @param {Array<Geometry>} geometries an array of GeoJSON Geometries
     * @param {Object} [properties={}] an Object of key-value pairs to add as properties
     * @param {Array<number>} [bbox] BBox [west, south, east, north]
     * @param {string|number} [id] Identifier
     * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature
     * @example
     * var pt = {
     *     "type": "Point",
     *       "coordinates": [100, 0]
     *     };
     * var line = {
     *     "type": "LineString",
     *     "coordinates": [ [101, 0], [102, 1] ]
     *   };
     * var collection = turf.geometryCollection([pt, line]);
     *
     * //=collection
     */
    function geometryCollection(geometries, properties, bbox, id) {
        if (!geometries) throw new Error('geometries is required');
        if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');

        return feature({
            type: 'GeometryCollection',
            geometries: geometries
        }, properties, bbox, id);
    }

    // https://en.wikipedia.org/wiki/Great-circle_distance#Radius_for_spherical_Earth
    var factors = {
        miles: 3960,
        nauticalmiles: 3441.145,
        degrees: 57.2957795,
        radians: 1,
        inches: 250905600,
        yards: 6969600,
        meters: 6373000,
        metres: 6373000,
        centimeters: 6.373e+8,
        centimetres: 6.373e+8,
        kilometers: 6373,
        kilometres: 6373,
        feet: 20908792.65
    };

    var areaFactors = {
        kilometers: 0.000001,
        kilometres: 0.000001,
        meters: 1,
        metres: 1,
        centimetres: 10000,
        millimeter: 1000000,
        acres: 0.000247105,
        miles: 3.86e-7,
        yards: 1.195990046,
        feet: 10.763910417,
        inches: 1550.003100006
    };
    /**
     * Round number to precision
     *
     * @param {number} num Number
     * @param {number} [precision=0] Precision
     * @returns {number} rounded number
     * @example
     * turf.round(120.4321)
     * //=120
     *
     * turf.round(120.4321, 2)
     * //=120.43
     */
    function round(num, precision) {
        if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');
        if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');
        var multiplier = Math.pow(10, precision || 0);
        return Math.round(num * multiplier) / multiplier;
    }

    /**
     * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.
     * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
     *
     * @name radiansToDistance
     * @param {number} radians in radians across the sphere
     * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
     * @returns {number} distance
     */
    function radiansToDistance(radians, units) {
        if (radians === undefined || radians === null) throw new Error('radians is required');

        var factor = factors[units || 'kilometers'];
        if (!factor) throw new Error('units is invalid');
        return radians * factor;
    }

    /**
     * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians
     * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
     *
     * @name distanceToRadians
     * @param {number} distance in real units
     * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
     * @returns {number} radians
     */
    function distanceToRadians(distance, units) {
        if (distance === undefined || distance === null) throw new Error('distance is required');

        var factor = factors[units || 'kilometers'];
        if (!factor) throw new Error('units is invalid');
        return distance / factor;
    }

    /**
     * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees
     * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet
     *
     * @name distanceToDegrees
     * @param {number} distance in real units
     * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
     * @returns {number} degrees
     */
    function distanceToDegrees(distance, units) {
        return radians2degrees(distanceToRadians(distance, units));
    }

    /**
     * Converts any bearing angle from the north line direction (positive clockwise)
     * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line
     *
     * @name bearingToAngle
     * @param {number} bearing angle, between -180 and +180 degrees
     * @returns {number} angle between 0 and 360 degrees
     */
    function bearingToAngle(bearing) {
        if (bearing === null || bearing === undefined) throw new Error('bearing is required');

        var angle = bearing % 360;
        if (angle < 0) angle += 360;
        return angle;
    }

    /**
     * Converts an angle in radians to degrees
     *
     * @name radians2degrees
     * @param {number} radians angle in radians
     * @returns {number} degrees between 0 and 360 degrees
     */
    function radians2degrees(radians) {
        if (radians === null || radians === undefined) throw new Error('radians is required');

        var degrees = radians % (2 * Math.PI);
        return degrees * 180 / Math.PI;
    }

    /**
     * Converts an angle in degrees to radians
     *
     * @name degrees2radians
     * @param {number} degrees angle between 0 and 360 degrees
     * @returns {number} angle in radians
     */
    function degrees2radians(degrees) {
        if (degrees === null || degrees === undefined) throw new Error('degrees is required');

        var radians = degrees % 360;
        return radians * Math.PI / 180;
    }

    /**
     * Converts a distance to the requested unit.
     * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
     *
     * @param {number} distance to be converted
     * @param {string} originalUnit of the distance
     * @param {string} [finalUnit=kilometers] returned unit
     * @returns {number} the converted distance
     */
    function convertDistance(distance, originalUnit, finalUnit) {
        if (distance === null || distance === undefined) throw new Error('distance is required');
        if (!(distance >= 0)) throw new Error('distance must be a positive number');

        var convertedDistance = radiansToDistance(distanceToRadians(distance, originalUnit), finalUnit || 'kilometers');
        return convertedDistance;
    }

    /**
     * Converts a area to the requested unit.
     * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeter, acre, mile, yard, foot, inch
     * @param {number} area to be converted
     * @param {string} [originalUnit=meters] of the distance
     * @param {string} [finalUnit=kilometers] returned unit
     * @returns {number} the converted distance
     */
    function convertArea(area, originalUnit, finalUnit) {
        if (area === null || area === undefined) throw new Error('area is required');
        if (!(area >= 0)) throw new Error('area must be a positive number');

        var startFactor = areaFactors[originalUnit || 'meters'];
        if (!startFactor) throw new Error('invalid original units');

        var finalFactor = areaFactors[finalUnit || 'kilometers'];
        if (!finalFactor) throw new Error('invalid final units');

        return area / startFactor * finalFactor;
    }

    /**
     * isNumber
     *
     * @param {*} num Number to validate
     * @returns {boolean} true/false
     * @example
     * turf.isNumber(123)
     * //=true
     * turf.isNumber('foo')
     * //=false
     */
    function isNumber(num) {
        return !isNaN(num) && num !== null && !Array.isArray(num);
    }

    module.exports = {
        feature: feature,
        geometry: geometry,
        featureCollection: featureCollection,
        geometryCollection: geometryCollection,
        point: point,
        multiPoint: multiPoint,
        lineString: lineString,
        multiLineString: multiLineString,
        polygon: polygon,
        multiPolygon: multiPolygon,
        radiansToDistance: radiansToDistance,
        distanceToRadians: distanceToRadians,
        distanceToDegrees: distanceToDegrees,
        radians2degrees: radians2degrees,
        degrees2radians: degrees2radians,
        bearingToAngle: bearingToAngle,
        convertDistance: convertDistance,
        convertArea: convertArea,
        round: round,
        isNumber: isNumber
    };
});
$__System.registerDynamic('19', [], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /**
     * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.
     *
     * @name getCoord
     * @param {Array<number>|Geometry<Point>|Feature<Point>} obj Object
     * @returns {Array<number>} coordinates
     * @example
     * var pt = turf.point([10, 10]);
     *
     * var coord = turf.getCoord(pt);
     * //= [10, 10]
     */
    function getCoord(obj) {
        if (!obj) throw new Error('obj is required');

        var coordinates = getCoords(obj);

        // getCoord() must contain at least two numbers (Point)
        if (coordinates.length > 1 && typeof coordinates[0] === 'number' && typeof coordinates[1] === 'number') {
            return coordinates;
        } else {
            throw new Error('Coordinate is not a valid Point');
        }
    }

    /**
     * Unwrap coordinates from a Feature, Geometry Object or an Array of numbers
     *
     * @name getCoords
     * @param {Array<number>|Geometry|Feature} obj Object
     * @returns {Array<number>} coordinates
     * @example
     * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);
     *
     * var coord = turf.getCoords(poly);
     * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]
     */
    function getCoords(obj) {
        if (!obj) throw new Error('obj is required');
        var coordinates;

        // Array of numbers
        if (obj.length) {
            coordinates = obj;

            // Geometry Object
        } else if (obj.coordinates) {
            coordinates = obj.coordinates;

            // Feature
        } else if (obj.geometry && obj.geometry.coordinates) {
            coordinates = obj.geometry.coordinates;
        }
        // Checks if coordinates contains a number
        if (coordinates) {
            containsNumber(coordinates);
            return coordinates;
        }
        throw new Error('No valid coordinates');
    }

    /**
     * Checks if coordinates contains a number
     *
     * @name containsNumber
     * @param {Array<any>} coordinates GeoJSON Coordinates
     * @returns {boolean} true if Array contains a number
     */
    function containsNumber(coordinates) {
        if (coordinates.length > 1 && typeof coordinates[0] === 'number' && typeof coordinates[1] === 'number') {
            return true;
        }

        if (Array.isArray(coordinates[0]) && coordinates[0].length) {
            return containsNumber(coordinates[0]);
        }
        throw new Error('coordinates must only contain numbers');
    }

    /**
     * Enforce expectations about types of GeoJSON objects for Turf.
     *
     * @name geojsonType
     * @param {GeoJSON} value any GeoJSON object
     * @param {string} type expected GeoJSON type
     * @param {string} name name of calling function
     * @throws {Error} if value is not the expected type.
     */
    function geojsonType(value, type, name) {
        if (!type || !name) throw new Error('type and name required');

        if (!value || value.type !== type) {
            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);
        }
    }

    /**
     * Enforce expectations about types of {@link Feature} inputs for Turf.
     * Internally this uses {@link geojsonType} to judge geometry types.
     *
     * @name featureOf
     * @param {Feature} feature a feature with an expected geometry type
     * @param {string} type expected GeoJSON type
     * @param {string} name name of calling function
     * @throws {Error} error if value is not the expected type.
     */
    function featureOf(feature, type, name) {
        if (!feature) throw new Error('No feature passed');
        if (!name) throw new Error('.featureOf() requires a name');
        if (!feature || feature.type !== 'Feature' || !feature.geometry) {
            throw new Error('Invalid input to ' + name + ', Feature with geometry required');
        }
        if (!feature.geometry || feature.geometry.type !== type) {
            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);
        }
    }

    /**
     * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.
     * Internally this uses {@link geojsonType} to judge geometry types.
     *
     * @name collectionOf
     * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged
     * @param {string} type expected GeoJSON type
     * @param {string} name name of calling function
     * @throws {Error} if value is not the expected type.
     */
    function collectionOf(featureCollection, type, name) {
        if (!featureCollection) throw new Error('No featureCollection passed');
        if (!name) throw new Error('.collectionOf() requires a name');
        if (!featureCollection || featureCollection.type !== 'FeatureCollection') {
            throw new Error('Invalid input to ' + name + ', FeatureCollection required');
        }
        for (var i = 0; i < featureCollection.features.length; i++) {
            var feature = featureCollection.features[i];
            if (!feature || feature.type !== 'Feature' || !feature.geometry) {
                throw new Error('Invalid input to ' + name + ', Feature with geometry required');
            }
            if (!feature.geometry || feature.geometry.type !== type) {
                throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);
            }
        }
    }

    /**
     * Get Geometry from Feature or Geometry Object
     *
     * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object
     * @returns {Geometry|null} GeoJSON Geometry Object
     * @throws {Error} if geojson is not a Feature or Geometry Object
     * @example
     * var point = {
     *   "type": "Feature",
     *   "properties": {},
     *   "geometry": {
     *     "type": "Point",
     *     "coordinates": [110, 40]
     *   }
     * }
     * var geom = turf.getGeom(point)
     * //={"type": "Point", "coordinates": [110, 40]}
     */
    function getGeom(geojson) {
        if (!geojson) throw new Error('geojson is required');
        if (geojson.geometry !== undefined) return geojson.geometry;
        if (geojson.coordinates || geojson.geometries) return geojson;
        throw new Error('geojson must be a valid Feature or Geometry Object');
    }

    /**
     * Get Geometry Type from Feature or Geometry Object
     *
     * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object
     * @returns {string} GeoJSON Geometry Type
     * @throws {Error} if geojson is not a Feature or Geometry Object
     * @example
     * var point = {
     *   "type": "Feature",
     *   "properties": {},
     *   "geometry": {
     *     "type": "Point",
     *     "coordinates": [110, 40]
     *   }
     * }
     * var geom = turf.getGeomType(point)
     * //="Point"
     */
    function getGeomType(geojson) {
        if (!geojson) throw new Error('geojson is required');
        var geom = getGeom(geojson);
        if (geom) return geom.type;
    }

    module.exports = {
        geojsonType: geojsonType,
        collectionOf: collectionOf,
        featureOf: featureOf,
        getCoord: getCoord,
        getCoords: getCoords,
        containsNumber: containsNumber,
        getGeom: getGeom,
        getGeomType: getGeomType
    };
});
$__System.registerDynamic('16', [], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /**
     * GeoJSON BBox
     *
     * @typedef {[number, number, number, number]} BBox
     */

    /**
     * GeoJSON Id
     *
     * @typedef {(number|string)} Id
     */

    /**
     * GeoJSON FeatureCollection
     *
     * @typedef {Object} FeatureCollection
     * @property {string} type
     * @property {?Id} id
     * @property {?BBox} bbox
     * @property {Feature[]} features
     */

    /**
     * GeoJSON Feature
     *
     * @typedef {Object} Feature
     * @property {string} type
     * @property {?Id} id
     * @property {?BBox} bbox
     * @property {*} properties
     * @property {Geometry} geometry
     */

    /**
     * GeoJSON Geometry
     *
     * @typedef {Object} Geometry
     * @property {string} type
     * @property {any[]} coordinates
     */

    /**
     * Callback for coordEach
     *
     * @callback coordEachCallback
     * @param {Array<number>} currentCoord The current coordinate being processed.
     * @param {number} coordIndex The current index of the coordinate being processed.
     * Starts at index 0.
     * @param {number} featureIndex The current index of the feature being processed.
     * @param {number} featureSubIndex The current subIndex of the feature being processed.
     */

    /**
     * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()
     *
     * @name coordEach
     * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
     * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, featureSubIndex)
     * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
     * @example
     * var features = turf.featureCollection([
     *   turf.point([26, 37], {"foo": "bar"}),
     *   turf.point([36, 53], {"hello": "world"})
     * ]);
     *
     * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, featureSubIndex) {
     *   //=currentCoord
     *   //=coordIndex
     *   //=featureIndex
     *   //=featureSubIndex
     * });
     */
    function coordEach(geojson, callback, excludeWrapCoord) {
        // Handles null Geometry -- Skips this GeoJSON
        if (geojson === null) return;
        var featureIndex,
            geometryIndex,
            j,
            k,
            l,
            geometry,
            stopG,
            coords,
            geometryMaybeCollection,
            wrapShrink = 0,
            coordIndex = 0,
            isGeometryCollection,
            type = geojson.type,
            isFeatureCollection = type === 'FeatureCollection',
            isFeature = type === 'Feature',
            stop = isFeatureCollection ? geojson.features.length : 1;

        // This logic may look a little weird. The reason why it is that way
        // is because it's trying to be fast. GeoJSON supports multiple kinds
        // of objects at its root: FeatureCollection, Features, Geometries.
        // This function has the responsibility of handling all of them, and that
        // means that some of the `for` loops you see below actually just don't apply
        // to certain inputs. For instance, if you give this just a
        // Point geometry, then both loops are short-circuited and all we do
        // is gradually rename the input until it's called 'geometry'.
        //
        // This also aims to allocate as few resources as possible: just a
        // few numbers and booleans, rather than any temporary arrays as would
        // be required with the normalization approach.
        for (featureIndex = 0; featureIndex < stop; featureIndex++) {
            var featureSubIndex = 0;

            geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;
            isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === 'GeometryCollection' : false;
            stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

            for (geometryIndex = 0; geometryIndex < stopG; geometryIndex++) {
                geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geometryIndex] : geometryMaybeCollection;

                // Handles null Geometry -- Skips this geometry
                if (geometry === null) continue;
                coords = geometry.coordinates;
                var geomType = geometry.type;

                wrapShrink = excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon') ? 1 : 0;

                switch (geomType) {
                    case null:
                        break;
                    case 'Point':
                        callback(coords, coordIndex, featureIndex, featureSubIndex);
                        coordIndex++;
                        featureSubIndex++;
                        break;
                    case 'LineString':
                    case 'MultiPoint':
                        for (j = 0; j < coords.length; j++) {
                            callback(coords[j], coordIndex, featureIndex, featureSubIndex);
                            coordIndex++;
                            featureSubIndex++;
                        }
                        break;
                    case 'Polygon':
                    case 'MultiLineString':
                        for (j = 0; j < coords.length; j++) for (k = 0; k < coords[j].length - wrapShrink; k++) {
                            callback(coords[j][k], coordIndex, featureIndex, featureSubIndex);
                            coordIndex++;
                            featureSubIndex++;
                        }
                        break;
                    case 'MultiPolygon':
                        for (j = 0; j < coords.length; j++) for (k = 0; k < coords[j].length; k++) for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                            callback(coords[j][k][l], coordIndex, featureIndex, featureSubIndex);
                            coordIndex++;
                            featureSubIndex++;
                        }
                        break;
                    case 'GeometryCollection':
                        for (j = 0; j < geometry.geometries.length; j++) coordEach(geometry.geometries[j], callback, excludeWrapCoord);
                        break;
                    default:
                        throw new Error('Unknown Geometry Type');
                }
            }
        }
    }

    /**
     * Callback for coordReduce
     *
     * The first time the callback function is called, the values provided as arguments depend
     * on whether the reduce method has an initialValue argument.
     *
     * If an initialValue is provided to the reduce method:
     *  - The previousValue argument is initialValue.
     *  - The currentValue argument is the value of the first element present in the array.
     *
     * If an initialValue is not provided:
     *  - The previousValue argument is the value of the first element present in the array.
     *  - The currentValue argument is the value of the second element present in the array.
     *
     * @callback coordReduceCallback
     * @param {*} previousValue The accumulated value previously returned in the last invocation
     * of the callback, or initialValue, if supplied.
     * @param {Array<number>} currentCoord The current coordinate being processed.
     * @param {number} coordIndex The current index of the coordinate being processed.
     * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
     * @param {number} featureIndex The current index of the feature being processed.
     * @param {number} featureSubIndex The current subIndex of the feature being processed.
     */

    /**
     * Reduce coordinates in any GeoJSON object, similar to Array.reduce()
     *
     * @name coordReduce
     * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object
     * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)
     * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
     * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
     * @returns {*} The value that results from the reduction.
     * @example
     * var features = turf.featureCollection([
     *   turf.point([26, 37], {"foo": "bar"}),
     *   turf.point([36, 53], {"hello": "world"})
     * ]);
     *
     * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, featureSubIndex) {
     *   //=previousValue
     *   //=currentCoord
     *   //=coordIndex
     *   //=featureIndex
     *   //=featureSubIndex
     *   return currentCoord;
     * });
     */
    function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
        var previousValue = initialValue;
        coordEach(geojson, function (currentCoord, coordIndex, featureIndex, featureSubIndex) {
            if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, featureSubIndex);
        }, excludeWrapCoord);
        return previousValue;
    }

    /**
     * Callback for propEach
     *
     * @callback propEachCallback
     * @param {Object} currentProperties The current properties being processed.
     * @param {number} featureIndex The index of the current element being processed in the
     * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
     */

    /**
     * Iterate over properties in any GeoJSON object, similar to Array.forEach()
     *
     * @name propEach
     * @param {(FeatureCollection|Feature)} geojson any GeoJSON object
     * @param {Function} callback a method that takes (currentProperties, featureIndex)
     * @example
     * var features = turf.featureCollection([
     *     turf.point([26, 37], {foo: 'bar'}),
     *     turf.point([36, 53], {hello: 'world'})
     * ]);
     *
     * turf.propEach(features, function (currentProperties, featureIndex) {
     *   //=currentProperties
     *   //=featureIndex
     * });
     */
    function propEach(geojson, callback) {
        var i;
        switch (geojson.type) {
            case 'FeatureCollection':
                for (i = 0; i < geojson.features.length; i++) {
                    callback(geojson.features[i].properties, i);
                }
                break;
            case 'Feature':
                callback(geojson.properties, 0);
                break;
        }
    }

    /**
     * Callback for propReduce
     *
     * The first time the callback function is called, the values provided as arguments depend
     * on whether the reduce method has an initialValue argument.
     *
     * If an initialValue is provided to the reduce method:
     *  - The previousValue argument is initialValue.
     *  - The currentValue argument is the value of the first element present in the array.
     *
     * If an initialValue is not provided:
     *  - The previousValue argument is the value of the first element present in the array.
     *  - The currentValue argument is the value of the second element present in the array.
     *
     * @callback propReduceCallback
     * @param {*} previousValue The accumulated value previously returned in the last invocation
     * of the callback, or initialValue, if supplied.
     * @param {*} currentProperties The current properties being processed.
     * @param {number} featureIndex The index of the current element being processed in the
     * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
     */

    /**
     * Reduce properties in any GeoJSON object into a single value,
     * similar to how Array.reduce works. However, in this case we lazily run
     * the reduction, so an array of all properties is unnecessary.
     *
     * @name propReduce
     * @param {(FeatureCollection|Feature)} geojson any GeoJSON object
     * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)
     * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
     * @returns {*} The value that results from the reduction.
     * @example
     * var features = turf.featureCollection([
     *     turf.point([26, 37], {foo: 'bar'}),
     *     turf.point([36, 53], {hello: 'world'})
     * ]);
     *
     * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {
     *   //=previousValue
     *   //=currentProperties
     *   //=featureIndex
     *   return currentProperties
     * });
     */
    function propReduce(geojson, callback, initialValue) {
        var previousValue = initialValue;
        propEach(geojson, function (currentProperties, featureIndex) {
            if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;else previousValue = callback(previousValue, currentProperties, featureIndex);
        });
        return previousValue;
    }

    /**
     * Callback for featureEach
     *
     * @callback featureEachCallback
     * @param {Feature<any>} currentFeature The current feature being processed.
     * @param {number} featureIndex The index of the current element being processed in the
     * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
     */

    /**
     * Iterate over features in any GeoJSON object, similar to
     * Array.forEach.
     *
     * @name featureEach
     * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
     * @param {Function} callback a method that takes (currentFeature, featureIndex)
     * @example
     * var features = turf.featureCollection([
     *   turf.point([26, 37], {foo: 'bar'}),
     *   turf.point([36, 53], {hello: 'world'})
     * ]);
     *
     * turf.featureEach(features, function (currentFeature, featureIndex) {
     *   //=currentFeature
     *   //=featureIndex
     * });
     */
    function featureEach(geojson, callback) {
        if (geojson.type === 'Feature') {
            callback(geojson, 0);
        } else if (geojson.type === 'FeatureCollection') {
            for (var i = 0; i < geojson.features.length; i++) {
                callback(geojson.features[i], i);
            }
        }
    }

    /**
     * Callback for featureReduce
     *
     * The first time the callback function is called, the values provided as arguments depend
     * on whether the reduce method has an initialValue argument.
     *
     * If an initialValue is provided to the reduce method:
     *  - The previousValue argument is initialValue.
     *  - The currentValue argument is the value of the first element present in the array.
     *
     * If an initialValue is not provided:
     *  - The previousValue argument is the value of the first element present in the array.
     *  - The currentValue argument is the value of the second element present in the array.
     *
     * @callback featureReduceCallback
     * @param {*} previousValue The accumulated value previously returned in the last invocation
     * of the callback, or initialValue, if supplied.
     * @param {Feature} currentFeature The current Feature being processed.
     * @param {number} featureIndex The index of the current element being processed in the
     * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
     */

    /**
     * Reduce features in any GeoJSON object, similar to Array.reduce().
     *
     * @name featureReduce
     * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
     * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)
     * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
     * @returns {*} The value that results from the reduction.
     * @example
     * var features = turf.featureCollection([
     *   turf.point([26, 37], {"foo": "bar"}),
     *   turf.point([36, 53], {"hello": "world"})
     * ]);
     *
     * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {
     *   //=previousValue
     *   //=currentFeature
     *   //=featureIndex
     *   return currentFeature
     * });
     */
    function featureReduce(geojson, callback, initialValue) {
        var previousValue = initialValue;
        featureEach(geojson, function (currentFeature, featureIndex) {
            if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;else previousValue = callback(previousValue, currentFeature, featureIndex);
        });
        return previousValue;
    }

    /**
     * Get all coordinates from any GeoJSON object.
     *
     * @name coordAll
     * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
     * @returns {Array<Array<number>>} coordinate position array
     * @example
     * var features = turf.featureCollection([
     *   turf.point([26, 37], {foo: 'bar'}),
     *   turf.point([36, 53], {hello: 'world'})
     * ]);
     *
     * var coords = turf.coordAll(features);
     * //= [[26, 37], [36, 53]]
     */
    function coordAll(geojson) {
        var coords = [];
        coordEach(geojson, function (coord) {
            coords.push(coord);
        });
        return coords;
    }

    /**
     * Callback for geomEach
     *
     * @callback geomEachCallback
     * @param {Geometry} currentGeometry The current geometry being processed.
     * @param {number} currentIndex The index of the current element being processed in the
     * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
     * @param {number} currentProperties The current feature properties being processed.
     */

    /**
     * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()
     *
     * @name geomEach
     * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
     * @param {Function} callback a method that takes (currentGeometry, featureIndex, currentProperties)
     * @example
     * var features = turf.featureCollection([
     *     turf.point([26, 37], {foo: 'bar'}),
     *     turf.point([36, 53], {hello: 'world'})
     * ]);
     *
     * turf.geomEach(features, function (currentGeometry, featureIndex, currentProperties) {
     *   //=currentGeometry
     *   //=featureIndex
     *   //=currentProperties
     * });
     */
    function geomEach(geojson, callback) {
        var i,
            j,
            g,
            geometry,
            stopG,
            geometryMaybeCollection,
            isGeometryCollection,
            geometryProperties,
            featureIndex = 0,
            isFeatureCollection = geojson.type === 'FeatureCollection',
            isFeature = geojson.type === 'Feature',
            stop = isFeatureCollection ? geojson.features.length : 1;

        // This logic may look a little weird. The reason why it is that way
        // is because it's trying to be fast. GeoJSON supports multiple kinds
        // of objects at its root: FeatureCollection, Features, Geometries.
        // This function has the responsibility of handling all of them, and that
        // means that some of the `for` loops you see below actually just don't apply
        // to certain inputs. For instance, if you give this just a
        // Point geometry, then both loops are short-circuited and all we do
        // is gradually rename the input until it's called 'geometry'.
        //
        // This also aims to allocate as few resources as possible: just a
        // few numbers and booleans, rather than any temporary arrays as would
        // be required with the normalization approach.
        for (i = 0; i < stop; i++) {

            geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;
            geometryProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};
            isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === 'GeometryCollection' : false;
            stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

            for (g = 0; g < stopG; g++) {
                geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;

                // Handle null Geometry
                if (geometry === null) {
                    callback(null, featureIndex, geometryProperties);
                    featureIndex++;
                    continue;
                }
                switch (geometry.type) {
                    case 'Point':
                    case 'LineString':
                    case 'MultiPoint':
                    case 'Polygon':
                    case 'MultiLineString':
                    case 'MultiPolygon':
                        {
                            callback(geometry, featureIndex, geometryProperties);
                            featureIndex++;
                            break;
                        }
                    case 'GeometryCollection':
                        {
                            for (j = 0; j < geometry.geometries.length; j++) {
                                callback(geometry.geometries[j], featureIndex, geometryProperties);
                                featureIndex++;
                            }
                            break;
                        }
                    default:
                        throw new Error('Unknown Geometry Type');
                }
            }
        }
    }

    /**
     * Callback for geomReduce
     *
     * The first time the callback function is called, the values provided as arguments depend
     * on whether the reduce method has an initialValue argument.
     *
     * If an initialValue is provided to the reduce method:
     *  - The previousValue argument is initialValue.
     *  - The currentValue argument is the value of the first element present in the array.
     *
     * If an initialValue is not provided:
     *  - The previousValue argument is the value of the first element present in the array.
     *  - The currentValue argument is the value of the second element present in the array.
     *
     * @callback geomReduceCallback
     * @param {*} previousValue The accumulated value previously returned in the last invocation
     * of the callback, or initialValue, if supplied.
     * @param {Geometry} currentGeometry The current Feature being processed.
     * @param {number} currentIndex The index of the current element being processed in the
     * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
     * @param {Object} currentProperties The current feature properties being processed.
     */

    /**
     * Reduce geometry in any GeoJSON object, similar to Array.reduce().
     *
     * @name geomReduce
     * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
     * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, currentProperties)
     * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
     * @returns {*} The value that results from the reduction.
     * @example
     * var features = turf.featureCollection([
     *     turf.point([26, 37], {foo: 'bar'}),
     *     turf.point([36, 53], {hello: 'world'})
     * ]);
     *
     * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, currentProperties) {
     *   //=previousValue
     *   //=currentGeometry
     *   //=featureIndex
     *   //=currentProperties
     *   return currentGeometry
     * });
     */
    function geomReduce(geojson, callback, initialValue) {
        var previousValue = initialValue;
        geomEach(geojson, function (currentGeometry, currentIndex, currentProperties) {
            if (currentIndex === 0 && initialValue === undefined) previousValue = currentGeometry;else previousValue = callback(previousValue, currentGeometry, currentIndex, currentProperties);
        });
        return previousValue;
    }

    /**
     * Callback for flattenEach
     *
     * @callback flattenEachCallback
     * @param {Feature} currentFeature The current flattened feature being processed.
     * @param {number} featureIndex The index of the current element being processed in the
     * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
     * @param {number} featureSubIndex The subindex of the current element being processed in the
     * array. Starts at index 0 and increases if the flattened feature was a multi-geometry.
     */

    /**
     * Iterate over flattened features in any GeoJSON object, similar to
     * Array.forEach.
     *
     * @name flattenEach
     * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
     * @param {Function} callback a method that takes (currentFeature, featureIndex, featureSubIndex)
     * @example
     * var features = turf.featureCollection([
     *     turf.point([26, 37], {foo: 'bar'}),
     *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
     * ]);
     *
     * turf.flattenEach(features, function (currentFeature, featureIndex, featureSubIndex) {
     *   //=currentFeature
     *   //=featureIndex
     *   //=featureSubIndex
     * });
     */
    function flattenEach(geojson, callback) {
        geomEach(geojson, function (geometry, featureIndex, properties) {
            // Callback for single geometry
            var type = geometry === null ? null : geometry.type;
            switch (type) {
                case null:
                case 'Point':
                case 'LineString':
                case 'Polygon':
                    callback(feature(geometry, properties), featureIndex, 0);
                    return;
            }

            var geomType;

            // Callback for multi-geometry
            switch (type) {
                case 'MultiPoint':
                    geomType = 'Point';
                    break;
                case 'MultiLineString':
                    geomType = 'LineString';
                    break;
                case 'MultiPolygon':
                    geomType = 'Polygon';
                    break;
            }

            geometry.coordinates.forEach(function (coordinate, featureSubIndex) {
                var geom = {
                    type: geomType,
                    coordinates: coordinate
                };
                callback(feature(geom, properties), featureIndex, featureSubIndex);
            });
        });
    }

    /**
     * Callback for flattenReduce
     *
     * The first time the callback function is called, the values provided as arguments depend
     * on whether the reduce method has an initialValue argument.
     *
     * If an initialValue is provided to the reduce method:
     *  - The previousValue argument is initialValue.
     *  - The currentValue argument is the value of the first element present in the array.
     *
     * If an initialValue is not provided:
     *  - The previousValue argument is the value of the first element present in the array.
     *  - The currentValue argument is the value of the second element present in the array.
     *
     * @callback flattenReduceCallback
     * @param {*} previousValue The accumulated value previously returned in the last invocation
     * of the callback, or initialValue, if supplied.
     * @param {Feature} currentFeature The current Feature being processed.
     * @param {number} featureIndex The index of the current element being processed in the
     * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
     * @param {number} featureSubIndex The subindex of the current element being processed in the
     * array. Starts at index 0 and increases if the flattened feature was a multi-geometry.
     */

    /**
     * Reduce flattened features in any GeoJSON object, similar to Array.reduce().
     *
     * @name flattenReduce
     * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object
     * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, featureSubIndex)
     * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
     * @returns {*} The value that results from the reduction.
     * @example
     * var features = turf.featureCollection([
     *     turf.point([26, 37], {foo: 'bar'}),
     *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
     * ]);
     *
     * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, featureSubIndex) {
     *   //=previousValue
     *   //=currentFeature
     *   //=featureIndex
     *   //=featureSubIndex
     *   return currentFeature
     * });
     */
    function flattenReduce(geojson, callback, initialValue) {
        var previousValue = initialValue;
        flattenEach(geojson, function (currentFeature, featureIndex, featureSubIndex) {
            if (featureIndex === 0 && featureSubIndex === 0 && initialValue === undefined) previousValue = currentFeature;else previousValue = callback(previousValue, currentFeature, featureIndex, featureSubIndex);
        });
        return previousValue;
    }

    /**
     * Callback for segmentEach
     *
     * @callback segmentEachCallback
     * @param {Feature<LineString>} currentSegment The current segment being processed.
     * @param {number} featureIndex The index of the current element being processed in the array, starts at index 0.
     * @param {number} featureSubIndex The subindex of the current element being processed in the
     * array. Starts at index 0 and increases for each iterating line segment.
     * @returns {void}
     */

    /**
     * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()
     * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
     *
     * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON
     * @param {Function} callback a method that takes (currentSegment, featureIndex, featureSubIndex)
     * @returns {void}
     * @example
     * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
     *
     * // Iterate over GeoJSON by 2-vertex segments
     * turf.segmentEach(polygon, function (currentSegment, featureIndex, featureSubIndex) {
     *   //= currentSegment
     *   //= featureIndex
     *   //= featureSubIndex
     * });
     *
     * // Calculate the total number of segments
     * var total = 0;
     * var initialValue = 0;
     * turf.segmentEach(polygon, function () {
     *     total++;
     * }, initialValue);
     */
    function segmentEach(geojson, callback) {
        flattenEach(geojson, function (feature, featureIndex) {
            var featureSubIndex = 0;
            // Exclude null Geometries
            if (!feature.geometry) return;
            // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
            var type = feature.geometry.type;
            if (type === 'Point' || type === 'MultiPoint') return;

            // Generate 2-vertex line segments
            coordReduce(feature, function (previousCoords, currentCoord) {
                var currentSegment = lineString([previousCoords, currentCoord], feature.properties);
                callback(currentSegment, featureIndex, featureSubIndex);
                featureSubIndex++;
                return currentCoord;
            });
        });
    }

    /**
     * Callback for segmentReduce
     *
     * The first time the callback function is called, the values provided as arguments depend
     * on whether the reduce method has an initialValue argument.
     *
     * If an initialValue is provided to the reduce method:
     *  - The previousValue argument is initialValue.
     *  - The currentValue argument is the value of the first element present in the array.
     *
     * If an initialValue is not provided:
     *  - The previousValue argument is the value of the first element present in the array.
     *  - The currentValue argument is the value of the second element present in the array.
     *
     * @callback segmentReduceCallback
     * @param {*} [previousValue] The accumulated value previously returned in the last invocation
     * of the callback, or initialValue, if supplied.
     * @param {Feature<LineString>} [currentSegment] The current segment being processed.
     * @param {number} [currentIndex] The index of the current element being processed in the
     * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
     * @param {number} [currentSubIndex] The subindex of the current element being processed in the
     * array. Starts at index 0 and increases for each iterating line segment.
     */

    /**
     * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()
     * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
     *
     * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON
     * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)
     * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
     * @returns {void}
     * @example
     * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
     *
     * // Iterate over GeoJSON by 2-vertex segments
     * turf.segmentReduce(polygon, function (previousSegment, currentSegment, currentIndex, currentSubIndex) {
     *   //= previousSegment
     *   //= currentSegment
     *   //= currentIndex
     *   //= currentSubIndex
     *   return currentSegment
     * });
     *
     * // Calculate the total number of segments
     * var initialValue = 0
     * var total = turf.segmentReduce(polygon, function (previousValue) {
     *     previousValue++;
     *     return previousValue;
     * }, initialValue);
     */
    function segmentReduce(geojson, callback, initialValue) {
        var previousValue = initialValue;
        segmentEach(geojson, function (currentSegment, currentIndex, currentSubIndex) {
            if (currentIndex === 0 && initialValue === undefined) previousValue = currentSegment;else previousValue = callback(previousValue, currentSegment, currentIndex, currentSubIndex);
        });
        return previousValue;
    }

    /**
     * Create Feature
     *
     * @private
     * @param {Geometry} geometry GeoJSON Geometry
     * @param {Object} properties Properties
     * @returns {Feature} GeoJSON Feature
     */
    function feature(geometry, properties) {
        if (geometry === undefined) throw new Error('No geometry passed');

        return {
            type: 'Feature',
            properties: properties || {},
            geometry: geometry
        };
    }

    /**
     * Create LineString
     *
     * @private
     * @param {Array<Array<number>>} coordinates Line Coordinates
     * @param {Object} properties Properties
     * @returns {Feature<LineString>} GeoJSON LineString Feature
     */
    function lineString(coordinates, properties) {
        if (!coordinates) throw new Error('No coordinates passed');
        if (coordinates.length < 2) throw new Error('Coordinates must be an array of two or more positions');

        return {
            type: 'Feature',
            properties: properties || {},
            geometry: {
                type: 'LineString',
                coordinates: coordinates
            }
        };
    }

    /**
     * Callback for lineEach
     *
     * @callback lineEachCallback
     * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.
     * @param {number} lineIndex The index of the current element being processed in the array, starts at index 0.
     * @param {number} lineSubIndex The sub-index of the current line being processed at index 0
     */

    /**
     * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,
     * similar to Array.forEach.
     *
     * @name lineEach
     * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
     * @param {Function} callback a method that takes (currentLine, lineIndex, lineSubIndex)
     * @example
     * var mtLn = turf.multiLineString([
     *   turf.lineString([[26, 37], [35, 45]]),
     *   turf.lineString([[36, 53], [38, 50], [41, 55]])
     * ]);
     *
     * turf.lineEach(mtLn, function (currentLine, lineIndex) {
     *   //=currentLine
     *   //=lineIndex
     * });
     */
    function lineEach(geojson, callback) {
        // validation
        if (!geojson) throw new Error('geojson is required');
        var type = geojson.geometry ? geojson.geometry.type : geojson.type;
        if (!type) throw new Error('invalid geojson');
        if (type === 'FeatureCollection') throw new Error('FeatureCollection is not supported');
        if (type === 'GeometryCollection') throw new Error('GeometryCollection is not supported');
        var coordinates = geojson.geometry ? geojson.geometry.coordinates : geojson.coordinates;
        if (!coordinates) throw new Error('geojson must contain coordinates');

        switch (type) {
            case 'LineString':
                callback(coordinates, 0, 0);
                return;
            case 'Polygon':
            case 'MultiLineString':
                var subIndex = 0;
                for (var line = 0; line < coordinates.length; line++) {
                    if (type === 'MultiLineString') subIndex = line;
                    callback(coordinates[line], line, subIndex);
                }
                return;
            case 'MultiPolygon':
                for (var multi = 0; multi < coordinates.length; multi++) {
                    for (var ring = 0; ring < coordinates[multi].length; ring++) {
                        callback(coordinates[multi][ring], ring, multi);
                    }
                }
                return;
            default:
                throw new Error(type + ' geometry not supported');
        }
    }

    /**
     * Callback for lineReduce
     *
     * The first time the callback function is called, the values provided as arguments depend
     * on whether the reduce method has an initialValue argument.
     *
     * If an initialValue is provided to the reduce method:
     *  - The previousValue argument is initialValue.
     *  - The currentValue argument is the value of the first element present in the array.
     *
     * If an initialValue is not provided:
     *  - The previousValue argument is the value of the first element present in the array.
     *  - The currentValue argument is the value of the second element present in the array.
     *
     * @callback lineReduceCallback
     * @param {*} previousValue The accumulated value previously returned in the last invocation
     * of the callback, or initialValue, if supplied.
     * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.
     * @param {number} lineIndex The index of the current element being processed in the
     * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
     * @param {number} lineSubIndex The sub-index of the current line being processed at index 0
     */

    /**
     * Reduce features in any GeoJSON object, similar to Array.reduce().
     *
     * @name lineReduce
     * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
     * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)
     * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
     * @returns {*} The value that results from the reduction.
     * @example
     * var mtp = turf.multiPolygon([
     *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),
     *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])
     * ]);
     *
     * turf.lineReduce(mtp, function (previousValue, currentLine, lineIndex, lineSubIndex) {
     *   //=previousValue
     *   //=currentLine
     *   //=lineIndex
     *   //=lineSubIndex
     *   return currentLine
     * }, 2);
     */
    function lineReduce(geojson, callback, initialValue) {
        var previousValue = initialValue;
        lineEach(geojson, function (currentLine, lineIndex, lineSubIndex) {
            if (lineIndex === 0 && initialValue === undefined) previousValue = currentLine;else previousValue = callback(previousValue, currentLine, lineIndex, lineSubIndex);
        });
        return previousValue;
    }

    module.exports = {
        coordEach: coordEach,
        coordReduce: coordReduce,
        propEach: propEach,
        propReduce: propReduce,
        featureEach: featureEach,
        featureReduce: featureReduce,
        coordAll: coordAll,
        geomEach: geomEach,
        geomReduce: geomReduce,
        flattenEach: flattenEach,
        flattenReduce: flattenReduce,
        segmentEach: segmentEach,
        segmentReduce: segmentReduce,
        lineEach: lineEach,
        lineReduce: lineReduce
    };
});
$__System.registerDynamic('38', ['c', '19', '16'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    var helpers = $__require('c');
    var getCoords = $__require('19').getCoords;
    var flattenEach = $__require('16').flattenEach;
    var lineString = helpers.lineString;
    var featureCollection = helpers.featureCollection;

    /**
     * Creates a {@link FeatureCollection} of 2-vertex {@link LineString} segments from a {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon}.
     *
     * @name lineSegment
     * @param {Geometry|FeatureCollection|Feature<LineString|MultiLineString|MultiPolygon|Polygon>} geojson GeoJSON Polygon or LineString
     * @returns {FeatureCollection<LineString>} 2-vertex line segments
     * @example
     * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
     * var segments = turf.lineSegment(polygon);
     *
     * //addToMap
     * var addToMap = [polygon, segments]
     */
    module.exports = function (geojson) {
        if (!geojson) throw new Error('geojson is required');

        var results = [];
        flattenEach(geojson, function (feature) {
            lineSegment(feature, results);
        });
        return featureCollection(results);
    };

    /**
     * Line Segment
     *
     * @private
     * @param {Feature<LineString|Polygon>} geojson Line or polygon feature
     * @param {Array} results push to results
     * @returns {void}
     */
    function lineSegment(geojson, results) {
        var coords = [];
        var geometry = geojson.geometry;
        switch (geometry.type) {
            case 'Polygon':
                coords = getCoords(geometry);
                break;
            case 'LineString':
                coords = [getCoords(geometry)];
        }
        coords.forEach(function (coord) {
            var segments = createSegments(coord, geojson.properties);
            segments.forEach(function (segment) {
                segment.id = results.length;
                results.push(segment);
            });
        });
    }

    /**
     * Create Segments from LineString coordinates
     *
     * @private
     * @param {LineString} coords LineString coordinates
     * @param {*} properties GeoJSON properties
     * @returns {Array<Feature<LineString>>} line segments
     */
    function createSegments(coords, properties) {
        var segments = [];
        coords.reduce(function (previousCoords, currentCoords) {
            var segment = lineString([previousCoords, currentCoords], properties);
            segment.bbox = bbox(previousCoords, currentCoords);
            segments.push(segment);
            return currentCoords;
        });
        return segments;
    }

    /**
     * Create BBox between two coordinates (faster than @turf/bbox)
     *
     * @private
     * @param {[number, number]} coords1 Point coordinate
     * @param {[number, number]} coords2 Point coordinate
     * @returns {BBox} [west, south, east, north]
     */
    function bbox(coords1, coords2) {
        var x1 = coords1[0];
        var y1 = coords1[1];
        var x2 = coords2[0];
        var y2 = coords2[1];
        var west = x1 < x2 ? x1 : x2;
        var south = y1 < y2 ? y1 : y2;
        var east = x1 > x2 ? x1 : x2;
        var north = y1 > y2 ? y1 : y2;
        return [west, south, east, north];
    }
});
$__System.registerDynamic('34', ['16', '37', 'c', '19', '38'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    var meta = $__require('16');
    var rbush = $__require('37');
    var helpers = $__require('c');
    var getCoords = $__require('19').getCoords;
    var lineSegment = $__require('38');
    var point = helpers.point;
    var featureEach = meta.featureEach;
    var featureCollection = helpers.featureCollection;

    /**
     * Takes any LineString or Polygon GeoJSON and returns the intersecting point(s).
     *
     * @name lineIntersect
     * @param {Geometry|FeatureCollection|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line1 any LineString or Polygon
     * @param {Geometry|FeatureCollection|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line2 any LineString or Polygon
     * @returns {FeatureCollection<Point>} point(s) that intersect both
     * @example
     * var line1 = turf.lineString([[126, -11], [129, -21]]);
     * var line2 = turf.lineString([[123, -18], [131, -14]]);
     * var intersects = turf.lineIntersect(line1, line2);
     *
     * //addToMap
     * var addToMap = [line1, line2, intersects]
     */
    module.exports = function (line1, line2) {
        var unique = {};
        var results = [];

        // First, normalize geometries to features
        // Then, handle simple 2-vertex segments
        if (line1.type === 'LineString') line1 = helpers.feature(line1);
        if (line2.type === 'LineString') line2 = helpers.feature(line2);
        if (line1.type === 'Feature' && line2.type === 'Feature' && line1.geometry.type === 'LineString' && line2.geometry.type === 'LineString' && line1.geometry.coordinates.length === 2 && line2.geometry.coordinates.length === 2) {
            var intersect = intersects(line1, line2);
            if (intersect) results.push(intersect);
            return featureCollection(results);
        }

        // Handles complex GeoJSON Geometries
        var tree = rbush();
        tree.load(lineSegment(line2));
        featureEach(lineSegment(line1), function (segment) {
            featureEach(tree.search(segment), function (match) {
                var intersect = intersects(segment, match);
                if (intersect) {
                    // prevent duplicate points https://github.com/Turfjs/turf/issues/688
                    var key = getCoords(intersect).join(',');
                    if (!unique[key]) {
                        unique[key] = true;
                        results.push(intersect);
                    }
                }
            });
        });
        return featureCollection(results);
    };

    /**
     * Find a point that intersects LineStrings with two coordinates each
     *
     * @private
     * @param {Feature<LineString>} line1 GeoJSON LineString (Must only contain 2 coordinates)
     * @param {Feature<LineString>} line2 GeoJSON LineString (Must only contain 2 coordinates)
     * @returns {Feature<Point>} intersecting GeoJSON Point
     */
    function intersects(line1, line2) {
        var coords1 = getCoords(line1);
        var coords2 = getCoords(line2);
        if (coords1.length !== 2) {
            throw new Error('<intersects> line1 must only contain 2 coordinates');
        }
        if (coords2.length !== 2) {
            throw new Error('<intersects> line2 must only contain 2 coordinates');
        }
        var x1 = coords1[0][0];
        var y1 = coords1[0][1];
        var x2 = coords1[1][0];
        var y2 = coords1[1][1];
        var x3 = coords2[0][0];
        var y3 = coords2[0][1];
        var x4 = coords2[1][0];
        var y4 = coords2[1][1];
        var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
        var numeA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
        var numeB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);

        if (denom === 0) {
            if (numeA === 0 && numeB === 0) {
                return null;
            }
            return null;
        }

        var uA = numeA / denom;
        var uB = numeB / denom;

        if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {
            var x = x1 + uA * (x2 - x1);
            var y = y1 + uA * (y2 - y1);
            return point([x, y]);
        }
        return null;
    }
});
$__System.register('a', ['c', '14', '1b', '1c', '1f', '25', '2a', '26', '32', '35', '34'], function (_export, _context) {
    "use strict";

    var turf_helpers, turf_concave, turf_simplify, turf_along, turf_union, turf_buffer, turf_inside, turk_kinks, turf_unkink, turf_line_slice, turf_line_intersect, beginsWith, endsWith, Wkt, arrayProto, splice, freeGlobal, freeSelf, root, Symbol, objectProto$1, hasOwnProperty$1, nativeObjectToString, symToStringTag$1, objectProto$2, nativeObjectToString$1, nullTag, undefinedTag, symToStringTag, asyncTag, funcTag, genTag, proxyTag, coreJsData, maskSrcKey, funcProto$1, funcToString$1, reRegExpChar, reIsHostCtor, funcProto, objectProto, funcToString, hasOwnProperty, reIsNative, Map, nativeCreate, HASH_UNDEFINED, objectProto$3, hasOwnProperty$2, objectProto$4, hasOwnProperty$3, HASH_UNDEFINED$1, LARGE_ARRAY_SIZE, HASH_UNDEFINED$2, COMPARE_PARTIAL_FLAG$2, COMPARE_UNORDERED_FLAG$1, Uint8Array, COMPARE_PARTIAL_FLAG$3, COMPARE_UNORDERED_FLAG$2, boolTag, dateTag, errorTag, mapTag, numberTag, regexpTag, setTag, stringTag, symbolTag, arrayBufferTag, dataViewTag, symbolProto, symbolValueOf, isArray, objectProto$7, propertyIsEnumerable, nativeGetSymbols, getSymbols, argsTag$1, objectProto$9, hasOwnProperty$7, propertyIsEnumerable$1, isArguments, freeExports, freeModule, moduleExports, Buffer, nativeIsBuffer, isBuffer, MAX_SAFE_INTEGER, reIsUint, MAX_SAFE_INTEGER$1, argsTag$2, arrayTag$1, boolTag$1, dateTag$1, errorTag$1, funcTag$1, mapTag$1, numberTag$1, objectTag$1, regexpTag$1, setTag$1, stringTag$1, weakMapTag, arrayBufferTag$1, dataViewTag$1, float32Tag, float64Tag, int8Tag, int16Tag, int32Tag, uint8Tag, uint8ClampedTag, uint16Tag, uint32Tag, typedArrayTags, freeExports$1, freeModule$1, moduleExports$1, freeProcess, nodeUtil, nodeIsTypedArray, isTypedArray, objectProto$8, hasOwnProperty$6, objectProto$11, nativeKeys, objectProto$10, hasOwnProperty$8, COMPARE_PARTIAL_FLAG$4, objectProto$6, hasOwnProperty$5, DataView, Promise, Set, WeakMap, mapTag$2, objectTag$2, promiseTag, setTag$2, weakMapTag$1, dataViewTag$2, dataViewCtorString, mapCtorString, promiseCtorString, setCtorString, weakMapCtorString, getTag, getTag$1, COMPARE_PARTIAL_FLAG$1, argsTag, arrayTag, objectTag, objectProto$5, hasOwnProperty$4, COMPARE_PARTIAL_FLAG, COMPARE_UNORDERED_FLAG, symbolTag$1, reIsDeepProp, reIsPlainProp, FUNC_ERROR_TEXT, MAX_MEMOIZE_SIZE, reLeadingDot, rePropName, reEscapeChar, stringToPath, INFINITY, symbolProto$1, symbolToString, INFINITY$1, COMPARE_PARTIAL_FLAG$5, COMPARE_UNORDERED_FLAG$3, baseFor, baseEach, rsAstralRange$1, rsComboMarksRange$1, reComboHalfMarksRange$1, rsComboSymbolsRange$1, rsComboRange$1, rsVarRange$1, rsAstral, rsCombo, rsFitz, rsModifier, rsNonAstral, rsRegional, rsSurrPair, rsZWJ$1, reOptMod, rsOptVar, rsOptJoin, rsSeq, rsSymbol, reUnicode, turf_linestring, debug, warn, turf_linestring$1, turf_linestring$2, turf_point, turf_linestring$3, turf_featurecollection, ig_turfhelper;


    function Wicket$1() {
        return new Wkt.Wkt();
    }

    /**
     * A specialized version of `_.map` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
        var index = -1,
            length = array == null ? 0 : array.length,
            result = Array(length);

        while (++index < length) {
            result[index] = iteratee(array[index], index, array);
        }
        return result;
    }

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
    }

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
        return value === other || value !== value && other !== other;
    }

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
            if (eq(array[length][0], key)) {
                return length;
            }
        }
        return -1;
    }

    /** Used for built-in method references. */


    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
        var data = this.__data__,
            index = assocIndexOf(data, key);

        if (index < 0) {
            return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
            data.pop();
        } else {
            splice.call(data, index, 1);
        }
        --this.size;
        return true;
    }

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
        var data = this.__data__,
            index = assocIndexOf(data, key);

        return index < 0 ? undefined : data[index][1];
    }

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
    }

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
        var data = this.__data__,
            index = assocIndexOf(data, key);

        if (index < 0) {
            ++this.size;
            data.push([key, value]);
        } else {
            data[index][1] = value;
        }
        return this;
    }

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
        var index = -1,
            length = entries == null ? 0 : entries.length;

        this.clear();
        while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
        }
    }

    // Add methods to `ListCache`.


    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
    }

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
        var data = this.__data__,
            result = data['delete'](key);

        this.size = data.size;
        return result;
    }

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
        return this.__data__.get(key);
    }

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
        return this.__data__.has(key);
    }

    /** Detect free variable `global` from Node.js. */


    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
        var isOwn = hasOwnProperty$1.call(value, symToStringTag$1),
            tag = value[symToStringTag$1];

        try {
            value[symToStringTag$1] = undefined;
            var unmasked = true;
        } catch (e) {}

        var result = nativeObjectToString.call(value);
        if (unmasked) {
            if (isOwn) {
                value[symToStringTag$1] = tag;
            } else {
                delete value[symToStringTag$1];
            }
        }
        return result;
    }

    /** Used for built-in method references. */


    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
        return nativeObjectToString$1.call(value);
    }

    /** `Object#toString` result references. */


    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
        if (value == null) {
            return value === undefined ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
        var type = typeof value;
        return value != null && (type == 'object' || type == 'function');
    }

    /** `Object#toString` result references. */


    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
        if (!isObject(value)) {
            return false;
        }
        // The use of `Object#toString` avoids issues with the `typeof` operator
        // in Safari 9 which returns 'object' for typed arrays and other constructors.
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /** Used to detect overreaching core-js shims. */


    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
    }

    /** Used for built-in method references. */


    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
        if (func != null) {
            try {
                return funcToString$1.call(func);
            } catch (e) {}
            try {
                return func + '';
            } catch (e) {}
        }
        return '';
    }

    /**
     * Used to match `RegExp`
     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
     */


    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
            return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
    }

    /**
     * Gets the value at `key` of `object`.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function getValue(object, key) {
        return object == null ? undefined : object[key];
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : undefined;
    }

    /* Built-in method references that are verified to be native. */


    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
    }

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
    }

    /** Used to stand-in for `undefined` hash values. */


    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
            var result = data[key];
            return result === HASH_UNDEFINED ? undefined : result;
        }
        return hasOwnProperty$2.call(data, key) ? data[key] : undefined;
    }

    /** Used for built-in method references. */


    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== undefined : hasOwnProperty$3.call(data, key);
    }

    /** Used to stand-in for `undefined` hash values. */


    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED$1 : value;
        return this;
    }

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
        var index = -1,
            length = entries == null ? 0 : entries.length;

        this.clear();
        while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
        }
    }

    // Add methods to `Hash`.


    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
            'hash': new Hash(),
            'map': new (Map || ListCache)(),
            'string': new Hash()
        };
    }

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
        var type = typeof value;
        return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
    }

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
        var data = map.__data__;
        return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
    }

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
        var result = getMapData(this, key)['delete'](key);
        this.size -= result ? 1 : 0;
        return result;
    }

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
        return getMapData(this, key).get(key);
    }

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
        return getMapData(this, key).has(key);
    }

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
        var data = getMapData(this, key),
            size = data.size;

        data.set(key, value);
        this.size += data.size == size ? 0 : 1;
        return this;
    }

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
        var index = -1,
            length = entries == null ? 0 : entries.length;

        this.clear();
        while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
        }
    }

    // Add methods to `MapCache`.


    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([key, value]);
                this.size = ++data.size;
                return this;
            }
            data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
    }

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
    }

    // Add methods to `Stack`.


    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED$2);
        return this;
    }

    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
    function setCacheHas(value) {
        return this.__data__.has(value);
    }

    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
        var index = -1,
            length = values == null ? 0 : values.length;

        this.__data__ = new MapCache();
        while (++index < length) {
            this.add(values[index]);
        }
    }

    // Add methods to `SetCache`.


    /**
     * A specialized version of `_.some` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function arraySome(array, predicate) {
        var index = -1,
            length = array == null ? 0 : array.length;

        while (++index < length) {
            if (predicate(array[index], index, array)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Checks if a `cache` value for `key` exists.
     *
     * @private
     * @param {Object} cache The cache to query.
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function cacheHas(cache, key) {
        return cache.has(key);
    }

    /** Used to compose bitmasks for value comparisons. */


    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2,
            arrLength = array.length,
            othLength = other.length;

        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
        }
        // Assume cyclic values are equal.
        var stacked = stack.get(array);
        if (stacked && stack.get(other)) {
            return stacked == other;
        }
        var index = -1,
            result = true,
            seen = bitmask & COMPARE_UNORDERED_FLAG$1 ? new SetCache() : undefined;

        stack.set(array, other);
        stack.set(other, array);

        // Ignore non-index properties.
        while (++index < arrLength) {
            var arrValue = array[index],
                othValue = other[index];

            if (customizer) {
                var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined) {
                if (compared) {
                    continue;
                }
                result = false;
                break;
            }
            // Recursively compare arrays (susceptible to call stack limits).
            if (seen) {
                if (!arraySome(other, function (othValue, othIndex) {
                    if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                        return seen.push(othIndex);
                    }
                })) {
                    result = false;
                    break;
                }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                result = false;
                break;
            }
        }
        stack['delete'](array);
        stack['delete'](other);
        return result;
    }

    /** Built-in value references. */


    /**
     * Converts `map` to its key-value pairs.
     *
     * @private
     * @param {Object} map The map to convert.
     * @returns {Array} Returns the key-value pairs.
     */
    function mapToArray(map) {
        var index = -1,
            result = Array(map.size);

        map.forEach(function (value, key) {
            result[++index] = [key, value];
        });
        return result;
    }

    /**
     * Converts `set` to an array of its values.
     *
     * @private
     * @param {Object} set The set to convert.
     * @returns {Array} Returns the values.
     */
    function setToArray(set) {
        var index = -1,
            result = Array(set.size);

        set.forEach(function (value) {
            result[++index] = value;
        });
        return result;
    }

    /** Used to compose bitmasks for value comparisons. */


    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
            case dataViewTag:
                if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                    return false;
                }
                object = object.buffer;
                other = other.buffer;

            case arrayBufferTag:
                if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                    return false;
                }
                return true;

            case boolTag:
            case dateTag:
            case numberTag:
                // Coerce booleans to `1` or `0` and dates to milliseconds.
                // Invalid dates are coerced to `NaN`.
                return eq(+object, +other);

            case errorTag:
                return object.name == other.name && object.message == other.message;

            case regexpTag:
            case stringTag:
                // Coerce regexes to strings and treat strings, primitives and objects,
                // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
                // for more details.
                return object == other + '';

            case mapTag:
                var convert = mapToArray;

            case setTag:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3;
                convert || (convert = setToArray);

                if (object.size != other.size && !isPartial) {
                    return false;
                }
                // Assume cyclic values are equal.
                var stacked = stack.get(object);
                if (stacked) {
                    return stacked == other;
                }
                bitmask |= COMPARE_UNORDERED_FLAG$2;

                // Recursively compare objects (susceptible to call stack limits).
                stack.set(object, other);
                var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                stack['delete'](object);
                return result;

            case symbolTag:
                if (symbolValueOf) {
                    return symbolValueOf.call(object) == symbolValueOf.call(other);
                }
        }
        return false;
    }

    /**
     * Appends the elements of `values` to `array`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to append.
     * @returns {Array} Returns `array`.
     */
    function arrayPush(array, values) {
        var index = -1,
            length = values.length,
            offset = array.length;

        while (++index < length) {
            array[offset + index] = values[index];
        }
        return array;
    }

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */


    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result = keysFunc(object);
        return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }

    /**
     * A specialized version of `_.filter` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function arrayFilter(array, predicate) {
        var index = -1,
            length = array == null ? 0 : array.length,
            resIndex = 0,
            result = [];

        while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
                result[resIndex++] = value;
            }
        }
        return result;
    }

    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
    function stubArray() {
        return [];
    }

    /** Used for built-in method references. */


    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */
    function baseTimes(n, iteratee) {
        var index = -1,
            result = Array(n);

        while (++index < n) {
            result[index] = iteratee(index);
        }
        return result;
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
        return value != null && typeof value == 'object';
    }

    /** `Object#toString` result references. */


    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag$1;
    }

    /** Used for built-in method references. */


    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
        return false;
    }

    /** Detect free variable `exports`. */


    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
    }

    /** Used as references for various `Number` constants. */


    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
        return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
    }

    /** `Object#toString` result references. */


    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */
    function baseUnary(func) {
        return function (value) {
            return func(value);
        };
    }

    /** Detect free variable `exports`. */


    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value),
            isArg = !isArr && isArguments(value),
            isBuff = !isArr && !isArg && isBuffer(value),
            isType = !isArr && !isArg && !isBuff && isTypedArray(value),
            skipIndexes = isArr || isArg || isBuff || isType,
            result = skipIndexes ? baseTimes(value.length, String) : [],
            length = result.length;

        for (var key in value) {
            if ((inherited || hasOwnProperty$6.call(value, key)) && !(skipIndexes && (
            // Safari 9 has enumerable `arguments.length` in strict mode.
            key == 'length' ||
            // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == 'offset' || key == 'parent') ||
            // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') ||
            // Skip index properties.
            isIndex(key, length)))) {
                result.push(key);
            }
        }
        return result;
    }

    /** Used for built-in method references. */


    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
        var Ctor = value && value.constructor,
            proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$11;

        return value === proto;
    }

    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */
    function overArg(func, transform) {
        return function (arg) {
            return func(transform(arg));
        };
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */


    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
        if (!isPrototype(object)) {
            return nativeKeys(object);
        }
        var result = [];
        for (var key in Object(object)) {
            if (hasOwnProperty$8.call(object, key) && key != 'constructor') {
                result.push(key);
            }
        }
        return result;
    }

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
    }

    /** Used to compose bitmasks for value comparisons. */


    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4,
            objProps = getAllKeys(object),
            objLength = objProps.length,
            othProps = getAllKeys(other),
            othLength = othProps.length;

        if (objLength != othLength && !isPartial) {
            return false;
        }
        var index = objLength;
        while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty$5.call(other, key))) {
                return false;
            }
        }
        // Assume cyclic values are equal.
        var stacked = stack.get(object);
        if (stacked && stack.get(other)) {
            return stacked == other;
        }
        var result = true;
        stack.set(object, other);
        stack.set(other, object);

        var skipCtor = isPartial;
        while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key],
                othValue = other[key];

            if (customizer) {
                var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            // Recursively compare objects (susceptible to call stack limits).
            if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                result = false;
                break;
            }
            skipCtor || (skipCtor = key == 'constructor');
        }
        if (result && !skipCtor) {
            var objCtor = object.constructor,
                othCtor = other.constructor;

            // Non `Object` object instances with different constructors are not equal.
            if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
                result = false;
            }
        }
        stack['delete'](object);
        stack['delete'](other);
        return result;
    }

    /* Built-in method references that are verified to be native. */


    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object),
            othIsArr = isArray(other),
            objTag = objIsArr ? arrayTag : getTag$1(object),
            othTag = othIsArr ? arrayTag : getTag$1(other);

        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;

        var objIsObj = objTag == objectTag,
            othIsObj = othTag == objectTag,
            isSameTag = objTag == othTag;

        if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
                return false;
            }
            objIsArr = true;
            objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG$1)) {
            var objIsWrapped = objIsObj && hasOwnProperty$4.call(object, '__wrapped__'),
                othIsWrapped = othIsObj && hasOwnProperty$4.call(other, '__wrapped__');

            if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object.value() : object,
                    othUnwrapped = othIsWrapped ? other.value() : other;

                stack || (stack = new Stack());
                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
        }
        if (!isSameTag) {
            return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }

    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
            return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }

    /** Used to compose bitmasks for value comparisons. */


    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length,
            length = index,
            noCustomizer = !customizer;

        if (object == null) {
            return !length;
        }
        object = Object(object);
        while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                return false;
            }
        }
        while (++index < length) {
            data = matchData[index];
            var key = data[0],
                objValue = object[key],
                srcValue = data[1];

            if (noCustomizer && data[2]) {
                if (objValue === undefined && !(key in object)) {
                    return false;
                }
            } else {
                var stack = new Stack();
                if (customizer) {
                    var result = customizer(objValue, srcValue, key, object, source, stack);
                }
                if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
        return value === value && !isObject(value);
    }

    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
        var result = keys(object),
            length = result.length;

        while (length--) {
            var key = result[length],
                value = object[key];

            result[length] = [key, value, isStrictComparable(value)];
        }
        return result;
    }

    /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function matchesStrictComparable(key, srcValue) {
        return function (object) {
            if (object == null) {
                return false;
            }
            return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
        };
    }

    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function (object) {
            return object === source || baseIsMatch(object, source, matchData);
        };
    }

    /** `Object#toString` result references. */


    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
        return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag$1;
    }

    /** Used to match property names within property paths. */


    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
        if (isArray(value)) {
            return false;
        }
        var type = typeof value;
        if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
            return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }

    /** Error message constants. */


    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
        if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
        }
        var memoized = function memoized() {
            var args = arguments,
                key = resolver ? resolver.apply(this, args) : args[0],
                cache = memoized.cache;

            if (cache.has(key)) {
                return cache.get(key);
            }
            var result = func.apply(this, args);
            memoized.cache = cache.set(key, result) || cache;
            return result;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
    }

    // Expose `MapCache`.


    /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
    function memoizeCapped(func) {
        var result = memoize(func, function (key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
                cache.clear();
            }
            return key;
        });

        var cache = result.cache;
        return result;
    }

    /** Used to match property names within property paths. */


    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
        // Exit early for strings to avoid a performance hit in some environments.
        if (typeof value == 'string') {
            return value;
        }
        if (isArray(value)) {
            // Recursively convert values (susceptible to call stack limits).
            return arrayMap(value, baseToString) + '';
        }
        if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : '';
        }
        var result = value + '';
        return result == '0' && 1 / value == -INFINITY ? '-0' : result;
    }

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
        return value == null ? '' : baseToString(value);
    }

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value, object) {
        if (isArray(value)) {
            return value;
        }
        return isKey(value, object) ? [value] : stringToPath(toString(value));
    }

    /** Used as references for various `Number` constants. */


    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
        if (typeof value == 'string' || isSymbol(value)) {
            return value;
        }
        var result = value + '';
        return result == '0' && 1 / value == -INFINITY$1 ? '-0' : result;
    }

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
        path = castPath(path, object);

        var index = 0,
            length = path.length;

        while (object != null && index < length) {
            object = object[toKey(path[index++])];
        }
        return index && index == length ? object : undefined;
    }

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
        var result = object == null ? undefined : baseGet(object, path);
        return result === undefined ? defaultValue : result;
    }

    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHasIn(object, key) {
        return object != null && key in Object(object);
    }

    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
    function hasPath(object, path, hasFunc) {
        path = castPath(path, object);

        var index = -1,
            length = path.length,
            result = false;

        while (++index < length) {
            var key = toKey(path[index]);
            if (!(result = object != null && hasFunc(object, key))) {
                break;
            }
            object = object[key];
        }
        if (result || ++index != length) {
            return result;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }

    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
    function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
    }

    /** Used to compose bitmasks for value comparisons. */


    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
        }
        return function (object) {
            var objValue = get(object, path);
            return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$5 | COMPARE_UNORDERED_FLAG$3);
        };
    }

    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */
    function identity(value) {
        return value;
    }

    /**
     * The base implementation of `_.property` without support for deep paths.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function baseProperty(key) {
        return function (object) {
            return object == null ? undefined : object[key];
        };
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyDeep(path) {
        return function (object) {
            return baseGet(object, path);
        };
    }

    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */
    function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }

    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
    function baseIteratee(value) {
        // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
        // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
        if (typeof value == 'function') {
            return value;
        }
        if (value == null) {
            return identity;
        }
        if (typeof value == 'object') {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
    }

    /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
        return function (object, iteratee, keysFunc) {
            var index = -1,
                iterable = Object(object),
                props = keysFunc(object),
                length = props.length;

            while (length--) {
                var key = props[fromRight ? length : ++index];
                if (iteratee(iterable[key], key, iterable) === false) {
                    break;
                }
            }
            return object;
        };
    }

    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */


    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
        return object && baseFor(object, iteratee, keys);
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
        return function (collection, iteratee) {
            if (collection == null) {
                return collection;
            }
            if (!isArrayLike(collection)) {
                return eachFunc(collection, iteratee);
            }
            var length = collection.length,
                index = fromRight ? length : -1,
                iterable = Object(collection);

            while (fromRight ? index-- : ++index < length) {
                if (iteratee(iterable[index], index, iterable) === false) {
                    break;
                }
            }
            return collection;
        };
    }

    /**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */


    /**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
        var index = -1,
            result = isArrayLike(collection) ? Array(collection.length) : [];

        baseEach(collection, function (value, key, collection) {
            result[++index] = iteratee(value, key, collection);
        });
        return result;
    }

    /**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee) {
        var func = isArray(collection) ? arrayMap : baseMap;
        return func(collection, baseIteratee(iteratee, 3));
    }

    /**
     * A specialized version of `_.forEach` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEach(array, iteratee) {
        var index = -1,
            length = array == null ? 0 : array.length;

        while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
                break;
            }
        }
        return array;
    }

    /**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */
    function castFunction(value) {
        return typeof value == 'function' ? value : identity;
    }

    /**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forEach(collection, iteratee) {
        var func = isArray(collection) ? arrayEach : baseEach;
        return func(collection, castFunction(iteratee));
    }

    /**
     * Converts a coordinate pair into a {@link google.maps.LatLngLiteral}
     * @param  {Position|google.maps.LatLngLiteral|google.maps.LatLng} position a coordinate pair 
     * @return {google.maps.LatLngLiteral}     a {@link google.maps.LatLngLiteral}
     * @private
     */
    function toLatLng(position) {
        if (position instanceof google.maps.LatLng) {
            return {
                lat: position.lat(),
                lng: position.lng()
            };
        } else if (position.lat && position.lng) {
            return position;
        } else {
            return {
                lat: position[1],
                lng: position[0]
            };
        }
    }

    /**
     * Transforma un array de LatLng en un array de coordenadas [lng,lat]
     * @param {Array.<Position>} arrayLatLng [description]
     * @return {Array.<google.maps.LatLngLiteral>} array of {@link google.maps.LatLngLiteral}
     */
    function toLatLngs(coordinates) {
        return map(coordinates, toLatLng);
    }

    /**
     * Transforms a {@link google.maps.LatLng} or {@link google.maps.LatLngLiteral}
     * @param  {google.maps.LatLng|google.maps.LatLngLiteral|Position} LatLng a coordinate to transform
     * @return {Position}   a coordinate pair
     * @private
     */
    function toCoord$1(LatLng) {
        if (google.maps && google.maps.LatLng && LatLng instanceof google.maps.LatLng) {
            return [LatLng.lng(), LatLng.lat()];
        } else if (LatLng.lat && LatLng.lng) {
            return [LatLng.lng, LatLng.lat];
        } else if (LatLng.length && LatLng.length >= 2) {
            return LatLng;
        } else {
            throw new Error('google.maps is not present in the global scope');
        }
    }

    /**
     * Transforms an array of coordinates to an array of [Lng, Lat]
     * @param {Array.<google.maps.LatLng>|Array.<google.maps.LatLngLiteral>} arrayLatLng Array of {@link google.maps.LatLng} or {@link google.maps.LatLngLiteral}
     * @param {bool} [closeRing=false] optionally, ensure the passed coordinate array forms a closed ring
     * @return {Array.<Position>} an array of {@link Position}
     */
    function toCoords(arrayLatLng, closeRing) {

        var ring = map(arrayLatLng, toCoord$1);

        if (closeRing === true) {
            var last_coord = ring.pop();
            if (last_coord[0] === ring[0][0] && last_coord[1] === ring[0][1]) {
                ring.push(ring[0]);
            } else {
                ring.push(last_coord);
                ring.push(ring[0]);
            }
        }
        return ring;
    }

    /** Used to compose unicode character classes. */

    /** Used to compose unicode character classes. */


    /**
     * Transforma un array de gmaps.LatLng en un Feature.Polygon
     * @param  {Array.<google.maps.LatLng>} LatLngArray [description]
     * @return {Feature.<Polygon>}             [description]
     */
    function arrayToFeaturePolygon(LatLngArray) {

        var vertices = toCoords(LatLngArray, true);

        return {
            type: "Feature",
            properties: {},
            geometry: {
                type: "Polygon",

                coordinates: [vertices]
            }
        };
    }

    /**
     * Transforms a {@link google.maps.Marker} to a {@link Feature<Point>}
     * @param  {google.maps.Marker} marker  - marker object to transform
     * @return {Feature<Point>}    output Feature
     */
    function markerToFeaturePoint(marker) {
        if (!marker.getPosition || typeof marker.getPosition !== 'function') {
            throw new Error('input object does not have a getPosition method');
        }
        var position = marker.getPosition(),
            Feature = {
            type: "Feature",
            properties: {},
            geometry: {
                type: "Point",
                coordinates: [position.lng(), position.lat()]
            }
        };

        return Feature;
    }

    /**
     * [polylineToFeatureLinestring description]
     * @param  {Array.<google.maps.LatLng>|google.maps.Polyline} objeto array of positions or a google.maps.Polyline
     * @return {Feature.<LineString>}          [description]
     */
    function polylineToFeatureLinestring(objeto) {
        var vertices;
        if (objeto instanceof google.maps.Polyline) {
            vertices = toCoords(objeto.getPath().getArray());
        } else {
            vertices = toCoords(objeto);
        }

        return turf_linestring(vertices);
    }

    /**
     * Receives an object and returns a GeoJson Feature of type Polygon
     * @param  {google.maps.Polygon|Array.<google.maps.LatLng>|Feature.Polygon|Geometry} object object to transform into a Feature.Polygon
     * @return {Feature.Polygon}        [description]
     */
    function polygonToFeaturePolygon(object) {
        var ring, polygonFeature;

        if (object.type === 'Feature') {
            polygonFeature = object;
        } else if (object instanceof google.maps.Polygon) {

            object = object.getPath().getArray();
            ring = toCoords(object, true);
            polygonFeature = arrayToFeaturePolygon(ring);
        } else if (!!(object && object.constructor === Array)) {

            ring = toCoords(object, true);
            polygonFeature = arrayToFeaturePolygon(ring);
        } else if (object.geometry) {

            polygonFeature = {
                type: "Feature",
                properties: {},
                geometry: object.geometry
            };
        } else {
            throw new Error('object is not a Feature, google.maps.Polygon nor an array of google.maps.LatLng');
        }

        polygonFeature.properties = {};

        return polygonFeature;
    }

    /**
     * Transforma un array de gmaps.LatLng en un featurecollection geoJson
     * donde cada Feature es un punto del array de entrada
     * @param  {Array<google.maps.LatLng>|google.maps.MVCArray} latLngArray array de posiciones {@link google.maps.LatLng}
     * @return {FeatureCollection}             geojson FeatureCollection
     */
    function arrayToFeaturePoints(latLngArray) {

        var FeatureCollection = {
            "type": "FeatureCollection",
            "features": []
        };
        latLngArray.forEach(function (latLng) {
            var Feature = {
                type: "Feature",
                geometry: {
                    type: "Point",
                    coordinates: toCoords([latLng])[0]
                }
            };
            FeatureCollection.features.push(Feature);
        });

        return FeatureCollection;
    }

    /**
     * Takes a set of points and returns a concave hull polygon. Internally, this uses turf-tin to generate geometries.
     * @param  {Array<google.maps.LatLng>|Array<google.maps.LatLngLiteral>|google.maps.MVCArray} latLngArray array of google positions
     * @param  {number} maxEdge the size of an edge necessary for part of the hull to become concave (in miles)
     * @param  {string} units degrees, radians, miles, or kilometers
     * @return {Feature.<Polygon>}  a concave hull
     */
    function concave(latLngArray, maxEdge, units) {

        var FeatureCollection = arrayToFeaturePoints(latLngArray);
        return turf_concave(FeatureCollection, maxEdge, units);
    }

    /**
     * Simplifies an array of coordinates
     * @param  {Array.<google.maps.LatLng>|Array.<google.maps.LatLngLiteral>} coordArray Array of coordinates
     * @param  {number} tolerance   [description]
     * @param  {boolean} highQuality [description]
     * @return {Array.<Number>}  Array de coordenadas [lng,lat]
     */
    function simplifyPointArray(coordArray, tolerance, highQuality) {
        tolerance = tolerance || 0.00001;
        highQuality = highQuality || false;
        var Feature = turf_linestring$1(toCoords(coordArray));

        var simplifiedgeom = turf_simplify(Feature, tolerance, highQuality);

        //debug('simplifyPointArray', 'geometry is', Feature.geometry, 'simplifiedgeom is', simplifiedgeom);

        return simplifiedgeom.geometry.coordinates;
    }

    /**
     * Simplified a Feature, google.maps.Polygon or google.maps.Polyline
     * @param  {google.maps.Polygon|google.maps.Polyline|Array.<google.maps.LatLng>|Feature.<Polygon>|Feature.<LineString>} object feature to be simplified
     * @param  {string} output either 'feature', 'geometry' or 'object' (google maps). Case insensitive. Defaults to feature
     * @param  {mumber} tolerance   simplification tolerance
     * @param  {boolean} highQuality [description]
     * @return {Feature|Geometry} whether or not to spend more time to create a higher-quality simplification with a different algorithm
     */
    function simplifyFeature(object, output, tolerance, highQuality) {

        output = (output || 'feature').toLowerCase();

        var Feature;
        if (object instanceof google.maps.Polyline || object instanceof google.maps.Polygon) {
            var geometry = Wicket$1().fromObject(object).toJson();
            Feature = {
                type: "Feature",
                properties: {},
                geometry: geometry
            };
        } else if (object.type && object.type === 'Feature' && object.geometry) {
            Feature = object;
        } else {
            Feature = polygonToFeaturePolygon(object);
        }

        if (Feature.geometry.type === 'MultiPolygon') {
            Feature.geometry.type = 'Polygon';
            Feature.geometry.coordinates = Feature.geometry.coordinates[0];
        }
        var simplifiedgeom = turf_simplify(Feature, tolerance, highQuality);

        if (simplifiedgeom && simplifiedgeom.geometry) {
            //debug('Simplified Feature', Feature, 'simplifiedgeom', simplifiedgeom);
            Feature = simplifiedgeom;
        } else {
            warn('Cannot simplify  Feature', Feature);
        }
        if (output === 'geometry') {
            return Feature.geometry;
        } else if (output === 'object') {
            return Wicket$1().fromJson(Feature.geometry).toObject();
        } else {
            return Feature;
        }
    }

    /**
     * Takes a linestring and returns a {@link Point|point} at a specified distance along the line.
     * @param  {google.maps.Polyline|Array.<google.maps.LatLng>|Array.<google.maps.LatLngLiteral>|Feature<LineString>} object input object
     * @param  {Number} distance    [description]
     * @param  {string} units can be degrees, radians, miles, or kilometers. Defaults to kilometers
     * @return {Feature.<Point>} Point distance units along the line
     */
    function along(object, distance, units) {
        var Feature;

        if (object instanceof google.maps.Polyline) {
            var geometry = Wicket$1().fromObject(object).toJson();
            Feature = {
                type: "Feature",
                properties: {},
                geometry: geometry
            };
        } else if (object.type && object.type === 'Feature' && object.geometry) {
            Feature = object;
        } else {
            var arrayCoords = toCoords(object);
            Feature = turf_linestring$2(arrayCoords);
        }

        return turf_along(Feature, distance, units);
    }

    /**
     * Superpone dos Feature.<Polygon>
     * @param  {google.maps.Polygon|Array.<google.maps.LatLng>|Feature.Polygon} poly1 object to transform into a Feature.Polygon
     * @param  {google.maps.Polygon|Array.<google.maps.LatLng>|Feature.Polygon} poly1 object to transform into a Feature.Polygon
     * @return {Feature.<Polygon>|Feature.<MultiPolygon>}  result of the union. If inputs are disjoint, returns a Feature.Multipolygon
     */
    function union(poly1, poly2) {
        var featurePolygon1 = polygonToFeaturePolygon(poly1),
            featurePolygon2 = polygonToFeaturePolygon(poly2),
            FeatureUnion = turf_union(featurePolygon1, featurePolygon2);
        return FeatureUnion;
    }

    /**
     * Calculates a buffer for input features for a given radius. Units supported are miles, kilometers, and degrees.
     * @param  {google.maps.Polygon|google.maps.Polyline|google.maps.Marker|google.maps.LatLng|Array.<google.maps.LatLng>|Feature.<Polygon|Linestring|Point>} object input object
     * @param  {String} output  either 'geometry','object' (google.maps) or 'feature', case insensitive, defaults to 'feature'
     * @param  {Number} distance    [description]
     * @param  {String} units       'meters' or 'miles' etc
     * @return {Feature|Feature.<Geometry>}  A GeoJson Feature or its geometry, according to output parameter
     */
    function createbuffer(object, output, distance, units, comment, steps) {
        units = units || 'meters';
        output = (output || 'feature').toLowerCase();

        var Feature;
        if (object instanceof google.maps.Polyline || object instanceof google.maps.Polygon || object instanceof google.maps.Marker || object instanceof google.maps.LatLng) {
            var geometry = Wicket$1().fromObject(object).toJson();
            Feature = {
                type: "Feature",
                properties: {},
                geometry: geometry
            };
        } else if (object.type && object.type === 'Feature' && object.geometry) {
            Feature = object;
        } else {
            Feature = polygonToFeaturePolygon(object);
        }

        var buffered = turf_buffer(Feature, distance, units, steps);

        if (buffered.type === 'FeatureCollection') {
            buffered = buffered.features[0];
        }

        if (output === 'geometry') {
            return buffered.geometry;
        } else if (output === 'object') {
            return Wicket$1().fromJson(buffered.geometry).toObject();
        } else {
            return buffered;
        }
    }

    /**
     * Filters an array of points returning those who falls inside a given {@link Polygon}
     * @param {Array<google.maps.Marker>} sourceArray array of {@link google.maps.Marker}
     * @param {Polygon|Multipolygon} geojsonPolygon  the polygon thay may contain the points
     * @return {{pointsInside:Array<google.maps.Marker>, pointsOutside:Array<google.maps.Marker>}} an object with the points that fall inside and outside the polygon
     */
    function pointInPolygon(sourceArray, geojsonPolygon) {
        var pointsInside = [];
        var pointsOutside = [];

        if (geojsonPolygon.type !== 'Feature') {
            geojsonPolygon = {
                "type": "Feature",
                "properties": {},
                "geometry": geojsonPolygon
            };
        }
        if (geojsonPolygon.geometry.type === 'Polygon' || geojsonPolygon.geometry.type === 'Multipolygon') {
            forEach(sourceArray, function (item) {

                var Point = markerToFeaturePoint(item);
                //console.zlog('Point is', Point);
                if (turf_inside(Point, geojsonPolygon)) {
                    pointsInside.push(item);
                } else {
                    pointsOutside.push(item);
                }
            });
        }

        return {
            pointsInside: pointsInside,
            pointsOutside: pointsOutside
        };
    }

    /**
     * Takes an array of points, google.maps.Polygon or Feature<Polygon> and returns {@link Point|points} at all self-intersections.
     *
     * @name kinks
     * @param  {google.maps.Polyline|google.maps.Polygon|Array.<google.maps.LatLng>|Feature<Polygon>} object array of points, google.maps.Polygon or Feature<Polygon>
     * @returns {FeatureCollection<Point>} self-intersections
     *
     */
    function kinks(object) {
        var Feature;
        if (object instanceof google.maps.Polyline || object instanceof google.maps.Polygon) {
            var geometry = Wicket().fromObject(object).toJson();
            Feature = {
                type: "Feature",
                properties: {},
                geometry: geometry
            };
        } else if (object.type && object.type === 'Feature' && object.geometry) {
            Feature = object;
        } else {
            Feature = polygonToFeaturePolygon(object);
        }

        return turk_kinks(Feature);
    }

    /**
     * Takes a kinked polygon and returns a feature collection of polygons that have no kinks. 
     * @param  {google.maps.Polygon|Array.<google.maps.LatLng>|Feature<Polygon>} object array of points, a google.maps.Polygon or Feature<Polygon>
     * @return {FeatureCollection<Polygon>}  Unkinked polygons
     */
    function unkink(object) {

        var polygonFeature = polygonToFeaturePolygon(object);

        return turf_unkink(polygonFeature);
    }

    /**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
        var result = [];
        baseEach(collection, function (value, index, collection) {
            if (predicate(value, index, collection)) {
                result.push(value);
            }
        });
        return result;
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     */
    function filter(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, baseIteratee(predicate, 3));
    }

    /**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */
    function baseExtremum(array, iteratee, comparator) {
        var index = -1,
            length = array.length;

        while (++index < length) {
            var value = array[index],
                current = iteratee(value);

            if (current != null && (computed === undefined ? current === current && !isSymbol(current) : comparator(current, computed))) {
                var computed = current,
                    result = value;
            }
        }
        return result;
    }

    /**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */
    function baseGt(value, other) {
        return value > other;
    }

    /**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */
    function max(array) {
        return array && array.length ? baseExtremum(array, identity, baseGt) : undefined;
    }

    /**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */
    function baseLt(value, other) {
        return value < other;
    }

    /**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */
    function min(array) {
        return array && array.length ? baseExtremum(array, identity, baseLt) : undefined;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */
    function isEqual(value, other) {
        return baseIsEqual(value, other);
    }

    /**
     * Takes two coordinates and returns the distance between them, in degrees
     * @param  {Array<number>} coord1 An array indicating a coordinate [lng, lat]
     * @param  {Array<number>} coord2 An array indicating a coordinate [lng, lat]
     * @return {number}        the distance between the points, in degrees 
     */
    function diffCoords(coord1, coord2) {
        var vector = [Math.abs(coord1[0] - coord2[0]), Math.abs(coord1[1] - coord2[1])];
        return Math.sqrt(Math.pow(vector[0], 2) + Math.pow(vector[1], 2));
    }

    /**
     * Determina si dos lineas se intersectan
     * @param  {Array.<number>} line1Start [description]
     * @param  {Array.<number>} line1End   [description]
     * @param  {Array.<number>} line2Start [description]
     * @param  {Array.<number>} line2End   [description]
     * @param {boolean} useOldMethod if true, use old method instead of turf_line_intersect 
     * @return {Array}             [description]
     */
    function lineIntersects(line1Start, line1End, line2Start, line2End, useOldMethod) {

        if (!useOldMethod) {
            var line1 = turf_linestring$3([line1Start, line1End]),
                line2 = turf_linestring$3([line2Start, line2End]),
                intersectionFC = turf_line_intersect(line1, line2);

            if (intersectionFC.features.length) {
                var intersection = intersectionFC.features[0].geometry.coordinates;
                intersection[0] = Math.round(intersection[0] * 100000000) / 100000000;
                intersection[1] = Math.round(intersection[1] * 100000000) / 100000000;
                return intersection;
            } else {
                return false;
            }
        }
        var line1StartX = line1Start[0],
            line1StartY = line1Start[1],
            line1EndX = line1End[0],
            line1EndY = line1End[1],
            line2StartX = line2Start[0],
            line2StartY = line2Start[1],
            line2EndX = line2End[0],
            line2EndY = line2End[1];
        // if the lines intersect, the result contains the x and y of the intersection
        // (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point
        var denominator,
            a,
            b,
            numerator1,
            numerator2,
            result = {
            x: null,
            y: null,
            onLine1: false,
            onLine2: false
        };
        denominator = (line2EndY - line2StartY) * (line1EndX - line1StartX) - (line2EndX - line2StartX) * (line1EndY - line1StartY);
        if (denominator === 0) {
            if (result.x !== null && result.y !== null) {
                return result;
            } else {
                return false;
            }
        }
        a = line1StartY - line2StartY;
        b = line1StartX - line2StartX;
        numerator1 = (line2EndX - line2StartX) * a - (line2EndY - line2StartY) * b;
        numerator2 = (line1EndX - line1StartX) * a - (line1EndY - line1StartY) * b;
        a = numerator1 / denominator;
        b = numerator2 / denominator;

        // if we cast these lines infinitely in both directions, they intersect here:
        result.x = line1StartX + a * (line1EndX - line1StartX);
        result.y = line1StartY + a * (line1EndY - line1StartY);

        // if line1 is a segment and line2 is infinite, they intersect if:
        if (a >= 0 && a <= 1) {
            result.onLine1 = true;
        }
        // if line2 is a segment and line1 is infinite, they intersect if:
        if (b >= 0 && b <= 1) {
            result.onLine2 = true;
        }
        // if line1 and line2 are segments, they intersect if both of the above are true
        if (result.onLine1 && result.onLine2) {
            result.x = Math.round(result.x * 100000000) / 100000000;
            result.y = Math.round(result.y * 100000000) / 100000000;

            return [result.x, result.y];
        } else {
            return false;
        }
    }

    /**
     * Takes two rings and finds their instersection points. If the rings are the same, the second ring is iterated skipping points already checked in the first one
     * @param  {Array.Array<number>} ring1 Array of coordinates [lng, lat]
     * @param  {Array.Array<number>} ring1 Array of coordinates [lng, lat]
     * @param {boolean} useOldMethod if true, use old method instead of turf_line_intersect 
     * @return {Object}       an object containing
     */
    function traverseRings(ring1, ring2, useOldMethod) {
        var intersections = turf_featurecollection([]);

        var samering = false,
            consecutive = false;
        if (isEqual(ring1, ring2)) {
            samering = true;
        }
        for (var i = 0; i < ring1.length - 1; i++) {
            var startK = samering ? i : 0;
            for (var k = startK; k < ring2.length - 1; k++) {
                // don't check adjacent sides of a given ring, since of course they intersect in a vertex.
                if (ring1 === ring2 && (Math.abs(i - k) === 1 || Math.abs(i - k) === ring1.length - 2)) {
                    continue;
                }

                var intersection = lineIntersects(ring1[i], ring1[i + 1], ring2[k], ring2[k + 1], useOldMethod);
                if (!intersection) {
                    continue;
                }

                // si son lineas consecutivas no quiero detectar el lÃ­mite entre ambas
                if ((diffCoords(intersection, ring1[0]) < 0.000005 || diffCoords(intersection, ring1[ring1.length - 1]) < 0.000005) && (diffCoords(intersection, ring2[0]) < 0.000005 || diffCoords(intersection, ring2[ring2.length - 1]) < 0.000005)) {
                    continue;
                }

                //debug('intersection at',
                // intersection,
                //diffCoords(intersection, ring2[0]),
                //diffCoords(intersection, ring1[ring1.length - 1]));
                var FeatureIntersection = turf_point([intersection[0], intersection[1]]);
                FeatureIntersection.properties = {
                    position1: i,
                    position2: k
                };
                intersections.features.push(FeatureIntersection);
            }
        }
        return intersections;
    }

    /**
     * Finds the {@link Point|points} where two {@link LineString|linestrings} intersect each other
     * @param  {Array.<google.maps.LatLng>} arrayLatLng1 array de posiciones {@link google.maps.LatLng}
     * @param  {Array.<google.maps.LatLng>} arrayLatLng2 array de posiciones {@link google.maps.LatLng}
     * @param {boolean} useOldMethod if true,use old method instead of turf_line_intersect 
     * @return {Array}        an array with [line1 trimmed at intersection,line2 trimmed at intersection,intersection ] 
     */
    function trimPaths(arrayLatLng1, arrayLatLng2, useOldMethod) {

        var ring1 = toCoords(arrayLatLng1); // googleGeom1.geometry.coordinates;
        var ring2 = toCoords(arrayLatLng2); // googleGeom2.geometry.coordinates;


        var intersections = traverseRings(ring1, ring2, useOldMethod);

        if (intersections.features.length > 0) {

            var line1 = turf_linestring$3(ring1);
            var line2 = turf_linestring$3(ring2);
            var line1Start = turf_point(ring1[0]);
            var line2End = turf_point(ring2.slice(-1)[0]);
            var sliced1, sliced2;

            // The first segment of the first ring with a kink
            var first_segment_with_kinks = min(intersections.features, function (kink) {
                return kink.properties.position1;
            });
            //console.log('first_segment_with_kinks', JSON.stringify(first_segment_with_kinks));

            // All the intersections which belong to the first segment with a kink of the first ring
            var kinks_in_first_segment = filter(intersections.features, function (kink) {
                return kink.properties.position1 === first_segment_with_kinks.properties.position1;
            });

            // Among the kinks in the first segment, which one happens further along the ring2
            var chosenIntersection = max(kinks_in_first_segment, function (kink) {
                return kink.properties.position2;
            });

            var intersectLatLng = toLatLngs([chosenIntersection.geometry.coordinates])[0];

            // if the first intersection happens in the first segment of line1
            // then we don't slice it
            if (chosenIntersection.properties.position1 === 0) {
                sliced1 = line1;
            } else {
                sliced1 = turf_line_slice(line1Start, chosenIntersection, line1);
            }

            // if the first intersection happens after the last segment of line2
            // then we don't slice it
            if (chosenIntersection.properties.position2 >= ring2.length - 1) {
                sliced2 = line2;
            } else {
                sliced2 = turf_line_slice(chosenIntersection, line2End, line2);
            }

            return [toLatLngs(sliced1.geometry.coordinates), toLatLngs(sliced2.geometry.coordinates), intersectLatLng];
        }
        return [];
    }

    /**
     * This module acts as a bridge between google.maps and Turf, 
     * By converting google maps overlays such as
     * {@link google.maps.Polygon}
     * {@link google.maps.Polyline}
     * {@link google.maps.Point}
     *
     * to their proper geojson representation.
     *
     * This in turn allows to perform Turf operations that google.maps doesn't natively support
     * 
     * @name turfHelper
     * @module turfHelper
     */
    return {
        setters: [function (_c) {
            turf_helpers = _c.default;
        }, function (_) {
            turf_concave = _.default;
        }, function (_b) {
            turf_simplify = _b.default;
        }, function (_c2) {
            turf_along = _c2.default;
        }, function (_f) {
            turf_union = _f.default;
        }, function (_2) {
            turf_buffer = _2.default;
        }, function (_a) {
            turf_inside = _a.default;
        }, function (_3) {
            turk_kinks = _3.default;
        }, function (_4) {
            turf_unkink = _4.default;
        }, function (_5) {
            turf_line_slice = _5.default;
        }, function (_6) {
            turf_line_intersect = _6.default;
        }],
        execute: function () {
            Wkt = function Wkt(obj) {
                if (obj instanceof Wkt) return obj;
                if (!(this instanceof Wkt)) return new Wkt(obj);
                this._wrapped = obj;
            };

            /**
             * Returns true if the substring is found at the beginning of the string.
             * @param   str {String}    The String to search
             * @param   sub {String}    The substring of interest
             * @return      {Boolean}
             * @private
             */
            beginsWith = function beginsWith(str, sub) {
                return str.substring(0, sub.length) === sub;
            };

            /**
             * Returns true if the substring is found at the end of the string.
             * @param   str {String}    The String to search
             * @param   sub {String}    The substring of interest
             * @return      {Boolean}
             * @private
             */
            endsWith = function endsWith(str, sub) {
                return str.substring(str.length - sub.length) === sub;
            };

            /**
             * The default delimiter for separating components of atomic geometry (coordinates)
             * @ignore
             */
            Wkt.delimiter = ' ';

            /**
             * Determines whether or not the passed Object is an Array.
             * @param   obj {Object}    The Object in question
             * @return      {Boolean}
             * @member Wkt.isArray
             * @method
             */
            Wkt.isArray = function (obj) {
                return !!(obj && obj.constructor === Array);
            };

            /**
             * Removes given character String(s) from a String.
             * @param   str {String}    The String to search
             * @param   sub {String}    The String character(s) to trim
             * @return      {String}    The trimmed string
             * @member Wkt.trim
             * @method
             */
            Wkt.trim = function (str, sub) {
                sub = sub || ' '; // Defaults to trimming spaces
                // Trim beginning spaces
                while (beginsWith(str, sub)) {
                    str = str.substring(1);
                }
                // Trim ending spaces
                while (endsWith(str, sub)) {
                    str = str.substring(0, str.length - 1);
                }
                return str;
            };

            /**
             * An object for reading WKT strings and writing geographic features
             * @constructor Wkt.Wkt
             * @param   initializer {String}    An optional WKT string for immediate read
             * @property            {Array}     components      - Holder for atomic geometry objects (internal representation of geometric components)
             * @property            {String}    delimiter       - The default delimiter for separating components of atomic geometry (coordinates)
             * @property            {Object}    regExes         - Some regular expressions copied from OpenLayers.Format.WKT.js
             * @property            {String}    type            - The Well-Known Text name (e.g. 'point') of the geometry
             * @property            {Boolean}   wrapVerticies   - True to wrap vertices in MULTIPOINT geometries; If true: MULTIPOINT((30 10),(10 30),(40 40)); If false: MULTIPOINT(30 10,10 30,40 40)
             * @return              {Wkt.Wkt}
             * @memberof Wkt
             */
            Wkt.Wkt = function (initializer) {

                /**
                 * The default delimiter between X and Y coordinates.
                 * @ignore
                 */
                this.delimiter = Wkt.delimiter || ' ';

                /**
                 * Configuration parameter for controlling how Wicket seralizes
                 * MULTIPOINT strings. Examples; both are valid WKT:
                 * If true: MULTIPOINT((30 10),(10 30),(40 40))
                 * If false: MULTIPOINT(30 10,10 30,40 40)
                 * @ignore
                 */
                this.wrapVertices = true;

                /**
                 * Some regular expressions copied from OpenLayers.Format.WKT.js
                 * @ignore
                 */
                this.regExes = {
                    'typeStr': /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,
                    'spaces': /\s+|\+/, // Matches the '+' or the empty space
                    'numeric': /-*\d+(\.*\d+)?/,
                    'comma': /\s*,\s*/,
                    'parenComma': /\)\s*,\s*\(/,
                    'coord': /-*\d+\.*\d+ -*\d+\.*\d+/, // e.g. "24 -14"
                    'doubleParenComma': /\)\s*\)\s*,\s*\(\s*\(/,
                    'trimParens': /^\s*\(?(.*?)\)?\s*$/,
                    'ogcTypes': /^(multi)?(point|line|polygon|box)?(string)?$/i, // Captures e.g. "Multi","Line","String"
                    'crudeJson': /^{.*"(type|coordinates|geometries|features)":.*}$/ // Attempts to recognize JSON strings
                };

                /**
                 * The internal representation of geometry--the "components" of geometry.
                 * @ignore
                 */
                this.components = undefined;

                // An initial WKT string may be provided
                if (initializer && typeof initializer === 'string') {
                    this.read(initializer);
                } else if (initializer && typeof initializer !== undefined) {
                    this.fromObject(initializer);
                }
            };

            /**
             * Returns true if the internal geometry is a collection of geometries.
             * @return  {Boolean}   Returns true when it is a collection
             * @memberof Wkt.Wkt
             * @method
             */
            Wkt.Wkt.prototype.isCollection = function () {
                switch (this.type.slice(0, 5)) {
                    case 'multi':
                        // Trivial; any multi-geometry is a collection
                        return true;
                    case 'polyg':
                        // Polygons with holes are "collections" of rings
                        return true;
                    default:
                        // Any other geometry is not a collection
                        return false;
                }
            };

            /**
             * Compares two x,y coordinates for equality.
             * @param   a   {Object}    An object with x and y properties
             * @param   b   {Object}    An object with x and y properties
             * @return      {Boolean}
             * @memberof Wkt.Wkt
             * @method
             */
            Wkt.Wkt.prototype.sameCoords = function (a, b) {
                return a.x === b.x && a.y === b.y;
            };

            /**
             * Sets internal geometry (components) from framework geometry (e.g.
             * Google Polygon objects or google.maps.Polygon).
             * @param   obj {Object}    The framework-dependent geometry representation
             * @return      {Wkt.Wkt}   The object itself
             * @memberof Wkt.Wkt
             * @method
             */
            Wkt.Wkt.prototype.fromObject = function (obj) {
                var result;

                if (obj.hasOwnProperty('type') && obj.hasOwnProperty('coordinates')) {
                    result = this.fromJson(obj);
                } else {
                    result = this.deconstruct.call(this, obj);
                }

                this.components = result.components;
                this.isRectangle = result.isRectangle || false;
                this.type = result.type;
                return this;
            };

            /**
             * Creates external geometry objects based on a plug-in framework's
             * construction methods and available geometry classes.
             * @param   config  {Object}    An optional framework-dependent properties specification
             * @return          {Object}    The framework-dependent geometry representation
             * @memberof Wkt.Wkt
             * @method
             */
            Wkt.Wkt.prototype.toObject = function (config) {
                var obj = this.construct[this.type].call(this, config);
                // Don't assign the "properties" property to an Array
                if (typeof obj === 'object' && !Wkt.isArray(obj)) {
                    obj.properties = this.properties;
                }
                return obj;
            };

            /**
             * Returns the WKT string representation; the same as the write() method.
             * @memberof Wkt.Wkt
             * @method
             */
            Wkt.Wkt.prototype.toString = function (config) {
                return this.write();
            };

            /**
             * Parses a JSON representation as an Object.
             * @param   obj {Object}    An Object with the GeoJSON schema
             * @return  {Wkt.Wkt}  The object itself
             * @memberof Wkt.Wkt
             * @method
             */
            Wkt.Wkt.prototype.fromJson = function (obj) {
                var i, j, k, coords, iring, oring;

                this.type = obj.type.toLowerCase();
                this.components = [];
                if (obj.hasOwnProperty('geometry')) {
                    //Feature
                    this.fromJson(obj.geometry);
                    this.properties = obj.properties;
                    return this;
                }
                coords = obj.coordinates;

                if (!Wkt.isArray(coords[0])) {
                    // Point
                    this.components.push({
                        x: coords[0],
                        y: coords[1]
                    });
                } else {

                    for (i in coords) {
                        if (coords.hasOwnProperty(i)) {

                            if (!Wkt.isArray(coords[i][0])) {
                                // LineString

                                if (this.type === 'multipoint') {
                                    // MultiPoint
                                    this.components.push([{
                                        x: coords[i][0],
                                        y: coords[i][1]
                                    }]);
                                } else {
                                    this.components.push({
                                        x: coords[i][0],
                                        y: coords[i][1]
                                    });
                                }
                            } else {

                                oring = [];
                                for (j in coords[i]) {
                                    if (coords[i].hasOwnProperty(j)) {

                                        if (!Wkt.isArray(coords[i][j][0])) {
                                            oring.push({
                                                x: coords[i][j][0],
                                                y: coords[i][j][1]
                                            });
                                        } else {

                                            iring = [];
                                            for (k in coords[i][j]) {
                                                if (coords[i][j].hasOwnProperty(k)) {

                                                    iring.push({
                                                        x: coords[i][j][k][0],
                                                        y: coords[i][j][k][1]
                                                    });
                                                }
                                            }

                                            oring.push(iring);
                                        }
                                    }
                                }

                                this.components.push(oring);
                            }
                        }
                    }
                }

                return this;
            };

            /**
             * Creates a JSON representation, with the GeoJSON schema, of the geometry.
             * @return    {Object}    The corresponding GeoJSON representation
             * @memberof Wkt.Wkt
             * @method
             */
            Wkt.Wkt.prototype.toJson = function () {
                var cs, json, i, j, k, ring, rings;

                cs = this.components;
                json = {
                    coordinates: [],
                    type: function () {
                        var i, type, s;

                        type = this.regExes.ogcTypes.exec(this.type).slice(1);
                        s = [];

                        for (i in type) {
                            if (type.hasOwnProperty(i)) {
                                if (type[i] !== undefined) {
                                    s.push(type[i].toLowerCase().slice(0, 1).toUpperCase() + type[i].toLowerCase().slice(1));
                                }
                            }
                        }

                        return s;
                    }.call(this).join(''

                    // Wkt BOX type gets a special bbox property in GeoJSON
                    ) };if (this.type.toLowerCase() === 'box') {
                    json.type = 'Polygon';
                    json.bbox = [];

                    for (i in cs) {
                        if (cs.hasOwnProperty(i)) {
                            json.bbox = json.bbox.concat([cs[i].x, cs[i].y]);
                        }
                    }

                    json.coordinates = [[[cs[0].x, cs[0].y], [cs[0].x, cs[1].y], [cs[1].x, cs[1].y], [cs[1].x, cs[0].y], [cs[0].x, cs[0].y]]];

                    return json;
                }

                // For the coordinates of most simple features
                for (i in cs) {
                    if (cs.hasOwnProperty(i)) {

                        // For those nested structures
                        if (Wkt.isArray(cs[i])) {
                            rings = [];

                            for (j in cs[i]) {
                                if (cs[i].hasOwnProperty(j)) {

                                    if (Wkt.isArray(cs[i][j])) {
                                        // MULTIPOLYGONS
                                        ring = [];

                                        for (k in cs[i][j]) {
                                            if (cs[i][j].hasOwnProperty(k)) {
                                                ring.push([cs[i][j][k].x, cs[i][j][k].y]);
                                            }
                                        }

                                        rings.push(ring);
                                    } else {
                                        // POLYGONS and MULTILINESTRINGS

                                        if (cs[i].length > 1) {
                                            rings.push([cs[i][j].x, cs[i][j].y]);
                                        } else {
                                            // MULTIPOINTS
                                            rings = rings.concat([cs[i][j].x, cs[i][j].y]);
                                        }
                                    }
                                }
                            }

                            json.coordinates.push(rings);
                        } else {
                            if (cs.length > 1) {
                                // For LINESTRING type
                                json.coordinates.push([cs[i].x, cs[i].y]);
                            } else {
                                // For POINT type
                                json.coordinates = json.coordinates.concat([cs[i].x, cs[i].y]);
                            }
                        }
                    }
                }

                return json;
            };

            /**
             * Absorbs the geometry of another Wkt.Wkt instance, merging it with its own,
             * creating a collection (MULTI-geometry) based on their types, which must agree.
             * For example, creates a MULTIPOLYGON from a POLYGON type merged with another
             * POLYGON type, or adds a POLYGON instance to a MULTIPOLYGON instance.
             * @param   wkt {String}    A Wkt.Wkt object
             * @return  {Wkt.Wkt}  The object itself
             * @memberof Wkt.Wkt
             * @method
             */
            Wkt.Wkt.prototype.merge = function (wkt) {
                var prefix = this.type.slice(0, 5);

                if (this.type !== wkt.type) {
                    if (this.type.slice(5, this.type.length) !== wkt.type) {
                        throw TypeError('The input geometry types must agree or the calling Wkt.Wkt instance must be a multigeometry of the other');
                    }
                }

                switch (prefix) {

                    case 'point':
                        this.components = [this.components.concat(wkt.components)];
                        break;

                    case 'multi':
                        this.components = this.components.concat(wkt.type.slice(0, 5) === 'multi' ? wkt.components : [wkt.components]);
                        break;

                    default:
                        this.components = [this.components, wkt.components];
                        break;

                }

                if (prefix !== 'multi') {
                    this.type = 'multi' + this.type;
                }
                return this;
            };

            /**
             * Reads a WKT string, validating and incorporating it.
             * @param   str {String}    A WKT or GeoJSON string
             * @return  {Wkt.Wkt}  The object itself
             * @memberof Wkt.Wkt
             * @method
             */
            Wkt.Wkt.prototype.read = function (str) {
                var matches;
                matches = this.regExes.typeStr.exec(str);
                if (matches) {
                    this.type = matches[1].toLowerCase();
                    this.base = matches[2];
                    if (this.ingest[this.type]) {
                        this.components = this.ingest[this.type].apply(this, [this.base]);
                    }
                } else {
                    if (this.regExes.crudeJson.test(str)) {
                        if (typeof JSON === 'object' && typeof JSON.parse === 'function') {
                            this.fromJson(JSON.parse(str));
                        } else {
                            console.log('JSON.parse() is not available; cannot parse GeoJSON strings');
                            throw {
                                name: 'JSONError',
                                message: 'JSON.parse() is not available; cannot parse GeoJSON strings'
                            };
                        }
                    } else {
                        console.log('Invalid WKT string provided to read() ', str);
                        throw {
                            name: 'WKTError',
                            message: 'Invalid WKT string provided to read()'
                        };
                    }
                }

                return this;
            }; // eo readWkt

            /**
             * Writes a WKT string.
             * @param   components  {Array}     An Array of internal geometry objects
             * @return              {String}    The corresponding WKT representation
             * @memberof Wkt.Wkt
             * @method
             */
            Wkt.Wkt.prototype.write = function (components) {
                var i, pieces, data;

                components = components || this.components;

                pieces = [];

                pieces.push(this.type.toUpperCase() + '(');

                for (i = 0; i < components.length; i += 1) {
                    if (this.isCollection() && i > 0) {
                        pieces.push(',');
                    }

                    // There should be an extract function for the named type
                    if (!this.extract[this.type]) {
                        return null;
                    }

                    data = this.extract[this.type].apply(this, [components[i]]);
                    if (this.isCollection() && this.type !== 'multipoint') {
                        pieces.push('(' + data + ')');
                    } else {
                        pieces.push(data);

                        // If not at the end of the components, add a comma
                        if (i !== components.length - 1 && this.type !== 'multipoint') {
                            pieces.push(',');
                        }
                    }
                }

                pieces.push(')');

                return pieces.join('');
            };

            /**
             * This object contains functions as property names that extract WKT
             * strings from the internal representation.
             * @memberof Wkt.Wkt
             * @namespace Wkt.Wkt.extract
             * @instance
             */
            Wkt.Wkt.prototype.extract = {
                /**
                 * Return a WKT string representing atomic (point) geometry
                 * @param   point   {Object}    An object with x and y properties
                 * @return          {String}    The WKT representation
                 * @memberof Wkt.Wkt.extract
                 * @instance
                 */
                point: function point(_point) {
                    return String(_point.x) + this.delimiter + String(_point.y);
                },

                /**
                 * Return a WKT string representing multiple atoms (points)
                 * @param   multipoint  {Array}     Multiple x-and-y objects
                 * @return              {String}    The WKT representation
                 * @memberof Wkt.Wkt.extract
                 * @instance
                 */
                multipoint: function multipoint(_multipoint) {
                    var i,
                        parts = [],
                        s;

                    for (i = 0; i < _multipoint.length; i += 1) {
                        s = this.extract.point.apply(this, [_multipoint[i]]);

                        if (this.wrapVertices) {
                            s = '(' + s + ')';
                        }

                        parts.push(s);
                    }

                    return parts.join(',');
                },

                /**
                 * Return a WKT string representing a chain (linestring) of atoms
                 * @param   linestring  {Array}     Multiple x-and-y objects
                 * @return              {String}    The WKT representation
                 * @memberof Wkt.Wkt.extract
                 * @instance
                 */
                linestring: function linestring(_linestring) {
                    // Extraction of linestrings is the same as for points
                    return this.extract.point.apply(this, [_linestring]);
                },

                /**
                 * Return a WKT string representing multiple chains (multilinestring) of atoms
                 * @param   multilinestring {Array}     Multiple of multiple x-and-y objects
                 * @return                  {String}    The WKT representation
                 * @memberof Wkt.Wkt.extract
                 * @instance
                 */
                multilinestring: function multilinestring(_multilinestring) {
                    var i,
                        parts = [];

                    if (_multilinestring.length) {
                        for (i = 0; i < _multilinestring.length; i += 1) {
                            parts.push(this.extract.linestring.apply(this, [_multilinestring[i]]));
                        }
                    } else {
                        parts.push(this.extract.point.apply(this, [_multilinestring]));
                    }

                    return parts.join(',');
                },

                /**
                 * Return a WKT string representing multiple atoms in closed series (polygon)
                 * @param   polygon {Array}     Collection of ordered x-and-y objects
                 * @return          {String}    The WKT representation
                 * @memberof Wkt.Wkt.extract
                 * @instance
                 */
                polygon: function polygon(_polygon) {
                    // Extraction of polygons is the same as for multilinestrings
                    return this.extract.multilinestring.apply(this, [_polygon]);
                },

                /**
                 * Return a WKT string representing multiple closed series (multipolygons) of multiple atoms
                 * @param   multipolygon    {Array}     Collection of ordered x-and-y objects
                 * @return                  {String}    The WKT representation
                 * @memberof Wkt.Wkt.extract
                 * @instance
                 */
                multipolygon: function multipolygon(_multipolygon) {
                    var i,
                        parts = [];
                    for (i = 0; i < _multipolygon.length; i += 1) {
                        parts.push('(' + this.extract.polygon.apply(this, [_multipolygon[i]]) + ')');
                    }
                    return parts.join(',');
                },

                /**
                 * Return a WKT string representing a 2DBox
                 * @param   multipolygon    {Array}     Collection of ordered x-and-y objects
                 * @return                  {String}    The WKT representation
                 * @memberof Wkt.Wkt.extract
                 * @instance
                 */
                box: function box(_box) {
                    return this.extract.linestring.apply(this, [_box]);
                },

                geometrycollection: function geometrycollection(str) {
                    console.log('The geometrycollection WKT type is not yet supported.');
                }
            };

            /**
             * This object contains functions as property names that ingest WKT
             * strings into the internal representation.
             * @memberof Wkt.Wkt
             * @namespace Wkt.Wkt.ingest
             * @instance
             */
            Wkt.Wkt.prototype.ingest = {

                /**
                 * Return point feature given a point WKT fragment.
                 * @param   str {String}    A WKT fragment representing the point
                 * @memberof Wkt.Wkt.ingest
                 * @instance
                 */
                point: function point(str) {
                    var coords = Wkt.trim(str).split(this.regExes.spaces);
                    // In case a parenthetical group of coordinates is passed...
                    return [{ // ...Search for numeric substrings
                        x: parseFloat(this.regExes.numeric.exec(coords[0])[0]),
                        y: parseFloat(this.regExes.numeric.exec(coords[1])[0])
                    }];
                },

                /**
                 * Return a multipoint feature given a multipoint WKT fragment.
                 * @param   str {String}    A WKT fragment representing the multipoint
                 * @memberof Wkt.Wkt.ingest
                 * @instance
                 */
                multipoint: function multipoint(str) {
                    var i, components, points;
                    components = [];
                    points = Wkt.trim(str).split(this.regExes.comma);
                    for (i = 0; i < points.length; i += 1) {
                        components.push(this.ingest.point.apply(this, [points[i]]));
                    }
                    return components;
                },

                /**
                 * Return a linestring feature given a linestring WKT fragment.
                 * @param   str {String}    A WKT fragment representing the linestring
                 * @memberof Wkt.Wkt.ingest
                 * @instance
                 */
                linestring: function linestring(str) {
                    var i, multipoints, components;

                    // In our x-and-y representation of components, parsing
                    //  multipoints is the same as parsing linestrings
                    multipoints = this.ingest.multipoint.apply(this, [str]);

                    // However, the points need to be joined
                    components = [];
                    for (i = 0; i < multipoints.length; i += 1) {
                        components = components.concat(multipoints[i]);
                    }
                    return components;
                },

                /**
                 * Return a multilinestring feature given a multilinestring WKT fragment.
                 * @param   str {String}    A WKT fragment representing the multilinestring
                 * @memberof Wkt.Wkt.ingest
                 * @instance
                 */
                multilinestring: function multilinestring(str) {
                    var i, components, line, lines;
                    components = [];

                    lines = Wkt.trim(str).split(this.regExes.doubleParenComma);
                    if (lines.length === 1) {
                        // If that didn't work...
                        lines = Wkt.trim(str).split(this.regExes.parenComma);
                    }

                    for (i = 0; i < lines.length; i += 1) {
                        line = lines[i].replace(this.regExes.trimParens, '$1');
                        components.push(this.ingest.linestring.apply(this, [line]));
                    }

                    return components;
                },

                /**
                 * Return a polygon feature given a polygon WKT fragment.
                 * @param   str {String}    A WKT fragment representing the polygon
                 * @memberof Wkt.Wkt.ingest
                 * @instance
                 */
                polygon: function polygon(str) {
                    var i, j, components, subcomponents, ring, rings;
                    rings = Wkt.trim(str).split(this.regExes.parenComma);
                    components = []; // Holds one or more rings
                    for (i = 0; i < rings.length; i += 1) {
                        ring = rings[i].replace(this.regExes.trimParens, '$1').split(this.regExes.comma);
                        subcomponents = []; // Holds the outer ring and any inner rings (holes)
                        for (j = 0; j < ring.length; j += 1) {
                            // Split on the empty space or '+' character (between coordinates)
                            var split = ring[j].split(this.regExes.spaces);
                            if (split.length > 2) {
                                //remove the elements which are blanks
                                split = split.filter(function (n) {
                                    return n != "";
                                });
                            }
                            if (split.length === 2) {
                                var x_cord = split[0];
                                var y_cord = split[1];

                                //now push
                                subcomponents.push({
                                    x: parseFloat(x_cord),
                                    y: parseFloat(y_cord)
                                });
                            }
                        }
                        components.push(subcomponents);
                    }
                    return components;
                },

                /**
                 * Return box vertices (which would become the Rectangle bounds) given a Box WKT fragment.
                 * @param   str {String}    A WKT fragment representing the box
                 * @memberof Wkt.Wkt.ingest
                 * @instance
                 */
                box: function box(str) {
                    var i, multipoints, components;

                    // In our x-and-y representation of components, parsing
                    //  multipoints is the same as parsing linestrings
                    multipoints = this.ingest.multipoint.apply(this, [str]);

                    // However, the points need to be joined
                    components = [];
                    for (i = 0; i < multipoints.length; i += 1) {
                        components = components.concat(multipoints[i]);
                    }

                    return components;
                },

                /**
                 * Return a multipolygon feature given a multipolygon WKT fragment.
                 * @param   str {String}    A WKT fragment representing the multipolygon
                 * @memberof Wkt.Wkt.ingest
                 * @instance
                 */
                multipolygon: function multipolygon(str) {
                    var i, components, polygon, polygons;
                    components = [];
                    polygons = Wkt.trim(str).split(this.regExes.doubleParenComma);
                    for (i = 0; i < polygons.length; i += 1) {
                        polygon = polygons[i].replace(this.regExes.trimParens, '$1');
                        components.push(this.ingest.polygon.apply(this, [polygon]));
                    }
                    return components;
                },

                /**
                 * Return an array of features given a geometrycollection WKT fragment.
                 * @param   str {String}    A WKT fragment representing the geometry collection
                 * @memberof Wkt.Wkt.ingest
                 * @instance
                 */
                geometrycollection: function geometrycollection(str) {
                    console.log('The geometrycollection WKT type is not yet supported.');
                }

            }; // eo ingest

            /**
             * @augments Wkt.Wkt
             * A framework-dependent flag, set for each Wkt.Wkt() instance, that indicates
             * whether or not a closed polygon geometry should be interpreted as a rectangle.
             */
            Wkt.Wkt.prototype.isRectangle = false;

            /**
             * @augments Wkt.Wkt
             * An object of framework-dependent construction methods used to generate
             * objects belonging to the various geometry classes of the framework.
             */
            Wkt.Wkt.prototype.construct = {
                /**
                 * Creates the framework's equivalent point geometry object.
                 * @param   config      {Object}    An optional properties hash the object should use
                 * @param   component   {Object}    An optional component to build from
                 * @return              {google.maps.Marker}
                 */
                point: function point(config, component) {
                    var c = component || this.components;

                    config = config || {
                        optimized: true
                    };

                    config.position = new google.maps.LatLng(c[0].y, c[0].x);

                    return new google.maps.Marker(config);
                },

                /**
                 * Creates the framework's equivalent multipoint geometry object.
                 * @param   config  {Object}    An optional properties hash the object should use
                 * @return          {Array}     Array containing multiple google.maps.Marker
                 */
                multipoint: function multipoint(config) {
                    var i, c, arr;

                    c = this.components;

                    config = config || {};

                    arr = [];

                    for (i = 0; i < c.length; i += 1) {
                        arr.push(this.construct.point(config, c[i]));
                    }

                    return arr;
                },

                /**
                 * Creates the framework's equivalent linestring geometry object.
                 * @param   config      {Object}    An optional properties hash the object should use
                 * @param   component   {Object}    An optional component to build from
                 * @return              {google.maps.Polyline}
                 */
                linestring: function linestring(config, component) {
                    var i, c;

                    c = component || this.components;

                    config = config || {
                        editable: false
                    };

                    config.path = [];

                    for (i = 0; i < c.length; i += 1) {
                        config.path.push(new google.maps.LatLng(c[i].y, c[i].x));
                    }

                    return new google.maps.Polyline(config);
                },

                /**
                 * Creates the framework's equivalent multilinestring geometry object.
                 * @param   config  {Object}    An optional properties hash the object should use
                 * @return          {Array}     Array containing multiple google.maps.Polyline instances
                 */
                multilinestring: function multilinestring(config) {
                    var i, c, arr;

                    c = this.components;

                    config = config || {
                        editable: false
                    };

                    config.path = [];

                    arr = [];

                    for (i = 0; i < c.length; i += 1) {
                        arr.push(this.construct.linestring(config, c[i]));
                    }

                    return arr;
                },

                /**
                 * Creates the framework's equivalent Box or Rectangle geometry object.
                 * @param   config      {Object}    An optional properties hash the object should use
                 * @param   component   {Object}    An optional component to build from
                 * @return              {google.maps.Rectangle}
                 */
                box: function box(config, component) {
                    var c = component || this.components;

                    config = config || {};

                    config.bounds = new google.maps.LatLngBounds(new google.maps.LatLng(c[0].y, c[0].x), new google.maps.LatLng(c[1].y, c[1].x));

                    return new google.maps.Rectangle(config);
                },

                /**
                 * Creates the framework's equivalent polygon geometry object.
                 * @param   config      {Object}    An optional properties hash the object should use
                 * @param   component   {Object}    An optional component to build from
                 * @return              {google.maps.Polygon}
                 */
                polygon: function polygon(config, component) {
                    var j, k, c, rings, verts;

                    c = component || this.components;

                    config = config || {
                        editable: false // Editable geometry off by default
                    };

                    config.paths = [];

                    rings = [];
                    for (j = 0; j < c.length; j += 1) {
                        // For each ring...

                        verts = [];
                        // NOTE: We iterate to one (1) less than the Array length to skip the last vertex
                        for (k = 0; k < c[j].length - 1; k += 1) {
                            // For each vertex...
                            verts.push(new google.maps.LatLng(c[j][k].y, c[j][k].x));
                        } // eo for each vertex

                        if (j !== 0) {
                            // Reverse the order of coordinates in inner rings
                            if (config.reverseInnerPolygons === null || config.reverseInnerPolygons) {
                                verts.reverse();
                            }
                        }

                        rings.push(verts);
                    } // eo for each ring

                    config.paths = config.paths.concat(rings);

                    if (this.isRectangle) {
                        return function () {
                            var bounds, v;

                            bounds = new google.maps.LatLngBounds();

                            for (v in rings[0]) {
                                // Ought to be only 1 ring in a Rectangle
                                if (rings[0].hasOwnProperty(v)) {
                                    bounds.extend(rings[0][v]);
                                }
                            }

                            return new google.maps.Rectangle({
                                bounds: bounds
                            });
                        }();
                    } else {
                        return new google.maps.Polygon(config);
                    }
                },

                /**
                 * Creates the framework's equivalent multipolygon geometry object.
                 * @param   config  {Object}    An optional properties hash the object should use
                 * @return          {Array}     Array containing multiple google.maps.Polygon
                 */
                multipolygon: function multipolygon(config) {
                    var i, c, arr;

                    c = this.components;

                    config = config || {
                        editable: false
                    };

                    config.path = [];

                    arr = [];

                    for (i = 0; i < c.length; i += 1) {
                        arr.push(this.construct.polygon(config, c[i]));
                    }

                    return arr;
                }

            };

            /**
             * @augments Wkt.Wkt
             * A framework-dependent deconstruction method used to generate internal
             * geometric representations from instances of framework geometry. This method
             * uses object detection to attempt to classify members of framework geometry
             * classes into the standard WKT types.
             * @param obj       {Object}    An instance of one of the framework's geometry classes
             * @param multiFlag {Boolean} If true, then the deconstructor will be forced to return a MultiGeometry (multipoint, multilinestring or multipolygon)
             * @return          {Object}    A hash of the 'type' and 'components' thus derived, plus the WKT string of the feature.
             */
            Wkt.Wkt.prototype.deconstruct = function (obj, multiFlag) {
                var features, i, j, verts, rings, sign, tmp, response, lat, lng, vertex, ring;
                var polygons, polygon, k, linestring, linestrings;
                // Shortcut to signed area function (determines clockwise vs counter-clock)
                if (google.maps.geometry) {
                    sign = google.maps.geometry.spherical.computeSignedArea;
                }

                // google.maps.LatLng //////////////////////////////////////////////////////
                if (obj.constructor === google.maps.LatLng) {

                    response = {
                        type: 'point',
                        components: [{
                            x: obj.lng(),
                            y: obj.lat()
                        }]
                    };
                    return response;
                }

                // google.maps.Point //////////////////////////////////////////////////////
                if (obj.constructor === google.maps.Point) {
                    response = {
                        type: 'point',
                        components: [{
                            x: obj.x,
                            y: obj.y
                        }]
                    };
                    return response;
                }

                // google.maps.Marker //////////////////////////////////////////////////////
                if (obj.constructor === google.maps.Marker) {
                    response = {
                        type: 'point',
                        components: [{
                            x: obj.getPosition().lng(),
                            y: obj.getPosition().lat()
                        }]
                    };
                    return response;
                }

                // google.maps.Polyline ////////////////////////////////////////////////////
                if (obj.constructor === google.maps.Polyline) {

                    verts = [];
                    for (i = 0; i < obj.getPath().length; i += 1) {
                        tmp = obj.getPath().getAt(i);
                        verts.push({
                            x: tmp.lng(),
                            y: tmp.lat()
                        });
                    }
                    response = {
                        type: 'linestring',
                        components: verts
                    };
                    return response;
                }

                // google.maps.Polygon /////////////////////////////////////////////////////
                if (obj.constructor === google.maps.Polygon) {

                    rings = [];

                    if (multiFlag === undefined) {
                        multiFlag = function () {
                            var areas, l;

                            l = obj.getPaths().length;
                            if (l <= 1) {
                                // Trivial; this is a single polygon
                                return false;
                            }

                            if (l === 2) {
                                // If clockwise*clockwise or counter*counter, i.e.
                                //  (-1)*(-1) or (1)*(1), then result would be positive
                                if (sign(obj.getPaths().getAt(0)) * sign(obj.getPaths().getAt(1)) < 0) {
                                    return false; // Most likely single polygon with 1 hole
                                }

                                return true;
                            }

                            // Must be longer than 3 polygons at this point...
                            areas = obj.getPaths().getArray().map(function (k) {
                                return sign(k) / Math.abs(sign(k)); // Unit normalization (outputs 1 or -1)
                            });

                            // If two clockwise or two counter-clockwise rings are found
                            //  (at different indices)...
                            if (areas.indexOf(areas[0]) !== areas.lastIndexOf(areas[0])) {
                                multiFlag = true; // Flag for holes in one or more polygons
                                return true;
                            }

                            return false;
                        }();
                    }

                    for (i = 0; i < obj.getPaths().length; i += 1) {
                        // For each polygon (ring)...
                        tmp = obj.getPaths().getAt(i);
                        verts = [];
                        for (j = 0; j < obj.getPaths().getAt(i).length; j += 1) {
                            // For each vertex...
                            verts.push({
                                x: tmp.getAt(j).lng(),
                                y: tmp.getAt(j).lat()
                            });
                        }

                        if (!tmp.getAt(tmp.length - 1).equals(tmp.getAt(0))) {
                            if (i % 2 !== 0) {
                                // In inner rings, coordinates are reversed...
                                verts.unshift({ // Add the first coordinate again for closure
                                    x: tmp.getAt(tmp.length - 1).lng(),
                                    y: tmp.getAt(tmp.length - 1).lat()
                                });
                            } else {
                                verts.push({ // Add the first coordinate again for closure
                                    x: tmp.getAt(0).lng(),
                                    y: tmp.getAt(0).lat()
                                });
                            }
                        }

                        if (obj.getPaths().length > 1 && i > 0) {
                            // If this and the last ring have the same signs...
                            if (sign(obj.getPaths().getAt(i)) > 0 && sign(obj.getPaths().getAt(i - 1)) > 0 || sign(obj.getPaths().getAt(i)) < 0 && sign(obj.getPaths().getAt(i - 1)) < 0 && !multiFlag) {
                                // ...They must both be inner rings (or both be outer rings, in a multipolygon)
                                verts = [verts]; // Wrap multipolygons once more (collection)
                            }
                        }

                        //TODO This makes mistakes when a second polygon has holes; it sees them all as individual polygons
                        if (i % 2 !== 0) {
                            // In inner rings, coordinates are reversed...
                            verts.reverse();
                        }
                        rings.push(verts);
                    }

                    response = {
                        type: multiFlag ? 'multipolygon' : 'polygon',
                        components: rings
                    };
                    return response;
                }

                // google.maps.Circle //////////////////////////////////////////////////////
                if (obj.constructor === google.maps.Circle) {
                    var point = obj.getCenter();
                    var radius = obj.getRadius();
                    verts = [];
                    var d2r = Math.PI / 180; // degrees to radians
                    var r2d = 180 / Math.PI; // radians to degrees
                    radius = radius / 1609; // meters to miles
                    var earthsradius = 3963; // 3963 is the radius of the earth in miles
                    var num_seg = 32; // number of segments used to approximate a circle
                    var rlat = radius / earthsradius * r2d;
                    var rlng = rlat / Math.cos(point.lat() * d2r);

                    for (var n = 0; n <= num_seg; n++) {
                        var theta = Math.PI * (n / (num_seg / 2));
                        lng = point.lng() + rlng * Math.cos(theta); // center a + radius x * cos(theta)
                        lat = point.lat() + rlat * Math.sin(theta); // center b + radius y * sin(theta)
                        verts.push({
                            x: lng,
                            y: lat
                        });
                    }

                    response = {
                        type: 'polygon',
                        components: [verts]
                    };

                    return response;
                }

                // google.maps.LatLngBounds ///////////////////////////////////////////////////
                if (obj.constructor === google.maps.LatLngBounds) {

                    tmp = obj;
                    verts = [];
                    verts.push({ // NW corner
                        x: tmp.getSouthWest().lng(),
                        y: tmp.getNorthEast().lat()
                    });

                    verts.push({ // NE corner
                        x: tmp.getNorthEast().lng(),
                        y: tmp.getNorthEast().lat()
                    });

                    verts.push({ // SE corner
                        x: tmp.getNorthEast().lng(),
                        y: tmp.getSouthWest().lat()
                    });

                    verts.push({ // SW corner
                        x: tmp.getSouthWest().lng(),
                        y: tmp.getSouthWest().lat()
                    });

                    verts.push({ // NW corner (again, for closure)
                        x: tmp.getSouthWest().lng(),
                        y: tmp.getNorthEast().lat()
                    });

                    response = {
                        type: 'polygon',
                        isRectangle: true,
                        components: [verts]
                    };

                    return response;
                }

                // google.maps.Rectangle ///////////////////////////////////////////////////
                if (obj.constructor === google.maps.Rectangle) {

                    tmp = obj.getBounds();
                    verts = [];
                    verts.push({ // NW corner
                        x: tmp.getSouthWest().lng(),
                        y: tmp.getNorthEast().lat()
                    });

                    verts.push({ // NE corner
                        x: tmp.getNorthEast().lng(),
                        y: tmp.getNorthEast().lat()
                    });

                    verts.push({ // SE corner
                        x: tmp.getNorthEast().lng(),
                        y: tmp.getSouthWest().lat()
                    });

                    verts.push({ // SW corner
                        x: tmp.getSouthWest().lng(),
                        y: tmp.getSouthWest().lat()
                    });

                    verts.push({ // NW corner (again, for closure)
                        x: tmp.getSouthWest().lng(),
                        y: tmp.getNorthEast().lat()
                    });

                    response = {
                        type: 'polygon',
                        isRectangle: true,
                        components: [verts]
                    };

                    return response;
                }

                // google.maps.Data Geometry Types /////////////////////////////////////////////////////

                // google.maps.Data.Feature /////////////////////////////////////////////////////
                if (obj.constructor === google.maps.Data.Feature) {
                    return this.deconstruct.call(this, obj.getGeometry());
                }

                // google.maps.Data.Point /////////////////////////////////////////////////////
                if (obj.constructor === google.maps.Data.Point) {
                    //console.zlog('It is a google.maps.Data.Point');
                    response = {
                        type: 'point',
                        components: [{
                            x: obj.get().lng(),
                            y: obj.get().lat()
                        }]
                    };
                    return response;
                }

                // google.maps.Data.LineString /////////////////////////////////////////////////////
                if (obj.constructor === google.maps.Data.LineString) {
                    verts = [];
                    //console.zlog('It is a google.maps.Data.LineString');
                    for (i = 0; i < obj.getLength(); i += 1) {
                        vertex = obj.getAt(i);
                        verts.push({
                            x: vertex.lng(),
                            y: vertex.lat()
                        });
                    }
                    response = {
                        type: 'linestring',
                        components: verts
                    };
                    return response;
                }

                // google.maps.Data.Polygon /////////////////////////////////////////////////////
                if (obj.constructor === google.maps.Data.Polygon) {
                    rings = [];
                    //console.zlog('It is a google.maps.Data.Polygon');
                    for (i = 0; i < obj.getLength(); i += 1) {
                        // For each ring...
                        ring = obj.getAt(i);
                        verts = [];
                        for (j = 0; j < ring.getLength(); j += 1) {
                            // For each vertex...
                            vertex = ring.getAt(j);
                            verts.push({
                                x: vertex.lng(),
                                y: vertex.lat()
                            });
                        }
                        verts.push({
                            x: ring.getAt(0).lng(),
                            y: ring.getAt(0).lat()
                        });

                        rings.push(verts);
                    }
                    response = {
                        type: 'polygon',
                        components: rings
                    };

                    return response;
                }

                // google.maps.Data.MultiPoint /////////////////////////////////////////////////////
                if (obj.constructor === google.maps.Data.MultiPoint) {
                    verts = [];
                    for (i = 0; i < obj.getLength(); i += 1) {
                        vertex = obj.getAt(i);
                        verts.push([{
                            x: vertex.lng(),
                            y: vertex.lat()
                        }]);
                    }
                    response = {
                        type: 'multipoint',
                        components: verts
                    };
                    return response;
                }

                // google.maps.Data.MultiLineString /////////////////////////////////////////////////////
                if (obj.constructor === google.maps.Data.MultiLineString) {
                    linestrings = [];
                    for (i = 0; i < obj.getLength(); i += 1) {
                        verts = [];
                        linestring = obj.getAt(i);
                        for (j = 0; j < linestring.getLength(); j += 1) {
                            vertex = linestring.getAt(j);
                            verts.push({
                                x: vertex.lng(),
                                y: vertex.lat()
                            });
                        }
                        linestrings.push(verts);
                    }
                    response = {
                        type: 'multilinestring',
                        components: linestrings
                    };
                    return response;
                }

                // google.maps.Data.MultiPolygon /////////////////////////////////////////////////////
                if (obj.constructor === google.maps.Data.MultiPolygon) {

                    polygons = [];

                    //console.zlog('It is a google.maps.Data.MultiPolygon');
                    for (k = 0; k < obj.getLength(); k += 1) {
                        // For each multipolygon
                        polygon = obj.getAt(k);
                        rings = [];
                        for (i = 0; i < polygon.getLength(); i += 1) {
                            // For each ring...
                            ring = polygon.getAt(i);
                            verts = [];
                            for (j = 0; j < ring.getLength(); j += 1) {
                                // For each vertex...
                                vertex = ring.getAt(j);
                                verts.push({
                                    x: vertex.lng(),
                                    y: vertex.lat()
                                });
                            }
                            verts.push({
                                x: ring.getAt(0).lng(),
                                y: ring.getAt(0).lat()
                            });

                            rings.push(verts);
                        }
                        polygons.push(rings);
                    }

                    response = {
                        type: 'multipolygon',
                        components: polygons
                    };
                    return response;
                }

                // google.maps.Data.GeometryCollection /////////////////////////////////////////////////////
                if (obj.constructor === google.maps.Data.GeometryCollection) {

                    var objects = [];
                    for (k = 0; k < obj.getLength(); k += 1) {
                        // For each multipolygon
                        var object = obj.getAt(k);
                        objects.push(this.deconstruct.call(this, object));
                    }
                    //console.zlog('It is a google.maps.Data.GeometryCollection', objects);
                    response = {
                        type: 'geometrycollection',
                        components: objects
                    };
                    return response;
                }

                // Array ///////////////////////////////////////////////////////////////////
                if (Wkt.isArray(obj)) {
                    features = [];

                    for (i = 0; i < obj.length; i += 1) {
                        features.push(this.deconstruct.call(this, obj[i], true));
                    }

                    response = {

                        type: function () {
                            var k,
                                type = obj[0].constructor;

                            for (k = 0; k < obj.length; k += 1) {
                                // Check that all items have the same constructor as the first item
                                if (obj[k].constructor !== type) {
                                    // If they don't, type is heterogeneous geometry collection
                                    return 'geometrycollection';
                                }
                            }

                            switch (type) {
                                case google.maps.Marker:
                                    return 'multipoint';
                                case google.maps.Polyline:
                                    return 'multilinestring';
                                case google.maps.Polygon:
                                    return 'multipolygon';
                                default:
                                    return 'geometrycollection';
                            }
                        }(),
                        components: function () {
                            // Pluck the components from each Wkt
                            var i, comps;

                            comps = [];
                            for (i = 0; i < features.length; i += 1) {
                                if (features[i].components) {
                                    comps.push(features[i].components);
                                }
                            }

                            return {
                                comps: comps
                            };
                        }()

                    };
                    response.components = response.components.comps;
                    return response;
                }

                console.warn('The passed object does not have any recognizable properties.');
            };arrayProto = Array.prototype;
            splice = arrayProto.splice;
            ListCache.prototype.clear = listCacheClear;
            ListCache.prototype['delete'] = listCacheDelete;
            ListCache.prototype.get = listCacheGet;
            ListCache.prototype.has = listCacheHas;
            ListCache.prototype.set = listCacheSet;freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
            freeSelf = typeof self == 'object' && self && self.Object === Object && self;
            root = freeGlobal || freeSelf || Function('return this')();
            Symbol = root.Symbol;
            objectProto$1 = Object.prototype;
            hasOwnProperty$1 = objectProto$1.hasOwnProperty;
            nativeObjectToString = objectProto$1.toString;
            symToStringTag$1 = Symbol ? Symbol.toStringTag : undefined;
            objectProto$2 = Object.prototype;
            nativeObjectToString$1 = objectProto$2.toString;
            nullTag = '[object Null]';
            undefinedTag = '[object Undefined]';
            symToStringTag = Symbol ? Symbol.toStringTag : undefined;
            asyncTag = '[object AsyncFunction]';
            funcTag = '[object Function]';
            genTag = '[object GeneratorFunction]';
            proxyTag = '[object Proxy]';
            coreJsData = root['__core-js_shared__'];

            maskSrcKey = function () {
                var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
                return uid ? 'Symbol(src)_1.' + uid : '';
            }();

            funcProto$1 = Function.prototype;
            funcToString$1 = funcProto$1.toString;
            reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
            reIsHostCtor = /^\[object .+?Constructor\]$/;
            funcProto = Function.prototype;
            objectProto = Object.prototype;
            funcToString = funcProto.toString;
            hasOwnProperty = objectProto.hasOwnProperty;
            reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
            Map = getNative(root, 'Map');
            nativeCreate = getNative(Object, 'create');
            HASH_UNDEFINED = '__lodash_hash_undefined__';
            objectProto$3 = Object.prototype;
            hasOwnProperty$2 = objectProto$3.hasOwnProperty;
            objectProto$4 = Object.prototype;
            hasOwnProperty$3 = objectProto$4.hasOwnProperty;
            HASH_UNDEFINED$1 = '__lodash_hash_undefined__';
            Hash.prototype.clear = hashClear;
            Hash.prototype['delete'] = hashDelete;
            Hash.prototype.get = hashGet;
            Hash.prototype.has = hashHas;
            Hash.prototype.set = hashSet;MapCache.prototype.clear = mapCacheClear;
            MapCache.prototype['delete'] = mapCacheDelete;
            MapCache.prototype.get = mapCacheGet;
            MapCache.prototype.has = mapCacheHas;
            MapCache.prototype.set = mapCacheSet;

            /** Used as the size to enable large array optimizations. */
            LARGE_ARRAY_SIZE = 200;
            Stack.prototype.clear = stackClear;
            Stack.prototype['delete'] = stackDelete;
            Stack.prototype.get = stackGet;
            Stack.prototype.has = stackHas;
            Stack.prototype.set = stackSet;

            /** Used to stand-in for `undefined` hash values. */
            HASH_UNDEFINED$2 = '__lodash_hash_undefined__';
            SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
            SetCache.prototype.has = setCacheHas;COMPARE_PARTIAL_FLAG$2 = 1;
            COMPARE_UNORDERED_FLAG$1 = 2;
            Uint8Array = root.Uint8Array;
            COMPARE_PARTIAL_FLAG$3 = 1;
            COMPARE_UNORDERED_FLAG$2 = 2;
            boolTag = '[object Boolean]';
            dateTag = '[object Date]';
            errorTag = '[object Error]';
            mapTag = '[object Map]';
            numberTag = '[object Number]';
            regexpTag = '[object RegExp]';
            setTag = '[object Set]';
            stringTag = '[object String]';
            symbolTag = '[object Symbol]';
            arrayBufferTag = '[object ArrayBuffer]';
            dataViewTag = '[object DataView]';
            symbolProto = Symbol ? Symbol.prototype : undefined;
            symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
            isArray = Array.isArray;
            objectProto$7 = Object.prototype;
            propertyIsEnumerable = objectProto$7.propertyIsEnumerable;
            nativeGetSymbols = Object.getOwnPropertySymbols;
            getSymbols = !nativeGetSymbols ? stubArray : function (object) {
                if (object == null) {
                    return [];
                }
                object = Object(object);
                return arrayFilter(nativeGetSymbols(object), function (symbol) {
                    return propertyIsEnumerable.call(object, symbol);
                });
            };
            argsTag$1 = '[object Arguments]';
            objectProto$9 = Object.prototype;
            hasOwnProperty$7 = objectProto$9.hasOwnProperty;
            propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;
            isArguments = baseIsArguments(function () {
                return arguments;
            }()) ? baseIsArguments : function (value) {
                return isObjectLike(value) && hasOwnProperty$7.call(value, 'callee') && !propertyIsEnumerable$1.call(value, 'callee');
            };
            freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
            freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
            moduleExports = freeModule && freeModule.exports === freeExports;
            Buffer = moduleExports ? root.Buffer : undefined;
            nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
            isBuffer = nativeIsBuffer || stubFalse;
            MAX_SAFE_INTEGER = 9007199254740991;
            reIsUint = /^(?:0|[1-9]\d*)$/;
            MAX_SAFE_INTEGER$1 = 9007199254740991;
            argsTag$2 = '[object Arguments]';
            arrayTag$1 = '[object Array]';
            boolTag$1 = '[object Boolean]';
            dateTag$1 = '[object Date]';
            errorTag$1 = '[object Error]';
            funcTag$1 = '[object Function]';
            mapTag$1 = '[object Map]';
            numberTag$1 = '[object Number]';
            objectTag$1 = '[object Object]';
            regexpTag$1 = '[object RegExp]';
            setTag$1 = '[object Set]';
            stringTag$1 = '[object String]';
            weakMapTag = '[object WeakMap]';
            arrayBufferTag$1 = '[object ArrayBuffer]';
            dataViewTag$1 = '[object DataView]';
            float32Tag = '[object Float32Array]';
            float64Tag = '[object Float64Array]';
            int8Tag = '[object Int8Array]';
            int16Tag = '[object Int16Array]';
            int32Tag = '[object Int32Array]';
            uint8Tag = '[object Uint8Array]';
            uint8ClampedTag = '[object Uint8ClampedArray]';
            uint16Tag = '[object Uint16Array]';
            uint32Tag = '[object Uint32Array]';
            typedArrayTags = {};

            typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
            typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$1] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$1] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$1] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$1] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag] = false;freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;
            freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;
            moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
            freeProcess = moduleExports$1 && freeGlobal.process;

            nodeUtil = function () {
                try {
                    return freeProcess && freeProcess.binding && freeProcess.binding('util');
                } catch (e) {}
            }();

            nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
            isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
            objectProto$8 = Object.prototype;
            hasOwnProperty$6 = objectProto$8.hasOwnProperty;
            objectProto$11 = Object.prototype;
            nativeKeys = overArg(Object.keys, Object);
            objectProto$10 = Object.prototype;
            hasOwnProperty$8 = objectProto$10.hasOwnProperty;
            COMPARE_PARTIAL_FLAG$4 = 1;
            objectProto$6 = Object.prototype;
            hasOwnProperty$5 = objectProto$6.hasOwnProperty;
            DataView = getNative(root, 'DataView');
            Promise = getNative(root, 'Promise');
            Set = getNative(root, 'Set');
            WeakMap = getNative(root, 'WeakMap');
            mapTag$2 = '[object Map]';
            objectTag$2 = '[object Object]';
            promiseTag = '[object Promise]';
            setTag$2 = '[object Set]';
            weakMapTag$1 = '[object WeakMap]';
            dataViewTag$2 = '[object DataView]';
            dataViewCtorString = toSource(DataView);
            mapCtorString = toSource(Map);
            promiseCtorString = toSource(Promise);
            setCtorString = toSource(Set);
            weakMapCtorString = toSource(WeakMap);
            getTag = baseGetTag;


            // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
            if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$2 || Map && getTag(new Map()) != mapTag$2 || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag$2 || WeakMap && getTag(new WeakMap()) != weakMapTag$1) {
                getTag = function getTag(value) {
                    var result = baseGetTag(value),
                        Ctor = result == objectTag$2 ? value.constructor : undefined,
                        ctorString = Ctor ? toSource(Ctor) : '';

                    if (ctorString) {
                        switch (ctorString) {
                            case dataViewCtorString:
                                return dataViewTag$2;
                            case mapCtorString:
                                return mapTag$2;
                            case promiseCtorString:
                                return promiseTag;
                            case setCtorString:
                                return setTag$2;
                            case weakMapCtorString:
                                return weakMapTag$1;
                        }
                    }
                    return result;
                };
            }

            getTag$1 = getTag;
            COMPARE_PARTIAL_FLAG$1 = 1;
            argsTag = '[object Arguments]';
            arrayTag = '[object Array]';
            objectTag = '[object Object]';
            objectProto$5 = Object.prototype;
            hasOwnProperty$4 = objectProto$5.hasOwnProperty;
            COMPARE_PARTIAL_FLAG = 1;
            COMPARE_UNORDERED_FLAG = 2;
            symbolTag$1 = '[object Symbol]';
            reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
            reIsPlainProp = /^\w*$/;
            FUNC_ERROR_TEXT = 'Expected a function';
            memoize.Cache = MapCache;

            /** Used as the maximum memoize cache size. */
            MAX_MEMOIZE_SIZE = 500;
            reLeadingDot = /^\./;
            rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
            reEscapeChar = /\\(\\)?/g;
            stringToPath = memoizeCapped(function (string) {
                var result = [];
                if (reLeadingDot.test(string)) {
                    result.push('');
                }
                string.replace(rePropName, function (match, number, quote, string) {
                    result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
                });
                return result;
            });
            INFINITY = 1 / 0;
            symbolProto$1 = Symbol ? Symbol.prototype : undefined;
            symbolToString = symbolProto$1 ? symbolProto$1.toString : undefined;
            INFINITY$1 = 1 / 0;
            COMPARE_PARTIAL_FLAG$5 = 1;
            COMPARE_UNORDERED_FLAG$3 = 2;
            baseFor = createBaseFor();
            baseEach = createBaseEach(baseForOwn);
            rsAstralRange$1 = '\\ud800-\\udfff';
            rsComboMarksRange$1 = '\\u0300-\\u036f';
            reComboHalfMarksRange$1 = '\\ufe20-\\ufe2f';
            rsComboSymbolsRange$1 = '\\u20d0-\\u20ff';
            rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
            rsVarRange$1 = '\\ufe0e\\ufe0f';
            rsAstral = '[' + rsAstralRange$1 + ']';
            rsCombo = '[' + rsComboRange$1 + ']';
            rsFitz = '\\ud83c[\\udffb-\\udfff]';
            rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')';
            rsNonAstral = '[^' + rsAstralRange$1 + ']';
            rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}';
            rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]';
            rsZWJ$1 = '\\u200d';
            reOptMod = rsModifier + '?';
            rsOptVar = '[' + rsVarRange$1 + ']?';
            rsOptJoin = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*';
            rsSeq = rsOptVar + reOptMod + rsOptJoin;
            rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
            reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
            turf_linestring = turf_helpers.lineString;
            debug = console.debug.bind(console, '%c turfHelper' + ':', "color:#00CC00;font-weight:bold;");
            warn = console.debug.bind(console, '%c turfHelper' + ':', "color:orange;font-weight:bold;");
            turf_linestring$1 = turf_helpers.lineString;
            turf_linestring$2 = turf_helpers.lineString;
            turf_point = turf_helpers.point;
            turf_linestring$3 = turf_helpers.lineString;
            turf_featurecollection = turf_helpers.featureCollection;
            ig_turfhelper = {
                along: along,
                arrayToFeaturePoints: arrayToFeaturePoints,
                createbuffer: createbuffer,
                pointInPolygon: pointInPolygon,
                polygonToFeaturePolygon: polygonToFeaturePolygon,
                polylineToFeatureLinestring: polylineToFeatureLinestring,
                simplifyFeature: simplifyFeature,
                simplifyPointArray: simplifyPointArray,
                toLatLngs: toLatLngs,
                toCoords: toCoords,
                trimPaths: trimPaths,
                union: union,
                kinks: kinks,
                unkink: unkink,
                concave: concave
            };

            _export('along', along);

            _export('arrayToFeaturePoints', arrayToFeaturePoints);

            _export('createbuffer', createbuffer);

            _export('pointInPolygon', pointInPolygon);

            _export('polygonToFeaturePolygon', polygonToFeaturePolygon);

            _export('polylineToFeatureLinestring', polylineToFeatureLinestring);

            _export('simplifyFeature', simplifyFeature);

            _export('simplifyPointArray', simplifyPointArray);

            _export('toLatLngs', toLatLngs);

            _export('toCoords', toCoords);

            _export('trimPaths', trimPaths);

            _export('kinks', kinks);

            _export('unkink', unkink);

            _export('union', union);

            _export('concave', concave);

            _export('default', ig_turfhelper);
        }
    };
});
})
(function(factory) {
  if (typeof define == 'function' && define.amd)
    define([], factory);
  else if (typeof module == 'object' && module.exports && typeof require == 'function')
    module.exports = factory();
  else
    turfHelper = factory();
});